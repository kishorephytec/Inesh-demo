###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:52:57
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\ring_buf\ring_buf.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\ring_buf_11661336123597384382.dir\ring_buf.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\ring_buf\ring_buf.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\ring_buf_11661336123597384382.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\ring_buf_11661336123597384382.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\ring_buf\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\ring_buf_11661336123597384382.dir\ring_buf.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\ring_buf_11661336123597384382.dir\ring_buf.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\ring_buf_11661336123597384382.dir\ring_buf.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\ring_buf\ring_buf.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Common - Ring Buffer Data Structure
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                               INCLUDE FILES
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <em_core.h>
     25          
     26          #include  <common/source/ring_buf/ring_buf_priv.h>
     27          #include  <common/source/rtos/rtos_utils_priv.h>
     28          #include  <common/source/kal/kal_priv.h>
     29          
     30          /********************************************************************************************************
     31           ********************************************************************************************************
     32           *                                               LOCAL DEFINES
     33           ********************************************************************************************************
     34           *******************************************************************************************************/
     35          
     36          #define  RING_BUF_IX_SIZE_BYTES             2u
     37          
     38          #define  LOG_DFLT_CH                       (COMMON, RING_BUF)
     39          #define  RTOS_MODULE_CUR                    RTOS_CFG_MODULE_COMMON
     40          
     41          /********************************************************************************************************
     42           ********************************************************************************************************
     43           *                                       LOCAL FUNCTION PROTOTYPES
     44           ********************************************************************************************************
     45           *******************************************************************************************************/
     46          
     47          static void RingBufRdIxNextRefresh(RING_BUF *p_ring_buf);
     48          
     49          /********************************************************************************************************
     50           ********************************************************************************************************
     51           *                                           GLOBAL FUNCTIONS
     52           ********************************************************************************************************
     53           *******************************************************************************************************/
     54          
     55          /****************************************************************************************************//**
     56           *                                               RingBufCreate()
     57           *
     58           * @brief    Create and initializes a ring buffer.
     59           *
     60           * @param    p_ring_buf  Pointer to ring buffer structure to use.
     61           *
     62           * @param    p_mem_seg   Pointer to memory segment to use to allocate buffer. If DEF_NULL, the LIB Mem
     63           *                       heap will be used.
     64           *
     65           * @param    buf_size    Size of the ring buffer, in bytes.
     66           *
     67           * @param    p_err       Pointer to variable that will receive the return error code from this function :
     68           *                           - RTOS_ERR_NONE
     69           *                           - RTOS_ERR_SEG_OVF
     70           *
     71           * @note     (1) Buffer size must be at least 128 bytes and less than 32767 bytes.
     72           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     73          void RingBufCreate(RING_BUF   *p_ring_buf,
     74                             MEM_SEG    *p_mem_seg,
     75                             CPU_INT16U buf_size,
     76                             RTOS_ERR   *p_err)
     77          {
   \                     RingBufCreate: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
     78            RTOS_ASSERT_DBG_ERR_SET((buf_size >= 128u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x2880             CMP      R0,#+128
   \       0x10   0xD208             BCS.N    ??RingBufCreate_0
   \       0x12   0x2008             MOVS     R0,#+8
   \       0x14   0x7038             STRB     R0,[R7, #+0]
   \       0x16   0x....             LDR.N    R0,??DataTable0
   \       0x18   0x6078             STR      R0,[R7, #+4]
   \       0x1A   0x204E             MOVS     R0,#+78
   \       0x1C   0x60B8             STR      R0,[R7, #+8]
   \       0x1E   0x....             LDR.N    R0,??DataTable0_1
   \       0x20   0x60F8             STR      R0,[R7, #+12]
   \                     ??RingBufCreate_1: (+1)
   \       0x22   0xE7FE             B.N      ??RingBufCreate_1
     79            RTOS_ASSERT_DBG_ERR_SET((buf_size < 32767u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??RingBufCreate_0: (+1)
   \       0x24   0x0031             MOVS     R1,R6
   \       0x26   0xB289             UXTH     R1,R1
   \       0x28   0xF647 0x70FF      MOVW     R0,#+32767
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD308             BCC.N    ??RingBufCreate_2
   \       0x30   0x2008             MOVS     R0,#+8
   \       0x32   0x7038             STRB     R0,[R7, #+0]
   \       0x34   0x....             LDR.N    R0,??DataTable0
   \       0x36   0x6078             STR      R0,[R7, #+4]
   \       0x38   0x204F             MOVS     R0,#+79
   \       0x3A   0x60B8             STR      R0,[R7, #+8]
   \       0x3C   0x....             LDR.N    R0,??DataTable0_1
   \       0x3E   0x60F8             STR      R0,[R7, #+12]
   \                     ??RingBufCreate_3: (+1)
   \       0x40   0xE7FE             B.N      ??RingBufCreate_3
     80          
     81            p_ring_buf->StartPtr = (CPU_INT08U *)Mem_SegAlloc("Ring Buf Data",
     82                                                              p_mem_seg,
     83                                                              buf_size,
     84                                                              p_err);
   \                     ??RingBufCreate_2: (+1)
   \       0x42   0x003B             MOVS     R3,R7
   \       0x44   0x0032             MOVS     R2,R6
   \       0x46   0xB292             UXTH     R2,R2
   \       0x48   0x0029             MOVS     R1,R5
   \       0x4A   0x....             LDR.N    R0,??DataTable0_2
   \       0x4C   0x.... 0x....      BL       Mem_SegAlloc
   \       0x50   0x6020             STR      R0,[R4, #+0]
     85            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x52   0x7838             LDRB     R0,[R7, #+0]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD118             BNE.N    ??RingBufCreate_4
     86              return;
     87            }
     88          
     89            p_ring_buf->Size = buf_size;
   \                     ??RingBufCreate_5: (+1)
   \       0x58   0x0030             MOVS     R0,R6
   \       0x5A   0xB280             UXTH     R0,R0
   \       0x5C   0x6060             STR      R0,[R4, #+4]
     90            p_ring_buf->RdIx = 0u;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x8120             STRH     R0,[R4, #+8]
     91            p_ring_buf->RdIxNext = 0u;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x8160             STRH     R0,[R4, #+10]
     92            p_ring_buf->WrIx = 0u;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x81A0             STRH     R0,[R4, #+12]
     93            p_ring_buf->WrIxPrev = 0u;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x81E0             STRH     R0,[R4, #+14]
     94            p_ring_buf->EndValidIx = 0u;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x8220             STRH     R0,[R4, #+16]
     95            p_ring_buf->IsReading = DEF_NO;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x74A0             STRB     R0,[R4, #+18]
     96            p_ring_buf->RdIxDirty = DEF_NO;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x74E0             STRB     R0,[R4, #+19]
     97          
     98            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x7038             STRB     R0,[R7, #+0]
   \       0x7E   0x....             LDR.N    R0,??DataTable0
   \       0x80   0x6078             STR      R0,[R7, #+4]
   \       0x82   0x2062             MOVS     R0,#+98
   \       0x84   0x60B8             STR      R0,[R7, #+8]
   \       0x86   0x....             LDR.N    R0,??DataTable0_1
   \       0x88   0x60F8             STR      R0,[R7, #+12]
     99          
    100            return;
   \                     ??RingBufCreate_4: (+1)
   \       0x8A   0xBDF1             POP      {R0,R4-R7,PC}
    101          }
    102          
    103          /****************************************************************************************************//**
    104           *                                               RingBufWrAlloc()
    105           *
    106           * @brief    Allocate space to write data in the ring buffer.
    107           *
    108           * @param    p_ring_buf  Pointer to ring buffer structure to use.
    109           *
    110           * @param    size        Size to allocate, in bytes. MUST be greater than 0.
    111           *
    112           * @return   Pointer to buffer location where to write, if NO error(s),
    113           *           DEF_NULL,                                  otherwise.
    114           *
    115           * @note     (1) This function MUST be called from a CRITICAL SECTION, the same in which the call to
    116           *               RingBufWrCommit() will be done.
    117           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    118          void *RingBufWrAlloc(RING_BUF   *p_ring_buf,
    119                               CPU_INT16U size)
    120          {
   \                     RingBufWrAlloc: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
    121            CPU_INT32U wr_size = size + RING_BUF_IX_SIZE_BYTES;           // Account for ix, at end of packet.
   \        0x4   0x000B             MOVS     R3,R1
   \        0x6   0xB29B             UXTH     R3,R3
   \        0x8   0x1C9B             ADDS     R3,R3,#+2
    122          
    123            //                                                               Make sure ring buf has been created.
    124            if (RING_BUF_IS_NULL(p_ring_buf) == DEF_YES) {
   \        0xA   0x6810             LDR      R0,[R2, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??RingBufWrAlloc_0
    125              return (DEF_NULL);
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE036             B.N      ??RingBufWrAlloc_1
    126            }
    127          
    128            RTOS_ASSERT_DBG((size > 0u), RTOS_ERR_INVALID_ARG, DEF_NULL);
   \                     ??RingBufWrAlloc_0: (+1)
   \       0x14   0x0008             MOVS     R0,R1
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD100             BNE.N    ??RingBufWrAlloc_2
   \                     ??RingBufWrAlloc_3: (+1)
   \       0x1C   0xE7FE             B.N      ??RingBufWrAlloc_3
    129            RTOS_ASSERT_DBG((wr_size <= p_ring_buf->Size), RTOS_ERR_INVALID_ARG, DEF_NULL);
   \                     ??RingBufWrAlloc_2: (+1)
   \       0x1E   0x6850             LDR      R0,[R2, #+4]
   \       0x20   0x4298             CMP      R0,R3
   \       0x22   0xD200             BCS.N    ??RingBufWrAlloc_4
   \                     ??RingBufWrAlloc_5: (+1)
   \       0x24   0xE7FE             B.N      ??RingBufWrAlloc_5
    130          
    131            if ((p_ring_buf->WrIx < p_ring_buf->RdIx)
    132                && ((p_ring_buf->WrIx + wr_size) >= p_ring_buf->RdIx)) {  // Wr is overwriting at rd location.
   \                     ??RingBufWrAlloc_4: (+1)
   \       0x26   0x8994             LDRH     R4,[R2, #+12]
   \       0x28   0x8910             LDRH     R0,[R2, #+8]
   \       0x2A   0x4284             CMP      R4,R0
   \       0x2C   0xD20C             BCS.N    ??RingBufWrAlloc_6
   \       0x2E   0x8990             LDRH     R0,[R2, #+12]
   \       0x30   0x181C             ADDS     R4,R3,R0
   \       0x32   0x8910             LDRH     R0,[R2, #+8]
   \       0x34   0x4284             CMP      R4,R0
   \       0x36   0xD307             BCC.N    ??RingBufWrAlloc_6
    133              if (p_ring_buf->IsReading == DEF_NO) {                      // OK only if no other task is currently reading.
   \       0x38   0x7C90             LDRB     R0,[R2, #+18]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD102             BNE.N    ??RingBufWrAlloc_7
    134                p_ring_buf->RdIxDirty = DEF_YES;                          // Indicate the rd ix will need to be re-calculated.
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x74D0             STRB     R0,[R2, #+19]
   \       0x42   0xE001             B.N      ??RingBufWrAlloc_6
    135              } else {
    136                return (DEF_NULL);
   \                     ??RingBufWrAlloc_7: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xE01C             B.N      ??RingBufWrAlloc_1
    137              }
    138            }
    139          
    140            if ((p_ring_buf->WrIx + wr_size) > p_ring_buf->Size) {        // No more room at end of ring buf.
   \                     ??RingBufWrAlloc_6: (+1)
   \       0x48   0x6850             LDR      R0,[R2, #+4]
   \       0x4A   0x8994             LDRH     R4,[R2, #+12]
   \       0x4C   0x191C             ADDS     R4,R3,R4
   \       0x4E   0x42A0             CMP      R0,R4
   \       0x50   0xD20F             BCS.N    ??RingBufWrAlloc_8
    141                                                                          // Re-check is needed, after wr ix adjusted for buf len.
    142              if (wr_size >= p_ring_buf->RdIx) {                          // Wr is overwriting at rd location.
   \       0x52   0x8910             LDRH     R0,[R2, #+8]
   \       0x54   0x4283             CMP      R3,R0
   \       0x56   0xD307             BCC.N    ??RingBufWrAlloc_9
    143                if (p_ring_buf->IsReading == DEF_NO) {
   \       0x58   0x7C90             LDRB     R0,[R2, #+18]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD102             BNE.N    ??RingBufWrAlloc_10
    144                  p_ring_buf->RdIxDirty = DEF_YES;                        // Indicate the rd ix will need to be re-calculated.
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0x74D0             STRB     R0,[R2, #+19]
   \       0x62   0xE001             B.N      ??RingBufWrAlloc_9
    145                } else {
    146                  return (DEF_NULL);
   \                     ??RingBufWrAlloc_10: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE00C             B.N      ??RingBufWrAlloc_1
    147                }
    148              }
    149              p_ring_buf->EndValidIx = p_ring_buf->WrIx - 1u;             // Indicate where valid data ends.
   \                     ??RingBufWrAlloc_9: (+1)
   \       0x68   0x8990             LDRH     R0,[R2, #+12]
   \       0x6A   0x1E40             SUBS     R0,R0,#+1
   \       0x6C   0x8210             STRH     R0,[R2, #+16]
    150              p_ring_buf->WrIx = 0u;                                      // Re-set wr ix to start of buf.
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x8190             STRH     R0,[R2, #+12]
    151            }
    152          
    153            p_ring_buf->WrIxPrev = p_ring_buf->WrIx;
   \                     ??RingBufWrAlloc_8: (+1)
   \       0x72   0x8990             LDRH     R0,[R2, #+12]
   \       0x74   0x81D0             STRH     R0,[R2, #+14]
    154          
    155            p_ring_buf->WrIx += size;
   \       0x76   0x8990             LDRH     R0,[R2, #+12]
   \       0x78   0x1808             ADDS     R0,R1,R0
   \       0x7A   0x8190             STRH     R0,[R2, #+12]
    156          
    157            return ((void *)&(p_ring_buf->StartPtr[p_ring_buf->WrIxPrev]));
   \       0x7C   0x6810             LDR      R0,[R2, #+0]
   \       0x7E   0x89D2             LDRH     R2,[R2, #+14]
   \       0x80   0x4410             ADD      R0,R0,R2
   \                     ??RingBufWrAlloc_1: (+1)
   \       0x82   0xBC10             POP      {R4}
   \       0x84   0x4770             BX       LR
    158          }
    159          
    160          /****************************************************************************************************//**
    161           *                                               RingBufWrCommit()
    162           *
    163           * @brief    Commit write data to ring buffer. After this call, no other writes should be done, unless
    164           *           a new call to RingBufWrAlloc() is made.
    165           *
    166           * @param    p_ring_buf  Pointer to ring buffer structure to use.
    167           *
    168           * @note     (1) This function MUST be called from a CRITICAL SECTION, the same in which the call to
    169           *               RingBufWrAlloc() has been done.
    170           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    171          void RingBufWrCommit(RING_BUF *p_ring_buf)
    172          {
    173            //                                                               Calculate and keep prev wr ix in ring buf, to ...
    174            //                                                               re-calculate rd ix in case of overwrite.
    175            MEM_VAL_SET_INT16U(&p_ring_buf->StartPtr[p_ring_buf->WrIx], p_ring_buf->WrIxPrev);
   \                     RingBufWrCommit: (+1)
   \        0x0   0x89C3             LDRH     R3,[R0, #+14]
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0x8981             LDRH     R1,[R0, #+12]
   \        0x6   0x5453             STRB     R3,[R2, R1]
   \        0x8   0x89C1             LDRH     R1,[R0, #+14]
   \        0xA   0xB289             UXTH     R1,R1
   \        0xC   0x0A09             LSRS     R1,R1,#+8
   \        0xE   0x6803             LDR      R3,[R0, #+0]
   \       0x10   0x8982             LDRH     R2,[R0, #+12]
   \       0x12   0x441A             ADD      R2,R3,R2
   \       0x14   0x7051             STRB     R1,[R2, #+1]
    176          
    177            p_ring_buf->WrIx += RING_BUF_IX_SIZE_BYTES;
   \       0x16   0x8981             LDRH     R1,[R0, #+12]
   \       0x18   0x1C89             ADDS     R1,R1,#+2
   \       0x1A   0x8181             STRH     R1,[R0, #+12]
    178            //                                                               If the end valid is 'pushed', adjust val.
    179            p_ring_buf->EndValidIx = DEF_MAX(p_ring_buf->EndValidIx, (p_ring_buf->WrIx - 1u));
   \       0x1C   0x8982             LDRH     R2,[R0, #+12]
   \       0x1E   0x1E52             SUBS     R2,R2,#+1
   \       0x20   0x8A01             LDRH     R1,[R0, #+16]
   \       0x22   0x428A             CMP      R2,R1
   \       0x24   0xD201             BCS.N    ??RingBufWrCommit_0
   \       0x26   0x8A01             LDRH     R1,[R0, #+16]
   \       0x28   0xE001             B.N      ??RingBufWrCommit_1
   \                     ??RingBufWrCommit_0: (+1)
   \       0x2A   0x8981             LDRH     R1,[R0, #+12]
   \       0x2C   0x1E49             SUBS     R1,R1,#+1
   \                     ??RingBufWrCommit_1: (+1)
   \       0x2E   0x8201             STRH     R1,[R0, #+16]
    180          }
   \       0x30   0x4770             BX       LR
    181          
    182          /****************************************************************************************************//**
    183           *                                               RingBufWr()
    184           *
    185           * @brief    Wrapper function that calls both RingBufWrAlloc() and RingBufWrCommit(), in a critical
    186           *           section.
    187           *
    188           * @param    p_ring_buf      Pointer to ring buffer structure to use.
    189           *
    190           * @param    size            Size of the data to write in the ring buffer, in bytes.
    191           *
    192           * @param    p_start_data    Pointer to start of data to write in the ring buffer.
    193           *
    194           * @return   DEF_OK    if write was successful,
    195           *           DEF_FAIL, otherwise.
    196           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    197          CPU_BOOLEAN RingBufWr(RING_BUF   *p_ring_buf,
    198                                CPU_INT16U size,
    199                                void       *p_start_data)
    200          {
   \                     RingBufWr: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
    201            void        *p_start_buf;
    202            CPU_BOOLEAN ret_val = DEF_FAIL;
   \        0xA   0xF05F 0x0800      MOVS     R8,#+0
    203            CORE_DECLARE_IRQ_STATE;
    204          
    205            CORE_ENTER_ATOMIC();
   \        0xE   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x12   0x4681             MOV      R9,R0
    206            p_start_buf = RingBufWrAlloc(p_ring_buf,
    207                                         size);
   \       0x14   0x0031             MOVS     R1,R6
   \       0x16   0xB289             UXTH     R1,R1
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       RingBufWrAlloc
   \       0x1E   0x0004             MOVS     R4,R0
    208            if (p_start_buf != DEF_NULL) {
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD00A             BEQ.N    ??RingBufWr_0
    209              ret_val = DEF_OK;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x4680             MOV      R8,R0
    210          
    211              Mem_Copy(p_start_buf, p_start_data, size);
   \       0x28   0x0032             MOVS     R2,R6
   \       0x2A   0xB292             UXTH     R2,R2
   \       0x2C   0x0039             MOVS     R1,R7
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       Mem_Copy
    212          
    213              RingBufWrCommit(p_ring_buf);
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0x.... 0x....      BL       RingBufWrCommit
    214            }
    215          
    216            CORE_EXIT_ATOMIC();
   \                     ??RingBufWr_0: (+1)
   \       0x3A   0x4648             MOV      R0,R9
   \       0x3C   0x.... 0x....      BL       CORE_ExitAtomic
    217          
    218            return (ret_val);
   \       0x40   0x4640             MOV      R0,R8
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    219          }
    220          
    221          /****************************************************************************************************//**
    222           *                                           RingBufDataIsAvail()
    223           *
    224           * @brief    See if there is any data that is available, in the ring buffer.
    225           *
    226           * @param    p_ring_buf  Pointer to ring buffer structure to use.
    227           *
    228           * @return   DEF_YES,  if there is data that is available to read in the ring buffer,
    229           *           DEF_FAIL, otherwise.
    230           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    231          CPU_BOOLEAN RingBufDataIsAvail(RING_BUF *p_ring_buf)
    232          {
   \                     RingBufDataIsAvail: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    233            CPU_BOOLEAN ret_val = DEF_NO;
   \        0x4   0x2500             MOVS     R5,#+0
    234            CORE_DECLARE_IRQ_STATE;
    235          
    236            if (RING_BUF_IS_NULL(p_ring_buf) == DEF_YES) {
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD102             BNE.N    ??RingBufDataIsAvail_0
    237              return (ret_val);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0xE015             B.N      ??RingBufDataIsAvail_1
    238            }
    239          
    240            CORE_ENTER_ATOMIC();
   \                     ??RingBufDataIsAvail_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x16   0x0006             MOVS     R6,R0
    241            RTOS_ASSERT_CRITICAL((p_ring_buf->IsReading == DEF_NO), RTOS_ERR_ASSERT_CRITICAL_FAIL, ret_val);
   \       0x18   0x7CA0             LDRB     R0,[R4, #+18]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??RingBufDataIsAvail_2
   \       0x1E   0x.... 0x....      BL       CPU_SW_Exception
    242          
    243            if ((p_ring_buf->RdIxDirty == DEF_YES)
    244                || (p_ring_buf->WrIx != p_ring_buf->RdIx)) {
   \                     ??RingBufDataIsAvail_2: (+1)
   \       0x22   0x7CE0             LDRB     R0,[R4, #+19]
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD003             BEQ.N    ??RingBufDataIsAvail_3
   \       0x28   0x89A1             LDRH     R1,[R4, #+12]
   \       0x2A   0x8920             LDRH     R0,[R4, #+8]
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD001             BEQ.N    ??RingBufDataIsAvail_4
    245              ret_val = DEF_YES;
   \                     ??RingBufDataIsAvail_3: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x0005             MOVS     R5,R0
    246            }
    247            CORE_EXIT_ATOMIC();
   \                     ??RingBufDataIsAvail_4: (+1)
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0x.... 0x....      BL       CORE_ExitAtomic
    248          
    249            return (ret_val);
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0xB2C0             UXTB     R0,R0
   \                     ??RingBufDataIsAvail_1: (+1)
   \       0x3E   0xBD70             POP      {R4-R6,PC}
    250          }
    251          
    252          /****************************************************************************************************//**
    253           *                                               RingBufRdStart()
    254           *
    255           * @brief    Start reading from the next available read location, in the ring buffer.
    256           *
    257           * @param    p_ring_buf  Pointer to ring buffer structure to use.
    258           *
    259           * @return   DEF_OK    if there is data to read in the ring buffer,
    260           *           DEF_FAIL, otherwise.
    261           *
    262           * @note     (1) This function must be called before any call to RingBufRd() is made. Once finished
    263           *               reading a packet, a corresponding RingBufRdEnd() must be called.
    264           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    265          CPU_BOOLEAN RingBufRdStart(RING_BUF *p_ring_buf)
    266          {
   \                     RingBufRdStart: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    267            CPU_BOOLEAN ret_val = DEF_FAIL;
   \        0x4   0x2500             MOVS     R5,#+0
    268            CORE_DECLARE_IRQ_STATE;
    269          
    270            CORE_ENTER_ATOMIC();
   \        0x6   0x.... 0x....      BL       CORE_EnterAtomic
   \        0xA   0x0006             MOVS     R6,R0
    271            RTOS_ASSERT_CRITICAL((p_ring_buf->IsReading == DEF_NO), RTOS_ERR_ASSERT_CRITICAL_FAIL, ret_val);
   \        0xC   0x7CA0             LDRB     R0,[R4, #+18]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD001             BEQ.N    ??RingBufRdStart_0
   \       0x12   0x.... 0x....      BL       CPU_SW_Exception
    272          
    273            if (p_ring_buf->RdIxDirty == DEF_YES) {
   \                     ??RingBufRdStart_0: (+1)
   \       0x16   0x7CE0             LDRB     R0,[R4, #+19]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD105             BNE.N    ??RingBufRdStart_1
    274              p_ring_buf->RdIxDirty = DEF_NO;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x74E0             STRB     R0,[R4, #+19]
    275              RingBufRdIxNextRefresh(p_ring_buf);
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       RingBufRdIxNextRefresh
   \       0x26   0xE003             B.N      ??RingBufRdStart_2
    276            } else if (p_ring_buf->WrIx == p_ring_buf->RdIx) {
   \                     ??RingBufRdStart_1: (+1)
   \       0x28   0x89A1             LDRH     R1,[R4, #+12]
   \       0x2A   0x8920             LDRH     R0,[R4, #+8]
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD003             BEQ.N    ??RingBufRdStart_3
    277              goto end;
    278            }
    279          
    280            p_ring_buf->IsReading = DEF_YES;
   \                     ??RingBufRdStart_2: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x74A0             STRB     R0,[R4, #+18]
    281            ret_val = DEF_OK;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0x0005             MOVS     R5,R0
    282          
    283          end:
    284            CORE_EXIT_ATOMIC();
   \                     ??RingBufRdStart_3: (+1)
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0x.... 0x....      BL       CORE_ExitAtomic
    285          
    286            return (ret_val);
   \       0x3E   0x0028             MOVS     R0,R5
   \       0x40   0xB2C0             UXTB     R0,R0
   \       0x42   0xBD70             POP      {R4-R6,PC}
    287          }
    288          
    289          /****************************************************************************************************//**
    290           *                                               RingBufRd()
    291           *
    292           * @brief    Read from the next available read location, in the ring buffer.
    293           *
    294           * @param    p_ring_buf  Pointer to ring buffer structure to use.
    295           *
    296           * @param    size        Size read from the buffer.
    297           *
    298           * @return   Pointer to buffer where to read, if NO error(s),
    299           *           DEF_NULL,                        otherwise.
    300           *
    301           * @note     (1) RingBufRdStart() must be called before making any call to this function. This
    302           *               function can be called any number of times to read a SINGLE packet from the buffer.
    303           *               Once finished reading a packet, a single call to RingBufRdEnd() must be made.
    304           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    305          void *RingBufRd(RING_BUF   *p_ring_buf,
    306                          CPU_SIZE_T size)
    307          {
   \                     RingBufRd: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    308            void *ret_val = DEF_NULL;
   \        0x8   0x2600             MOVS     R6,#+0
    309            CORE_DECLARE_IRQ_STATE;
    310          
    311            CORE_ENTER_ATOMIC();
   \        0xA   0x.... 0x....      BL       CORE_EnterAtomic
   \        0xE   0x0007             MOVS     R7,R0
    312            RTOS_ASSERT_CRITICAL((p_ring_buf->IsReading == DEF_YES), RTOS_ERR_ASSERT_CRITICAL_FAIL, ret_val);
   \       0x10   0x7CA0             LDRB     R0,[R4, #+18]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD001             BEQ.N    ??RingBufRd_0
   \       0x16   0x.... 0x....      BL       CPU_SW_Exception
    313          
    314            //                                                               Rd attempts to go beyond wr location.
    315            RTOS_ASSERT_CRITICAL(!((p_ring_buf->RdIxNext < p_ring_buf->WrIx)
    316                                   && ((p_ring_buf->RdIxNext + size) > p_ring_buf->WrIx)), RTOS_ERR_ASSERT_CRITICAL_FAIL, ret_val);
   \                     ??RingBufRd_0: (+1)
   \       0x1A   0x8961             LDRH     R1,[R4, #+10]
   \       0x1C   0x89A0             LDRH     R0,[R4, #+12]
   \       0x1E   0x4281             CMP      R1,R0
   \       0x20   0xD204             BCS.N    ??RingBufRd_1
   \       0x22   0x89A0             LDRH     R0,[R4, #+12]
   \       0x24   0x8961             LDRH     R1,[R4, #+10]
   \       0x26   0x1869             ADDS     R1,R5,R1
   \       0x28   0x4288             CMP      R0,R1
   \       0x2A   0xD301             BCC.N    ??RingBufRd_2
   \                     ??RingBufRd_1: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xE000             B.N      ??RingBufRd_3
   \                     ??RingBufRd_2: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??RingBufRd_3: (+1)
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD101             BNE.N    ??RingBufRd_4
   \       0x38   0x.... 0x....      BL       CPU_SW_Exception
    317          
    318            //                                                               No more room at end of ring buf.
    319            if ((p_ring_buf->RdIxNext + size) > p_ring_buf->EndValidIx) {
   \                     ??RingBufRd_4: (+1)
   \       0x3C   0x8A20             LDRH     R0,[R4, #+16]
   \       0x3E   0x8961             LDRH     R1,[R4, #+10]
   \       0x40   0x1869             ADDS     R1,R5,R1
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xD20E             BCS.N    ??RingBufRd_5
    320              p_ring_buf->RdIxNext = 0u;                                  // Re-set rd ix to start of buf.
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x8160             STRH     R0,[R4, #+10]
    321          
    322              //                                                             Re-check is needed, after rd ix adjusted for buf len.
    323              //                                                             Rd attempts to go beyond wr location.
    324              RTOS_ASSERT_CRITICAL(!((p_ring_buf->RdIxNext + size) > p_ring_buf->WrIx), RTOS_ERR_ASSERT_CRITICAL_FAIL, ret_val);
   \       0x4A   0x89A0             LDRH     R0,[R4, #+12]
   \       0x4C   0x8961             LDRH     R1,[R4, #+10]
   \       0x4E   0x1869             ADDS     R1,R5,R1
   \       0x50   0x4288             CMP      R0,R1
   \       0x52   0xD301             BCC.N    ??RingBufRd_6
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0xE000             B.N      ??RingBufRd_7
   \                     ??RingBufRd_6: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \                     ??RingBufRd_7: (+1)
   \       0x5A   0xB2C0             UXTB     R0,R0
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD101             BNE.N    ??RingBufRd_5
   \       0x60   0x.... 0x....      BL       CPU_SW_Exception
    325            }
    326          
    327            p_ring_buf->RdIx = p_ring_buf->RdIxNext;                      // Update, in case RdStart is called more than once before End is called.
   \                     ??RingBufRd_5: (+1)
   \       0x64   0x8960             LDRH     R0,[R4, #+10]
   \       0x66   0x8120             STRH     R0,[R4, #+8]
    328            p_ring_buf->RdIxNext = p_ring_buf->RdIx + size;
   \       0x68   0x8920             LDRH     R0,[R4, #+8]
   \       0x6A   0x1828             ADDS     R0,R5,R0
   \       0x6C   0x8160             STRH     R0,[R4, #+10]
    329          
    330            ret_val = &p_ring_buf->StartPtr[p_ring_buf->RdIx];
   \       0x6E   0x6821             LDR      R1,[R4, #+0]
   \       0x70   0x8920             LDRH     R0,[R4, #+8]
   \       0x72   0xEB01 0x0800      ADD      R8,R1,R0
    331          
    332            CORE_EXIT_ATOMIC();
   \       0x76   0x0038             MOVS     R0,R7
   \       0x78   0x.... 0x....      BL       CORE_ExitAtomic
    333          
    334            return (ret_val);
   \       0x7C   0x4640             MOV      R0,R8
   \       0x7E   0xE8BD 0x81F0      POP      {R4-R8,PC}
    335          }
    336          
    337          /****************************************************************************************************//**
    338           *                                               RingBufRdEnd()
    339           *
    340           * @brief    Finish reading from the ring buffer.
    341           *
    342           * @param    p_ring_buf  Pointer to ring buffer structure to use.
    343           *
    344           * @note     (1) This function must be called after the call(s) to RingBufRd() is/are made and a
    345           *               complete packet has been read.
    346           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    347          void RingBufRdEnd(RING_BUF *p_ring_buf)
    348          {
   \                     RingBufRdEnd: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    349            CORE_DECLARE_IRQ_STATE;
    350          
    351            CORE_ENTER_ATOMIC();
   \        0x4   0x.... 0x....      BL       CORE_EnterAtomic
   \        0x8   0x0005             MOVS     R5,R0
    352            RTOS_ASSERT_CRITICAL((p_ring_buf->IsReading == DEF_YES), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \        0xA   0x7CA0             LDRB     R0,[R4, #+18]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD001             BEQ.N    ??RingBufRdEnd_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
    353          
    354            p_ring_buf->IsReading = DEF_NO;
   \                     ??RingBufRdEnd_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x74A0             STRB     R0,[R4, #+18]
    355            p_ring_buf->RdIxNext += RING_BUF_IX_SIZE_BYTES;
   \       0x18   0x8960             LDRH     R0,[R4, #+10]
   \       0x1A   0x1C80             ADDS     R0,R0,#+2
   \       0x1C   0x8160             STRH     R0,[R4, #+10]
    356            p_ring_buf->RdIx = p_ring_buf->RdIxNext;
   \       0x1E   0x8960             LDRH     R0,[R4, #+10]
   \       0x20   0x8120             STRH     R0,[R4, #+8]
    357            CORE_EXIT_ATOMIC();
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       CORE_ExitAtomic
    358          }
   \       0x28   0xBD31             POP      {R0,R4,R5,PC}
    359          
    360          /********************************************************************************************************
    361           ********************************************************************************************************
    362           *                                               LOCAL FUNCTIONS
    363           ********************************************************************************************************
    364           *******************************************************************************************************/
    365          
    366          /****************************************************************************************************//**
    367           *                                           RingBufRdIxNextRefresh()
    368           *
    369           * @brief    Calculates and updates the RdIxNext if the rd location had been overwritten by a write.
    370           *
    371           * @param    p_ring_buf  Pointer to ring buffer structure to use.
    372           *
    373           * @note     (1) This function MUST be called from a CRITICAL SECTION, the same in which the
    374           *               'IsReading' flag is set to DEF_YES.
    375           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    376          static void RingBufRdIxNextRefresh(RING_BUF *p_ring_buf)
    377          {
   \                     RingBufRdIxNextRefresh: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
    378            CPU_INT16U rd_ix;
    379            CPU_INT16U prev_rd_ix;
    380            CPU_INT16U wr_ix;
    381          
    382            if (p_ring_buf->WrIx > p_ring_buf->EndValidIx) {              // WrIx is at the end of the buf. Rd should start at 0.
   \        0x2   0x8A03             LDRH     R3,[R0, #+16]
   \        0x4   0x8982             LDRH     R2,[R0, #+12]
   \        0x6   0x4293             CMP      R3,R2
   \        0x8   0xD202             BCS.N    ??RingBufRdIxNextRefresh_0
    383              p_ring_buf->RdIxNext = 0u;
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x8142             STRH     R2,[R0, #+10]
    384              return;
   \        0xE   0xE044             B.N      ??RingBufRdIxNextRefresh_1
    385            }
    386          
    387            wr_ix = p_ring_buf->WrIx;
   \                     ??RingBufRdIxNextRefresh_0: (+1)
   \       0x10   0x8982             LDRH     R2,[R0, #+12]
    388            rd_ix = wr_ix;
   \       0x12   0x0013             MOVS     R3,R2
    389          
    390            while (DEF_YES) {
    391              if (rd_ix != 0u) {
   \                     ??RingBufRdIxNextRefresh_2: (+1)
   \       0x14   0x001C             MOVS     R4,R3
   \       0x16   0xB2A4             UXTH     R4,R4
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD00F             BEQ.N    ??RingBufRdIxNextRefresh_3
    392                prev_rd_ix = rd_ix;
   \       0x1C   0x0019             MOVS     R1,R3
    393                rd_ix = MEM_VAL_GET_INT16U(&p_ring_buf->StartPtr[rd_ix - RING_BUF_IX_SIZE_BYTES]);
   \       0x1E   0x6805             LDR      R5,[R0, #+0]
   \       0x20   0x001C             MOVS     R4,R3
   \       0x22   0xB2A4             UXTH     R4,R4
   \       0x24   0x442C             ADD      R4,R5,R4
   \       0x26   0xF814 0x4C02      LDRB     R4,[R4, #-2]
   \       0x2A   0x6805             LDR      R5,[R0, #+0]
   \       0x2C   0xB29B             UXTH     R3,R3
   \       0x2E   0x442B             ADD      R3,R5,R3
   \       0x30   0xF813 0x3C01      LDRB     R3,[R3, #-1]
   \       0x34   0x021B             LSLS     R3,R3,#+8
   \       0x36   0xFA53 0xF384      UXTAB    R3,R3,R4
   \       0x3A   0xE00D             B.N      ??RingBufRdIxNextRefresh_4
    394              } else {                                                    // RdIx re-starts at end of buf.
    395                rd_ix = MEM_VAL_GET_INT16U(&p_ring_buf->StartPtr[p_ring_buf->EndValidIx - 1u]);
   \                     ??RingBufRdIxNextRefresh_3: (+1)
   \       0x3C   0x6805             LDR      R5,[R0, #+0]
   \       0x3E   0x8A04             LDRH     R4,[R0, #+16]
   \       0x40   0x442C             ADD      R4,R5,R4
   \       0x42   0xF814 0x4C01      LDRB     R4,[R4, #-1]
   \       0x46   0x6806             LDR      R6,[R0, #+0]
   \       0x48   0x8A05             LDRH     R5,[R0, #+16]
   \       0x4A   0x5D75             LDRB     R5,[R6, R5]
   \       0x4C   0x022D             LSLS     R5,R5,#+8
   \       0x4E   0xFA55 0xF484      UXTAB    R4,R5,R4
   \       0x52   0x0023             MOVS     R3,R4
    396                //                                                           Indicate prev_rd_ix has looped.
    397                prev_rd_ix = p_ring_buf->EndValidIx;
   \       0x54   0x8A04             LDRH     R4,[R0, #+16]
   \       0x56   0x0021             MOVS     R1,R4
    398              }
    399          
    400              if (rd_ix == wr_ix) {                                       // If equal, rd packet is considered lost, since ...
   \                     ??RingBufRdIxNextRefresh_4: (+1)
   \       0x58   0x001D             MOVS     R5,R3
   \       0x5A   0x0014             MOVS     R4,R2
   \       0x5C   0xB2AD             UXTH     R5,R5
   \       0x5E   0xB2A4             UXTH     R4,R4
   \       0x60   0x42A5             CMP      R5,R4
   \       0x62   0xD101             BNE.N    ??RingBufRdIxNextRefresh_5
    401                                                                          // equal ix should mean an empty buf.
    402                p_ring_buf->RdIxNext = prev_rd_ix;
   \       0x64   0x8141             STRH     R1,[R0, #+10]
    403                return;
   \       0x66   0xE018             B.N      ??RingBufRdIxNextRefresh_1
    404              }
    405              if ((prev_rd_ix > wr_ix)
    406                  && (rd_ix < wr_ix)) {
   \                     ??RingBufRdIxNextRefresh_5: (+1)
   \       0x68   0x0015             MOVS     R5,R2
   \       0x6A   0x000C             MOVS     R4,R1
   \       0x6C   0xB2AD             UXTH     R5,R5
   \       0x6E   0xB2A4             UXTH     R4,R4
   \       0x70   0x42A5             CMP      R5,R4
   \       0x72   0xD207             BCS.N    ??RingBufRdIxNextRefresh_6
   \       0x74   0x001D             MOVS     R5,R3
   \       0x76   0x0014             MOVS     R4,R2
   \       0x78   0xB2AD             UXTH     R5,R5
   \       0x7A   0xB2A4             UXTH     R4,R4
   \       0x7C   0x42A5             CMP      R5,R4
   \       0x7E   0xD201             BCS.N    ??RingBufRdIxNextRefresh_6
    407                p_ring_buf->RdIxNext = prev_rd_ix;
   \       0x80   0x8141             STRH     R1,[R0, #+10]
    408                return;
   \       0x82   0xE00A             B.N      ??RingBufRdIxNextRefresh_1
    409              }
    410          
    411              if ((rd_ix > wr_ix)
    412                  && (((CPU_INT16U)(rd_ix - wr_ix)) <= RING_BUF_IX_SIZE_BYTES)) {
   \                     ??RingBufRdIxNextRefresh_6: (+1)
   \       0x84   0x0015             MOVS     R5,R2
   \       0x86   0x001C             MOVS     R4,R3
   \       0x88   0xB2AD             UXTH     R5,R5
   \       0x8A   0xB2A4             UXTH     R4,R4
   \       0x8C   0x42A5             CMP      R5,R4
   \       0x8E   0xD2C1             BCS.N    ??RingBufRdIxNextRefresh_2
   \       0x90   0x1A9C             SUBS     R4,R3,R2
   \       0x92   0xB2A4             UXTH     R4,R4
   \       0x94   0x2C03             CMP      R4,#+3
   \       0x96   0xD2BD             BCS.N    ??RingBufRdIxNextRefresh_2
    413                //                                                           Stop if RdIx obtained is within 2 bytes of WrIx. ...
    414                //                                                           That means that the prev ix cannot be computed   ...
    415                //                                                           and could be corrupted.
    416                p_ring_buf->RdIxNext = rd_ix;
   \       0x98   0x8143             STRH     R3,[R0, #+10]
    417                return;
   \                     ??RingBufRdIxNextRefresh_1: (+1)
   \       0x9A   0xBC70             POP      {R4-R6}
   \       0x9C   0x4770             BX       LR
    418              }
    419            }
    420          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \        0x0   0x....'....        DC32     `RingBufCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x63, 0x6F, 0x6D, 0x6D, 0x6F
   \              0x5C 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x6F
   \       0x58   0x6E 0x5C          DC8 0x6E, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65
   \       0x60   0x5C 0x72          DC8 0x5C, 0x72, 0x69, 0x6E, 0x67, 0x5F, 0x62, 0x75
   \              0x69 0x6E    
   \              0x67 0x5F    
   \              0x62 0x75
   \       0x68   0x66 0x5C          DC8 0x66, 0x5C, 0x72, 0x69, 0x6E, 0x67, 0x5F, 0x62
   \              0x72 0x69    
   \              0x6E 0x67    
   \              0x5F 0x62
   \       0x70   0x75 0x66          DC8 0x75, 0x66, 0x2E, 0x63, 0
   \              0x2E 0x63    
   \              0x00
   \       0x75                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x52 0x69          DC8 "Ring Buf Data"
   \              0x6E 0x67    
   \              0x20 0x42    
   \              0x75 0x66    
   \              0x20 0x44    
   \              0x61 0x74    
   \              0x61 0x00
   \        0xE                      DS8 2

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   RingBufCreate
        24   -> Mem_SegAlloc
      16   RingBufDataIsAvail
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> CPU_SW_Exception
      24   RingBufRd
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CPU_SW_Exception
      16   RingBufRdEnd
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> CPU_SW_Exception
      12   RingBufRdIxNextRefresh
      16   RingBufRdStart
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> CPU_SW_Exception
        16   -> RingBufRdIxNextRefresh
      32   RingBufWr
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> Mem_Copy
        32   -> RingBufWrAlloc
        32   -> RingBufWrCommit
       4   RingBufWrAlloc
       0   RingBufWrCommit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
     120  ?_0
      16  ?_1
     140  RingBufCreate
      64  RingBufDataIsAvail
     130  RingBufRd
      42  RingBufRdEnd
     158  RingBufRdIxNextRefresh
      68  RingBufRdStart
      72  RingBufWr
     134  RingBufWrAlloc
      50  RingBufWrCommit
      16  -- Other

 
 152 bytes in section .rodata
 870 bytes in section .text
 
 870 bytes of CODE  memory
 152 bytes of CONST memory

Errors: none
Warnings: none
