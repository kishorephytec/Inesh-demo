###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:52:59
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\source\cpu_core.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_6493983593496012072.dir\cpu_core.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\source\cpu_core.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_6493983593496012072.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_6493983593496012072.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\source\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_6493983593496012072.dir\cpu_core.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_6493983593496012072.dir\cpu_core.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_6493983593496012072.dir\cpu_core.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\source\cpu_core.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Core CPU Module
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                                   MODULE
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #define    MICRIUM_SOURCE
     25          #define    CPU_CORE_MODULE
     26          
     27          /********************************************************************************************************
     28           ********************************************************************************************************
     29           *                                               INCLUDE FILES
     30           ********************************************************************************************************
     31           *******************************************************************************************************/
     32          
     33          #include  <em_core.h>
     34          
     35          #include  <cpu/include/cpu.h>
     36          
     37          #include  <common/source/rtos/rtos_utils_priv.h>
     38          
     39          #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
     40          #include  <cpu/include/cpu_cache.h>
     41          #endif
     42          
     43          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
     44          #include  <common/include/lib_mem.h>
     45          #include  <common/include/lib_str.h>
     46          #endif
     47          
     48          /********************************************************************************************************
     49           ********************************************************************************************************
     50           *                                               LOCAL DEFINES
     51           ********************************************************************************************************
     52           *******************************************************************************************************/
     53          
     54          #define  RTOS_MODULE_CUR                 RTOS_CFG_MODULE_CPU
     55          
     56          //                                                                 Pop cnt algorithm csts.
     57          #define CRC_UTIL_POPCNT_MASK01010101_32  0x55555555u
     58          #define CRC_UTIL_POPCNT_MASK00110011_32  0x33333333u
     59          #define CRC_UTIL_POPCNT_MASK00001111_32  0x0F0F0F0Fu
     60          #define CRC_UTIL_POPCNT_POWERSOF256_32   0x01010101u
     61          
     62          /********************************************************************************************************
     63           ********************************************************************************************************
     64           *                                               LOCAL TABLES
     65           ********************************************************************************************************
     66           *******************************************************************************************************/
     67          
     68          /********************************************************************************************************
     69           *                                   CPU COUNT LEAD ZEROs LOOKUP TABLE
     70           *
     71           * Note(s) : (1) Index into bit pattern table determines the number of leading zeros in an 8-bit value :
     72           *
     73           *                           b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
     74           *                           ---  ---  ---  ---  ---  ---  ---  ---    ---------------
     75           *                           1    x    x    x    x    x    x    x            0
     76           *                           0    1    x    x    x    x    x    x            1
     77           *                           0    0    1    x    x    x    x    x            2
     78           *                           0    0    0    1    x    x    x    x            3
     79           *                           0    0    0    0    1    x    x    x            4
     80           *                           0    0    0    0    0    1    x    x            5
     81           *                           0    0    0    0    0    0    1    x            6
     82           *                           0    0    0    0    0    0    0    1            7
     83           *                           0    0    0    0    0    0    0    0            8
     84           *******************************************************************************************************/
     85          
     86          #if (!(defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) \
     87            || (CPU_CFG_DATA_SIZE_MAX > CPU_CFG_DATA_SIZE))

   \                                 In section .rodata, align 4
     88          static const CPU_INT08U CPU_CntLeadZerosTbl[256] = {              // Data vals :
   \                     CPU_CntLeadZerosTbl:
   \        0x0   0x08 0x07          DC8 8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3
   \              0x06 0x06    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03
   \       0x17   0x03 0x03          DC8 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02
   \       0x2E   0x02 0x02          DC8 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01
   \       0x45   0x01 0x01          DC8 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01
   \       0x5C   0x01 0x01          DC8 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01
   \       0x73   0x01 0x01          DC8 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00
   \       0x8A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00
   \       0xA1   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00
   \       0xB8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00
   \       0xCF   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00
   \       0xE6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00
   \       0xFD   0x00 0x00          DC8 0, 0, 0
   \              0x00
     89          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
     90            8u, 7u, 6u, 6u, 5u, 5u, 5u, 5u, 4u, 4u, 4u, 4u, 4u, 4u, 4u, 4u, // 0x00 to 0x0F
     91            3u, 3u, 3u, 3u, 3u, 3u, 3u, 3u, 3u, 3u, 3u, 3u, 3u, 3u, 3u, 3u, // 0x10 to 0x1F
     92            2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, // 0x20 to 0x2F
     93            2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, 2u, // 0x30 to 0x3F
     94            1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, // 0x40 to 0x4F
     95            1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, // 0x50 to 0x5F
     96            1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, // 0x60 to 0x6F
     97            1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, // 0x70 to 0x7F
     98            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, // 0x80 to 0x8F
     99            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, // 0x90 to 0x9F
    100            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, // 0xA0 to 0xAF
    101            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, // 0xB0 to 0xBF
    102            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, // 0xC0 to 0xCF
    103            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, // 0xD0 to 0xDF
    104            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, // 0xE0 to 0xEF
    105            0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u  // 0xF0 to 0xFF
    106          };
    107          #endif
    108          
    109          /********************************************************************************************************
    110           ********************************************************************************************************
    111           *                                           LOCAL GLOBAL VARIABLES
    112           ********************************************************************************************************
    113           *******************************************************************************************************/
    114          

   \                                 In section .rodata, align 4
    115          CPU_INT32U const CPU_EndiannessTest = 0x12345678LU;             // Variable to test CPU endianness.
   \                     CPU_EndiannessTest:
   \        0x0   0x1234'5678        DC32 305'419'896
    116          
    117          /********************************************************************************************************
    118           ********************************************************************************************************
    119           *                                       LOCAL FUNCTION PROTOTYPES
    120           ********************************************************************************************************
    121           *******************************************************************************************************/
    122          
    123          #if    (CPU_CFG_NAME_EN == DEF_ENABLED)                         // ------------------ CPU NAME FNCTS ------------------
    124          static void CPU_NameInit(void);
    125          #endif
    126          
    127          //                                                                 ------------------- CPU TS FNCTS -------------------
    128          #if   ((CPU_CFG_TS_EN == DEF_ENABLED) \
    129            || (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
    130          static void CPU_TS_Init(void);
    131          #endif
    132          
    133          /********************************************************************************************************
    134           ********************************************************************************************************
    135           *                                           GLOBAL FUNCTIONS
    136           ********************************************************************************************************
    137           *******************************************************************************************************/
    138          
    139          /****************************************************************************************************//**
    140           *                                               CPU_Init()
    141           *
    142           * @brief    Initialize CPU module :
    143           *               - (a) Initialize CPU timestamps;
    144           *               - (b) Initialize CPU interrupts disabled time measurements;
    145           *               - (c) Initialize CPU host name;
    146           *               - (d) Initialize CPU cache management;
    147           *               - (e) Initialize CPU interrupt management.
    148           *
    149           * @note     (1) CPU_Init() MUST be called ... :
    150           *               - (a) ONLY ONCE from a product's application; ...
    151           *               - (b) BEFORE product's application calls any core CPU module function(s)
    152           *
    153           * @note     (2) The following initialization functions MUST be sequenced as follows :
    154           *               - (a) CPU_TS_Init()           SHOULD precede ALL calls to other CPU timestamp functions.
    155           *               - (b) CPU_IntDisMeasInit()    SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
    156           *                                               & other CPU interrupts disabled time measurement
    157           *                                               functions.
    158           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    159          void CPU_Init(void)
    160          {
    161            //                                                               --------------------- INIT TS ----------------------
    162          #if ((CPU_CFG_TS_EN == DEF_ENABLED) \
    163            || (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
    164            CPU_TS_Init();                                                // See Note #2a.
    165          #endif
    166          
    167            //                                                               ------------------ INIT CPU NAME -------------------
    168          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
    169            CPU_NameInit();
    170          #endif
    171            //                                                               -------------- INIT CACHE MANAGEMENT ---------------
    172          #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
    173            CPU_Cache_Init();
    174          #endif
    175          
    176          #ifdef  CPU_PORT_INIT
    177            CPU_PortInit();
    178          #endif
    179          }
   \                     CPU_Init: (+1)
   \        0x0   0x4770             BX       LR
    180          
    181          /****************************************************************************************************//**
    182           *                                               CPU_Break()
    183           *
    184           * @brief    If the port does not define a CPU_Break() function, emulate the break with a software
    185           *           exception equivalent.
    186           *
    187           * @note     (1) See 'cpu.h  CPU_BREAK()  Note #1'.
    188           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    189          void CPU_Break(void)
    190          {
    191            while (DEF_ON) {
   \                     CPU_Break: (+1)
   \                     ??CPU_Break_0: (+1)
   \        0x0   0xE7FE             B.N      ??CPU_Break_0
    192              ;
    193            }
    194          }
    195          
    196          /****************************************************************************************************//**
    197           *                                           CPU_SW_Exception()
    198           *
    199           * @brief    Trap unrecoverable software exception.
    200           *
    201           * @note     (1) CPU_SW_Exception() deadlocks the current code execution -- whether multi-tasked/
    202           *               -processed/-threaded or single-threaded -- when the current code execution cannot
    203           *               gracefully recover or report a fault or exception condition.
    204           *               See also 'cpu.h  CPU_SW_EXCEPTION()  Note #1'.
    205           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    206          void CPU_SW_Exception(void)
    207          {
    208            while (DEF_ON) {
   \                     CPU_SW_Exception: (+1)
   \                     ??CPU_SW_Exception_0: (+1)
   \        0x0   0xE7FE             B.N      ??CPU_SW_Exception_0
    209              ;
    210            }
    211          }
    212          
    213          /****************************************************************************************************//**
    214           *                                               CPU_NameClr()
    215           *
    216           * @brief    Clear CPU Name.
    217           *******************************************************************************************************/
    218          
    219          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
    220          void CPU_NameClr(void)
    221          {
    222            CORE_DECLARE_IRQ_STATE;
    223          
    224            CORE_ENTER_ATOMIC();
    225            Mem_Clr((void *)&CPU_Name[0],
    226                    (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
    227            CORE_EXIT_ATOMIC();
    228          }
    229          #endif
    230          
    231          /****************************************************************************************************//**
    232           *                                               CPU_NameGet()
    233           *
    234           * @brief    Get CPU host name.
    235           *
    236           * @param    p_name  Pointer to an ASCII character array that will receive the return CPU host
    237           *
    238           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from this function:
    239           *                       - RTOS_ERR_NONE
    240           *
    241           * @note     (1) The size of the ASCII character array that will receive the return CPU host name
    242           *               ASCII string :
    243           *               - (a) MUST   be greater than or equal to the current CPU host name's ASCII string
    244           *                               size including the terminating NULL character;
    245           *               - (b) SHOULD be greater than or equal to CPU_CFG_NAME_SIZE
    246           *******************************************************************************************************/
    247          
    248          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
    249          void CPU_NameGet(CPU_CHAR *p_name,
    250                           RTOS_ERR *p_err)
    251          {
    252            CORE_DECLARE_IRQ_STATE;
    253          
    254            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
    255          
    256            RTOS_ASSERT_DBG_ERR_SET((p_name != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
    257          
    258            CORE_ENTER_ATOMIC();
    259            (void)Str_Copy_N(p_name,
    260                             &CPU_Name[0],
    261                             CPU_CFG_NAME_SIZE);
    262            CORE_EXIT_ATOMIC();
    263          
    264            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    265          }
    266          #endif
    267          
    268          /****************************************************************************************************//**
    269           *                                               CPU_NameSet()
    270           *
    271           * @brief    Set CPU host name.
    272           *
    273           * @param    p_name  Pointer to CPU host name to set.
    274           *
    275           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from this function:
    276           *                       - RTOS_ERR_NONE
    277           *                       - RTOS_ERR_INVALID_ARG
    278           *
    279           * @note     (1) 'p_name' ASCII string size, including the terminating NULL character, MUST be less
    280           *               than or equal to CPU_CFG_NAME_SIZE.
    281           *******************************************************************************************************/
    282          
    283          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
    284          void CPU_NameSet(const CPU_CHAR *p_name,
    285                           RTOS_ERR       *p_err)
    286          {
    287            CPU_SIZE_T len;
    288            CORE_DECLARE_IRQ_STATE;
    289          
    290            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
    291          
    292            RTOS_ASSERT_DBG_ERR_SET((p_name != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
    293          
    294            len = Str_Len_N(p_name,
    295                            CPU_CFG_NAME_SIZE);
    296            if (len < CPU_CFG_NAME_SIZE) {                                // If       cfg name len < max name size, ...
    297              CORE_ENTER_ATOMIC();
    298              (void)Str_Copy_N(&CPU_Name[0],                              // ... copy cfg name to CPU host name.
    299                               p_name,
    300                               CPU_CFG_NAME_SIZE);
    301              CORE_EXIT_ATOMIC();
    302              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    303            } else {
    304              RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_ARG);
    305            }
    306          }
    307          #endif
    308          
    309          /****************************************************************************************************//**
    310           *                                               CPU_TS_Get32()
    311           *
    312           * @brief    Get current 32-bit CPU timestamp.
    313           *
    314           * @return   Current 32-bit CPU timestamp (in timestamp timer counts).
    315           *
    316           * @note     (1) When applicable, the amount of time measured by CPU timestamps is calculated by
    317           *               either of the following equations :
    318           *                   @verbatim
    319           *               - (a) Time measured  =  Number timer counts  *  Timer period
    320           *
    321           *                           where
    322           *
    323           *                               Number timer counts     Number of timer counts measured
    324           *                               Timer period            Timer's period in some units of
    325           *                                                       (fractional) seconds
    326           *                               Time measured           Amount of time measured, in same
    327           *                                                       units of (fractional) seconds
    328           *                                                       as the Timer period
    329           *
    330           *                                           Number timer counts
    331           *               - (b) Time measured  =  ---------------------
    332           *                                           Timer frequency
    333           *
    334           *                           where
    335           *
    336           *                               Number timer counts     Number of timer counts measured
    337           *                               Timer frequency         Timer's frequency in some units
    338           *                                                       of counts per second
    339           *                               Time measured           Amount of time measured, in seconds
    340           *                   @endverbatim
    341           *               See also 'cpu.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
    342           *
    343           * @note     (2) In case the CPU timestamp timer has lower precision than the 32-bit CPU timestamp;
    344           *               its precision is extended via periodic updates by accumulating the deltas of the
    345           *               timestamp timer count values into the higher-precision 32-bit CPU timestamp.
    346           *
    347           * @note     (3) After initialization, 'CPU_TS_32_Accum' & 'CPU_TS_32_TmrPrev' MUST ALWAYS
    348           *               be accessed AND updated exclusively with interrupts disabled -- but NOT
    349           *               with critical sections.
    350           *******************************************************************************************************/
    351          
    352          #if (CPU_CFG_TS_32_EN == DEF_ENABLED)
    353          CPU_TS32 CPU_TS_Get32(void)
    354          {
    355            CPU_TS32 ts;
    356          #if (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_32)
    357            CPU_TS_TMR tmr_cur;
    358            CPU_TS_TMR tmr_delta;
    359            CORE_DECLARE_IRQ_STATE;
    360          
    361          #endif
    362          
    363          #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_32)
    364            ts = (CPU_TS32)CPU_TS_TmrRd();                                // Get cur ts tmr val (in 32-bit ts cnts).
    365          
    366          #else
    367            CORE_ENTER_ATOMIC();
    368            tmr_cur = (CPU_TS_TMR) CPU_TS_TmrRd();                        // Get cur ts tmr val (in ts tmr cnts).
    369            tmr_delta = (CPU_TS_TMR)(tmr_cur - CPU_TS_32_TmrPrev);        // Calc      delta ts tmr cnts.
    370            CPU_TS_32_Accum += (CPU_TS32) tmr_delta;                      // Inc ts by delta ts tmr cnts (see Note #2).
    371            CPU_TS_32_TmrPrev = (CPU_TS_TMR) tmr_cur;                     // Save cur ts tmr cnts for next update.
    372            ts = (CPU_TS32) CPU_TS_32_Accum;
    373            CORE_EXIT_ATOMIC();
    374          #endif
    375          
    376            return (ts);
    377          }
    378          #endif
    379          
    380          /****************************************************************************************************//**
    381           *                                               CPU_TS_Get64()
    382           *
    383           * @brief    Get current 64-bit CPU timestamp.
    384           *
    385           * @return   Current 64-bit CPU timestamp (in timestamp timer counts).
    386           *
    387           * @note     (1) When applicable, the amount of time measured by CPU timestamps is calculated by
    388           *               either of the following equations :
    389           *                   @verbatim
    390           *               - (a) Time measured  =  Number timer counts  *  Timer period
    391           *
    392           *                           where
    393           *
    394           *                               Number timer counts     Number of timer counts measured
    395           *                               Timer period            Timer's period in some units of
    396           *                                                       (fractional) seconds
    397           *                               Time measured           Amount of time measured, in same
    398           *                                                       units of (fractional) seconds
    399           *                                                       as the Timer period
    400           *
    401           *                                           Number timer counts
    402           *               - (b) Time measured  =  ---------------------
    403           *                                           Timer frequency
    404           *
    405           *                           where
    406           *
    407           *                               Number timer counts     Number of timer counts measured
    408           *                               Timer frequency         Timer's frequency in some units
    409           *                                                       of counts per second
    410           *                               Time measured           Amount of time measured, in seconds
    411           *                   @endverbatim
    412           *               See also 'cpu.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
    413           *
    414           * @note     (2) In case the CPU timestamp timer has lower precision than the 64-bit CPU timestamp;
    415           *               its precision is extended via periodic updates by accumulating the deltas of the
    416           *               timestamp timer count values into the higher-precision 64-bit CPU timestamp.
    417           *
    418           * @note     (3) After initialization, 'CPU_TS_64_Accum' & 'CPU_TS_64_TmrPrev' MUST ALWAYS
    419           *               be accessed AND updated exclusively with interrupts disabled -- but NOT
    420           *               with critical sections.
    421           *******************************************************************************************************/
    422          
    423          #if (CPU_CFG_TS_64_EN == DEF_ENABLED)
    424          CPU_TS64 CPU_TS_Get64(void)
    425          {
    426            CPU_TS64 ts;
    427          #if (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_64)
    428            CPU_TS_TMR tmr_cur;
    429            CPU_TS_TMR tmr_delta;
    430            CORE_DECLARE_IRQ_STATE;
    431          #endif
    432          
    433          #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_64)
    434            ts = (CPU_TS64)CPU_TS_TmrRd();                                // Get cur ts tmr val (in 64-bit ts cnts).
    435          
    436          #else
    437            CORE_ENTER_ATOMIC();
    438            tmr_cur = (CPU_TS_TMR) CPU_TS_TmrRd();                        // Get cur ts tmr val (in ts tmr cnts).
    439            tmr_delta = (CPU_TS_TMR)(tmr_cur - CPU_TS_64_TmrPrev);        // Calc      delta ts tmr cnts.
    440            CPU_TS_64_Accum += (CPU_TS64) tmr_delta;                      // Inc ts by delta ts tmr cnts (see Note #2).
    441            CPU_TS_64_TmrPrev = (CPU_TS_TMR) tmr_cur;                     // Save cur ts tmr cnts for next update.
    442            ts = (CPU_TS64) CPU_TS_64_Accum;
    443            CORE_EXIT_ATOMIC();
    444          #endif
    445          
    446            return (ts);
    447          }
    448          #endif
    449          
    450          /****************************************************************************************************//**
    451           *                                               CPU_TS_Update()
    452           *
    453           * @brief    Update current CPU timestamp(s).
    454           *
    455           * @note     (1) CPU timestamp(s) MUST be updated periodically by some application (or BSP) time
    456           *               handler in order to (adequately) maintain CPU timestamp(s)' time.
    457           *               CPU timestamp(s) MUST be updated more frequently than the CPU timestamp timer
    458           *               overflows; otherwise, CPU timestamp(s) will lose time.
    459           *               See also 'cpu.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2e2'.
    460           *******************************************************************************************************/
    461          
    462          #if (CPU_CFG_TS_EN == DEF_ENABLED)
    463          void CPU_TS_Update(void)
    464          {
    465          #if ((CPU_CFG_TS_32_EN == DEF_ENABLED) \
    466            && (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_32))
    467            (void)CPU_TS_Get32();
    468          #endif
    469          
    470          #if ((CPU_CFG_TS_64_EN == DEF_ENABLED) \
    471            && (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_64))
    472            (void)CPU_TS_Get64();
    473          #endif
    474          }
    475          #endif
    476          
    477          /****************************************************************************************************//**
    478           *                                           CPU_TS_TmrFreqGet()
    479           *
    480           * @brief    Get CPU timestamp's timer frequency.
    481           *
    482           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from this function:
    483           *                       - RTOS_ERR_NONE
    484           *                       - RTOS_ERR_INVALID_CFG
    485           *                       - RTOS_ERR_NOT_AVAIL
    486           *
    487           * @return   CPU timestamp's timer frequency (in Hertz), if NO error(s).
    488           *           0                                         , otherwise.
    489           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    490          CPU_TS_TMR_FREQ CPU_TS_TmrFreqGet(RTOS_ERR *p_err)
    491          {
   \                     CPU_TS_TmrFreqGet: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    492          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
    493            CPU_TS_TMR_FREQ freq_hz;
    494          
    495            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0);
    496          
    497            freq_hz = CPU_TS_TmrFreq_Hz;
    498            RTOS_ERR_SET(*p_err, (freq_hz != 0u) ? RTOS_ERR_NONE : RTOS_ERR_INVALID_CFG);
    499          
    500            return (freq_hz);
    501          #else
    502            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0);
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??CPU_TS_TmrFreqGet_0
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
    503          
    504            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   \                     ??CPU_TS_TmrFreqGet_0: (+1)
   \        0xC   0x2006             MOVS     R0,#+6
   \        0xE   0x7020             STRB     R0,[R4, #+0]
   \       0x10   0x....             LDR.N    R0,??DataTable2
   \       0x12   0x6060             STR      R0,[R4, #+4]
   \       0x14   0xF44F 0x70FC      MOV      R0,#+504
   \       0x18   0x60A0             STR      R0,[R4, #+8]
   \       0x1A   0x....             LDR.N    R0,??DataTable2_1
   \       0x1C   0x60E0             STR      R0,[R4, #+12]
    505          
    506            return (0u);
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD10             POP      {R4,PC}
    507          #endif
    508          }
    509          
    510          /****************************************************************************************************//**
    511           *                                           CPU_TS_TmrFreqSet()
    512           *
    513           * @brief    Set CPU timestamp's timer frequency.
    514           *
    515           * @param    freq_hz     Frequency (in Hertz) to set for CPU timestamp's timer.
    516           *
    517           * @note     (1) CPU timestamp timer frequency is NOT required for internal CPU timestamp
    518           *               operations but may OPTIONALLY be configured by CPU_TS_TmrInit() or other
    519           *               application/BSP initialization functions.
    520           *               CPU timestamp timer frequency MAY be used with optional CPU_TSxx_to_uSec()
    521           *               to convert CPU timestamps from timer counts into microseconds.
    522           *               See also 'cpu.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec().
    523           *               @n
    524           *               CPU timestamp timer period SHOULD be less than the typical measured time but MUST
    525           *               be less than the maximum measured time; otherwise, timer resolution inadequate to
    526           *               measure desired times.
    527           *               See also 'cpu.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec().
    528           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    529          void CPU_TS_TmrFreqSet(CPU_TS_TMR_FREQ freq_hz)
    530          {
    531          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
    532            CPU_TS_TmrFreq_Hz = freq_hz;
    533          #else
    534            PP_UNUSED_PARAM(freq_hz);
    535          #endif
    536          }
   \                     CPU_TS_TmrFreqSet: (+1)
   \        0x0   0x4770             BX       LR
    537          
    538          /****************************************************************************************************//**
    539           *                                           CPU_CntLeadZeros()
    540           *
    541           * @brief    Count the number of contiguous, most-significant, leading zero bits in a data value.
    542           *
    543           * @param    val     Data value to count leading zero bits.
    544           *
    545           * @return   Number of contiguous, most-significant, leading zero bits in 'val', if NO error(s).
    546           *           DEF_INT_CPU_U_MAX_VAL,                                              otherwise.
    547           *
    548           * @note     (1) Supports the following data value sizes :
    549           *               - 8-bits,
    550           *               - 16-bits,
    551           *               - 32-bits,
    552           *               - 64-bits
    553           *               @n
    554           *               See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
    555           *
    556           *           - (a) For  8-bit values :
    557           *               @verbatim
    558           *                   b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
    559           *                   ---  ---  ---  ---  ---  ---  ---  ---    ---------------
    560           *                   1    x    x    x    x    x    x    x            0
    561           *                   0    1    x    x    x    x    x    x            1
    562           *                   0    0    1    x    x    x    x    x            2
    563           *                   0    0    0    1    x    x    x    x            3
    564           *                   0    0    0    0    1    x    x    x            4
    565           *                   0    0    0    0    0    1    x    x            5
    566           *                   0    0    0    0    0    0    1    x            6
    567           *                   0    0    0    0    0    0    0    1            7
    568           *                   0    0    0    0    0    0    0    0            8
    569           *               @endverbatim
    570           *           - (b) For 16-bit values :
    571           *               @verbatim
    572           *                   b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
    573           *                   ---  ---  ---       ---  ---  ---  ---  ---    ---------------
    574           *                   1    x    x         x    x    x    x    x            0
    575           *                   0    1    x         x    x    x    x    x            1
    576           *                   0    0    1         x    x    x    x    x            2
    577           *                   :    :    :         :    :    :    :    :            :
    578           *                   :    :    :         :    :    :    :    :            :
    579           *                   0    0    0         1    x    x    x    x           11
    580           *                   0    0    0         0    1    x    x    x           12
    581           *                   0    0    0         0    0    1    x    x           13
    582           *                   0    0    0         0    0    0    1    x           14
    583           *                   0    0    0         0    0    0    0    1           15
    584           *                   0    0    0         0    0    0    0    0           16
    585           *               @endverbatim
    586           *           - (c) For 32-bit values :
    587           *               @verbatim
    588           *                   b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
    589           *                   ---  ---  ---       ---  ---  ---  ---  ---    ---------------
    590           *                   1    x    x         x    x    x    x    x            0
    591           *                   0    1    x         x    x    x    x    x            1
    592           *                   0    0    1         x    x    x    x    x            2
    593           *                   :    :    :         :    :    :    :    :            :
    594           *                   :    :    :         :    :    :    :    :            :
    595           *                   0    0    0         1    x    x    x    x           27
    596           *                   0    0    0         0    1    x    x    x           28
    597           *                   0    0    0         0    0    1    x    x           29
    598           *                   0    0    0         0    0    0    1    x           30
    599           *                   0    0    0         0    0    0    0    1           31
    600           *                   0    0    0         0    0    0    0    0           32
    601           *               @endverbatim
    602           *
    603           *           - (d) For 64-bit values :
    604           *               @verbatim
    605           *                   b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
    606           *                   ---  ---  ---       ---  ---  ---  ---  ---    ---------------
    607           *                   1    x    x         x    x    x    x    x            0
    608           *                   0    1    x         x    x    x    x    x            1
    609           *                   0    0    1         x    x    x    x    x            2
    610           *                   :    :    :         :    :    :    :    :            :
    611           *                   :    :    :         :    :    :    :    :            :
    612           *                   0    0    0         1    x    x    x    x           59
    613           *                   0    0    0         0    1    x    x    x           60
    614           *                   0    0    0         0    0    1    x    x           61
    615           *                   0    0    0         0    0    0    1    x           62
    616           *                   0    0    0         0    0    0    0    1           63
    617           *                   0    0    0         0    0    0    0    0           64
    618           *               @endverbatim
    619           *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
    620           *******************************************************************************************************/
    621          
    622          #ifndef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
    623          CPU_DATA CPU_CntLeadZeros(CPU_DATA val)
    624          {
    625            CPU_DATA nbr_lead_zeros;
    626          
    627          #if   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_08)
    628            nbr_lead_zeros = CPU_CntLeadZeros08((CPU_INT08U)val);
    629          
    630          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
    631            nbr_lead_zeros = CPU_CntLeadZeros16((CPU_INT16U)val);
    632          
    633          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
    634            nbr_lead_zeros = CPU_CntLeadZeros32((CPU_INT32U)val);
    635          
    636          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_64)
    637            nbr_lead_zeros = CPU_CntLeadZeros64((CPU_INT64U)val);
    638          
    639          #else //                                                           See Note #1a.
    640            nbr_lead_zeros = DEF_INT_CPU_U_MAX_VAL;
    641          #endif
    642          
    643            return (nbr_lead_zeros);
    644          }
    645          #endif
    646          
    647          /****************************************************************************************************//**
    648           *                                           CPU_CntLeadZeros08()
    649           *
    650           * @brief    Count the number of contiguous, most-significant, leading zero bits in an 8-bit data value.
    651           *
    652           * @param    val     Data value to count leading zero bits.
    653           *
    654           * @return   Number of contiguous, most-significant, leading zero bits in 'val'.
    655           *
    656           * @note     (1) Supports  8-bit values :
    657           *               @verbatim
    658           *                           b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
    659           *                           ---  ---  ---  ---  ---  ---  ---  ---    ---------------
    660           *                           1    x    x    x    x    x    x    x            0
    661           *                           0    1    x    x    x    x    x    x            1
    662           *                           0    0    1    x    x    x    x    x            2
    663           *                           0    0    0    1    x    x    x    x            3
    664           *                           0    0    0    0    1    x    x    x            4
    665           *                           0    0    0    0    0    1    x    x            5
    666           *                           0    0    0    0    0    0    1    x            6
    667           *                           0    0    0    0    0    0    0    1            7
    668           *                           0    0    0    0    0    0    0    0            8
    669           *               @endverbatim
    670           *               See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
    671           *******************************************************************************************************/
    672          
    673          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)

   \                                 In section .text, align 2, keep-with-next
    674          CPU_DATA CPU_CntLeadZeros08(CPU_INT08U val)
    675          {
   \                     CPU_CntLeadZeros08: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    676          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) \
    677            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
    678            CPU_DATA ix;
    679          #endif
    680            CPU_DATA nbr_lead_zeros;
    681          
    682          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) \
    683            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
    684            //                                                               ---------- ASM-OPTIMIZED -----------
    685            nbr_lead_zeros = CPU_CntLeadZeros((CPU_DATA)val);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x.... 0x....      BL       CPU_CntLeadZeros
    686            nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
   \        0xC   0x3818             SUBS     R0,R0,#+24
    687          
    688          #else
    689            //                                                               ----------- C-OPTIMIZED ------------
    690            //                                                               Chk bits [07:00] :
    691            //                                                               .. Nbr lead zeros =               ..
    692            //                                                               .. lookup tbl ix  = 'val' >>  0 bits
    693            //                                                               .. plus nbr msb lead zeros =  0 bits.
    694            ix = (CPU_DATA)(val);
    695            nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);
    696          #endif
    697          
    698            return (nbr_lead_zeros);
   \        0xE   0xBD10             POP      {R4,PC}
    699          }
    700          #endif
    701          
    702          /****************************************************************************************************//**
    703           *                                           CPU_CntLeadZeros16()
    704           *
    705           * @brief    Count the number of contiguous, most-significant, leading zero bits in a 16-bit data value.
    706           *
    707           * @param    val     Data value to count leading zero bits.
    708           *
    709           * @return   Number of contiguous, most-significant, leading zero bits in 'val'.
    710           *
    711           * @note     (1) Supports 16-bit values :
    712           *               @verbatim
    713           *                       b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
    714           *                       ---  ---  ---       ---  ---  ---  ---  ---    ---------------
    715           *                       1    x    x         x    x    x    x    x            0
    716           *                       0    1    x         x    x    x    x    x            1
    717           *                       0    0    1         x    x    x    x    x            2
    718           *                       :    :    :         :    :    :    :    :            :
    719           *                       :    :    :         :    :    :    :    :            :
    720           *                       0    0    0         1    x    x    x    x           11
    721           *                       0    0    0         0    1    x    x    x           12
    722           *                       0    0    0         0    0    1    x    x           13
    723           *                       0    0    0         0    0    0    1    x           14
    724           *                       0    0    0         0    0    0    0    1           15
    725           *                       0    0    0         0    0    0    0    0           16
    726           *               @endverbatim
    727           *
    728           *               See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
    729           *******************************************************************************************************/
    730          
    731          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)

   \                                 In section .text, align 2, keep-with-next
    732          CPU_DATA CPU_CntLeadZeros16(CPU_INT16U val)
    733          {
   \                     CPU_CntLeadZeros16: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    734          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) \
    735            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
    736            CPU_DATA ix;
    737          #endif
    738            CPU_DATA nbr_lead_zeros;
    739          
    740            //                                                               ---------- ASM-OPTIMIZED -----------
    741          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) \
    742            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
    743            nbr_lead_zeros = CPU_CntLeadZeros((CPU_DATA)val);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB280             UXTH     R0,R0
   \        0x8   0x.... 0x....      BL       CPU_CntLeadZeros
    744            nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
   \        0xC   0x3810             SUBS     R0,R0,#+16
    745          
    746          #else
    747            //                                                               ----------- C-OPTIMIZED ------------
    748            if (val > 0x00FFu) {                                          // Chk bits [15:08] :
    749                                                                          // .. Nbr lead zeros =               ..
    750              ix = (CPU_DATA)((CPU_DATA)val >> 8u);                       // .. lookup tbl ix  = 'val' >>  8 bits
    751              nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);       // .. plus nbr msb lead zeros =  0 bits.
    752            } else {                                                      // Chk bits [07:00] :
    753                                                                          // .. Nbr lead zeros =               ..
    754              ix = (CPU_DATA)(val);                                       // .. lookup tbl ix  = 'val' >>  0 bits
    755                                                                          // .. plus nbr msb lead zeros =  8 bits.
    756              nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);
    757            }
    758          #endif
    759          
    760            return (nbr_lead_zeros);
   \        0xE   0xBD10             POP      {R4,PC}
    761          }
    762          #endif
    763          
    764          /****************************************************************************************************//**
    765           *                                           CPU_CntLeadZeros32()
    766           *
    767           * @brief    Count the number of contiguous, most-significant, leading zero bits in a 32-bit data value.
    768           *
    769           * @param    val     Data value to count leading zero bits.
    770           *
    771           * @return   Number of contiguous, most-significant, leading zero bits in 'val'.
    772           *
    773           * @note     (1) Supports 32-bit values :
    774           *               @verbatim
    775           *                       b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
    776           *                       ---  ---  ---       ---  ---  ---  ---  ---    ---------------
    777           *                       1    x    x         x    x    x    x    x            0
    778           *                       0    1    x         x    x    x    x    x            1
    779           *                       0    0    1         x    x    x    x    x            2
    780           *                       :    :    :         :    :    :    :    :            :
    781           *                       :    :    :         :    :    :    :    :            :
    782           *                       0    0    0         1    x    x    x    x           27
    783           *                       0    0    0         0    1    x    x    x           28
    784           *                       0    0    0         0    0    1    x    x           29
    785           *                       0    0    0         0    0    0    1    x           30
    786           *                       0    0    0         0    0    0    0    1           31
    787           *                       0    0    0         0    0    0    0    0           32
    788           *               @endverbatim
    789           *
    790           *               See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
    791           *******************************************************************************************************/
    792          
    793          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)

   \                                 In section .text, align 2, keep-with-next
    794          CPU_DATA CPU_CntLeadZeros32(CPU_INT32U val)
    795          {
   \                     CPU_CntLeadZeros32: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    796          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) \
    797            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
    798            CPU_DATA ix;
    799          #endif
    800            CPU_DATA nbr_lead_zeros;
    801          
    802            //                                                               ---------- ASM-OPTIMIZED -----------
    803          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) \
    804            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
    805            nbr_lead_zeros = CPU_CntLeadZeros((CPU_DATA)val);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       CPU_CntLeadZeros
    806            nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
    807          
    808          #else //                                                           ----------- C-OPTIMIZED ------------
    809            if (val > 0x0000FFFFu) {
    810              if (val > 0x00FFFFFFu) {                                    // Chk bits [31:24] :
    811                                                                          // .. Nbr lead zeros =               ..
    812                ix = (CPU_DATA)((CPU_DATA)(val >> 24u));                  // .. lookup tbl ix  = 'val' >> 24 bits
    813                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);     // .. plus nbr msb lead zeros =  0 bits.
    814              } else {                                                    // Chk bits [23:16] :
    815                                                                          // .. Nbr lead zeros =               ..
    816                ix = (CPU_DATA)((CPU_DATA)(val >> 16u));                  // .. lookup tbl ix  = 'val' >> 16 bits
    817                                                                          // .. plus nbr msb lead zeros =  8 bits.
    818                nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);
    819              }
    820            } else {
    821              if (val > 0x000000FFu) {                                    // Chk bits [15:08] :
    822                                                                          // .. Nbr lead zeros =               ..
    823                ix = (CPU_DATA)((CPU_DATA)(val >>  8u));                  // .. lookup tbl ix  = 'val' >>  8 bits
    824                                                                          // .. plus nbr msb lead zeros = 16 bits.
    825                nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 16u);
    826              } else {                                                    // Chk bits [07:00] :
    827                                                                          // .. Nbr lead zeros =               ..
    828                ix = (CPU_DATA)((CPU_DATA)(val >>  0u));                  // .. lookup tbl ix  = 'val' >>  0 bits
    829                                                                          // .. plus nbr msb lead zeros = 24 bits.
    830                nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 24u);
    831              }
    832            }
    833          #endif
    834          
    835            return (nbr_lead_zeros);
   \        0xA   0xBD10             POP      {R4,PC}
    836          }
    837          #endif
    838          
    839          /****************************************************************************************************//**
    840           *                                           CPU_CntLeadZeros64()
    841           *
    842           * @brief    Count the number of contiguous, most-significant, leading zero bits in a 64-bit data value.
    843           *
    844           * @param    val     Data value to count leading zero bits.
    845           *
    846           * @return   Number of contiguous, most-significant, leading zero bits in 'val'.
    847           *
    848           * @note     (1) Supports 64-bit values :
    849           *               @verbatim
    850           *                       b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
    851           *                       ---  ---  ---       ---  ---  ---  ---  ---    ---------------
    852           *                       1    x    x         x    x    x    x    x            0
    853           *                       0    1    x         x    x    x    x    x            1
    854           *                       0    0    1         x    x    x    x    x            2
    855           *                       :    :    :         :    :    :    :    :            :
    856           *                       :    :    :         :    :    :    :    :            :
    857           *                       0    0    0         1    x    x    x    x           59
    858           *                       0    0    0         0    1    x    x    x           60
    859           *                       0    0    0         0    0    1    x    x           61
    860           *                       0    0    0         0    0    0    1    x           62
    861           *                       0    0    0         0    0    0    0    1           63
    862           *                       0    0    0         0    0    0    0    0           64
    863           *               @endverbatim
    864           *
    865           *               See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
    866           *******************************************************************************************************/
    867          
    868          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)

   \                                 In section .text, align 2, keep-with-next
    869          CPU_DATA CPU_CntLeadZeros64(CPU_INT64U val)
    870          {
   \                     CPU_CntLeadZeros64: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    871          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) \
    872            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
    873            CPU_DATA ix;
    874          #endif
    875            CPU_DATA nbr_lead_zeros;
    876          
    877            //                                                               ---------- ASM-OPTIMIZED -----------
    878          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) \
    879            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
    880            nbr_lead_zeros = CPU_CntLeadZeros((CPU_DATA)val);
    881            nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
    882          
    883          #else //                                                           ----------- C-OPTIMIZED ------------
    884            if (val > 0x00000000FFFFFFFFu) {
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x428D             CMP      R5,R1
   \        0xC   0xD332             BCC.N    ??CPU_CntLeadZeros64_0
   \        0xE   0xD801             BHI.N    ??CPU_CntLeadZeros64_1
   \       0x10   0x4284             CMP      R4,R0
   \       0x12   0xD32F             BCC.N    ??CPU_CntLeadZeros64_0
    885              if (val > 0x0000FFFFFFFFFFFFu) {
   \                     ??CPU_CntLeadZeros64_1: (+1)
   \       0x14   0xF5B5 0x3F80      CMP      R5,#+65536
   \       0x18   0xD319             BCC.N    ??CPU_CntLeadZeros64_2
   \       0x1A   0xD801             BHI.N    ??CPU_CntLeadZeros64_3
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD316             BCC.N    ??CPU_CntLeadZeros64_2
    886                if (val > 0x00FFFFFFFFFFFFFFu) {                          // Chk bits [63:56] :
   \                     ??CPU_CntLeadZeros64_3: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xF05F 0x7180      MOVS     R1,#+16777216
   \       0x26   0x428D             CMP      R5,R1
   \       0x28   0xD309             BCC.N    ??CPU_CntLeadZeros64_4
   \       0x2A   0xD801             BHI.N    ??CPU_CntLeadZeros64_5
   \       0x2C   0x4284             CMP      R4,R0
   \       0x2E   0xD306             BCC.N    ??CPU_CntLeadZeros64_4
    887                                                                          // .. Nbr lead zeros =               ..
    888                  ix = (CPU_DATA)((CPU_INT64U)val >> 56u);                // .. lookup tbl ix  = 'val' >> 56 bits
   \                     ??CPU_CntLeadZeros64_5: (+1)
   \       0x30   0x0022             MOVS     R2,R4
   \       0x32   0x002B             MOVS     R3,R5
   \       0x34   0x0E1A             LSRS     R2,R3,#+24
   \       0x36   0x2300             MOVS     R3,#+0
    889                  nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);   // .. plus nbr msb lead zeros =  0 bits.
   \       0x38   0x....             LDR.N    R0,??DataTable2_2
   \       0x3A   0x5C80             LDRB     R0,[R0, R2]
   \       0x3C   0xE052             B.N      ??CPU_CntLeadZeros64_6
    890                } else {                                                  // Chk bits [55:48] :
    891                                                                          // .. Nbr lead zeros =               ..
    892                  ix = (CPU_DATA)((CPU_INT64U)val >> 48u);                // .. lookup tbl ix  = 'val' >> 48 bits
   \                     ??CPU_CntLeadZeros64_4: (+1)
   \       0x3E   0x0022             MOVS     R2,R4
   \       0x40   0x002B             MOVS     R3,R5
   \       0x42   0x0C1A             LSRS     R2,R3,#+16
   \       0x44   0x2300             MOVS     R3,#+0
    893                                                                          // .. plus nbr msb lead zeros =  8 bits.
    894                  nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] +  8u);
   \       0x46   0x....             LDR.N    R0,??DataTable2_2
   \       0x48   0x5C80             LDRB     R0,[R0, R2]
   \       0x4A   0x3008             ADDS     R0,R0,#+8
   \       0x4C   0xE04A             B.N      ??CPU_CntLeadZeros64_6
    895                }
    896              } else {
    897                if (val > 0x000000FFFFFFFFFFu) {                          // Chk bits [47:40] :
   \                     ??CPU_CntLeadZeros64_2: (+1)
   \       0x4E   0xF5B5 0x7F80      CMP      R5,#+256
   \       0x52   0xD30A             BCC.N    ??CPU_CntLeadZeros64_7
   \       0x54   0xD801             BHI.N    ??CPU_CntLeadZeros64_8
   \       0x56   0x2C00             CMP      R4,#+0
   \       0x58   0xD307             BCC.N    ??CPU_CntLeadZeros64_7
    898                                                                          // .. Nbr lead zeros =               ..
    899                  ix = (CPU_DATA)((CPU_INT64U)val >> 40u);                // .. lookup tbl ix  = 'val' >> 40 bits
   \                     ??CPU_CntLeadZeros64_8: (+1)
   \       0x5A   0x0022             MOVS     R2,R4
   \       0x5C   0x002B             MOVS     R3,R5
   \       0x5E   0x0A1A             LSRS     R2,R3,#+8
   \       0x60   0x2300             MOVS     R3,#+0
    900                                                                          // .. plus nbr msb lead zeros = 16 bits.
    901                  nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 16u);
   \       0x62   0x....             LDR.N    R0,??DataTable2_2
   \       0x64   0x5C80             LDRB     R0,[R0, R2]
   \       0x66   0x3010             ADDS     R0,R0,#+16
   \       0x68   0xE03C             B.N      ??CPU_CntLeadZeros64_6
    902                } else {                                                  // Chk bits [39:32] :
    903                                                                          // .. Nbr lead zeros =               ..
    904                  ix = (CPU_DATA)((CPU_INT64U)val >> 32u);                // .. lookup tbl ix  = 'val' >> 32 bits
   \                     ??CPU_CntLeadZeros64_7: (+1)
   \       0x6A   0x002A             MOVS     R2,R5
    905                                                                          // .. plus nbr msb lead zeros = 24 bits.
    906                  nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 24u);
   \       0x6C   0x....             LDR.N    R0,??DataTable2_2
   \       0x6E   0x5C80             LDRB     R0,[R0, R2]
   \       0x70   0x3018             ADDS     R0,R0,#+24
   \       0x72   0xE037             B.N      ??CPU_CntLeadZeros64_6
    907                }
    908              }
    909            } else {
    910              if (val > 0x000000000000FFFFu) {
   \                     ??CPU_CntLeadZeros64_0: (+1)
   \       0x74   0x2D00             CMP      R5,#+0
   \       0x76   0xD320             BCC.N    ??CPU_CntLeadZeros64_9
   \       0x78   0xD802             BHI.N    ??CPU_CntLeadZeros64_10
   \       0x7A   0xF5B4 0x3F80      CMP      R4,#+65536
   \       0x7E   0xD31C             BCC.N    ??CPU_CntLeadZeros64_9
    911                if (val > 0x0000000000FFFFFFu) {                          // Chk bits [31:24] :
   \                     ??CPU_CntLeadZeros64_10: (+1)
   \       0x80   0xF05F 0x7080      MOVS     R0,#+16777216
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0x428D             CMP      R5,R1
   \       0x88   0xD30C             BCC.N    ??CPU_CntLeadZeros64_11
   \       0x8A   0xD801             BHI.N    ??CPU_CntLeadZeros64_12
   \       0x8C   0x4284             CMP      R4,R0
   \       0x8E   0xD309             BCC.N    ??CPU_CntLeadZeros64_11
    912                                                                          // .. Nbr lead zeros =               ..
    913                  ix = (CPU_DATA)((CPU_INT64U)val >> 24u);                // .. lookup tbl ix  = 'val' >> 24 bits
   \                     ??CPU_CntLeadZeros64_12: (+1)
   \       0x90   0x0022             MOVS     R2,R4
   \       0x92   0x002B             MOVS     R3,R5
   \       0x94   0x0E12             LSRS     R2,R2,#+24
   \       0x96   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \       0x9A   0x0E1B             LSRS     R3,R3,#+24
    914                                                                          // .. plus nbr msb lead zeros = 32 bits.
    915                  nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 32u);
   \       0x9C   0x....             LDR.N    R0,??DataTable2_2
   \       0x9E   0x5C80             LDRB     R0,[R0, R2]
   \       0xA0   0x3020             ADDS     R0,R0,#+32
   \       0xA2   0xE01F             B.N      ??CPU_CntLeadZeros64_6
    916                } else {                                                  // Chk bits [23:16] :
    917                                                                          // .. Nbr lead zeros =               ..
    918                  ix = (CPU_DATA)((CPU_INT64U)val >> 16u);                // .. lookup tbl ix  = 'val' >> 16 bits
   \                     ??CPU_CntLeadZeros64_11: (+1)
   \       0xA4   0x0020             MOVS     R0,R4
   \       0xA6   0x0029             MOVS     R1,R5
   \       0xA8   0x0C00             LSRS     R0,R0,#+16
   \       0xAA   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \       0xAE   0x0C09             LSRS     R1,R1,#+16
   \       0xB0   0x0002             MOVS     R2,R0
    919                                                                          // .. plus nbr msb lead zeros = 40 bits.
    920                  nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 40u);
   \       0xB2   0x....             LDR.N    R0,??DataTable2_2
   \       0xB4   0x5C80             LDRB     R0,[R0, R2]
   \       0xB6   0x3028             ADDS     R0,R0,#+40
   \       0xB8   0xE014             B.N      ??CPU_CntLeadZeros64_6
    921                }
    922              } else {
    923                if (val > 0x00000000000000FFu) {                          // Chk bits [15:08] :
   \                     ??CPU_CntLeadZeros64_9: (+1)
   \       0xBA   0x2D00             CMP      R5,#+0
   \       0xBC   0xD30E             BCC.N    ??CPU_CntLeadZeros64_13
   \       0xBE   0xD802             BHI.N    ??CPU_CntLeadZeros64_14
   \       0xC0   0xF5B4 0x7F80      CMP      R4,#+256
   \       0xC4   0xD30A             BCC.N    ??CPU_CntLeadZeros64_13
    924                                                                          // .. Nbr lead zeros =               ..
    925                  ix = (CPU_DATA)((CPU_INT64U)val >>  8u);                // .. lookup tbl ix  = 'val' >>  8 bits
   \                     ??CPU_CntLeadZeros64_14: (+1)
   \       0xC6   0x0020             MOVS     R0,R4
   \       0xC8   0x0029             MOVS     R1,R5
   \       0xCA   0x0A00             LSRS     R0,R0,#+8
   \       0xCC   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \       0xD0   0x0A09             LSRS     R1,R1,#+8
   \       0xD2   0x0002             MOVS     R2,R0
    926                                                                          // .. plus nbr msb lead zeros = 48 bits.
    927                  nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 48u);
   \       0xD4   0x....             LDR.N    R0,??DataTable2_2
   \       0xD6   0x5C80             LDRB     R0,[R0, R2]
   \       0xD8   0x3030             ADDS     R0,R0,#+48
   \       0xDA   0xE003             B.N      ??CPU_CntLeadZeros64_6
    928                } else {                                                  // Chk bits [07:00] :
    929                                                                          // .. Nbr lead zeros =               ..
    930                  ix = (CPU_DATA)(val);                                   // .. lookup tbl ix  = 'val' >>  0 bits
   \                     ??CPU_CntLeadZeros64_13: (+1)
   \       0xDC   0x0022             MOVS     R2,R4
    931                                                                          // .. plus nbr msb lead zeros = 56 bits.
    932                  nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 56u);
   \       0xDE   0x....             LDR.N    R0,??DataTable2_2
   \       0xE0   0x5C80             LDRB     R0,[R0, R2]
   \       0xE2   0x3038             ADDS     R0,R0,#+56
    933                }
    934              }
    935            }
    936          #endif
    937          
    938            return (nbr_lead_zeros);
   \                     ??CPU_CntLeadZeros64_6: (+1)
   \       0xE4   0xBC30             POP      {R4,R5}
   \       0xE6   0x4770             BX       LR
    939          }
    940          #endif
    941          
    942          /****************************************************************************************************//**
    943           *                                           CPU_CntTrailZeros()
    944           *
    945           * @brief    Count the number of contiguous, least-significant, trailing zero bits in a data value.
    946           *
    947           * @param    val     Data value to count trailing zero bits.
    948           *
    949           * @return   Number of contiguous, least-significant, trailing zero bits in 'val'.
    950           *
    951           * @note     (1) Supports the following data value sizes :
    952           *               -  8-bits,
    953           *               - 16-bits,
    954           *               - 32-bits,
    955           *               - 64-bits
    956           *                   See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
    957           *               @verbatim
    958           *           - (a) For  8-bit values :
    959           *
    960           *                   b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
    961           *                   ---  ---  ---  ---  ---  ---  ---  ---    ----------------
    962           *                   x    x    x    x    x    x    x    1            0
    963           *                   x    x    x    x    x    x    1    0            1
    964           *                   x    x    x    x    x    1    0    0            2
    965           *                   x    x    x    x    1    0    0    0            3
    966           *                   x    x    x    1    0    0    0    0            4
    967           *                   x    x    1    0    0    0    0    0            5
    968           *                   x    1    0    0    0    0    0    0            6
    969           *                   1    0    0    0    0    0    0    0            7
    970           *                   0    0    0    0    0    0    0    0            8
    971           *               @endverbatim
    972           *
    973           *           - (b) For 16-bit values :
    974           *               @verbatim
    975           *                   b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
    976           *                   ---  ---  ---  ---  ---       ---  ---  ---    ----------------
    977           *                   x    x    x    x    x         x    x    1            0
    978           *                   x    x    x    x    x         x    1    0            1
    979           *                   x    x    x    x    x         1    0    0            2
    980           *                   :    :    :    :    :         :    :    :            :
    981           *                   :    :    :    :    :         :    :    :            :
    982           *                   x    x    x    x    1         0    0    0           11
    983           *                   x    x    x    1    0         0    0    0           12
    984           *                   x    x    1    0    0         0    0    0           13
    985           *                   x    1    0    0    0         0    0    0           14
    986           *                   1    0    0    0    0         0    0    0           15
    987           *                   0    0    0    0    0         0    0    0           16
    988           *               @endverbatim
    989           *
    990           *           - (c) For 32-bit values :
    991           *               @verbatim
    992           *                   b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
    993           *                   ---  ---  ---  ---  ---       ---  ---  ---    ----------------
    994           *                   x    x    x    x    x         x    x    1            0
    995           *                   x    x    x    x    x         x    1    0            1
    996           *                   x    x    x    x    x         1    0    0            2
    997           *                   :    :    :    :    :         :    :    :            :
    998           *                   :    :    :    :    :         :    :    :            :
    999           *                   x    x    x    x    1         0    0    0           27
   1000           *                   x    x    x    1    0         0    0    0           28
   1001           *                   x    x    1    0    0         0    0    0           29
   1002           *                   x    1    0    0    0         0    0    0           30
   1003           *                   1    0    0    0    0         0    0    0           31
   1004           *                   0    0    0    0    0         0    0    0           32
   1005           *               @endverbatim
   1006           *
   1007           *           - (d) For 64-bit values :
   1008           *               @verbatim
   1009           *                   b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
   1010           *                   ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1011           *                   x    x    x    x    x         x    x    1            0
   1012           *                   x    x    x    x    x         x    1    0            1
   1013           *                   x    x    x    x    x         1    0    0            2
   1014           *                   :    :    :    :    :         :    :    :            :
   1015           *                   :    :    :    :    :         :    :    :            :
   1016           *                   x    x    x    x    1         0    0    0           59
   1017           *                   x    x    x    1    0         0    0    0           60
   1018           *                   x    x    1    0    0         0    0    0           61
   1019           *                   x    1    0    0    0         0    0    0           62
   1020           *                   1    0    0    0    0         0    0    0           63
   1021           *                   0    0    0    0    0         0    0    0           64
   1022           *               @endverbatim
   1023           *
   1024           * @note     (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1025           *               zero bits is also equivalent to the bit position of the least-significant set bit.
   1026           *
   1027           * @note     (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1028           *           - (a) CPU_CntTrailZeros()'s final conditional statement calculates 'val's number of
   1029           *                   trailing zeros based on its return data size, 'CPU_CFG_DATA_SIZE', & 'val's
   1030           *                   calculated number of lead zeros ONLY if the initial 'val' is non-'0' :
   1031           *                   @verbatim
   1032           *                       if (val != 0u) {
   1033           *                           nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1034           *                       } else {
   1035           *                           nbr_trail_zeros = nbr_lead_zeros;
   1036           *                       }
   1037           *                   @endverbatim
   1038           *                   Therefore, initially validating all non-'0' values avoids having to conditionally
   1039           *                   execute the final 'if' statement.
   1040           *******************************************************************************************************/
   1041          
   1042          #ifndef   CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
   1043          CPU_DATA CPU_CntTrailZeros(CPU_DATA val)
   1044          {
   1045            CPU_DATA val_bit_mask;
   1046            CPU_DATA nbr_lead_zeros;
   1047            CPU_DATA nbr_trail_zeros;
   1048          
   1049            if (val == 0u) {                                              // Rtn ALL val bits as zero'd (see Note #3).
   1050              return (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS);
   1051            }
   1052          
   1053            val_bit_mask = val & ((CPU_DATA) ~val + 1u);                  // Zero/clr all bits EXCEPT least-sig set bit.
   1054            nbr_lead_zeros = CPU_CntLeadZeros(val_bit_mask);              // Cnt  nbr lead  0s.
   1055                                                                          // Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.
   1056            nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1057          
   1058            return (nbr_trail_zeros);
   1059          }
   1060          #endif
   1061          
   1062          /****************************************************************************************************//**
   1063           *                                           CPU_CntTrailZeros08()
   1064           *
   1065           * @brief    Count the number of contiguous, least-significant, trailing zero bits in an 8-bit data value.
   1066           *
   1067           * @param    val     Data value to count trailing zero bits.
   1068           *
   1069           * @return   Number of contiguous, least-significant, trailing zero bits in 'val'.
   1070           *
   1071           * @note     (1) Supports  8-bit values :
   1072           *               @verbatim
   1073           *                           b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
   1074           *                           ---  ---  ---  ---  ---  ---  ---  ---    ----------------
   1075           *                           x    x    x    x    x    x    x    1            0
   1076           *                           x    x    x    x    x    x    1    0            1
   1077           *                           x    x    x    x    x    1    0    0            2
   1078           *                           x    x    x    x    1    0    0    0            3
   1079           *                           x    x    x    1    0    0    0    0            4
   1080           *                           x    x    1    0    0    0    0    0            5
   1081           *                           x    1    0    0    0    0    0    0            6
   1082           *                           1    0    0    0    0    0    0    0            7
   1083           *                           0    0    0    0    0    0    0    0            8
   1084           *               @endverbatim
   1085           *
   1086           * @note     (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1087           *               zero bits is also equivalent to the bit position of the least-significant set bit.
   1088           *
   1089           * @note     (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1090           *           - (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1091           *                   number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1092           *                   If the returned number of zeros exceeds CPU_CntTrailZeros08()'s  8-bit return
   1093           *                   data size, then the returned number of zeros must be offset by the difference
   1094           *                   between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros08()'s return data size :
   1095           *                   @verbatim
   1096           *                       nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1097           *                       if (nbr_trail_zeros >  (CPU_WORD_SIZE_08  * DEF_OCTET_NBR_BITS)) {
   1098           *                           nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
   1099           *                       }
   1100           *                   @endverbatim
   1101           *                   However, this ONLY occurs for an initial 'val' of '0' since all non-'0'  8-bit
   1102           *                   values would return a number of trailing zeros less than or equal to  8 bits.
   1103           *                   @n
   1104           *                   Therefore, initially validating all non-'0' values prior to calling assembly-
   1105           *                   optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1106           *                   trailing zeros by the difference in CPU data size and  8-bit data value bits.
   1107           *           - (b) For CPU_CntTrailZeros08()'s C implementation, the final conditional statement
   1108           *                   calculates 'val's number of trailing zeros based on CPU_CntTrailZeros08()'s
   1109           *                   8-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1110           *                   initial 'val' is non-'0' :
   1111           *                   @verbatim
   1112           *                       if (val != 0u) {
   1113           *                           nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1114           *                       } else {
   1115           *                           nbr_trail_zeros = nbr_lead_zeros;
   1116           *                       }
   1117           *                   @endverbatim
   1118           *                   Therefore, initially validating all non-'0' values avoids having to conditionally
   1119           *                   execute the final 'if' statement.
   1120           *******************************************************************************************************/
   1121          
   1122          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)

   \                                 In section .text, align 2, keep-with-next
   1123          CPU_DATA CPU_CntTrailZeros08(CPU_INT08U val)
   1124          {
   \                     CPU_CntTrailZeros08: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1125          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) \
   1126            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
   1127            CPU_INT08U val_bit_mask;
   1128            CPU_DATA   nbr_lead_zeros;
   1129          #endif
   1130            CPU_DATA nbr_trail_zeros;
   1131          
   1132            if (val == 0u) {                                              // Rtn ALL val bits as zero'd (see Note #3).
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??CPU_CntTrailZeros08_0
   1133              return (CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS);
   \        0xC   0x2008             MOVS     R0,#+8
   \        0xE   0xE003             B.N      ??CPU_CntTrailZeros08_1
   1134            }
   1135          
   1136            //                                                               ------------------ ASM-OPTIMIZED -------------------
   1137          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) \
   1138            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
   1139            nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   \                     ??CPU_CntTrailZeros08_0: (+1)
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0x.... 0x....      BL       CPU_CntTrailZeros
   1140          
   1141          #else //                                                           ------------------- C-OPTIMIZED --------------------
   1142            val_bit_mask = val & ((CPU_INT08U) ~val + 1u);                // Zero/clr all bits EXCEPT least-sig set bit.
   1143            nbr_lead_zeros = CPU_CntLeadZeros08(val_bit_mask);            // Cnt  nbr lead  0s.
   1144                                                                          // Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.
   1145            nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1146          #endif
   1147          
   1148            return (nbr_trail_zeros);
   \                     ??CPU_CntTrailZeros08_1: (+1)
   \       0x18   0xBD10             POP      {R4,PC}
   1149          }
   1150          #endif
   1151          
   1152          /****************************************************************************************************//**
   1153           *                                           CPU_CntTrailZeros16()
   1154           *
   1155           * @brief    Count the number of contiguous, least-significant, trailing zero bits in a 16-bit data value.
   1156           *
   1157           * @param    val     Data value to count trailing zero bits.
   1158           *
   1159           * @return   Number of contiguous, least-significant, trailing zero bits in 'val'.
   1160           *
   1161           * @note     (1) Supports 16-bit values :
   1162           *               @verbatim
   1163           *                       b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
   1164           *                       ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1165           *                       x    x    x    x    x         x    x    1            0
   1166           *                       x    x    x    x    x         x    1    0            1
   1167           *                       x    x    x    x    x         1    0    0            2
   1168           *                       :    :    :    :    :         :    :    :            :
   1169           *                       :    :    :    :    :         :    :    :            :
   1170           *                       x    x    x    x    1         0    0    0           11
   1171           *                       x    x    x    1    0         0    0    0           12
   1172           *                       x    x    1    0    0         0    0    0           13
   1173           *                       x    1    0    0    0         0    0    0           14
   1174           *                       1    0    0    0    0         0    0    0           15
   1175           *                       0    0    0    0    0         0    0    0           16
   1176           *               @endverbatim
   1177           *
   1178           * @note     (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1179           *               zero bits is also equivalent to the bit position of the least-significant set bit.
   1180           *
   1181           * @note     (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1182           *           - (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1183           *                   number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1184           *                   If the returned number of zeros exceeds CPU_CntTrailZeros16()'s 16-bit return
   1185           *                   data size, then the returned number of zeros must be offset by the difference
   1186           *                   between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros16()'s return data size :
   1187           *               @verbatim
   1188           *                       nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1189           *                       if (nbr_trail_zeros >  (CPU_WORD_SIZE_16  * DEF_OCTET_NBR_BITS)) {
   1190           *                           nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
   1191           *                       }
   1192           *               @endverbatim
   1193           *                   However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 16-bit
   1194           *                   values would return a number of trailing zeros less than or equal to 16 bits.
   1195           *                   @n
   1196           *                   Therefore, initially validating all non-'0' values prior to calling assembly-
   1197           *                   optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1198           *                   trailing zeros by the difference in CPU data size and 16-bit data value bits.
   1199           *           - (b) For CPU_CntTrailZeros16()'s C implementation, the final conditional statement
   1200           *                   calculates 'val's number of trailing zeros based on CPU_CntTrailZeros16()'s
   1201           *                   16-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1202           *                   initial 'val' is non-'0' :
   1203           *                   @verbatim
   1204           *                       if (val != 0u) {
   1205           *                           nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1206           *                       } else {
   1207           *                           nbr_trail_zeros = nbr_lead_zeros;
   1208           *                       }
   1209           *                   @endverbatim
   1210           *                   Therefore, initially validating all non-'0' values avoids having to conditionally
   1211           *                   execute the final 'if' statement.
   1212           *******************************************************************************************************/
   1213          
   1214          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)

   \                                 In section .text, align 2, keep-with-next
   1215          CPU_DATA CPU_CntTrailZeros16(CPU_INT16U val)
   1216          {
   \                     CPU_CntTrailZeros16: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1217          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) \
   1218            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
   1219            CPU_INT16U val_bit_mask;
   1220            CPU_DATA   nbr_lead_zeros;
   1221          #endif
   1222            CPU_DATA nbr_trail_zeros;
   1223          
   1224            if (val == 0u) {                                              // Rtn ALL val bits as zero'd (see Note #3).
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB280             UXTH     R0,R0
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??CPU_CntTrailZeros16_0
   1225              return (CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS);
   \        0xC   0x2010             MOVS     R0,#+16
   \        0xE   0xE003             B.N      ??CPU_CntTrailZeros16_1
   1226            }
   1227          
   1228            //                                                               ------------------ ASM-OPTIMIZED -------------------
   1229          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) \
   1230            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
   1231            nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   \                     ??CPU_CntTrailZeros16_0: (+1)
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x.... 0x....      BL       CPU_CntTrailZeros
   1232          
   1233          #else //                                                           ------------------- C-OPTIMIZED --------------------
   1234            val_bit_mask = val & ((CPU_INT16U) ~val + 1u);                // Zero/clr all bits EXCEPT least-sig set bit.
   1235            nbr_lead_zeros = CPU_CntLeadZeros16(val_bit_mask);            // Cnt  nbr lead  0s.
   1236                                                                          // Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.
   1237            nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1238          #endif
   1239          
   1240            return (nbr_trail_zeros);
   \                     ??CPU_CntTrailZeros16_1: (+1)
   \       0x18   0xBD10             POP      {R4,PC}
   1241          }
   1242          #endif
   1243          
   1244          /****************************************************************************************************//**
   1245           *                                           CPU_CntTrailZeros32()
   1246           *
   1247           * @brief    Count the number of contiguous, least-significant, trailing zero bits in a 32-bit data value.
   1248           *
   1249           * @param    val     Data value to count trailing zero bits.
   1250           *
   1251           * @return   Number of contiguous, least-significant, trailing zero bits in 'val'.
   1252           *
   1253           * @note     (1) Supports 32-bit values :
   1254           *               @verbatim
   1255           *                       b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
   1256           *                       ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1257           *                       x    x    x    x    x         x    x    1            0
   1258           *                       x    x    x    x    x         x    1    0            1
   1259           *                       x    x    x    x    x         1    0    0            2
   1260           *                       :    :    :    :    :         :    :    :            :
   1261           *                       :    :    :    :    :         :    :    :            :
   1262           *                       x    x    x    x    1         0    0    0           27
   1263           *                       x    x    x    1    0         0    0    0           28
   1264           *                       x    x    1    0    0         0    0    0           29
   1265           *                       x    1    0    0    0         0    0    0           30
   1266           *                       1    0    0    0    0         0    0    0           31
   1267           *                       0    0    0    0    0         0    0    0           32
   1268           *               @endverbatim
   1269           *
   1270           * @note     (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1271           *               zero bits is also equivalent to the bit position of the least-significant set bit.
   1272           *
   1273           * @note     (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1274           *           - (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1275           *                   number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1276           *                   If the returned number of zeros exceeds CPU_CntTrailZeros32()'s 32-bit return
   1277           *                   data size, then the returned number of zeros must be offset by the difference
   1278           *                   between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros32()'s return data size :
   1279           *                   @verbatim
   1280           *                       nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1281           *                       if (nbr_trail_zeros >  (CPU_WORD_SIZE_32  * DEF_OCTET_NBR_BITS)) {
   1282           *                           nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
   1283           *                       }
   1284           *                   @endverbatim
   1285           *                   However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 32-bit
   1286           *                   values would return a number of trailing zeros less than or equal to 32 bits.
   1287           *                   @n
   1288           *                   Therefore, initially validating all non-'0' values prior to calling assembly-
   1289           *                   optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1290           *                   trailing zeros by the difference in CPU data size and 32-bit data value bits.
   1291           *
   1292           *           - (b) For CPU_CntTrailZeros32()'s C implementation, the final conditional statement
   1293           *                   calculates 'val's number of trailing zeros based on CPU_CntTrailZeros32()'s
   1294           *                   32-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1295           *                   initial 'val' is non-'0' :
   1296           *                   @verbatim
   1297           *                       if (val != 0u) {
   1298           *                           nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1299           *                       } else {
   1300           *                           nbr_trail_zeros = nbr_lead_zeros;
   1301           *                       }
   1302           *                   @endverbatim
   1303           *                   Therefore, initially validating all non-'0' values avoids having to conditionally
   1304           *                   execute the final 'if' statement.
   1305           *******************************************************************************************************/
   1306          
   1307          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)

   \                                 In section .text, align 2, keep-with-next
   1308          CPU_DATA CPU_CntTrailZeros32(CPU_INT32U val)
   1309          {
   \                     CPU_CntTrailZeros32: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1310          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) \
   1311            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
   1312            CPU_INT32U val_bit_mask;
   1313            CPU_DATA   nbr_lead_zeros;
   1314          #endif
   1315            CPU_DATA nbr_trail_zeros;
   1316          
   1317            if (val == 0u) {                                              // Rtn ALL val bits as zero'd (see Note #3).
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??CPU_CntTrailZeros32_0
   1318              return (CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS);
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xE002             B.N      ??CPU_CntTrailZeros32_1
   1319            }
   1320          
   1321            //                                                               ------------------ ASM-OPTIMIZED -------------------
   1322          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) \
   1323            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
   1324            nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   \                     ??CPU_CntTrailZeros32_0: (+1)
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       CPU_CntTrailZeros
   1325          
   1326          #else //                                                           ------------------- C-OPTIMIZED --------------------
   1327            val_bit_mask = val & ((CPU_INT32U) ~val + 1u);                // Zero/clr all bits EXCEPT least-sig set bit.
   1328            nbr_lead_zeros = CPU_CntLeadZeros32(val_bit_mask);            // Cnt  nbr lead  0s.
   1329                                                                          // Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.
   1330            nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1331          #endif
   1332          
   1333            return (nbr_trail_zeros);
   \                     ??CPU_CntTrailZeros32_1: (+1)
   \       0x12   0xBD10             POP      {R4,PC}
   1334          }
   1335          #endif
   1336          
   1337          /****************************************************************************************************//**
   1338           *                                           CPU_CntTrailZeros64()
   1339           *
   1340           * @brief    Count the number of contiguous, least-significant, trailing zero bits in a 64-bit data value.
   1341           *
   1342           * @param    val     Data value to count trailing zero bits.
   1343           *
   1344           * @return   Number of contiguous, least-significant, trailing zero bits in 'val'.
   1345           *
   1346           * @note     (1) Supports 64-bit values :
   1347           *               @verbatim
   1348           *                       b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
   1349           *                       ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1350           *                       x    x    x    x    x         x    x    1            0
   1351           *                       x    x    x    x    x         x    1    0            1
   1352           *                       x    x    x    x    x         1    0    0            2
   1353           *                       :    :    :    :    :         :    :    :            :
   1354           *                       :    :    :    :    :         :    :    :            :
   1355           *                       x    x    x    x    1         0    0    0           59
   1356           *                       x    x    x    1    0         0    0    0           60
   1357           *                       x    x    1    0    0         0    0    0           61
   1358           *                       x    1    0    0    0         0    0    0           62
   1359           *                       1    0    0    0    0         0    0    0           63
   1360           *                       0    0    0    0    0         0    0    0           64
   1361           *               @endverbatim
   1362           *
   1363           * @note     (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1364           *               zero bits is also equivalent to the bit position of the least-significant set bit.
   1365           *
   1366           * @note     (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1367           *           - (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1368           *                   number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1369           *                   If the returned number of zeros exceeds CPU_CntTrailZeros64()'s 64-bit return
   1370           *                   data size, then the returned number of zeros must be offset by the difference
   1371           *                   between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros64()'s return data size :
   1372           *                   @verbatim
   1373           *                       nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1374           *                       if (nbr_trail_zeros >  (CPU_WORD_SIZE_64  * DEF_OCTET_NBR_BITS)) {
   1375           *                           nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
   1376           *                       }
   1377           *                   @endverbatim
   1378           *                   However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 64-bit
   1379           *                   values would return a number of trailing zeros less than or equal to 64 bits.
   1380           *                   @n
   1381           *                   Therefore, initially validating all non-'0' values prior to calling assembly-
   1382           *                   optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1383           *                   trailing zeros by the difference in CPU data size and 64-bit data value bits.
   1384           *
   1385           *           - (b) For CPU_CntTrailZeros64()'s C implementation, the final conditional statement
   1386           *                   calculates 'val's number of trailing zeros based on CPU_CntTrailZeros64()'s
   1387           *                   64-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1388           *                   initial 'val' is non-'0' :
   1389           *                   @verbatim
   1390           *                       if (val != 0u) {
   1391           *                           nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1392           *                       } else {
   1393           *                           nbr_trail_zeros = nbr_lead_zeros;
   1394           *                       }
   1395           *                   @endverbatim
   1396           *                   Therefore, initially validating all non-'0' values avoids having to conditionally
   1397           *                   execute the final 'if' statement.
   1398           *******************************************************************************************************/
   1399          
   1400          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)

   \                                 In section .text, align 2, keep-with-next
   1401          CPU_DATA CPU_CntTrailZeros64(CPU_INT64U val)
   1402          {
   \                     CPU_CntTrailZeros64: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1403          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) \
   1404            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
   1405            CPU_INT64U val_bit_mask;
   1406            CPU_DATA   nbr_lead_zeros;
   1407          #endif
   1408            CPU_DATA nbr_trail_zeros;
   1409          
   1410            if (val == 0u) {                                              // Rtn ALL val bits as zero'd (see Note #3).
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD103             BNE.N    ??CPU_CntTrailZeros64_0
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??CPU_CntTrailZeros64_0
   1411              return (CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS);
   \        0xE   0x2040             MOVS     R0,#+64
   \       0x10   0xE00F             B.N      ??CPU_CntTrailZeros64_1
   1412            }
   1413          
   1414            //                                                               ------------------ ASM-OPTIMIZED -------------------
   1415          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) \
   1416            && (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
   1417            nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1418          
   1419          #else //                                                           ------------------- C-OPTIMIZED --------------------
   1420            val_bit_mask = val & ((CPU_INT64U) ~val + 1u);                // Zero/clr all bits EXCEPT least-sig set bit.
   \                     ??CPU_CntTrailZeros64_0: (+1)
   \       0x12   0x43E0             MVNS     R0,R4
   \       0x14   0x43E9             MVNS     R1,R5
   \       0x16   0x1C40             ADDS     R0,R0,#+1
   \       0x18   0xF171 0x31FF      SBCS     R1,R1,#+4294967295
   \       0x1C   0xEA14 0x0600      ANDS     R6,R4,R0
   \       0x20   0xEA15 0x0701      ANDS     R7,R5,R1
   1421            nbr_lead_zeros = CPU_CntLeadZeros64(val_bit_mask);            // Cnt  nbr lead  0s.
   \       0x24   0x0030             MOVS     R0,R6
   \       0x26   0x0039             MOVS     R1,R7
   \       0x28   0x.... 0x....      BL       CPU_CntLeadZeros64
   \       0x2C   0x0001             MOVS     R1,R0
   1422                                                                          // Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.
   1423            nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   \       0x2E   0xF1D1 0x003F      RSBS     R0,R1,#+63
   1424          #endif
   1425          
   1426            return (nbr_trail_zeros);
   \                     ??CPU_CntTrailZeros64_1: (+1)
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}
   1427          }
   1428          #endif
   1429          
   1430          /****************************************************************************************************//**
   1431           *                                               CPU_PopCnt32()
   1432           *
   1433           * @brief    Compute population count (hamming weight) for value (number of bits set).
   1434           *
   1435           * @param    value   Value to compute population count on.
   1436           *
   1437           * @return   Value's population count.
   1438           *
   1439           * @note     (1) Algorithm taken from http://en.wikipedia.org/wiki/Hamming_weight
   1440           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1441          CPU_INT08U CPU_PopCnt32(CPU_INT32U value)
   1442          {
   \                     CPU_PopCnt32: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x4686             MOV      LR,R0
   1443            CPU_INT32U even_cnt;
   1444            CPU_INT32U odd_cnt;
   1445            CPU_INT32U result;
   1446          
   1447            odd_cnt = (value >> 1u) & CRC_UTIL_POPCNT_MASK01010101_32;    // 2-bits pieces.
   \        0x4   0x4672             MOV      R2,LR
   \        0x6   0x0852             LSRS     R2,R2,#+1
   \        0x8   0xF032 0x32AA      BICS     R2,R2,#0xAAAAAAAA
   1448            result = value - odd_cnt;                                     // Same result as result=odd_cnt+(value & 0x55555555).
   \        0xC   0xEBBE 0x0302      SUBS     R3,LR,R2
   1449          
   1450            even_cnt = result & CRC_UTIL_POPCNT_MASK00110011_32;          // 4-bits pieces.
   \       0x10   0xF033 0x34CC      BICS     R4,R3,#0xCCCCCCCC
   1451            odd_cnt = (result >> 2u) & CRC_UTIL_POPCNT_MASK00110011_32;
   \       0x14   0x001D             MOVS     R5,R3
   \       0x16   0x08AD             LSRS     R5,R5,#+2
   \       0x18   0xF035 0x35CC      BICS     R5,R5,#0xCCCCCCCC
   1452            result = even_cnt + odd_cnt;
   \       0x1C   0x192E             ADDS     R6,R5,R4
   1453          
   1454            even_cnt = result & CRC_UTIL_POPCNT_MASK00001111_32;          // 8-bits pieces.
   \       0x1E   0xF036 0x37F0      BICS     R7,R6,#0xF0F0F0F0
   1455            odd_cnt = (result >> 4u) & CRC_UTIL_POPCNT_MASK00001111_32;
   \       0x22   0x46B4             MOV      R12,R6
   \       0x24   0xEA5F 0x1C1C      LSRS     R12,R12,#+4
   \       0x28   0xF03C 0x3CF0      BICS     R12,R12,#0xF0F0F0F0
   1456            result = even_cnt + odd_cnt;
   \       0x2C   0xEB1C 0x0007      ADDS     R0,R12,R7
   1457          
   1458            result = (result * CRC_UTIL_POPCNT_POWERSOF256_32) >> 24u;
   \       0x30   0xF05F 0x3101      MOVS     R1,#+16843009
   \       0x34   0x4348             MULS     R0,R1,R0
   \       0x36   0x0E00             LSRS     R0,R0,#+24
   1459          
   1460            return ((CPU_INT08U)result);
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0xBDF0             POP      {R4-R7,PC}
   1461          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     `CPU_TS_TmrFreqGet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     CPU_CntLeadZerosTbl

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x63, 0x70, 0x75, 0x5C, 0x73
   \              0x5C 0x63    
   \              0x70 0x75    
   \              0x5C 0x73
   \       0x58   0x6F 0x75          DC8 0x6F, 0x75, 0x72, 0x63, 0x65, 0x5C, 0x63, 0x70
   \              0x72 0x63    
   \              0x65 0x5C    
   \              0x63 0x70
   \       0x60   0x75 0x5F          DC8 0x75, 0x5F, 0x63, 0x6F, 0x72, 0x65, 0x2E, 0x63
   \              0x63 0x6F    
   \              0x72 0x65    
   \              0x2E 0x63
   \       0x68   0x00               DC8 0
   \       0x69                      DS8 3
   1462          
   1463          /********************************************************************************************************
   1464           ********************************************************************************************************
   1465           *                                               LOCAL FUNCTIONS
   1466           ********************************************************************************************************
   1467           *******************************************************************************************************/
   1468          
   1469          /****************************************************************************************************//**
   1470           *                                               CPU_NameInit()
   1471           *
   1472           * @brief    Initialize CPU Name.
   1473           *******************************************************************************************************/
   1474          
   1475          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
   1476          static void CPU_NameInit(void)
   1477          {
   1478            CPU_NameClr();
   1479          }
   1480          #endif
   1481          
   1482          /****************************************************************************************************//**
   1483           *                                               CPU_TS_Init()
   1484           *
   1485           * @brief    (1) Initialize CPU timestamp :
   1486           *               - (a) Initialize/start CPU timestamp timer                            See Note #1
   1487           *               - (b) Initialize       CPU timestamp controls
   1488           *
   1489           * @note     (1) The following initialization MUST be sequenced as follows :
   1490           *               - (a) CPU_TS_TmrFreq_Hz     MUST be initialized prior to CPU_TS_TmrInit()
   1491           *               - (b) CPU_TS_TmrInit()      SHOULD precede calls to all other CPU timestamp functions;
   1492           *                                               otherwise, invalid time measurements may be calculated/
   1493           *                                               returned.
   1494           *               See also 'CPU_Init()  Note #3a'.
   1495           *******************************************************************************************************/
   1496          
   1497          #if ((CPU_CFG_TS_EN == DEF_ENABLED) \
   1498            || (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
   1499          static void CPU_TS_Init(void)
   1500          {
   1501          #if (((CPU_CFG_TS_32_EN == DEF_ENABLED)        \
   1502            && (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_32)) \
   1503            || ((CPU_CFG_TS_64_EN == DEF_ENABLED)        \
   1504            && (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_64)))
   1505            CPU_TS_TMR ts_tmr_cnts;
   1506          #endif
   1507          
   1508            //                                                               ----------------- INIT CPU TS TMR ------------------
   1509          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
   1510            CPU_TS_TmrFreq_Hz = 0u;                                       // Init/clr     ts tmr freq (see Note #1a).
   1511            CPU_TS_TmrInit();                                             // Init & start ts tmr      (see Note #1b).
   1512          #endif
   1513          
   1514            //                                                               ------------------- INIT CPU TS --------------------
   1515          #if (((CPU_CFG_TS_32_EN == DEF_ENABLED)        \
   1516            && (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_32)) \
   1517            || ((CPU_CFG_TS_64_EN == DEF_ENABLED)        \
   1518            && (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_64)))
   1519            ts_tmr_cnts = CPU_TS_TmrRd();                                 // Get init ts tmr val (in ts tmr cnts).
   1520          #endif
   1521          
   1522          #if  ((CPU_CFG_TS_32_EN == DEF_ENABLED) \
   1523            && (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_32))
   1524            CPU_TS_32_Accum = 0u;                                         // Init 32-bit accum'd ts.
   1525            CPU_TS_32_TmrPrev = ts_tmr_cnts;                              // Init 32-bit ts prev tmr val.
   1526          #endif
   1527          
   1528          #if  ((CPU_CFG_TS_64_EN == DEF_ENABLED) \
   1529            && (CPU_CFG_TS_TMR_SIZE < CPU_WORD_SIZE_64))
   1530            CPU_TS_64_Accum = 0u;                                         // Init 64-bit accum'd ts.
   1531            CPU_TS_64_TmrPrev = ts_tmr_cnts;                              // Init 64-bit ts prev tmr val.
   1532          #endif
   1533          }
   1534          #endif
   1535          
   1536          /****************************************************************************************************//**
   1537           *                                         CPU_RevBits()
   1538           * @brief    Reverses the bits in a data value.
   1539           *
   1540           * @param    val     Data value to reverse bits.
   1541           *
   1542           * @return   Value with all bits in 'val' reversed (see Note #1).
   1543           *
   1544           *               This function is an INTERNAL CPU module function but MAY be called by application function(s).
   1545           *
   1546           * @note     (1) val is a 32-bit number
   1547           *
   1548           * @note     (2) Goes through a number and checks for sets bits which are then set
   1549           *               in the reverse locations:
   1550           *
   1551           *               reverse_val                 =>     0b00000....00
   1552           *               val                         =>     0101100....10
   1553           *               val's 2nd bit is set        =>     reverse_val's bit (num_bits - 1 - count)
   1554           *               val's 5th bit is set        =>     reverse_val's bit (num_bits - 1 - count)
   1555           *               ...                                ...
   1556           *               ...                                ...
   1557           *
   1558           *******************************************************************************************************/
   1559          
   1560          #ifndef  CPU_CFG_REVERSE_BIT_ASM_PRESENT
   1561          CPU_DATA CPU_RevBits(CPU_DATA val)
   1562          {
   1563            CPU_DATA   reverse_val;
   1564            CPU_INT08U nbr_bits;                                          // establish how many bits are in val
   1565            CPU_INT32U cnt;                                               // for stepping through each bit in val
   1566            CPU_INT32U tmp;                                               // gets shifted off bit to check if set or not
   1567          
   1568            nbr_bits = sizeof(CPU_DATA) * 8;
   1569            reverse_val = 0;                                              // make sure reverse_val is cleared out to zeros
   1570          
   1571            for (cnt = 0; cnt < nbr_bits; cnt++) {
   1572              tmp = (val & (1 << cnt));                                   // shift the next bit into tmp
   1573          
   1574              if (tmp) {
   1575                reverse_val |= (1 << ((nbr_bits - 1) - cnt));             // shift in a 1 bit to reverse equivalent bit
   1576              }
   1577            }
   1578          
   1579            return (reverse_val);
   1580          }
   1581          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CPU_Break
       8   CPU_CntLeadZeros08
         8   -> CPU_CntLeadZeros
       8   CPU_CntLeadZeros16
         8   -> CPU_CntLeadZeros
       8   CPU_CntLeadZeros32
         8   -> CPU_CntLeadZeros
       8   CPU_CntLeadZeros64
       8   CPU_CntTrailZeros08
         8   -> CPU_CntTrailZeros
       8   CPU_CntTrailZeros16
         8   -> CPU_CntTrailZeros
       8   CPU_CntTrailZeros32
         8   -> CPU_CntTrailZeros
      24   CPU_CntTrailZeros64
        24   -> CPU_CntLeadZeros64
       0   CPU_Init
      20   CPU_PopCnt32
       0   CPU_SW_Exception
       8   CPU_TS_TmrFreqGet
         8   -> CPU_SW_Exception
       0   CPU_TS_TmrFreqSet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
     108  ?_0
       2  CPU_Break
      16  CPU_CntLeadZeros08
      16  CPU_CntLeadZeros16
      12  CPU_CntLeadZeros32
     232  CPU_CntLeadZeros64
     256  CPU_CntLeadZerosTbl
      26  CPU_CntTrailZeros08
      26  CPU_CntTrailZeros16
      20  CPU_CntTrailZeros32
      52  CPU_CntTrailZeros64
       4  CPU_EndiannessTest
       2  CPU_Init
      60  CPU_PopCnt32
       2  CPU_SW_Exception
      34  CPU_TS_TmrFreqGet
       2  CPU_TS_TmrFreqSet
      20  -- Other

 
 388 bytes in section .rodata
 514 bytes in section .text
 
 514 bytes of CODE  memory
 388 bytes of CONST memory

Errors: none
Warnings: none
