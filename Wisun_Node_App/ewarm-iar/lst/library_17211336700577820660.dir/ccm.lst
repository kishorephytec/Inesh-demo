###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:41
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ccm.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ccm.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ccm.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ccm.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\ccm.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ccm.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ccm.c
      1          /*
      2           *  NIST SP800-38C compliant CCM implementation
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           * Definition of CCM:
     22           * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf
     23           * RFC 3610 "Counter with CBC-MAC (CCM)"
     24           *
     25           * Related:
     26           * RFC 5116 "An Interface and Algorithms for Authenticated Encryption"
     27           */
     28          
     29          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint32_t mbedtls_get_unaligned_uint32(void const *)
   \                     mbedtls_get_unaligned_uint32: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2404             MOVS     R4,#+4
   \        0x6   0x003D             MOVS     R5,R7
   \        0x8   0x466E             MOV      R6,SP
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint32(void *, uint32_t)
   \                     mbedtls_put_unaligned_uint32: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2404             MOVS     R4,#+4
   \        0x6   0x466D             MOV      R5,SP
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2
   \   __vfp void mbedtls_xor(unsigned char *, unsigned char const *, unsigned char const *, size_t)
   \                     mbedtls_xor: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??mbedtls_xor_0: (+1)
   \       0x10   0xF118 0x0004      ADDS     R0,R8,#+4
   \       0x14   0x4287             CMP      R7,R0
   \       0x16   0xD313             BCC.N    ??mbedtls_xor_1
   \       0x18   0xEB05 0x0008      ADD      R0,R5,R8
   \       0x1C   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x20   0x4681             MOV      R9,R0
   \       0x22   0xEB06 0x0008      ADD      R0,R6,R8
   \       0x26   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x2A   0x4682             MOV      R10,R0
   \       0x2C   0xEA9A 0x0A09      EORS     R10,R10,R9
   \       0x30   0x4651             MOV      R1,R10
   \       0x32   0xEB04 0x0008      ADD      R0,R4,R8
   \       0x36   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
   \       0x3A   0xF118 0x0804      ADDS     R8,R8,#+4
   \       0x3E   0xE7E7             B.N      ??mbedtls_xor_0
   \                     ??mbedtls_xor_1: (+1)
   \       0x40   0x45B8             CMP      R8,R7
   \       0x42   0xD209             BCS.N    ??mbedtls_xor_2
   \       0x44   0xF815 0x1008      LDRB     R1,[R5, R8]
   \       0x48   0xF816 0x0008      LDRB     R0,[R6, R8]
   \       0x4C   0x4041             EORS     R1,R0,R1
   \       0x4E   0xF804 0x1008      STRB     R1,[R4, R8]
   \       0x52   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x56   0xE7F3             B.N      ??mbedtls_xor_1
   \                     ??mbedtls_xor_2: (+1)
   \       0x58   0xE8BD 0x87F0      POP      {R4-R10,PC}
     30          
     31          #if defined(MBEDTLS_CCM_C)
     32          
     33          #include "mbedtls/ccm.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_cipher_info_get_block_size(mbedtls_cipher_info_t const *)
   \                     mbedtls_cipher_info_get_block_size: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD101             BNE.N    ??mbedtls_cipher_info_get_block_size_0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE002             B.N      ??mbedtls_cipher_info_get_block_size_1
   \                     ??mbedtls_cipher_info_get_block_size_0: (+1)
   \        0xA   0x7908             LDRB     R0,[R1, #+4]
   \        0xC   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \                     ??mbedtls_cipher_info_get_block_size_1: (+1)
   \       0x10   0x4770             BX       LR
     34          #include "mbedtls/platform_util.h"
     35          #include "mbedtls/error.h"
     36          #include "mbedtls/constant_time.h"
     37          
     38          #include <string.h>
     39          
     40          #if defined(MBEDTLS_PLATFORM_C)
     41          #include "mbedtls/platform.h"
     42          #else
     43          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
     44          #include <stdio.h>
     45          #define mbedtls_printf printf
     46          #endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
     47          #endif /* MBEDTLS_PLATFORM_C */
     48          
     49          #if !defined(MBEDTLS_CCM_ALT)
     50          
     51          
     52          /*
     53           * Initialize context
     54           */

   \                                 In section .text, align 2, keep-with-next
     55          void mbedtls_ccm_init(mbedtls_ccm_context *ctx)
     56          {
   \                     mbedtls_ccm_init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
     57              memset(ctx, 0, sizeof(mbedtls_ccm_context));
   \        0x4   0x2484             MOVS     R4,#+132
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memset
     58          }
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}
     59          

   \                                 In section .text, align 2, keep-with-next
     60          int mbedtls_ccm_setkey(mbedtls_ccm_context *ctx,
     61                                 mbedtls_cipher_id_t cipher,
     62                                 const unsigned char *key,
     63                                 unsigned int keybits)
     64          {
   \                     mbedtls_ccm_setkey: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
     65              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x0A6D      MVNS     R10,#+109
     66              const mbedtls_cipher_info_t *cipher_info;
     67          
     68              cipher_info = mbedtls_cipher_info_from_values(cipher, keybits,
     69                                                            MBEDTLS_MODE_ECB);
   \       0x10   0x2201             MOVS     R2,#+1
   \       0x12   0x0039             MOVS     R1,R7
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x.... 0x....      BL       mbedtls_cipher_info_from_values
   \       0x1C   0x0004             MOVS     R4,R0
     70              if (cipher_info == NULL) {
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD102             BNE.N    ??mbedtls_ccm_setkey_0
     71                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x22   0xF07F 0x000C      MVNS     R0,#+12
   \       0x26   0xE022             B.N      ??mbedtls_ccm_setkey_1
     72              }
     73          
     74              if (mbedtls_cipher_info_get_block_size(cipher_info) != 16) {
   \                     ??mbedtls_ccm_setkey_0: (+1)
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       mbedtls_cipher_info_get_block_size
   \       0x2E   0x2810             CMP      R0,#+16
   \       0x30   0xD002             BEQ.N    ??mbedtls_ccm_setkey_2
     75                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x32   0xF07F 0x000C      MVNS     R0,#+12
   \       0x36   0xE01A             B.N      ??mbedtls_ccm_setkey_1
     76              }
     77          
     78              mbedtls_cipher_free(&ctx->cipher_ctx);
   \                     ??mbedtls_ccm_setkey_2: (+1)
   \       0x38   0xF119 0x0038      ADDS     R0,R9,#+56
   \       0x3C   0x.... 0x....      BL       mbedtls_cipher_free
     79          
     80              if ((ret = mbedtls_cipher_setup(&ctx->cipher_ctx, cipher_info)) != 0) {
   \       0x40   0x0021             MOVS     R1,R4
   \       0x42   0xF119 0x0038      ADDS     R0,R9,#+56
   \       0x46   0x.... 0x....      BL       mbedtls_cipher_setup
   \       0x4A   0x4680             MOV      R8,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD001             BEQ.N    ??mbedtls_ccm_setkey_3
     81                  return ret;
   \       0x50   0x4640             MOV      R0,R8
   \       0x52   0xE00C             B.N      ??mbedtls_ccm_setkey_1
     82              }
     83          
     84              if ((ret = mbedtls_cipher_setkey(&ctx->cipher_ctx, key, keybits,
     85                                               MBEDTLS_ENCRYPT)) != 0) {
   \                     ??mbedtls_ccm_setkey_3: (+1)
   \       0x54   0x2301             MOVS     R3,#+1
   \       0x56   0x003A             MOVS     R2,R7
   \       0x58   0x0031             MOVS     R1,R6
   \       0x5A   0xF119 0x0038      ADDS     R0,R9,#+56
   \       0x5E   0x.... 0x....      BL       mbedtls_cipher_setkey
   \       0x62   0x0001             MOVS     R1,R0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD001             BEQ.N    ??mbedtls_ccm_setkey_4
     86                  return ret;
   \       0x68   0x0008             MOVS     R0,R1
   \       0x6A   0xE000             B.N      ??mbedtls_ccm_setkey_1
     87              }
     88          
     89              return 0;
   \                     ??mbedtls_ccm_setkey_4: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_setkey_1: (+1)
   \       0x6E   0xE8BD 0x87F0      POP      {R4-R10,PC}
     90          }
     91          
     92          /*
     93           * Free context
     94           */

   \                                 In section .text, align 2, keep-with-next
     95          void mbedtls_ccm_free(mbedtls_ccm_context *ctx)
     96          {
   \                     mbedtls_ccm_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     97              if (ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD007             BEQ.N    ??mbedtls_ccm_free_0
     98                  return;
     99              }
    100              mbedtls_cipher_free(&ctx->cipher_ctx);
   \                     ??mbedtls_ccm_free_1: (+1)
   \        0x8   0xF114 0x0038      ADDS     R0,R4,#+56
   \        0xC   0x.... 0x....      BL       mbedtls_cipher_free
    101              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_ccm_context));
   \       0x10   0x2184             MOVS     R1,#+132
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       mbedtls_platform_zeroize
    102          }
   \                     ??mbedtls_ccm_free_0: (+1)
   \       0x18   0xBD10             POP      {R4,PC}
    103          
    104          #define CCM_STATE__CLEAR                0
    105          #define CCM_STATE__STARTED              (1 << 0)
    106          #define CCM_STATE__LENGTHS_SET          (1 << 1)
    107          #define CCM_STATE__AUTH_DATA_STARTED    (1 << 2)
    108          #define CCM_STATE__AUTH_DATA_FINISHED   (1 << 3)
    109          #define CCM_STATE__ERROR                (1 << 4)
    110          
    111          /*
    112           * Encrypt or decrypt a partial block with CTR
    113           */

   \                                 In section .text, align 2, keep-with-next
    114          static int mbedtls_ccm_crypt(mbedtls_ccm_context *ctx,
    115                                       size_t offset, size_t use_len,
    116                                       const unsigned char *input,
    117                                       unsigned char *output)
    118          {
   \                     mbedtls_ccm_crypt: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
   \        0xE   0x9F0E             LDR      R7,[SP, #+56]
    119              size_t olen = 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x9001             STR      R0,[SP, #+4]
    120              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x14   0xF07F 0x086D      MVNS     R8,#+109
   \       0x18   0x2110             MOVS     R1,#+16
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0xF10D 0x0A08      ADD      R10,SP,#+8
   \       0x20   0x4650             MOV      R0,R10
   \       0x22   0x.... 0x....      BL       __aeabi_memset
    121              unsigned char tmp_buf[16] = { 0 };
    122          
    123              if ((ret = mbedtls_cipher_update(&ctx->cipher_ctx, ctx->ctr, 16, tmp_buf,
    124                                               &olen)) != 0) {
   \       0x26   0xA801             ADD      R0,SP,#+4
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0xAB02             ADD      R3,SP,#+8
   \       0x2C   0x2210             MOVS     R2,#+16
   \       0x2E   0xF119 0x0110      ADDS     R1,R9,#+16
   \       0x32   0xF119 0x0038      ADDS     R0,R9,#+56
   \       0x36   0x.... 0x....      BL       mbedtls_cipher_update
   \       0x3A   0x4682             MOV      R10,R0
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD00B             BEQ.N    ??mbedtls_ccm_crypt_0
    125                  ctx->state |= CCM_STATE__ERROR;
   \       0x40   0xF8D9 0x0080      LDR      R0,[R9, #+128]
   \       0x44   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x48   0xF8C9 0x0080      STR      R0,[R9, #+128]
    126                  mbedtls_platform_zeroize(tmp_buf, sizeof(tmp_buf));
   \       0x4C   0x2110             MOVS     R1,#+16
   \       0x4E   0xA802             ADD      R0,SP,#+8
   \       0x50   0x.... 0x....      BL       mbedtls_platform_zeroize
    127                  return ret;
   \       0x54   0x4650             MOV      R0,R10
   \       0x56   0xE00C             B.N      ??mbedtls_ccm_crypt_1
    128              }
    129          
    130              mbedtls_xor(output, input, tmp_buf + offset, use_len);
   \                     ??mbedtls_ccm_crypt_0: (+1)
   \       0x58   0x002B             MOVS     R3,R5
   \       0x5A   0xA802             ADD      R0,SP,#+8
   \       0x5C   0xEB00 0x0204      ADD      R2,R0,R4
   \       0x60   0x0031             MOVS     R1,R6
   \       0x62   0x0038             MOVS     R0,R7
   \       0x64   0x.... 0x....      BL       mbedtls_xor
    131          
    132              mbedtls_platform_zeroize(tmp_buf, sizeof(tmp_buf));
   \       0x68   0x2110             MOVS     R1,#+16
   \       0x6A   0xA802             ADD      R0,SP,#+8
   \       0x6C   0x.... 0x....      BL       mbedtls_platform_zeroize
    133              return ret;
   \       0x70   0x4650             MOV      R0,R10
   \                     ??mbedtls_ccm_crypt_1: (+1)
   \       0x72   0xB006             ADD      SP,SP,#+24
   \       0x74   0xE8BD 0x87F0      POP      {R4-R10,PC}
    134          }
    135          

   \                                 In section .text, align 2, keep-with-next
    136          static void mbedtls_ccm_clear_state(mbedtls_ccm_context *ctx)
    137          {
   \                     mbedtls_ccm_clear_state: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
    138              ctx->state = CCM_STATE__CLEAR;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xF8C4 0x0080      STR      R0,[R4, #+128]
    139              memset(ctx->y, 0, 16);
   \        0xC   0x2510             MOVS     R5,#+16
   \        0xE   0x2600             MOVS     R6,#+0
   \       0x10   0x0027             MOVS     R7,R4
   \       0x12   0x0032             MOVS     R2,R6
   \       0x14   0x0029             MOVS     R1,R5
   \       0x16   0x0038             MOVS     R0,R7
   \       0x18   0x.... 0x....      BL       __aeabi_memset
    140              memset(ctx->ctr, 0, 16);
   \       0x1C   0xF05F 0x0910      MOVS     R9,#+16
   \       0x20   0x2700             MOVS     R7,#+0
   \       0x22   0xF114 0x0810      ADDS     R8,R4,#+16
   \       0x26   0x003A             MOVS     R2,R7
   \       0x28   0x4649             MOV      R1,R9
   \       0x2A   0x4640             MOV      R0,R8
   \       0x2C   0x.... 0x....      BL       __aeabi_memset
    141          }
   \       0x30   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
    142          

   \                                 In section .text, align 2, keep-with-next
    143          static int ccm_calculate_first_block_if_ready(mbedtls_ccm_context *ctx)
    144          {
   \                     ccm_calculate_first_block_if_ready: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
    145              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x066D      MVNS     R6,#+109
    146              unsigned char i;
    147              size_t len_left, olen;
    148          
    149              /* length calculation can be done only after both
    150               * mbedtls_ccm_starts() and mbedtls_ccm_set_lengths() have been executed
    151               */
    152              if (!(ctx->state & CCM_STATE__STARTED) || !(ctx->state & CCM_STATE__LENGTHS_SET)) {
   \        0x8   0xF895 0x0080      LDRB     R0,[R5, #+128]
   \        0xC   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x10   0x2803             CMP      R0,#+3
   \       0x12   0xD001             BEQ.N    ??ccm_calculate_first_block_if_ready_0
    153                  return 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE053             B.N      ??ccm_calculate_first_block_if_ready_1
    154              }
    155          
    156              /* CCM expects non-empty tag.
    157               * CCM* allows empty tag. For CCM* without tag, ignore plaintext length.
    158               */
    159              if (ctx->tag_len == 0) {
   \                     ??ccm_calculate_first_block_if_ready_0: (+1)
   \       0x18   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD10B             BNE.N    ??ccm_calculate_first_block_if_ready_2
    160                  if (ctx->mode == MBEDTLS_CCM_STAR_ENCRYPT || ctx->mode == MBEDTLS_CCM_STAR_DECRYPT) {
   \       0x1E   0x6B68             LDR      R0,[R5, #+52]
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xD002             BEQ.N    ??ccm_calculate_first_block_if_ready_3
   \       0x24   0x6B68             LDR      R0,[R5, #+52]
   \       0x26   0x2802             CMP      R0,#+2
   \       0x28   0xD102             BNE.N    ??ccm_calculate_first_block_if_ready_4
    161                      ctx->plaintext_len = 0;
   \                     ??ccm_calculate_first_block_if_ready_3: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6228             STR      R0,[R5, #+32]
   \       0x2E   0xE002             B.N      ??ccm_calculate_first_block_if_ready_2
    162                  } else {
    163                      return MBEDTLS_ERR_CCM_BAD_INPUT;
   \                     ??ccm_calculate_first_block_if_ready_4: (+1)
   \       0x30   0xF07F 0x000C      MVNS     R0,#+12
   \       0x34   0xE044             B.N      ??ccm_calculate_first_block_if_ready_1
    164                  }
    165              }
    166          
    167              /*
    168               * First block:
    169               * 0        .. 0        flags
    170               * 1        .. iv_len   nonce (aka iv)  - set by: mbedtls_ccm_starts()
    171               * iv_len+1 .. 15       length
    172               *
    173               * With flags as (bits):
    174               * 7        0
    175               * 6        add present?
    176               * 5 .. 3   (t - 2) / 2
    177               * 2 .. 0   q - 1
    178               */
    179              ctx->y[0] |= (ctx->add_len > 0) << 6;
   \                     ??ccm_calculate_first_block_if_ready_2: (+1)
   \       0x36   0x6A68             LDR      R0,[R5, #+36]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??ccm_calculate_first_block_if_ready_5
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0xE000             B.N      ??ccm_calculate_first_block_if_ready_6
   \                     ??ccm_calculate_first_block_if_ready_5: (+1)
   \       0x40   0x2100             MOVS     R1,#+0
   \                     ??ccm_calculate_first_block_if_ready_6: (+1)
   \       0x42   0x7828             LDRB     R0,[R5, #+0]
   \       0x44   0xEA50 0x1081      ORRS     R0,R0,R1, LSL #+6
   \       0x48   0x7028             STRB     R0,[R5, #+0]
    180              ctx->y[0] |= ((ctx->tag_len - 2) / 2) << 3;
   \       0x4A   0x7829             LDRB     R1,[R5, #+0]
   \       0x4C   0x6AA8             LDR      R0,[R5, #+40]
   \       0x4E   0x1E80             SUBS     R0,R0,#+2
   \       0x50   0x0840             LSRS     R0,R0,#+1
   \       0x52   0xEA51 0x01C0      ORRS     R1,R1,R0, LSL #+3
   \       0x56   0x7029             STRB     R1,[R5, #+0]
    181              ctx->y[0] |= ctx->q - 1;
   \       0x58   0x7829             LDRB     R1,[R5, #+0]
   \       0x5A   0x6B28             LDR      R0,[R5, #+48]
   \       0x5C   0x1E40             SUBS     R0,R0,#+1
   \       0x5E   0x4301             ORRS     R1,R0,R1
   \       0x60   0x7029             STRB     R1,[R5, #+0]
    182          
    183              for (i = 0, len_left = ctx->plaintext_len; i < ctx->q; i++, len_left >>= 8) {
   \       0x62   0x2700             MOVS     R7,#+0
   \       0x64   0x6A2C             LDR      R4,[R5, #+32]
   \                     ??ccm_calculate_first_block_if_ready_7: (+1)
   \       0x66   0x0039             MOVS     R1,R7
   \       0x68   0xB2C9             UXTB     R1,R1
   \       0x6A   0x6B28             LDR      R0,[R5, #+48]
   \       0x6C   0x4281             CMP      R1,R0
   \       0x6E   0xD207             BCS.N    ??ccm_calculate_first_block_if_ready_8
    184                  ctx->y[15-i] = MBEDTLS_BYTE_0(len_left);
   \       0x70   0x0038             MOVS     R0,R7
   \       0x72   0xB2C0             UXTB     R0,R0
   \       0x74   0x4240             RSBS     R0,R0,#+0
   \       0x76   0x4428             ADD      R0,R5,R0
   \       0x78   0x73C4             STRB     R4,[R0, #+15]
    185              }
   \       0x7A   0x1C7F             ADDS     R7,R7,#+1
   \       0x7C   0x0A24             LSRS     R4,R4,#+8
   \       0x7E   0xE7F2             B.N      ??ccm_calculate_first_block_if_ready_7
    186          
    187              if (len_left > 0) {
   \                     ??ccm_calculate_first_block_if_ready_8: (+1)
   \       0x80   0x2C00             CMP      R4,#+0
   \       0x82   0xD008             BEQ.N    ??ccm_calculate_first_block_if_ready_9
    188                  ctx->state |= CCM_STATE__ERROR;
   \       0x84   0xF8D5 0x0080      LDR      R0,[R5, #+128]
   \       0x88   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x8C   0xF8C5 0x0080      STR      R0,[R5, #+128]
    189                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x90   0xF07F 0x000C      MVNS     R0,#+12
   \       0x94   0xE014             B.N      ??ccm_calculate_first_block_if_ready_1
    190              }
    191          
    192              /* Start CBC-MAC with first block*/
    193              if ((ret = mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16, ctx->y, &olen)) != 0) {
   \                     ??ccm_calculate_first_block_if_ready_9: (+1)
   \       0x96   0xA801             ADD      R0,SP,#+4
   \       0x98   0x9000             STR      R0,[SP, #+0]
   \       0x9A   0x002B             MOVS     R3,R5
   \       0x9C   0x2210             MOVS     R2,#+16
   \       0x9E   0x0029             MOVS     R1,R5
   \       0xA0   0xF115 0x0038      ADDS     R0,R5,#+56
   \       0xA4   0x.... 0x....      BL       mbedtls_cipher_update
   \       0xA8   0x0001             MOVS     R1,R0
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD007             BEQ.N    ??ccm_calculate_first_block_if_ready_10
    194                  ctx->state |= CCM_STATE__ERROR;
   \       0xAE   0xF8D5 0x0080      LDR      R0,[R5, #+128]
   \       0xB2   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xB6   0xF8C5 0x0080      STR      R0,[R5, #+128]
    195                  return ret;
   \       0xBA   0x0008             MOVS     R0,R1
   \       0xBC   0xE000             B.N      ??ccm_calculate_first_block_if_ready_1
    196              }
    197          
    198              return 0;
   \                     ??ccm_calculate_first_block_if_ready_10: (+1)
   \       0xBE   0x2000             MOVS     R0,#+0
   \                     ??ccm_calculate_first_block_if_ready_1: (+1)
   \       0xC0   0xBDFE             POP      {R1-R7,PC}
    199          }
    200          

   \                                 In section .text, align 2, keep-with-next
    201          int mbedtls_ccm_starts(mbedtls_ccm_context *ctx,
    202                                 int mode,
    203                                 const unsigned char *iv,
    204                                 size_t iv_len)
    205          {
   \                     mbedtls_ccm_starts: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
    206              /* Also implies q is within bounds */
    207              if (iv_len < 7 || iv_len > 13) {
   \        0xE   0x2E07             CMP      R6,#+7
   \       0x10   0xD301             BCC.N    ??mbedtls_ccm_starts_0
   \       0x12   0x2E0E             CMP      R6,#+14
   \       0x14   0xD302             BCC.N    ??mbedtls_ccm_starts_1
    208                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \                     ??mbedtls_ccm_starts_0: (+1)
   \       0x16   0xF07F 0x000C      MVNS     R0,#+12
   \       0x1A   0xE042             B.N      ??mbedtls_ccm_starts_2
    209              }
    210          
    211              ctx->mode = mode;
   \                     ??mbedtls_ccm_starts_1: (+1)
   \       0x1C   0xF8CA 0x4034      STR      R4,[R10, #+52]
    212              ctx->q = 16 - 1 - (unsigned char) iv_len;
   \       0x20   0x0030             MOVS     R0,R6
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0xF1D0 0x000F      RSBS     R0,R0,#+15
   \       0x28   0xF8CA 0x0030      STR      R0,[R10, #+48]
    213          
    214              /*
    215               * Prepare counter block for encryption:
    216               * 0        .. 0        flags
    217               * 1        .. iv_len   nonce (aka iv)
    218               * iv_len+1 .. 15       counter (initially 1)
    219               *
    220               * With flags as (bits):
    221               * 7 .. 3   0
    222               * 2 .. 0   q - 1
    223               */
    224              memset(ctx->ctr, 0, 16);
   \       0x2C   0x2710             MOVS     R7,#+16
   \       0x2E   0xF05F 0x0800      MOVS     R8,#+0
   \       0x32   0xF11A 0x0910      ADDS     R9,R10,#+16
   \       0x36   0x4642             MOV      R2,R8
   \       0x38   0x0039             MOVS     R1,R7
   \       0x3A   0x4648             MOV      R0,R9
   \       0x3C   0x.... 0x....      BL       __aeabi_memset
    225              ctx->ctr[0] = ctx->q - 1;
   \       0x40   0xF8DA 0x0030      LDR      R0,[R10, #+48]
   \       0x44   0x1E40             SUBS     R0,R0,#+1
   \       0x46   0xF88A 0x0010      STRB     R0,[R10, #+16]
    226              memcpy(ctx->ctr + 1, iv, iv_len);
   \       0x4A   0x9604             STR      R6,[SP, #+16]
   \       0x4C   0x9503             STR      R5,[SP, #+12]
   \       0x4E   0xF11A 0x0911      ADDS     R9,R10,#+17
   \       0x52   0x9A04             LDR      R2,[SP, #+16]
   \       0x54   0x9903             LDR      R1,[SP, #+12]
   \       0x56   0x4648             MOV      R0,R9
   \       0x58   0x.... 0x....      BL       __aeabi_memcpy
    227              memset(ctx->ctr + 1 + iv_len, 0, ctx->q);
   \       0x5C   0xF8DA 0x0030      LDR      R0,[R10, #+48]
   \       0x60   0x9002             STR      R0,[SP, #+8]
   \       0x62   0xF05F 0x0900      MOVS     R9,#+0
   \       0x66   0xEB0A 0x0006      ADD      R0,R10,R6
   \       0x6A   0xF110 0x0B11      ADDS     R11,R0,#+17
   \       0x6E   0x464A             MOV      R2,R9
   \       0x70   0x9902             LDR      R1,[SP, #+8]
   \       0x72   0x4658             MOV      R0,R11
   \       0x74   0x.... 0x....      BL       __aeabi_memset
    228              ctx->ctr[15] = 1;
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0xF88A 0x001F      STRB     R0,[R10, #+31]
    229          
    230              /*
    231               * See ccm_calculate_first_block_if_ready() for block layout description
    232               */
    233              memcpy(ctx->y + 1, iv, iv_len);
   \       0x7E   0x9601             STR      R6,[SP, #+4]
   \       0x80   0x9500             STR      R5,[SP, #+0]
   \       0x82   0xF11A 0x0B01      ADDS     R11,R10,#+1
   \       0x86   0x9A01             LDR      R2,[SP, #+4]
   \       0x88   0x9900             LDR      R1,[SP, #+0]
   \       0x8A   0x4658             MOV      R0,R11
   \       0x8C   0x.... 0x....      BL       __aeabi_memcpy
    234          
    235              ctx->state |= CCM_STATE__STARTED;
   \       0x90   0xF8DA 0x0080      LDR      R0,[R10, #+128]
   \       0x94   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x98   0xF8CA 0x0080      STR      R0,[R10, #+128]
    236              return ccm_calculate_first_block_if_ready(ctx);
   \       0x9C   0x4650             MOV      R0,R10
   \       0x9E   0x.... 0x....      BL       ccm_calculate_first_block_if_ready
   \                     ??mbedtls_ccm_starts_2: (+1)
   \       0xA2   0xB005             ADD      SP,SP,#+20
   \       0xA4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    237          }
    238          

   \                                 In section .text, align 2, keep-with-next
    239          int mbedtls_ccm_set_lengths(mbedtls_ccm_context *ctx,
    240                                      size_t total_ad_len,
    241                                      size_t plaintext_len,
    242                                      size_t tag_len)
    243          {
   \                     mbedtls_ccm_set_lengths: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
    244              /*
    245               * Check length requirements: SP800-38C A.1
    246               * Additional requirement: a < 2^16 - 2^8 to simplify the code.
    247               * 'length' checked later (when writing it to the first block)
    248               *
    249               * Also, loosen the requirements to enable support for CCM* (IEEE 802.15.4).
    250               */
    251              if (tag_len == 2 || tag_len > 16 || tag_len % 2 != 0) {
   \        0xA   0x2F02             CMP      R7,#+2
   \        0xC   0xD003             BEQ.N    ??mbedtls_ccm_set_lengths_0
   \        0xE   0x2F11             CMP      R7,#+17
   \       0x10   0xD201             BCS.N    ??mbedtls_ccm_set_lengths_0
   \       0x12   0x07F8             LSLS     R0,R7,#+31
   \       0x14   0xD502             BPL.N    ??mbedtls_ccm_set_lengths_1
    252                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \                     ??mbedtls_ccm_set_lengths_0: (+1)
   \       0x16   0xF07F 0x000C      MVNS     R0,#+12
   \       0x1A   0xE013             B.N      ??mbedtls_ccm_set_lengths_2
    253              }
    254          
    255              if (total_ad_len >= 0xFF00) {
   \                     ??mbedtls_ccm_set_lengths_1: (+1)
   \       0x1C   0xF5B5 0x4F7F      CMP      R5,#+65280
   \       0x20   0xD302             BCC.N    ??mbedtls_ccm_set_lengths_3
    256                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x22   0xF07F 0x000C      MVNS     R0,#+12
   \       0x26   0xE00D             B.N      ??mbedtls_ccm_set_lengths_2
    257              }
    258          
    259              ctx->plaintext_len = plaintext_len;
   \                     ??mbedtls_ccm_set_lengths_3: (+1)
   \       0x28   0x6226             STR      R6,[R4, #+32]
    260              ctx->add_len = total_ad_len;
   \       0x2A   0x6265             STR      R5,[R4, #+36]
    261              ctx->tag_len = tag_len;
   \       0x2C   0x62A7             STR      R7,[R4, #+40]
    262              ctx->processed = 0;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x62E0             STR      R0,[R4, #+44]
    263          
    264              ctx->state |= CCM_STATE__LENGTHS_SET;
   \       0x32   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \       0x36   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x3A   0xF8C4 0x0080      STR      R0,[R4, #+128]
    265              return ccm_calculate_first_block_if_ready(ctx);
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       ccm_calculate_first_block_if_ready
   \                     ??mbedtls_ccm_set_lengths_2: (+1)
   \       0x44   0xBDF2             POP      {R1,R4-R7,PC}
    266          }
    267          

   \                                 In section .text, align 2, keep-with-next
    268          int mbedtls_ccm_update_ad(mbedtls_ccm_context *ctx,
    269                                    const unsigned char *add,
    270                                    size_t add_len)
    271          {
   \                     mbedtls_ccm_update_ad: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0014             MOVS     R4,R2
    272              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x086D      MVNS     R8,#+109
    273              size_t olen, use_len, offset;
    274          
    275              if (ctx->state & CCM_STATE__ERROR) {
   \        0xE   0xF896 0x0080      LDRB     R0,[R6, #+128]
   \       0x12   0x06C0             LSLS     R0,R0,#+27
   \       0x14   0xD502             BPL.N    ??mbedtls_ccm_update_ad_0
    276                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x16   0xF07F 0x000C      MVNS     R0,#+12
   \       0x1A   0xE06F             B.N      ??mbedtls_ccm_update_ad_1
    277              }
    278          
    279              if (add_len > 0) {
   \                     ??mbedtls_ccm_update_ad_0: (+1)
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD06C             BEQ.N    ??mbedtls_ccm_update_ad_2
    280                  if (ctx->state & CCM_STATE__AUTH_DATA_FINISHED) {
   \       0x20   0xF896 0x0080      LDRB     R0,[R6, #+128]
   \       0x24   0x0700             LSLS     R0,R0,#+28
   \       0x26   0xD502             BPL.N    ??mbedtls_ccm_update_ad_3
    281                      return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x28   0xF07F 0x000C      MVNS     R0,#+12
   \       0x2C   0xE066             B.N      ??mbedtls_ccm_update_ad_1
    282                  }
    283          
    284                  if (!(ctx->state & CCM_STATE__AUTH_DATA_STARTED)) {
   \                     ??mbedtls_ccm_update_ad_3: (+1)
   \       0x2E   0xF896 0x0080      LDRB     R0,[R6, #+128]
   \       0x32   0x0740             LSLS     R0,R0,#+29
   \       0x34   0xD415             BMI.N    ??mbedtls_ccm_update_ad_4
    285                      if (add_len > ctx->add_len) {
   \       0x36   0x6A70             LDR      R0,[R6, #+36]
   \       0x38   0x42A0             CMP      R0,R4
   \       0x3A   0xD202             BCS.N    ??mbedtls_ccm_update_ad_5
    286                          return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x3C   0xF07F 0x000C      MVNS     R0,#+12
   \       0x40   0xE05C             B.N      ??mbedtls_ccm_update_ad_1
    287                      }
    288          
    289                      ctx->y[0] ^= (unsigned char) ((ctx->add_len >> 8) & 0xFF);
   \                     ??mbedtls_ccm_update_ad_5: (+1)
   \       0x42   0x7831             LDRB     R1,[R6, #+0]
   \       0x44   0x6A70             LDR      R0,[R6, #+36]
   \       0x46   0x0A00             LSRS     R0,R0,#+8
   \       0x48   0x4041             EORS     R1,R0,R1
   \       0x4A   0x7031             STRB     R1,[R6, #+0]
    290                      ctx->y[1] ^= (unsigned char) ((ctx->add_len) & 0xFF);
   \       0x4C   0x7871             LDRB     R1,[R6, #+1]
   \       0x4E   0x6A70             LDR      R0,[R6, #+36]
   \       0x50   0x4041             EORS     R1,R0,R1
   \       0x52   0x7071             STRB     R1,[R6, #+1]
    291          
    292                      ctx->state |= CCM_STATE__AUTH_DATA_STARTED;
   \       0x54   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \       0x58   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x5C   0xF8C6 0x0080      STR      R0,[R6, #+128]
   \       0x60   0xE007             B.N      ??mbedtls_ccm_update_ad_6
    293                  } else if (ctx->processed + add_len > ctx->add_len) {
   \                     ??mbedtls_ccm_update_ad_4: (+1)
   \       0x62   0x6A71             LDR      R1,[R6, #+36]
   \       0x64   0x6AF0             LDR      R0,[R6, #+44]
   \       0x66   0x1820             ADDS     R0,R4,R0
   \       0x68   0x4281             CMP      R1,R0
   \       0x6A   0xD202             BCS.N    ??mbedtls_ccm_update_ad_6
    294                      return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x6C   0xF07F 0x000C      MVNS     R0,#+12
   \       0x70   0xE044             B.N      ??mbedtls_ccm_update_ad_1
    295                  }
    296          
    297                  while (add_len > 0) {
   \                     ??mbedtls_ccm_update_ad_6: (+1)
   \       0x72   0x2C00             CMP      R4,#+0
   \       0x74   0xD035             BEQ.N    ??mbedtls_ccm_update_ad_7
    298                      offset = (ctx->processed + 2) % 16; /* account for y[0] and y[1]
   \       0x76   0x6AF0             LDR      R0,[R6, #+44]
   \       0x78   0x1C80             ADDS     R0,R0,#+2
   \       0x7A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x7E   0x0005             MOVS     R5,R0
    299                                                           * holding total auth data length */
    300                      use_len = 16 - offset;
   \       0x80   0xF1D5 0x0010      RSBS     R0,R5,#+16
   \       0x84   0x4681             MOV      R9,R0
    301          
    302                      if (use_len > add_len) {
   \       0x86   0x454C             CMP      R4,R9
   \       0x88   0xD200             BCS.N    ??mbedtls_ccm_update_ad_8
    303                          use_len = add_len;
   \       0x8A   0x46A1             MOV      R9,R4
    304                      }
    305          
    306                      mbedtls_xor(ctx->y + offset, ctx->y + offset, add, use_len);
   \                     ??mbedtls_ccm_update_ad_8: (+1)
   \       0x8C   0x464B             MOV      R3,R9
   \       0x8E   0x003A             MOVS     R2,R7
   \       0x90   0xEB06 0x0105      ADD      R1,R6,R5
   \       0x94   0xEB06 0x0005      ADD      R0,R6,R5
   \       0x98   0x.... 0x....      BL       mbedtls_xor
    307          
    308                      ctx->processed += use_len;
   \       0x9C   0x6AF0             LDR      R0,[R6, #+44]
   \       0x9E   0xEB19 0x0000      ADDS     R0,R9,R0
   \       0xA2   0x62F0             STR      R0,[R6, #+44]
    309                      add_len -= use_len;
   \       0xA4   0xEBB4 0x0409      SUBS     R4,R4,R9
    310                      add += use_len;
   \       0xA8   0x444F             ADD      R7,R7,R9
    311          
    312                      if (use_len + offset == 16 || ctx->processed == ctx->add_len) {
   \       0xAA   0xEB15 0x0009      ADDS     R0,R5,R9
   \       0xAE   0x2810             CMP      R0,#+16
   \       0xB0   0xD003             BEQ.N    ??mbedtls_ccm_update_ad_9
   \       0xB2   0x6AF1             LDR      R1,[R6, #+44]
   \       0xB4   0x6A70             LDR      R0,[R6, #+36]
   \       0xB6   0x4281             CMP      R1,R0
   \       0xB8   0xD1DB             BNE.N    ??mbedtls_ccm_update_ad_6
    313                          if ((ret =
    314                                   mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16, ctx->y, &olen)) != 0) {
   \                     ??mbedtls_ccm_update_ad_9: (+1)
   \       0xBA   0xA801             ADD      R0,SP,#+4
   \       0xBC   0x9000             STR      R0,[SP, #+0]
   \       0xBE   0x0033             MOVS     R3,R6
   \       0xC0   0x2210             MOVS     R2,#+16
   \       0xC2   0x0031             MOVS     R1,R6
   \       0xC4   0xF116 0x0038      ADDS     R0,R6,#+56
   \       0xC8   0x.... 0x....      BL       mbedtls_cipher_update
   \       0xCC   0x4680             MOV      R8,R0
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD0CF             BEQ.N    ??mbedtls_ccm_update_ad_6
    315                              ctx->state |= CCM_STATE__ERROR;
   \       0xD2   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \       0xD6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xDA   0xF8C6 0x0080      STR      R0,[R6, #+128]
    316                              return ret;
   \       0xDE   0x4640             MOV      R0,R8
   \       0xE0   0xE00C             B.N      ??mbedtls_ccm_update_ad_1
    317                          }
    318                      }
    319                  }
    320          
    321                  if (ctx->processed == ctx->add_len) {
   \                     ??mbedtls_ccm_update_ad_7: (+1)
   \       0xE2   0x6AF1             LDR      R1,[R6, #+44]
   \       0xE4   0x6A70             LDR      R0,[R6, #+36]
   \       0xE6   0x4281             CMP      R1,R0
   \       0xE8   0xD107             BNE.N    ??mbedtls_ccm_update_ad_2
    322                      ctx->state |= CCM_STATE__AUTH_DATA_FINISHED;
   \       0xEA   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \       0xEE   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xF2   0xF8C6 0x0080      STR      R0,[R6, #+128]
    323                      ctx->processed = 0; // prepare for mbedtls_ccm_update()
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0x62F0             STR      R0,[R6, #+44]
    324                  }
    325              }
    326          
    327              return 0;
   \                     ??mbedtls_ccm_update_ad_2: (+1)
   \       0xFA   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_update_ad_1: (+1)
   \       0xFC   0xE8BD 0x83FE      POP      {R1-R9,PC}
    328          }
    329          

   \                                 In section .text, align 2, keep-with-next
    330          int mbedtls_ccm_update(mbedtls_ccm_context *ctx,
    331                                 const unsigned char *input, size_t input_len,
    332                                 unsigned char *output, size_t output_size,
    333                                 size_t *output_len)
    334          {
   \                     mbedtls_ccm_update: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x469A             MOV      R10,R3
    335              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x016D      MVNS     R1,#+109
    336              unsigned char i;
    337              size_t use_len, offset, olen;
    338          
    339              unsigned char local_output[16];
    340          
    341              if (ctx->state & CCM_STATE__ERROR) {
   \       0x12   0xF898 0x0080      LDRB     R0,[R8, #+128]
   \       0x16   0x06C0             LSLS     R0,R0,#+27
   \       0x18   0xD502             BPL.N    ??mbedtls_ccm_update_0
    342                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x1A   0xF07F 0x000C      MVNS     R0,#+12
   \       0x1E   0xE0D1             B.N      ??mbedtls_ccm_update_1
    343              }
    344          
    345              /* Check against plaintext length only if performing operation with
    346               * authentication
    347               */
    348              if (ctx->tag_len != 0 && ctx->processed + input_len > ctx->plaintext_len) {
   \                     ??mbedtls_ccm_update_0: (+1)
   \       0x20   0xF8D8 0x0028      LDR      R0,[R8, #+40]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD009             BEQ.N    ??mbedtls_ccm_update_2
   \       0x28   0xF8D8 0x2020      LDR      R2,[R8, #+32]
   \       0x2C   0xF8D8 0x002C      LDR      R0,[R8, #+44]
   \       0x30   0x1828             ADDS     R0,R5,R0
   \       0x32   0x4282             CMP      R2,R0
   \       0x34   0xD202             BCS.N    ??mbedtls_ccm_update_2
    349                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x36   0xF07F 0x000C      MVNS     R0,#+12
   \       0x3A   0xE0C3             B.N      ??mbedtls_ccm_update_1
    350              }
    351          
    352              if (output_size < input_len) {
   \                     ??mbedtls_ccm_update_2: (+1)
   \       0x3C   0x9812             LDR      R0,[SP, #+72]
   \       0x3E   0x42A8             CMP      R0,R5
   \       0x40   0xD202             BCS.N    ??mbedtls_ccm_update_3
    353                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x42   0xF07F 0x000C      MVNS     R0,#+12
   \       0x46   0xE0BD             B.N      ??mbedtls_ccm_update_1
    354              }
    355              *output_len = input_len;
   \                     ??mbedtls_ccm_update_3: (+1)
   \       0x48   0x9813             LDR      R0,[SP, #+76]
   \       0x4A   0x6005             STR      R5,[R0, #+0]
    356          
    357              ret = 0;
   \       0x4C   0x2400             MOVS     R4,#+0
    358          
    359              while (input_len > 0) {
   \                     ??mbedtls_ccm_update_4: (+1)
   \       0x4E   0x2D00             CMP      R5,#+0
   \       0x50   0xF000 0x80B3      BEQ.W    ??mbedtls_ccm_update_5
    360                  offset = ctx->processed % 16;
   \       0x54   0xF898 0x002C      LDRB     R0,[R8, #+44]
   \       0x58   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x5C   0x0007             MOVS     R7,R0
    361          
    362                  use_len = 16 - offset;
   \       0x5E   0xF1D7 0x0010      RSBS     R0,R7,#+16
   \       0x62   0x0006             MOVS     R6,R0
    363          
    364                  if (use_len > input_len) {
   \       0x64   0x42B5             CMP      R5,R6
   \       0x66   0xD200             BCS.N    ??mbedtls_ccm_update_6
    365                      use_len = input_len;
   \       0x68   0x002E             MOVS     R6,R5
    366                  }
    367          
    368                  ctx->processed += use_len;
   \                     ??mbedtls_ccm_update_6: (+1)
   \       0x6A   0xF8D8 0x002C      LDR      R0,[R8, #+44]
   \       0x6E   0x1830             ADDS     R0,R6,R0
   \       0x70   0xF8C8 0x002C      STR      R0,[R8, #+44]
    369          
    370                  if (ctx->mode == MBEDTLS_CCM_ENCRYPT || \
    371                      ctx->mode == MBEDTLS_CCM_STAR_ENCRYPT) {
   \       0x74   0xF8D8 0x0034      LDR      R0,[R8, #+52]
   \       0x78   0x2801             CMP      R0,#+1
   \       0x7A   0xD003             BEQ.N    ??mbedtls_ccm_update_7
   \       0x7C   0xF8D8 0x0034      LDR      R0,[R8, #+52]
   \       0x80   0x2803             CMP      R0,#+3
   \       0x82   0xD12E             BNE.N    ??mbedtls_ccm_update_8
    372                      mbedtls_xor(ctx->y + offset, ctx->y + offset, input, use_len);
   \                     ??mbedtls_ccm_update_7: (+1)
   \       0x84   0x0033             MOVS     R3,R6
   \       0x86   0x464A             MOV      R2,R9
   \       0x88   0xEB08 0x0107      ADD      R1,R8,R7
   \       0x8C   0xEB08 0x0007      ADD      R0,R8,R7
   \       0x90   0x.... 0x....      BL       mbedtls_xor
    373          
    374                      if (use_len + offset == 16 || ctx->processed == ctx->plaintext_len) {
   \       0x94   0x19B8             ADDS     R0,R7,R6
   \       0x96   0x2810             CMP      R0,#+16
   \       0x98   0xD005             BEQ.N    ??mbedtls_ccm_update_9
   \       0x9A   0xF8D8 0x102C      LDR      R1,[R8, #+44]
   \       0x9E   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \       0xA2   0x4281             CMP      R1,R0
   \       0xA4   0xD112             BNE.N    ??mbedtls_ccm_update_10
    375                          if ((ret =
    376                                   mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16, ctx->y, &olen)) != 0) {
   \                     ??mbedtls_ccm_update_9: (+1)
   \       0xA6   0xA801             ADD      R0,SP,#+4
   \       0xA8   0x9000             STR      R0,[SP, #+0]
   \       0xAA   0x4643             MOV      R3,R8
   \       0xAC   0x2210             MOVS     R2,#+16
   \       0xAE   0x4641             MOV      R1,R8
   \       0xB0   0xF118 0x0038      ADDS     R0,R8,#+56
   \       0xB4   0x.... 0x....      BL       mbedtls_cipher_update
   \       0xB8   0x0004             MOVS     R4,R0
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD006             BEQ.N    ??mbedtls_ccm_update_10
    377                              ctx->state |= CCM_STATE__ERROR;
   \       0xBE   0xF8D8 0x0080      LDR      R0,[R8, #+128]
   \       0xC2   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xC6   0xF8C8 0x0080      STR      R0,[R8, #+128]
    378                              goto exit;
   \       0xCA   0xE076             B.N      ??mbedtls_ccm_update_5
    379                          }
    380                      }
    381          
    382                      ret = mbedtls_ccm_crypt(ctx, offset, use_len, input, output);
   \                     ??mbedtls_ccm_update_10: (+1)
   \       0xCC   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \       0xD0   0x464B             MOV      R3,R9
   \       0xD2   0x0032             MOVS     R2,R6
   \       0xD4   0x0039             MOVS     R1,R7
   \       0xD6   0x4640             MOV      R0,R8
   \       0xD8   0x.... 0x....      BL       mbedtls_ccm_crypt
   \       0xDC   0x0004             MOVS     R4,R0
    383                      if (ret != 0) {
   \       0xDE   0x2C00             CMP      R4,#+0
   \       0xE0   0xD16B             BNE.N    ??mbedtls_ccm_update_5
    384                          goto exit;
    385                      }
    386                  }
    387          
    388                  if (ctx->mode == MBEDTLS_CCM_DECRYPT || \
    389                      ctx->mode == MBEDTLS_CCM_STAR_DECRYPT) {
   \                     ??mbedtls_ccm_update_8: (+1)
   \       0xE2   0xF8D8 0x0034      LDR      R0,[R8, #+52]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD003             BEQ.N    ??mbedtls_ccm_update_11
   \       0xEA   0xF8D8 0x0034      LDR      R0,[R8, #+52]
   \       0xEE   0x2802             CMP      R0,#+2
   \       0xF0   0xD139             BNE.N    ??mbedtls_ccm_update_12
    390                      /* Since output may be in shared memory, we cannot be sure that
    391                       * it will contain what we wrote to it. Therefore, we should avoid using
    392                       * it as input to any operations.
    393                       * Write decrypted data to local_output to avoid using output variable as
    394                       * input in the XOR operation for Y.
    395                       */
    396                      ret = mbedtls_ccm_crypt(ctx, offset, use_len, input, local_output);
   \                     ??mbedtls_ccm_update_11: (+1)
   \       0xF2   0xA804             ADD      R0,SP,#+16
   \       0xF4   0x9000             STR      R0,[SP, #+0]
   \       0xF6   0x464B             MOV      R3,R9
   \       0xF8   0x0032             MOVS     R2,R6
   \       0xFA   0x0039             MOVS     R1,R7
   \       0xFC   0x4640             MOV      R0,R8
   \       0xFE   0x.... 0x....      BL       mbedtls_ccm_crypt
   \      0x102   0x0004             MOVS     R4,R0
    397                      if (ret != 0) {
   \      0x104   0x2C00             CMP      R4,#+0
   \      0x106   0xD158             BNE.N    ??mbedtls_ccm_update_5
    398                          goto exit;
    399                      }
    400          
    401                      mbedtls_xor(ctx->y + offset, ctx->y + offset, local_output, use_len);
   \                     ??mbedtls_ccm_update_13: (+1)
   \      0x108   0x0033             MOVS     R3,R6
   \      0x10A   0xAA04             ADD      R2,SP,#+16
   \      0x10C   0xEB08 0x0107      ADD      R1,R8,R7
   \      0x110   0xEB08 0x0007      ADD      R0,R8,R7
   \      0x114   0x.... 0x....      BL       mbedtls_xor
    402          
    403                      memcpy(output, local_output, use_len);
   \      0x118   0x9603             STR      R6,[SP, #+12]
   \      0x11A   0xA804             ADD      R0,SP,#+16
   \      0x11C   0x9002             STR      R0,[SP, #+8]
   \      0x11E   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \      0x122   0x9A03             LDR      R2,[SP, #+12]
   \      0x124   0x9902             LDR      R1,[SP, #+8]
   \      0x126   0x9800             LDR      R0,[SP, #+0]
   \      0x128   0x.... 0x....      BL       __aeabi_memcpy
   \      0x12C   0x9800             LDR      R0,[SP, #+0]
    404          
    405                      if (use_len + offset == 16 || ctx->processed == ctx->plaintext_len) {
   \      0x12E   0x19B8             ADDS     R0,R7,R6
   \      0x130   0x2810             CMP      R0,#+16
   \      0x132   0xD005             BEQ.N    ??mbedtls_ccm_update_14
   \      0x134   0xF8D8 0x102C      LDR      R1,[R8, #+44]
   \      0x138   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \      0x13C   0x4281             CMP      R1,R0
   \      0x13E   0xD112             BNE.N    ??mbedtls_ccm_update_12
    406                          if ((ret =
    407                                   mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16, ctx->y, &olen)) != 0) {
   \                     ??mbedtls_ccm_update_14: (+1)
   \      0x140   0xA801             ADD      R0,SP,#+4
   \      0x142   0x9000             STR      R0,[SP, #+0]
   \      0x144   0x4643             MOV      R3,R8
   \      0x146   0x2210             MOVS     R2,#+16
   \      0x148   0x4641             MOV      R1,R8
   \      0x14A   0xF118 0x0038      ADDS     R0,R8,#+56
   \      0x14E   0x.... 0x....      BL       mbedtls_cipher_update
   \      0x152   0x0004             MOVS     R4,R0
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD006             BEQ.N    ??mbedtls_ccm_update_12
    408                              ctx->state |= CCM_STATE__ERROR;
   \      0x158   0xF8D8 0x0080      LDR      R0,[R8, #+128]
   \      0x15C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x160   0xF8C8 0x0080      STR      R0,[R8, #+128]
    409                              goto exit;
   \      0x164   0xE029             B.N      ??mbedtls_ccm_update_5
    410                          }
    411                      }
    412                  }
    413          
    414                  if (use_len + offset == 16 || ctx->processed == ctx->plaintext_len) {
   \                     ??mbedtls_ccm_update_12: (+1)
   \      0x166   0x19B8             ADDS     R0,R7,R6
   \      0x168   0x2810             CMP      R0,#+16
   \      0x16A   0xD005             BEQ.N    ??mbedtls_ccm_update_15
   \      0x16C   0xF8D8 0x102C      LDR      R1,[R8, #+44]
   \      0x170   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \      0x174   0x4281             CMP      R1,R0
   \      0x176   0xD11C             BNE.N    ??mbedtls_ccm_update_16
    415                      for (i = 0; i < ctx->q; i++) {
   \                     ??mbedtls_ccm_update_15: (+1)
   \      0x178   0x2000             MOVS     R0,#+0
   \      0x17A   0x4683             MOV      R11,R0
   \                     ??mbedtls_ccm_update_17: (+1)
   \      0x17C   0x4659             MOV      R1,R11
   \      0x17E   0xB2C9             UXTB     R1,R1
   \      0x180   0xF8D8 0x0030      LDR      R0,[R8, #+48]
   \      0x184   0x4281             CMP      R1,R0
   \      0x186   0xD214             BCS.N    ??mbedtls_ccm_update_16
    416                          if (++(ctx->ctr)[15-i] != 0) {
   \      0x188   0x4658             MOV      R0,R11
   \      0x18A   0xB2C0             UXTB     R0,R0
   \      0x18C   0x4240             RSBS     R0,R0,#+0
   \      0x18E   0x4440             ADD      R0,R8,R0
   \      0x190   0x7FC0             LDRB     R0,[R0, #+31]
   \      0x192   0x1C40             ADDS     R0,R0,#+1
   \      0x194   0x4659             MOV      R1,R11
   \      0x196   0xB2C9             UXTB     R1,R1
   \      0x198   0x4249             RSBS     R1,R1,#+0
   \      0x19A   0x4441             ADD      R1,R8,R1
   \      0x19C   0x77C8             STRB     R0,[R1, #+31]
   \      0x19E   0x4658             MOV      R0,R11
   \      0x1A0   0xB2C0             UXTB     R0,R0
   \      0x1A2   0x4240             RSBS     R0,R0,#+0
   \      0x1A4   0x4440             ADD      R0,R8,R0
   \      0x1A6   0x7FC0             LDRB     R0,[R0, #+31]
   \      0x1A8   0x2800             CMP      R0,#+0
   \      0x1AA   0xD102             BNE.N    ??mbedtls_ccm_update_16
    417                              break;
    418                          }
    419                      }
   \                     ??mbedtls_ccm_update_18: (+1)
   \      0x1AC   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \      0x1B0   0xE7E4             B.N      ??mbedtls_ccm_update_17
    420                  }
    421          
    422                  input_len -= use_len;
   \                     ??mbedtls_ccm_update_16: (+1)
   \      0x1B2   0x1BAD             SUBS     R5,R5,R6
    423                  input += use_len;
   \      0x1B4   0x44B1             ADD      R9,R9,R6
    424                  output += use_len;
   \      0x1B6   0x44B2             ADD      R10,R10,R6
   \      0x1B8   0xE749             B.N      ??mbedtls_ccm_update_4
    425              }
    426          
    427          exit:
    428              mbedtls_platform_zeroize(local_output, 16);
   \                     ??mbedtls_ccm_update_5: (+1)
   \      0x1BA   0x2110             MOVS     R1,#+16
   \      0x1BC   0xA804             ADD      R0,SP,#+16
   \      0x1BE   0x.... 0x....      BL       mbedtls_platform_zeroize
    429          
    430              return ret;
   \      0x1C2   0x0020             MOVS     R0,R4
   \                     ??mbedtls_ccm_update_1: (+1)
   \      0x1C4   0xB009             ADD      SP,SP,#+36
   \      0x1C6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    431          }
    432          

   \                                 In section .text, align 2, keep-with-next
    433          int mbedtls_ccm_finish(mbedtls_ccm_context *ctx,
    434                                 unsigned char *tag, size_t tag_len)
    435          {
   \                     mbedtls_ccm_finish: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
    436              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x006D      MVNS     R0,#+109
   \        0xE   0x0007             MOVS     R7,R0
    437              unsigned char i;
    438          
    439              if (ctx->state & CCM_STATE__ERROR) {
   \       0x10   0xF898 0x1080      LDRB     R1,[R8, #+128]
   \       0x14   0x06C9             LSLS     R1,R1,#+27
   \       0x16   0xD443             BMI.N    ??mbedtls_ccm_finish_0
    440                  return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    441              }
    442          
    443              if (ctx->add_len > 0 && !(ctx->state & CCM_STATE__AUTH_DATA_FINISHED)) {
   \                     ??mbedtls_ccm_finish_1: (+1)
   \       0x18   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD006             BEQ.N    ??mbedtls_ccm_finish_2
   \       0x20   0xF898 0x0080      LDRB     R0,[R8, #+128]
   \       0x24   0x0700             LSLS     R0,R0,#+28
   \       0x26   0xD402             BMI.N    ??mbedtls_ccm_finish_2
    444                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x28   0xF07F 0x000C      MVNS     R0,#+12
   \       0x2C   0xE038             B.N      ??mbedtls_ccm_finish_0
    445              }
    446          
    447              if (ctx->plaintext_len > 0 && ctx->processed != ctx->plaintext_len) {
   \                     ??mbedtls_ccm_finish_2: (+1)
   \       0x2E   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD008             BEQ.N    ??mbedtls_ccm_finish_3
   \       0x36   0xF8D8 0x102C      LDR      R1,[R8, #+44]
   \       0x3A   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \       0x3E   0x4281             CMP      R1,R0
   \       0x40   0xD002             BEQ.N    ??mbedtls_ccm_finish_3
    448                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \       0x42   0xF07F 0x000C      MVNS     R0,#+12
   \       0x46   0xE02B             B.N      ??mbedtls_ccm_finish_0
    449              }
    450          
    451              /*
    452               * Authentication: reset counter and crypt/mask internal tag
    453               */
    454              for (i = 0; i < ctx->q; i++) {
   \                     ??mbedtls_ccm_finish_3: (+1)
   \       0x48   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??mbedtls_ccm_finish_4: (+1)
   \       0x4C   0x4649             MOV      R1,R9
   \       0x4E   0xB2C9             UXTB     R1,R1
   \       0x50   0xF8D8 0x0030      LDR      R0,[R8, #+48]
   \       0x54   0x4281             CMP      R1,R0
   \       0x56   0xD208             BCS.N    ??mbedtls_ccm_finish_5
    455                  ctx->ctr[15-i] = 0;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x4649             MOV      R1,R9
   \       0x5C   0xB2C9             UXTB     R1,R1
   \       0x5E   0x4249             RSBS     R1,R1,#+0
   \       0x60   0x4441             ADD      R1,R8,R1
   \       0x62   0x77C8             STRB     R0,[R1, #+31]
    456              }
   \       0x64   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x68   0xE7F0             B.N      ??mbedtls_ccm_finish_4
    457          
    458              ret = mbedtls_ccm_crypt(ctx, 0, 16, ctx->y, ctx->y);
   \                     ??mbedtls_ccm_finish_5: (+1)
   \       0x6A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x6E   0x4643             MOV      R3,R8
   \       0x70   0x2210             MOVS     R2,#+16
   \       0x72   0x2100             MOVS     R1,#+0
   \       0x74   0x4640             MOV      R0,R8
   \       0x76   0x.... 0x....      BL       mbedtls_ccm_crypt
   \       0x7A   0x0005             MOVS     R5,R0
    459              if (ret != 0) {
   \       0x7C   0x2D00             CMP      R5,#+0
   \       0x7E   0xD001             BEQ.N    ??mbedtls_ccm_finish_6
    460                  return ret;
   \       0x80   0x0028             MOVS     R0,R5
   \       0x82   0xE00D             B.N      ??mbedtls_ccm_finish_0
    461              }
    462              if (tag != NULL) {
   \                     ??mbedtls_ccm_finish_6: (+1)
   \       0x84   0x2C00             CMP      R4,#+0
   \       0x86   0xD007             BEQ.N    ??mbedtls_ccm_finish_7
    463                  memcpy(tag, ctx->y, tag_len);
   \       0x88   0x46B3             MOV      R11,R6
   \       0x8A   0x4647             MOV      R7,R8
   \       0x8C   0x46A2             MOV      R10,R4
   \       0x8E   0x465A             MOV      R2,R11
   \       0x90   0x0039             MOVS     R1,R7
   \       0x92   0x4650             MOV      R0,R10
   \       0x94   0x.... 0x....      BL       __aeabi_memcpy
    464              }
    465              mbedtls_ccm_clear_state(ctx);
   \                     ??mbedtls_ccm_finish_7: (+1)
   \       0x98   0x4640             MOV      R0,R8
   \       0x9A   0x.... 0x....      BL       mbedtls_ccm_clear_state
    466          
    467              return 0;
   \       0x9E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_finish_0: (+1)
   \       0xA0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    468          }
    469          
    470          /*
    471           * Authenticated encryption or decryption
    472           */

   \                                 In section .text, align 2, keep-with-next
    473          static int ccm_auth_crypt(mbedtls_ccm_context *ctx, int mode, size_t length,
    474                                    const unsigned char *iv, size_t iv_len,
    475                                    const unsigned char *add, size_t add_len,
    476                                    const unsigned char *input, unsigned char *output,
    477                                    unsigned char *tag, size_t tag_len)
    478          {
   \                     ccm_auth_crypt: (+1)
   \        0x0   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x9D11             LDR      R5,[SP, #+68]
   \        0xC   0x9E12             LDR      R6,[SP, #+72]
   \        0xE   0x9F13             LDR      R7,[SP, #+76]
   \       0x10   0xF8DD 0x8050      LDR      R8,[SP, #+80]
   \       0x14   0xF8DD 0x9054      LDR      R9,[SP, #+84]
   \       0x18   0xF8DD 0xA058      LDR      R10,[SP, #+88]
    479              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x1C   0xF07F 0x006D      MVNS     R0,#+109
   \       0x20   0x9002             STR      R0,[SP, #+8]
    480              size_t olen;
    481          
    482              if ((ret = mbedtls_ccm_starts(ctx, mode, iv, iv_len)) != 0) {
   \       0x22   0x9B10             LDR      R3,[SP, #+64]
   \       0x24   0x9A06             LDR      R2,[SP, #+24]
   \       0x26   0x9905             LDR      R1,[SP, #+20]
   \       0x28   0x4658             MOV      R0,R11
   \       0x2A   0x.... 0x....      BL       mbedtls_ccm_starts
   \       0x2E   0x9002             STR      R0,[SP, #+8]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD001             BEQ.N    ??ccm_auth_crypt_0
    483                  return ret;
   \       0x34   0x9802             LDR      R0,[SP, #+8]
   \       0x36   0xE02D             B.N      ??ccm_auth_crypt_1
    484              }
    485          
    486              if ((ret = mbedtls_ccm_set_lengths(ctx, add_len, length, tag_len)) != 0) {
   \                     ??ccm_auth_crypt_0: (+1)
   \       0x38   0x4653             MOV      R3,R10
   \       0x3A   0x0022             MOVS     R2,R4
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0x4658             MOV      R0,R11
   \       0x40   0x.... 0x....      BL       mbedtls_ccm_set_lengths
   \       0x44   0x9002             STR      R0,[SP, #+8]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD001             BEQ.N    ??ccm_auth_crypt_2
    487                  return ret;
   \       0x4A   0x9802             LDR      R0,[SP, #+8]
   \       0x4C   0xE022             B.N      ??ccm_auth_crypt_1
    488              }
    489          
    490              if ((ret = mbedtls_ccm_update_ad(ctx, add, add_len)) != 0) {
   \                     ??ccm_auth_crypt_2: (+1)
   \       0x4E   0x0032             MOVS     R2,R6
   \       0x50   0x0029             MOVS     R1,R5
   \       0x52   0x4658             MOV      R0,R11
   \       0x54   0x.... 0x....      BL       mbedtls_ccm_update_ad
   \       0x58   0x9002             STR      R0,[SP, #+8]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD001             BEQ.N    ??ccm_auth_crypt_3
    491                  return ret;
   \       0x5E   0x9802             LDR      R0,[SP, #+8]
   \       0x60   0xE018             B.N      ??ccm_auth_crypt_1
    492              }
    493          
    494              if ((ret = mbedtls_ccm_update(ctx, input, length,
    495                                            output, length, &olen)) != 0) {
   \                     ??ccm_auth_crypt_3: (+1)
   \       0x62   0xA803             ADD      R0,SP,#+12
   \       0x64   0x9001             STR      R0,[SP, #+4]
   \       0x66   0x9400             STR      R4,[SP, #+0]
   \       0x68   0x4643             MOV      R3,R8
   \       0x6A   0x0022             MOVS     R2,R4
   \       0x6C   0x0039             MOVS     R1,R7
   \       0x6E   0x4658             MOV      R0,R11
   \       0x70   0x.... 0x....      BL       mbedtls_ccm_update
   \       0x74   0x9002             STR      R0,[SP, #+8]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD001             BEQ.N    ??ccm_auth_crypt_4
    496                  return ret;
   \       0x7A   0x9802             LDR      R0,[SP, #+8]
   \       0x7C   0xE00A             B.N      ??ccm_auth_crypt_1
    497              }
    498          
    499              if ((ret = mbedtls_ccm_finish(ctx, tag, tag_len)) != 0) {
   \                     ??ccm_auth_crypt_4: (+1)
   \       0x7E   0x4652             MOV      R2,R10
   \       0x80   0x4649             MOV      R1,R9
   \       0x82   0x4658             MOV      R0,R11
   \       0x84   0x.... 0x....      BL       mbedtls_ccm_finish
   \       0x88   0x0001             MOVS     R1,R0
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD001             BEQ.N    ??ccm_auth_crypt_5
    500                  return ret;
   \       0x8E   0x0008             MOVS     R0,R1
   \       0x90   0xE000             B.N      ??ccm_auth_crypt_1
    501              }
    502          
    503              return 0;
   \                     ??ccm_auth_crypt_5: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \                     ??ccm_auth_crypt_1: (+1)
   \       0x94   0xB007             ADD      SP,SP,#+28
   \       0x96   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    504          }
    505          
    506          /*
    507           * Authenticated encryption
    508           */

   \                                 In section .text, align 2, keep-with-next
    509          int mbedtls_ccm_star_encrypt_and_tag(mbedtls_ccm_context *ctx, size_t length,
    510                                               const unsigned char *iv, size_t iv_len,
    511                                               const unsigned char *add, size_t add_len,
    512                                               const unsigned char *input, unsigned char *output,
    513                                               unsigned char *tag, size_t tag_len)
    514          {
   \                     mbedtls_ccm_star_encrypt_and_tag: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    515              return ccm_auth_crypt(ctx, MBEDTLS_CCM_STAR_ENCRYPT, length, iv, iv_len,
    516                                    add, add_len, input, output, tag, tag_len);
   \        0xC   0x9811             LDR      R0,[SP, #+68]
   \        0xE   0x9006             STR      R0,[SP, #+24]
   \       0x10   0x9810             LDR      R0,[SP, #+64]
   \       0x12   0x9005             STR      R0,[SP, #+20]
   \       0x14   0x980F             LDR      R0,[SP, #+60]
   \       0x16   0x9004             STR      R0,[SP, #+16]
   \       0x18   0x980E             LDR      R0,[SP, #+56]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   \       0x1C   0x980D             LDR      R0,[SP, #+52]
   \       0x1E   0x9002             STR      R0,[SP, #+8]
   \       0x20   0x980C             LDR      R0,[SP, #+48]
   \       0x22   0x9001             STR      R0,[SP, #+4]
   \       0x24   0x9700             STR      R7,[SP, #+0]
   \       0x26   0x0033             MOVS     R3,R6
   \       0x28   0x002A             MOVS     R2,R5
   \       0x2A   0x2103             MOVS     R1,#+3
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       ccm_auth_crypt
   \       0x32   0xB007             ADD      SP,SP,#+28
   \       0x34   0xBDF0             POP      {R4-R7,PC}
    517          }
    518          

   \                                 In section .text, align 2, keep-with-next
    519          int mbedtls_ccm_encrypt_and_tag(mbedtls_ccm_context *ctx, size_t length,
    520                                          const unsigned char *iv, size_t iv_len,
    521                                          const unsigned char *add, size_t add_len,
    522                                          const unsigned char *input, unsigned char *output,
    523                                          unsigned char *tag, size_t tag_len)
    524          {
   \                     mbedtls_ccm_encrypt_and_tag: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    525              return ccm_auth_crypt(ctx, MBEDTLS_CCM_ENCRYPT, length, iv, iv_len,
    526                                    add, add_len, input, output, tag, tag_len);
   \        0xC   0x9811             LDR      R0,[SP, #+68]
   \        0xE   0x9006             STR      R0,[SP, #+24]
   \       0x10   0x9810             LDR      R0,[SP, #+64]
   \       0x12   0x9005             STR      R0,[SP, #+20]
   \       0x14   0x980F             LDR      R0,[SP, #+60]
   \       0x16   0x9004             STR      R0,[SP, #+16]
   \       0x18   0x980E             LDR      R0,[SP, #+56]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   \       0x1C   0x980D             LDR      R0,[SP, #+52]
   \       0x1E   0x9002             STR      R0,[SP, #+8]
   \       0x20   0x980C             LDR      R0,[SP, #+48]
   \       0x22   0x9001             STR      R0,[SP, #+4]
   \       0x24   0x9700             STR      R7,[SP, #+0]
   \       0x26   0x0033             MOVS     R3,R6
   \       0x28   0x002A             MOVS     R2,R5
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       ccm_auth_crypt
   \       0x32   0xB007             ADD      SP,SP,#+28
   \       0x34   0xBDF0             POP      {R4-R7,PC}
    527          }
    528          
    529          /*
    530           * Authenticated decryption
    531           */

   \                                 In section .text, align 2, keep-with-next
    532          static int mbedtls_ccm_compare_tags(const unsigned char *tag1,
    533                                              const unsigned char *tag2,
    534                                              size_t tag_len)
    535          {
   \                     mbedtls_ccm_compare_tags: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
    536              /* Check tag in "constant-time" */
    537              int diff = mbedtls_ct_memcmp(tag1, tag2, tag_len);
   \        0x8   0x002A             MOVS     R2,R5
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0030             MOVS     R0,R6
   \        0xE   0x.... 0x....      BL       mbedtls_ct_memcmp
   \       0x12   0x0001             MOVS     R1,R0
    538          
    539              if (diff != 0) {
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD002             BEQ.N    ??mbedtls_ccm_compare_tags_0
    540                  return MBEDTLS_ERR_CCM_AUTH_FAILED;
   \       0x18   0xF07F 0x000E      MVNS     R0,#+14
   \       0x1C   0xE000             B.N      ??mbedtls_ccm_compare_tags_1
    541              }
    542          
    543              return 0;
   \                     ??mbedtls_ccm_compare_tags_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_compare_tags_1: (+1)
   \       0x20   0xBD70             POP      {R4-R6,PC}
    544          }
    545          

   \                                 In section .text, align 2, keep-with-next
    546          static int ccm_auth_decrypt(mbedtls_ccm_context *ctx, int mode, size_t length,
    547                                      const unsigned char *iv, size_t iv_len,
    548                                      const unsigned char *add, size_t add_len,
    549                                      const unsigned char *input, unsigned char *output,
    550                                      const unsigned char *tag, size_t tag_len)
    551          {
   \                     ccm_auth_decrypt: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
   \        0xE   0x9F18             LDR      R7,[SP, #+96]
   \       0x10   0xF8DD 0x8064      LDR      R8,[SP, #+100]
   \       0x14   0xF8DD 0x9068      LDR      R9,[SP, #+104]
    552              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x18   0xF07F 0x0A6D      MVNS     R10,#+109
    553              unsigned char check_tag[16];
    554          
    555              if ((ret = ccm_auth_crypt(ctx, mode, length,
    556                                        iv, iv_len, add, add_len,
    557                                        input, output, check_tag, tag_len)) != 0) {
   \       0x1C   0xF8CD 0x9018      STR      R9,[SP, #+24]
   \       0x20   0xA807             ADD      R0,SP,#+28
   \       0x22   0x9005             STR      R0,[SP, #+20]
   \       0x24   0x9704             STR      R7,[SP, #+16]
   \       0x26   0x9817             LDR      R0,[SP, #+92]
   \       0x28   0x9003             STR      R0,[SP, #+12]
   \       0x2A   0x9816             LDR      R0,[SP, #+88]
   \       0x2C   0x9002             STR      R0,[SP, #+8]
   \       0x2E   0x9815             LDR      R0,[SP, #+84]
   \       0x30   0x9001             STR      R0,[SP, #+4]
   \       0x32   0x9814             LDR      R0,[SP, #+80]
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x0033             MOVS     R3,R6
   \       0x38   0x002A             MOVS     R2,R5
   \       0x3A   0x0021             MOVS     R1,R4
   \       0x3C   0x4658             MOV      R0,R11
   \       0x3E   0x.... 0x....      BL       ccm_auth_crypt
   \       0x42   0x9000             STR      R0,[SP, #+0]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD001             BEQ.N    ??ccm_auth_decrypt_0
    558                  return ret;
   \       0x48   0x9800             LDR      R0,[SP, #+0]
   \       0x4A   0xE00E             B.N      ??ccm_auth_decrypt_1
    559              }
    560          
    561              if ((ret = mbedtls_ccm_compare_tags(tag, check_tag, tag_len)) != 0) {
   \                     ??ccm_auth_decrypt_0: (+1)
   \       0x4C   0x464A             MOV      R2,R9
   \       0x4E   0xA907             ADD      R1,SP,#+28
   \       0x50   0x4640             MOV      R0,R8
   \       0x52   0x.... 0x....      BL       mbedtls_ccm_compare_tags
   \       0x56   0x4682             MOV      R10,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD005             BEQ.N    ??ccm_auth_decrypt_2
    562                  mbedtls_platform_zeroize(output, length);
   \       0x5C   0x0029             MOVS     R1,R5
   \       0x5E   0x0038             MOVS     R0,R7
   \       0x60   0x.... 0x....      BL       mbedtls_platform_zeroize
    563                  return ret;
   \       0x64   0x4650             MOV      R0,R10
   \       0x66   0xE000             B.N      ??ccm_auth_decrypt_1
    564              }
    565          
    566              return 0;
   \                     ??ccm_auth_decrypt_2: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??ccm_auth_decrypt_1: (+1)
   \       0x6A   0xB00B             ADD      SP,SP,#+44
   \       0x6C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    567          }
    568          

   \                                 In section .text, align 2, keep-with-next
    569          int mbedtls_ccm_star_auth_decrypt(mbedtls_ccm_context *ctx, size_t length,
    570                                            const unsigned char *iv, size_t iv_len,
    571                                            const unsigned char *add, size_t add_len,
    572                                            const unsigned char *input, unsigned char *output,
    573                                            const unsigned char *tag, size_t tag_len)
    574          {
   \                     mbedtls_ccm_star_auth_decrypt: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    575              return ccm_auth_decrypt(ctx, MBEDTLS_CCM_STAR_DECRYPT, length,
    576                                      iv, iv_len, add, add_len,
    577                                      input, output, tag, tag_len);
   \        0xC   0x9811             LDR      R0,[SP, #+68]
   \        0xE   0x9006             STR      R0,[SP, #+24]
   \       0x10   0x9810             LDR      R0,[SP, #+64]
   \       0x12   0x9005             STR      R0,[SP, #+20]
   \       0x14   0x980F             LDR      R0,[SP, #+60]
   \       0x16   0x9004             STR      R0,[SP, #+16]
   \       0x18   0x980E             LDR      R0,[SP, #+56]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   \       0x1C   0x980D             LDR      R0,[SP, #+52]
   \       0x1E   0x9002             STR      R0,[SP, #+8]
   \       0x20   0x980C             LDR      R0,[SP, #+48]
   \       0x22   0x9001             STR      R0,[SP, #+4]
   \       0x24   0x9700             STR      R7,[SP, #+0]
   \       0x26   0x0033             MOVS     R3,R6
   \       0x28   0x002A             MOVS     R2,R5
   \       0x2A   0x2102             MOVS     R1,#+2
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       ccm_auth_decrypt
   \       0x32   0xB007             ADD      SP,SP,#+28
   \       0x34   0xBDF0             POP      {R4-R7,PC}
    578          }
    579          

   \                                 In section .text, align 2, keep-with-next
    580          int mbedtls_ccm_auth_decrypt(mbedtls_ccm_context *ctx, size_t length,
    581                                       const unsigned char *iv, size_t iv_len,
    582                                       const unsigned char *add, size_t add_len,
    583                                       const unsigned char *input, unsigned char *output,
    584                                       const unsigned char *tag, size_t tag_len)
    585          {
   \                     mbedtls_ccm_auth_decrypt: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    586              return ccm_auth_decrypt(ctx, MBEDTLS_CCM_DECRYPT, length,
    587                                      iv, iv_len, add, add_len,
    588                                      input, output, tag, tag_len);
   \        0xC   0x9811             LDR      R0,[SP, #+68]
   \        0xE   0x9006             STR      R0,[SP, #+24]
   \       0x10   0x9810             LDR      R0,[SP, #+64]
   \       0x12   0x9005             STR      R0,[SP, #+20]
   \       0x14   0x980F             LDR      R0,[SP, #+60]
   \       0x16   0x9004             STR      R0,[SP, #+16]
   \       0x18   0x980E             LDR      R0,[SP, #+56]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   \       0x1C   0x980D             LDR      R0,[SP, #+52]
   \       0x1E   0x9002             STR      R0,[SP, #+8]
   \       0x20   0x980C             LDR      R0,[SP, #+48]
   \       0x22   0x9001             STR      R0,[SP, #+4]
   \       0x24   0x9700             STR      R7,[SP, #+0]
   \       0x26   0x0033             MOVS     R3,R6
   \       0x28   0x002A             MOVS     R2,R5
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       ccm_auth_decrypt
   \       0x32   0xB007             ADD      SP,SP,#+28
   \       0x34   0xBDF0             POP      {R4-R7,PC}
    589          }
    590          #endif /* !MBEDTLS_CCM_ALT */
    591          
    592          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
    593          /*
    594           * Examples 1 to 3 from SP800-38C Appendix C
    595           */
    596          
    597          #define NB_TESTS 3
    598          #define CCM_SELFTEST_PT_MAX_LEN 24
    599          #define CCM_SELFTEST_CT_MAX_LEN 32
    600          /*
    601           * The data is the same for all tests, only the used length changes
    602           */
    603          static const unsigned char key_test_data[] = {
    604              0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    605              0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
    606          };
    607          
    608          static const unsigned char iv_test_data[] = {
    609              0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    610              0x18, 0x19, 0x1a, 0x1b
    611          };
    612          
    613          static const unsigned char ad_test_data[] = {
    614              0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    615              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    616              0x10, 0x11, 0x12, 0x13
    617          };
    618          
    619          static const unsigned char msg_test_data[CCM_SELFTEST_PT_MAX_LEN] = {
    620              0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    621              0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    622              0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    623          };
    624          
    625          static const size_t iv_len_test_data[NB_TESTS] = { 7, 8,  12 };
    626          static const size_t add_len_test_data[NB_TESTS] = { 8, 16, 20 };
    627          static const size_t msg_len_test_data[NB_TESTS] = { 4, 16, 24 };
    628          static const size_t tag_len_test_data[NB_TESTS] = { 4, 6,  8  };
    629          
    630          static const unsigned char res_test_data[NB_TESTS][CCM_SELFTEST_CT_MAX_LEN] = {
    631              {   0x71, 0x62, 0x01, 0x5b, 0x4d, 0xac, 0x25, 0x5d },
    632              {   0xd2, 0xa1, 0xf0, 0xe0, 0x51, 0xea, 0x5f, 0x62,
    633                  0x08, 0x1a, 0x77, 0x92, 0x07, 0x3d, 0x59, 0x3d,
    634                  0x1f, 0xc6, 0x4f, 0xbf, 0xac, 0xcd },
    635              {   0xe3, 0xb2, 0x01, 0xa9, 0xf5, 0xb7, 0x1a, 0x7a,
    636                  0x9b, 0x1c, 0xea, 0xec, 0xcd, 0x97, 0xe7, 0x0b,
    637                  0x61, 0x76, 0xaa, 0xd9, 0xa4, 0x42, 0x8a, 0xa5,
    638                  0x48, 0x43, 0x92, 0xfb, 0xc1, 0xb0, 0x99, 0x51 }
    639          };
    640          
    641          int mbedtls_ccm_self_test(int verbose)
    642          {
    643              mbedtls_ccm_context ctx;
    644              /*
    645               * Some hardware accelerators require the input and output buffers
    646               * would be in RAM, because the flash is not accessible.
    647               * Use buffers on the stack to hold the test vectors data.
    648               */
    649              unsigned char plaintext[CCM_SELFTEST_PT_MAX_LEN];
    650              unsigned char ciphertext[CCM_SELFTEST_CT_MAX_LEN];
    651              size_t i;
    652              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    653          
    654              mbedtls_ccm_init(&ctx);
    655          
    656              if (mbedtls_ccm_setkey(&ctx, MBEDTLS_CIPHER_ID_AES, key_test_data,
    657                                     8 * sizeof(key_test_data)) != 0) {
    658                  if (verbose != 0) {
    659                      mbedtls_printf("  CCM: setup failed");
    660                  }
    661          
    662                  return 1;
    663              }
    664          
    665              for (i = 0; i < NB_TESTS; i++) {
    666                  if (verbose != 0) {
    667                      mbedtls_printf("  CCM-AES #%u: ", (unsigned int) i + 1);
    668                  }
    669          
    670                  memset(plaintext, 0, CCM_SELFTEST_PT_MAX_LEN);
    671                  memset(ciphertext, 0, CCM_SELFTEST_CT_MAX_LEN);
    672                  memcpy(plaintext, msg_test_data, msg_len_test_data[i]);
    673          
    674                  ret = mbedtls_ccm_encrypt_and_tag(&ctx, msg_len_test_data[i],
    675                                                    iv_test_data, iv_len_test_data[i],
    676                                                    ad_test_data, add_len_test_data[i],
    677                                                    plaintext, ciphertext,
    678                                                    ciphertext + msg_len_test_data[i],
    679                                                    tag_len_test_data[i]);
    680          
    681                  if (ret != 0 ||
    682                      memcmp(ciphertext, res_test_data[i],
    683                             msg_len_test_data[i] + tag_len_test_data[i]) != 0) {
    684                      if (verbose != 0) {
    685                          mbedtls_printf("failed\n");
    686                      }
    687          
    688                      return 1;
    689                  }
    690                  memset(plaintext, 0, CCM_SELFTEST_PT_MAX_LEN);
    691          
    692                  ret = mbedtls_ccm_auth_decrypt(&ctx, msg_len_test_data[i],
    693                                                 iv_test_data, iv_len_test_data[i],
    694                                                 ad_test_data, add_len_test_data[i],
    695                                                 ciphertext, plaintext,
    696                                                 ciphertext + msg_len_test_data[i],
    697                                                 tag_len_test_data[i]);
    698          
    699                  if (ret != 0 ||
    700                      memcmp(plaintext, msg_test_data, msg_len_test_data[i]) != 0) {
    701                      if (verbose != 0) {
    702                          mbedtls_printf("failed\n");
    703                      }
    704          
    705                      return 1;
    706                  }
    707          
    708                  if (verbose != 0) {
    709                      mbedtls_printf("passed\n");
    710                  }
    711              }
    712          
    713              mbedtls_ccm_free(&ctx);
    714          
    715              if (verbose != 0) {
    716                  mbedtls_printf("\n");
    717              }
    718          
    719              return 0;
    720          }
    721          
    722          #endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
    723          
    724          #endif /* MBEDTLS_CCM_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   ccm_auth_crypt
        64   -> mbedtls_ccm_finish
        64   -> mbedtls_ccm_set_lengths
        64   -> mbedtls_ccm_starts
        64   -> mbedtls_ccm_update
        64   -> mbedtls_ccm_update_ad
      80   ccm_auth_decrypt
        80   -> ccm_auth_crypt
        80   -> mbedtls_ccm_compare_tags
        80   -> mbedtls_platform_zeroize
      32   ccm_calculate_first_block_if_ready
        32   -> mbedtls_cipher_update
      48   mbedtls_ccm_auth_decrypt
        48   -> ccm_auth_decrypt
      32   mbedtls_ccm_clear_state
        32   -> __aeabi_memset
      16   mbedtls_ccm_compare_tags
        16   -> mbedtls_ct_memcmp
      56   mbedtls_ccm_crypt
        56   -> __aeabi_memset
        56   -> mbedtls_cipher_update
        56   -> mbedtls_platform_zeroize
        56   -> mbedtls_xor
      48   mbedtls_ccm_encrypt_and_tag
        48   -> ccm_auth_crypt
      40   mbedtls_ccm_finish
        40   -> __aeabi_memcpy
        40   -> mbedtls_ccm_clear_state
        40   -> mbedtls_ccm_crypt
       8   mbedtls_ccm_free
         8   -> mbedtls_cipher_free
         8   -> mbedtls_platform_zeroize
      24   mbedtls_ccm_init
        24   -> __aeabi_memset
      24   mbedtls_ccm_set_lengths
        24   -> ccm_calculate_first_block_if_ready
      32   mbedtls_ccm_setkey
        32   -> mbedtls_cipher_free
        32   -> mbedtls_cipher_info_from_values
        32   -> mbedtls_cipher_info_get_block_size
        32   -> mbedtls_cipher_setkey
        32   -> mbedtls_cipher_setup
      48   mbedtls_ccm_star_auth_decrypt
        48   -> ccm_auth_decrypt
      48   mbedtls_ccm_star_encrypt_and_tag
        48   -> ccm_auth_crypt
      56   mbedtls_ccm_starts
        56   -> __aeabi_memcpy
        56   -> __aeabi_memset
        56   -> ccm_calculate_first_block_if_ready
      72   mbedtls_ccm_update
        72   -> __aeabi_memcpy
        72   -> mbedtls_ccm_crypt
        72   -> mbedtls_cipher_update
        72   -> mbedtls_platform_zeroize
        72   -> mbedtls_xor
      40   mbedtls_ccm_update_ad
        40   -> mbedtls_cipher_update
        40   -> mbedtls_xor
       0   mbedtls_cipher_info_get_block_size
      24   mbedtls_get_unaligned_uint32
        24   -> __aeabi_memcpy
      24   mbedtls_put_unaligned_uint32
        24   -> __aeabi_memcpy
      32   mbedtls_xor
        32   -> mbedtls_get_unaligned_uint32
        32   -> mbedtls_put_unaligned_uint32


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     154  ccm_auth_crypt
     112  ccm_auth_decrypt
     194  ccm_calculate_first_block_if_ready
      54  mbedtls_ccm_auth_decrypt
      52  mbedtls_ccm_clear_state
      34  mbedtls_ccm_compare_tags
     120  mbedtls_ccm_crypt
      54  mbedtls_ccm_encrypt_and_tag
     164  mbedtls_ccm_finish
      26  mbedtls_ccm_free
      22  mbedtls_ccm_init
      70  mbedtls_ccm_set_lengths
     114  mbedtls_ccm_setkey
      54  mbedtls_ccm_star_auth_decrypt
      54  mbedtls_ccm_star_encrypt_and_tag
     168  mbedtls_ccm_starts
     458  mbedtls_ccm_update
     256  mbedtls_ccm_update_ad
      18  mbedtls_cipher_info_get_block_size
      24  mbedtls_get_unaligned_uint32
      22  mbedtls_put_unaligned_uint32
      92  mbedtls_xor

 
 2'316 bytes in section .text
 
 2'178 bytes of CODE memory (+ 138 bytes shared)

Errors: none
Warnings: none
