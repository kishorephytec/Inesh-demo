###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:49
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\pk_wrap.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\pk_wrap.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\pk_wrap.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\pk_wrap.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\pk_wrap.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\pk_wrap.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\pk_wrap.c
      1          /*
      2           *  Public Key abstraction layer: wrapper functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"
     21          
     22          #include "mbedtls/platform_util.h"
     23          
     24          #if defined(MBEDTLS_PK_C)
     25          #include "pk_wrap.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_extend_key_usage_flags(uint32_t *)
   \                     psa_extend_key_usage_flags: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x04C9             LSLS     R1,R1,#+19
   \        0x4   0xD503             BPL.N    ??psa_extend_key_usage_flags_0
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0xF451 0x6180      ORRS     R1,R1,#0x400
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \                     ??psa_extend_key_usage_flags_0: (+1)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x0489             LSLS     R1,R1,#+18
   \       0x12   0xD503             BPL.N    ??psa_extend_key_usage_flags_1
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF451 0x6100      ORRS     R1,R1,#0x800
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   \                     ??psa_extend_key_usage_flags_1: (+1)
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_usage_flags(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_usage_flags: (+1)
   \        0x0   0xB513             PUSH     {R0,R1,R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0xA801             ADD      R0,SP,#+4
   \        0x6   0x.... 0x....      BL       psa_extend_key_usage_flags
   \        0xA   0x9801             LDR      R0,[SP, #+4]
   \        0xC   0x60E0             STR      R0,[R4, #+12]
   \        0xE   0xBD13             POP      {R0,R1,R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_algorithm(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_algorithm: (+1)
   \        0x0   0x6101             STR      R1,[R0, #+16]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t psa_get_key_algorithm(psa_key_attributes_t const *)
   \                     psa_get_key_algorithm: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_type(psa_key_attributes_t *, uint16_t)
   \                     psa_set_key_type: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x69E8             LDR      R0,[R5, #+28]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??psa_set_key_type_0
   \        0xC   0x802C             STRH     R4,[R5, #+0]
   \        0xE   0xE006             B.N      ??psa_set_key_type_1
   \                     ??psa_set_key_type_0: (+1)
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x0021             MOVS     R1,R4
   \       0x16   0xB289             UXTH     R1,R1
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       psa_set_key_domain_parameters
   \                     ??psa_set_key_type_1: (+1)
   \       0x1E   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t psa_get_key_type(psa_key_attributes_t const *)
   \                     psa_get_key_type: (+1)
   \        0x0   0x8800             LDRH     R0,[R0, #+0]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t psa_get_key_bits(psa_key_attributes_t const *)
   \                     psa_get_key_bits: (+1)
   \        0x0   0x8840             LDRH     R0,[R0, #+2]
   \        0x2   0x4770             BX       LR
     26          #include "pk_internal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp mbedtls_ecp_keypair const *mbedtls_pk_ec_ro(mbedtls_pk_context const)
   \                     mbedtls_pk_ec_ro: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB580             PUSH     {R7,LR}
   \        0x4   0xA802             ADD      R0,SP,#+8
   \        0x6   0x.... 0x....      BL       mbedtls_pk_get_type
   \        0xA   0x1E80             SUBS     R0,R0,#+2
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD801             BHI.N    ??mbedtls_pk_ec_ro_0
   \                     ??mbedtls_pk_ec_ro_1: (+1)
   \       0x10   0x9803             LDR      R0,[SP, #+12]
   \       0x12   0xE000             B.N      ??mbedtls_pk_ec_ro_2
   \                     ??mbedtls_pk_ec_ro_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_pk_ec_ro_2: (+1)
   \       0x16   0xBC02             POP      {R1}
   \       0x18   0xF85D 0xFB14      LDR      PC,[SP], #+20

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp mbedtls_ecp_keypair *mbedtls_pk_ec_rw(mbedtls_pk_context const)
   \                     mbedtls_pk_ec_rw: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB580             PUSH     {R7,LR}
   \        0x4   0xA802             ADD      R0,SP,#+8
   \        0x6   0x.... 0x....      BL       mbedtls_pk_get_type
   \        0xA   0x1E80             SUBS     R0,R0,#+2
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD801             BHI.N    ??mbedtls_pk_ec_rw_0
   \                     ??mbedtls_pk_ec_rw_1: (+1)
   \       0x10   0x9803             LDR      R0,[SP, #+12]
   \       0x12   0xE000             B.N      ??mbedtls_pk_ec_rw_2
   \                     ??mbedtls_pk_ec_rw_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_pk_ec_rw_2: (+1)
   \       0x16   0xBC02             POP      {R1}
   \       0x18   0xF85D 0xFB14      LDR      PC,[SP], #+20
     27          #include "mbedtls/error.h"
     28          #include "md_psa.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_md_psa_alg_from_type(mbedtls_md_type_t)
   \                     mbedtls_md_psa_alg_from_type: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0
   \        0x2   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \        0x6   0x4770             BX       LR
     29          
     30          /* Even if RSA not activated, for the sake of RSA-alt */
     31          #include "mbedtls/rsa.h"
     32          
     33          #if defined(MBEDTLS_ECP_C)
     34          #include "mbedtls/ecp.h"
     35          #endif
     36          
     37          #if defined(MBEDTLS_ECDSA_C)
     38          #include "mbedtls/ecdsa.h"
     39          #endif
     40          
     41          #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_PSA_CRYPTO_C)
     42          #include "pkwrite.h"
     43          #endif
     44          
     45          #if defined(MBEDTLS_PSA_CRYPTO_C)
     46          #include "psa_util_internal.h"
     47          #endif
     48          
     49          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     50          #include "psa/crypto.h"
     51          
     52          #if defined(MBEDTLS_PK_CAN_ECDSA_SOME)
     53          #include "mbedtls/asn1write.h"
     54          #include "mbedtls/asn1.h"
     55          #endif
     56          #endif  /* MBEDTLS_USE_PSA_CRYPTO */
     57          
     58          #include "mbedtls/platform.h"
     59          
     60          #include <limits.h>
     61          #include <stdint.h>
     62          #include <string.h>
     63          
     64          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
     65          #if defined(MBEDTLS_PSA_CRYPTO_C)

   \                                 In section .text, align 2, keep-with-next
     66          int mbedtls_pk_error_from_psa(psa_status_t status)
     67          {
   \                     mbedtls_pk_error_from_psa: (+1)
   \        0x0   0x0001             MOVS     R1,R0
     68              switch (status) {
   \        0x2   0x000A             MOVS     R2,R1
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD01B             BEQ.N    ??mbedtls_pk_error_from_psa_0
   \        0x8   0xF07F 0x0098      MVNS     R0,#+152
   \        0xC   0x1A12             SUBS     R2,R2,R0
   \        0xE   0x2A01             CMP      R2,#+1
   \       0x10   0xD930             BLS.N    ??mbedtls_pk_error_from_psa_1
   \       0x12   0x1E92             SUBS     R2,R2,#+2
   \       0x14   0xD031             BEQ.N    ??mbedtls_pk_error_from_psa_2
   \       0x16   0x1F12             SUBS     R2,R2,#+4
   \       0x18   0xD029             BEQ.N    ??mbedtls_pk_error_from_psa_3
   \       0x1A   0x1E52             SUBS     R2,R2,#+1
   \       0x1C   0xD02A             BEQ.N    ??mbedtls_pk_error_from_psa_1
   \       0x1E   0x1E52             SUBS     R2,R2,#+1
   \       0x20   0xD025             BEQ.N    ??mbedtls_pk_error_from_psa_3
   \       0x22   0x1F12             SUBS     R2,R2,#+4
   \       0x24   0xD01D             BEQ.N    ??mbedtls_pk_error_from_psa_4
   \       0x26   0x1ED2             SUBS     R2,R2,#+3
   \       0x28   0xD012             BEQ.N    ??mbedtls_pk_error_from_psa_5
   \       0x2A   0x1E52             SUBS     R2,R2,#+1
   \       0x2C   0xD01C             BEQ.N    ??mbedtls_pk_error_from_psa_6
   \       0x2E   0x1E52             SUBS     R2,R2,#+1
   \       0x30   0xD008             BEQ.N    ??mbedtls_pk_error_from_psa_7
   \       0x32   0x1E52             SUBS     R2,R2,#+1
   \       0x34   0xD012             BEQ.N    ??mbedtls_pk_error_from_psa_8
   \       0x36   0x1E52             SUBS     R2,R2,#+1
   \       0x38   0xD00D             BEQ.N    ??mbedtls_pk_error_from_psa_9
   \       0x3A   0x1E52             SUBS     R2,R2,#+1
   \       0x3C   0xD005             BEQ.N    ??mbedtls_pk_error_from_psa_10
   \       0x3E   0xE01F             B.N      ??mbedtls_pk_error_from_psa_11
     69                  case PSA_SUCCESS:
     70                      return 0;
   \                     ??mbedtls_pk_error_from_psa_0: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xE01F             B.N      ??mbedtls_pk_error_from_psa_12
     71                  case PSA_ERROR_INVALID_HANDLE:
     72                      return MBEDTLS_ERR_PK_KEY_INVALID_FORMAT;
   \                     ??mbedtls_pk_error_from_psa_7: (+1)
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x48   0xE01C             B.N      ??mbedtls_pk_error_from_psa_12
     73                  case PSA_ERROR_NOT_PERMITTED:
     74                      return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
   \                     ??mbedtls_pk_error_from_psa_10: (+1)
   \       0x4A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x4E   0xE019             B.N      ??mbedtls_pk_error_from_psa_12
     75                  case PSA_ERROR_BUFFER_TOO_SMALL:
     76                      return MBEDTLS_ERR_PK_BUFFER_TOO_SMALL;
   \                     ??mbedtls_pk_error_from_psa_5: (+1)
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \       0x54   0xE016             B.N      ??mbedtls_pk_error_from_psa_12
     77                  case PSA_ERROR_NOT_SUPPORTED:
     78                      return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_pk_error_from_psa_9: (+1)
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \       0x5A   0xE013             B.N      ??mbedtls_pk_error_from_psa_12
     79                  case PSA_ERROR_INVALID_ARGUMENT:
     80                      return MBEDTLS_ERR_PK_INVALID_ALG;
   \                     ??mbedtls_pk_error_from_psa_8: (+1)
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \       0x60   0xE010             B.N      ??mbedtls_pk_error_from_psa_12
     81                  case PSA_ERROR_INSUFFICIENT_MEMORY:
     82                      return MBEDTLS_ERR_PK_ALLOC_FAILED;
   \                     ??mbedtls_pk_error_from_psa_4: (+1)
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \       0x66   0xE00D             B.N      ??mbedtls_pk_error_from_psa_12
     83                  case PSA_ERROR_BAD_STATE:
     84                      return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_error_from_psa_6: (+1)
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \       0x6C   0xE00A             B.N      ??mbedtls_pk_error_from_psa_12
     85                  case PSA_ERROR_COMMUNICATION_FAILURE:
     86                  case PSA_ERROR_HARDWARE_FAILURE:
     87                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \                     ??mbedtls_pk_error_from_psa_3: (+1)
   \       0x6E   0xF07F 0x006F      MVNS     R0,#+111
   \       0x72   0xE007             B.N      ??mbedtls_pk_error_from_psa_12
     88                  case PSA_ERROR_DATA_CORRUPT:
     89                  case PSA_ERROR_DATA_INVALID:
     90                  case PSA_ERROR_STORAGE_FAILURE:
     91                      return MBEDTLS_ERR_PK_FILE_IO_ERROR;
   \                     ??mbedtls_pk_error_from_psa_1: (+1)
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \       0x78   0xE004             B.N      ??mbedtls_pk_error_from_psa_12
     92                  case PSA_ERROR_CORRUPTION_DETECTED:
     93                      return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_pk_error_from_psa_2: (+1)
   \       0x7A   0xF07F 0x006D      MVNS     R0,#+109
   \       0x7E   0xE001             B.N      ??mbedtls_pk_error_from_psa_12
     94                  default:
     95                      return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
   \                     ??mbedtls_pk_error_from_psa_11: (+1)
   \       0x80   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??mbedtls_pk_error_from_psa_12: (+1)
   \       0x84   0x4770             BX       LR
     96              }
     97          }
     98          
     99          #if defined(PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY) ||    \
    100              defined(PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC)
    101          int mbedtls_pk_error_from_psa_rsa(psa_status_t status)
    102          {
    103              switch (status) {
    104                  case PSA_ERROR_NOT_PERMITTED:
    105                  case PSA_ERROR_INVALID_ARGUMENT:
    106                  case PSA_ERROR_INVALID_HANDLE:
    107                      return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
    108                  case PSA_ERROR_BUFFER_TOO_SMALL:
    109                      return MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
    110                  case PSA_ERROR_INSUFFICIENT_ENTROPY:
    111                      return MBEDTLS_ERR_RSA_RNG_FAILED;
    112                  case PSA_ERROR_INVALID_SIGNATURE:
    113                      return MBEDTLS_ERR_RSA_VERIFY_FAILED;
    114                  case PSA_ERROR_INVALID_PADDING:
    115                      return MBEDTLS_ERR_RSA_INVALID_PADDING;
    116                  case PSA_SUCCESS:
    117                      return 0;
    118                  case PSA_ERROR_NOT_SUPPORTED:
    119                      return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
    120                  case PSA_ERROR_INSUFFICIENT_MEMORY:
    121                      return MBEDTLS_ERR_PK_ALLOC_FAILED;
    122                  case PSA_ERROR_BAD_STATE:
    123                      return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    124                  case PSA_ERROR_COMMUNICATION_FAILURE:
    125                  case PSA_ERROR_HARDWARE_FAILURE:
    126                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
    127                  case PSA_ERROR_DATA_CORRUPT:
    128                  case PSA_ERROR_DATA_INVALID:
    129                  case PSA_ERROR_STORAGE_FAILURE:
    130                      return MBEDTLS_ERR_PK_FILE_IO_ERROR;
    131                  case PSA_ERROR_CORRUPTION_DETECTED:
    132                      return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    133                  default:
    134                      return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
    135              }
    136          }
    137          #endif /* PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY || PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC */
    138          #endif /* MBEDTLS_PSA_CRYPTO_C */
    139          
    140          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    141          #if defined(PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY)

   \                                 In section .text, align 2, keep-with-next
    142          int mbedtls_pk_error_from_psa_ecdsa(psa_status_t status)
    143          {
   \                     mbedtls_pk_error_from_psa_ecdsa: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    144              switch (status) {
   \        0x2   0x000A             MOVS     R2,R1
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD02D             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_0
   \        0x8   0xF07F 0x0098      MVNS     R0,#+152
   \        0xC   0x1A12             SUBS     R2,R2,R0
   \        0xE   0x2A01             CMP      R2,#+1
   \       0x10   0xD936             BLS.N    ??mbedtls_pk_error_from_psa_ecdsa_1
   \       0x12   0x1E92             SUBS     R2,R2,#+2
   \       0x14   0xD037             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_2
   \       0x16   0x1E92             SUBS     R2,R2,#+2
   \       0x18   0xD021             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_3
   \       0x1A   0x1E52             SUBS     R2,R2,#+1
   \       0x1C   0xD01C             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_4
   \       0x1E   0x1E52             SUBS     R2,R2,#+1
   \       0x20   0xD02B             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_5
   \       0x22   0x1E52             SUBS     R2,R2,#+1
   \       0x24   0xD02C             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_1
   \       0x26   0x1E52             SUBS     R2,R2,#+1
   \       0x28   0xD027             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_5
   \       0x2A   0x1F12             SUBS     R2,R2,#+4
   \       0x2C   0xD01F             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_6
   \       0x2E   0x1ED2             SUBS     R2,R2,#+3
   \       0x30   0xD00F             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_7
   \       0x32   0x1E52             SUBS     R2,R2,#+1
   \       0x34   0xD01E             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_8
   \       0x36   0x1E52             SUBS     R2,R2,#+1
   \       0x38   0xD008             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_9
   \       0x3A   0x1E52             SUBS     R2,R2,#+1
   \       0x3C   0xD003             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_10
   \       0x3E   0x1E52             SUBS     R2,R2,#+1
   \       0x40   0xD012             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_11
   \       0x42   0x1E52             SUBS     R2,R2,#+1
   \       0x44   0xD122             BNE.N    ??mbedtls_pk_error_from_psa_ecdsa_12
    145                  case PSA_ERROR_NOT_PERMITTED:
    146                  case PSA_ERROR_INVALID_ARGUMENT:
    147                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_10: (+1)
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable10_7
   \       0x4A   0xE021             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    148                  case PSA_ERROR_INVALID_HANDLE:
    149                      return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_9: (+1)
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable10_8
   \       0x50   0xE01E             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    150                  case PSA_ERROR_BUFFER_TOO_SMALL:
    151                      return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_7: (+1)
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \       0x56   0xE01B             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    152                  case PSA_ERROR_INSUFFICIENT_ENTROPY:
    153                      return MBEDTLS_ERR_ECP_RANDOM_FAILED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_4: (+1)
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable10_10
   \       0x5C   0xE018             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    154                  case PSA_ERROR_INVALID_SIGNATURE:
    155                      return MBEDTLS_ERR_ECP_VERIFY_FAILED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_3: (+1)
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable10_11
   \       0x62   0xE015             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    156                  case PSA_SUCCESS:
    157                      return 0;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_0: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE013             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    158                  case PSA_ERROR_NOT_SUPPORTED:
    159                      return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_11: (+1)
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \       0x6C   0xE010             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    160                  case PSA_ERROR_INSUFFICIENT_MEMORY:
    161                      return MBEDTLS_ERR_PK_ALLOC_FAILED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_6: (+1)
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \       0x72   0xE00D             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    162                  case PSA_ERROR_BAD_STATE:
    163                      return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_8: (+1)
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \       0x78   0xE00A             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    164                  case PSA_ERROR_COMMUNICATION_FAILURE:
    165                  case PSA_ERROR_HARDWARE_FAILURE:
    166                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_5: (+1)
   \       0x7A   0xF07F 0x006F      MVNS     R0,#+111
   \       0x7E   0xE007             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    167                  case PSA_ERROR_DATA_CORRUPT:
    168                  case PSA_ERROR_DATA_INVALID:
    169                  case PSA_ERROR_STORAGE_FAILURE:
    170                      return MBEDTLS_ERR_PK_FILE_IO_ERROR;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_1: (+1)
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \       0x84   0xE004             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    171                  case PSA_ERROR_CORRUPTION_DETECTED:
    172                      return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_2: (+1)
   \       0x86   0xF07F 0x006D      MVNS     R0,#+109
   \       0x8A   0xE001             B.N      ??mbedtls_pk_error_from_psa_ecdsa_13
    173                  default:
    174                      return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_12: (+1)
   \       0x8C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??mbedtls_pk_error_from_psa_ecdsa_13: (+1)
   \       0x90   0x4770             BX       LR
    175              }
    176          }
    177          #endif /* PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY */
    178          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    179          #endif /* !MBEDTLS_DEPRECATED_REMOVED */
    180          
    181          #if defined(MBEDTLS_RSA_C)
    182          static int rsa_can_do(mbedtls_pk_type_t type)
    183          {
    184              return type == MBEDTLS_PK_RSA ||
    185                     type == MBEDTLS_PK_RSASSA_PSS;
    186          }
    187          
    188          static size_t rsa_get_bitlen(mbedtls_pk_context *pk)
    189          {
    190              const mbedtls_rsa_context *rsa = (const mbedtls_rsa_context *) pk->pk_ctx;
    191              return 8 * mbedtls_rsa_get_len(rsa);
    192          }
    193          
    194          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    195          static int rsa_verify_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    196                                     const unsigned char *hash, size_t hash_len,
    197                                     const unsigned char *sig, size_t sig_len)
    198          {
    199              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    200              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    201              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    202              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    203              psa_status_t status;
    204              mbedtls_pk_context key;
    205              int key_len;
    206              unsigned char buf[MBEDTLS_PK_RSA_PUB_DER_MAX_BYTES];
    207              psa_algorithm_t psa_alg_md =
    208                  PSA_ALG_RSA_PKCS1V15_SIGN(mbedtls_md_psa_alg_from_type(md_alg));
    209              size_t rsa_len = mbedtls_rsa_get_len(rsa);
    210          
    211              if (md_alg == MBEDTLS_MD_NONE
    212          #if SIZE_MAX > UINT_MAX
    213                  && UINT_MAX < hash_len
    214          #endif
    215                  ) {
    216                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    217              }
    218          
    219              if (sig_len < rsa_len) {
    220                  return MBEDTLS_ERR_RSA_VERIFY_FAILED;
    221              }
    222          
    223              /* mbedtls_pk_write_pubkey_der() expects a full PK context;
    224               * re-construct one to make it happy */
    225              key.pk_info = &mbedtls_rsa_info;
    226              key.pk_ctx = rsa;
    227              key_len = mbedtls_pk_write_pubkey_der(&key, buf, sizeof(buf));
    228              if (key_len <= 0) {
    229                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    230              }
    231          
    232              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_VERIFY_HASH);
    233              psa_set_key_algorithm(&attributes, psa_alg_md);
    234              psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_PUBLIC_KEY);
    235          
    236              status = psa_import_key(&attributes,
    237                                      buf + sizeof(buf) - key_len, key_len,
    238                                      &key_id);
    239              if (status != PSA_SUCCESS) {
    240                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    241                  goto cleanup;
    242              }
    243          
    244              status = psa_verify_hash(key_id, psa_alg_md, hash, hash_len,
    245                                       sig, sig_len);
    246              if (status != PSA_SUCCESS) {
    247                  ret = PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    248                  goto cleanup;
    249              }
    250              ret = 0;
    251          
    252          cleanup:
    253              status = psa_destroy_key(key_id);
    254              if (ret == 0 && status != PSA_SUCCESS) {
    255                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    256              }
    257          
    258              return ret;
    259          }
    260          #else /* MBEDTLS_USE_PSA_CRYPTO */
    261          static int rsa_verify_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    262                                     const unsigned char *hash, size_t hash_len,
    263                                     const unsigned char *sig, size_t sig_len)
    264          {
    265              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    266              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    267              size_t rsa_len = mbedtls_rsa_get_len(rsa);
    268          
    269          #if SIZE_MAX > UINT_MAX
    270              if (md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len) {
    271                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    272              }
    273          #endif
    274          
    275              if (sig_len < rsa_len) {
    276                  return MBEDTLS_ERR_RSA_VERIFY_FAILED;
    277              }
    278          
    279              if ((ret = mbedtls_rsa_pkcs1_verify(rsa, md_alg,
    280                                                  (unsigned int) hash_len,
    281                                                  hash, sig)) != 0) {
    282                  return ret;
    283              }
    284          
    285              /* The buffer contains a valid signature followed by extra data.
    286               * We have a special error code for that so that so that callers can
    287               * use mbedtls_pk_verify() to check "Does the buffer start with a
    288               * valid signature?" and not just "Does the buffer contain a valid
    289               * signature?". */
    290              if (sig_len > rsa_len) {
    291                  return MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
    292              }
    293          
    294              return 0;
    295          }
    296          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    297          
    298          #if defined(MBEDTLS_PSA_CRYPTO_C)
    299          int  mbedtls_pk_psa_rsa_sign_ext(psa_algorithm_t alg,
    300                                           mbedtls_rsa_context *rsa_ctx,
    301                                           const unsigned char *hash, size_t hash_len,
    302                                           unsigned char *sig, size_t sig_size,
    303                                           size_t *sig_len)
    304          {
    305              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    306              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    307              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    308              psa_status_t status;
    309              mbedtls_pk_context key;
    310              int key_len;
    311              unsigned char *buf = NULL;
    312              buf = mbedtls_calloc(1, MBEDTLS_PK_RSA_PRV_DER_MAX_BYTES);
    313              if (buf == NULL) {
    314                  return MBEDTLS_ERR_PK_ALLOC_FAILED;
    315              }
    316              mbedtls_pk_info_t pk_info = mbedtls_rsa_info;
    317          
    318              *sig_len = mbedtls_rsa_get_len(rsa_ctx);
    319              if (sig_size < *sig_len) {
    320                  mbedtls_free(buf);
    321                  return MBEDTLS_ERR_PK_BUFFER_TOO_SMALL;
    322              }
    323          
    324              /* mbedtls_pk_write_key_der() expects a full PK context;
    325               * re-construct one to make it happy */
    326              key.pk_info = &pk_info;
    327              key.pk_ctx = rsa_ctx;
    328              key_len = mbedtls_pk_write_key_der(&key, buf, MBEDTLS_PK_RSA_PRV_DER_MAX_BYTES);
    329              if (key_len <= 0) {
    330                  mbedtls_free(buf);
    331                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    332              }
    333              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_HASH);
    334              psa_set_key_algorithm(&attributes, alg);
    335              psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_KEY_PAIR);
    336          
    337              status = psa_import_key(&attributes,
    338                                      buf + MBEDTLS_PK_RSA_PRV_DER_MAX_BYTES - key_len, key_len,
    339                                      &key_id);
    340              if (status != PSA_SUCCESS) {
    341                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    342                  goto cleanup;
    343              }
    344              status = psa_sign_hash(key_id, alg, hash, hash_len,
    345                                     sig, sig_size, sig_len);
    346              if (status != PSA_SUCCESS) {
    347                  ret = PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    348                  goto cleanup;
    349              }
    350          
    351              ret = 0;
    352          
    353          cleanup:
    354              mbedtls_free(buf);
    355              status = psa_destroy_key(key_id);
    356              if (ret == 0 && status != PSA_SUCCESS) {
    357                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    358              }
    359              return ret;
    360          }
    361          #endif /* MBEDTLS_PSA_CRYPTO_C */
    362          
    363          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    364          static int rsa_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    365                                   const unsigned char *hash, size_t hash_len,
    366                                   unsigned char *sig, size_t sig_size, size_t *sig_len,
    367                                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    368          {
    369              ((void) f_rng);
    370              ((void) p_rng);
    371          
    372              psa_algorithm_t psa_md_alg;
    373              psa_md_alg = mbedtls_md_psa_alg_from_type(md_alg);
    374              if (psa_md_alg == 0) {
    375                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    376              }
    377          
    378              return mbedtls_pk_psa_rsa_sign_ext(PSA_ALG_RSA_PKCS1V15_SIGN(
    379                                                     psa_md_alg),
    380                                                 pk->pk_ctx, hash, hash_len,
    381                                                 sig, sig_size, sig_len);
    382          }
    383          #else /* MBEDTLS_USE_PSA_CRYPTO */
    384          static int rsa_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    385                                   const unsigned char *hash, size_t hash_len,
    386                                   unsigned char *sig, size_t sig_size, size_t *sig_len,
    387                                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    388          {
    389              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    390          
    391          #if SIZE_MAX > UINT_MAX
    392              if (md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len) {
    393                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    394              }
    395          #endif
    396          
    397              *sig_len = mbedtls_rsa_get_len(rsa);
    398              if (sig_size < *sig_len) {
    399                  return MBEDTLS_ERR_PK_BUFFER_TOO_SMALL;
    400              }
    401          
    402              return mbedtls_rsa_pkcs1_sign(rsa, f_rng, p_rng,
    403                                            md_alg, (unsigned int) hash_len,
    404                                            hash, sig);
    405          }
    406          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    407          
    408          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    409          static int rsa_decrypt_wrap(mbedtls_pk_context *pk,
    410                                      const unsigned char *input, size_t ilen,
    411                                      unsigned char *output, size_t *olen, size_t osize,
    412                                      int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    413          {
    414              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    415              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    416              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    417              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    418              psa_status_t status;
    419              mbedtls_pk_context key;
    420              int key_len;
    421              unsigned char buf[MBEDTLS_PK_RSA_PRV_DER_MAX_BYTES];
    422          
    423              ((void) f_rng);
    424              ((void) p_rng);
    425          
    426          #if !defined(MBEDTLS_RSA_ALT)
    427              if (rsa->padding != MBEDTLS_RSA_PKCS_V15) {
    428                  return MBEDTLS_ERR_RSA_INVALID_PADDING;
    429              }
    430          #endif /* !MBEDTLS_RSA_ALT */
    431          
    432              if (ilen != mbedtls_rsa_get_len(rsa)) {
    433                  return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
    434              }
    435          
    436              /* mbedtls_pk_write_key_der() expects a full PK context;
    437               * re-construct one to make it happy */
    438              key.pk_info = &mbedtls_rsa_info;
    439              key.pk_ctx = rsa;
    440              key_len = mbedtls_pk_write_key_der(&key, buf, sizeof(buf));
    441              if (key_len <= 0) {
    442                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    443              }
    444          
    445              psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_KEY_PAIR);
    446              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
    447              psa_set_key_algorithm(&attributes, PSA_ALG_RSA_PKCS1V15_CRYPT);
    448          
    449              status = psa_import_key(&attributes,
    450                                      buf + sizeof(buf) - key_len, key_len,
    451                                      &key_id);
    452              if (status != PSA_SUCCESS) {
    453                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    454                  goto cleanup;
    455              }
    456          
    457              status = psa_asymmetric_decrypt(key_id, PSA_ALG_RSA_PKCS1V15_CRYPT,
    458                                              input, ilen,
    459                                              NULL, 0,
    460                                              output, osize, olen);
    461              if (status != PSA_SUCCESS) {
    462                  ret = PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    463                  goto cleanup;
    464              }
    465          
    466              ret = 0;
    467          
    468          cleanup:
    469              mbedtls_platform_zeroize(buf, sizeof(buf));
    470              status = psa_destroy_key(key_id);
    471              if (ret == 0 && status != PSA_SUCCESS) {
    472                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    473              }
    474          
    475              return ret;
    476          }
    477          #else /* MBEDTLS_USE_PSA_CRYPTO */
    478          static int rsa_decrypt_wrap(mbedtls_pk_context *pk,
    479                                      const unsigned char *input, size_t ilen,
    480                                      unsigned char *output, size_t *olen, size_t osize,
    481                                      int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    482          {
    483              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    484          
    485              if (ilen != mbedtls_rsa_get_len(rsa)) {
    486                  return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
    487              }
    488          
    489              return mbedtls_rsa_pkcs1_decrypt(rsa, f_rng, p_rng,
    490                                               olen, input, output, osize);
    491          }
    492          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    493          
    494          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    495          static int rsa_encrypt_wrap(mbedtls_pk_context *pk,
    496                                      const unsigned char *input, size_t ilen,
    497                                      unsigned char *output, size_t *olen, size_t osize,
    498                                      int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    499          {
    500              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    501              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    502              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    503              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    504              psa_status_t status;
    505              mbedtls_pk_context key;
    506              int key_len;
    507              unsigned char buf[MBEDTLS_PK_RSA_PUB_DER_MAX_BYTES];
    508          
    509              ((void) f_rng);
    510              ((void) p_rng);
    511          
    512          #if !defined(MBEDTLS_RSA_ALT)
    513              if (rsa->padding != MBEDTLS_RSA_PKCS_V15) {
    514                  return MBEDTLS_ERR_RSA_INVALID_PADDING;
    515              }
    516          #endif
    517          
    518              if (mbedtls_rsa_get_len(rsa) > osize) {
    519                  return MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
    520              }
    521          
    522              /* mbedtls_pk_write_pubkey_der() expects a full PK context;
    523               * re-construct one to make it happy */
    524              key.pk_info = &mbedtls_rsa_info;
    525              key.pk_ctx = rsa;
    526              key_len = mbedtls_pk_write_pubkey_der(&key, buf, sizeof(buf));
    527              if (key_len <= 0) {
    528                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    529              }
    530          
    531              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    532              psa_set_key_algorithm(&attributes, PSA_ALG_RSA_PKCS1V15_CRYPT);
    533              psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_PUBLIC_KEY);
    534          
    535              status = psa_import_key(&attributes,
    536                                      buf + sizeof(buf) - key_len, key_len,
    537                                      &key_id);
    538              if (status != PSA_SUCCESS) {
    539                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    540                  goto cleanup;
    541              }
    542          
    543              status = psa_asymmetric_encrypt(key_id, PSA_ALG_RSA_PKCS1V15_CRYPT,
    544                                              input, ilen,
    545                                              NULL, 0,
    546                                              output, osize, olen);
    547              if (status != PSA_SUCCESS) {
    548                  ret = PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    549                  goto cleanup;
    550              }
    551          
    552              ret = 0;
    553          
    554          cleanup:
    555              status = psa_destroy_key(key_id);
    556              if (ret == 0 && status != PSA_SUCCESS) {
    557                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    558              }
    559          
    560              return ret;
    561          }
    562          #else /* MBEDTLS_USE_PSA_CRYPTO */
    563          static int rsa_encrypt_wrap(mbedtls_pk_context *pk,
    564                                      const unsigned char *input, size_t ilen,
    565                                      unsigned char *output, size_t *olen, size_t osize,
    566                                      int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    567          {
    568              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    569              *olen = mbedtls_rsa_get_len(rsa);
    570          
    571              if (*olen > osize) {
    572                  return MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
    573              }
    574          
    575              return mbedtls_rsa_pkcs1_encrypt(rsa, f_rng, p_rng,
    576                                               ilen, input, output);
    577          }
    578          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    579          
    580          static int rsa_check_pair_wrap(mbedtls_pk_context *pub, mbedtls_pk_context *prv,
    581                                         int (*f_rng)(void *, unsigned char *, size_t),
    582                                         void *p_rng)
    583          {
    584              (void) f_rng;
    585              (void) p_rng;
    586              return mbedtls_rsa_check_pub_priv((const mbedtls_rsa_context *) pub->pk_ctx,
    587                                                (const mbedtls_rsa_context *) prv->pk_ctx);
    588          }
    589          
    590          static void *rsa_alloc_wrap(void)
    591          {
    592              void *ctx = mbedtls_calloc(1, sizeof(mbedtls_rsa_context));
    593          
    594              if (ctx != NULL) {
    595                  mbedtls_rsa_init((mbedtls_rsa_context *) ctx);
    596              }
    597          
    598              return ctx;
    599          }
    600          
    601          static void rsa_free_wrap(void *ctx)
    602          {
    603              mbedtls_rsa_free((mbedtls_rsa_context *) ctx);
    604              mbedtls_free(ctx);
    605          }
    606          
    607          static void rsa_debug(mbedtls_pk_context *pk, mbedtls_pk_debug_item *items)
    608          {
    609          #if defined(MBEDTLS_RSA_ALT)
    610              /* Not supported */
    611              (void) pk;
    612              (void) items;
    613          #else
    614              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    615          
    616              items->type = MBEDTLS_PK_DEBUG_MPI;
    617              items->name = "rsa.N";
    618              items->value = &(rsa->N);
    619          
    620              items++;
    621          
    622              items->type = MBEDTLS_PK_DEBUG_MPI;
    623              items->name = "rsa.E";
    624              items->value = &(rsa->E);
    625          #endif
    626          }
    627          
    628          const mbedtls_pk_info_t mbedtls_rsa_info = {
    629              .type = MBEDTLS_PK_RSA,
    630              .name = "RSA",
    631              .get_bitlen = rsa_get_bitlen,
    632              .can_do = rsa_can_do,
    633              .verify_func = rsa_verify_wrap,
    634              .sign_func = rsa_sign_wrap,
    635          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
    636              .verify_rs_func = NULL,
    637              .sign_rs_func = NULL,
    638              .rs_alloc_func = NULL,
    639              .rs_free_func = NULL,
    640          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
    641              .decrypt_func = rsa_decrypt_wrap,
    642              .encrypt_func = rsa_encrypt_wrap,
    643              .check_pair_func = rsa_check_pair_wrap,
    644              .ctx_alloc_func = rsa_alloc_wrap,
    645              .ctx_free_func = rsa_free_wrap,
    646              .debug_func = rsa_debug,
    647          };
    648          #endif /* MBEDTLS_RSA_C */
    649          
    650          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    651          /*
    652           * Generic EC key
    653           */

   \                                 In section .text, align 2, keep-with-next
    654          static int eckey_can_do(mbedtls_pk_type_t type)
    655          {
    656              return type == MBEDTLS_PK_ECKEY ||
    657                     type == MBEDTLS_PK_ECKEY_DH ||
    658                     type == MBEDTLS_PK_ECDSA;
   \                     eckey_can_do: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2902             CMP      R1,#+2
   \        0x6   0xD006             BEQ.N    ??eckey_can_do_0
   \        0x8   0x0001             MOVS     R1,R0
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0x2903             CMP      R1,#+3
   \        0xE   0xD002             BEQ.N    ??eckey_can_do_0
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x2804             CMP      R0,#+4
   \       0x14   0xD101             BNE.N    ??eckey_can_do_1
   \                     ??eckey_can_do_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xE000             B.N      ??eckey_can_do_2
   \                     ??eckey_can_do_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \                     ??eckey_can_do_2: (+1)
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x4770             BX       LR
    659          }
    660          

   \                                 In section .text, align 2, keep-with-next
    661          static size_t eckey_get_bitlen(mbedtls_pk_context *pk)
    662          {
   \                     eckey_get_bitlen: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    663          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
    664              return pk->ec_bits;
    665          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
    666              mbedtls_ecp_keypair *ecp = (mbedtls_ecp_keypair *) pk->pk_ctx;
   \        0x2   0x6848             LDR      R0,[R1, #+4]
    667              return ecp->grp.pbits;
   \        0x4   0x6BC0             LDR      R0,[R0, #+60]
   \        0x6   0x4770             BX       LR
    668          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
    669          }
    670          
    671          #if defined(MBEDTLS_PK_CAN_ECDSA_VERIFY)
    672          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    673          /*
    674           * An ASN.1 encoded signature is a sequence of two ASN.1 integers. Parse one of
    675           * those integers and convert it to the fixed-length encoding expected by PSA.
    676           */

   \                                 In section .text, align 2, keep-with-next
    677          static int extract_ecdsa_sig_int(unsigned char **from, const unsigned char *end,
    678                                           unsigned char *to, size_t to_len)
    679          {
   \                     extract_ecdsa_sig_int: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
    680              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x086D      MVNS     R8,#+109
    681              size_t unpadded_len, padding_len;
    682          
    683              if ((ret = mbedtls_asn1_get_tag(from, end, &unpadded_len,
    684                                              MBEDTLS_ASN1_INTEGER)) != 0) {
   \       0x12   0x2302             MOVS     R3,#+2
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0x0038             MOVS     R0,R7
   \       0x1A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x1E   0x9003             STR      R0,[SP, #+12]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD001             BEQ.N    ??extract_ecdsa_sig_int_0
    685                  return ret;
   \       0x24   0x9803             LDR      R0,[SP, #+12]
   \       0x26   0xE034             B.N      ??extract_ecdsa_sig_int_1
    686              }
    687          
    688              while (unpadded_len > 0 && **from == 0x00) {
   \                     ??extract_ecdsa_sig_int_0: (+1)
   \       0x28   0x9800             LDR      R0,[SP, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD00A             BEQ.N    ??extract_ecdsa_sig_int_2
   \       0x2E   0x6838             LDR      R0,[R7, #+0]
   \       0x30   0x7800             LDRB     R0,[R0, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD106             BNE.N    ??extract_ecdsa_sig_int_2
    689                  (*from)++;
   \       0x36   0x6838             LDR      R0,[R7, #+0]
   \       0x38   0x1C40             ADDS     R0,R0,#+1
   \       0x3A   0x6038             STR      R0,[R7, #+0]
    690                  unpadded_len--;
   \       0x3C   0x9800             LDR      R0,[SP, #+0]
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \       0x40   0x9000             STR      R0,[SP, #+0]
   \       0x42   0xE7F1             B.N      ??extract_ecdsa_sig_int_0
    691              }
    692          
    693              if (unpadded_len > to_len || unpadded_len == 0) {
   \                     ??extract_ecdsa_sig_int_2: (+1)
   \       0x44   0x9800             LDR      R0,[SP, #+0]
   \       0x46   0x4286             CMP      R6,R0
   \       0x48   0xD302             BCC.N    ??extract_ecdsa_sig_int_3
   \       0x4A   0x9800             LDR      R0,[SP, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD102             BNE.N    ??extract_ecdsa_sig_int_4
    694                  return MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
   \                     ??extract_ecdsa_sig_int_3: (+1)
   \       0x50   0xF07F 0x0065      MVNS     R0,#+101
   \       0x54   0xE01D             B.N      ??extract_ecdsa_sig_int_1
    695              }
    696          
    697              padding_len = to_len - unpadded_len;
   \                     ??extract_ecdsa_sig_int_4: (+1)
   \       0x56   0xF8DD 0x8000      LDR      R8,[SP, #+0]
   \       0x5A   0xEBB6 0x0808      SUBS     R8,R6,R8
    698              memset(to, 0x00, padding_len);
   \       0x5E   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x62   0xF05F 0x0900      MOVS     R9,#+0
   \       0x66   0x46AA             MOV      R10,R5
   \       0x68   0x464A             MOV      R2,R9
   \       0x6A   0x9902             LDR      R1,[SP, #+8]
   \       0x6C   0x4650             MOV      R0,R10
   \       0x6E   0x.... 0x....      BL       __aeabi_memset
    699              memcpy(to + padding_len, *from, unpadded_len);
   \       0x72   0x9800             LDR      R0,[SP, #+0]
   \       0x74   0x9001             STR      R0,[SP, #+4]
   \       0x76   0xF8D7 0xB000      LDR      R11,[R7, #+0]
   \       0x7A   0xEB05 0x0A08      ADD      R10,R5,R8
   \       0x7E   0x9A01             LDR      R2,[SP, #+4]
   \       0x80   0x4659             MOV      R1,R11
   \       0x82   0x4650             MOV      R0,R10
   \       0x84   0x.... 0x....      BL       __aeabi_memcpy
    700              (*from) += unpadded_len;
   \       0x88   0x6839             LDR      R1,[R7, #+0]
   \       0x8A   0x9800             LDR      R0,[SP, #+0]
   \       0x8C   0x4408             ADD      R0,R1,R0
   \       0x8E   0x6038             STR      R0,[R7, #+0]
    701          
    702              return 0;
   \       0x90   0x2000             MOVS     R0,#+0
   \                     ??extract_ecdsa_sig_int_1: (+1)
   \       0x92   0xB005             ADD      SP,SP,#+20
   \       0x94   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    703          }
    704          
    705          /*
    706           * Convert a signature from an ASN.1 sequence of two integers
    707           * to a raw {r,s} buffer. Note: the provided sig buffer must be at least
    708           * twice as big as int_size.
    709           */

   \                                 In section .text, align 2, keep-with-next
    710          static int extract_ecdsa_sig(unsigned char **p, const unsigned char *end,
    711                                       unsigned char *sig, size_t int_size)
    712          {
   \                     extract_ecdsa_sig: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    713              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x086D      MVNS     R8,#+109
    714              size_t tmp_size;
    715          
    716              if ((ret = mbedtls_asn1_get_tag(p, end, &tmp_size,
    717                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0x10   0x2330             MOVS     R3,#+48
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x0029             MOVS     R1,R5
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x1C   0x4681             MOV      R9,R0
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??extract_ecdsa_sig_0
    718                  return ret;
   \       0x22   0x4648             MOV      R0,R9
   \       0x24   0xE017             B.N      ??extract_ecdsa_sig_1
    719              }
    720          
    721              /* Extract r */
    722              if ((ret = extract_ecdsa_sig_int(p, end, sig, int_size)) != 0) {
   \                     ??extract_ecdsa_sig_0: (+1)
   \       0x26   0x003B             MOVS     R3,R7
   \       0x28   0x0032             MOVS     R2,R6
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       extract_ecdsa_sig_int
   \       0x32   0x4680             MOV      R8,R0
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD001             BEQ.N    ??extract_ecdsa_sig_2
    723                  return ret;
   \       0x38   0x4640             MOV      R0,R8
   \       0x3A   0xE00C             B.N      ??extract_ecdsa_sig_1
    724              }
    725              /* Extract s */
    726              if ((ret = extract_ecdsa_sig_int(p, end, sig + int_size, int_size)) != 0) {
   \                     ??extract_ecdsa_sig_2: (+1)
   \       0x3C   0x003B             MOVS     R3,R7
   \       0x3E   0xEB06 0x0207      ADD      R2,R6,R7
   \       0x42   0x0029             MOVS     R1,R5
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       extract_ecdsa_sig_int
   \       0x4A   0x0001             MOVS     R1,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD001             BEQ.N    ??extract_ecdsa_sig_3
    727                  return ret;
   \       0x50   0x0008             MOVS     R0,R1
   \       0x52   0xE000             B.N      ??extract_ecdsa_sig_1
    728              }
    729          
    730              return 0;
   \                     ??extract_ecdsa_sig_3: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??extract_ecdsa_sig_1: (+1)
   \       0x56   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    731          }
    732          
    733          /* Common helper for ECDSA verify using PSA functions. */

   \                                 In section .text, align 2, keep-with-next
    734          static int ecdsa_verify_psa(unsigned char *key, size_t key_len,
    735                                      psa_ecc_family_t curve, size_t curve_bits,
    736                                      const unsigned char *hash, size_t hash_len,
    737                                      const unsigned char *sig, size_t sig_len)
    738          {
   \                     ecdsa_verify_psa: (+1)
   \        0x0   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \        0x4   0xB09E             SUB      SP,SP,#+120
   \        0x6   0x4691             MOV      R9,R2
   \        0x8   0x9D2B             LDR      R5,[SP, #+172]
   \        0xA   0x9E2C             LDR      R6,[SP, #+176]
   \        0xC   0x9F2D             LDR      R7,[SP, #+180]
    739              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x086D      MVNS     R8,#+109
    740              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \       0x12   0xA805             ADD      R0,SP,#+20
   \       0x14   0x2124             MOVS     R1,#+36
   \       0x16   0x.... 0x....      BL       __aeabi_memclr4
    741              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9002             STR      R0,[SP, #+8]
    742              psa_algorithm_t psa_sig_md = PSA_ALG_ECDSA_ANY;
   \       0x1E   0xF05F 0x2B06      MOVS     R11,#+100664832
    743              size_t signature_len = PSA_ECDSA_SIGNATURE_SIZE(curve_bits);
   \       0x22   0x9820             LDR      R0,[SP, #+128]
   \       0x24   0x1DC0             ADDS     R0,R0,#+7
   \       0x26   0x08C0             LSRS     R0,R0,#+3
   \       0x28   0x0040             LSLS     R0,R0,#+1
   \       0x2A   0x9003             STR      R0,[SP, #+12]
    744              unsigned char extracted_sig[PSA_VENDOR_ECDSA_SIGNATURE_MAX_SIZE];
    745              unsigned char *p;
    746              psa_status_t status;
    747          
    748              if (curve == 0) {
   \       0x2C   0x4648             MOV      R0,R9
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD102             BNE.N    ??ecdsa_verify_psa_0
    749                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \       0x38   0xE061             B.N      ??ecdsa_verify_psa_1
    750              }
    751          
    752              psa_set_key_type(&attributes, PSA_KEY_TYPE_ECC_PUBLIC_KEY(curve));
   \                     ??ecdsa_verify_psa_0: (+1)
   \       0x3A   0x4649             MOV      R1,R9
   \       0x3C   0xB2C9             UXTB     R1,R1
   \       0x3E   0xF451 0x4182      ORRS     R1,R1,#0x4100
   \       0x42   0xB289             UXTH     R1,R1
   \       0x44   0xA805             ADD      R0,SP,#+20
   \       0x46   0x.... 0x....      BL       psa_set_key_type
    753              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_VERIFY_HASH);
   \       0x4A   0xF44F 0x5100      MOV      R1,#+8192
   \       0x4E   0xA805             ADD      R0,SP,#+20
   \       0x50   0x.... 0x....      BL       psa_set_key_usage_flags
    754              psa_set_key_algorithm(&attributes, psa_sig_md);
   \       0x54   0x4659             MOV      R1,R11
   \       0x56   0xA805             ADD      R0,SP,#+20
   \       0x58   0x.... 0x....      BL       psa_set_key_algorithm
    755          
    756              status = psa_import_key(&attributes, key, key_len, &key_id);
   \       0x5C   0xAB02             ADD      R3,SP,#+8
   \       0x5E   0x9A1F             LDR      R2,[SP, #+124]
   \       0x60   0x991E             LDR      R1,[SP, #+120]
   \       0x62   0xA805             ADD      R0,SP,#+20
   \       0x64   0x.... 0x....      BL       psa_import_key
   \       0x68   0x0004             MOVS     R4,R0
    757              if (status != PSA_SUCCESS) {
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD004             BEQ.N    ??ecdsa_verify_psa_2
    758                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0x74   0x4682             MOV      R10,R0
    759                  goto cleanup;
   \       0x76   0xE033             B.N      ??ecdsa_verify_psa_3
    760              }
    761          
    762              if (signature_len > sizeof(extracted_sig)) {
   \                     ??ecdsa_verify_psa_2: (+1)
   \       0x78   0x9803             LDR      R0,[SP, #+12]
   \       0x7A   0x2841             CMP      R0,#+65
   \       0x7C   0xD302             BCC.N    ??ecdsa_verify_psa_4
    763                  ret = MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \       0x7E   0x.... 0x....      LDR.W    R10,??DataTable10_5
    764                  goto cleanup;
   \       0x82   0xE02D             B.N      ??ecdsa_verify_psa_3
    765              }
    766          
    767              p = (unsigned char *) sig;
   \                     ??ecdsa_verify_psa_4: (+1)
   \       0x84   0x9604             STR      R6,[SP, #+16]
    768              /* extract_ecdsa_sig's last parameter is the size
    769               * of each integer to be parsed, so it's actually half
    770               * the size of the signature. */
    771              if ((ret = extract_ecdsa_sig(&p, sig + sig_len, extracted_sig,
    772                                           signature_len/2)) != 0) {
   \       0x86   0x9B03             LDR      R3,[SP, #+12]
   \       0x88   0x085B             LSRS     R3,R3,#+1
   \       0x8A   0xAA0E             ADD      R2,SP,#+56
   \       0x8C   0xEB06 0x0107      ADD      R1,R6,R7
   \       0x90   0xA804             ADD      R0,SP,#+16
   \       0x92   0x.... 0x....      BL       extract_ecdsa_sig
   \       0x96   0x4682             MOV      R10,R0
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD121             BNE.N    ??ecdsa_verify_psa_3
    773                  goto cleanup;
    774              }
    775          
    776              status = psa_verify_hash(key_id, psa_sig_md, hash, hash_len,
    777                                       extracted_sig, signature_len);
   \                     ??ecdsa_verify_psa_5: (+1)
   \       0x9C   0x9803             LDR      R0,[SP, #+12]
   \       0x9E   0x9001             STR      R0,[SP, #+4]
   \       0xA0   0xA80E             ADD      R0,SP,#+56
   \       0xA2   0x9000             STR      R0,[SP, #+0]
   \       0xA4   0x002B             MOVS     R3,R5
   \       0xA6   0x9A2A             LDR      R2,[SP, #+168]
   \       0xA8   0x4659             MOV      R1,R11
   \       0xAA   0x9802             LDR      R0,[SP, #+8]
   \       0xAC   0x.... 0x....      BL       psa_verify_hash
   \       0xB0   0x0004             MOVS     R4,R0
    778              if (status != PSA_SUCCESS) {
   \       0xB2   0x2C00             CMP      R4,#+0
   \       0xB4   0xD009             BEQ.N    ??ecdsa_verify_psa_6
    779                  ret = PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
   \       0xB6   0x.... 0x....      LDR.W    R3,??DataTable10_12
   \       0xBA   0x2207             MOVS     R2,#+7
   \       0xBC   0x.... 0x....      LDR.W    R1,??DataTable10_13
   \       0xC0   0x0020             MOVS     R0,R4
   \       0xC2   0x.... 0x....      BL       psa_status_to_mbedtls
   \       0xC6   0x4682             MOV      R10,R0
    780                  goto cleanup;
   \       0xC8   0xE00A             B.N      ??ecdsa_verify_psa_3
    781              }
    782          
    783              if (p != sig + sig_len) {
   \                     ??ecdsa_verify_psa_6: (+1)
   \       0xCA   0x9904             LDR      R1,[SP, #+16]
   \       0xCC   0xEB06 0x0007      ADD      R0,R6,R7
   \       0xD0   0x4281             CMP      R1,R0
   \       0xD2   0xD003             BEQ.N    ??ecdsa_verify_psa_7
    784                  ret = MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
   \       0xD4   0x.... 0x....      LDR.W    R0,??DataTable10_14
   \       0xD8   0x4682             MOV      R10,R0
    785                  goto cleanup;
   \       0xDA   0xE001             B.N      ??ecdsa_verify_psa_3
    786              }
    787              ret = 0;
   \                     ??ecdsa_verify_psa_7: (+1)
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0x4682             MOV      R10,R0
    788          
    789          cleanup:
    790              status = psa_destroy_key(key_id);
   \                     ??ecdsa_verify_psa_3: (+1)
   \       0xE0   0x9802             LDR      R0,[SP, #+8]
   \       0xE2   0x.... 0x....      BL       psa_destroy_key
   \       0xE6   0x4680             MOV      R8,R0
    791              if (ret == 0 && status != PSA_SUCCESS) {
   \       0xE8   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xEC   0xD106             BNE.N    ??ecdsa_verify_psa_8
   \       0xEE   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xF2   0xD003             BEQ.N    ??ecdsa_verify_psa_8
    792                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0xF4   0x4640             MOV      R0,R8
   \       0xF6   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xFA   0x4682             MOV      R10,R0
    793              }
    794          
    795              return ret;
   \                     ??ecdsa_verify_psa_8: (+1)
   \       0xFC   0x4650             MOV      R0,R10
   \                     ??ecdsa_verify_psa_1: (+1)
   \       0xFE   0xB021             ADD      SP,SP,#+132
   \      0x100   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    796          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
    797          

   \                                 In section .text, align 2, keep-with-next
    798          static int ecdsa_opaque_verify_wrap(mbedtls_pk_context *pk,
    799                                              mbedtls_md_type_t md_alg,
    800                                              const unsigned char *hash, size_t hash_len,
    801                                              const unsigned char *sig, size_t sig_len)
    802          {
   \                     ecdsa_opaque_verify_wrap: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB09F             SUB      SP,SP,#+124
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
    803              (void) md_alg;
    804              unsigned char key[MBEDTLS_PK_MAX_EC_PUBKEY_RAW_LEN];
    805              size_t key_len;
    806              psa_key_attributes_t key_attr = PSA_KEY_ATTRIBUTES_INIT;
   \        0xE   0xA805             ADD      R0,SP,#+20
   \       0x10   0x2124             MOVS     R1,#+36
   \       0x12   0x.... 0x....      BL       __aeabi_memclr4
    807              psa_ecc_family_t curve;
    808              size_t curve_bits;
    809              psa_status_t status;
    810          
    811              status = psa_get_key_attributes(pk->priv_id, &key_attr);
   \       0x16   0xA905             ADD      R1,SP,#+20
   \       0x18   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x1C   0x.... 0x....      BL       psa_get_key_attributes
   \       0x20   0x0004             MOVS     R4,R0
    812              if (status != PSA_SUCCESS) {
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD008             BEQ.N    ??ecdsa_opaque_verify_wrap_0
    813                  return PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
   \       0x26   0x.... 0x....      LDR.W    R3,??DataTable10_12
   \       0x2A   0x2207             MOVS     R2,#+7
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable10_13
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       psa_status_to_mbedtls
   \       0x36   0xE037             B.N      ??ecdsa_opaque_verify_wrap_1
    814              }
    815              curve = PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(&key_attr));
   \                     ??ecdsa_opaque_verify_wrap_0: (+1)
   \       0x38   0xA805             ADD      R0,SP,#+20
   \       0x3A   0x.... 0x....      BL       psa_get_key_type
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable10_15
   \       0x42   0x4008             ANDS     R0,R1,R0
   \       0x44   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0x48   0xD104             BNE.N    ??ecdsa_opaque_verify_wrap_2
   \       0x4A   0xA805             ADD      R0,SP,#+20
   \       0x4C   0x.... 0x....      BL       psa_get_key_type
   \       0x50   0x4683             MOV      R11,R0
   \       0x52   0xE001             B.N      ??ecdsa_opaque_verify_wrap_3
   \                     ??ecdsa_opaque_verify_wrap_2: (+1)
   \       0x54   0xF05F 0x0B00      MOVS     R11,#+0
    816              curve_bits = psa_get_key_bits(&key_attr);
   \                     ??ecdsa_opaque_verify_wrap_3: (+1)
   \       0x58   0xA805             ADD      R0,SP,#+20
   \       0x5A   0x.... 0x....      BL       psa_get_key_bits
   \       0x5E   0x4682             MOV      R10,R0
    817              psa_reset_key_attributes(&key_attr);
   \       0x60   0xA805             ADD      R0,SP,#+20
   \       0x62   0x.... 0x....      BL       psa_reset_key_attributes
    818          
    819              status = psa_export_public_key(pk->priv_id, key, sizeof(key), &key_len);
   \       0x66   0xAB04             ADD      R3,SP,#+16
   \       0x68   0x2241             MOVS     R2,#+65
   \       0x6A   0xA90E             ADD      R1,SP,#+56
   \       0x6C   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x70   0x.... 0x....      BL       psa_export_public_key
   \       0x74   0x0005             MOVS     R5,R0
    820              if (status != PSA_SUCCESS) {
   \       0x76   0x2D00             CMP      R5,#+0
   \       0x78   0xD008             BEQ.N    ??ecdsa_opaque_verify_wrap_4
    821                  return PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
   \       0x7A   0x.... 0x....      LDR.W    R3,??DataTable10_12
   \       0x7E   0x2207             MOVS     R2,#+7
   \       0x80   0x.... 0x....      LDR.W    R1,??DataTable10_13
   \       0x84   0x0028             MOVS     R0,R5
   \       0x86   0x.... 0x....      BL       psa_status_to_mbedtls
   \       0x8A   0xE00D             B.N      ??ecdsa_opaque_verify_wrap_1
    822              }
    823          
    824              return ecdsa_verify_psa(key, key_len, curve, curve_bits,
    825                                      hash, hash_len, sig, sig_len);
   \                     ??ecdsa_opaque_verify_wrap_4: (+1)
   \       0x8C   0x9829             LDR      R0,[SP, #+164]
   \       0x8E   0x9003             STR      R0,[SP, #+12]
   \       0x90   0x9828             LDR      R0,[SP, #+160]
   \       0x92   0x9002             STR      R0,[SP, #+8]
   \       0x94   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x98   0x9700             STR      R7,[SP, #+0]
   \       0x9A   0x4653             MOV      R3,R10
   \       0x9C   0x465A             MOV      R2,R11
   \       0x9E   0xB2D2             UXTB     R2,R2
   \       0xA0   0x9904             LDR      R1,[SP, #+16]
   \       0xA2   0xA80E             ADD      R0,SP,#+56
   \       0xA4   0x.... 0x....      BL       ecdsa_verify_psa
   \                     ??ecdsa_opaque_verify_wrap_1: (+1)
   \       0xA8   0xB01F             ADD      SP,SP,#+124
   \       0xAA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    826          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
    827          
    828          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
    829          static int ecdsa_verify_wrap(mbedtls_pk_context *pk,
    830                                       mbedtls_md_type_t md_alg,
    831                                       const unsigned char *hash, size_t hash_len,
    832                                       const unsigned char *sig, size_t sig_len)
    833          {
    834              (void) md_alg;
    835              psa_ecc_family_t curve = pk->ec_family;
    836              size_t curve_bits = pk->ec_bits;
    837          
    838              return ecdsa_verify_psa(pk->pub_raw, pk->pub_raw_len, curve, curve_bits,
    839                                      hash, hash_len, sig, sig_len);
    840          }
    841          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */

   \                                 In section .text, align 2, keep-with-next
    842          static int ecdsa_verify_wrap(mbedtls_pk_context *pk,
    843                                       mbedtls_md_type_t md_alg,
    844                                       const unsigned char *hash, size_t hash_len,
    845                                       const unsigned char *sig, size_t sig_len)
    846          {
   \                     ecdsa_verify_wrap: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB097             SUB      SP,SP,#+92
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
    847              (void) md_alg;
    848              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x086D      MVNS     R8,#+109
    849              mbedtls_ecp_keypair *ctx = pk->pk_ctx;
   \       0x12   0xF8DB 0x9004      LDR      R9,[R11, #+4]
    850              unsigned char key[MBEDTLS_PSA_MAX_EC_PUBKEY_LENGTH];
    851              size_t key_len;
    852              size_t curve_bits;
    853              psa_ecc_family_t curve = mbedtls_ecc_group_to_psa(ctx->grp.id, &curve_bits);
   \       0x16   0xA904             ADD      R1,SP,#+16
   \       0x18   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x1C   0x.... 0x....      BL       mbedtls_ecc_group_to_psa
   \       0x20   0x4682             MOV      R10,R0
    854          
    855              ret = mbedtls_ecp_point_write_binary(&ctx->grp, &ctx->Q,
    856                                                   MBEDTLS_ECP_PF_UNCOMPRESSED,
    857                                                   &key_len, key, sizeof(key));
   \       0x22   0x2041             MOVS     R0,#+65
   \       0x24   0x9001             STR      R0,[SP, #+4]
   \       0x26   0xA806             ADD      R0,SP,#+24
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0xAB05             ADD      R3,SP,#+20
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0xF119 0x0168      ADDS     R1,R9,#+104
   \       0x32   0x4648             MOV      R0,R9
   \       0x34   0x.... 0x....      BL       mbedtls_ecp_point_write_binary
   \       0x38   0x0004             MOVS     R4,R0
    858              if (ret != 0) {
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD001             BEQ.N    ??ecdsa_verify_wrap_0
    859                  return ret;
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0xE00C             B.N      ??ecdsa_verify_wrap_1
    860              }
    861          
    862              return ecdsa_verify_psa(key, key_len, curve, curve_bits,
    863                                      hash, hash_len, sig, sig_len);
   \                     ??ecdsa_verify_wrap_0: (+1)
   \       0x42   0x9821             LDR      R0,[SP, #+132]
   \       0x44   0x9003             STR      R0,[SP, #+12]
   \       0x46   0x9820             LDR      R0,[SP, #+128]
   \       0x48   0x9002             STR      R0,[SP, #+8]
   \       0x4A   0x9701             STR      R7,[SP, #+4]
   \       0x4C   0x9600             STR      R6,[SP, #+0]
   \       0x4E   0x9B04             LDR      R3,[SP, #+16]
   \       0x50   0x4652             MOV      R2,R10
   \       0x52   0xB2D2             UXTB     R2,R2
   \       0x54   0x9905             LDR      R1,[SP, #+20]
   \       0x56   0xA806             ADD      R0,SP,#+24
   \       0x58   0x.... 0x....      BL       ecdsa_verify_psa
   \                     ??ecdsa_verify_wrap_1: (+1)
   \       0x5C   0xB017             ADD      SP,SP,#+92
   \       0x5E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    864          }
    865          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
    866          #else /* MBEDTLS_USE_PSA_CRYPTO */
    867          static int ecdsa_verify_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    868                                       const unsigned char *hash, size_t hash_len,
    869                                       const unsigned char *sig, size_t sig_len)
    870          {
    871              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    872              ((void) md_alg);
    873          
    874              ret = mbedtls_ecdsa_read_signature((mbedtls_ecdsa_context *) pk->pk_ctx,
    875                                                 hash, hash_len, sig, sig_len);
    876          
    877              if (ret == MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) {
    878                  return MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
    879              }
    880          
    881              return ret;
    882          }
    883          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    884          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
    885          
    886          #if defined(MBEDTLS_PK_CAN_ECDSA_SIGN)
    887          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    888          /*
    889           * Simultaneously convert and move raw MPI from the beginning of a buffer
    890           * to an ASN.1 MPI at the end of the buffer.
    891           * See also mbedtls_asn1_write_mpi().
    892           *
    893           * p: pointer to the end of the output buffer
    894           * start: start of the output buffer, and also of the mpi to write at the end
    895           * n_len: length of the mpi to read from start
    896           */

   \                                 In section .text, align 2, keep-with-next
    897          static int asn1_write_mpibuf(unsigned char **p, unsigned char *start,
    898                                       size_t n_len)
    899          {
   \                     asn1_write_mpibuf: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    900              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x096D      MVNS     R9,#+109
    901              size_t len = 0;
   \        0xE   0xF05F 0x0800      MOVS     R8,#+0
    902          
    903              if ((size_t) (*p - start) < n_len) {
   \       0x12   0x6838             LDR      R0,[R7, #+0]
   \       0x14   0x1B40             SUBS     R0,R0,R5
   \       0x16   0x42B0             CMP      R0,R6
   \       0x18   0xD202             BCS.N    ??asn1_write_mpibuf_0
    904                  return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
   \       0x1A   0xF07F 0x006B      MVNS     R0,#+107
   \       0x1E   0xE047             B.N      ??asn1_write_mpibuf_1
    905              }
    906          
    907              len = n_len;
   \                     ??asn1_write_mpibuf_0: (+1)
   \       0x20   0x0034             MOVS     R4,R6
    908              *p -= len;
   \       0x22   0x6839             LDR      R1,[R7, #+0]
   \       0x24   0x4260             RSBS     R0,R4,#+0
   \       0x26   0x4408             ADD      R0,R1,R0
   \       0x28   0x6038             STR      R0,[R7, #+0]
    909              memmove(*p, start, len);
   \       0x2A   0x9400             STR      R4,[SP, #+0]
   \       0x2C   0x46AB             MOV      R11,R5
   \       0x2E   0xF8D7 0xA000      LDR      R10,[R7, #+0]
   \       0x32   0x9A00             LDR      R2,[SP, #+0]
   \       0x34   0x4659             MOV      R1,R11
   \       0x36   0x4650             MOV      R0,R10
   \       0x38   0x.... 0x....      BL       __aeabi_memmove
    910          
    911              /* ASN.1 DER encoding requires minimal length, so skip leading 0s.
    912               * Neither r nor s should be 0, but as a failsafe measure, still detect
    913               * that rather than overflowing the buffer in case of a PSA error. */
    914              while (len > 0 && **p == 0x00) {
   \                     ??asn1_write_mpibuf_2: (+1)
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD008             BEQ.N    ??asn1_write_mpibuf_3
   \       0x40   0x6838             LDR      R0,[R7, #+0]
   \       0x42   0x7800             LDRB     R0,[R0, #+0]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD104             BNE.N    ??asn1_write_mpibuf_3
    915                  ++(*p);
   \       0x48   0x6838             LDR      R0,[R7, #+0]
   \       0x4A   0x1C40             ADDS     R0,R0,#+1
   \       0x4C   0x6038             STR      R0,[R7, #+0]
    916                  --len;
   \       0x4E   0x1E64             SUBS     R4,R4,#+1
   \       0x50   0xE7F4             B.N      ??asn1_write_mpibuf_2
    917              }
    918          
    919              /* this is only reached if the signature was invalid */
    920              if (len == 0) {
   \                     ??asn1_write_mpibuf_3: (+1)
   \       0x52   0x2C00             CMP      R4,#+0
   \       0x54   0xD102             BNE.N    ??asn1_write_mpibuf_4
    921                  return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0x56   0xF07F 0x006F      MVNS     R0,#+111
   \       0x5A   0xE029             B.N      ??asn1_write_mpibuf_1
    922              }
    923          
    924              /* if the msb is 1, ASN.1 requires that we prepend a 0.
    925               * Neither r nor s can be 0, so we can assume len > 0 at all times. */
    926              if (**p & 0x80) {
   \                     ??asn1_write_mpibuf_4: (+1)
   \       0x5C   0x6838             LDR      R0,[R7, #+0]
   \       0x5E   0x7800             LDRB     R0,[R0, #+0]
   \       0x60   0x0600             LSLS     R0,R0,#+24
   \       0x62   0xD50D             BPL.N    ??asn1_write_mpibuf_5
    927                  if (*p - start < 1) {
   \       0x64   0x6838             LDR      R0,[R7, #+0]
   \       0x66   0x1B40             SUBS     R0,R0,R5
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xDA02             BGE.N    ??asn1_write_mpibuf_6
    928                      return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
   \       0x6C   0xF07F 0x006B      MVNS     R0,#+107
   \       0x70   0xE01E             B.N      ??asn1_write_mpibuf_1
    929                  }
    930          
    931                  *--(*p) = 0x00;
   \                     ??asn1_write_mpibuf_6: (+1)
   \       0x72   0x6838             LDR      R0,[R7, #+0]
   \       0x74   0x1E40             SUBS     R0,R0,#+1
   \       0x76   0x6038             STR      R0,[R7, #+0]
   \       0x78   0x2100             MOVS     R1,#+0
   \       0x7A   0x6838             LDR      R0,[R7, #+0]
   \       0x7C   0x7001             STRB     R1,[R0, #+0]
    932                  len += 1;
   \       0x7E   0x1C64             ADDS     R4,R4,#+1
    933              }
    934          
    935              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(p, start, len));
   \                     ??asn1_write_mpibuf_5: (+1)
   \       0x80   0x0022             MOVS     R2,R4
   \       0x82   0x0029             MOVS     R1,R5
   \       0x84   0x0038             MOVS     R0,R7
   \       0x86   0x.... 0x....      BL       mbedtls_asn1_write_len
   \       0x8A   0x4680             MOV      R8,R0
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD501             BPL.N    ??asn1_write_mpibuf_7
   \       0x90   0x4640             MOV      R0,R8
   \       0x92   0xE00D             B.N      ??asn1_write_mpibuf_1
   \                     ??asn1_write_mpibuf_7: (+1)
   \       0x94   0xEB18 0x0404      ADDS     R4,R8,R4
    936              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(p, start,
    937                                                               MBEDTLS_ASN1_INTEGER));
   \       0x98   0x2202             MOVS     R2,#+2
   \       0x9A   0x0029             MOVS     R1,R5
   \       0x9C   0x0038             MOVS     R0,R7
   \       0x9E   0x.... 0x....      BL       mbedtls_asn1_write_tag
   \       0xA2   0x0001             MOVS     R1,R0
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD501             BPL.N    ??asn1_write_mpibuf_8
   \       0xA8   0x0008             MOVS     R0,R1
   \       0xAA   0xE001             B.N      ??asn1_write_mpibuf_1
   \                     ??asn1_write_mpibuf_8: (+1)
   \       0xAC   0x190C             ADDS     R4,R1,R4
    938          
    939              return (int) len;
   \       0xAE   0x0020             MOVS     R0,R4
   \                     ??asn1_write_mpibuf_1: (+1)
   \       0xB0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    940          }
    941          
    942          /* Transcode signature from PSA format to ASN.1 sequence.
    943           * See ecdsa_signature_to_asn1 in ecdsa.c, but with byte buffers instead of
    944           * MPIs, and in-place.
    945           *
    946           * [in/out] sig: the signature pre- and post-transcoding
    947           * [in/out] sig_len: signature length pre- and post-transcoding
    948           * [int] buf_len: the available size the in/out buffer
    949           */

   \                                 In section .text, align 2, keep-with-next
    950          static int pk_ecdsa_sig_asn1_from_psa(unsigned char *sig, size_t *sig_len,
    951                                                size_t buf_len)
    952          {
   \                     pk_ecdsa_sig_asn1_from_psa: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    953              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x096D      MVNS     R9,#+109
    954              size_t len = 0;
   \        0xE   0x2400             MOVS     R4,#+0
    955              const size_t rs_len = *sig_len / 2;
   \       0x10   0x682F             LDR      R7,[R5, #+0]
   \       0x12   0x087F             LSRS     R7,R7,#+1
    956              unsigned char *p = sig + buf_len;
   \       0x14   0xEB08 0x0006      ADD      R0,R8,R6
   \       0x18   0x9000             STR      R0,[SP, #+0]
    957          
    958              MBEDTLS_ASN1_CHK_ADD(len, asn1_write_mpibuf(&p, sig + rs_len, rs_len));
   \       0x1A   0x003A             MOVS     R2,R7
   \       0x1C   0xEB08 0x0107      ADD      R1,R8,R7
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x.... 0x....      BL       asn1_write_mpibuf
   \       0x26   0x4682             MOV      R10,R0
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD501             BPL.N    ??pk_ecdsa_sig_asn1_from_psa_0
   \       0x2C   0x4650             MOV      R0,R10
   \       0x2E   0xE030             B.N      ??pk_ecdsa_sig_asn1_from_psa_1
   \                     ??pk_ecdsa_sig_asn1_from_psa_0: (+1)
   \       0x30   0xEB1A 0x0404      ADDS     R4,R10,R4
    959              MBEDTLS_ASN1_CHK_ADD(len, asn1_write_mpibuf(&p, sig, rs_len));
   \       0x34   0x003A             MOVS     R2,R7
   \       0x36   0x4641             MOV      R1,R8
   \       0x38   0x4668             MOV      R0,SP
   \       0x3A   0x.... 0x....      BL       asn1_write_mpibuf
   \       0x3E   0x4681             MOV      R9,R0
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD501             BPL.N    ??pk_ecdsa_sig_asn1_from_psa_2
   \       0x44   0x4648             MOV      R0,R9
   \       0x46   0xE024             B.N      ??pk_ecdsa_sig_asn1_from_psa_1
   \                     ??pk_ecdsa_sig_asn1_from_psa_2: (+1)
   \       0x48   0xEB19 0x0404      ADDS     R4,R9,R4
    960          
    961              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(&p, sig, len));
   \       0x4C   0x0022             MOVS     R2,R4
   \       0x4E   0x4641             MOV      R1,R8
   \       0x50   0x4668             MOV      R0,SP
   \       0x52   0x.... 0x....      BL       mbedtls_asn1_write_len
   \       0x56   0x4682             MOV      R10,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD501             BPL.N    ??pk_ecdsa_sig_asn1_from_psa_3
   \       0x5C   0x4650             MOV      R0,R10
   \       0x5E   0xE018             B.N      ??pk_ecdsa_sig_asn1_from_psa_1
   \                     ??pk_ecdsa_sig_asn1_from_psa_3: (+1)
   \       0x60   0xEB1A 0x0404      ADDS     R4,R10,R4
    962              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(&p, sig,
    963                                                               MBEDTLS_ASN1_CONSTRUCTED |
    964                                                               MBEDTLS_ASN1_SEQUENCE));
   \       0x64   0x2230             MOVS     R2,#+48
   \       0x66   0x4641             MOV      R1,R8
   \       0x68   0x4668             MOV      R0,SP
   \       0x6A   0x.... 0x....      BL       mbedtls_asn1_write_tag
   \       0x6E   0x4681             MOV      R9,R0
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD501             BPL.N    ??pk_ecdsa_sig_asn1_from_psa_4
   \       0x74   0x4648             MOV      R0,R9
   \       0x76   0xE00C             B.N      ??pk_ecdsa_sig_asn1_from_psa_1
   \                     ??pk_ecdsa_sig_asn1_from_psa_4: (+1)
   \       0x78   0xEB19 0x0404      ADDS     R4,R9,R4
    965          
    966              memmove(sig, p, len);
   \       0x7C   0x46A2             MOV      R10,R4
   \       0x7E   0x9800             LDR      R0,[SP, #+0]
   \       0x80   0x9001             STR      R0,[SP, #+4]
   \       0x82   0x46C3             MOV      R11,R8
   \       0x84   0x4652             MOV      R2,R10
   \       0x86   0x9901             LDR      R1,[SP, #+4]
   \       0x88   0x4658             MOV      R0,R11
   \       0x8A   0x.... 0x....      BL       __aeabi_memmove
    967              *sig_len = len;
   \       0x8E   0x602C             STR      R4,[R5, #+0]
    968          
    969              return 0;
   \       0x90   0x2000             MOVS     R0,#+0
   \                     ??pk_ecdsa_sig_asn1_from_psa_1: (+1)
   \       0x92   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    970          }
    971          
    972          /* Common helper for ECDSA sign using PSA functions. */

   \                                 In section .text, align 2, keep-with-next
    973          static int ecdsa_sign_psa(mbedtls_svc_key_id_t key_id, mbedtls_md_type_t md_alg,
    974                                    const unsigned char *hash, size_t hash_len,
    975                                    unsigned char *sig, size_t sig_size, size_t *sig_len)
    976          {
   \                     ecdsa_sign_psa: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB08E             SUB      SP,SP,#+56
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x9D1A             LDR      R5,[SP, #+104]
   \        0xC   0x9E1B             LDR      R6,[SP, #+108]
   \        0xE   0x9F1C             LDR      R7,[SP, #+112]
    977              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x10   0xF07F 0x006D      MVNS     R0,#+109
   \       0x14   0x9004             STR      R0,[SP, #+16]
    978              psa_status_t status;
    979              psa_algorithm_t psa_sig_md;
    980              psa_key_attributes_t key_attr = PSA_KEY_ATTRIBUTES_INIT;
   \       0x16   0xA805             ADD      R0,SP,#+20
   \       0x18   0x2124             MOVS     R1,#+36
   \       0x1A   0x.... 0x....      BL       __aeabi_memclr4
    981              psa_algorithm_t alg;
    982          
    983              status = psa_get_key_attributes(key_id, &key_attr);
   \       0x1E   0xA905             ADD      R1,SP,#+20
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0x.... 0x....      BL       psa_get_key_attributes
   \       0x26   0x4683             MOV      R11,R0
    984              if (status != PSA_SUCCESS) {
   \       0x28   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x2C   0xD008             BEQ.N    ??ecdsa_sign_psa_0
    985                  return PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
   \       0x2E   0x.... 0x....      LDR.W    R3,??DataTable10_12
   \       0x32   0x2207             MOVS     R2,#+7
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable10_13
   \       0x38   0x4658             MOV      R0,R11
   \       0x3A   0x.... 0x....      BL       psa_status_to_mbedtls
   \       0x3E   0xE03A             B.N      ??ecdsa_sign_psa_1
    986              }
    987              alg = psa_get_key_algorithm(&key_attr);
   \                     ??ecdsa_sign_psa_0: (+1)
   \       0x40   0xA805             ADD      R0,SP,#+20
   \       0x42   0x.... 0x....      BL       psa_get_key_algorithm
   \       0x46   0x9003             STR      R0,[SP, #+12]
    988              psa_reset_key_attributes(&key_attr);
   \       0x48   0xA805             ADD      R0,SP,#+20
   \       0x4A   0x.... 0x....      BL       psa_reset_key_attributes
    989          
    990              if (PSA_ALG_IS_DETERMINISTIC_ECDSA(alg)) {
   \       0x4E   0x.... 0x....      LDR.W    R10,??DataTable10_16
   \       0x52   0x9803             LDR      R0,[SP, #+12]
   \       0x54   0x0A00             LSRS     R0,R0,#+8
   \       0x56   0x0200             LSLS     R0,R0,#+8
   \       0x58   0x4550             CMP      R0,R10
   \       0x5A   0xD108             BNE.N    ??ecdsa_sign_psa_2
    991                  psa_sig_md = PSA_ALG_DETERMINISTIC_ECDSA(mbedtls_md_psa_alg_from_type(md_alg));
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0xB2C0             UXTB     R0,R0
   \       0x60   0x.... 0x....      BL       mbedtls_md_psa_alg_from_type
   \       0x64   0xF000 0x00FF      AND      R0,R0,#0xFF
   \       0x68   0xEA5A 0x0A00      ORRS     R10,R10,R0
   \       0x6C   0xE008             B.N      ??ecdsa_sign_psa_3
    992              } else {
    993                  psa_sig_md = PSA_ALG_ECDSA(mbedtls_md_psa_alg_from_type(md_alg));
   \                     ??ecdsa_sign_psa_2: (+1)
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0xB2C0             UXTB     R0,R0
   \       0x72   0x.... 0x....      BL       mbedtls_md_psa_alg_from_type
   \       0x76   0x4682             MOV      R10,R0
   \       0x78   0xF00A 0x0AFF      AND      R10,R10,#0xFF
   \       0x7C   0xF05A 0x2A06      ORRS     R10,R10,#0x6000600
    994              }
    995          
    996              status = psa_sign_hash(key_id, psa_sig_md, hash, hash_len,
    997                                     sig, sig_size, sig_len);
   \                     ??ecdsa_sign_psa_3: (+1)
   \       0x80   0x9702             STR      R7,[SP, #+8]
   \       0x82   0x9601             STR      R6,[SP, #+4]
   \       0x84   0x9500             STR      R5,[SP, #+0]
   \       0x86   0x9B10             LDR      R3,[SP, #+64]
   \       0x88   0x9A0F             LDR      R2,[SP, #+60]
   \       0x8A   0x4651             MOV      R1,R10
   \       0x8C   0x4640             MOV      R0,R8
   \       0x8E   0x.... 0x....      BL       psa_sign_hash
   \       0x92   0x4681             MOV      R9,R0
    998              if (status != PSA_SUCCESS) {
   \       0x94   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x98   0xD008             BEQ.N    ??ecdsa_sign_psa_4
    999                  return PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
   \       0x9A   0x.... 0x....      LDR.W    R3,??DataTable10_12
   \       0x9E   0x2207             MOVS     R2,#+7
   \       0xA0   0x.... 0x....      LDR.W    R1,??DataTable10_13
   \       0xA4   0x4648             MOV      R0,R9
   \       0xA6   0x.... 0x....      BL       psa_status_to_mbedtls
   \       0xAA   0xE004             B.N      ??ecdsa_sign_psa_1
   1000              }
   1001          
   1002              ret = pk_ecdsa_sig_asn1_from_psa(sig, sig_len, sig_size);
   \                     ??ecdsa_sign_psa_4: (+1)
   \       0xAC   0x0032             MOVS     R2,R6
   \       0xAE   0x0039             MOVS     R1,R7
   \       0xB0   0x0028             MOVS     R0,R5
   \       0xB2   0x.... 0x....      BL       pk_ecdsa_sig_asn1_from_psa
   1003          
   1004              return ret;
   \                     ??ecdsa_sign_psa_1: (+1)
   \       0xB6   0xB011             ADD      SP,SP,#+68
   \       0xB8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1005          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   1006          

   \                                 In section .text, align 2, keep-with-next
   1007          static int ecdsa_opaque_sign_wrap(mbedtls_pk_context *pk,
   1008                                            mbedtls_md_type_t md_alg,
   1009                                            const unsigned char *hash, size_t hash_len,
   1010                                            unsigned char *sig, size_t sig_size,
   1011                                            size_t *sig_len,
   1012                                            int (*f_rng)(void *, unsigned char *, size_t),
   1013                                            void *p_rng)
   1014          {
   \                     ecdsa_opaque_sign_wrap: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   1015              ((void) f_rng);
   1016              ((void) p_rng);
   1017          
   1018              return ecdsa_sign_psa(pk->priv_id, md_alg, hash, hash_len, sig, sig_size,
   1019                                    sig_len);
   \        0xA   0x980A             LDR      R0,[SP, #+40]
   \        0xC   0x9002             STR      R0,[SP, #+8]
   \        0xE   0x9809             LDR      R0,[SP, #+36]
   \       0x10   0x9001             STR      R0,[SP, #+4]
   \       0x12   0x9808             LDR      R0,[SP, #+32]
   \       0x14   0x9000             STR      R0,[SP, #+0]
   \       0x16   0x003B             MOVS     R3,R7
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0xB2C9             UXTB     R1,R1
   \       0x1E   0x68A0             LDR      R0,[R4, #+8]
   \       0x20   0x.... 0x....      BL       ecdsa_sign_psa
   \       0x24   0xBDFE             POP      {R1-R7,PC}
   1020          }
   1021          
   1022          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1023          /* When PK_USE_PSA_EC_DATA is defined opaque and non-opaque keys end up
   1024           * using the same function. */
   1025          #define ecdsa_sign_wrap     ecdsa_opaque_sign_wrap
   1026          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */

   \                                 In section .text, align 2, keep-with-next
   1027          static int ecdsa_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1028                                     const unsigned char *hash, size_t hash_len,
   1029                                     unsigned char *sig, size_t sig_size, size_t *sig_len,
   1030                                     int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1031          {
   \                     ecdsa_sign_wrap: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB098             SUB      SP,SP,#+96
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1032              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
   \       0x10   0x46B8             MOV      R8,R7
   1033              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9003             STR      R0,[SP, #+12]
   1034              psa_status_t status;
   1035              mbedtls_ecp_keypair *ctx = pk->pk_ctx;
   \       0x16   0x9818             LDR      R0,[SP, #+96]
   \       0x18   0x6840             LDR      R0,[R0, #+4]
   \       0x1A   0x9005             STR      R0,[SP, #+20]
   1036              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \       0x1C   0xA807             ADD      R0,SP,#+28
   \       0x1E   0x2124             MOVS     R1,#+36
   \       0x20   0x.... 0x....      BL       __aeabi_memclr4
   1037              unsigned char buf[MBEDTLS_PSA_MAX_EC_KEY_PAIR_LENGTH];
   1038              size_t curve_bits;
   1039              psa_ecc_family_t curve =
   1040                  mbedtls_ecc_group_to_psa(ctx->grp.id, &curve_bits);
   \       0x24   0xA906             ADD      R1,SP,#+24
   \       0x26   0x9805             LDR      R0,[SP, #+20]
   \       0x28   0x7800             LDRB     R0,[R0, #+0]
   \       0x2A   0x.... 0x....      BL       mbedtls_ecc_group_to_psa
   \       0x2E   0x4683             MOV      R11,R0
   1041              size_t key_len = PSA_BITS_TO_BYTES(curve_bits);
   \       0x30   0xF8DD 0x9018      LDR      R9,[SP, #+24]
   \       0x34   0xF119 0x0907      ADDS     R9,R9,#+7
   \       0x38   0xEA5F 0x09D9      LSRS     R9,R9,#+3
   1042          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
   1043              psa_algorithm_t psa_sig_md =
   1044                  PSA_ALG_DETERMINISTIC_ECDSA(mbedtls_md_psa_alg_from_type(md_alg));
   1045          #else
   1046              psa_algorithm_t psa_sig_md =
   1047                  PSA_ALG_ECDSA(mbedtls_md_psa_alg_from_type(md_alg));
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0xB2C0             UXTB     R0,R0
   \       0x40   0x.... 0x....      BL       mbedtls_md_psa_alg_from_type
   \       0x44   0x4682             MOV      R10,R0
   \       0x46   0xF00A 0x0AFF      AND      R10,R10,#0xFF
   \       0x4A   0xF05A 0x2A06      ORRS     R10,R10,#0x6000600
   1048          #endif
   1049              ((void) f_rng);
   1050              ((void) p_rng);
   1051          
   1052              if (curve == 0) {
   \       0x4E   0x4658             MOV      R0,R11
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD102             BNE.N    ??ecdsa_sign_wrap_0
   1053                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \       0x5A   0xE04D             B.N      ??ecdsa_sign_wrap_1
   1054              }
   1055          
   1056              if (key_len > sizeof(buf)) {
   \                     ??ecdsa_sign_wrap_0: (+1)
   \       0x5C   0xF1B9 0x0F21      CMP      R9,#+33
   \       0x60   0xD301             BCC.N    ??ecdsa_sign_wrap_2
   1057                  return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x62   0x0038             MOVS     R0,R7
   \       0x64   0xE048             B.N      ??ecdsa_sign_wrap_1
   1058              }
   1059              ret = mbedtls_mpi_write_binary(&ctx->d, buf, key_len);
   \                     ??ecdsa_sign_wrap_2: (+1)
   \       0x66   0x464A             MOV      R2,R9
   \       0x68   0xA910             ADD      R1,SP,#+64
   \       0x6A   0x9805             LDR      R0,[SP, #+20]
   \       0x6C   0x3060             ADDS     R0,R0,#+96
   \       0x6E   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x72   0x0007             MOVS     R7,R0
   1060              if (ret != 0) {
   \       0x74   0x2F00             CMP      R7,#+0
   \       0x76   0xD12D             BNE.N    ??ecdsa_sign_wrap_3
   1061                  goto cleanup;
   1062              }
   1063          
   1064              psa_set_key_type(&attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(curve));
   \                     ??ecdsa_sign_wrap_4: (+1)
   \       0x78   0x4659             MOV      R1,R11
   \       0x7A   0xB2C9             UXTB     R1,R1
   \       0x7C   0xF451 0x41E2      ORRS     R1,R1,#0x7100
   \       0x80   0xB289             UXTH     R1,R1
   \       0x82   0xA807             ADD      R0,SP,#+28
   \       0x84   0x.... 0x....      BL       psa_set_key_type
   1065              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_HASH);
   \       0x88   0xF44F 0x5180      MOV      R1,#+4096
   \       0x8C   0xA807             ADD      R0,SP,#+28
   \       0x8E   0x.... 0x....      BL       psa_set_key_usage_flags
   1066              psa_set_key_algorithm(&attributes, psa_sig_md);
   \       0x92   0x4651             MOV      R1,R10
   \       0x94   0xA807             ADD      R0,SP,#+28
   \       0x96   0x.... 0x....      BL       psa_set_key_algorithm
   1067          
   1068              status = psa_import_key(&attributes, buf, key_len, &key_id);
   \       0x9A   0xAB03             ADD      R3,SP,#+12
   \       0x9C   0x464A             MOV      R2,R9
   \       0x9E   0xA910             ADD      R1,SP,#+64
   \       0xA0   0xA807             ADD      R0,SP,#+28
   \       0xA2   0x.... 0x....      BL       psa_import_key
   \       0xA6   0x9004             STR      R0,[SP, #+16]
   1069              if (status != PSA_SUCCESS) {
   \       0xA8   0x9804             LDR      R0,[SP, #+16]
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD004             BEQ.N    ??ecdsa_sign_wrap_5
   1070                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0xAE   0x9804             LDR      R0,[SP, #+16]
   \       0xB0   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xB4   0x0007             MOVS     R7,R0
   1071                  goto cleanup;
   \       0xB6   0xE00D             B.N      ??ecdsa_sign_wrap_3
   1072              }
   1073          
   1074              ret = ecdsa_sign_psa(key_id, md_alg, hash, hash_len, sig, sig_size, sig_len);
   \                     ??ecdsa_sign_wrap_5: (+1)
   \       0xB8   0x9824             LDR      R0,[SP, #+144]
   \       0xBA   0x9002             STR      R0,[SP, #+8]
   \       0xBC   0x9823             LDR      R0,[SP, #+140]
   \       0xBE   0x9001             STR      R0,[SP, #+4]
   \       0xC0   0x9822             LDR      R0,[SP, #+136]
   \       0xC2   0x9000             STR      R0,[SP, #+0]
   \       0xC4   0x0033             MOVS     R3,R6
   \       0xC6   0x002A             MOVS     R2,R5
   \       0xC8   0x0021             MOVS     R1,R4
   \       0xCA   0xB2C9             UXTB     R1,R1
   \       0xCC   0x9803             LDR      R0,[SP, #+12]
   \       0xCE   0x.... 0x....      BL       ecdsa_sign_psa
   \       0xD2   0x0007             MOVS     R7,R0
   1075          
   1076          cleanup:
   1077              mbedtls_platform_zeroize(buf, sizeof(buf));
   \                     ??ecdsa_sign_wrap_3: (+1)
   \       0xD4   0x2120             MOVS     R1,#+32
   \       0xD6   0xA810             ADD      R0,SP,#+64
   \       0xD8   0x.... 0x....      BL       mbedtls_platform_zeroize
   1078              status = psa_destroy_key(key_id);
   \       0xDC   0x9803             LDR      R0,[SP, #+12]
   \       0xDE   0x.... 0x....      BL       psa_destroy_key
   \       0xE2   0x4680             MOV      R8,R0
   1079              if (ret == 0 && status != PSA_SUCCESS) {
   \       0xE4   0x2F00             CMP      R7,#+0
   \       0xE6   0xD106             BNE.N    ??ecdsa_sign_wrap_6
   \       0xE8   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xEC   0xD003             BEQ.N    ??ecdsa_sign_wrap_6
   1080                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0xEE   0x4640             MOV      R0,R8
   \       0xF0   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xF4   0x0007             MOVS     R7,R0
   1081              }
   1082          
   1083              return ret;
   \                     ??ecdsa_sign_wrap_6: (+1)
   \       0xF6   0x0038             MOVS     R0,R7
   \                     ??ecdsa_sign_wrap_1: (+1)
   \       0xF8   0xB019             ADD      SP,SP,#+100
   \       0xFA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1084          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   1085          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1086          #else /* MBEDTLS_USE_PSA_CRYPTO */
   1087          static int ecdsa_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1088                                     const unsigned char *hash, size_t hash_len,
   1089                                     unsigned char *sig, size_t sig_size, size_t *sig_len,
   1090                                     int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1091          {
   1092              return mbedtls_ecdsa_write_signature((mbedtls_ecdsa_context *) pk->pk_ctx,
   1093                                                   md_alg, hash, hash_len,
   1094                                                   sig, sig_size, sig_len,
   1095                                                   f_rng, p_rng);
   1096          }
   1097          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1098          #endif /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1099          
   1100          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1101          /* Forward declarations */
   1102          static int ecdsa_verify_rs_wrap(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
   1103                                          const unsigned char *hash, size_t hash_len,
   1104                                          const unsigned char *sig, size_t sig_len,
   1105                                          void *rs_ctx);
   1106          
   1107          static int ecdsa_sign_rs_wrap(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
   1108                                        const unsigned char *hash, size_t hash_len,
   1109                                        unsigned char *sig, size_t sig_size, size_t *sig_len,
   1110                                        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   1111                                        void *rs_ctx);
   1112          
   1113          /*
   1114           * Restart context for ECDSA operations with ECKEY context
   1115           *
   1116           * We need to store an actual ECDSA context, as we need to pass the same to
   1117           * the underlying ecdsa function, so we can't create it on the fly every time.
   1118           */
   1119          typedef struct {
   1120              mbedtls_ecdsa_restart_ctx ecdsa_rs;
   1121              mbedtls_ecdsa_context ecdsa_ctx;
   1122          } eckey_restart_ctx;
   1123          
   1124          static void *eckey_rs_alloc(void)
   1125          {
   1126              eckey_restart_ctx *rs_ctx;
   1127          
   1128              void *ctx = mbedtls_calloc(1, sizeof(eckey_restart_ctx));
   1129          
   1130              if (ctx != NULL) {
   1131                  rs_ctx = ctx;
   1132                  mbedtls_ecdsa_restart_init(&rs_ctx->ecdsa_rs);
   1133                  mbedtls_ecdsa_init(&rs_ctx->ecdsa_ctx);
   1134              }
   1135          
   1136              return ctx;
   1137          }
   1138          
   1139          static void eckey_rs_free(void *ctx)
   1140          {
   1141              eckey_restart_ctx *rs_ctx;
   1142          
   1143              if (ctx == NULL) {
   1144                  return;
   1145              }
   1146          
   1147              rs_ctx = ctx;
   1148              mbedtls_ecdsa_restart_free(&rs_ctx->ecdsa_rs);
   1149              mbedtls_ecdsa_free(&rs_ctx->ecdsa_ctx);
   1150          
   1151              mbedtls_free(ctx);
   1152          }
   1153          
   1154          static int eckey_verify_rs_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1155                                          const unsigned char *hash, size_t hash_len,
   1156                                          const unsigned char *sig, size_t sig_len,
   1157                                          void *rs_ctx)
   1158          {
   1159              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1160              eckey_restart_ctx *rs = rs_ctx;
   1161          
   1162              /* Should never happen */
   1163              if (rs == NULL) {
   1164                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1165              }
   1166          
   1167              /* set up our own sub-context if needed (that is, on first run) */
   1168              if (rs->ecdsa_ctx.grp.pbits == 0) {
   1169                  MBEDTLS_MPI_CHK(mbedtls_ecdsa_from_keypair(&rs->ecdsa_ctx, pk->pk_ctx));
   1170              }
   1171          
   1172              MBEDTLS_MPI_CHK(ecdsa_verify_rs_wrap(pk,
   1173                                                   md_alg, hash, hash_len,
   1174                                                   sig, sig_len, &rs->ecdsa_rs));
   1175          
   1176          cleanup:
   1177              return ret;
   1178          }
   1179          
   1180          static int eckey_sign_rs_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1181                                        const unsigned char *hash, size_t hash_len,
   1182                                        unsigned char *sig, size_t sig_size, size_t *sig_len,
   1183                                        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   1184                                        void *rs_ctx)
   1185          {
   1186              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1187              eckey_restart_ctx *rs = rs_ctx;
   1188          
   1189              /* Should never happen */
   1190              if (rs == NULL) {
   1191                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1192              }
   1193          
   1194              /* set up our own sub-context if needed (that is, on first run) */
   1195              if (rs->ecdsa_ctx.grp.pbits == 0) {
   1196                  MBEDTLS_MPI_CHK(mbedtls_ecdsa_from_keypair(&rs->ecdsa_ctx, pk->pk_ctx));
   1197              }
   1198          
   1199              MBEDTLS_MPI_CHK(ecdsa_sign_rs_wrap(pk, md_alg,
   1200                                                 hash, hash_len, sig, sig_size, sig_len,
   1201                                                 f_rng, p_rng, &rs->ecdsa_rs));
   1202          
   1203          cleanup:
   1204              return ret;
   1205          }
   1206          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1207          
   1208          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1209          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1210          static int eckey_check_pair_psa(mbedtls_pk_context *pub, mbedtls_pk_context *prv)
   1211          {
   1212              psa_status_t status;
   1213              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1214              uint8_t prv_key_buf[MBEDTLS_PSA_MAX_EC_PUBKEY_LENGTH];
   1215              size_t prv_key_len;
   1216              mbedtls_svc_key_id_t key_id = prv->priv_id;
   1217          
   1218              status = psa_export_public_key(key_id, prv_key_buf, sizeof(prv_key_buf),
   1219                                             &prv_key_len);
   1220              ret = PSA_PK_TO_MBEDTLS_ERR(status);
   1221              if (ret != 0) {
   1222                  return ret;
   1223              }
   1224          
   1225              if (memcmp(prv_key_buf, pub->pub_raw, pub->pub_raw_len) != 0) {
   1226                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1227              }
   1228          
   1229              return 0;
   1230          }
   1231          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */

   \                                 In section .text, align 2, keep-with-next
   1232          static int eckey_check_pair_psa(mbedtls_pk_context *pub, mbedtls_pk_context *prv)
   1233          {
   \                     eckey_check_pair_psa: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB0D4             SUB      SP,SP,#+336
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x4689             MOV      R9,R1
   1234              psa_status_t status;
   1235              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x046D      MVNS     R4,#+109
   1236              uint8_t prv_key_buf[MBEDTLS_PSA_MAX_EC_PUBKEY_LENGTH];
   1237              size_t prv_key_len;
   1238              psa_status_t destruction_status;
   1239              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9024             STR      R0,[SP, #+144]
   1240              psa_key_attributes_t key_attr = PSA_KEY_ATTRIBUTES_INIT;
   \       0x12   0xA829             ADD      R0,SP,#+164
   \       0x14   0x2124             MOVS     R1,#+36
   \       0x16   0x.... 0x....      BL       __aeabi_memclr4
   1241              uint8_t pub_key_buf[MBEDTLS_PSA_MAX_EC_PUBKEY_LENGTH];
   1242              size_t pub_key_len;
   1243              size_t curve_bits;
   1244              const psa_ecc_family_t curve =
   1245                  mbedtls_ecc_group_to_psa(mbedtls_pk_ec_ro(*prv)->grp.id, &curve_bits);
   \       0x1A   0x4649             MOV      R1,R9
   \       0x1C   0xB084             SUB      SP,SP,#+16
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x22A0             MOVS     R2,#+160
   \       0x22   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x26   0xBC0F             POP      {R0-R3}
   \       0x28   0x.... 0x....      BL       mbedtls_pk_ec_ro
   \       0x2C   0xA925             ADD      R1,SP,#+148
   \       0x2E   0x7800             LDRB     R0,[R0, #+0]
   \       0x30   0x.... 0x....      BL       mbedtls_ecc_group_to_psa
   \       0x34   0x0007             MOVS     R7,R0
   1246              const size_t curve_bytes = PSA_BITS_TO_BYTES(curve_bits);
   \       0x36   0x9D25             LDR      R5,[SP, #+148]
   \       0x38   0x1DED             ADDS     R5,R5,#+7
   \       0x3A   0x08ED             LSRS     R5,R5,#+3
   1247          
   1248              if (curve == 0) {
   \       0x3C   0x0038             MOVS     R0,R7
   \       0x3E   0xB2C0             UXTB     R0,R0
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD101             BNE.N    ??eckey_check_pair_psa_0
   1249                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \       0x44   0x....             LDR.N    R0,??DataTable10_5
   \       0x46   0xE07C             B.N      ??eckey_check_pair_psa_1
   1250              }
   1251          
   1252              psa_set_key_type(&key_attr, PSA_KEY_TYPE_ECC_KEY_PAIR(curve));
   \                     ??eckey_check_pair_psa_0: (+1)
   \       0x48   0x0039             MOVS     R1,R7
   \       0x4A   0xB2C9             UXTB     R1,R1
   \       0x4C   0xF451 0x41E2      ORRS     R1,R1,#0x7100
   \       0x50   0xB289             UXTH     R1,R1
   \       0x52   0xA829             ADD      R0,SP,#+164
   \       0x54   0x.... 0x....      BL       psa_set_key_type
   1253              psa_set_key_usage_flags(&key_attr, PSA_KEY_USAGE_EXPORT);
   \       0x58   0x2101             MOVS     R1,#+1
   \       0x5A   0xA829             ADD      R0,SP,#+164
   \       0x5C   0x.... 0x....      BL       psa_set_key_usage_flags
   1254          
   1255              ret = mbedtls_mpi_write_binary(&mbedtls_pk_ec_ro(*prv)->d,
   1256                                             prv_key_buf, curve_bytes);
   \       0x60   0x4649             MOV      R1,R9
   \       0x62   0xB084             SUB      SP,SP,#+16
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x22A0             MOVS     R2,#+160
   \       0x68   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x6C   0xBC0F             POP      {R0-R3}
   \       0x6E   0x.... 0x....      BL       mbedtls_pk_ec_ro
   \       0x72   0x002A             MOVS     R2,R5
   \       0x74   0xA943             ADD      R1,SP,#+268
   \       0x76   0x3060             ADDS     R0,R0,#+96
   \       0x78   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x7C   0x4680             MOV      R8,R0
   1257              if (ret != 0) {
   \       0x7E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x82   0xD005             BEQ.N    ??eckey_check_pair_psa_2
   1258                  mbedtls_platform_zeroize(prv_key_buf, sizeof(prv_key_buf));
   \       0x84   0x2141             MOVS     R1,#+65
   \       0x86   0xA843             ADD      R0,SP,#+268
   \       0x88   0x.... 0x....      BL       mbedtls_platform_zeroize
   1259                  return ret;
   \       0x8C   0x4640             MOV      R0,R8
   \       0x8E   0xE058             B.N      ??eckey_check_pair_psa_1
   1260              }
   1261          
   1262              status = psa_import_key(&key_attr, prv_key_buf, curve_bytes, &key_id);
   \                     ??eckey_check_pair_psa_2: (+1)
   \       0x90   0xAB24             ADD      R3,SP,#+144
   \       0x92   0x002A             MOVS     R2,R5
   \       0x94   0xA943             ADD      R1,SP,#+268
   \       0x96   0xA829             ADD      R0,SP,#+164
   \       0x98   0x.... 0x....      BL       psa_import_key
   \       0x9C   0x4683             MOV      R11,R0
   1263              mbedtls_platform_zeroize(prv_key_buf, sizeof(prv_key_buf));
   \       0x9E   0x2141             MOVS     R1,#+65
   \       0xA0   0xA843             ADD      R0,SP,#+268
   \       0xA2   0x.... 0x....      BL       mbedtls_platform_zeroize
   1264              ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0xA6   0x4658             MOV      R0,R11
   \       0xA8   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xAC   0x0006             MOVS     R6,R0
   1265              if (ret != 0) {
   \       0xAE   0x2E00             CMP      R6,#+0
   \       0xB0   0xD001             BEQ.N    ??eckey_check_pair_psa_3
   1266                  return ret;
   \       0xB2   0x0030             MOVS     R0,R6
   \       0xB4   0xE045             B.N      ??eckey_check_pair_psa_1
   1267              }
   1268          
   1269              // From now on prv_key_buf is used to store the public key of prv.
   1270              status = psa_export_public_key(key_id, prv_key_buf, sizeof(prv_key_buf),
   1271                                             &prv_key_len);
   \                     ??eckey_check_pair_psa_3: (+1)
   \       0xB6   0xAB27             ADD      R3,SP,#+156
   \       0xB8   0x2241             MOVS     R2,#+65
   \       0xBA   0xA943             ADD      R1,SP,#+268
   \       0xBC   0x9824             LDR      R0,[SP, #+144]
   \       0xBE   0x.... 0x....      BL       psa_export_public_key
   \       0xC2   0x9028             STR      R0,[SP, #+160]
   1272              ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0xC4   0x9828             LDR      R0,[SP, #+160]
   \       0xC6   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xCA   0x0004             MOVS     R4,R0
   1273              destruction_status = psa_destroy_key(key_id);
   \       0xCC   0x9824             LDR      R0,[SP, #+144]
   \       0xCE   0x.... 0x....      BL       psa_destroy_key
   \       0xD2   0x4680             MOV      R8,R0
   1274              if (ret != 0) {
   \       0xD4   0x2C00             CMP      R4,#+0
   \       0xD6   0xD001             BEQ.N    ??eckey_check_pair_psa_4
   1275                  return ret;
   \       0xD8   0x0020             MOVS     R0,R4
   \       0xDA   0xE032             B.N      ??eckey_check_pair_psa_1
   1276              } else if (destruction_status != PSA_SUCCESS) {
   \                     ??eckey_check_pair_psa_4: (+1)
   \       0xDC   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xE0   0xD003             BEQ.N    ??eckey_check_pair_psa_5
   1277                  return PSA_PK_TO_MBEDTLS_ERR(destruction_status);
   \       0xE2   0x4640             MOV      R0,R8
   \       0xE4   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xE8   0xE02B             B.N      ??eckey_check_pair_psa_1
   1278              }
   1279          
   1280              ret = mbedtls_ecp_point_write_binary(&mbedtls_pk_ec_rw(*pub)->grp,
   1281                                                   &mbedtls_pk_ec_rw(*pub)->Q,
   1282                                                   MBEDTLS_ECP_PF_UNCOMPRESSED,
   1283                                                   &pub_key_len, pub_key_buf,
   1284                                                   sizeof(pub_key_buf));
   \                     ??eckey_check_pair_psa_5: (+1)
   \       0xEA   0x4651             MOV      R1,R10
   \       0xEC   0xB084             SUB      SP,SP,#+16
   \       0xEE   0x4668             MOV      R0,SP
   \       0xF0   0x22A0             MOVS     R2,#+160
   \       0xF2   0x.... 0x....      BL       __aeabi_memcpy4
   \       0xF6   0xBC0F             POP      {R0-R3}
   \       0xF8   0x.... 0x....      BL       mbedtls_pk_ec_rw
   \       0xFC   0x0006             MOVS     R6,R0
   \       0xFE   0x4651             MOV      R1,R10
   \      0x100   0xB084             SUB      SP,SP,#+16
   \      0x102   0x4668             MOV      R0,SP
   \      0x104   0x22A0             MOVS     R2,#+160
   \      0x106   0x.... 0x....      BL       __aeabi_memcpy4
   \      0x10A   0xBC0F             POP      {R0-R3}
   \      0x10C   0x.... 0x....      BL       mbedtls_pk_ec_rw
   \      0x110   0x2141             MOVS     R1,#+65
   \      0x112   0x9101             STR      R1,[SP, #+4]
   \      0x114   0xA932             ADD      R1,SP,#+200
   \      0x116   0x9100             STR      R1,[SP, #+0]
   \      0x118   0xAB26             ADD      R3,SP,#+152
   \      0x11A   0x2200             MOVS     R2,#+0
   \      0x11C   0xF116 0x0168      ADDS     R1,R6,#+104
   \      0x120   0x.... 0x....      BL       mbedtls_ecp_point_write_binary
   \      0x124   0x0006             MOVS     R6,R0
   1285              if (ret != 0) {
   \      0x126   0x2E00             CMP      R6,#+0
   \      0x128   0xD001             BEQ.N    ??eckey_check_pair_psa_6
   1286                  return ret;
   \      0x12A   0x0030             MOVS     R0,R6
   \      0x12C   0xE009             B.N      ??eckey_check_pair_psa_1
   1287              }
   1288          
   1289              if (memcmp(prv_key_buf, pub_key_buf, curve_bytes) != 0) {
   \                     ??eckey_check_pair_psa_6: (+1)
   \      0x12E   0x002A             MOVS     R2,R5
   \      0x130   0xA932             ADD      R1,SP,#+200
   \      0x132   0xA843             ADD      R0,SP,#+268
   \      0x134   0x.... 0x....      BL       memcmp
   \      0x138   0x2800             CMP      R0,#+0
   \      0x13A   0xD001             BEQ.N    ??eckey_check_pair_psa_7
   1290                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \      0x13C   0x....             LDR.N    R0,??DataTable10_5
   \      0x13E   0xE000             B.N      ??eckey_check_pair_psa_1
   1291              }
   1292          
   1293              return 0;
   \                     ??eckey_check_pair_psa_7: (+1)
   \      0x140   0x2000             MOVS     R0,#+0
   \                     ??eckey_check_pair_psa_1: (+1)
   \      0x142   0xB055             ADD      SP,SP,#+340
   \      0x144   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1294          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   1295          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1296          

   \                                 In section .text, align 2, keep-with-next
   1297          static int eckey_check_pair_wrap(mbedtls_pk_context *pub, mbedtls_pk_context *prv,
   1298                                           int (*f_rng)(void *, unsigned char *, size_t),
   1299                                           void *p_rng)
   1300          {
   \                     eckey_check_pair_wrap: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001E             MOVS     R6,R3
   1301              (void) f_rng;
   1302              (void) p_rng;
   1303              return eckey_check_pair_psa(pub, prv);
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0x.... 0x....      BL       eckey_check_pair_psa
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
   1304          }
   1305          #else /* MBEDTLS_USE_PSA_CRYPTO */
   1306          static int eckey_check_pair_wrap(mbedtls_pk_context *pub, mbedtls_pk_context *prv,
   1307                                           int (*f_rng)(void *, unsigned char *, size_t),
   1308                                           void *p_rng)
   1309          {
   1310              return mbedtls_ecp_check_pub_priv((const mbedtls_ecp_keypair *) pub->pk_ctx,
   1311                                                (const mbedtls_ecp_keypair *) prv->pk_ctx,
   1312                                                f_rng, p_rng);
   1313          }
   1314          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1315          
   1316          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1317          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1318          /* When PK_USE_PSA_EC_DATA is defined opaque and non-opaque keys end up
   1319           * using the same function. */
   1320          #define ecdsa_opaque_check_pair_wrap    eckey_check_pair_wrap
   1321          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */

   \                                 In section .text, align 2, keep-with-next
   1322          static int ecdsa_opaque_check_pair_wrap(mbedtls_pk_context *pub,
   1323                                                  mbedtls_pk_context *prv,
   1324                                                  int (*f_rng)(void *, unsigned char *, size_t),
   1325                                                  void *p_rng)
   1326          {
   \                     ecdsa_opaque_check_pair_wrap: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB0C8             SUB      SP,SP,#+288
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x4698             MOV      R8,R3
   1327              psa_status_t status;
   1328              uint8_t exp_pub_key[MBEDTLS_PK_MAX_EC_PUBKEY_RAW_LEN];
   1329              size_t exp_pub_key_len = 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9024             STR      R0,[SP, #+144]
   1330              uint8_t pub_key[MBEDTLS_PK_MAX_EC_PUBKEY_RAW_LEN];
   1331              size_t pub_key_len = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9025             STR      R0,[SP, #+148]
   1332              int ret;
   1333              (void) f_rng;
   1334              (void) p_rng;
   1335          
   1336              status = psa_export_public_key(prv->priv_id, exp_pub_key, sizeof(exp_pub_key),
   1337                                             &exp_pub_key_len);
   \       0x16   0xAB24             ADD      R3,SP,#+144
   \       0x18   0x2241             MOVS     R2,#+65
   \       0x1A   0xA937             ADD      R1,SP,#+220
   \       0x1C   0x68A8             LDR      R0,[R5, #+8]
   \       0x1E   0x.... 0x....      BL       psa_export_public_key
   \       0x22   0x0004             MOVS     R4,R0
   1338              if (status != PSA_SUCCESS) {
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD003             BEQ.N    ??ecdsa_opaque_check_pair_wrap_0
   1339                  ret = psa_pk_status_to_mbedtls(status);
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   1340                  return ret;
   \       0x2E   0xE02F             B.N      ??ecdsa_opaque_check_pair_wrap_1
   1341              }
   1342              ret = mbedtls_ecp_point_write_binary(&(mbedtls_pk_ec_ro(*pub)->grp),
   1343                                                   &(mbedtls_pk_ec_ro(*pub)->Q),
   1344                                                   MBEDTLS_ECP_PF_UNCOMPRESSED,
   1345                                                   &pub_key_len, pub_key, sizeof(pub_key));
   \                     ??ecdsa_opaque_check_pair_wrap_0: (+1)
   \       0x30   0x0039             MOVS     R1,R7
   \       0x32   0xB084             SUB      SP,SP,#+16
   \       0x34   0x4668             MOV      R0,SP
   \       0x36   0x22A0             MOVS     R2,#+160
   \       0x38   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x3C   0xBC0F             POP      {R0-R3}
   \       0x3E   0x.... 0x....      BL       mbedtls_pk_ec_ro
   \       0x42   0x0006             MOVS     R6,R0
   \       0x44   0x0039             MOVS     R1,R7
   \       0x46   0xB084             SUB      SP,SP,#+16
   \       0x48   0x4668             MOV      R0,SP
   \       0x4A   0x22A0             MOVS     R2,#+160
   \       0x4C   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x50   0xBC0F             POP      {R0-R3}
   \       0x52   0x.... 0x....      BL       mbedtls_pk_ec_ro
   \       0x56   0x2141             MOVS     R1,#+65
   \       0x58   0x9101             STR      R1,[SP, #+4]
   \       0x5A   0xA926             ADD      R1,SP,#+152
   \       0x5C   0x9100             STR      R1,[SP, #+0]
   \       0x5E   0xAB25             ADD      R3,SP,#+148
   \       0x60   0x2200             MOVS     R2,#+0
   \       0x62   0xF116 0x0168      ADDS     R1,R6,#+104
   \       0x66   0x.... 0x....      BL       mbedtls_ecp_point_write_binary
   \       0x6A   0x0006             MOVS     R6,R0
   1346              if (ret != 0) {
   \       0x6C   0x2E00             CMP      R6,#+0
   \       0x6E   0xD001             BEQ.N    ??ecdsa_opaque_check_pair_wrap_2
   1347                  return ret;
   \       0x70   0x0030             MOVS     R0,R6
   \       0x72   0xE00D             B.N      ??ecdsa_opaque_check_pair_wrap_1
   1348              }
   1349              if ((exp_pub_key_len != pub_key_len) ||
   1350                  memcmp(exp_pub_key, pub_key, exp_pub_key_len)) {
   \                     ??ecdsa_opaque_check_pair_wrap_2: (+1)
   \       0x74   0x9924             LDR      R1,[SP, #+144]
   \       0x76   0x9825             LDR      R0,[SP, #+148]
   \       0x78   0x4281             CMP      R1,R0
   \       0x7A   0xD106             BNE.N    ??ecdsa_opaque_check_pair_wrap_3
   \       0x7C   0x9A24             LDR      R2,[SP, #+144]
   \       0x7E   0xA926             ADD      R1,SP,#+152
   \       0x80   0xA837             ADD      R0,SP,#+220
   \       0x82   0x.... 0x....      BL       memcmp
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD001             BEQ.N    ??ecdsa_opaque_check_pair_wrap_4
   1351                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??ecdsa_opaque_check_pair_wrap_3: (+1)
   \       0x8A   0x....             LDR.N    R0,??DataTable10_5
   \       0x8C   0xE000             B.N      ??ecdsa_opaque_check_pair_wrap_1
   1352              }
   1353              return 0;
   \                     ??ecdsa_opaque_check_pair_wrap_4: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \                     ??ecdsa_opaque_check_pair_wrap_1: (+1)
   \       0x90   0xB049             ADD      SP,SP,#+292
   \       0x92   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1354          }
   1355          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1356          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1357          
   1358          #if !defined(MBEDTLS_PK_USE_PSA_EC_DATA)

   \                                 In section .text, align 2, keep-with-next
   1359          static void *eckey_alloc_wrap(void)
   1360          {
   \                     eckey_alloc_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1361              void *ctx = mbedtls_calloc(1, sizeof(mbedtls_ecp_keypair));
   \        0x2   0x2180             MOVS     R1,#+128
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x.... 0x....      BL       sl_calloc
   \        0xA   0x0004             MOVS     R4,R0
   1362          
   1363              if (ctx != NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD002             BEQ.N    ??eckey_alloc_wrap_0
   1364                  mbedtls_ecp_keypair_init(ctx);
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       mbedtls_ecp_keypair_init
   1365              }
   1366          
   1367              return ctx;
   \                     ??eckey_alloc_wrap_0: (+1)
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0xBD10             POP      {R4,PC}
   1368          }
   1369          

   \                                 In section .text, align 2, keep-with-next
   1370          static void eckey_free_wrap(void *ctx)
   1371          {
   \                     eckey_free_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1372              mbedtls_ecp_keypair_free((mbedtls_ecp_keypair *) ctx);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       mbedtls_ecp_keypair_free
   1373              mbedtls_free(ctx);
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       sl_free
   1374          }
   \       0x10   0xBD10             POP      {R4,PC}
   1375          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1376          

   \                                 In section .text, align 2, keep-with-next
   1377          static void eckey_debug(mbedtls_pk_context *pk, mbedtls_pk_debug_item *items)
   1378          {
   1379          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1380              items->type = MBEDTLS_PK_DEBUG_PSA_EC;
   1381              items->name = "eckey.Q";
   1382              items->value = pk;
   1383          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1384              mbedtls_ecp_keypair *ecp = (mbedtls_ecp_keypair *) pk->pk_ctx;
   \                     eckey_debug: (+1)
   \        0x0   0x6842             LDR      R2,[R0, #+4]
   1385              items->type = MBEDTLS_PK_DEBUG_ECP;
   \        0x2   0x2302             MOVS     R3,#+2
   \        0x4   0x700B             STRB     R3,[R1, #+0]
   1386              items->name = "eckey.Q";
   \        0x6   0x....             LDR.N    R3,??DataTable10_17
   \        0x8   0x604B             STR      R3,[R1, #+4]
   1387              items->value = &(ecp->Q);
   \        0xA   0xF112 0x0368      ADDS     R3,R2,#+104
   \        0xE   0x608B             STR      R3,[R1, #+8]
   1388          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1389          }
   \       0x10   0x4770             BX       LR
   1390          

   \                                 In section .rodata, align 4
   1391          const mbedtls_pk_info_t mbedtls_eckey_info = {
   \                     mbedtls_eckey_info:
   \        0x0   0x02               DC8 2
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_0, eckey_get_bitlen, eckey_can_do, ecdsa_verify_wrap
   \              0x....'....  
   \              0x....'....  
   \              0x....'....
   \       0x14   0x....'....        DC32 ecdsa_sign_wrap, 0x0, 0x0, eckey_check_pair_wrap, eckey_alloc_wrap
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x....'....  
   \              0x....'....
   \       0x28   0x....'....        DC32 eckey_free_wrap, eckey_debug
   \              0x....'....
   1392              .type = MBEDTLS_PK_ECKEY,
   1393              .name = "EC",
   1394              .get_bitlen = eckey_get_bitlen,
   1395              .can_do = eckey_can_do,
   1396          #if defined(MBEDTLS_PK_CAN_ECDSA_VERIFY)
   1397              .verify_func = ecdsa_verify_wrap,   /* Compatible key structures */
   1398          #else /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1399              .verify_func = NULL,
   1400          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1401          #if defined(MBEDTLS_PK_CAN_ECDSA_SIGN)
   1402              .sign_func = ecdsa_sign_wrap,   /* Compatible key structures */
   1403          #else /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1404              .sign_func = NULL,
   1405          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1406          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1407              .verify_rs_func = eckey_verify_rs_wrap,
   1408              .sign_rs_func = eckey_sign_rs_wrap,
   1409              .rs_alloc_func = eckey_rs_alloc,
   1410              .rs_free_func = eckey_rs_free,
   1411          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1412              .decrypt_func = NULL,
   1413              .encrypt_func = NULL,
   1414              .check_pair_func = eckey_check_pair_wrap,
   1415          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1416              .ctx_alloc_func = NULL,
   1417              .ctx_free_func = NULL,
   1418          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1419              .ctx_alloc_func = eckey_alloc_wrap,
   1420              .ctx_free_func = eckey_free_wrap,
   1421          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1422              .debug_func = eckey_debug,
   1423          };
   1424          
   1425          /*
   1426           * EC key restricted to ECDH
   1427           */

   \                                 In section .text, align 2, keep-with-next
   1428          static int eckeydh_can_do(mbedtls_pk_type_t type)
   1429          {
   1430              return type == MBEDTLS_PK_ECKEY ||
   1431                     type == MBEDTLS_PK_ECKEY_DH;
   \                     eckeydh_can_do: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2902             CMP      R1,#+2
   \        0x6   0xD002             BEQ.N    ??eckeydh_can_do_0
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x2803             CMP      R0,#+3
   \        0xC   0xD101             BNE.N    ??eckeydh_can_do_1
   \                     ??eckeydh_can_do_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE000             B.N      ??eckeydh_can_do_2
   \                     ??eckeydh_can_do_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \                     ??eckeydh_can_do_2: (+1)
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x4770             BX       LR
   1432          }
   1433          

   \                                 In section .rodata, align 4
   1434          const mbedtls_pk_info_t mbedtls_eckeydh_info = {
   \                     mbedtls_eckeydh_info:
   \        0x0   0x03               DC8 3
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_1, eckey_get_bitlen, eckeydh_can_do, 0x0, 0x0, 0x0, 0x0
   \              0x....'....  
   \              0x....'....  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x....'....        DC32 eckey_check_pair_wrap, eckey_alloc_wrap, eckey_free_wrap
   \              0x....'....  
   \              0x....'....
   \       0x2C   0x....'....        DC32 eckey_debug
   1435              .type = MBEDTLS_PK_ECKEY_DH,
   1436              .name = "EC_DH",
   1437              .get_bitlen = eckey_get_bitlen,         /* Same underlying key structure */
   1438              .can_do = eckeydh_can_do,
   1439              .verify_func = NULL,
   1440              .sign_func = NULL,
   1441          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1442              .verify_rs_func = NULL,
   1443              .sign_rs_func = NULL,
   1444          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1445              .decrypt_func = NULL,
   1446              .encrypt_func = NULL,
   1447              .check_pair_func = eckey_check_pair_wrap,
   1448          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1449              .ctx_alloc_func = NULL,
   1450              .ctx_free_func = NULL,
   1451          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1452              .ctx_alloc_func = eckey_alloc_wrap,   /* Same underlying key structure */
   1453              .ctx_free_func = eckey_free_wrap,    /* Same underlying key structure */
   1454          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1455              .debug_func = eckey_debug,            /* Same underlying key structure */
   1456          };
   1457          
   1458          #if defined(MBEDTLS_PK_CAN_ECDSA_SOME)

   \                                 In section .text, align 2, keep-with-next
   1459          static int ecdsa_can_do(mbedtls_pk_type_t type)
   1460          {
   1461              return type == MBEDTLS_PK_ECDSA;
   \                     ecdsa_can_do: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0
   \        0x2   0x2804             CMP      R0,#+4
   \        0x4   0xD101             BNE.N    ??ecdsa_can_do_0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE000             B.N      ??ecdsa_can_do_1
   \                     ??ecdsa_can_do_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \                     ??ecdsa_can_do_1: (+1)
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x4770             BX       LR
   1462          }
   1463          
   1464          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1465          static int ecdsa_verify_rs_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1466                                          const unsigned char *hash, size_t hash_len,
   1467                                          const unsigned char *sig, size_t sig_len,
   1468                                          void *rs_ctx)
   1469          {
   1470              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1471              ((void) md_alg);
   1472          
   1473              ret = mbedtls_ecdsa_read_signature_restartable(
   1474                  (mbedtls_ecdsa_context *) pk->pk_ctx,
   1475                  hash, hash_len, sig, sig_len,
   1476                  (mbedtls_ecdsa_restart_ctx *) rs_ctx);
   1477          
   1478              if (ret == MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) {
   1479                  return MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
   1480              }
   1481          
   1482              return ret;
   1483          }
   1484          
   1485          static int ecdsa_sign_rs_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1486                                        const unsigned char *hash, size_t hash_len,
   1487                                        unsigned char *sig, size_t sig_size, size_t *sig_len,
   1488                                        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   1489                                        void *rs_ctx)
   1490          {
   1491              return mbedtls_ecdsa_write_signature_restartable(
   1492                  (mbedtls_ecdsa_context *) pk->pk_ctx,
   1493                  md_alg, hash, hash_len, sig, sig_size, sig_len, f_rng, p_rng,
   1494                  (mbedtls_ecdsa_restart_ctx *) rs_ctx);
   1495          
   1496          }
   1497          
   1498          static void *ecdsa_rs_alloc(void)
   1499          {
   1500              void *ctx = mbedtls_calloc(1, sizeof(mbedtls_ecdsa_restart_ctx));
   1501          
   1502              if (ctx != NULL) {
   1503                  mbedtls_ecdsa_restart_init(ctx);
   1504              }
   1505          
   1506              return ctx;
   1507          }
   1508          
   1509          static void ecdsa_rs_free(void *ctx)
   1510          {
   1511              mbedtls_ecdsa_restart_free(ctx);
   1512              mbedtls_free(ctx);
   1513          }
   1514          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1515          

   \                                 In section .rodata, align 4
   1516          const mbedtls_pk_info_t mbedtls_ecdsa_info = {
   \                     mbedtls_ecdsa_info:
   \        0x0   0x04               DC8 4
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_2, eckey_get_bitlen, ecdsa_can_do, ecdsa_verify_wrap
   \              0x....'....  
   \              0x....'....  
   \              0x....'....
   \       0x14   0x....'....        DC32 ecdsa_sign_wrap, 0x0, 0x0, eckey_check_pair_wrap, eckey_alloc_wrap
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x....'....  
   \              0x....'....
   \       0x28   0x....'....        DC32 eckey_free_wrap, eckey_debug
   \              0x....'....
   1517              .type = MBEDTLS_PK_ECDSA,
   1518              .name = "ECDSA",
   1519              .get_bitlen = eckey_get_bitlen,     /* Compatible key structures */
   1520              .can_do = ecdsa_can_do,
   1521          #if defined(MBEDTLS_PK_CAN_ECDSA_VERIFY)
   1522              .verify_func = ecdsa_verify_wrap,   /* Compatible key structures */
   1523          #else /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1524              .verify_func = NULL,
   1525          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1526          #if defined(MBEDTLS_PK_CAN_ECDSA_SIGN)
   1527              .sign_func = ecdsa_sign_wrap,   /* Compatible key structures */
   1528          #else /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1529              .sign_func = NULL,
   1530          #endif /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1531          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1532              .verify_rs_func = ecdsa_verify_rs_wrap,
   1533              .sign_rs_func = ecdsa_sign_rs_wrap,
   1534              .rs_alloc_func = ecdsa_rs_alloc,
   1535              .rs_free_func = ecdsa_rs_free,
   1536          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1537              .decrypt_func = NULL,
   1538              .encrypt_func = NULL,
   1539              .check_pair_func = eckey_check_pair_wrap,   /* Compatible key structures */
   1540          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1541              .ctx_alloc_func = NULL,
   1542              .ctx_free_func = NULL,
   1543          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1544              .ctx_alloc_func = eckey_alloc_wrap,   /* Compatible key structures */
   1545              .ctx_free_func = eckey_free_wrap,   /* Compatible key structures */
   1546          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1547              .debug_func = eckey_debug,        /* Compatible key structures */
   1548          };
   1549          #endif /* MBEDTLS_PK_CAN_ECDSA_SOME */
   1550          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
   1551          
   1552          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
   1553          /*
   1554           * Support for alternative RSA-private implementations
   1555           */
   1556          
   1557          static int rsa_alt_can_do(mbedtls_pk_type_t type)
   1558          {
   1559              return type == MBEDTLS_PK_RSA;
   1560          }
   1561          
   1562          static size_t rsa_alt_get_bitlen(mbedtls_pk_context *pk)
   1563          {
   1564              const mbedtls_rsa_alt_context *rsa_alt = pk->pk_ctx;
   1565          
   1566              return 8 * rsa_alt->key_len_func(rsa_alt->key);
   1567          }
   1568          
   1569          static int rsa_alt_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1570                                       const unsigned char *hash, size_t hash_len,
   1571                                       unsigned char *sig, size_t sig_size, size_t *sig_len,
   1572                                       int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1573          {
   1574              mbedtls_rsa_alt_context *rsa_alt = pk->pk_ctx;
   1575          
   1576          #if SIZE_MAX > UINT_MAX
   1577              if (UINT_MAX < hash_len) {
   1578                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1579              }
   1580          #endif
   1581          
   1582              *sig_len = rsa_alt->key_len_func(rsa_alt->key);
   1583              if (*sig_len > MBEDTLS_PK_SIGNATURE_MAX_SIZE) {
   1584                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1585              }
   1586              if (*sig_len > sig_size) {
   1587                  return MBEDTLS_ERR_PK_BUFFER_TOO_SMALL;
   1588              }
   1589          
   1590              return rsa_alt->sign_func(rsa_alt->key, f_rng, p_rng,
   1591                                        md_alg, (unsigned int) hash_len, hash, sig);
   1592          }
   1593          
   1594          static int rsa_alt_decrypt_wrap(mbedtls_pk_context *pk,
   1595                                          const unsigned char *input, size_t ilen,
   1596                                          unsigned char *output, size_t *olen, size_t osize,
   1597                                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1598          {
   1599              mbedtls_rsa_alt_context *rsa_alt = pk->pk_ctx;
   1600          
   1601              ((void) f_rng);
   1602              ((void) p_rng);
   1603          
   1604              if (ilen != rsa_alt->key_len_func(rsa_alt->key)) {
   1605                  return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
   1606              }
   1607          
   1608              return rsa_alt->decrypt_func(rsa_alt->key,
   1609                                           olen, input, output, osize);
   1610          }
   1611          
   1612          #if defined(MBEDTLS_RSA_C)
   1613          static int rsa_alt_check_pair(mbedtls_pk_context *pub, mbedtls_pk_context *prv,
   1614                                        int (*f_rng)(void *, unsigned char *, size_t),
   1615                                        void *p_rng)
   1616          {
   1617              unsigned char sig[MBEDTLS_MPI_MAX_SIZE];
   1618              unsigned char hash[32];
   1619              size_t sig_len = 0;
   1620              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1621          
   1622              if (rsa_alt_get_bitlen(prv) != rsa_get_bitlen(pub)) {
   1623                  return MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
   1624              }
   1625          
   1626              memset(hash, 0x2a, sizeof(hash));
   1627          
   1628              if ((ret = rsa_alt_sign_wrap(prv, MBEDTLS_MD_NONE,
   1629                                           hash, sizeof(hash),
   1630                                           sig, sizeof(sig), &sig_len,
   1631                                           f_rng, p_rng)) != 0) {
   1632                  return ret;
   1633              }
   1634          
   1635              if (rsa_verify_wrap(pub, MBEDTLS_MD_NONE,
   1636                                  hash, sizeof(hash), sig, sig_len) != 0) {
   1637                  return MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
   1638              }
   1639          
   1640              return 0;
   1641          }
   1642          #endif /* MBEDTLS_RSA_C */
   1643          
   1644          static void *rsa_alt_alloc_wrap(void)
   1645          {
   1646              void *ctx = mbedtls_calloc(1, sizeof(mbedtls_rsa_alt_context));
   1647          
   1648              if (ctx != NULL) {
   1649                  memset(ctx, 0, sizeof(mbedtls_rsa_alt_context));
   1650              }
   1651          
   1652              return ctx;
   1653          }
   1654          
   1655          static void rsa_alt_free_wrap(void *ctx)
   1656          {
   1657              mbedtls_zeroize_and_free(ctx, sizeof(mbedtls_rsa_alt_context));
   1658          }
   1659          
   1660          const mbedtls_pk_info_t mbedtls_rsa_alt_info = {
   1661              .type = MBEDTLS_PK_RSA_ALT,
   1662              .name = "RSA-alt",
   1663              .get_bitlen = rsa_alt_get_bitlen,
   1664              .can_do = rsa_alt_can_do,
   1665              .verify_func = NULL,
   1666              .sign_func = rsa_alt_sign_wrap,
   1667          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1668              .verify_rs_func = NULL,
   1669              .sign_rs_func = NULL,
   1670              .rs_alloc_func = NULL,
   1671              .rs_free_func = NULL,
   1672          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1673              .decrypt_func = rsa_alt_decrypt_wrap,
   1674              .encrypt_func = NULL,
   1675          #if defined(MBEDTLS_RSA_C)
   1676              .check_pair_func = rsa_alt_check_pair,
   1677          #else
   1678              .check_pair_func = NULL,
   1679          #endif
   1680              .ctx_alloc_func = rsa_alt_alloc_wrap,
   1681              .ctx_free_func = rsa_alt_free_wrap,
   1682              .debug_func = NULL,
   1683          };
   1684          #endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
   1685          
   1686          #if defined(MBEDTLS_USE_PSA_CRYPTO)

   \                                 In section .text, align 2, keep-with-next
   1687          static size_t opaque_get_bitlen(mbedtls_pk_context *pk)
   1688          {
   \                     opaque_get_bitlen: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x0004             MOVS     R4,R0
   1689              size_t bits;
   1690              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x2124             MOVS     R1,#+36
   \        0xA   0x.... 0x....      BL       __aeabi_memclr4
   1691          
   1692              if (PSA_SUCCESS != psa_get_key_attributes(pk->priv_id, &attributes)) {
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x68A0             LDR      R0,[R4, #+8]
   \       0x12   0x.... 0x....      BL       psa_get_key_attributes
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??opaque_get_bitlen_0
   1693                  return 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE007             B.N      ??opaque_get_bitlen_1
   1694              }
   1695          
   1696              bits = psa_get_key_bits(&attributes);
   \                     ??opaque_get_bitlen_0: (+1)
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x.... 0x....      BL       psa_get_key_bits
   \       0x24   0x0005             MOVS     R5,R0
   1697              psa_reset_key_attributes(&attributes);
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x.... 0x....      BL       psa_reset_key_attributes
   1698              return bits;
   \       0x2C   0x0028             MOVS     R0,R5
   \                     ??opaque_get_bitlen_1: (+1)
   \       0x2E   0xB009             ADD      SP,SP,#+36
   \       0x30   0xBD30             POP      {R4,R5,PC}
   1699          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   1700          
   1701          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)

   \                                 In section .text, align 2, keep-with-next
   1702          static int ecdsa_opaque_can_do(mbedtls_pk_type_t type)
   1703          {
   1704              return type == MBEDTLS_PK_ECKEY ||
   1705                     type == MBEDTLS_PK_ECDSA;
   \                     ecdsa_opaque_can_do: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2902             CMP      R1,#+2
   \        0x6   0xD002             BEQ.N    ??ecdsa_opaque_can_do_0
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xD101             BNE.N    ??ecdsa_opaque_can_do_1
   \                     ??ecdsa_opaque_can_do_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE000             B.N      ??ecdsa_opaque_can_do_2
   \                     ??ecdsa_opaque_can_do_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \                     ??ecdsa_opaque_can_do_2: (+1)
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x4770             BX       LR
   1706          }
   1707          

   \                                 In section .rodata, align 4
   1708          const mbedtls_pk_info_t mbedtls_ecdsa_opaque_info = {
   \                     mbedtls_ecdsa_opaque_info:
   \        0x0   0x07               DC8 7
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_3, opaque_get_bitlen, ecdsa_opaque_can_do
   \              0x....'....  
   \              0x....'....
   \       0x10   0x....'....        DC32 ecdsa_opaque_verify_wrap, ecdsa_opaque_sign_wrap, 0x0, 0x0
   \              0x....'....  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x....'....        DC32 ecdsa_opaque_check_pair_wrap, 0x0, 0x0, 0x0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   1709              .type = MBEDTLS_PK_OPAQUE,
   1710              .name = "Opaque",
   1711              .get_bitlen = opaque_get_bitlen,
   1712              .can_do = ecdsa_opaque_can_do,
   1713          #if defined(MBEDTLS_PK_CAN_ECDSA_VERIFY)
   1714              .verify_func = ecdsa_opaque_verify_wrap,
   1715          #else /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1716              .verify_func = NULL,
   1717          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1718          #if defined(MBEDTLS_PK_CAN_ECDSA_SIGN)
   1719              .sign_func = ecdsa_opaque_sign_wrap,
   1720          #else /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1721              .sign_func = NULL,
   1722          #endif /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1723          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1724              .verify_rs_func = NULL,
   1725              .sign_rs_func = NULL,
   1726              .rs_alloc_func = NULL,
   1727              .rs_free_func = NULL,
   1728          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1729              .decrypt_func = NULL,
   1730              .encrypt_func = NULL,
   1731              .check_pair_func = ecdsa_opaque_check_pair_wrap,
   1732              .ctx_alloc_func = NULL,
   1733              .ctx_free_func = NULL,
   1734              .debug_func = NULL,
   1735          };
   1736          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
   1737          

   \                                 In section .text, align 2, keep-with-next
   1738          static int rsa_opaque_can_do(mbedtls_pk_type_t type)
   1739          {
   1740              return type == MBEDTLS_PK_RSA ||
   1741                     type == MBEDTLS_PK_RSASSA_PSS;
   \                     rsa_opaque_can_do: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD002             BEQ.N    ??rsa_opaque_can_do_0
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x2806             CMP      R0,#+6
   \        0xC   0xD101             BNE.N    ??rsa_opaque_can_do_1
   \                     ??rsa_opaque_can_do_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE000             B.N      ??rsa_opaque_can_do_2
   \                     ??rsa_opaque_can_do_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \                     ??rsa_opaque_can_do_2: (+1)
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x4770             BX       LR
   1742          }
   1743          
   1744          #if defined(PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC)
   1745          static int rsa_opaque_decrypt(mbedtls_pk_context *pk,
   1746                                        const unsigned char *input, size_t ilen,
   1747                                        unsigned char *output, size_t *olen, size_t osize,
   1748                                        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1749          {
   1750              psa_status_t status;
   1751          
   1752              /* PSA has its own RNG */
   1753              (void) f_rng;
   1754              (void) p_rng;
   1755          
   1756              status = psa_asymmetric_decrypt(pk->priv_id, PSA_ALG_RSA_PKCS1V15_CRYPT,
   1757                                              input, ilen,
   1758                                              NULL, 0,
   1759                                              output, osize, olen);
   1760              if (status != PSA_SUCCESS) {
   1761                  return PSA_PK_RSA_TO_MBEDTLS_ERR(status);
   1762              }
   1763          
   1764              return 0;
   1765          }
   1766          #endif /* PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC */
   1767          

   \                                 In section .text, align 2, keep-with-next
   1768          static int rsa_opaque_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1769                                          const unsigned char *hash, size_t hash_len,
   1770                                          unsigned char *sig, size_t sig_size, size_t *sig_len,
   1771                                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1772          {
   \                     rsa_opaque_sign_wrap: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0004             MOVS     R4,R0
   1773          #if defined(MBEDTLS_RSA_C)
   1774              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   1775              psa_algorithm_t alg;
   1776              psa_key_type_t type;
   1777              psa_status_t status;
   1778          
   1779              /* PSA has its own RNG */
   1780              (void) f_rng;
   1781              (void) p_rng;
   1782          
   1783              status = psa_get_key_attributes(pk->priv_id, &attributes);
   1784              if (status != PSA_SUCCESS) {
   1785                  return PSA_PK_TO_MBEDTLS_ERR(status);
   1786              }
   1787          
   1788              type = psa_get_key_type(&attributes);
   1789              psa_reset_key_attributes(&attributes);
   1790          
   1791              if (PSA_KEY_TYPE_IS_RSA(type)) {
   1792                  alg = PSA_ALG_RSA_PKCS1V15_SIGN(mbedtls_md_psa_alg_from_type(md_alg));
   1793              } else {
   1794                  return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   1795              }
   1796          
   1797              /* make the signature */
   1798              status = psa_sign_hash(pk->priv_id, alg, hash, hash_len,
   1799                                     sig, sig_size, sig_len);
   1800              if (status != PSA_SUCCESS) {
   1801                  if (PSA_KEY_TYPE_IS_RSA(type)) {
   1802                      return PSA_PK_RSA_TO_MBEDTLS_ERR(status);
   1803                  } else {
   1804                      return PSA_PK_TO_MBEDTLS_ERR(status);
   1805                  }
   1806              }
   1807          
   1808              return 0;
   1809          #else /* !MBEDTLS_RSA_C */
   1810              ((void) pk);
   1811              ((void) md_alg);
   1812              ((void) hash);
   1813              ((void) hash_len);
   1814              ((void) sig);
   1815              ((void) sig_size);
   1816              ((void) sig_len);
   1817              ((void) f_rng);
   1818              ((void) p_rng);
   1819              return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   \        0x4   0x....             LDR.N    R0,??DataTable10_2
   \        0x6   0xBC10             POP      {R4}
   \        0x8   0x4770             BX       LR
   1820          #endif /* !MBEDTLS_RSA_C */
   1821          }
   1822          

   \                                 In section .rodata, align 4
   1823          const mbedtls_pk_info_t mbedtls_rsa_opaque_info = {
   \                     mbedtls_rsa_opaque_info:
   \        0x0   0x07               DC8 7
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_3, opaque_get_bitlen, rsa_opaque_can_do, 0x0
   \              0x....'....  
   \              0x....'....  
   \              0x0000'0000
   \       0x14   0x....'....        DC32 rsa_opaque_sign_wrap, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0xFFFF'C300        DC32     0xffffc300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0xFFFF'C780        DC32     0xffffc780

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0xFFFF'C680        DC32     0xffffc680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0xFFFF'C580        DC32     0xffffc580

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0xFFFF'C080        DC32     0xffffc080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0xFFFF'C180        DC32     0xffffc180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0xFFFF'C200        DC32     0xffffc200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \        0x0   0xFFFF'B080        DC32     0xffffb080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \        0x0   0xFFFF'B180        DC32     0xffffb180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \        0x0   0xFFFF'B100        DC32     0xffffb100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \        0x0   0xFFFF'B300        DC32     0xffffb300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \        0x0   0xFFFF'B200        DC32     0xffffb200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \        0x0   0x....'....        DC32     psa_pk_status_to_mbedtls

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \        0x0   0x....'....        DC32     psa_to_pk_ecdsa_errors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \        0x0   0xFFFF'C700        DC32     0xffffc700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \        0x0   0x0600'0700        DC32     0x6000700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x45 0x43          DC8 "EC"
   \              0x00
   \        0x3                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x45 0x43          DC8 "EC_DH"
   \              0x5F 0x44    
   \              0x48 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x45 0x43          DC8 "ECDSA"
   \              0x44 0x53    
   \              0x41 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x4F 0x70          DC8 "Opaque"
   \              0x61 0x71    
   \              0x75 0x65    
   \              0x00
   \        0x7                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x65 0x63          DC8 "eckey.Q"
   \              0x6B 0x65    
   \              0x79 0x2E    
   \              0x51 0x00
   1824              .type = MBEDTLS_PK_OPAQUE,
   1825              .name = "Opaque",
   1826              .get_bitlen = opaque_get_bitlen,
   1827              .can_do = rsa_opaque_can_do,
   1828              .verify_func = NULL,
   1829              .sign_func = rsa_opaque_sign_wrap,
   1830          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1831              .verify_rs_func = NULL,
   1832              .sign_rs_func = NULL,
   1833              .rs_alloc_func = NULL,
   1834              .rs_free_func = NULL,
   1835          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1836          #if defined(PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC)
   1837              .decrypt_func = rsa_opaque_decrypt,
   1838          #else /* PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC */
   1839              .decrypt_func = NULL,
   1840          #endif /* PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC */
   1841              .encrypt_func = NULL,
   1842              .check_pair_func = NULL,
   1843              .ctx_alloc_func = NULL,
   1844              .ctx_free_func = NULL,
   1845              .debug_func = NULL,
   1846          };
   1847          
   1848          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1849          
   1850          #endif /* MBEDTLS_PK_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   asn1_write_mpibuf
        40   -> __aeabi_memmove
        40   -> mbedtls_asn1_write_len
        40   -> mbedtls_asn1_write_tag
       0   ecdsa_can_do
       0   ecdsa_opaque_can_do
     336   ecdsa_opaque_check_pair_wrap
       336   -> __aeabi_memcpy4
       320   -> mbedtls_ecp_point_write_binary
       320   -> mbedtls_pk_ec_ro
       320   -> memcmp
       320   -> psa_export_public_key
       320   -> psa_pk_status_to_mbedtls
      32   ecdsa_opaque_sign_wrap
        32   -> ecdsa_sign_psa
     160   ecdsa_opaque_verify_wrap
       160   -> __aeabi_memclr4
       160   -> ecdsa_verify_psa
       160   -> psa_export_public_key
       160   -> psa_get_key_attributes
       160   -> psa_get_key_bits
       160   -> psa_get_key_type
       160   -> psa_reset_key_attributes
       160   -> psa_status_to_mbedtls
     104   ecdsa_sign_psa
       104   -> __aeabi_memclr4
       104   -> mbedtls_md_psa_alg_from_type
       104   -> pk_ecdsa_sig_asn1_from_psa
       104   -> psa_get_key_algorithm
       104   -> psa_get_key_attributes
       104   -> psa_reset_key_attributes
       104   -> psa_sign_hash
       104   -> psa_status_to_mbedtls
     136   ecdsa_sign_wrap
       136   -> __aeabi_memclr4
       136   -> ecdsa_sign_psa
       136   -> mbedtls_ecc_group_to_psa
       136   -> mbedtls_md_psa_alg_from_type
       136   -> mbedtls_mpi_write_binary
       136   -> mbedtls_platform_zeroize
       136   -> psa_destroy_key
       136   -> psa_import_key
       136   -> psa_pk_status_to_mbedtls
       136   -> psa_set_key_algorithm
       136   -> psa_set_key_type
       136   -> psa_set_key_usage_flags
     168   ecdsa_verify_psa
       168   -> __aeabi_memclr4
       168   -> extract_ecdsa_sig
       168   -> psa_destroy_key
       168   -> psa_import_key
       168   -> psa_pk_status_to_mbedtls
       168   -> psa_set_key_algorithm
       168   -> psa_set_key_type
       168   -> psa_set_key_usage_flags
       168   -> psa_status_to_mbedtls
       168   -> psa_verify_hash
     128   ecdsa_verify_wrap
       128   -> ecdsa_verify_psa
       128   -> mbedtls_ecc_group_to_psa
       128   -> mbedtls_ecp_point_write_binary
       8   eckey_alloc_wrap
         8   -> mbedtls_ecp_keypair_init
         8   -> sl_calloc
       0   eckey_can_do
     392   eckey_check_pair_psa
       376   -> __aeabi_memclr4
       392   -> __aeabi_memcpy4
       376   -> mbedtls_ecc_group_to_psa
       376   -> mbedtls_ecp_point_write_binary
       376   -> mbedtls_mpi_write_binary
       376   -> mbedtls_pk_ec_ro
       376   -> mbedtls_pk_ec_rw
       376   -> mbedtls_platform_zeroize
       376   -> memcmp
       376   -> psa_destroy_key
       376   -> psa_export_public_key
       376   -> psa_import_key
       376   -> psa_pk_status_to_mbedtls
       376   -> psa_set_key_type
       376   -> psa_set_key_usage_flags
      24   eckey_check_pair_wrap
        24   -> eckey_check_pair_psa
       0   eckey_debug
       8   eckey_free_wrap
         8   -> mbedtls_ecp_keypair_free
         8   -> sl_free
       0   eckey_get_bitlen
       0   eckeydh_can_do
      32   extract_ecdsa_sig
        32   -> extract_ecdsa_sig_int
        32   -> mbedtls_asn1_get_tag
      56   extract_ecdsa_sig_int
        56   -> __aeabi_memcpy
        56   -> __aeabi_memset
        56   -> mbedtls_asn1_get_tag
       0   mbedtls_md_psa_alg_from_type
      24   mbedtls_pk_ec_ro
        24   -> mbedtls_pk_get_type
      24   mbedtls_pk_ec_rw
        24   -> mbedtls_pk_get_type
       0   mbedtls_pk_error_from_psa
       0   mbedtls_pk_error_from_psa_ecdsa
      48   opaque_get_bitlen
        48   -> __aeabi_memclr4
        48   -> psa_get_key_attributes
        48   -> psa_get_key_bits
        48   -> psa_reset_key_attributes
      48   pk_ecdsa_sig_asn1_from_psa
        48   -> __aeabi_memmove
        48   -> asn1_write_mpibuf
        48   -> mbedtls_asn1_write_len
        48   -> mbedtls_asn1_write_tag
       0   psa_extend_key_usage_flags
       0   psa_get_key_algorithm
       0   psa_get_key_bits
       0   psa_get_key_type
       0   psa_set_key_algorithm
      16   psa_set_key_type
        16   -> psa_set_key_domain_parameters
      16   psa_set_key_usage_flags
        16   -> psa_extend_key_usage_flags
       0   rsa_opaque_can_do
       4   rsa_opaque_sign_wrap


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ?_0
       8  ?_1
      36  ?_10
       8  ?_2
       8  ?_3
       8  ?_4
      36  ?_5
      36  ?_6
      36  ?_7
      36  ?_8
      36  ?_9
     180  asn1_write_mpibuf
      16  ecdsa_can_do
      24  ecdsa_opaque_can_do
     150  ecdsa_opaque_check_pair_wrap
      38  ecdsa_opaque_sign_wrap
     174  ecdsa_opaque_verify_wrap
     188  ecdsa_sign_psa
     254  ecdsa_sign_wrap
     260  ecdsa_verify_psa
      98  ecdsa_verify_wrap
      26  eckey_alloc_wrap
      32  eckey_can_do
     328  eckey_check_pair_psa
      20  eckey_check_pair_wrap
      18  eckey_debug
      18  eckey_free_wrap
       8  eckey_get_bitlen
      24  eckeydh_can_do
      90  extract_ecdsa_sig
     152  extract_ecdsa_sig_int
      48  mbedtls_ecdsa_info
      48  mbedtls_ecdsa_opaque_info
      48  mbedtls_eckey_info
      48  mbedtls_eckeydh_info
       8  mbedtls_md_psa_alg_from_type
      28  mbedtls_pk_ec_ro
      28  mbedtls_pk_ec_rw
     134  mbedtls_pk_error_from_psa
     146  mbedtls_pk_error_from_psa_ecdsa
      48  mbedtls_rsa_opaque_info
      50  opaque_get_bitlen
     150  pk_ecdsa_sig_asn1_from_psa
      30  psa_extend_key_usage_flags
       4  psa_get_key_algorithm
       4  psa_get_key_bits
       4  psa_get_key_type
       4  psa_set_key_algorithm
      32  psa_set_key_type
      16  psa_set_key_usage_flags
      24  rsa_opaque_can_do
      10  rsa_opaque_sign_wrap

 
   492 bytes in section .rodata
 2'842 bytes in section .text
 
 2'842 bytes of CODE  memory
   492 bytes of CONST memory

Errors: none
Warnings: none
