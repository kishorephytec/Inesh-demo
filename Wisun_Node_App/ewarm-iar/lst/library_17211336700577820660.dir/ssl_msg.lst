###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:53
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_msg.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ssl_msg.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_msg.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ssl_msg.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\ssl_msg.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ssl_msg.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_msg.c
      1          /*
      2           *  Generic SSL/TLS messaging layer functions
      3           *  (record layer + retransmission state machine)
      4           *
      5           *  Copyright The Mbed TLS Contributors
      6           *  SPDX-License-Identifier: Apache-2.0
      7           *
      8           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      9           *  not use this file except in compliance with the License.
     10           *  You may obtain a copy of the License at
     11           *
     12           *  http://www.apache.org/licenses/LICENSE-2.0
     13           *
     14           *  Unless required by applicable law or agreed to in writing, software
     15           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     16           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     17           *  See the License for the specific language governing permissions and
     18           *  limitations under the License.
     19           */
     20          /*
     21           *  http://www.ietf.org/rfc/rfc2246.txt
     22           *  http://www.ietf.org/rfc/rfc4346.txt
     23           */
     24          
     25          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint16_t mbedtls_get_unaligned_uint16(void const *)
   \                     mbedtls_get_unaligned_uint16: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2402             MOVS     R4,#+2
   \        0x6   0x003D             MOVS     R5,R7
   \        0x8   0x466E             MOV      R6,SP
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x18   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2402             MOVS     R4,#+2
   \        0x6   0x466D             MOV      R5,SP
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2
   \   __vfp uint32_t mbedtls_get_unaligned_uint32(void const *)
   \                     mbedtls_get_unaligned_uint32: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2404             MOVS     R4,#+4
   \        0x6   0x003D             MOVS     R5,R7
   \        0x8   0x466E             MOV      R6,SP
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint32(void *, uint32_t)
   \                     mbedtls_put_unaligned_uint32: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2404             MOVS     R4,#+4
   \        0x6   0x466D             MOV      R5,SP
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t mbedtls_bswap16(uint16_t)
   \                     mbedtls_bswap16: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x0A00             LSRS     R0,R0,#+8
   \        0x8   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x4770             BX       LR

   \                                 In section .rodata, align 2
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256

   \                                 In section .text, align 2
   \   __vfp void mbedtls_xor(unsigned char *, unsigned char const *, unsigned char const *, size_t)
   \                     mbedtls_xor: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??mbedtls_xor_0: (+1)
   \       0x10   0xF118 0x0004      ADDS     R0,R8,#+4
   \       0x14   0x4287             CMP      R7,R0
   \       0x16   0xD313             BCC.N    ??mbedtls_xor_1
   \       0x18   0xEB05 0x0008      ADD      R0,R5,R8
   \       0x1C   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x20   0x4681             MOV      R9,R0
   \       0x22   0xEB06 0x0008      ADD      R0,R6,R8
   \       0x26   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x2A   0x4682             MOV      R10,R0
   \       0x2C   0xEA9A 0x0A09      EORS     R10,R10,R9
   \       0x30   0x4651             MOV      R1,R10
   \       0x32   0xEB04 0x0008      ADD      R0,R4,R8
   \       0x36   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
   \       0x3A   0xF118 0x0804      ADDS     R8,R8,#+4
   \       0x3E   0xE7E7             B.N      ??mbedtls_xor_0
   \                     ??mbedtls_xor_1: (+1)
   \       0x40   0x45B8             CMP      R8,R7
   \       0x42   0xD209             BCS.N    ??mbedtls_xor_2
   \       0x44   0xF815 0x1008      LDRB     R1,[R5, R8]
   \       0x48   0xF816 0x0008      LDRB     R0,[R6, R8]
   \       0x4C   0x4041             EORS     R1,R0,R1
   \       0x4E   0xF804 0x1008      STRB     R1,[R4, R8]
   \       0x52   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x56   0xE7F3             B.N      ??mbedtls_xor_1
   \                     ??mbedtls_xor_2: (+1)
   \       0x58   0xE8BD 0x87F0      POP      {R4-R10,PC}
     26          
     27          #if defined(MBEDTLS_SSL_TLS_C)
     28          
     29          #include "mbedtls/platform.h"
     30          
     31          #include "mbedtls/ssl.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t psa_get_key_type(psa_key_attributes_t const *)
   \                     psa_get_key_type: (+1)
   \        0x0   0x8800             LDRH     R0,[R0, #+0]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_is_handshake_over(mbedtls_ssl_context *)
   \                     mbedtls_ssl_is_handshake_over: (+1)
   \        0x0   0x6840             LDR      R0,[R0, #+4]
   \        0x2   0x281B             CMP      R0,#+27
   \        0x4   0xDB01             BLT.N    ??mbedtls_ssl_is_handshake_over_0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE000             B.N      ??mbedtls_ssl_is_handshake_over_1
   \                     ??mbedtls_ssl_is_handshake_over_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_is_handshake_over_1: (+1)
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x4770             BX       LR
     32          #include "ssl_misc.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_write_handshake_msg(mbedtls_ssl_context *)
   \                     mbedtls_ssl_write_handshake_msg: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       mbedtls_ssl_write_handshake_msg_ext
   \        0xE   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_ssl_in_hdr_len(mbedtls_ssl_context const *)
   \                     mbedtls_ssl_in_hdr_len: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x2005             MOVS     R0,#+5
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_ssl_out_hdr_len(mbedtls_ssl_context const *)
   \                     mbedtls_ssl_out_hdr_len: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xF8D1 0x00A4      LDR      R0,[R1, #+164]
   \        0x6   0xF8D1 0x109C      LDR      R1,[R1, #+156]
   \        0xA   0x1A40             SUBS     R0,R0,R1
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_ssl_hs_hdr_len(mbedtls_ssl_context const *)
   \                     mbedtls_ssl_hs_hdr_len: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x2004             MOVS     R0,#+4
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_ssl_ep_len(mbedtls_ssl_context const *)
   \                     mbedtls_ssl_ep_len: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x4770             BX       LR

      return 0;
      ^
"D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_misc.h",2433  Warning[Pe111]: 
          statement is unreachable
     33          #include "mbedtls/debug.h"
     34          #include "mbedtls/error.h"
     35          #include "mbedtls/platform_util.h"
     36          #include "mbedtls/version.h"
     37          #include "constant_time_internal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_compiler_opaque(uint32_t)
   \                     mbedtls_ct_compiler_opaque: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable6
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0x4048             EORS     R0,R1,R0
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool(uint32_t)
   \                     mbedtls_ct_bool: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xA   0x0002             MOVS     R2,R0
   \        0xC   0x4251             RSBS     R1,R2,#+0
   \        0xE   0x0010             MOVS     R0,R2
   \       0x10   0x0840             LSRS     R0,R0,#+1
   \       0x12   0x4240             RSBS     R0,R0,#+0
   \       0x14   0x4308             ORRS     R0,R0,R1
   \       0x16   0x0FC0             LSRS     R0,R0,#+31
   \       0x18   0x4240             RSBS     R0,R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_if(uint32_t, uint32_t, uint32_t)
   \                     mbedtls_ct_if: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xE   0x43C0             MVNS     R0,R0
   \       0x10   0x4026             ANDS     R6,R4,R6
   \       0x12   0x4005             ANDS     R5,R5,R0
   \       0x14   0x432E             ORRS     R6,R5,R6
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_lt(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_lt: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x4648             MOV      R0,R9
   \        0xA   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xE   0x0005             MOVS     R5,R0
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x16   0x0006             MOVS     R6,R0
   \       0x18   0xEA96 0x0005      EORS     R0,R6,R5
   \       0x1C   0x0FC0             LSRS     R0,R0,#+31
   \       0x1E   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x22   0x0007             MOVS     R7,R0
   \       0x24   0x1BAA             SUBS     R2,R5,R6
   \       0x26   0x0031             MOVS     R1,R6
   \       0x28   0x0038             MOVS     R0,R7
   \       0x2A   0x.... 0x....      BL       mbedtls_ct_if
   \       0x2E   0x4680             MOV      R8,R0
   \       0x30   0xEA5F 0x78D8      LSRS     R8,R8,#+31
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x3A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_ne(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_ne: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0038             MOVS     R0,R7
   \        0x8   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xC   0x0005             MOVS     R5,R0
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x14   0x0006             MOVS     R6,R0
   \       0x16   0x406E             EORS     R6,R6,R5
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_ct_size_if_else_0(uint32_t, size_t)
   \                     mbedtls_ct_size_if_else_0: (+1)
   \        0x0   0x4008             ANDS     R0,R1,R0
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_eq(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_eq: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0021             MOVS     R1,R4
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_ct_uint_ne
   \        0xE   0x43C0             MVNS     R0,R0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_ge(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_ge: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0021             MOVS     R1,R4
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_ct_uint_lt
   \        0xE   0x43C0             MVNS     R0,R0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool_and(uint32_t, uint32_t)
   \                     mbedtls_ct_bool_and: (+1)
   \        0x0   0x4008             ANDS     R0,R1,R0
   \        0x2   0x4770             BX       LR
     38          #include "mbedtls/constant_time.h"
     39          
     40          #include <string.h>
     41          
     42          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     43          #include "psa_util_internal.h"
     44          #include "psa/crypto.h"
     45          #endif
     46          
     47          #if defined(MBEDTLS_X509_CRT_PARSE_C)
     48          #include "mbedtls/oid.h"
     49          #endif
     50          
     51          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     52          /* Define a local translating function to save code size by not using too many
     53           * arguments in each translating place. */

   \                                 In section .text, align 2, keep-with-next
     54          static int local_err_translation(psa_status_t status)
     55          {
   \                     local_err_translation: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     56              return psa_status_to_mbedtls(status, psa_to_ssl_errors,
     57                                           ARRAY_LENGTH(psa_to_ssl_errors),
     58                                           psa_generic_status_to_mbedtls);
   \        0x4   0x.... 0x....      LDR.W    R3,??DataTable6_1
   \        0x8   0x2207             MOVS     R2,#+7
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       psa_status_to_mbedtls
   \       0x14   0xBD10             POP      {R4,PC}
     59          }
     60          #define PSA_TO_MBEDTLS_ERR(status) local_err_translation(status)
     61          #endif
     62          
     63          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
     64          
     65          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     66          
     67          #if defined(PSA_WANT_ALG_SHA_384)
     68          #define MAX_HASH_BLOCK_LENGTH PSA_HASH_BLOCK_LENGTH(PSA_ALG_SHA_384)
     69          #elif defined(PSA_WANT_ALG_SHA_256)
     70          #define MAX_HASH_BLOCK_LENGTH PSA_HASH_BLOCK_LENGTH(PSA_ALG_SHA_256)
     71          #else /* See check_config.h */
     72          #define MAX_HASH_BLOCK_LENGTH PSA_HASH_BLOCK_LENGTH(PSA_ALG_SHA_1)
     73          #endif
     74          

   \                                 In section .text, align 2, keep-with-next
     75          MBEDTLS_STATIC_TESTABLE
     76          int mbedtls_ct_hmac(mbedtls_svc_key_id_t key,
     77                              psa_algorithm_t mac_alg,
     78                              const unsigned char *add_data,
     79                              size_t add_data_len,
     80                              const unsigned char *data,
     81                              size_t data_len_secret,
     82                              size_t min_data_len,
     83                              size_t max_data_len,
     84                              unsigned char *output)
     85          {
   \                     mbedtls_ct_hmac: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xF5AD 0x7D0D      SUB      SP,SP,#+564
   \        0x8   0xF8DD 0x9274      LDR      R9,[SP, #+628]
   \        0xC   0x9D9E             LDR      R5,[SP, #+632]
     86              /*
     87               * This function breaks the HMAC abstraction and uses psa_hash_clone()
     88               * extension in order to get constant-flow behaviour.
     89               *
     90               * HMAC(msg) is defined as HASH(okey + HASH(ikey + msg)) where + means
     91               * concatenation, and okey/ikey are the XOR of the key with some fixed bit
     92               * patterns (see RFC 2104, sec. 2).
     93               *
     94               * We'll first compute ikey/okey, then inner_hash = HASH(ikey + msg) by
     95               * hashing up to minlen, then cloning the context, and for each byte up
     96               * to maxlen finishing up the hash computation, keeping only the
     97               * correct result.
     98               *
     99               * Then we only need to compute HASH(okey + inner_hash) and we're done.
    100               */
    101              psa_algorithm_t hash_alg = PSA_ALG_HMAC_GET_HASH(mac_alg);
   \        0xE   0x9E8E             LDR      R6,[SP, #+568]
   \       0x10   0xF006 0x06FF      AND      R6,R6,#0xFF
   \       0x14   0xF056 0x7600      ORRS     R6,R6,#0x2000000
    102              const size_t block_size = PSA_HASH_BLOCK_LENGTH(hash_alg);
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x1C   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x20   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x24   0x4281             CMP      R1,R0
   \       0x26   0xD101             BNE.N    ??mbedtls_ct_hmac_0
   \       0x28   0x2740             MOVS     R7,#+64
   \       0x2A   0xE078             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_0: (+1)
   \       0x2C   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0x30   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \       0x38   0x428A             CMP      R2,R1
   \       0x3A   0xD101             BNE.N    ??mbedtls_ct_hmac_2
   \       0x3C   0x2740             MOVS     R7,#+64
   \       0x3E   0xE06E             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_2: (+1)
   \       0x40   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0x44   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0x4C   0x428A             CMP      R2,R1
   \       0x4E   0xD101             BNE.N    ??mbedtls_ct_hmac_3
   \       0x50   0x2740             MOVS     R7,#+64
   \       0x52   0xE064             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_3: (+1)
   \       0x54   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0x58   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x5C   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \       0x60   0x428A             CMP      R2,R1
   \       0x62   0xD101             BNE.N    ??mbedtls_ct_hmac_4
   \       0x64   0x2740             MOVS     R7,#+64
   \       0x66   0xE05A             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_4: (+1)
   \       0x68   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0x6C   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x70   0x.... 0x....      LDR.W    R1,??DataTable6_7
   \       0x74   0x428A             CMP      R2,R1
   \       0x76   0xD101             BNE.N    ??mbedtls_ct_hmac_5
   \       0x78   0x2740             MOVS     R7,#+64
   \       0x7A   0xE050             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_5: (+1)
   \       0x7C   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0x80   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x84   0x.... 0x....      LDR.W    R1,??DataTable6_8
   \       0x88   0x428A             CMP      R2,R1
   \       0x8A   0xD101             BNE.N    ??mbedtls_ct_hmac_6
   \       0x8C   0x2780             MOVS     R7,#+128
   \       0x8E   0xE046             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_6: (+1)
   \       0x90   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0x94   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x98   0x.... 0x....      LDR.W    R1,??DataTable6_9
   \       0x9C   0x428A             CMP      R2,R1
   \       0x9E   0xD101             BNE.N    ??mbedtls_ct_hmac_7
   \       0xA0   0x2780             MOVS     R7,#+128
   \       0xA2   0xE03C             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_7: (+1)
   \       0xA4   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xA8   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xAC   0x.... 0x....      LDR.W    R2,??DataTable7
   \       0xB0   0x4291             CMP      R1,R2
   \       0xB2   0xD101             BNE.N    ??mbedtls_ct_hmac_8
   \       0xB4   0x2780             MOVS     R7,#+128
   \       0xB6   0xE032             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_8: (+1)
   \       0xB8   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0xBC   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xC0   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \       0xC4   0x428A             CMP      R2,R1
   \       0xC6   0xD101             BNE.N    ??mbedtls_ct_hmac_9
   \       0xC8   0x2780             MOVS     R7,#+128
   \       0xCA   0xE028             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_9: (+1)
   \       0xCC   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0xD0   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xD4   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \       0xD8   0x428A             CMP      R2,R1
   \       0xDA   0xD101             BNE.N    ??mbedtls_ct_hmac_10
   \       0xDC   0x2790             MOVS     R7,#+144
   \       0xDE   0xE01E             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_10: (+1)
   \       0xE0   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0xE4   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xE8   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \       0xEC   0x428A             CMP      R2,R1
   \       0xEE   0xD101             BNE.N    ??mbedtls_ct_hmac_11
   \       0xF0   0x2788             MOVS     R7,#+136
   \       0xF2   0xE014             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_11: (+1)
   \       0xF4   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0xF8   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xFC   0x.... 0x....      LDR.W    R1,??DataTable7_4
   \      0x100   0x428A             CMP      R2,R1
   \      0x102   0xD101             BNE.N    ??mbedtls_ct_hmac_12
   \      0x104   0x2768             MOVS     R7,#+104
   \      0x106   0xE00A             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_12: (+1)
   \      0x108   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x10C   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x110   0x.... 0x....      LDR.W    R1,??DataTable7_5
   \      0x114   0x428A             CMP      R2,R1
   \      0x116   0xD101             BNE.N    ??mbedtls_ct_hmac_13
   \      0x118   0x2748             MOVS     R7,#+72
   \      0x11A   0xE000             B.N      ??mbedtls_ct_hmac_1
   \                     ??mbedtls_ct_hmac_13: (+1)
   \      0x11C   0x2700             MOVS     R7,#+0
    103              unsigned char key_buf[MAX_HASH_BLOCK_LENGTH];
    104              const size_t hash_size = PSA_HASH_LENGTH(hash_alg);
   \                     ??mbedtls_ct_hmac_1: (+1)
   \      0x11E   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x122   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x126   0x4281             CMP      R1,R0
   \      0x128   0xD102             BNE.N    ??mbedtls_ct_hmac_14
   \      0x12A   0xF05F 0x0810      MOVS     R8,#+16
   \      0x12E   0xE085             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_14: (+1)
   \      0x130   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x134   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x138   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \      0x13C   0x4281             CMP      R1,R0
   \      0x13E   0xD102             BNE.N    ??mbedtls_ct_hmac_16
   \      0x140   0xF05F 0x0814      MOVS     R8,#+20
   \      0x144   0xE07A             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_16: (+1)
   \      0x146   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x14A   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x14E   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \      0x152   0x4281             CMP      R1,R0
   \      0x154   0xD102             BNE.N    ??mbedtls_ct_hmac_17
   \      0x156   0xF05F 0x0814      MOVS     R8,#+20
   \      0x15A   0xE06F             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_17: (+1)
   \      0x15C   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x160   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x164   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \      0x168   0x4281             CMP      R1,R0
   \      0x16A   0xD102             BNE.N    ??mbedtls_ct_hmac_18
   \      0x16C   0xF05F 0x081C      MOVS     R8,#+28
   \      0x170   0xE064             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_18: (+1)
   \      0x172   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x176   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x17A   0x.... 0x....      LDR.W    R0,??DataTable6_7
   \      0x17E   0x4281             CMP      R1,R0
   \      0x180   0xD102             BNE.N    ??mbedtls_ct_hmac_19
   \      0x182   0xF05F 0x0820      MOVS     R8,#+32
   \      0x186   0xE059             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_19: (+1)
   \      0x188   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x18C   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x190   0x.... 0x....      LDR.W    R0,??DataTable6_8
   \      0x194   0x4281             CMP      R1,R0
   \      0x196   0xD102             BNE.N    ??mbedtls_ct_hmac_20
   \      0x198   0xF05F 0x0830      MOVS     R8,#+48
   \      0x19C   0xE04E             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_20: (+1)
   \      0x19E   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x1A2   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x1A6   0x.... 0x....      LDR.W    R0,??DataTable6_9
   \      0x1AA   0x4281             CMP      R1,R0
   \      0x1AC   0xD102             BNE.N    ??mbedtls_ct_hmac_21
   \      0x1AE   0xF05F 0x0840      MOVS     R8,#+64
   \      0x1B2   0xE043             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_21: (+1)
   \      0x1B4   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x1B8   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x1BC   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x1C0   0x4281             CMP      R1,R0
   \      0x1C2   0xD102             BNE.N    ??mbedtls_ct_hmac_22
   \      0x1C4   0xF05F 0x081C      MOVS     R8,#+28
   \      0x1C8   0xE038             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_22: (+1)
   \      0x1CA   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x1CE   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x1D2   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \      0x1D6   0x4281             CMP      R1,R0
   \      0x1D8   0xD102             BNE.N    ??mbedtls_ct_hmac_23
   \      0x1DA   0xF05F 0x0820      MOVS     R8,#+32
   \      0x1DE   0xE02D             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_23: (+1)
   \      0x1E0   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x1E4   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x1E8   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \      0x1EC   0x4281             CMP      R1,R0
   \      0x1EE   0xD102             BNE.N    ??mbedtls_ct_hmac_24
   \      0x1F0   0xF05F 0x081C      MOVS     R8,#+28
   \      0x1F4   0xE022             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_24: (+1)
   \      0x1F6   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x1FA   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x1FE   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \      0x202   0x4281             CMP      R1,R0
   \      0x204   0xD102             BNE.N    ??mbedtls_ct_hmac_25
   \      0x206   0xF05F 0x0820      MOVS     R8,#+32
   \      0x20A   0xE017             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_25: (+1)
   \      0x20C   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x210   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x214   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \      0x218   0x4281             CMP      R1,R0
   \      0x21A   0xD102             BNE.N    ??mbedtls_ct_hmac_26
   \      0x21C   0xF05F 0x0830      MOVS     R8,#+48
   \      0x220   0xE00C             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_26: (+1)
   \      0x222   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x226   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x22A   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x22E   0x4281             CMP      R1,R0
   \      0x230   0xD102             BNE.N    ??mbedtls_ct_hmac_27
   \      0x232   0xF05F 0x0840      MOVS     R8,#+64
   \      0x236   0xE001             B.N      ??mbedtls_ct_hmac_15
   \                     ??mbedtls_ct_hmac_27: (+1)
   \      0x238   0xF05F 0x0800      MOVS     R8,#+0
    105              psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;
   \                     ??mbedtls_ct_hmac_15: (+1)
   \      0x23C   0xA855             ADD      R0,SP,#+340
   \      0x23E   0x21E0             MOVS     R1,#+224
   \      0x240   0x.... 0x....      BL       __aeabi_memclr4
    106              size_t hash_length;
    107          
    108              unsigned char aux_out[PSA_HASH_MAX_SIZE];
    109              psa_hash_operation_t aux_operation = PSA_HASH_OPERATION_INIT;
   \      0x244   0xA81D             ADD      R0,SP,#+116
   \      0x246   0x21E0             MOVS     R1,#+224
   \      0x248   0x.... 0x....      BL       __aeabi_memclr4
    110              size_t offset;
    111              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \      0x24C   0xF07F 0x0096      MVNS     R0,#+150
   \      0x250   0x9000             STR      R0,[SP, #+0]
    112          
    113              size_t mac_key_length;
    114              size_t i;
    115          
    116          #define PSA_CHK(func_call)        \
    117              do {                            \
    118                  status = (func_call);       \
    119                  if (status != PSA_SUCCESS) \
    120                  goto cleanup;           \
    121              } while (0)
    122          
    123              /* Export MAC key
    124               * We assume key length is always exactly the output size
    125               * which is never more than the block size, thus we use block_size
    126               * as the key buffer size.
    127               */
    128              PSA_CHK(psa_export_key(key, key_buf, block_size, &mac_key_length));
   \      0x252   0xAB01             ADD      R3,SP,#+4
   \      0x254   0x003A             MOVS     R2,R7
   \      0x256   0xA90D             ADD      R1,SP,#+52
   \      0x258   0x988D             LDR      R0,[SP, #+564]
   \      0x25A   0x.... 0x....      BL       psa_export_key
   \      0x25E   0x0004             MOVS     R4,R0
   \      0x260   0x2C00             CMP      R4,#+0
   \      0x262   0xF040 0x80B1      BNE.W    ??mbedtls_ct_hmac_28
    129          
    130              /* Calculate ikey */
    131              for (i = 0; i < mac_key_length; i++) {
   \                     ??mbedtls_ct_hmac_29: (+1)
   \      0x266   0x2000             MOVS     R0,#+0
   \      0x268   0x4682             MOV      R10,R0
   \                     ??mbedtls_ct_hmac_30: (+1)
   \      0x26A   0x9801             LDR      R0,[SP, #+4]
   \      0x26C   0x4582             CMP      R10,R0
   \      0x26E   0xD209             BCS.N    ??mbedtls_ct_hmac_31
    132                  key_buf[i] = (unsigned char) (key_buf[i] ^ 0x36);
   \      0x270   0xA90D             ADD      R1,SP,#+52
   \      0x272   0xF811 0x000A      LDRB     R0,[R1, R10]
   \      0x276   0xF090 0x0036      EORS     R0,R0,#0x36
   \      0x27A   0xF801 0x000A      STRB     R0,[R1, R10]
    133              }
   \      0x27E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x282   0xE7F2             B.N      ??mbedtls_ct_hmac_30
    134              for (; i < block_size; ++i) {
   \                     ??mbedtls_ct_hmac_31: (+1)
   \      0x284   0x45BA             CMP      R10,R7
   \      0x286   0xD206             BCS.N    ??mbedtls_ct_hmac_32
    135                  key_buf[i] = 0x36;
   \      0x288   0x2136             MOVS     R1,#+54
   \      0x28A   0xA80D             ADD      R0,SP,#+52
   \      0x28C   0xF800 0x100A      STRB     R1,[R0, R10]
    136              }
   \      0x290   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x294   0xE7F6             B.N      ??mbedtls_ct_hmac_31
    137          
    138              PSA_CHK(psa_hash_setup(&operation, hash_alg));
   \                     ??mbedtls_ct_hmac_32: (+1)
   \      0x296   0x0031             MOVS     R1,R6
   \      0x298   0xA855             ADD      R0,SP,#+340
   \      0x29A   0x.... 0x....      BL       psa_hash_setup
   \      0x29E   0x0004             MOVS     R4,R0
   \      0x2A0   0x2C00             CMP      R4,#+0
   \      0x2A2   0xF040 0x8091      BNE.W    ??mbedtls_ct_hmac_28
    139          
    140              /* Now compute inner_hash = HASH(ikey + msg) */
    141              PSA_CHK(psa_hash_update(&operation, key_buf, block_size));
   \                     ??mbedtls_ct_hmac_33: (+1)
   \      0x2A6   0x003A             MOVS     R2,R7
   \      0x2A8   0xA90D             ADD      R1,SP,#+52
   \      0x2AA   0xA855             ADD      R0,SP,#+340
   \      0x2AC   0x.... 0x....      BL       psa_hash_update
   \      0x2B0   0x0004             MOVS     R4,R0
   \      0x2B2   0x2C00             CMP      R4,#+0
   \      0x2B4   0xF040 0x8088      BNE.W    ??mbedtls_ct_hmac_28
    142              PSA_CHK(psa_hash_update(&operation, add_data, add_data_len));
   \                     ??mbedtls_ct_hmac_34: (+1)
   \      0x2B8   0x9A90             LDR      R2,[SP, #+576]
   \      0x2BA   0x998F             LDR      R1,[SP, #+572]
   \      0x2BC   0xA855             ADD      R0,SP,#+340
   \      0x2BE   0x.... 0x....      BL       psa_hash_update
   \      0x2C2   0x0004             MOVS     R4,R0
   \      0x2C4   0x2C00             CMP      R4,#+0
   \      0x2C6   0xF040 0x807F      BNE.W    ??mbedtls_ct_hmac_28
    143              PSA_CHK(psa_hash_update(&operation, data, min_data_len));
   \                     ??mbedtls_ct_hmac_35: (+1)
   \      0x2CA   0x9A9C             LDR      R2,[SP, #+624]
   \      0x2CC   0x999A             LDR      R1,[SP, #+616]
   \      0x2CE   0xA855             ADD      R0,SP,#+340
   \      0x2D0   0x.... 0x....      BL       psa_hash_update
   \      0x2D4   0x0004             MOVS     R4,R0
   \      0x2D6   0x2C00             CMP      R4,#+0
   \      0x2D8   0xD176             BNE.N    ??mbedtls_ct_hmac_28
    144          
    145              /* Fill the hash buffer in advance with something that is
    146               * not a valid hash (barring an attack on the hash and
    147               * deliberately-crafted input), in case the caller doesn't
    148               * check the return status properly. */
    149              memset(output, '!', hash_size);
   \                     ??mbedtls_ct_hmac_36: (+1)
   \      0x2DA   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \      0x2DE   0x2021             MOVS     R0,#+33
   \      0x2E0   0x9003             STR      R0,[SP, #+12]
   \      0x2E2   0x9500             STR      R5,[SP, #+0]
   \      0x2E4   0x9A03             LDR      R2,[SP, #+12]
   \      0x2E6   0x9904             LDR      R1,[SP, #+16]
   \      0x2E8   0x9800             LDR      R0,[SP, #+0]
   \      0x2EA   0x.... 0x....      BL       __aeabi_memset
   \      0x2EE   0x9800             LDR      R0,[SP, #+0]
    150          
    151              /* For each possible length, compute the hash up to that point */
    152              for (offset = min_data_len; offset <= max_data_len; offset++) {
   \      0x2F0   0x989C             LDR      R0,[SP, #+624]
   \      0x2F2   0x4683             MOV      R11,R0
   \                     ??mbedtls_ct_hmac_37: (+1)
   \      0x2F4   0x45D9             CMP      R9,R11
   \      0x2F6   0xD329             BCC.N    ??mbedtls_ct_hmac_38
    153                  PSA_CHK(psa_hash_clone(&operation, &aux_operation));
   \      0x2F8   0xA91D             ADD      R1,SP,#+116
   \      0x2FA   0xA855             ADD      R0,SP,#+340
   \      0x2FC   0x.... 0x....      BL       psa_hash_clone
   \      0x300   0x0004             MOVS     R4,R0
   \      0x302   0x2C00             CMP      R4,#+0
   \      0x304   0xD160             BNE.N    ??mbedtls_ct_hmac_28
    154                  PSA_CHK(psa_hash_finish(&aux_operation, aux_out,
    155                                          PSA_HASH_MAX_SIZE, &hash_length));
   \                     ??mbedtls_ct_hmac_39: (+1)
   \      0x306   0xAB02             ADD      R3,SP,#+8
   \      0x308   0x2220             MOVS     R2,#+32
   \      0x30A   0xA905             ADD      R1,SP,#+20
   \      0x30C   0xA81D             ADD      R0,SP,#+116
   \      0x30E   0x.... 0x....      BL       psa_hash_finish
   \      0x312   0x0004             MOVS     R4,R0
   \      0x314   0x2C00             CMP      R4,#+0
   \      0x316   0xD157             BNE.N    ??mbedtls_ct_hmac_28
    156                  /* Keep only the correct inner_hash in the output buffer */
    157                  mbedtls_ct_memcpy_if(mbedtls_ct_uint_eq(offset, data_len_secret),
    158                                       output, aux_out, NULL, hash_size);
   \                     ??mbedtls_ct_hmac_40: (+1)
   \      0x318   0x999B             LDR      R1,[SP, #+620]
   \      0x31A   0x4658             MOV      R0,R11
   \      0x31C   0x.... 0x....      BL       mbedtls_ct_uint_eq
   \      0x320   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x324   0x2300             MOVS     R3,#+0
   \      0x326   0xAA05             ADD      R2,SP,#+20
   \      0x328   0x0029             MOVS     R1,R5
   \      0x32A   0x.... 0x....      BL       mbedtls_ct_memcpy_if
    159          
    160                  if (offset < max_data_len) {
   \      0x32E   0x45CB             CMP      R11,R9
   \      0x330   0xD209             BCS.N    ??mbedtls_ct_hmac_41
    161                      PSA_CHK(psa_hash_update(&operation, data + offset, 1));
   \      0x332   0x2201             MOVS     R2,#+1
   \      0x334   0x989A             LDR      R0,[SP, #+616]
   \      0x336   0xEB00 0x010B      ADD      R1,R0,R11
   \      0x33A   0xA855             ADD      R0,SP,#+340
   \      0x33C   0x.... 0x....      BL       psa_hash_update
   \      0x340   0x0004             MOVS     R4,R0
   \      0x342   0x2C00             CMP      R4,#+0
   \      0x344   0xD140             BNE.N    ??mbedtls_ct_hmac_28
    162                  }
    163              }
   \                     ??mbedtls_ct_hmac_42: (+1)
   \                     ??mbedtls_ct_hmac_41: (+1)
   \      0x346   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \      0x34A   0xE7D3             B.N      ??mbedtls_ct_hmac_37
    164          
    165              /* Abort current operation to prepare for final operation */
    166              PSA_CHK(psa_hash_abort(&operation));
   \                     ??mbedtls_ct_hmac_38: (+1)
   \      0x34C   0xA855             ADD      R0,SP,#+340
   \      0x34E   0x.... 0x....      BL       psa_hash_abort
   \      0x352   0x0004             MOVS     R4,R0
   \      0x354   0x2C00             CMP      R4,#+0
   \      0x356   0xD137             BNE.N    ??mbedtls_ct_hmac_28
    167          
    168              /* Calculate okey */
    169              for (i = 0; i < mac_key_length; i++) {
   \                     ??mbedtls_ct_hmac_43: (+1)
   \      0x358   0x2000             MOVS     R0,#+0
   \      0x35A   0x4682             MOV      R10,R0
   \                     ??mbedtls_ct_hmac_44: (+1)
   \      0x35C   0x9801             LDR      R0,[SP, #+4]
   \      0x35E   0x4582             CMP      R10,R0
   \      0x360   0xD209             BCS.N    ??mbedtls_ct_hmac_45
    170                  key_buf[i] = (unsigned char) ((key_buf[i] ^ 0x36) ^ 0x5C);
   \      0x362   0xA90D             ADD      R1,SP,#+52
   \      0x364   0xF811 0x000A      LDRB     R0,[R1, R10]
   \      0x368   0xF090 0x006A      EORS     R0,R0,#0x6A
   \      0x36C   0xF801 0x000A      STRB     R0,[R1, R10]
    171              }
   \      0x370   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x374   0xE7F2             B.N      ??mbedtls_ct_hmac_44
    172              for (; i < block_size; ++i) {
   \                     ??mbedtls_ct_hmac_45: (+1)
   \      0x376   0x45BA             CMP      R10,R7
   \      0x378   0xD206             BCS.N    ??mbedtls_ct_hmac_46
    173                  key_buf[i] = 0x5C;
   \      0x37A   0x205C             MOVS     R0,#+92
   \      0x37C   0xA90D             ADD      R1,SP,#+52
   \      0x37E   0xF801 0x000A      STRB     R0,[R1, R10]
    174              }
   \      0x382   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x386   0xE7F6             B.N      ??mbedtls_ct_hmac_45
    175          
    176              /* Now compute HASH(okey + inner_hash) */
    177              PSA_CHK(psa_hash_setup(&operation, hash_alg));
   \                     ??mbedtls_ct_hmac_46: (+1)
   \      0x388   0x0031             MOVS     R1,R6
   \      0x38A   0xA855             ADD      R0,SP,#+340
   \      0x38C   0x.... 0x....      BL       psa_hash_setup
   \      0x390   0x0004             MOVS     R4,R0
   \      0x392   0x2C00             CMP      R4,#+0
   \      0x394   0xD118             BNE.N    ??mbedtls_ct_hmac_28
    178              PSA_CHK(psa_hash_update(&operation, key_buf, block_size));
   \                     ??mbedtls_ct_hmac_47: (+1)
   \      0x396   0x003A             MOVS     R2,R7
   \      0x398   0xA90D             ADD      R1,SP,#+52
   \      0x39A   0xA855             ADD      R0,SP,#+340
   \      0x39C   0x.... 0x....      BL       psa_hash_update
   \      0x3A0   0x0004             MOVS     R4,R0
   \      0x3A2   0x2C00             CMP      R4,#+0
   \      0x3A4   0xD110             BNE.N    ??mbedtls_ct_hmac_28
    179              PSA_CHK(psa_hash_update(&operation, output, hash_size));
   \                     ??mbedtls_ct_hmac_48: (+1)
   \      0x3A6   0x4642             MOV      R2,R8
   \      0x3A8   0x0029             MOVS     R1,R5
   \      0x3AA   0xA855             ADD      R0,SP,#+340
   \      0x3AC   0x.... 0x....      BL       psa_hash_update
   \      0x3B0   0x0004             MOVS     R4,R0
   \      0x3B2   0x2C00             CMP      R4,#+0
   \      0x3B4   0xD108             BNE.N    ??mbedtls_ct_hmac_28
    180              PSA_CHK(psa_hash_finish(&operation, output, hash_size, &hash_length));
   \                     ??mbedtls_ct_hmac_49: (+1)
   \      0x3B6   0xAB02             ADD      R3,SP,#+8
   \      0x3B8   0x4642             MOV      R2,R8
   \      0x3BA   0x0029             MOVS     R1,R5
   \      0x3BC   0xA855             ADD      R0,SP,#+340
   \      0x3BE   0x.... 0x....      BL       psa_hash_finish
   \      0x3C2   0x0004             MOVS     R4,R0
   \      0x3C4   0x2C00             CMP      R4,#+0
   \      0x3C6   0xD1FF             BNE.N    ??mbedtls_ct_hmac_28
    181          
    182          #undef PSA_CHK
    183          
    184          cleanup:
    185              mbedtls_platform_zeroize(key_buf, MAX_HASH_BLOCK_LENGTH);
   \                     ??mbedtls_ct_hmac_50: (+1)
   \                     ??mbedtls_ct_hmac_28: (+1)
   \      0x3C8   0x2140             MOVS     R1,#+64
   \      0x3CA   0xA80D             ADD      R0,SP,#+52
   \      0x3CC   0x.... 0x....      BL       mbedtls_platform_zeroize
    186              mbedtls_platform_zeroize(aux_out, PSA_HASH_MAX_SIZE);
   \      0x3D0   0x2120             MOVS     R1,#+32
   \      0x3D2   0xA805             ADD      R0,SP,#+20
   \      0x3D4   0x.... 0x....      BL       mbedtls_platform_zeroize
    187          
    188              psa_hash_abort(&operation);
   \      0x3D8   0xA855             ADD      R0,SP,#+340
   \      0x3DA   0x.... 0x....      BL       psa_hash_abort
    189              psa_hash_abort(&aux_operation);
   \      0x3DE   0xA81D             ADD      R0,SP,#+116
   \      0x3E0   0x.... 0x....      BL       psa_hash_abort
    190              return PSA_TO_MBEDTLS_ERR(status);
   \      0x3E4   0x0020             MOVS     R0,R4
   \      0x3E6   0x.... 0x....      BL       local_err_translation
   \      0x3EA   0xF50D 0x7D11      ADD      SP,SP,#+580
   \      0x3EE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    191          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0
   \              0x0000'0000
   \        0x8                      DS8 216

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0
   \              0x0000'0000
   \        0x8                      DS8 216
    192          
    193          #undef MAX_HASH_BLOCK_LENGTH
    194          
    195          #else
    196          MBEDTLS_STATIC_TESTABLE
    197          int mbedtls_ct_hmac(mbedtls_md_context_t *ctx,
    198                              const unsigned char *add_data,
    199                              size_t add_data_len,
    200                              const unsigned char *data,
    201                              size_t data_len_secret,
    202                              size_t min_data_len,
    203                              size_t max_data_len,
    204                              unsigned char *output)
    205          {
    206              /*
    207               * This function breaks the HMAC abstraction and uses the md_clone()
    208               * extension to the MD API in order to get constant-flow behaviour.
    209               *
    210               * HMAC(msg) is defined as HASH(okey + HASH(ikey + msg)) where + means
    211               * concatenation, and okey/ikey are the XOR of the key with some fixed bit
    212               * patterns (see RFC 2104, sec. 2), which are stored in ctx->hmac_ctx.
    213               *
    214               * We'll first compute inner_hash = HASH(ikey + msg) by hashing up to
    215               * minlen, then cloning the context, and for each byte up to maxlen
    216               * finishing up the hash computation, keeping only the correct result.
    217               *
    218               * Then we only need to compute HASH(okey + inner_hash) and we're done.
    219               */
    220              const mbedtls_md_type_t md_alg = mbedtls_md_get_type(ctx->md_info);
    221              /* TLS 1.2 only supports SHA-384, SHA-256, SHA-1, MD-5,
    222               * all of which have the same block size except SHA-384. */
    223              const size_t block_size = md_alg == MBEDTLS_MD_SHA384 ? 128 : 64;
    224              const unsigned char * const ikey = ctx->hmac_ctx;
    225              const unsigned char * const okey = ikey + block_size;
    226              const size_t hash_size = mbedtls_md_get_size(ctx->md_info);
    227          
    228              unsigned char aux_out[MBEDTLS_MD_MAX_SIZE];
    229              mbedtls_md_context_t aux;
    230              size_t offset;
    231              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    232          
    233              mbedtls_md_init(&aux);
    234          
    235          #define MD_CHK(func_call) \
    236              do {                    \
    237                  ret = (func_call);  \
    238                  if (ret != 0)      \
    239                  goto cleanup;   \
    240              } while (0)
    241          
    242              MD_CHK(mbedtls_md_setup(&aux, ctx->md_info, 0));
    243          
    244              /* After hmac_start() of hmac_reset(), ikey has already been hashed,
    245               * so we can start directly with the message */
    246              MD_CHK(mbedtls_md_update(ctx, add_data, add_data_len));
    247              MD_CHK(mbedtls_md_update(ctx, data, min_data_len));
    248          
    249              /* Fill the hash buffer in advance with something that is
    250               * not a valid hash (barring an attack on the hash and
    251               * deliberately-crafted input), in case the caller doesn't
    252               * check the return status properly. */
    253              memset(output, '!', hash_size);
    254          
    255              /* For each possible length, compute the hash up to that point */
    256              for (offset = min_data_len; offset <= max_data_len; offset++) {
    257                  MD_CHK(mbedtls_md_clone(&aux, ctx));
    258                  MD_CHK(mbedtls_md_finish(&aux, aux_out));
    259                  /* Keep only the correct inner_hash in the output buffer */
    260                  mbedtls_ct_memcpy_if(mbedtls_ct_uint_eq(offset, data_len_secret),
    261                                       output, aux_out, NULL, hash_size);
    262          
    263                  if (offset < max_data_len) {
    264                      MD_CHK(mbedtls_md_update(ctx, data + offset, 1));
    265                  }
    266              }
    267          
    268              /* The context needs to finish() before it starts() again */
    269              MD_CHK(mbedtls_md_finish(ctx, aux_out));
    270          
    271              /* Now compute HASH(okey + inner_hash) */
    272              MD_CHK(mbedtls_md_starts(ctx));
    273              MD_CHK(mbedtls_md_update(ctx, okey, block_size));
    274              MD_CHK(mbedtls_md_update(ctx, output, hash_size));
    275              MD_CHK(mbedtls_md_finish(ctx, output));
    276          
    277              /* Done, get ready for next time */
    278              MD_CHK(mbedtls_md_hmac_reset(ctx));
    279          
    280          #undef MD_CHK
    281          
    282          cleanup:
    283              mbedtls_md_free(&aux);
    284              return ret;
    285          }
    286          
    287          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    288          
    289          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_MAC */
    290          
    291          static uint32_t ssl_get_hs_total_len(mbedtls_ssl_context const *ssl);
    292          
    293          /*
    294           * Start a timer.
    295           * Passing millisecs = 0 cancels a running timer.
    296           */

   \                                 In section .text, align 2, keep-with-next
    297          void mbedtls_ssl_set_timer(mbedtls_ssl_context *ssl, uint32_t millisecs)
    298          {
   \                     mbedtls_ssl_set_timer: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    299              if (ssl->f_set_timer == NULL) {
   \        0x6   0x6D20             LDR      R0,[R4, #+80]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD005             BEQ.N    ??mbedtls_ssl_set_timer_0
    300                  return;
    301              }
    302          
    303              MBEDTLS_SSL_DEBUG_MSG(3, ("set_timer to %d ms", (int) millisecs));
    304              ssl->f_set_timer(ssl->p_timer, millisecs / 4, millisecs);
   \                     ??mbedtls_ssl_set_timer_1: (+1)
   \        0xC   0x002A             MOVS     R2,R5
   \        0xE   0x0029             MOVS     R1,R5
   \       0x10   0x0889             LSRS     R1,R1,#+2
   \       0x12   0x6CE0             LDR      R0,[R4, #+76]
   \       0x14   0x6D23             LDR      R3,[R4, #+80]
   \       0x16   0x4798             BLX      R3
    305          }
   \                     ??mbedtls_ssl_set_timer_0: (+1)
   \       0x18   0xBD31             POP      {R0,R4,R5,PC}
    306          
    307          /*
    308           * Return -1 is timer is expired, 0 if it isn't.
    309           */

   \                                 In section .text, align 2, keep-with-next
    310          int mbedtls_ssl_check_timer(mbedtls_ssl_context *ssl)
    311          {
   \                     mbedtls_ssl_check_timer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    312              if (ssl->f_get_timer == NULL) {
   \        0x4   0x6D60             LDR      R0,[R4, #+84]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD101             BNE.N    ??mbedtls_ssl_check_timer_0
    313                  return 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE008             B.N      ??mbedtls_ssl_check_timer_1
    314              }
    315          
    316              if (ssl->f_get_timer(ssl->p_timer) == 2) {
   \                     ??mbedtls_ssl_check_timer_0: (+1)
   \        0xE   0x6CE0             LDR      R0,[R4, #+76]
   \       0x10   0x6D61             LDR      R1,[R4, #+84]
   \       0x12   0x4788             BLX      R1
   \       0x14   0x2802             CMP      R0,#+2
   \       0x16   0xD102             BNE.N    ??mbedtls_ssl_check_timer_2
    317                  MBEDTLS_SSL_DEBUG_MSG(3, ("timer expired"));
    318                  return -1;
   \       0x18   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1C   0xE000             B.N      ??mbedtls_ssl_check_timer_1
    319              }
    320          
    321              return 0;
   \                     ??mbedtls_ssl_check_timer_2: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_check_timer_1: (+1)
   \       0x20   0xBD10             POP      {R4,PC}
    322          }
    323          
    324          MBEDTLS_CHECK_RETURN_CRITICAL
    325          static int ssl_parse_record_header(mbedtls_ssl_context const *ssl,
    326                                             unsigned char *buf,
    327                                             size_t len,
    328                                             mbedtls_record *rec);
    329          

   \                                 In section .text, align 2, keep-with-next
    330          int mbedtls_ssl_check_record(mbedtls_ssl_context const *ssl,
    331                                       unsigned char *buf,
    332                                       size_t buflen)
    333          {
   \                     mbedtls_ssl_check_record: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    334              int ret = 0;
   \        0x8   0x2700             MOVS     R7,#+0
    335              MBEDTLS_SSL_DEBUG_MSG(1, ("=> mbedtls_ssl_check_record"));
    336              MBEDTLS_SSL_DEBUG_BUF(3, "record buffer", buf, buflen);
    337          
    338              /* We don't support record checking in TLS because
    339               * there doesn't seem to be a usecase for it.
    340               */
    341              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_STREAM) {
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x7940             LDRB     R0,[R0, #+5]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD102             BNE.N    ??mbedtls_ssl_check_record_0
    342                  ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x16   0x0007             MOVS     R7,R0
    343                  goto exit;
    344              }
    345          #if defined(MBEDTLS_SSL_PROTO_DTLS)
    346              else {
    347                  mbedtls_record rec;
    348          
    349                  ret = ssl_parse_record_header(ssl, buf, buflen, &rec);
    350                  if (ret != 0) {
    351                      MBEDTLS_SSL_DEBUG_RET(3, "ssl_parse_record_header", ret);
    352                      goto exit;
    353                  }
    354          
    355                  if (ssl->transform_in != NULL) {
    356                      ret = mbedtls_ssl_decrypt_buf(ssl, ssl->transform_in, &rec);
    357                      if (ret != 0) {
    358                          MBEDTLS_SSL_DEBUG_RET(3, "mbedtls_ssl_decrypt_buf", ret);
    359                          goto exit;
    360                      }
    361                  }
    362              }
    363          #endif /* MBEDTLS_SSL_PROTO_DTLS */
    364          
    365          exit:
    366              /* On success, we have decrypted the buffer in-place, so make
    367               * sure we don't leak any plaintext data. */
    368              mbedtls_platform_zeroize(buf, buflen);
   \                     ??mbedtls_ssl_check_record_0: (+1)
   \       0x18   0x0031             MOVS     R1,R6
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0x.... 0x....      BL       mbedtls_platform_zeroize
    369          
    370              /* For the purpose of this API, treat messages with unexpected CID
    371               * as well as such from future epochs as unexpected. */
    372              if (ret == MBEDTLS_ERR_SSL_UNEXPECTED_CID ||
    373                  ret == MBEDTLS_ERR_SSL_EARLY_MESSAGE) {
   \       0x20   0xF517 0x4FC0      CMN      R7,#+24576
   \       0x24   0xD002             BEQ.N    ??mbedtls_ssl_check_record_1
   \       0x26   0xF517 0x4FC9      CMN      R7,#+25728
   \       0x2A   0xD102             BNE.N    ??mbedtls_ssl_check_record_2
    374                  ret = MBEDTLS_ERR_SSL_UNEXPECTED_RECORD;
   \                     ??mbedtls_ssl_check_record_1: (+1)
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \       0x30   0x0007             MOVS     R7,R0
    375              }
    376          
    377              MBEDTLS_SSL_DEBUG_MSG(1, ("<= mbedtls_ssl_check_record"));
    378              return ret;
   \                     ??mbedtls_ssl_check_record_2: (+1)
   \       0x32   0x0038             MOVS     R0,R7
   \       0x34   0xBDF2             POP      {R1,R4-R7,PC}
    379          }
    380          
    381          #define SSL_DONT_FORCE_FLUSH 0
    382          #define SSL_FORCE_FLUSH      1
    383          
    384          #if defined(MBEDTLS_SSL_PROTO_DTLS)
    385          
    386          /* Forward declarations for functions related to message buffering. */
    387          static void ssl_buffering_free_slot(mbedtls_ssl_context *ssl,
    388                                              uint8_t slot);
    389          static void ssl_free_buffered_record(mbedtls_ssl_context *ssl);
    390          MBEDTLS_CHECK_RETURN_CRITICAL
    391          static int ssl_load_buffered_message(mbedtls_ssl_context *ssl);
    392          MBEDTLS_CHECK_RETURN_CRITICAL
    393          static int ssl_load_buffered_record(mbedtls_ssl_context *ssl);
    394          MBEDTLS_CHECK_RETURN_CRITICAL
    395          static int ssl_buffer_message(mbedtls_ssl_context *ssl);
    396          MBEDTLS_CHECK_RETURN_CRITICAL
    397          static int ssl_buffer_future_record(mbedtls_ssl_context *ssl,
    398                                              mbedtls_record const *rec);
    399          MBEDTLS_CHECK_RETURN_CRITICAL
    400          static int ssl_next_record_is_in_datagram(mbedtls_ssl_context *ssl);
    401          
    402          static size_t ssl_get_maximum_datagram_size(mbedtls_ssl_context const *ssl)
    403          {
    404              size_t mtu = mbedtls_ssl_get_current_mtu(ssl);
    405          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
    406              size_t out_buf_len = ssl->out_buf_len;
    407          #else
    408              size_t out_buf_len = MBEDTLS_SSL_OUT_BUFFER_LEN;
    409          #endif
    410          
    411              if (mtu != 0 && mtu < out_buf_len) {
    412                  return mtu;
    413              }
    414          
    415              return out_buf_len;
    416          }
    417          
    418          MBEDTLS_CHECK_RETURN_CRITICAL
    419          static int ssl_get_remaining_space_in_datagram(mbedtls_ssl_context const *ssl)
    420          {
    421              size_t const bytes_written = ssl->out_left;
    422              size_t const mtu           = ssl_get_maximum_datagram_size(ssl);
    423          
    424              /* Double-check that the write-index hasn't gone
    425               * past what we can transmit in a single datagram. */
    426              if (bytes_written > mtu) {
    427                  /* Should never happen... */
    428                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
    429              }
    430          
    431              return (int) (mtu - bytes_written);
    432          }
    433          
    434          MBEDTLS_CHECK_RETURN_CRITICAL
    435          static int ssl_get_remaining_payload_in_datagram(mbedtls_ssl_context const *ssl)
    436          {
    437              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    438              size_t remaining, expansion;
    439              size_t max_len = MBEDTLS_SSL_OUT_CONTENT_LEN;
    440          
    441          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    442              const size_t mfl = mbedtls_ssl_get_output_max_frag_len(ssl);
    443          
    444              if (max_len > mfl) {
    445                  max_len = mfl;
    446              }
    447          
    448              /* By the standard (RFC 6066 Sect. 4), the MFL extension
    449               * only limits the maximum record payload size, so in theory
    450               * we would be allowed to pack multiple records of payload size
    451               * MFL into a single datagram. However, this would mean that there's
    452               * no way to explicitly communicate MTU restrictions to the peer.
    453               *
    454               * The following reduction of max_len makes sure that we never
    455               * write datagrams larger than MFL + Record Expansion Overhead.
    456               */
    457              if (max_len <= ssl->out_left) {
    458                  return 0;
    459              }
    460          
    461              max_len -= ssl->out_left;
    462          #endif
    463          
    464              ret = ssl_get_remaining_space_in_datagram(ssl);
    465              if (ret < 0) {
    466                  return ret;
    467              }
    468              remaining = (size_t) ret;
    469          
    470              ret = mbedtls_ssl_get_record_expansion(ssl);
    471              if (ret < 0) {
    472                  return ret;
    473              }
    474              expansion = (size_t) ret;
    475          
    476              if (remaining <= expansion) {
    477                  return 0;
    478              }
    479          
    480              remaining -= expansion;
    481              if (remaining >= max_len) {
    482                  remaining = max_len;
    483              }
    484          
    485              return (int) remaining;
    486          }
    487          
    488          /*
    489           * Double the retransmit timeout value, within the allowed range,
    490           * returning -1 if the maximum value has already been reached.
    491           */
    492          MBEDTLS_CHECK_RETURN_CRITICAL
    493          static int ssl_double_retransmit_timeout(mbedtls_ssl_context *ssl)
    494          {
    495              uint32_t new_timeout;
    496          
    497              if (ssl->handshake->retransmit_timeout >= ssl->conf->hs_timeout_max) {
    498                  return -1;
    499              }
    500          
    501              /* Implement the final paragraph of RFC 6347 section 4.1.1.1
    502               * in the following way: after the initial transmission and a first
    503               * retransmission, back off to a temporary estimated MTU of 508 bytes.
    504               * This value is guaranteed to be deliverable (if not guaranteed to be
    505               * delivered) of any compliant IPv4 (and IPv6) network, and should work
    506               * on most non-IP stacks too. */
    507              if (ssl->handshake->retransmit_timeout != ssl->conf->hs_timeout_min) {
    508                  ssl->handshake->mtu = 508;
    509                  MBEDTLS_SSL_DEBUG_MSG(2, ("mtu autoreduction to %d bytes", ssl->handshake->mtu));
    510              }
    511          
    512              new_timeout = 2 * ssl->handshake->retransmit_timeout;
    513          
    514              /* Avoid arithmetic overflow and range overflow */
    515              if (new_timeout < ssl->handshake->retransmit_timeout ||
    516                  new_timeout > ssl->conf->hs_timeout_max) {
    517                  new_timeout = ssl->conf->hs_timeout_max;
    518              }
    519          
    520              ssl->handshake->retransmit_timeout = new_timeout;
    521              MBEDTLS_SSL_DEBUG_MSG(3, ("update timeout value to %lu millisecs",
    522                                        (unsigned long) ssl->handshake->retransmit_timeout));
    523          
    524              return 0;
    525          }
    526          
    527          static void ssl_reset_retransmit_timeout(mbedtls_ssl_context *ssl)
    528          {
    529              ssl->handshake->retransmit_timeout = ssl->conf->hs_timeout_min;
    530              MBEDTLS_SSL_DEBUG_MSG(3, ("update timeout value to %lu millisecs",
    531                                        (unsigned long) ssl->handshake->retransmit_timeout));
    532          }
    533          #endif /* MBEDTLS_SSL_PROTO_DTLS */
    534          
    535          /*
    536           * Encryption/decryption functions
    537           */
    538          
    539          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID) || defined(MBEDTLS_SSL_PROTO_TLS1_3)
    540          
    541          static size_t ssl_compute_padding_length(size_t len,
    542                                                   size_t granularity)
    543          {
    544              return (granularity - (len + 1) % granularity) % granularity;
    545          }
    546          
    547          /* This functions transforms a (D)TLS plaintext fragment and a record content
    548           * type into an instance of the (D)TLSInnerPlaintext structure. This is used
    549           * in DTLS 1.2 + CID and within TLS 1.3 to allow flexible padding and to protect
    550           * a record's content type.
    551           *
    552           *        struct {
    553           *            opaque content[DTLSPlaintext.length];
    554           *            ContentType real_type;
    555           *            uint8 zeros[length_of_padding];
    556           *        } (D)TLSInnerPlaintext;
    557           *
    558           *  Input:
    559           *  - `content`: The beginning of the buffer holding the
    560           *               plaintext to be wrapped.
    561           *  - `*content_size`: The length of the plaintext in Bytes.
    562           *  - `max_len`: The number of Bytes available starting from
    563           *               `content`. This must be `>= *content_size`.
    564           *  - `rec_type`: The desired record content type.
    565           *
    566           *  Output:
    567           *  - `content`: The beginning of the resulting (D)TLSInnerPlaintext structure.
    568           *  - `*content_size`: The length of the resulting (D)TLSInnerPlaintext structure.
    569           *
    570           *  Returns:
    571           *  - `0` on success.
    572           *  - A negative error code if `max_len` didn't offer enough space
    573           *    for the expansion.
    574           */
    575          MBEDTLS_CHECK_RETURN_CRITICAL
    576          static int ssl_build_inner_plaintext(unsigned char *content,
    577                                               size_t *content_size,
    578                                               size_t remaining,
    579                                               uint8_t rec_type,
    580                                               size_t pad)
    581          {
    582              size_t len = *content_size;
    583          
    584              /* Write real content type */
    585              if (remaining == 0) {
    586                  return -1;
    587              }
    588              content[len] = rec_type;
    589              len++;
    590              remaining--;
    591          
    592              if (remaining < pad) {
    593                  return -1;
    594              }
    595              memset(content + len, 0, pad);
    596              len += pad;
    597              remaining -= pad;
    598          
    599              *content_size = len;
    600              return 0;
    601          }
    602          
    603          /* This function parses a (D)TLSInnerPlaintext structure.
    604           * See ssl_build_inner_plaintext() for details. */
    605          MBEDTLS_CHECK_RETURN_CRITICAL
    606          static int ssl_parse_inner_plaintext(unsigned char const *content,
    607                                               size_t *content_size,
    608                                               uint8_t *rec_type)
    609          {
    610              size_t remaining = *content_size;
    611          
    612              /* Determine length of padding by skipping zeroes from the back. */
    613              do {
    614                  if (remaining == 0) {
    615                      return -1;
    616                  }
    617                  remaining--;
    618              } while (content[remaining] == 0);
    619          
    620              *content_size = remaining;
    621              *rec_type = content[remaining];
    622          
    623              return 0;
    624          }
    625          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID || MBEDTLS_SSL_PROTO_TLS1_3 */
    626          
    627          /* The size of the `add_data` structure depends on various
    628           * factors, namely
    629           *
    630           * 1) CID functionality disabled
    631           *
    632           * additional_data =
    633           *    8:                    seq_num +
    634           *    1:                       type +
    635           *    2:                    version +
    636           *    2:  length of inner plaintext +
    637           *
    638           * size = 13 bytes
    639           *
    640           * 2) CID functionality based on RFC 9146 enabled
    641           *
    642           * size = 8 + 1 + 1 + 1 + 2 + 2 + 6 + 2 + CID-length
    643           *      = 23 + CID-length
    644           *
    645           * 3) CID functionality based on legacy CID version
    646              according to draft-ietf-tls-dtls-connection-id-05
    647           *  https://tools.ietf.org/html/draft-ietf-tls-dtls-connection-id-05
    648           *
    649           * size = 13 + 1 + CID-length
    650           *
    651           * More information about the CID usage:
    652           *
    653           * Per Section 5.3 of draft-ietf-tls-dtls-connection-id-05 the
    654           * size of the additional data structure is calculated as:
    655           *
    656           * additional_data =
    657           *    8:                    seq_num +
    658           *    1:                  tls12_cid +
    659           *    2:     DTLSCipherText.version +
    660           *    n:                        cid +
    661           *    1:                 cid_length +
    662           *    2: length_of_DTLSInnerPlaintext
    663           *
    664           * Per RFC 9146 the size of the add_data structure is calculated as:
    665           *
    666           * additional_data =
    667           *    8:        seq_num_placeholder +
    668           *    1:                  tls12_cid +
    669           *    1:                 cid_length +
    670           *    1:                  tls12_cid +
    671           *    2:     DTLSCiphertext.version +
    672           *    2:                      epoch +
    673           *    6:            sequence_number +
    674           *    n:                        cid +
    675           *    2: length_of_DTLSInnerPlaintext
    676           *
    677           */

   \                                 In section .text, align 2, keep-with-next
    678          static void ssl_extract_add_data_from_record(unsigned char *add_data,
    679                                                       size_t *add_data_len,
    680                                                       mbedtls_record *rec,
    681                                                       mbedtls_ssl_protocol_version
    682                                                       tls_version,
    683                                                       size_t taglen)
    684          {
   \                     ssl_extract_add_data_from_record: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
    685              /* Several types of ciphers have been defined for use with TLS and DTLS,
    686               * and the MAC calculations for those ciphers differ slightly. Further
    687               * variants were added when the CID functionality was added with RFC 9146.
    688               * This implementations also considers the use of a legacy version of the
    689               * CID specification published in draft-ietf-tls-dtls-connection-id-05,
    690               * which is used in deployments.
    691               *
    692               * We will distinguish between the non-CID and the CID cases below.
    693               *
    694               * --- Non-CID cases ---
    695               *
    696               * Quoting RFC 5246 (TLS 1.2):
    697               *
    698               *    additional_data = seq_num + TLSCompressed.type +
    699               *                      TLSCompressed.version + TLSCompressed.length;
    700               *
    701               * For TLS 1.3, the record sequence number is dropped from the AAD
    702               * and encoded within the nonce of the AEAD operation instead.
    703               * Moreover, the additional data involves the length of the TLS
    704               * ciphertext, not the TLS plaintext as in earlier versions.
    705               * Quoting RFC 8446 (TLS 1.3):
    706               *
    707               *      additional_data = TLSCiphertext.opaque_type ||
    708               *                        TLSCiphertext.legacy_record_version ||
    709               *                        TLSCiphertext.length
    710               *
    711               * We pass the tag length to this function in order to compute the
    712               * ciphertext length from the inner plaintext length rec->data_len via
    713               *
    714               *     TLSCiphertext.length = TLSInnerPlaintext.length + taglen.
    715               *
    716               * --- CID cases ---
    717               *
    718               * RFC 9146 uses a common pattern when constructing the data
    719               * passed into a MAC / AEAD cipher.
    720               *
    721               * Data concatenation for MACs used with block ciphers with
    722               * Encrypt-then-MAC Processing (with CID):
    723               *
    724               *  data = seq_num_placeholder +
    725               *         tls12_cid +
    726               *         cid_length +
    727               *         tls12_cid +
    728               *         DTLSCiphertext.version +
    729               *         epoch +
    730               *         sequence_number +
    731               *         cid +
    732               *         DTLSCiphertext.length +
    733               *         IV +
    734               *         ENC(content + padding + padding_length)
    735               *
    736               * Data concatenation for MACs used with block ciphers (with CID):
    737               *
    738               *  data =  seq_num_placeholder +
    739               *          tls12_cid +
    740               *          cid_length +
    741               *          tls12_cid +
    742               *          DTLSCiphertext.version +
    743               *          epoch +
    744               *          sequence_number +
    745               *          cid +
    746               *          length_of_DTLSInnerPlaintext +
    747               *          DTLSInnerPlaintext.content +
    748               *          DTLSInnerPlaintext.real_type +
    749               *          DTLSInnerPlaintext.zeros
    750               *
    751               * AEAD ciphers use the following additional data calculation (with CIDs):
    752               *
    753               *     additional_data = seq_num_placeholder +
    754               *                tls12_cid +
    755               *                cid_length +
    756               *                tls12_cid +
    757               *                DTLSCiphertext.version +
    758               *                epoch +
    759               *                sequence_number +
    760               *                cid +
    761               *                length_of_DTLSInnerPlaintext
    762               *
    763               * Section 5.3 of draft-ietf-tls-dtls-connection-id-05 (for legacy CID use)
    764               * defines the additional data calculation as follows:
    765               *
    766               *     additional_data = seq_num +
    767               *                tls12_cid +
    768               *                DTLSCipherText.version +
    769               *                cid +
    770               *                cid_length +
    771               *                length_of_DTLSInnerPlaintext
    772               */
    773          
    774              unsigned char *cur = add_data;
   \        0xC   0x46B9             MOV      R9,R7
    775              size_t ad_len_field = rec->data_len;
   \        0xE   0x69A8             LDR      R0,[R5, #+24]
   \       0x10   0x9000             STR      R0,[SP, #+0]
    776          
    777          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID) && \
    778              MBEDTLS_SSL_DTLS_CONNECTION_ID_COMPAT == 0
    779              const unsigned char seq_num_placeholder[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
    780          #endif
    781          
    782          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    783              if (tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
    784                  /* In TLS 1.3, the AAD contains the length of the TLSCiphertext,
    785                   * which differs from the length of the TLSInnerPlaintext
    786                   * by the length of the authentication tag. */
    787                  ad_len_field += taglen;
    788              } else
    789          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
    790              {
    791                  ((void) tls_version);
    792                  ((void) taglen);
    793          
    794          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID) && \
    795                  MBEDTLS_SSL_DTLS_CONNECTION_ID_COMPAT == 0
    796                  if (rec->cid_len != 0) {
    797                      // seq_num_placeholder
    798                      memcpy(cur, seq_num_placeholder, sizeof(seq_num_placeholder));
    799                      cur += sizeof(seq_num_placeholder);
    800          
    801                      // tls12_cid type
    802                      *cur = rec->type;
    803                      cur++;
    804          
    805                      // cid_length
    806                      *cur = rec->cid_len;
    807                      cur++;
    808                  } else
    809          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    810                  {
    811                      // epoch + sequence number
    812                      memcpy(cur, rec->ctr, sizeof(rec->ctr));
   \       0x12   0xF05F 0x0808      MOVS     R8,#+8
   \       0x16   0x9502             STR      R5,[SP, #+8]
   \       0x18   0x46CA             MOV      R10,R9
   \       0x1A   0x4642             MOV      R2,R8
   \       0x1C   0x9902             LDR      R1,[SP, #+8]
   \       0x1E   0x4650             MOV      R0,R10
   \       0x20   0x.... 0x....      BL       __aeabi_memcpy
    813                      cur += sizeof(rec->ctr);
   \       0x24   0xF119 0x0108      ADDS     R1,R9,#+8
    814                  }
    815              }
    816          
    817              // type
    818              *cur = rec->type;
   \       0x28   0x7A28             LDRB     R0,[R5, #+8]
   \       0x2A   0x7008             STRB     R0,[R1, #+0]
    819              cur++;
   \       0x2C   0xF111 0x0A01      ADDS     R10,R1,#+1
    820          
    821              // version
    822              memcpy(cur, rec->ver, sizeof(rec->ver));
   \       0x30   0xF05F 0x0902      MOVS     R9,#+2
   \       0x34   0xF115 0x0009      ADDS     R0,R5,#+9
   \       0x38   0x9001             STR      R0,[SP, #+4]
   \       0x3A   0x46D3             MOV      R11,R10
   \       0x3C   0x464A             MOV      R2,R9
   \       0x3E   0x9901             LDR      R1,[SP, #+4]
   \       0x40   0x4658             MOV      R0,R11
   \       0x42   0x.... 0x....      BL       __aeabi_memcpy
    823              cur += sizeof(rec->ver);
   \       0x46   0xF11A 0x0A02      ADDS     R10,R10,#+2
    824          
    825          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID) && \
    826              MBEDTLS_SSL_DTLS_CONNECTION_ID_COMPAT == 1
    827          
    828              if (rec->cid_len != 0) {
    829                  // CID
    830                  memcpy(cur, rec->cid, rec->cid_len);
    831                  cur += rec->cid_len;
    832          
    833                  // cid_length
    834                  *cur = rec->cid_len;
    835                  cur++;
    836          
    837                  // length of inner plaintext
    838                  MBEDTLS_PUT_UINT16_BE(ad_len_field, cur, 0);
    839                  cur += 2;
    840              } else
    841          #elif defined(MBEDTLS_SSL_DTLS_CONNECTION_ID) && \
    842              MBEDTLS_SSL_DTLS_CONNECTION_ID_COMPAT == 0
    843          
    844              if (rec->cid_len != 0) {
    845                  // epoch + sequence number
    846                  memcpy(cur, rec->ctr, sizeof(rec->ctr));
    847                  cur += sizeof(rec->ctr);
    848          
    849                  // CID
    850                  memcpy(cur, rec->cid, rec->cid_len);
    851                  cur += rec->cid_len;
    852          
    853                  // length of inner plaintext
    854                  MBEDTLS_PUT_UINT16_BE(ad_len_field, cur, 0);
    855                  cur += 2;
    856              } else
    857          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    858              {
    859                  MBEDTLS_PUT_UINT16_BE(ad_len_field, cur, 0);
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable11
   \       0x4E   0x7800             LDRB     R0,[R0, #+0]
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD105             BNE.N    ??ssl_extract_add_data_from_record_0
   \       0x54   0x9900             LDR      R1,[SP, #+0]
   \       0x56   0xB289             UXTH     R1,R1
   \       0x58   0x4650             MOV      R0,R10
   \       0x5A   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x5E   0xE008             B.N      ??ssl_extract_add_data_from_record_1
   \                     ??ssl_extract_add_data_from_record_0: (+1)
   \       0x60   0x9800             LDR      R0,[SP, #+0]
   \       0x62   0xB280             UXTH     R0,R0
   \       0x64   0x.... 0x....      BL       mbedtls_bswap16
   \       0x68   0x0001             MOVS     R1,R0
   \       0x6A   0xB289             UXTH     R1,R1
   \       0x6C   0x4650             MOV      R0,R10
   \       0x6E   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    860                  cur += 2;
   \                     ??ssl_extract_add_data_from_record_1: (+1)
   \       0x72   0xF11A 0x0102      ADDS     R1,R10,#+2
    861              }
    862          
    863              *add_data_len = cur - add_data;
   \       0x76   0x1BC8             SUBS     R0,R1,R7
   \       0x78   0x6020             STR      R0,[R4, #+0]
    864          }
   \       0x7A   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    865          
    866          #if defined(MBEDTLS_GCM_C) || \
    867              defined(MBEDTLS_CCM_C) || \
    868              defined(MBEDTLS_CHACHAPOLY_C)
    869          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    870          static int ssl_transform_aead_dynamic_iv_is_explicit(
    871              mbedtls_ssl_transform const *transform)
    872          {
    873              return transform->ivlen != transform->fixed_ivlen;
   \                     ssl_transform_aead_dynamic_iv_is_explicit: (+1)
   \        0x0   0x6841             LDR      R1,[R0, #+4]
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0x4281             CMP      R1,R0
   \        0x6   0xD001             BEQ.N    ??ssl_transform_aead_dynamic_iv_is_explicit_0
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??ssl_transform_aead_dynamic_iv_is_explicit_1
   \                     ??ssl_transform_aead_dynamic_iv_is_explicit_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \                     ??ssl_transform_aead_dynamic_iv_is_explicit_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4770             BX       LR
    874          }
    875          
    876          /* Compute IV := ( fixed_iv || 0 ) XOR ( 0 || dynamic_IV )
    877           *
    878           * Concretely, this occurs in two variants:
    879           *
    880           * a) Fixed and dynamic IV lengths add up to total IV length, giving
    881           *       IV = fixed_iv || dynamic_iv
    882           *
    883           *    This variant is used in TLS 1.2 when used with GCM or CCM.
    884           *
    885           * b) Fixed IV lengths matches total IV length, giving
    886           *       IV = fixed_iv XOR ( 0 || dynamic_iv )
    887           *
    888           *    This variant occurs in TLS 1.3 and for TLS 1.2 when using ChaChaPoly.
    889           *
    890           * See also the documentation of mbedtls_ssl_transform.
    891           *
    892           * This function has the precondition that
    893           *
    894           *     dst_iv_len >= max( fixed_iv_len, dynamic_iv_len )
    895           *
    896           * which has to be ensured by the caller. If this precondition
    897           * violated, the behavior of this function is undefined.
    898           */

   \                                 In section .text, align 2, keep-with-next
    899          static void ssl_build_record_nonce(unsigned char *dst_iv,
    900                                             size_t dst_iv_len,
    901                                             unsigned char const *fixed_iv,
    902                                             size_t fixed_iv_len,
    903                                             unsigned char const *dynamic_iv,
    904                                             size_t dynamic_iv_len)
    905          {
   \                     ssl_build_record_nonce: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0C             LDR      R7,[SP, #+48]
   \        0xE   0xF8DD 0x8034      LDR      R8,[SP, #+52]
    906              /* Start with Fixed IV || 0 */
    907              memset(dst_iv, 0, dst_iv_len);
   \       0x12   0x9402             STR      R4,[SP, #+8]
   \       0x14   0xF05F 0x0900      MOVS     R9,#+0
   \       0x18   0x46D3             MOV      R11,R10
   \       0x1A   0x464A             MOV      R2,R9
   \       0x1C   0x9902             LDR      R1,[SP, #+8]
   \       0x1E   0x4658             MOV      R0,R11
   \       0x20   0x.... 0x....      BL       __aeabi_memset
    908              memcpy(dst_iv, fixed_iv, fixed_iv_len);
   \       0x24   0x9601             STR      R6,[SP, #+4]
   \       0x26   0x9500             STR      R5,[SP, #+0]
   \       0x28   0x46D3             MOV      R11,R10
   \       0x2A   0x9A01             LDR      R2,[SP, #+4]
   \       0x2C   0x9900             LDR      R1,[SP, #+0]
   \       0x2E   0x4658             MOV      R0,R11
   \       0x30   0x.... 0x....      BL       __aeabi_memcpy
    909          
    910              dst_iv += dst_iv_len - dynamic_iv_len;
   \       0x34   0xEBB4 0x0008      SUBS     R0,R4,R8
   \       0x38   0x4482             ADD      R10,R10,R0
    911              mbedtls_xor(dst_iv, dst_iv, dynamic_iv, dynamic_iv_len);
   \       0x3A   0x4643             MOV      R3,R8
   \       0x3C   0x003A             MOVS     R2,R7
   \       0x3E   0x4651             MOV      R1,R10
   \       0x40   0x4650             MOV      R0,R10
   \       0x42   0x.... 0x....      BL       mbedtls_xor
    912          }
   \       0x46   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    913          #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C || MBEDTLS_CHACHAPOLY_C */
    914          

   \                                 In section .text, align 2, keep-with-next
    915          int mbedtls_ssl_encrypt_buf(mbedtls_ssl_context *ssl,
    916                                      mbedtls_ssl_transform *transform,
    917                                      mbedtls_record *rec,
    918                                      int (*f_rng)(void *, unsigned char *, size_t),
    919                                      void *p_rng)
    920          {
   \                     mbedtls_ssl_encrypt_buf: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xF5AD 0x7D1B      SUB      SP,SP,#+620
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
    921              mbedtls_ssl_mode_t ssl_mode;
    922              int auth_done = 0;
   \        0xC   0x2700             MOVS     R7,#+0
    923              unsigned char *data;
    924              /* For an explanation of the additional data length see
    925               * the description of ssl_extract_add_data_from_record().
    926               */
    927          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
    928              unsigned char add_data[23 + MBEDTLS_SSL_CID_OUT_LEN_MAX];
    929          #else
    930              unsigned char add_data[13];
    931          #endif
    932              size_t add_data_len;
    933              size_t post_avail;
    934          
    935              /* The SSL context is only used for debugging purposes! */
    936          #if !defined(MBEDTLS_DEBUG_C)
    937              ssl = NULL; /* make sure we don't use it except for debug */
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x9113             STR      R1,[SP, #+76]
    938              ((void) ssl);
    939          #endif
    940          
    941              /* The PRNG is used for dynamic IV generation that's used
    942               * for CBC transformations in TLS 1.2. */
    943          #if !(defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC) && \
    944              defined(MBEDTLS_SSL_PROTO_TLS1_2))
    945              ((void) f_rng);
    946              ((void) p_rng);
    947          #endif
    948          
    949              MBEDTLS_SSL_DEBUG_MSG(2, ("=> encrypt buf"));
    950          
    951              if (transform == NULL) {
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD102             BNE.N    ??mbedtls_ssl_encrypt_buf_0
    952                  MBEDTLS_SSL_DEBUG_MSG(1, ("no transform provided to encrypt_buf"));
    953                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x1A   0xE1D7             B.N      ??mbedtls_ssl_encrypt_buf_1
    954              }
    955              if (rec == NULL
    956                  || rec->buf == NULL
    957                  || rec->buf_len < rec->data_offset
    958                  || rec->buf_len - rec->data_offset < rec->data_len
    959          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
    960                  || rec->cid_len != 0
    961          #endif
    962                  ) {
   \                     ??mbedtls_ssl_encrypt_buf_0: (+1)
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD00C             BEQ.N    ??mbedtls_ssl_encrypt_buf_2
   \       0x20   0x68F0             LDR      R0,[R6, #+12]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD009             BEQ.N    ??mbedtls_ssl_encrypt_buf_2
   \       0x26   0x6931             LDR      R1,[R6, #+16]
   \       0x28   0x6970             LDR      R0,[R6, #+20]
   \       0x2A   0x4281             CMP      R1,R0
   \       0x2C   0xD305             BCC.N    ??mbedtls_ssl_encrypt_buf_2
   \       0x2E   0x6931             LDR      R1,[R6, #+16]
   \       0x30   0x6970             LDR      R0,[R6, #+20]
   \       0x32   0x1A09             SUBS     R1,R1,R0
   \       0x34   0x69B0             LDR      R0,[R6, #+24]
   \       0x36   0x4281             CMP      R1,R0
   \       0x38   0xD202             BCS.N    ??mbedtls_ssl_encrypt_buf_3
    963                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad record structure provided to encrypt_buf"));
    964                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \                     ??mbedtls_ssl_encrypt_buf_2: (+1)
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x3E   0xE1C5             B.N      ??mbedtls_ssl_encrypt_buf_1
    965              }
    966          
    967              ssl_mode = mbedtls_ssl_get_mode_from_transform(transform);
   \                     ??mbedtls_ssl_encrypt_buf_3: (+1)
   \       0x40   0x0028             MOVS     R0,R5
   \       0x42   0x.... 0x....      BL       mbedtls_ssl_get_mode_from_transform
   \       0x46   0xF88D 0x001C      STRB     R0,[SP, #+28]
    968          
    969              data = rec->buf + rec->data_offset;
   \       0x4A   0x68F1             LDR      R1,[R6, #+12]
   \       0x4C   0x6970             LDR      R0,[R6, #+20]
   \       0x4E   0xEB01 0x0800      ADD      R8,R1,R0
    970              post_avail = rec->buf_len - (rec->data_len + rec->data_offset);
   \       0x52   0x6931             LDR      R1,[R6, #+16]
   \       0x54   0x69B0             LDR      R0,[R6, #+24]
   \       0x56   0x1A09             SUBS     R1,R1,R0
   \       0x58   0x6970             LDR      R0,[R6, #+20]
   \       0x5A   0x1A09             SUBS     R1,R1,R0
    971              MBEDTLS_SSL_DEBUG_BUF(4, "before encrypt: output payload",
    972                                    data, rec->data_len);
    973          
    974              if (rec->data_len > MBEDTLS_SSL_OUT_CONTENT_LEN) {
   \       0x5C   0x69B2             LDR      R2,[R6, #+24]
   \       0x5E   0xF240 0x3001      MOVW     R0,#+769
   \       0x62   0x4282             CMP      R2,R0
   \       0x64   0xD302             BCC.N    ??mbedtls_ssl_encrypt_buf_4
    975                  MBEDTLS_SSL_DEBUG_MSG(1, ("Record content %" MBEDTLS_PRINTF_SIZET
    976                                            " too large, maximum %" MBEDTLS_PRINTF_SIZET,
    977                                            rec->data_len,
    978                                            (size_t) MBEDTLS_SSL_OUT_CONTENT_LEN));
    979                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x6A   0xE1AF             B.N      ??mbedtls_ssl_encrypt_buf_1
    980              }
    981          
    982              /* The following two code paths implement the (D)TLSInnerPlaintext
    983               * structure present in TLS 1.3 and DTLS 1.2 + CID.
    984               *
    985               * See ssl_build_inner_plaintext() for more information.
    986               *
    987               * Note that this changes `rec->data_len`, and hence
    988               * `post_avail` needs to be recalculated afterwards.
    989               *
    990               * Note also that the two code paths cannot occur simultaneously
    991               * since they apply to different versions of the protocol. There
    992               * is hence no risk of double-addition of the inner plaintext.
    993               */
    994          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    995              if (transform->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
    996                  size_t padding =
    997                      ssl_compute_padding_length(rec->data_len,
    998                                                 MBEDTLS_SSL_CID_TLS1_3_PADDING_GRANULARITY);
    999                  if (ssl_build_inner_plaintext(data,
   1000                                                &rec->data_len,
   1001                                                post_avail,
   1002                                                rec->type,
   1003                                                padding) != 0) {
   1004                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   1005                  }
   1006          
   1007                  rec->type = MBEDTLS_SSL_MSG_APPLICATION_DATA;
   1008              }
   1009          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   1010          
   1011          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   1012              /*
   1013               * Add CID information
   1014               */
   1015              rec->cid_len = transform->out_cid_len;
   1016              memcpy(rec->cid, transform->out_cid, transform->out_cid_len);
   1017              MBEDTLS_SSL_DEBUG_BUF(3, "CID", rec->cid, rec->cid_len);
   1018          
   1019              if (rec->cid_len != 0) {
   1020                  size_t padding =
   1021                      ssl_compute_padding_length(rec->data_len,
   1022                                                 MBEDTLS_SSL_CID_TLS1_3_PADDING_GRANULARITY);
   1023                  /*
   1024                   * Wrap plaintext into DTLSInnerPlaintext structure.
   1025                   * See ssl_build_inner_plaintext() for more information.
   1026                   *
   1027                   * Note that this changes `rec->data_len`, and hence
   1028                   * `post_avail` needs to be recalculated afterwards.
   1029                   */
   1030                  if (ssl_build_inner_plaintext(data,
   1031                                                &rec->data_len,
   1032                                                post_avail,
   1033                                                rec->type,
   1034                                                padding) != 0) {
   1035                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   1036                  }
   1037          
   1038                  rec->type = MBEDTLS_SSL_MSG_CID;
   1039              }
   1040          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   1041          
   1042              post_avail = rec->buf_len - (rec->data_len + rec->data_offset);
   \                     ??mbedtls_ssl_encrypt_buf_4: (+1)
   \       0x6C   0xF8D6 0x9010      LDR      R9,[R6, #+16]
   \       0x70   0x69B0             LDR      R0,[R6, #+24]
   \       0x72   0xEBB9 0x0900      SUBS     R9,R9,R0
   \       0x76   0x6970             LDR      R0,[R6, #+20]
   \       0x78   0xEBB9 0x0900      SUBS     R9,R9,R0
   1043          
   1044              /*
   1045               * Add MAC before if needed
   1046               */
   1047          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
   1048              if (ssl_mode == MBEDTLS_SSL_MODE_STREAM ||
   1049                  ssl_mode == MBEDTLS_SSL_MODE_CBC) {
   \       0x7C   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD003             BEQ.N    ??mbedtls_ssl_encrypt_buf_5
   \       0x84   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \       0x88   0x2801             CMP      R0,#+1
   \       0x8A   0xD16A             BNE.N    ??mbedtls_ssl_encrypt_buf_6
   1050                  if (post_avail < transform->maclen) {
   \                     ??mbedtls_ssl_encrypt_buf_5: (+1)
   \       0x8C   0x68E8             LDR      R0,[R5, #+12]
   \       0x8E   0x4581             CMP      R9,R0
   \       0x90   0xD202             BCS.N    ??mbedtls_ssl_encrypt_buf_7
   1051                      MBEDTLS_SSL_DEBUG_MSG(1, ("Buffer provided for encrypted record not large enough"));
   1052                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x96   0xE199             B.N      ??mbedtls_ssl_encrypt_buf_1
   1053                  }
   1054          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1055                  unsigned char mac[MBEDTLS_SSL_MAC_ADD];
   1056                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_ssl_encrypt_buf_7: (+1)
   \       0x98   0xF07F 0x006D      MVNS     R0,#+109
   \       0x9C   0x9002             STR      R0,[SP, #+8]
   1057          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1058                  psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;
   \       0x9E   0xA842             ADD      R0,SP,#+264
   \       0xA0   0xF44F 0x71B2      MOV      R1,#+356
   \       0xA4   0x.... 0x....      BL       __aeabi_memclr4
   1059                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0xA8   0xF07F 0x0A96      MVNS     R10,#+150
   1060                  size_t sign_mac_length = 0;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x9001             STR      R0,[SP, #+4]
   1061          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1062          
   1063                  ssl_extract_add_data_from_record(add_data, &add_data_len, rec,
   1064                                                   transform->tls_version,
   1065                                                   transform->taglen);
   \       0xB0   0x6928             LDR      R0,[R5, #+16]
   \       0xB2   0x9000             STR      R0,[SP, #+0]
   \       0xB4   0xF9B5 0x3040      LDRSH    R3,[R5, #+64]
   \       0xB8   0x0032             MOVS     R2,R6
   \       0xBA   0xA908             ADD      R1,SP,#+32
   \       0xBC   0xA80F             ADD      R0,SP,#+60
   \       0xBE   0x.... 0x....      BL       ssl_extract_add_data_from_record
   1066          
   1067          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1068                  status = psa_mac_sign_setup(&operation, transform->psa_mac_enc,
   1069                                              transform->psa_mac_alg);
   \       0xC2   0x6BEA             LDR      R2,[R5, #+60]
   \       0xC4   0x6B69             LDR      R1,[R5, #+52]
   \       0xC6   0xA842             ADD      R0,SP,#+264
   \       0xC8   0x.... 0x....      BL       psa_mac_sign_setup
   \       0xCC   0x0004             MOVS     R4,R0
   1070                  if (status != PSA_SUCCESS) {
   \       0xCE   0x2C00             CMP      R4,#+0
   \       0xD0   0xD12C             BNE.N    ??mbedtls_ssl_encrypt_buf_8
   1071                      goto hmac_failed_etm_disabled;
   1072                  }
   1073          
   1074                  status = psa_mac_update(&operation, add_data, add_data_len);
   \                     ??mbedtls_ssl_encrypt_buf_9: (+1)
   \       0xD2   0x9A08             LDR      R2,[SP, #+32]
   \       0xD4   0xA90F             ADD      R1,SP,#+60
   \       0xD6   0xA842             ADD      R0,SP,#+264
   \       0xD8   0x.... 0x....      BL       psa_mac_update
   \       0xDC   0x0004             MOVS     R4,R0
   1075                  if (status != PSA_SUCCESS) {
   \       0xDE   0x2C00             CMP      R4,#+0
   \       0xE0   0xD124             BNE.N    ??mbedtls_ssl_encrypt_buf_8
   1076                      goto hmac_failed_etm_disabled;
   1077                  }
   1078          
   1079                  status = psa_mac_update(&operation, data, rec->data_len);
   \                     ??mbedtls_ssl_encrypt_buf_10: (+1)
   \       0xE2   0x69B2             LDR      R2,[R6, #+24]
   \       0xE4   0x4641             MOV      R1,R8
   \       0xE6   0xA842             ADD      R0,SP,#+264
   \       0xE8   0x.... 0x....      BL       psa_mac_update
   \       0xEC   0x0004             MOVS     R4,R0
   1080                  if (status != PSA_SUCCESS) {
   \       0xEE   0x2C00             CMP      R4,#+0
   \       0xF0   0xD11C             BNE.N    ??mbedtls_ssl_encrypt_buf_8
   1081                      goto hmac_failed_etm_disabled;
   1082                  }
   1083          
   1084                  status = psa_mac_sign_finish(&operation, mac, MBEDTLS_SSL_MAC_ADD,
   1085                                               &sign_mac_length);
   \                     ??mbedtls_ssl_encrypt_buf_11: (+1)
   \       0xF2   0xAB01             ADD      R3,SP,#+4
   \       0xF4   0x2220             MOVS     R2,#+32
   \       0xF6   0xA914             ADD      R1,SP,#+80
   \       0xF8   0xA842             ADD      R0,SP,#+264
   \       0xFA   0x.... 0x....      BL       psa_mac_sign_finish
   \       0xFE   0x0004             MOVS     R4,R0
   1086                  if (status != PSA_SUCCESS) {
   \      0x100   0x2C00             CMP      R4,#+0
   \      0x102   0xD113             BNE.N    ??mbedtls_ssl_encrypt_buf_8
   1087                      goto hmac_failed_etm_disabled;
   1088                  }
   1089          #else
   1090                  ret = mbedtls_md_hmac_update(&transform->md_ctx_enc, add_data,
   1091                                               add_data_len);
   1092                  if (ret != 0) {
   1093                      goto hmac_failed_etm_disabled;
   1094                  }
   1095                  ret = mbedtls_md_hmac_update(&transform->md_ctx_enc, data, rec->data_len);
   1096                  if (ret != 0) {
   1097                      goto hmac_failed_etm_disabled;
   1098                  }
   1099                  ret = mbedtls_md_hmac_finish(&transform->md_ctx_enc, mac);
   1100                  if (ret != 0) {
   1101                      goto hmac_failed_etm_disabled;
   1102                  }
   1103                  ret = mbedtls_md_hmac_reset(&transform->md_ctx_enc);
   1104                  if (ret != 0) {
   1105                      goto hmac_failed_etm_disabled;
   1106                  }
   1107          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1108          
   1109                  memcpy(data + rec->data_len, mac, transform->maclen);
   \                     ??mbedtls_ssl_encrypt_buf_12: (+1)
   \      0x104   0x68E8             LDR      R0,[R5, #+12]
   \      0x106   0x9000             STR      R0,[SP, #+0]
   \      0x108   0xF10D 0x0A50      ADD      R10,SP,#+80
   \      0x10C   0x69B0             LDR      R0,[R6, #+24]
   \      0x10E   0xEB08 0x0B00      ADD      R11,R8,R0
   \      0x112   0x9A00             LDR      R2,[SP, #+0]
   \      0x114   0x4651             MOV      R1,R10
   \      0x116   0x4658             MOV      R0,R11
   \      0x118   0x.... 0x....      BL       __aeabi_memcpy
   1110          #endif
   1111          
   1112                  MBEDTLS_SSL_DEBUG_BUF(4, "computed mac", data + rec->data_len,
   1113                                        transform->maclen);
   1114          
   1115                  rec->data_len += transform->maclen;
   \      0x11C   0x69B1             LDR      R1,[R6, #+24]
   \      0x11E   0x68E8             LDR      R0,[R5, #+12]
   \      0x120   0x1841             ADDS     R1,R0,R1
   \      0x122   0x61B1             STR      R1,[R6, #+24]
   1116                  post_avail -= transform->maclen;
   \      0x124   0x68E8             LDR      R0,[R5, #+12]
   \      0x126   0xEBB9 0x0900      SUBS     R9,R9,R0
   1117                  auth_done++;
   \      0x12A   0x1C7F             ADDS     R7,R7,#+1
   1118          
   1119          hmac_failed_etm_disabled:
   1120                  mbedtls_platform_zeroize(mac, transform->maclen);
   \                     ??mbedtls_ssl_encrypt_buf_8: (+1)
   \      0x12C   0x68E9             LDR      R1,[R5, #+12]
   \      0x12E   0xA814             ADD      R0,SP,#+80
   \      0x130   0x.... 0x....      BL       mbedtls_platform_zeroize
   1121          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1122                  ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x134   0x0020             MOVS     R0,R4
   \      0x136   0x.... 0x....      BL       local_err_translation
   \      0x13A   0x4682             MOV      R10,R0
   1123                  status = psa_mac_abort(&operation);
   \      0x13C   0xA842             ADD      R0,SP,#+264
   \      0x13E   0x.... 0x....      BL       psa_mac_abort
   \      0x142   0x4683             MOV      R11,R0
   1124                  if (ret == 0 && status != PSA_SUCCESS) {
   \      0x144   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x148   0xD106             BNE.N    ??mbedtls_ssl_encrypt_buf_13
   \      0x14A   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x14E   0xD003             BEQ.N    ??mbedtls_ssl_encrypt_buf_13
   1125                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x150   0x4658             MOV      R0,R11
   \      0x152   0x.... 0x....      BL       local_err_translation
   \      0x156   0x4682             MOV      R10,R0
   1126                  }
   1127          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1128                  if (ret != 0) {
   \                     ??mbedtls_ssl_encrypt_buf_13: (+1)
   \      0x158   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x15C   0xD001             BEQ.N    ??mbedtls_ssl_encrypt_buf_6
   1129                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_md_hmac_xxx", ret);
   1130                      return ret;
   \      0x15E   0x4650             MOV      R0,R10
   \      0x160   0xE134             B.N      ??mbedtls_ssl_encrypt_buf_1
   1131                  }
   1132              }
   1133          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_MAC */
   1134          
   1135              /*
   1136               * Encrypt
   1137               */
   1138          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_STREAM)
   1139              if (ssl_mode == MBEDTLS_SSL_MODE_STREAM) {
   1140                  MBEDTLS_SSL_DEBUG_MSG(3, ("before encrypt: msglen = %" MBEDTLS_PRINTF_SIZET ", "
   1141                                                                                              "including %d bytes of padding",
   1142                                            rec->data_len, 0));
   1143          
   1144                  /* The only supported stream cipher is "NULL",
   1145                   * so there's nothing to do here.*/
   1146              } else
   1147          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_STREAM */
   1148          
   1149          #if defined(MBEDTLS_GCM_C) || \
   1150              defined(MBEDTLS_CCM_C) || \
   1151              defined(MBEDTLS_CHACHAPOLY_C)
   1152              if (ssl_mode == MBEDTLS_SSL_MODE_AEAD) {
   \                     ??mbedtls_ssl_encrypt_buf_6: (+1)
   \      0x162   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \      0x166   0x2803             CMP      R0,#+3
   \      0x168   0xD16B             BNE.N    ??mbedtls_ssl_encrypt_buf_14
   1153                  unsigned char iv[12];
   1154                  unsigned char *dynamic_iv;
   1155                  size_t dynamic_iv_len;
   1156                  int dynamic_iv_is_explicit =
   1157                      ssl_transform_aead_dynamic_iv_is_explicit(transform);
   \      0x16A   0x0028             MOVS     R0,R5
   \      0x16C   0x.... 0x....      BL       ssl_transform_aead_dynamic_iv_is_explicit
   \      0x170   0x0004             MOVS     R4,R0
   1158          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1159                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \      0x172   0xF07F 0x0096      MVNS     R0,#+150
   \      0x176   0x900B             STR      R0,[SP, #+44]
   1160          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1161                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \      0x178   0xF07F 0x006D      MVNS     R0,#+109
   \      0x17C   0x900A             STR      R0,[SP, #+40]
   1162          
   1163                  /* Check that there's space for the authentication tag. */
   1164                  if (post_avail < transform->taglen) {
   \      0x17E   0x6928             LDR      R0,[R5, #+16]
   \      0x180   0x4581             CMP      R9,R0
   \      0x182   0xD202             BCS.N    ??mbedtls_ssl_encrypt_buf_15
   1165                      MBEDTLS_SSL_DEBUG_MSG(1, ("Buffer provided for encrypted record not large enough"));
   1166                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   \      0x184   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \      0x188   0xE120             B.N      ??mbedtls_ssl_encrypt_buf_1
   1167                  }
   1168          
   1169                  /*
   1170                   * Build nonce for AEAD encryption.
   1171                   *
   1172                   * Note: In the case of CCM and GCM in TLS 1.2, the dynamic
   1173                   *       part of the IV is prepended to the ciphertext and
   1174                   *       can be chosen freely - in particular, it need not
   1175                   *       agree with the record sequence number.
   1176                   *       However, since ChaChaPoly as well as all AEAD modes
   1177                   *       in TLS 1.3 use the record sequence number as the
   1178                   *       dynamic part of the nonce, we uniformly use the
   1179                   *       record sequence number here in all cases.
   1180                   */
   1181                  dynamic_iv     = rec->ctr;
   \                     ??mbedtls_ssl_encrypt_buf_15: (+1)
   \      0x18A   0x9609             STR      R6,[SP, #+36]
   1182                  dynamic_iv_len = sizeof(rec->ctr);
   \      0x18C   0xF05F 0x0B08      MOVS     R11,#+8
   1183          
   1184                  ssl_build_record_nonce(iv, sizeof(iv),
   1185                                         transform->iv_enc,
   1186                                         transform->fixed_ivlen,
   1187                                         dynamic_iv,
   1188                                         dynamic_iv_len);
   \      0x190   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \      0x194   0x9809             LDR      R0,[SP, #+36]
   \      0x196   0x9000             STR      R0,[SP, #+0]
   \      0x198   0x68AB             LDR      R3,[R5, #+8]
   \      0x19A   0xF115 0x0214      ADDS     R2,R5,#+20
   \      0x19E   0x210C             MOVS     R1,#+12
   \      0x1A0   0xA80C             ADD      R0,SP,#+48
   \      0x1A2   0x.... 0x....      BL       ssl_build_record_nonce
   1189          
   1190                  /*
   1191                   * Build additional data for AEAD encryption.
   1192                   * This depends on the TLS version.
   1193                   */
   1194                  ssl_extract_add_data_from_record(add_data, &add_data_len, rec,
   1195                                                   transform->tls_version,
   1196                                                   transform->taglen);
   \      0x1A6   0x6928             LDR      R0,[R5, #+16]
   \      0x1A8   0x9000             STR      R0,[SP, #+0]
   \      0x1AA   0xF9B5 0x3040      LDRSH    R3,[R5, #+64]
   \      0x1AE   0x0032             MOVS     R2,R6
   \      0x1B0   0xA908             ADD      R1,SP,#+32
   \      0x1B2   0xA80F             ADD      R0,SP,#+60
   \      0x1B4   0x.... 0x....      BL       ssl_extract_add_data_from_record
   1197          
   1198                  MBEDTLS_SSL_DEBUG_BUF(4, "IV used (internal)",
   1199                                        iv, transform->ivlen);
   1200                  MBEDTLS_SSL_DEBUG_BUF(4, "IV used (transmitted)",
   1201                                        dynamic_iv,
   1202                                        dynamic_iv_is_explicit ? dynamic_iv_len : 0);
   1203                  MBEDTLS_SSL_DEBUG_BUF(4, "additional data used for AEAD",
   1204                                        add_data, add_data_len);
   1205                  MBEDTLS_SSL_DEBUG_MSG(3, ("before encrypt: msglen = %" MBEDTLS_PRINTF_SIZET ", "
   1206                                                                                              "including 0 bytes of padding",
   1207                                            rec->data_len));
   1208          
   1209                  /*
   1210                   * Encrypt and authenticate
   1211                   */
   1212          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1213                  status = psa_aead_encrypt(transform->psa_key_enc,
   1214                                            transform->psa_alg,
   1215                                            iv, transform->ivlen,
   1216                                            add_data, add_data_len,
   1217                                            data, rec->data_len,
   1218                                            data, rec->buf_len - (data - rec->buf),
   1219                                            &rec->data_len);
   \      0x1B8   0xF116 0x0018      ADDS     R0,R6,#+24
   \      0x1BC   0x9006             STR      R0,[SP, #+24]
   \      0x1BE   0x6931             LDR      R1,[R6, #+16]
   \      0x1C0   0xEBB1 0x0108      SUBS     R1,R1,R8
   \      0x1C4   0x68F0             LDR      R0,[R6, #+12]
   \      0x1C6   0x1841             ADDS     R1,R0,R1
   \      0x1C8   0x9105             STR      R1,[SP, #+20]
   \      0x1CA   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \      0x1CE   0x69B0             LDR      R0,[R6, #+24]
   \      0x1D0   0x9003             STR      R0,[SP, #+12]
   \      0x1D2   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \      0x1D6   0x9808             LDR      R0,[SP, #+32]
   \      0x1D8   0x9001             STR      R0,[SP, #+4]
   \      0x1DA   0xA80F             ADD      R0,SP,#+60
   \      0x1DC   0x9000             STR      R0,[SP, #+0]
   \      0x1DE   0x686B             LDR      R3,[R5, #+4]
   \      0x1E0   0xAA0C             ADD      R2,SP,#+48
   \      0x1E2   0x6CE9             LDR      R1,[R5, #+76]
   \      0x1E4   0x6C68             LDR      R0,[R5, #+68]
   \      0x1E6   0x.... 0x....      BL       psa_aead_encrypt
   \      0x1EA   0x4682             MOV      R10,R0
   1220          
   1221                  if (status != PSA_SUCCESS) {
   \      0x1EC   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x1F0   0xD003             BEQ.N    ??mbedtls_ssl_encrypt_buf_16
   1222                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x1F2   0x4650             MOV      R0,R10
   \      0x1F4   0x.... 0x....      BL       local_err_translation
   1223                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_encrypt_buf", ret);
   1224                      return ret;
   \      0x1F8   0xE0E8             B.N      ??mbedtls_ssl_encrypt_buf_1
   1225                  }
   1226          #else
   1227                  if ((ret = mbedtls_cipher_auth_encrypt_ext(&transform->cipher_ctx_enc,
   1228                                                             iv, transform->ivlen,
   1229                                                             add_data, add_data_len,
   1230                                                             data, rec->data_len, /* src */
   1231                                                             data, rec->buf_len - (data - rec->buf), /* dst */
   1232                                                             &rec->data_len,
   1233                                                             transform->taglen)) != 0) {
   1234                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_auth_encrypt_ext", ret);
   1235                      return ret;
   1236                  }
   1237          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1238          
   1239                  MBEDTLS_SSL_DEBUG_BUF(4, "after encrypt: tag",
   1240                                        data + rec->data_len - transform->taglen,
   1241                                        transform->taglen);
   1242                  /* Account for authentication tag. */
   1243                  post_avail -= transform->taglen;
   \                     ??mbedtls_ssl_encrypt_buf_16: (+1)
   \      0x1FA   0x6928             LDR      R0,[R5, #+16]
   \      0x1FC   0xEBB9 0x0900      SUBS     R9,R9,R0
   \      0x200   0xF8CD 0x9018      STR      R9,[SP, #+24]
   1244          
   1245                  /*
   1246                   * Prefix record content with dynamic IV in case it is explicit.
   1247                   */
   1248                  if (dynamic_iv_is_explicit != 0) {
   \      0x204   0x2C00             CMP      R4,#+0
   \      0x206   0xD01A             BEQ.N    ??mbedtls_ssl_encrypt_buf_17
   1249                      if (rec->data_offset < dynamic_iv_len) {
   \      0x208   0x6970             LDR      R0,[R6, #+20]
   \      0x20A   0x4558             CMP      R0,R11
   \      0x20C   0xD202             BCS.N    ??mbedtls_ssl_encrypt_buf_18
   1250                          MBEDTLS_SSL_DEBUG_MSG(1, ("Buffer provided for encrypted record not large enough"));
   1251                          return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   \      0x20E   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \      0x212   0xE0DB             B.N      ??mbedtls_ssl_encrypt_buf_1
   1252                      }
   1253          
   1254                      memcpy(data - dynamic_iv_len, dynamic_iv, dynamic_iv_len);
   \                     ??mbedtls_ssl_encrypt_buf_18: (+1)
   \      0x214   0xF8CD 0xB008      STR      R11,[SP, #+8]
   \      0x218   0x9809             LDR      R0,[SP, #+36]
   \      0x21A   0x9000             STR      R0,[SP, #+0]
   \      0x21C   0xF1DB 0x0000      RSBS     R0,R11,#+0
   \      0x220   0xEB08 0x0900      ADD      R9,R8,R0
   \      0x224   0x9A02             LDR      R2,[SP, #+8]
   \      0x226   0x9900             LDR      R1,[SP, #+0]
   \      0x228   0x4648             MOV      R0,R9
   \      0x22A   0x.... 0x....      BL       __aeabi_memcpy
   1255                      rec->data_offset -= dynamic_iv_len;
   \      0x22E   0x6970             LDR      R0,[R6, #+20]
   \      0x230   0xEBB0 0x000B      SUBS     R0,R0,R11
   \      0x234   0x6170             STR      R0,[R6, #+20]
   1256                      rec->data_len    += dynamic_iv_len;
   \      0x236   0x69B0             LDR      R0,[R6, #+24]
   \      0x238   0xEB1B 0x0000      ADDS     R0,R11,R0
   \      0x23C   0x61B0             STR      R0,[R6, #+24]
   1257                  }
   1258          
   1259                  auth_done++;
   \                     ??mbedtls_ssl_encrypt_buf_17: (+1)
   \      0x23E   0x1C7F             ADDS     R7,R7,#+1
   \      0x240   0xE0BE             B.N      ??mbedtls_ssl_encrypt_buf_19
   1260              } else
   1261          #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C || MBEDTLS_CHACHAPOLY_C */
   1262          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC)
   1263              if (ssl_mode == MBEDTLS_SSL_MODE_CBC ||
   1264                  ssl_mode == MBEDTLS_SSL_MODE_CBC_ETM) {
   \                     ??mbedtls_ssl_encrypt_buf_14: (+1)
   \      0x242   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \      0x246   0x2801             CMP      R0,#+1
   \      0x248   0xD004             BEQ.N    ??mbedtls_ssl_encrypt_buf_20
   \      0x24A   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \      0x24E   0x2802             CMP      R0,#+2
   \      0x250   0xF040 0x80B3      BNE.W    ??mbedtls_ssl_encrypt_buf_21
   1265                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_ssl_encrypt_buf_20: (+1)
   \      0x254   0xF07F 0x006D      MVNS     R0,#+109
   \      0x258   0x9000             STR      R0,[SP, #+0]
   1266                  size_t padlen, i;
   1267                  size_t olen;
   1268          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1269                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \      0x25A   0xF07F 0x0096      MVNS     R0,#+150
   \      0x25E   0x9002             STR      R0,[SP, #+8]
   1270                  size_t part_len;
   1271                  psa_cipher_operation_t cipher_op = PSA_CIPHER_OPERATION_INIT;
   \      0x260   0xA81C             ADD      R0,SP,#+112
   \      0x262   0x2198             MOVS     R1,#+152
   \      0x264   0x.... 0x....      BL       __aeabi_memclr4
   1272          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1273          
   1274                  /* Currently we're always using minimal padding
   1275                   * (up to 255 bytes would be allowed). */
   1276                  padlen = transform->ivlen - (rec->data_len + 1) % transform->ivlen;
   \      0x268   0x69B1             LDR      R1,[R6, #+24]
   \      0x26A   0x1C49             ADDS     R1,R1,#+1
   \      0x26C   0x6868             LDR      R0,[R5, #+4]
   \      0x26E   0xF8D5 0xB004      LDR      R11,[R5, #+4]
   \      0x272   0xEBBB 0x0B01      SUBS     R11,R11,R1
   \      0x276   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   \      0x27A   0xFB00 0xBB01      MLA      R11,R0,R1,R11
   1277                  if (padlen == transform->ivlen) {
   \      0x27E   0x6868             LDR      R0,[R5, #+4]
   \      0x280   0x4583             CMP      R11,R0
   \      0x282   0xD101             BNE.N    ??mbedtls_ssl_encrypt_buf_22
   1278                      padlen = 0;
   \      0x284   0x2000             MOVS     R0,#+0
   \      0x286   0x4683             MOV      R11,R0
   1279                  }
   1280          
   1281                  /* Check there's enough space in the buffer for the padding. */
   1282                  if (post_avail < padlen + 1) {
   \                     ??mbedtls_ssl_encrypt_buf_22: (+1)
   \      0x288   0xF11B 0x0001      ADDS     R0,R11,#+1
   \      0x28C   0x4581             CMP      R9,R0
   \      0x28E   0xD202             BCS.N    ??mbedtls_ssl_encrypt_buf_23
   1283                      MBEDTLS_SSL_DEBUG_MSG(1, ("Buffer provided for encrypted record not large enough"));
   1284                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   \      0x290   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \      0x294   0xE09A             B.N      ??mbedtls_ssl_encrypt_buf_1
   1285                  }
   1286          
   1287                  for (i = 0; i <= padlen; i++) {
   \                     ??mbedtls_ssl_encrypt_buf_23: (+1)
   \      0x296   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??mbedtls_ssl_encrypt_buf_24: (+1)
   \      0x29A   0x45D3             CMP      R11,R10
   \      0x29C   0xD307             BCC.N    ??mbedtls_ssl_encrypt_buf_25
   1288                      data[rec->data_len + i] = (unsigned char) padlen;
   \      0x29E   0x69B0             LDR      R0,[R6, #+24]
   \      0x2A0   0xEB1A 0x0000      ADDS     R0,R10,R0
   \      0x2A4   0xF808 0xB000      STRB     R11,[R8, R0]
   1289                  }
   \      0x2A8   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x2AC   0xE7F5             B.N      ??mbedtls_ssl_encrypt_buf_24
   1290          
   1291                  rec->data_len += padlen + 1;
   \                     ??mbedtls_ssl_encrypt_buf_25: (+1)
   \      0x2AE   0x69B0             LDR      R0,[R6, #+24]
   \      0x2B0   0xEB1B 0x0000      ADDS     R0,R11,R0
   \      0x2B4   0x1C40             ADDS     R0,R0,#+1
   \      0x2B6   0x61B0             STR      R0,[R6, #+24]
   1292                  post_avail -= padlen + 1;
   \      0x2B8   0xEBB9 0x090B      SUBS     R9,R9,R11
   \      0x2BC   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \      0x2C0   0xF8CD 0x9018      STR      R9,[SP, #+24]
   1293          
   1294          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1295                  /*
   1296                   * Prepend per-record IV for block cipher in TLS v1.2 as per
   1297                   * Method 1 (6.2.3.2. in RFC4346 and RFC5246)
   1298                   */
   1299                  if (f_rng == NULL) {
   \      0x2C4   0x989C             LDR      R0,[SP, #+624]
   \      0x2C6   0x2800             CMP      R0,#+0
   \      0x2C8   0xD102             BNE.N    ??mbedtls_ssl_encrypt_buf_26
   1300                      MBEDTLS_SSL_DEBUG_MSG(1, ("No PRNG provided to encrypt_record routine"));
   1301                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \      0x2CA   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x2CE   0xE07D             B.N      ??mbedtls_ssl_encrypt_buf_1
   1302                  }
   1303          
   1304                  if (rec->data_offset < transform->ivlen) {
   \                     ??mbedtls_ssl_encrypt_buf_26: (+1)
   \      0x2D0   0x6971             LDR      R1,[R6, #+20]
   \      0x2D2   0x6868             LDR      R0,[R5, #+4]
   \      0x2D4   0x4281             CMP      R1,R0
   \      0x2D6   0xD202             BCS.N    ??mbedtls_ssl_encrypt_buf_27
   1305                      MBEDTLS_SSL_DEBUG_MSG(1, ("Buffer provided for encrypted record not large enough"));
   1306                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   \      0x2D8   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \      0x2DC   0xE076             B.N      ??mbedtls_ssl_encrypt_buf_1
   1307                  }
   1308          
   1309                  /*
   1310                   * Generate IV
   1311                   */
   1312                  ret = f_rng(p_rng, transform->iv_enc, transform->ivlen);
   \                     ??mbedtls_ssl_encrypt_buf_27: (+1)
   \      0x2DE   0x686A             LDR      R2,[R5, #+4]
   \      0x2E0   0xF115 0x0114      ADDS     R1,R5,#+20
   \      0x2E4   0x98A6             LDR      R0,[SP, #+664]
   \      0x2E6   0x9B9C             LDR      R3,[SP, #+624]
   \      0x2E8   0x4798             BLX      R3
   \      0x2EA   0x4681             MOV      R9,R0
   1313                  if (ret != 0) {
   \      0x2EC   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x2F0   0xD001             BEQ.N    ??mbedtls_ssl_encrypt_buf_28
   1314                      return ret;
   \      0x2F2   0x4648             MOV      R0,R9
   \      0x2F4   0xE06A             B.N      ??mbedtls_ssl_encrypt_buf_1
   1315                  }
   1316          
   1317                  memcpy(data - transform->ivlen, transform->iv_enc, transform->ivlen);
   \                     ??mbedtls_ssl_encrypt_buf_28: (+1)
   \      0x2F6   0x6868             LDR      R0,[R5, #+4]
   \      0x2F8   0x9005             STR      R0,[SP, #+20]
   \      0x2FA   0xF115 0x0014      ADDS     R0,R5,#+20
   \      0x2FE   0x9000             STR      R0,[SP, #+0]
   \      0x300   0x6868             LDR      R0,[R5, #+4]
   \      0x302   0x4240             RSBS     R0,R0,#+0
   \      0x304   0xEB08 0x0400      ADD      R4,R8,R0
   \      0x308   0x9A05             LDR      R2,[SP, #+20]
   \      0x30A   0x9900             LDR      R1,[SP, #+0]
   \      0x30C   0x0020             MOVS     R0,R4
   \      0x30E   0x.... 0x....      BL       __aeabi_memcpy
   1318          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   1319          
   1320                  MBEDTLS_SSL_DEBUG_MSG(3, ("before encrypt: msglen = %" MBEDTLS_PRINTF_SIZET ", "
   1321                                                                                              "including %"
   1322                                            MBEDTLS_PRINTF_SIZET
   1323                                            " bytes of IV and %" MBEDTLS_PRINTF_SIZET " bytes of padding",
   1324                                            rec->data_len, transform->ivlen,
   1325                                            padlen + 1));
   1326          
   1327          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1328                  status = psa_cipher_encrypt_setup(&cipher_op,
   1329                                                    transform->psa_key_enc, transform->psa_alg);
   \      0x312   0x6CEA             LDR      R2,[R5, #+76]
   \      0x314   0x6C69             LDR      R1,[R5, #+68]
   \      0x316   0xA81C             ADD      R0,SP,#+112
   \      0x318   0x.... 0x....      BL       psa_cipher_encrypt_setup
   \      0x31C   0x0004             MOVS     R4,R0
   1330          
   1331                  if (status != PSA_SUCCESS) {
   \      0x31E   0x2C00             CMP      R4,#+0
   \      0x320   0xD003             BEQ.N    ??mbedtls_ssl_encrypt_buf_29
   1332                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x322   0x0020             MOVS     R0,R4
   \      0x324   0x.... 0x....      BL       local_err_translation
   1333                      MBEDTLS_SSL_DEBUG_RET(1, "psa_cipher_encrypt_setup", ret);
   1334                      return ret;
   \      0x328   0xE050             B.N      ??mbedtls_ssl_encrypt_buf_1
   1335                  }
   1336          
   1337                  status = psa_cipher_set_iv(&cipher_op, transform->iv_enc, transform->ivlen);
   \                     ??mbedtls_ssl_encrypt_buf_29: (+1)
   \      0x32A   0x686A             LDR      R2,[R5, #+4]
   \      0x32C   0xF115 0x0114      ADDS     R1,R5,#+20
   \      0x330   0xA81C             ADD      R0,SP,#+112
   \      0x332   0x.... 0x....      BL       psa_cipher_set_iv
   \      0x336   0x9002             STR      R0,[SP, #+8]
   1338          
   1339                  if (status != PSA_SUCCESS) {
   \      0x338   0x9802             LDR      R0,[SP, #+8]
   \      0x33A   0x2800             CMP      R0,#+0
   \      0x33C   0xD003             BEQ.N    ??mbedtls_ssl_encrypt_buf_30
   1340                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x33E   0x9802             LDR      R0,[SP, #+8]
   \      0x340   0x.... 0x....      BL       local_err_translation
   1341                      MBEDTLS_SSL_DEBUG_RET(1, "psa_cipher_set_iv", ret);
   1342                      return ret;
   \      0x344   0xE042             B.N      ??mbedtls_ssl_encrypt_buf_1
   1343          
   1344                  }
   1345          
   1346                  status = psa_cipher_update(&cipher_op,
   1347                                             data, rec->data_len,
   1348                                             data, rec->data_len, &olen);
   \                     ??mbedtls_ssl_encrypt_buf_30: (+1)
   \      0x346   0xA803             ADD      R0,SP,#+12
   \      0x348   0x9001             STR      R0,[SP, #+4]
   \      0x34A   0x69B0             LDR      R0,[R6, #+24]
   \      0x34C   0x9000             STR      R0,[SP, #+0]
   \      0x34E   0x4643             MOV      R3,R8
   \      0x350   0x69B2             LDR      R2,[R6, #+24]
   \      0x352   0x4641             MOV      R1,R8
   \      0x354   0xA81C             ADD      R0,SP,#+112
   \      0x356   0x.... 0x....      BL       psa_cipher_update
   \      0x35A   0x9002             STR      R0,[SP, #+8]
   1349          
   1350                  if (status != PSA_SUCCESS) {
   \      0x35C   0x9802             LDR      R0,[SP, #+8]
   \      0x35E   0x2800             CMP      R0,#+0
   \      0x360   0xD003             BEQ.N    ??mbedtls_ssl_encrypt_buf_31
   1351                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x362   0x9802             LDR      R0,[SP, #+8]
   \      0x364   0x.... 0x....      BL       local_err_translation
   1352                      MBEDTLS_SSL_DEBUG_RET(1, "psa_cipher_update", ret);
   1353                      return ret;
   \      0x368   0xE030             B.N      ??mbedtls_ssl_encrypt_buf_1
   1354          
   1355                  }
   1356          
   1357                  status = psa_cipher_finish(&cipher_op,
   1358                                             data + olen, rec->data_len - olen,
   1359                                             &part_len);
   \                     ??mbedtls_ssl_encrypt_buf_31: (+1)
   \      0x36A   0xAB04             ADD      R3,SP,#+16
   \      0x36C   0x69B2             LDR      R2,[R6, #+24]
   \      0x36E   0x9803             LDR      R0,[SP, #+12]
   \      0x370   0x1A12             SUBS     R2,R2,R0
   \      0x372   0x9803             LDR      R0,[SP, #+12]
   \      0x374   0xEB08 0x0100      ADD      R1,R8,R0
   \      0x378   0xA81C             ADD      R0,SP,#+112
   \      0x37A   0x.... 0x....      BL       psa_cipher_finish
   \      0x37E   0x0004             MOVS     R4,R0
   1360          
   1361                  if (status != PSA_SUCCESS) {
   \      0x380   0x2C00             CMP      R4,#+0
   \      0x382   0xD003             BEQ.N    ??mbedtls_ssl_encrypt_buf_32
   1362                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x384   0x0020             MOVS     R0,R4
   \      0x386   0x.... 0x....      BL       local_err_translation
   1363                      MBEDTLS_SSL_DEBUG_RET(1, "psa_cipher_finish", ret);
   1364                      return ret;
   \      0x38A   0xE01F             B.N      ??mbedtls_ssl_encrypt_buf_1
   1365          
   1366                  }
   1367          
   1368                  olen += part_len;
   \                     ??mbedtls_ssl_encrypt_buf_32: (+1)
   \      0x38C   0x9903             LDR      R1,[SP, #+12]
   \      0x38E   0x9804             LDR      R0,[SP, #+16]
   \      0x390   0x1841             ADDS     R1,R0,R1
   \      0x392   0x9103             STR      R1,[SP, #+12]
   1369          #else
   1370                  if ((ret = mbedtls_cipher_crypt(&transform->cipher_ctx_enc,
   1371                                                  transform->iv_enc,
   1372                                                  transform->ivlen,
   1373                                                  data, rec->data_len,
   1374                                                  data, &olen)) != 0) {
   1375                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_crypt", ret);
   1376                      return ret;
   1377                  }
   1378          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1379          
   1380                  if (rec->data_len != olen) {
   \      0x394   0x69B0             LDR      R0,[R6, #+24]
   \      0x396   0x9903             LDR      R1,[SP, #+12]
   \      0x398   0x4288             CMP      R0,R1
   \      0x39A   0xD002             BEQ.N    ??mbedtls_ssl_encrypt_buf_33
   1381                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   1382                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \      0x39C   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x3A0   0xE014             B.N      ??mbedtls_ssl_encrypt_buf_1
   1383                  }
   1384          
   1385                  data             -= transform->ivlen;
   \                     ??mbedtls_ssl_encrypt_buf_33: (+1)
   \      0x3A2   0x6868             LDR      R0,[R5, #+4]
   \      0x3A4   0x4240             RSBS     R0,R0,#+0
   \      0x3A6   0x4480             ADD      R8,R8,R0
   1386                  rec->data_offset -= transform->ivlen;
   \      0x3A8   0x6971             LDR      R1,[R6, #+20]
   \      0x3AA   0x6868             LDR      R0,[R5, #+4]
   \      0x3AC   0x1A09             SUBS     R1,R1,R0
   \      0x3AE   0x6171             STR      R1,[R6, #+20]
   1387                  rec->data_len    += transform->ivlen;
   \      0x3B0   0x69B1             LDR      R1,[R6, #+24]
   \      0x3B2   0x6868             LDR      R0,[R5, #+4]
   \      0x3B4   0x1841             ADDS     R1,R0,R1
   \      0x3B6   0x61B1             STR      R1,[R6, #+24]
   \      0x3B8   0xE002             B.N      ??mbedtls_ssl_encrypt_buf_19
   1388          
   1389          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1390                  if (auth_done == 0) {
   1391                      unsigned char mac[MBEDTLS_SSL_MAC_ADD];
   1392          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1393                      psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;
   1394                      size_t sign_mac_length = 0;
   1395          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1396          
   1397                      /* MAC(MAC_write_key, add_data, IV, ENC(content + padding + padding_length))
   1398                       */
   1399          
   1400                      if (post_avail < transform->maclen) {
   1401                          MBEDTLS_SSL_DEBUG_MSG(1, ("Buffer provided for encrypted record not large enough"));
   1402                          return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   1403                      }
   1404          
   1405                      ssl_extract_add_data_from_record(add_data, &add_data_len,
   1406                                                       rec, transform->tls_version,
   1407                                                       transform->taglen);
   1408          
   1409                      MBEDTLS_SSL_DEBUG_MSG(3, ("using encrypt then mac"));
   1410                      MBEDTLS_SSL_DEBUG_BUF(4, "MAC'd meta-data", add_data,
   1411                                            add_data_len);
   1412          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1413                      status = psa_mac_sign_setup(&operation, transform->psa_mac_enc,
   1414                                                  transform->psa_mac_alg);
   1415                      if (status != PSA_SUCCESS) {
   1416                          goto hmac_failed_etm_enabled;
   1417                      }
   1418          
   1419                      status = psa_mac_update(&operation, add_data, add_data_len);
   1420                      if (status != PSA_SUCCESS) {
   1421                          goto hmac_failed_etm_enabled;
   1422                      }
   1423          
   1424                      status = psa_mac_update(&operation, data, rec->data_len);
   1425                      if (status != PSA_SUCCESS) {
   1426                          goto hmac_failed_etm_enabled;
   1427                      }
   1428          
   1429                      status = psa_mac_sign_finish(&operation, mac, MBEDTLS_SSL_MAC_ADD,
   1430                                                   &sign_mac_length);
   1431                      if (status != PSA_SUCCESS) {
   1432                          goto hmac_failed_etm_enabled;
   1433                      }
   1434          #else
   1435          
   1436                      ret = mbedtls_md_hmac_update(&transform->md_ctx_enc, add_data,
   1437                                                   add_data_len);
   1438                      if (ret != 0) {
   1439                          goto hmac_failed_etm_enabled;
   1440                      }
   1441                      ret = mbedtls_md_hmac_update(&transform->md_ctx_enc,
   1442                                                   data, rec->data_len);
   1443                      if (ret != 0) {
   1444                          goto hmac_failed_etm_enabled;
   1445                      }
   1446                      ret = mbedtls_md_hmac_finish(&transform->md_ctx_enc, mac);
   1447                      if (ret != 0) {
   1448                          goto hmac_failed_etm_enabled;
   1449                      }
   1450                      ret = mbedtls_md_hmac_reset(&transform->md_ctx_enc);
   1451                      if (ret != 0) {
   1452                          goto hmac_failed_etm_enabled;
   1453                      }
   1454          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1455          
   1456                      memcpy(data + rec->data_len, mac, transform->maclen);
   1457          
   1458                      rec->data_len += transform->maclen;
   1459                      post_avail -= transform->maclen;
   1460                      auth_done++;
   1461          
   1462          hmac_failed_etm_enabled:
   1463                      mbedtls_platform_zeroize(mac, transform->maclen);
   1464          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1465                      ret = PSA_TO_MBEDTLS_ERR(status);
   1466                      status = psa_mac_abort(&operation);
   1467                      if (ret == 0 && status != PSA_SUCCESS) {
   1468                          ret = PSA_TO_MBEDTLS_ERR(status);
   1469                      }
   1470          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1471                      if (ret != 0) {
   1472                          MBEDTLS_SSL_DEBUG_RET(1, "HMAC calculation failed", ret);
   1473                          return ret;
   1474                      }
   1475                  }
   1476          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   1477              } else
   1478          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC) */
   1479              {
   1480                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   1481                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \                     ??mbedtls_ssl_encrypt_buf_21: (+1)
   \      0x3BA   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x3BE   0xE005             B.N      ??mbedtls_ssl_encrypt_buf_1
   1482              }
   1483          
   1484              /* Make extra sure authentication was performed, exactly once */
   1485              if (auth_done != 1) {
   \                     ??mbedtls_ssl_encrypt_buf_19: (+1)
   \      0x3C0   0x2F01             CMP      R7,#+1
   \      0x3C2   0xD002             BEQ.N    ??mbedtls_ssl_encrypt_buf_34
   1486                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   1487                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \      0x3C4   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x3C8   0xE000             B.N      ??mbedtls_ssl_encrypt_buf_1
   1488              }
   1489          
   1490              MBEDTLS_SSL_DEBUG_MSG(2, ("<= encrypt buf"));
   1491          
   1492              return 0;
   \                     ??mbedtls_ssl_encrypt_buf_34: (+1)
   \      0x3CA   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_encrypt_buf_1: (+1)
   \      0x3CC   0xF50D 0x7D1D      ADD      SP,SP,#+628
   \      0x3D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1493          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0
   \        0x6                      DS8 2
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 344

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0
   \        0x6                      DS8 2
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 140
   1494          

   \                                 In section .text, align 2, keep-with-next
   1495          int mbedtls_ssl_decrypt_buf(mbedtls_ssl_context const *ssl,
   1496                                      mbedtls_ssl_transform *transform,
   1497                                      mbedtls_record *rec)
   1498          {
   \                     mbedtls_ssl_decrypt_buf: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB0CC             SUB      SP,SP,#+304
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x0014             MOVS     R4,R2
   1499          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC) || defined(MBEDTLS_CIPHER_MODE_AEAD)
   1500              size_t olen;
   1501          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC || MBEDTLS_CIPHER_MODE_AEAD */
   1502              mbedtls_ssl_mode_t ssl_mode;
   1503              int ret;
   1504          
   1505              int auth_done = 0;
   \        0xC   0x2500             MOVS     R5,#+0
   1506          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
   1507              size_t padlen = 0;
   \        0xE   0x2600             MOVS     R6,#+0
   1508              mbedtls_ct_condition_t correct = MBEDTLS_CT_TRUE;
   \       0x10   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x14   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x18   0x0007             MOVS     R7,R0
   1509          #endif
   1510              unsigned char *data;
   1511              /* For an explanation of the additional data length see
   1512               * the description of ssl_extract_add_data_from_record().
   1513               */
   1514          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   1515              unsigned char add_data[23 + MBEDTLS_SSL_CID_IN_LEN_MAX];
   1516          #else
   1517              unsigned char add_data[13];
   1518          #endif
   1519              size_t add_data_len;
   1520          
   1521          #if !defined(MBEDTLS_DEBUG_C)
   1522              ssl = NULL; /* make sure we don't use it except for debug */
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9015             STR      R0,[SP, #+84]
   1523              ((void) ssl);
   1524          #endif
   1525          
   1526              MBEDTLS_SSL_DEBUG_MSG(2, ("=> decrypt buf"));
   1527              if (rec == NULL                     ||
   1528                  rec->buf == NULL                ||
   1529                  rec->buf_len < rec->data_offset ||
   1530                  rec->buf_len - rec->data_offset < rec->data_len) {
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD00C             BEQ.N    ??mbedtls_ssl_decrypt_buf_0
   \       0x22   0x68E0             LDR      R0,[R4, #+12]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD009             BEQ.N    ??mbedtls_ssl_decrypt_buf_0
   \       0x28   0x6921             LDR      R1,[R4, #+16]
   \       0x2A   0x6960             LDR      R0,[R4, #+20]
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD305             BCC.N    ??mbedtls_ssl_decrypt_buf_0
   \       0x30   0x6921             LDR      R1,[R4, #+16]
   \       0x32   0x6960             LDR      R0,[R4, #+20]
   \       0x34   0x1A09             SUBS     R1,R1,R0
   \       0x36   0x69A0             LDR      R0,[R4, #+24]
   \       0x38   0x4281             CMP      R1,R0
   \       0x3A   0xD202             BCS.N    ??mbedtls_ssl_decrypt_buf_1
   1531                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad record structure provided to decrypt_buf"));
   1532                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \                     ??mbedtls_ssl_decrypt_buf_0: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x40   0xE202             B.N      ??mbedtls_ssl_decrypt_buf_2
   1533              }
   1534          
   1535              data = rec->buf + rec->data_offset;
   \                     ??mbedtls_ssl_decrypt_buf_1: (+1)
   \       0x42   0x68E0             LDR      R0,[R4, #+12]
   \       0x44   0x6961             LDR      R1,[R4, #+20]
   \       0x46   0xEB00 0x0801      ADD      R8,R0,R1
   1536              ssl_mode = mbedtls_ssl_get_mode_from_transform(transform);
   \       0x4A   0x4648             MOV      R0,R9
   \       0x4C   0x.... 0x....      BL       mbedtls_ssl_get_mode_from_transform
   \       0x50   0xF88D 0x001C      STRB     R0,[SP, #+28]
   1537          
   1538          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   1539              /*
   1540               * Match record's CID with incoming CID.
   1541               */
   1542              if (rec->cid_len != transform->in_cid_len ||
   1543                  memcmp(rec->cid, transform->in_cid, rec->cid_len) != 0) {
   1544                  return MBEDTLS_ERR_SSL_UNEXPECTED_CID;
   1545              }
   1546          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   1547          
   1548          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_STREAM)
   1549              if (ssl_mode == MBEDTLS_SSL_MODE_STREAM) {
   1550                  if (rec->data_len < transform->maclen) {
   1551                      MBEDTLS_SSL_DEBUG_MSG(1,
   1552                                            ("Record too short for MAC:"
   1553                                             " %" MBEDTLS_PRINTF_SIZET " < %" MBEDTLS_PRINTF_SIZET,
   1554                                             rec->data_len, transform->maclen));
   1555                      return MBEDTLS_ERR_SSL_INVALID_MAC;
   1556                  }
   1557          
   1558                  /* The only supported stream cipher is "NULL",
   1559                   * so there's no encryption to do here.*/
   1560              } else
   1561          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_STREAM */
   1562          #if defined(MBEDTLS_GCM_C) || \
   1563              defined(MBEDTLS_CCM_C) || \
   1564              defined(MBEDTLS_CHACHAPOLY_C)
   1565              if (ssl_mode == MBEDTLS_SSL_MODE_AEAD) {
   \       0x54   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \       0x58   0x2803             CMP      R0,#+3
   \       0x5A   0xD16E             BNE.N    ??mbedtls_ssl_decrypt_buf_3
   1566                  unsigned char iv[12];
   1567                  unsigned char *dynamic_iv;
   1568                  size_t dynamic_iv_len;
   1569          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1570                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x5C   0xF07F 0x0096      MVNS     R0,#+150
   \       0x60   0x900C             STR      R0,[SP, #+48]
   1571          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1572          
   1573                  /*
   1574                   * Extract dynamic part of nonce for AEAD decryption.
   1575                   *
   1576                   * Note: In the case of CCM and GCM in TLS 1.2, the dynamic
   1577                   *       part of the IV is prepended to the ciphertext and
   1578                   *       can be chosen freely - in particular, it need not
   1579                   *       agree with the record sequence number.
   1580                   */
   1581                  dynamic_iv_len = sizeof(rec->ctr);
   \       0x62   0xF05F 0x0B08      MOVS     R11,#+8
   1582                  if (ssl_transform_aead_dynamic_iv_is_explicit(transform) == 1) {
   \       0x66   0x4648             MOV      R0,R9
   \       0x68   0x.... 0x....      BL       ssl_transform_aead_dynamic_iv_is_explicit
   \       0x6C   0x2801             CMP      R0,#+1
   \       0x6E   0xD111             BNE.N    ??mbedtls_ssl_decrypt_buf_4
   1583                      if (rec->data_len < dynamic_iv_len) {
   \       0x70   0x69A0             LDR      R0,[R4, #+24]
   \       0x72   0x4558             CMP      R0,R11
   \       0x74   0xD202             BCS.N    ??mbedtls_ssl_decrypt_buf_5
   1584                          MBEDTLS_SSL_DEBUG_MSG(1, ("msglen (%" MBEDTLS_PRINTF_SIZET
   1585                                                    " ) < explicit_iv_len (%" MBEDTLS_PRINTF_SIZET ") ",
   1586                                                    rec->data_len,
   1587                                                    dynamic_iv_len));
   1588                          return MBEDTLS_ERR_SSL_INVALID_MAC;
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0x7A   0xE1E5             B.N      ??mbedtls_ssl_decrypt_buf_2
   1589                      }
   1590                      dynamic_iv = data;
   \                     ??mbedtls_ssl_decrypt_buf_5: (+1)
   \       0x7C   0xF8CD 0x802C      STR      R8,[SP, #+44]
   1591          
   1592                      data += dynamic_iv_len;
   \       0x80   0x44D8             ADD      R8,R8,R11
   1593                      rec->data_offset += dynamic_iv_len;
   \       0x82   0x6960             LDR      R0,[R4, #+20]
   \       0x84   0xEB1B 0x0000      ADDS     R0,R11,R0
   \       0x88   0x6160             STR      R0,[R4, #+20]
   1594                      rec->data_len    -= dynamic_iv_len;
   \       0x8A   0x69A0             LDR      R0,[R4, #+24]
   \       0x8C   0xEBB0 0x000B      SUBS     R0,R0,R11
   \       0x90   0x61A0             STR      R0,[R4, #+24]
   \       0x92   0xE000             B.N      ??mbedtls_ssl_decrypt_buf_6
   1595                  } else {
   1596                      dynamic_iv = rec->ctr;
   \                     ??mbedtls_ssl_decrypt_buf_4: (+1)
   \       0x94   0x940B             STR      R4,[SP, #+44]
   1597                  }
   1598          
   1599                  /* Check that there's space for the authentication tag. */
   1600                  if (rec->data_len < transform->taglen) {
   \                     ??mbedtls_ssl_decrypt_buf_6: (+1)
   \       0x96   0x69A1             LDR      R1,[R4, #+24]
   \       0x98   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x9C   0x4281             CMP      R1,R0
   \       0x9E   0xD202             BCS.N    ??mbedtls_ssl_decrypt_buf_7
   1601                      MBEDTLS_SSL_DEBUG_MSG(1, ("msglen (%" MBEDTLS_PRINTF_SIZET
   1602                                                ") < taglen (%" MBEDTLS_PRINTF_SIZET ") ",
   1603                                                rec->data_len,
   1604                                                transform->taglen));
   1605                      return MBEDTLS_ERR_SSL_INVALID_MAC;
   \       0xA0   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0xA4   0xE1D0             B.N      ??mbedtls_ssl_decrypt_buf_2
   1606                  }
   1607                  rec->data_len -= transform->taglen;
   \                     ??mbedtls_ssl_decrypt_buf_7: (+1)
   \       0xA6   0x69A1             LDR      R1,[R4, #+24]
   \       0xA8   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0xAC   0x1A09             SUBS     R1,R1,R0
   \       0xAE   0x61A1             STR      R1,[R4, #+24]
   1608          
   1609                  /*
   1610                   * Prepare nonce from dynamic and static parts.
   1611                   */
   1612                  ssl_build_record_nonce(iv, sizeof(iv),
   1613                                         transform->iv_dec,
   1614                                         transform->fixed_ivlen,
   1615                                         dynamic_iv,
   1616                                         dynamic_iv_len);
   \       0xB0   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \       0xB4   0x980B             LDR      R0,[SP, #+44]
   \       0xB6   0x9000             STR      R0,[SP, #+0]
   \       0xB8   0xF8D9 0x3008      LDR      R3,[R9, #+8]
   \       0xBC   0xF119 0x0224      ADDS     R2,R9,#+36
   \       0xC0   0x210C             MOVS     R1,#+12
   \       0xC2   0xA80E             ADD      R0,SP,#+56
   \       0xC4   0x.... 0x....      BL       ssl_build_record_nonce
   1617          
   1618                  /*
   1619                   * Build additional data for AEAD encryption.
   1620                   * This depends on the TLS version.
   1621                   */
   1622                  ssl_extract_add_data_from_record(add_data, &add_data_len, rec,
   1623                                                   transform->tls_version,
   1624                                                   transform->taglen);
   \       0xC8   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0xCC   0x9000             STR      R0,[SP, #+0]
   \       0xCE   0xF9B9 0x3040      LDRSH    R3,[R9, #+64]
   \       0xD2   0x0022             MOVS     R2,R4
   \       0xD4   0xA909             ADD      R1,SP,#+36
   \       0xD6   0xA811             ADD      R0,SP,#+68
   \       0xD8   0x.... 0x....      BL       ssl_extract_add_data_from_record
   1625                  MBEDTLS_SSL_DEBUG_BUF(4, "additional data used for AEAD",
   1626                                        add_data, add_data_len);
   1627          
   1628                  /* Because of the check above, we know that there are
   1629                   * explicit_iv_len Bytes preceding data, and taglen
   1630                   * bytes following data + data_len. This justifies
   1631                   * the debug message and the invocation of
   1632                   * mbedtls_cipher_auth_decrypt_ext() below. */
   1633          
   1634                  MBEDTLS_SSL_DEBUG_BUF(4, "IV used", iv, transform->ivlen);
   1635                  MBEDTLS_SSL_DEBUG_BUF(4, "TAG used", data + rec->data_len,
   1636                                        transform->taglen);
   1637          
   1638                  /*
   1639                   * Decrypt and authenticate
   1640                   */
   1641          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1642                  status = psa_aead_decrypt(transform->psa_key_dec,
   1643                                            transform->psa_alg,
   1644                                            iv, transform->ivlen,
   1645                                            add_data, add_data_len,
   1646                                            data, rec->data_len + transform->taglen,
   1647                                            data, rec->buf_len - (data - rec->buf),
   1648                                            &olen);
   \       0xDC   0xA808             ADD      R0,SP,#+32
   \       0xDE   0x9006             STR      R0,[SP, #+24]
   \       0xE0   0x6921             LDR      R1,[R4, #+16]
   \       0xE2   0xEBB1 0x0108      SUBS     R1,R1,R8
   \       0xE6   0x68E0             LDR      R0,[R4, #+12]
   \       0xE8   0x1841             ADDS     R1,R0,R1
   \       0xEA   0x9105             STR      R1,[SP, #+20]
   \       0xEC   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0xF0   0x69A1             LDR      R1,[R4, #+24]
   \       0xF2   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0xF6   0x1841             ADDS     R1,R0,R1
   \       0xF8   0x9103             STR      R1,[SP, #+12]
   \       0xFA   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0xFE   0x9809             LDR      R0,[SP, #+36]
   \      0x100   0x9001             STR      R0,[SP, #+4]
   \      0x102   0xA811             ADD      R0,SP,#+68
   \      0x104   0x9000             STR      R0,[SP, #+0]
   \      0x106   0xF8D9 0x3004      LDR      R3,[R9, #+4]
   \      0x10A   0xAA0E             ADD      R2,SP,#+56
   \      0x10C   0xF8D9 0x104C      LDR      R1,[R9, #+76]
   \      0x110   0xF8D9 0x0048      LDR      R0,[R9, #+72]
   \      0x114   0x.... 0x....      BL       psa_aead_decrypt
   \      0x118   0x4682             MOV      R10,R0
   1649          
   1650                  if (status != PSA_SUCCESS) {
   \      0x11A   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x11E   0xD003             BEQ.N    ??mbedtls_ssl_decrypt_buf_8
   1651                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x120   0x4650             MOV      R0,R10
   \      0x122   0x.... 0x....      BL       local_err_translation
   1652                      MBEDTLS_SSL_DEBUG_RET(1, "psa_aead_decrypt", ret);
   1653                      return ret;
   \      0x126   0xE18F             B.N      ??mbedtls_ssl_decrypt_buf_2
   1654                  }
   1655          #else
   1656                  if ((ret = mbedtls_cipher_auth_decrypt_ext(&transform->cipher_ctx_dec,
   1657                                                             iv, transform->ivlen,
   1658                                                             add_data, add_data_len,
   1659                                                             data, rec->data_len + transform->taglen, /* src */
   1660                                                             data, rec->buf_len - (data - rec->buf), &olen, /* dst */
   1661                                                             transform->taglen)) != 0) {
   1662                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_auth_decrypt_ext", ret);
   1663          
   1664                      if (ret == MBEDTLS_ERR_CIPHER_AUTH_FAILED) {
   1665                          return MBEDTLS_ERR_SSL_INVALID_MAC;
   1666                      }
   1667          
   1668                      return ret;
   1669                  }
   1670          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1671          
   1672                  auth_done++;
   \                     ??mbedtls_ssl_decrypt_buf_8: (+1)
   \      0x128   0x1C6D             ADDS     R5,R5,#+1
   1673          
   1674                  /* Double-check that AEAD decryption doesn't change content length. */
   1675                  if (olen != rec->data_len) {
   \      0x12A   0x9908             LDR      R1,[SP, #+32]
   \      0x12C   0x69A0             LDR      R0,[R4, #+24]
   \      0x12E   0x4281             CMP      R1,R0
   \      0x130   0xF000 0x8113      BEQ.W    ??mbedtls_ssl_decrypt_buf_9
   1676                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   1677                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \      0x134   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x138   0xE186             B.N      ??mbedtls_ssl_decrypt_buf_2
   1678                  }
   1679              } else
   1680          #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C */
   1681          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC)
   1682              if (ssl_mode == MBEDTLS_SSL_MODE_CBC ||
   1683                  ssl_mode == MBEDTLS_SSL_MODE_CBC_ETM) {
   \                     ??mbedtls_ssl_decrypt_buf_3: (+1)
   \      0x13A   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \      0x13E   0x2801             CMP      R0,#+1
   \      0x140   0xD004             BEQ.N    ??mbedtls_ssl_decrypt_buf_10
   \      0x142   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \      0x146   0x2802             CMP      R0,#+2
   \      0x148   0xF040 0x8104      BNE.W    ??mbedtls_ssl_decrypt_buf_11
   1684                  size_t minlen = 0;
   \                     ??mbedtls_ssl_decrypt_buf_10: (+1)
   \      0x14C   0xF05F 0x0B00      MOVS     R11,#+0
   1685          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1686                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \      0x150   0xF07F 0x0A96      MVNS     R10,#+150
   1687                  size_t part_len;
   1688                  psa_cipher_operation_t cipher_op = PSA_CIPHER_OPERATION_INIT;
   \      0x154   0xA826             ADD      R0,SP,#+152
   \      0x156   0x2198             MOVS     R1,#+152
   \      0x158   0x.... 0x....      BL       __aeabi_memclr4
   1689          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1690          
   1691                  /*
   1692                   * Check immediate ciphertext sanity
   1693                   */
   1694          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1695                  /* The ciphertext is prefixed with the CBC IV. */
   1696                  minlen += transform->ivlen;
   \      0x15C   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x160   0xEB10 0x0B0B      ADDS     R11,R0,R11
   \      0x164   0xF8CD 0xB010      STR      R11,[SP, #+16]
   1697          #endif
   1698          
   1699                  /* Size considerations:
   1700                   *
   1701                   * - The CBC cipher text must not be empty and hence
   1702                   *   at least of size transform->ivlen.
   1703                   *
   1704                   * Together with the potential IV-prefix, this explains
   1705                   * the first of the two checks below.
   1706                   *
   1707                   * - The record must contain a MAC, either in plain or
   1708                   *   encrypted, depending on whether Encrypt-then-MAC
   1709                   *   is used or not.
   1710                   *   - If it is, the message contains the IV-prefix,
   1711                   *     the CBC ciphertext, and the MAC.
   1712                   *   - If it is not, the padded plaintext, and hence
   1713                   *     the CBC ciphertext, has at least length maclen + 1
   1714                   *     because there is at least the padding length byte.
   1715                   *
   1716                   * As the CBC ciphertext is not empty, both cases give the
   1717                   * lower bound minlen + maclen + 1 on the record size, which
   1718                   * we test for in the second check below.
   1719                   */
   1720                  if (rec->data_len < minlen + transform->ivlen ||
   1721                      rec->data_len < minlen + transform->maclen + 1) {
   \      0x168   0x69A2             LDR      R2,[R4, #+24]
   \      0x16A   0x9904             LDR      R1,[SP, #+16]
   \      0x16C   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x170   0x1841             ADDS     R1,R0,R1
   \      0x172   0x428A             CMP      R2,R1
   \      0x174   0xD307             BCC.N    ??mbedtls_ssl_decrypt_buf_12
   \      0x176   0x69A2             LDR      R2,[R4, #+24]
   \      0x178   0x9904             LDR      R1,[SP, #+16]
   \      0x17A   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \      0x17E   0x1841             ADDS     R1,R0,R1
   \      0x180   0x1C49             ADDS     R1,R1,#+1
   \      0x182   0x428A             CMP      R2,R1
   \      0x184   0xD202             BCS.N    ??mbedtls_ssl_decrypt_buf_13
   1722                      MBEDTLS_SSL_DEBUG_MSG(1, ("msglen (%" MBEDTLS_PRINTF_SIZET
   1723                                                ") < max( ivlen(%" MBEDTLS_PRINTF_SIZET
   1724                                                "), maclen (%" MBEDTLS_PRINTF_SIZET ") "
   1725                                                                                    "+ 1 ) ( + expl IV )",
   1726                                                rec->data_len,
   1727                                                transform->ivlen,
   1728                                                transform->maclen));
   1729                      return MBEDTLS_ERR_SSL_INVALID_MAC;
   \                     ??mbedtls_ssl_decrypt_buf_12: (+1)
   \      0x186   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x18A   0xE15D             B.N      ??mbedtls_ssl_decrypt_buf_2
   1730                  }
   1731          
   1732                  /*
   1733                   * Authenticate before decrypt if enabled
   1734                   */
   1735          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1736                  if (ssl_mode == MBEDTLS_SSL_MODE_CBC_ETM) {
   1737          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1738                      psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;
   1739          #else
   1740                      unsigned char mac_expect[MBEDTLS_SSL_MAC_ADD];
   1741          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1742          
   1743                      MBEDTLS_SSL_DEBUG_MSG(3, ("using encrypt then mac"));
   1744          
   1745                      /* Update data_len in tandem with add_data.
   1746                       *
   1747                       * The subtraction is safe because of the previous check
   1748                       * data_len >= minlen + maclen + 1.
   1749                       *
   1750                       * Afterwards, we know that data + data_len is followed by at
   1751                       * least maclen Bytes, which justifies the call to
   1752                       * mbedtls_ct_memcmp() below.
   1753                       *
   1754                       * Further, we still know that data_len > minlen */
   1755                      rec->data_len -= transform->maclen;
   1756                      ssl_extract_add_data_from_record(add_data, &add_data_len, rec,
   1757                                                       transform->tls_version,
   1758                                                       transform->taglen);
   1759          
   1760                      /* Calculate expected MAC. */
   1761                      MBEDTLS_SSL_DEBUG_BUF(4, "MAC'd meta-data", add_data,
   1762                                            add_data_len);
   1763          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1764                      status = psa_mac_verify_setup(&operation, transform->psa_mac_dec,
   1765                                                    transform->psa_mac_alg);
   1766                      if (status != PSA_SUCCESS) {
   1767                          goto hmac_failed_etm_enabled;
   1768                      }
   1769          
   1770                      status = psa_mac_update(&operation, add_data, add_data_len);
   1771                      if (status != PSA_SUCCESS) {
   1772                          goto hmac_failed_etm_enabled;
   1773                      }
   1774          
   1775                      status = psa_mac_update(&operation, data, rec->data_len);
   1776                      if (status != PSA_SUCCESS) {
   1777                          goto hmac_failed_etm_enabled;
   1778                      }
   1779          
   1780                      /* Compare expected MAC with MAC at the end of the record. */
   1781                      status = psa_mac_verify_finish(&operation, data + rec->data_len,
   1782                                                     transform->maclen);
   1783                      if (status != PSA_SUCCESS) {
   1784                          goto hmac_failed_etm_enabled;
   1785                      }
   1786          #else
   1787                      ret = mbedtls_md_hmac_update(&transform->md_ctx_dec, add_data,
   1788                                                   add_data_len);
   1789                      if (ret != 0) {
   1790                          goto hmac_failed_etm_enabled;
   1791                      }
   1792                      ret = mbedtls_md_hmac_update(&transform->md_ctx_dec,
   1793                                                   data, rec->data_len);
   1794                      if (ret != 0) {
   1795                          goto hmac_failed_etm_enabled;
   1796                      }
   1797                      ret = mbedtls_md_hmac_finish(&transform->md_ctx_dec, mac_expect);
   1798                      if (ret != 0) {
   1799                          goto hmac_failed_etm_enabled;
   1800                      }
   1801                      ret = mbedtls_md_hmac_reset(&transform->md_ctx_dec);
   1802                      if (ret != 0) {
   1803                          goto hmac_failed_etm_enabled;
   1804                      }
   1805          
   1806                      MBEDTLS_SSL_DEBUG_BUF(4, "message  mac", data + rec->data_len,
   1807                                            transform->maclen);
   1808                      MBEDTLS_SSL_DEBUG_BUF(4, "expected mac", mac_expect,
   1809                                            transform->maclen);
   1810          
   1811                      /* Compare expected MAC with MAC at the end of the record. */
   1812                      if (mbedtls_ct_memcmp(data + rec->data_len, mac_expect,
   1813                                            transform->maclen) != 0) {
   1814                          MBEDTLS_SSL_DEBUG_MSG(1, ("message mac does not match"));
   1815                          ret = MBEDTLS_ERR_SSL_INVALID_MAC;
   1816                          goto hmac_failed_etm_enabled;
   1817                      }
   1818          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1819                      auth_done++;
   1820          
   1821          hmac_failed_etm_enabled:
   1822          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1823                      ret = PSA_TO_MBEDTLS_ERR(status);
   1824                      status = psa_mac_abort(&operation);
   1825                      if (ret == 0 && status != PSA_SUCCESS) {
   1826                          ret = PSA_TO_MBEDTLS_ERR(status);
   1827                      }
   1828          #else
   1829                      mbedtls_platform_zeroize(mac_expect, transform->maclen);
   1830          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1831                      if (ret != 0) {
   1832                          if (ret != MBEDTLS_ERR_SSL_INVALID_MAC) {
   1833                              MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_hmac_xxx", ret);
   1834                          }
   1835                          return ret;
   1836                      }
   1837                  }
   1838          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   1839          
   1840                  /*
   1841                   * Check length sanity
   1842                   */
   1843          
   1844                  /* We know from above that data_len > minlen >= 0,
   1845                   * so the following check in particular implies that
   1846                   * data_len >= minlen + ivlen ( = minlen or 2 * minlen ). */
   1847                  if (rec->data_len % transform->ivlen != 0) {
   \                     ??mbedtls_ssl_decrypt_buf_13: (+1)
   \      0x18C   0x69A0             LDR      R0,[R4, #+24]
   \      0x18E   0xF8D9 0x2004      LDR      R2,[R9, #+4]
   \      0x192   0xFBB0 0xF1F2      UDIV     R1,R0,R2
   \      0x196   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \      0x19A   0x2800             CMP      R0,#+0
   \      0x19C   0xD002             BEQ.N    ??mbedtls_ssl_decrypt_buf_14
   1848                      MBEDTLS_SSL_DEBUG_MSG(1, ("msglen (%" MBEDTLS_PRINTF_SIZET
   1849                                                ") %% ivlen (%" MBEDTLS_PRINTF_SIZET ") != 0",
   1850                                                rec->data_len, transform->ivlen));
   1851                      return MBEDTLS_ERR_SSL_INVALID_MAC;
   \      0x19E   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x1A2   0xE151             B.N      ??mbedtls_ssl_decrypt_buf_2
   1852                  }
   1853          
   1854          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1855                  /*
   1856                   * Initialize for prepended IV for block cipher in TLS v1.2
   1857                   */
   1858                  /* Safe because data_len >= minlen + ivlen = 2 * ivlen. */
   1859                  memcpy(transform->iv_dec, data, transform->ivlen);
   \                     ??mbedtls_ssl_decrypt_buf_14: (+1)
   \      0x1A4   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x1A8   0x9001             STR      R0,[SP, #+4]
   \      0x1AA   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x1AE   0xF119 0x0B24      ADDS     R11,R9,#+36
   \      0x1B2   0x9A01             LDR      R2,[SP, #+4]
   \      0x1B4   0x9900             LDR      R1,[SP, #+0]
   \      0x1B6   0x4658             MOV      R0,R11
   \      0x1B8   0x.... 0x....      BL       __aeabi_memcpy
   1860          
   1861                  data += transform->ivlen;
   \      0x1BC   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x1C0   0x4480             ADD      R8,R8,R0
   1862                  rec->data_offset += transform->ivlen;
   \      0x1C2   0x6961             LDR      R1,[R4, #+20]
   \      0x1C4   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x1C8   0x1841             ADDS     R1,R0,R1
   \      0x1CA   0x6161             STR      R1,[R4, #+20]
   1863                  rec->data_len -= transform->ivlen;
   \      0x1CC   0x69A1             LDR      R1,[R4, #+24]
   \      0x1CE   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x1D2   0x1A09             SUBS     R1,R1,R0
   \      0x1D4   0x61A1             STR      R1,[R4, #+24]
   1864          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   1865          
   1866                  /* We still have data_len % ivlen == 0 and data_len >= ivlen here. */
   1867          
   1868          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1869                  status = psa_cipher_decrypt_setup(&cipher_op,
   1870                                                    transform->psa_key_dec, transform->psa_alg);
   \      0x1D6   0xF8D9 0x204C      LDR      R2,[R9, #+76]
   \      0x1DA   0xF8D9 0x1048      LDR      R1,[R9, #+72]
   \      0x1DE   0xA826             ADD      R0,SP,#+152
   \      0x1E0   0x.... 0x....      BL       psa_cipher_decrypt_setup
   \      0x1E4   0x4683             MOV      R11,R0
   1871          
   1872                  if (status != PSA_SUCCESS) {
   \      0x1E6   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x1EA   0xD003             BEQ.N    ??mbedtls_ssl_decrypt_buf_15
   1873                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x1EC   0x4658             MOV      R0,R11
   \      0x1EE   0x.... 0x....      BL       local_err_translation
   1874                      MBEDTLS_SSL_DEBUG_RET(1, "psa_cipher_decrypt_setup", ret);
   1875                      return ret;
   \      0x1F2   0xE129             B.N      ??mbedtls_ssl_decrypt_buf_2
   1876                  }
   1877          
   1878                  status = psa_cipher_set_iv(&cipher_op, transform->iv_dec, transform->ivlen);
   \                     ??mbedtls_ssl_decrypt_buf_15: (+1)
   \      0x1F4   0xF8D9 0x2004      LDR      R2,[R9, #+4]
   \      0x1F8   0xF119 0x0124      ADDS     R1,R9,#+36
   \      0x1FC   0xA826             ADD      R0,SP,#+152
   \      0x1FE   0x.... 0x....      BL       psa_cipher_set_iv
   \      0x202   0x4682             MOV      R10,R0
   1879          
   1880                  if (status != PSA_SUCCESS) {
   \      0x204   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x208   0xD003             BEQ.N    ??mbedtls_ssl_decrypt_buf_16
   1881                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x20A   0x4650             MOV      R0,R10
   \      0x20C   0x.... 0x....      BL       local_err_translation
   1882                      MBEDTLS_SSL_DEBUG_RET(1, "psa_cipher_set_iv", ret);
   1883                      return ret;
   \      0x210   0xE11A             B.N      ??mbedtls_ssl_decrypt_buf_2
   1884                  }
   1885          
   1886                  status = psa_cipher_update(&cipher_op,
   1887                                             data, rec->data_len,
   1888                                             data, rec->data_len, &olen);
   \                     ??mbedtls_ssl_decrypt_buf_16: (+1)
   \      0x212   0xA808             ADD      R0,SP,#+32
   \      0x214   0x9001             STR      R0,[SP, #+4]
   \      0x216   0x69A0             LDR      R0,[R4, #+24]
   \      0x218   0x9000             STR      R0,[SP, #+0]
   \      0x21A   0x4643             MOV      R3,R8
   \      0x21C   0x69A2             LDR      R2,[R4, #+24]
   \      0x21E   0x4641             MOV      R1,R8
   \      0x220   0xA826             ADD      R0,SP,#+152
   \      0x222   0x.... 0x....      BL       psa_cipher_update
   \      0x226   0x4683             MOV      R11,R0
   1889          
   1890                  if (status != PSA_SUCCESS) {
   \      0x228   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x22C   0xD003             BEQ.N    ??mbedtls_ssl_decrypt_buf_17
   1891                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x22E   0x4658             MOV      R0,R11
   \      0x230   0x.... 0x....      BL       local_err_translation
   1892                      MBEDTLS_SSL_DEBUG_RET(1, "psa_cipher_update", ret);
   1893                      return ret;
   \      0x234   0xE108             B.N      ??mbedtls_ssl_decrypt_buf_2
   1894                  }
   1895          
   1896                  status = psa_cipher_finish(&cipher_op,
   1897                                             data + olen, rec->data_len - olen,
   1898                                             &part_len);
   \                     ??mbedtls_ssl_decrypt_buf_17: (+1)
   \      0x236   0xAB03             ADD      R3,SP,#+12
   \      0x238   0x69A2             LDR      R2,[R4, #+24]
   \      0x23A   0x9808             LDR      R0,[SP, #+32]
   \      0x23C   0x1A12             SUBS     R2,R2,R0
   \      0x23E   0x9808             LDR      R0,[SP, #+32]
   \      0x240   0xEB08 0x0100      ADD      R1,R8,R0
   \      0x244   0xA826             ADD      R0,SP,#+152
   \      0x246   0x.... 0x....      BL       psa_cipher_finish
   \      0x24A   0x9002             STR      R0,[SP, #+8]
   1899          
   1900                  if (status != PSA_SUCCESS) {
   \      0x24C   0x9802             LDR      R0,[SP, #+8]
   \      0x24E   0x2800             CMP      R0,#+0
   \      0x250   0xD003             BEQ.N    ??mbedtls_ssl_decrypt_buf_18
   1901                      ret = PSA_TO_MBEDTLS_ERR(status);
   \      0x252   0x9802             LDR      R0,[SP, #+8]
   \      0x254   0x.... 0x....      BL       local_err_translation
   1902                      MBEDTLS_SSL_DEBUG_RET(1, "psa_cipher_finish", ret);
   1903                      return ret;
   \      0x258   0xE0F6             B.N      ??mbedtls_ssl_decrypt_buf_2
   1904                  }
   1905          
   1906                  olen += part_len;
   \                     ??mbedtls_ssl_decrypt_buf_18: (+1)
   \      0x25A   0x9908             LDR      R1,[SP, #+32]
   \      0x25C   0x9803             LDR      R0,[SP, #+12]
   \      0x25E   0x1841             ADDS     R1,R0,R1
   \      0x260   0x9108             STR      R1,[SP, #+32]
   1907          #else
   1908          
   1909                  if ((ret = mbedtls_cipher_crypt(&transform->cipher_ctx_dec,
   1910                                                  transform->iv_dec, transform->ivlen,
   1911                                                  data, rec->data_len, data, &olen)) != 0) {
   1912                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_crypt", ret);
   1913                      return ret;
   1914                  }
   1915          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1916          
   1917                  /* Double-check that length hasn't changed during decryption. */
   1918                  if (rec->data_len != olen) {
   \      0x262   0x69A0             LDR      R0,[R4, #+24]
   \      0x264   0x9908             LDR      R1,[SP, #+32]
   \      0x266   0x4288             CMP      R0,R1
   \      0x268   0xD002             BEQ.N    ??mbedtls_ssl_decrypt_buf_19
   1919                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   1920                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \      0x26A   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x26E   0xE0EB             B.N      ??mbedtls_ssl_decrypt_buf_2
   1921                  }
   1922          
   1923                  /* Safe since data_len >= minlen + maclen + 1, so after having
   1924                   * subtracted at most minlen and maclen up to this point,
   1925                   * data_len > 0 (because of data_len % ivlen == 0, it's actually
   1926                   * >= ivlen ). */
   1927                  padlen = data[rec->data_len - 1];
   \                     ??mbedtls_ssl_decrypt_buf_19: (+1)
   \      0x270   0x69A0             LDR      R0,[R4, #+24]
   \      0x272   0x4440             ADD      R0,R8,R0
   \      0x274   0xF810 0xAC01      LDRB     R10,[R0, #-1]
   1928          
   1929                  if (auth_done == 1) {
   \      0x278   0x2D01             CMP      R5,#+1
   \      0x27A   0xD10F             BNE.N    ??mbedtls_ssl_decrypt_buf_20
   1930                      const mbedtls_ct_condition_t ge = mbedtls_ct_uint_ge(
   1931                          rec->data_len,
   1932                          padlen + 1);
   \      0x27C   0xF11A 0x0101      ADDS     R1,R10,#+1
   \      0x280   0x69A0             LDR      R0,[R4, #+24]
   \      0x282   0x.... 0x....      BL       mbedtls_ct_uint_ge
   \      0x286   0x0006             MOVS     R6,R0
   1933                      correct = mbedtls_ct_bool_and(ge, correct);
   \      0x288   0x0039             MOVS     R1,R7
   \      0x28A   0x0030             MOVS     R0,R6
   \      0x28C   0x.... 0x....      BL       mbedtls_ct_bool_and
   \      0x290   0x9005             STR      R0,[SP, #+20]
   1934                      padlen  = mbedtls_ct_size_if_else_0(ge, padlen);
   \      0x292   0x4651             MOV      R1,R10
   \      0x294   0x0030             MOVS     R0,R6
   \      0x296   0x.... 0x....      BL       mbedtls_ct_size_if_else_0
   \      0x29A   0xE011             B.N      ??mbedtls_ssl_decrypt_buf_21
   1935                  } else {
   1936          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   1937                      if (rec->data_len < transform->maclen + padlen + 1) {
   1938                          MBEDTLS_SSL_DEBUG_MSG(1, ("msglen (%" MBEDTLS_PRINTF_SIZET
   1939                                                    ") < maclen (%" MBEDTLS_PRINTF_SIZET
   1940                                                    ") + padlen (%" MBEDTLS_PRINTF_SIZET ")",
   1941                                                    rec->data_len,
   1942                                                    transform->maclen,
   1943                                                    padlen + 1));
   1944                      }
   1945          #endif
   1946                      const mbedtls_ct_condition_t ge = mbedtls_ct_uint_ge(
   1947                          rec->data_len,
   1948                          transform->maclen + padlen + 1);
   \                     ??mbedtls_ssl_decrypt_buf_20: (+1)
   \      0x29C   0xF8D9 0x100C      LDR      R1,[R9, #+12]
   \      0x2A0   0xEB1A 0x0101      ADDS     R1,R10,R1
   \      0x2A4   0x1C49             ADDS     R1,R1,#+1
   \      0x2A6   0x69A0             LDR      R0,[R4, #+24]
   \      0x2A8   0x.... 0x....      BL       mbedtls_ct_uint_ge
   \      0x2AC   0x0006             MOVS     R6,R0
   1949                      correct = mbedtls_ct_bool_and(ge, correct);
   \      0x2AE   0x0039             MOVS     R1,R7
   \      0x2B0   0x0030             MOVS     R0,R6
   \      0x2B2   0x.... 0x....      BL       mbedtls_ct_bool_and
   \      0x2B6   0x9005             STR      R0,[SP, #+20]
   1950                      padlen  = mbedtls_ct_size_if_else_0(ge, padlen);
   \      0x2B8   0x4651             MOV      R1,R10
   \      0x2BA   0x0030             MOVS     R0,R6
   \      0x2BC   0x.... 0x....      BL       mbedtls_ct_size_if_else_0
   1951                  }
   1952          
   1953                  padlen++;
   \                     ??mbedtls_ssl_decrypt_buf_21: (+1)
   \      0x2C0   0x1C40             ADDS     R0,R0,#+1
   \      0x2C2   0x9000             STR      R0,[SP, #+0]
   1954          
   1955                  /* Regardless of the validity of the padding,
   1956                   * we have data_len >= padlen here. */
   1957          
   1958          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1959                  /* The padding check involves a series of up to 256
   1960                   * consecutive memory reads at the end of the record
   1961                   * plaintext buffer. In order to hide the length and
   1962                   * validity of the padding, always perform exactly
   1963                   * `min(256,plaintext_len)` reads (but take into account
   1964                   * only the last `padlen` bytes for the padding check). */
   1965                  size_t pad_count = 0;
   \      0x2C4   0xF05F 0x0B00      MOVS     R11,#+0
   1966                  volatile unsigned char * const check = data;
   \      0x2C8   0xF8CD 0x8034      STR      R8,[SP, #+52]
   1967          
   1968                  /* Index of first padding byte; it has been ensured above
   1969                   * that the subtraction is safe. */
   1970                  size_t const padding_idx = rec->data_len - padlen;
   \      0x2CC   0x69A1             LDR      R1,[R4, #+24]
   \      0x2CE   0x9800             LDR      R0,[SP, #+0]
   \      0x2D0   0x1A09             SUBS     R1,R1,R0
   \      0x2D2   0x910C             STR      R1,[SP, #+48]
   1971                  size_t const num_checks = rec->data_len <= 256 ? rec->data_len : 256;
   \      0x2D4   0x69A0             LDR      R0,[R4, #+24]
   \      0x2D6   0xF240 0x1101      MOVW     R1,#+257
   \      0x2DA   0x4288             CMP      R0,R1
   \      0x2DC   0xD202             BCS.N    ??mbedtls_ssl_decrypt_buf_22
   \      0x2DE   0x69A0             LDR      R0,[R4, #+24]
   \      0x2E0   0x9001             STR      R0,[SP, #+4]
   \      0x2E2   0xE002             B.N      ??mbedtls_ssl_decrypt_buf_23
   \                     ??mbedtls_ssl_decrypt_buf_22: (+1)
   \      0x2E4   0xF44F 0x7080      MOV      R0,#+256
   \      0x2E8   0x9001             STR      R0,[SP, #+4]
   1972                  size_t const start_idx = rec->data_len - num_checks;
   \                     ??mbedtls_ssl_decrypt_buf_23: (+1)
   \      0x2EA   0x69A1             LDR      R1,[R4, #+24]
   \      0x2EC   0x9801             LDR      R0,[SP, #+4]
   \      0x2EE   0x1A09             SUBS     R1,R1,R0
   \      0x2F0   0x910B             STR      R1,[SP, #+44]
   1973                  size_t idx;
   1974          
   1975                  for (idx = start_idx; idx < rec->data_len; idx++) {
   \      0x2F2   0xF8DD 0xA02C      LDR      R10,[SP, #+44]
   \                     ??mbedtls_ssl_decrypt_buf_24: (+1)
   \      0x2F6   0x69A0             LDR      R0,[R4, #+24]
   \      0x2F8   0x4582             CMP      R10,R0
   \      0x2FA   0xD21A             BCS.N    ??mbedtls_ssl_decrypt_buf_25
   1976                      /* pad_count += (idx >= padding_idx) &&
   1977                       *              (check[idx] == padlen - 1);
   1978                       */
   1979                      const mbedtls_ct_condition_t a = mbedtls_ct_uint_ge(idx, padding_idx);
   \      0x2FC   0x990C             LDR      R1,[SP, #+48]
   \      0x2FE   0x4650             MOV      R0,R10
   \      0x300   0x.... 0x....      BL       mbedtls_ct_uint_ge
   \      0x304   0x9006             STR      R0,[SP, #+24]
   1980                      size_t increment = mbedtls_ct_size_if_else_0(a, 1);
   \      0x306   0x2101             MOVS     R1,#+1
   \      0x308   0x9806             LDR      R0,[SP, #+24]
   \      0x30A   0x.... 0x....      BL       mbedtls_ct_size_if_else_0
   \      0x30E   0x0007             MOVS     R7,R0
   1981                      const mbedtls_ct_condition_t b = mbedtls_ct_uint_eq(check[idx], padlen - 1);
   \      0x310   0x9900             LDR      R1,[SP, #+0]
   \      0x312   0x1E49             SUBS     R1,R1,#+1
   \      0x314   0x980D             LDR      R0,[SP, #+52]
   \      0x316   0xF810 0x000A      LDRB     R0,[R0, R10]
   \      0x31A   0x.... 0x....      BL       mbedtls_ct_uint_eq
   \      0x31E   0x0006             MOVS     R6,R0
   1982                      increment = mbedtls_ct_size_if_else_0(b, increment);
   \      0x320   0x0039             MOVS     R1,R7
   \      0x322   0x0030             MOVS     R0,R6
   \      0x324   0x.... 0x....      BL       mbedtls_ct_size_if_else_0
   1983                      pad_count += increment;
   \      0x328   0xEB10 0x0B0B      ADDS     R11,R0,R11
   1984                  }
   \      0x32C   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x330   0xE7E1             B.N      ??mbedtls_ssl_decrypt_buf_24
   1985                  correct = mbedtls_ct_bool_and(mbedtls_ct_uint_eq(pad_count, padlen), correct);
   \                     ??mbedtls_ssl_decrypt_buf_25: (+1)
   \      0x332   0x9900             LDR      R1,[SP, #+0]
   \      0x334   0x4658             MOV      R0,R11
   \      0x336   0x.... 0x....      BL       mbedtls_ct_uint_eq
   \      0x33A   0x9905             LDR      R1,[SP, #+20]
   \      0x33C   0x.... 0x....      BL       mbedtls_ct_bool_and
   \      0x340   0x0007             MOVS     R7,R0
   1986          
   1987          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   1988                  if (padlen > 0 && correct == MBEDTLS_CT_FALSE) {
   1989                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad padding byte detected"));
   1990                  }
   1991          #endif
   1992                  padlen = mbedtls_ct_size_if_else_0(correct, padlen);
   \      0x342   0x9900             LDR      R1,[SP, #+0]
   \      0x344   0x0038             MOVS     R0,R7
   \      0x346   0x.... 0x....      BL       mbedtls_ct_size_if_else_0
   \      0x34A   0x0006             MOVS     R6,R0
   1993          
   1994          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   1995          
   1996                  /* If the padding was found to be invalid, padlen == 0
   1997                   * and the subtraction is safe. If the padding was found valid,
   1998                   * padlen hasn't been changed and the previous assertion
   1999                   * data_len >= padlen still holds. */
   2000                  rec->data_len -= padlen;
   \      0x34C   0x69A0             LDR      R0,[R4, #+24]
   \      0x34E   0x1B80             SUBS     R0,R0,R6
   \      0x350   0x61A0             STR      R0,[R4, #+24]
   \      0x352   0xE002             B.N      ??mbedtls_ssl_decrypt_buf_9
   2001              } else
   2002          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC */
   2003              {
   2004                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2005                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \                     ??mbedtls_ssl_decrypt_buf_11: (+1)
   \      0x354   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x358   0xE076             B.N      ??mbedtls_ssl_decrypt_buf_2
   2006              }
   2007          
   2008          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   2009              MBEDTLS_SSL_DEBUG_BUF(4, "raw buffer after decryption",
   2010                                    data, rec->data_len);
   2011          #endif
   2012          
   2013              /*
   2014               * Authenticate if not done yet.
   2015               * Compute the MAC regardless of the padding result (RFC4346, CBCTIME).
   2016               */
   2017          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
   2018              if (auth_done == 0) {
   \                     ??mbedtls_ssl_decrypt_buf_9: (+1)
   \      0x35A   0x2D00             CMP      R5,#+0
   \      0x35C   0xD166             BNE.N    ??mbedtls_ssl_decrypt_buf_26
   \      0x35E   0x2120             MOVS     R1,#+32
   \      0x360   0x2200             MOVS     R2,#+0
   \      0x362   0xF10D 0x0A78      ADD      R10,SP,#+120
   \      0x366   0x4650             MOV      R0,R10
   \      0x368   0x.... 0x....      BL       __aeabi_memset
   \      0x36C   0x2120             MOVS     R1,#+32
   \      0x36E   0x2200             MOVS     R2,#+0
   \      0x370   0xF10D 0x0A58      ADD      R10,SP,#+88
   \      0x374   0x4650             MOV      R0,R10
   \      0x376   0x.... 0x....      BL       __aeabi_memset
   2019                  unsigned char mac_expect[MBEDTLS_SSL_MAC_ADD] = { 0 };
   2020                  unsigned char mac_peer[MBEDTLS_SSL_MAC_ADD] = { 0 };
   2021          
   2022                  /* For CBC+MAC, If the initial value of padlen was such that
   2023                   * data_len < maclen + padlen + 1, then padlen
   2024                   * got reset to 1, and the initial check
   2025                   * data_len >= minlen + maclen + 1
   2026                   * guarantees that at this point we still
   2027                   * have at least data_len >= maclen.
   2028                   *
   2029                   * If the initial value of padlen was such that
   2030                   * data_len >= maclen + padlen + 1, then we have
   2031                   * subtracted either padlen + 1 (if the padding was correct)
   2032                   * or 0 (if the padding was incorrect) since then,
   2033                   * hence data_len >= maclen in any case.
   2034                   *
   2035                   * For stream ciphers, we checked above that
   2036                   * data_len >= maclen.
   2037                   */
   2038                  rec->data_len -= transform->maclen;
   \      0x37A   0x69A1             LDR      R1,[R4, #+24]
   \      0x37C   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \      0x380   0x1A09             SUBS     R1,R1,R0
   \      0x382   0x61A1             STR      R1,[R4, #+24]
   2039                  ssl_extract_add_data_from_record(add_data, &add_data_len, rec,
   2040                                                   transform->tls_version,
   2041                                                   transform->taglen);
   \      0x384   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \      0x388   0x9000             STR      R0,[SP, #+0]
   \      0x38A   0xF9B9 0x3040      LDRSH    R3,[R9, #+64]
   \      0x38E   0x0022             MOVS     R2,R4
   \      0x390   0xA909             ADD      R1,SP,#+36
   \      0x392   0xA811             ADD      R0,SP,#+68
   \      0x394   0x.... 0x....      BL       ssl_extract_add_data_from_record
   2042          
   2043          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   2044                  /*
   2045                   * The next two sizes are the minimum and maximum values of
   2046                   * data_len over all padlen values.
   2047                   *
   2048                   * They're independent of padlen, since we previously did
   2049                   * data_len -= padlen.
   2050                   *
   2051                   * Note that max_len + maclen is never more than the buffer
   2052                   * length, as we previously did in_msglen -= maclen too.
   2053                   */
   2054                  const size_t max_len = rec->data_len + padlen;
   \      0x398   0xF8D4 0xB018      LDR      R11,[R4, #+24]
   \      0x39C   0xEB16 0x0B0B      ADDS     R11,R6,R11
   2055                  const size_t min_len = (max_len > 256) ? max_len - 256 : 0;
   \      0x3A0   0xF240 0x1001      MOVW     R0,#+257
   \      0x3A4   0x4583             CMP      R11,R0
   \      0x3A6   0xD302             BCC.N    ??mbedtls_ssl_decrypt_buf_27
   \      0x3A8   0xF5BB 0x7A80      SUBS     R10,R11,#+256
   \      0x3AC   0xE001             B.N      ??mbedtls_ssl_decrypt_buf_28
   \                     ??mbedtls_ssl_decrypt_buf_27: (+1)
   \      0x3AE   0xF05F 0x0A00      MOVS     R10,#+0
   2056          
   2057          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2058                  ret = mbedtls_ct_hmac(transform->psa_mac_dec,
   2059                                        transform->psa_mac_alg,
   2060                                        add_data, add_data_len,
   2061                                        data, rec->data_len, min_len, max_len,
   2062                                        mac_expect);
   \                     ??mbedtls_ssl_decrypt_buf_28: (+1)
   \      0x3B2   0xA81E             ADD      R0,SP,#+120
   \      0x3B4   0x9004             STR      R0,[SP, #+16]
   \      0x3B6   0xF8CD 0xB00C      STR      R11,[SP, #+12]
   \      0x3BA   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \      0x3BE   0x69A0             LDR      R0,[R4, #+24]
   \      0x3C0   0x9001             STR      R0,[SP, #+4]
   \      0x3C2   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x3C6   0x9B09             LDR      R3,[SP, #+36]
   \      0x3C8   0xAA11             ADD      R2,SP,#+68
   \      0x3CA   0xF8D9 0x103C      LDR      R1,[R9, #+60]
   \      0x3CE   0xF8D9 0x0038      LDR      R0,[R9, #+56]
   \      0x3D2   0x.... 0x....      BL       mbedtls_ct_hmac
   \      0x3D6   0x900A             STR      R0,[SP, #+40]
   2063          #else
   2064                  ret = mbedtls_ct_hmac(&transform->md_ctx_dec,
   2065                                        add_data, add_data_len,
   2066                                        data, rec->data_len, min_len, max_len,
   2067                                        mac_expect);
   2068          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2069                  if (ret != 0) {
   \      0x3D8   0x980A             LDR      R0,[SP, #+40]
   \      0x3DA   0x2800             CMP      R0,#+0
   \      0x3DC   0xD117             BNE.N    ??mbedtls_ssl_decrypt_buf_29
   2070                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ct_hmac", ret);
   2071                      goto hmac_failed_etm_disabled;
   2072                  }
   2073          
   2074                  mbedtls_ct_memcpy_offset(mac_peer, data,
   2075                                           rec->data_len,
   2076                                           min_len, max_len,
   2077                                           transform->maclen);
   \                     ??mbedtls_ssl_decrypt_buf_30: (+1)
   \      0x3DE   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \      0x3E2   0x9001             STR      R0,[SP, #+4]
   \      0x3E4   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \      0x3E8   0x4653             MOV      R3,R10
   \      0x3EA   0x69A2             LDR      R2,[R4, #+24]
   \      0x3EC   0x4641             MOV      R1,R8
   \      0x3EE   0xA816             ADD      R0,SP,#+88
   \      0x3F0   0x.... 0x....      BL       mbedtls_ct_memcpy_offset
   2078          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   2079          
   2080          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   2081                  MBEDTLS_SSL_DEBUG_BUF(4, "expected mac", mac_expect, transform->maclen);
   2082                  MBEDTLS_SSL_DEBUG_BUF(4, "message  mac", mac_peer, transform->maclen);
   2083          #endif
   2084          
   2085                  if (mbedtls_ct_memcmp(mac_peer, mac_expect,
   2086                                        transform->maclen) != 0) {
   \      0x3F4   0xF8D9 0x200C      LDR      R2,[R9, #+12]
   \      0x3F8   0xA91E             ADD      R1,SP,#+120
   \      0x3FA   0xA816             ADD      R0,SP,#+88
   \      0x3FC   0x.... 0x....      BL       mbedtls_ct_memcmp
   \      0x400   0x2800             CMP      R0,#+0
   \      0x402   0xD003             BEQ.N    ??mbedtls_ssl_decrypt_buf_31
   2087          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   2088                      MBEDTLS_SSL_DEBUG_MSG(1, ("message mac does not match"));
   2089          #endif
   2090                      correct = MBEDTLS_CT_FALSE;
   \      0x404   0x2000             MOVS     R0,#+0
   \      0x406   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \      0x40A   0x0007             MOVS     R7,R0
   2091                  }
   2092                  auth_done++;
   \                     ??mbedtls_ssl_decrypt_buf_31: (+1)
   \      0x40C   0x1C6D             ADDS     R5,R5,#+1
   2093          
   2094          hmac_failed_etm_disabled:
   2095                  mbedtls_platform_zeroize(mac_peer, transform->maclen);
   \                     ??mbedtls_ssl_decrypt_buf_29: (+1)
   \      0x40E   0xF8D9 0x100C      LDR      R1,[R9, #+12]
   \      0x412   0xA816             ADD      R0,SP,#+88
   \      0x414   0x.... 0x....      BL       mbedtls_platform_zeroize
   2096                  mbedtls_platform_zeroize(mac_expect, transform->maclen);
   \      0x418   0xF8D9 0x100C      LDR      R1,[R9, #+12]
   \      0x41C   0xA81E             ADD      R0,SP,#+120
   \      0x41E   0x.... 0x....      BL       mbedtls_platform_zeroize
   2097                  if (ret != 0) {
   \      0x422   0x980A             LDR      R0,[SP, #+40]
   \      0x424   0x2800             CMP      R0,#+0
   \      0x426   0xD001             BEQ.N    ??mbedtls_ssl_decrypt_buf_26
   2098                      return ret;
   \      0x428   0x980A             LDR      R0,[SP, #+40]
   \      0x42A   0xE00D             B.N      ??mbedtls_ssl_decrypt_buf_2
   2099                  }
   2100              }
   2101          
   2102              /*
   2103               * Finally check the correct flag
   2104               */
   2105              if (correct == MBEDTLS_CT_FALSE) {
   \                     ??mbedtls_ssl_decrypt_buf_26: (+1)
   \      0x42C   0x2000             MOVS     R0,#+0
   \      0x42E   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \      0x432   0x4287             CMP      R7,R0
   \      0x434   0xD102             BNE.N    ??mbedtls_ssl_decrypt_buf_32
   2106                  return MBEDTLS_ERR_SSL_INVALID_MAC;
   \      0x436   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x43A   0xE005             B.N      ??mbedtls_ssl_decrypt_buf_2
   2107              }
   2108          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_MAC */
   2109          
   2110              /* Make extra sure authentication was performed, exactly once */
   2111              if (auth_done != 1) {
   \                     ??mbedtls_ssl_decrypt_buf_32: (+1)
   \      0x43C   0x2D01             CMP      R5,#+1
   \      0x43E   0xD002             BEQ.N    ??mbedtls_ssl_decrypt_buf_33
   2112                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2113                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \      0x440   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x444   0xE000             B.N      ??mbedtls_ssl_decrypt_buf_2
   2114              }
   2115          
   2116          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   2117              if (transform->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
   2118                  /* Remove inner padding and infer true content type. */
   2119                  ret = ssl_parse_inner_plaintext(data, &rec->data_len,
   2120                                                  &rec->type);
   2121          
   2122                  if (ret != 0) {
   2123                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   2124                  }
   2125              }
   2126          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   2127          
   2128          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   2129              if (rec->cid_len != 0) {
   2130                  ret = ssl_parse_inner_plaintext(data, &rec->data_len,
   2131                                                  &rec->type);
   2132                  if (ret != 0) {
   2133                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   2134                  }
   2135              }
   2136          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   2137          
   2138              MBEDTLS_SSL_DEBUG_MSG(2, ("<= decrypt buf"));
   2139          
   2140              return 0;
   \                     ??mbedtls_ssl_decrypt_buf_33: (+1)
   \      0x446   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_decrypt_buf_2: (+1)
   \      0x448   0xB04D             ADD      SP,SP,#+308
   \      0x44A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2141          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0
   \        0x6                      DS8 2
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 140
   2142          
   2143          #undef MAC_NONE
   2144          #undef MAC_PLAINTEXT
   2145          #undef MAC_CIPHERTEXT
   2146          
   2147          /*
   2148           * Fill the input message buffer by appending data to it.
   2149           * The amount of data already fetched is in ssl->in_left.
   2150           *
   2151           * If we return 0, is it guaranteed that (at least) nb_want bytes are
   2152           * available (from this read and/or a previous one). Otherwise, an error code
   2153           * is returned (possibly EOF or WANT_READ).
   2154           *
   2155           * With stream transport (TLS) on success ssl->in_left == nb_want, but
   2156           * with datagram transport (DTLS) on success ssl->in_left >= nb_want,
   2157           * since we always read a whole datagram at once.
   2158           *
   2159           * For DTLS, it is up to the caller to set ssl->next_record_offset when
   2160           * they're done reading a record.
   2161           */

   \                                 In section .text, align 2, keep-with-next
   2162          int mbedtls_ssl_fetch_input(mbedtls_ssl_context *ssl, size_t nb_want)
   2163          {
   \                     mbedtls_ssl_fetch_input: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   2164              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x046D      MVNS     R4,#+109
   2165              size_t len;
   2166          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   2167              size_t in_buf_len = ssl->in_buf_len;
   2168          #else
   2169              size_t in_buf_len = MBEDTLS_SSL_IN_BUFFER_LEN;
   \        0xC   0xF240 0x473D      MOVW     R7,#+1085
   2170          #endif
   2171          
   2172              MBEDTLS_SSL_DEBUG_MSG(2, ("=> fetch input"));
   2173          
   2174              if (ssl->f_recv == NULL && ssl->f_recv_timeout == NULL) {
   \       0x10   0x69E8             LDR      R0,[R5, #+28]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD105             BNE.N    ??mbedtls_ssl_fetch_input_0
   \       0x16   0x6A28             LDR      R0,[R5, #+32]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD102             BNE.N    ??mbedtls_ssl_fetch_input_0
   2175                  MBEDTLS_SSL_DEBUG_MSG(1, ("Bad usage of mbedtls_ssl_set_bio() "));
   2176                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x20   0xE041             B.N      ??mbedtls_ssl_fetch_input_1
   2177              }
   2178          
   2179              if (nb_want > in_buf_len - (size_t) (ssl->in_hdr - ssl->in_buf)) {
   \                     ??mbedtls_ssl_fetch_input_0: (+1)
   \       0x22   0x6E29             LDR      R1,[R5, #+96]
   \       0x24   0x1A79             SUBS     R1,R7,R1
   \       0x26   0x6DA8             LDR      R0,[R5, #+88]
   \       0x28   0x1841             ADDS     R1,R0,R1
   \       0x2A   0x42B1             CMP      R1,R6
   \       0x2C   0xD202             BCS.N    ??mbedtls_ssl_fetch_input_2
   2180                  MBEDTLS_SSL_DEBUG_MSG(1, ("requesting more data than fits"));
   2181                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x32   0xE038             B.N      ??mbedtls_ssl_fetch_input_1
   2182              }
   2183          
   2184          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2185              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   2186                  uint32_t timeout;
   2187          
   2188                  /*
   2189                   * The point is, we need to always read a full datagram at once, so we
   2190                   * sometimes read more then requested, and handle the additional data.
   2191                   * It could be the rest of the current record (while fetching the
   2192                   * header) and/or some other records in the same datagram.
   2193                   */
   2194          
   2195                  /*
   2196                   * Move to the next record in the already read datagram if applicable
   2197                   */
   2198                  if (ssl->next_record_offset != 0) {
   2199                      if (ssl->in_left < ssl->next_record_offset) {
   2200                          MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2201                          return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2202                      }
   2203          
   2204                      ssl->in_left -= ssl->next_record_offset;
   2205          
   2206                      if (ssl->in_left != 0) {
   2207                          MBEDTLS_SSL_DEBUG_MSG(2, ("next record in same datagram, offset: %"
   2208                                                    MBEDTLS_PRINTF_SIZET,
   2209                                                    ssl->next_record_offset));
   2210                          memmove(ssl->in_hdr,
   2211                                  ssl->in_hdr + ssl->next_record_offset,
   2212                                  ssl->in_left);
   2213                      }
   2214          
   2215                      ssl->next_record_offset = 0;
   2216                  }
   2217          
   2218                  MBEDTLS_SSL_DEBUG_MSG(2, ("in_left: %" MBEDTLS_PRINTF_SIZET
   2219                                            ", nb_want: %" MBEDTLS_PRINTF_SIZET,
   2220                                            ssl->in_left, nb_want));
   2221          
   2222                  /*
   2223                   * Done if we already have enough data.
   2224                   */
   2225                  if (nb_want <= ssl->in_left) {
   2226                      MBEDTLS_SSL_DEBUG_MSG(2, ("<= fetch input"));
   2227                      return 0;
   2228                  }
   2229          
   2230                  /*
   2231                   * A record can't be split across datagrams. If we need to read but
   2232                   * are not at the beginning of a new record, the caller did something
   2233                   * wrong.
   2234                   */
   2235                  if (ssl->in_left != 0) {
   2236                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2237                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2238                  }
   2239          
   2240                  /*
   2241                   * Don't even try to read if time's out already.
   2242                   * This avoids by-passing the timer when repeatedly receiving messages
   2243                   * that will end up being dropped.
   2244                   */
   2245                  if (mbedtls_ssl_check_timer(ssl) != 0) {
   2246                      MBEDTLS_SSL_DEBUG_MSG(2, ("timer has expired"));
   2247                      ret = MBEDTLS_ERR_SSL_TIMEOUT;
   2248                  } else {
   2249                      len = in_buf_len - (ssl->in_hdr - ssl->in_buf);
   2250          
   2251                      if (mbedtls_ssl_is_handshake_over(ssl) == 0) {
   2252                          timeout = ssl->handshake->retransmit_timeout;
   2253                      } else {
   2254                          timeout = ssl->conf->read_timeout;
   2255                      }
   2256          
   2257                      MBEDTLS_SSL_DEBUG_MSG(3, ("f_recv_timeout: %lu ms", (unsigned long) timeout));
   2258          
   2259                      if (ssl->f_recv_timeout != NULL) {
   2260                          ret = ssl->f_recv_timeout(ssl->p_bio, ssl->in_hdr, len,
   2261                                                    timeout);
   2262                      } else {
   2263                          ret = ssl->f_recv(ssl->p_bio, ssl->in_hdr, len);
   2264                      }
   2265          
   2266                      MBEDTLS_SSL_DEBUG_RET(2, "ssl->f_recv(_timeout)", ret);
   2267          
   2268                      if (ret == 0) {
   2269                          return MBEDTLS_ERR_SSL_CONN_EOF;
   2270                      }
   2271                  }
   2272          
   2273                  if (ret == MBEDTLS_ERR_SSL_TIMEOUT) {
   2274                      MBEDTLS_SSL_DEBUG_MSG(2, ("timeout"));
   2275                      mbedtls_ssl_set_timer(ssl, 0);
   2276          
   2277                      if (ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER) {
   2278                          if (ssl_double_retransmit_timeout(ssl) != 0) {
   2279                              MBEDTLS_SSL_DEBUG_MSG(1, ("handshake timeout"));
   2280                              return MBEDTLS_ERR_SSL_TIMEOUT;
   2281                          }
   2282          
   2283                          if ((ret = mbedtls_ssl_resend(ssl)) != 0) {
   2284                              MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_resend", ret);
   2285                              return ret;
   2286                          }
   2287          
   2288                          return MBEDTLS_ERR_SSL_WANT_READ;
   2289                      }
   2290          #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_RENEGOTIATION)
   2291                      else if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   2292                               ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING) {
   2293                          if ((ret = mbedtls_ssl_resend_hello_request(ssl)) != 0) {
   2294                              MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_resend_hello_request",
   2295                                                    ret);
   2296                              return ret;
   2297                          }
   2298          
   2299                          return MBEDTLS_ERR_SSL_WANT_READ;
   2300                      }
   2301          #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_RENEGOTIATION */
   2302                  }
   2303          
   2304                  if (ret < 0) {
   2305                      return ret;
   2306                  }
   2307          
   2308                  ssl->in_left = ret;
   2309              } else
   2310          #endif
   2311              {
   2312                  MBEDTLS_SSL_DEBUG_MSG(2, ("in_left: %" MBEDTLS_PRINTF_SIZET
   2313                                            ", nb_want: %" MBEDTLS_PRINTF_SIZET,
   2314                                            ssl->in_left, nb_want));
   2315          
   2316                  while (ssl->in_left < nb_want) {
   \                     ??mbedtls_ssl_fetch_input_2: (+1)
   \                     ??mbedtls_ssl_fetch_input_3: (+1)
   \       0x34   0x6FE8             LDR      R0,[R5, #+124]
   \       0x36   0x42B0             CMP      R0,R6
   \       0x38   0xD234             BCS.N    ??mbedtls_ssl_fetch_input_4
   2317                      len = nb_want - ssl->in_left;
   \       0x3A   0x6FE8             LDR      R0,[R5, #+124]
   \       0x3C   0x1A30             SUBS     R0,R6,R0
   \       0x3E   0x4680             MOV      R8,R0
   2318          
   2319                      if (mbedtls_ssl_check_timer(ssl) != 0) {
   \       0x40   0x0028             MOVS     R0,R5
   \       0x42   0x.... 0x....      BL       mbedtls_ssl_check_timer
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD003             BEQ.N    ??mbedtls_ssl_fetch_input_5
   2320                          ret = MBEDTLS_ERR_SSL_TIMEOUT;
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable23
   \       0x4E   0x0004             MOVS     R4,R0
   \       0x50   0xE016             B.N      ??mbedtls_ssl_fetch_input_6
   2321                      } else {
   2322                          if (ssl->f_recv_timeout != NULL) {
   \                     ??mbedtls_ssl_fetch_input_5: (+1)
   \       0x52   0x6A28             LDR      R0,[R5, #+32]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD00B             BEQ.N    ??mbedtls_ssl_fetch_input_7
   2323                              ret = ssl->f_recv_timeout(ssl->p_bio,
   2324                                                        ssl->in_hdr + ssl->in_left, len,
   2325                                                        ssl->conf->read_timeout);
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0x6D43             LDR      R3,[R0, #+84]
   \       0x5C   0x4642             MOV      R2,R8
   \       0x5E   0x6E29             LDR      R1,[R5, #+96]
   \       0x60   0x6FE8             LDR      R0,[R5, #+124]
   \       0x62   0x4401             ADD      R1,R1,R0
   \       0x64   0x6A68             LDR      R0,[R5, #+36]
   \       0x66   0xF8D5 0xC020      LDR      R12,[R5, #+32]
   \       0x6A   0x47E0             BLX      R12
   \       0x6C   0x0004             MOVS     R4,R0
   \       0x6E   0xE007             B.N      ??mbedtls_ssl_fetch_input_6
   2326                          } else {
   2327                              ret = ssl->f_recv(ssl->p_bio,
   2328                                                ssl->in_hdr + ssl->in_left, len);
   \                     ??mbedtls_ssl_fetch_input_7: (+1)
   \       0x70   0x4642             MOV      R2,R8
   \       0x72   0x6E29             LDR      R1,[R5, #+96]
   \       0x74   0x6FE8             LDR      R0,[R5, #+124]
   \       0x76   0x4401             ADD      R1,R1,R0
   \       0x78   0x6A68             LDR      R0,[R5, #+36]
   \       0x7A   0x69EB             LDR      R3,[R5, #+28]
   \       0x7C   0x4798             BLX      R3
   \       0x7E   0x0004             MOVS     R4,R0
   2329                          }
   2330                      }
   2331          
   2332                      MBEDTLS_SSL_DEBUG_MSG(2, ("in_left: %" MBEDTLS_PRINTF_SIZET
   2333                                                ", nb_want: %" MBEDTLS_PRINTF_SIZET,
   2334                                                ssl->in_left, nb_want));
   2335                      MBEDTLS_SSL_DEBUG_RET(2, "ssl->f_recv(_timeout)", ret);
   2336          
   2337                      if (ret == 0) {
   \                     ??mbedtls_ssl_fetch_input_6: (+1)
   \       0x80   0x2C00             CMP      R4,#+0
   \       0x82   0xD102             BNE.N    ??mbedtls_ssl_fetch_input_8
   2338                          return MBEDTLS_ERR_SSL_CONN_EOF;
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x88   0xE00D             B.N      ??mbedtls_ssl_fetch_input_1
   2339                      }
   2340          
   2341                      if (ret < 0) {
   \                     ??mbedtls_ssl_fetch_input_8: (+1)
   \       0x8A   0x2C00             CMP      R4,#+0
   \       0x8C   0xD501             BPL.N    ??mbedtls_ssl_fetch_input_9
   2342                          return ret;
   \       0x8E   0x0020             MOVS     R0,R4
   \       0x90   0xE009             B.N      ??mbedtls_ssl_fetch_input_1
   2343                      }
   2344          
   2345                      if ((size_t) ret > len) {
   \                     ??mbedtls_ssl_fetch_input_9: (+1)
   \       0x92   0x45A0             CMP      R8,R4
   \       0x94   0xD202             BCS.N    ??mbedtls_ssl_fetch_input_10
   2346                          MBEDTLS_SSL_DEBUG_MSG(1,
   2347                                                ("f_recv returned %d bytes but only %" MBEDTLS_PRINTF_SIZET
   2348                                                 " were requested",
   2349                                                 ret, len));
   2350                          return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0x96   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x9A   0xE004             B.N      ??mbedtls_ssl_fetch_input_1
   2351                      }
   2352          
   2353                      ssl->in_left += ret;
   \                     ??mbedtls_ssl_fetch_input_10: (+1)
   \       0x9C   0x6FE8             LDR      R0,[R5, #+124]
   \       0x9E   0x1820             ADDS     R0,R4,R0
   \       0xA0   0x67E8             STR      R0,[R5, #+124]
   \       0xA2   0xE7C7             B.N      ??mbedtls_ssl_fetch_input_3
   2354                  }
   2355              }
   2356          
   2357              MBEDTLS_SSL_DEBUG_MSG(2, ("<= fetch input"));
   2358          
   2359              return 0;
   \                     ??mbedtls_ssl_fetch_input_4: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_fetch_input_1: (+1)
   \       0xA6   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2360          }
   2361          
   2362          /*
   2363           * Flush any data not yet written
   2364           */

   \                                 In section .text, align 2, keep-with-next
   2365          int mbedtls_ssl_flush_output(mbedtls_ssl_context *ssl)
   2366          {
   \                     mbedtls_ssl_flush_output: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   2367              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x066D      MVNS     R6,#+109
   2368              unsigned char *buf;
   2369          
   2370              MBEDTLS_SSL_DEBUG_MSG(2, ("=> flush output"));
   2371          
   2372              if (ssl->f_send == NULL) {
   \        0x8   0x69A8             LDR      R0,[R5, #+24]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD102             BNE.N    ??mbedtls_ssl_flush_output_0
   2373                  MBEDTLS_SSL_DEBUG_MSG(1, ("Bad usage of mbedtls_ssl_set_bio() "));
   2374                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x12   0xE032             B.N      ??mbedtls_ssl_flush_output_1
   2375              }
   2376          
   2377              /* Avoid incrementing counter if data is flushed */
   2378              if (ssl->out_left == 0) {
   \                     ??mbedtls_ssl_flush_output_0: (+1)
   \       0x14   0xF8D5 0x00B4      LDR      R0,[R5, #+180]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??mbedtls_ssl_flush_output_2
   2379                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= flush output"));
   2380                  return 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xE02C             B.N      ??mbedtls_ssl_flush_output_1
   2381              }
   2382          
   2383              while (ssl->out_left > 0) {
   \                     ??mbedtls_ssl_flush_output_2: (+1)
   \       0x20   0xF8D5 0x00B4      LDR      R0,[R5, #+180]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD01E             BEQ.N    ??mbedtls_ssl_flush_output_3
   2384                  MBEDTLS_SSL_DEBUG_MSG(2, ("message length: %" MBEDTLS_PRINTF_SIZET
   2385                                            ", out_left: %" MBEDTLS_PRINTF_SIZET,
   2386                                            mbedtls_ssl_out_hdr_len(ssl) + ssl->out_msglen, ssl->out_left));
   2387          
   2388                  buf = ssl->out_hdr - ssl->out_left;
   \       0x28   0xF8D5 0x109C      LDR      R1,[R5, #+156]
   \       0x2C   0xF8D5 0x00B4      LDR      R0,[R5, #+180]
   \       0x30   0x4240             RSBS     R0,R0,#+0
   \       0x32   0x4408             ADD      R0,R1,R0
   \       0x34   0x0004             MOVS     R4,R0
   2389                  ret = ssl->f_send(ssl->p_bio, buf, ssl->out_left);
   \       0x36   0xF8D5 0x20B4      LDR      R2,[R5, #+180]
   \       0x3A   0x0021             MOVS     R1,R4
   \       0x3C   0x6A68             LDR      R0,[R5, #+36]
   \       0x3E   0x69AB             LDR      R3,[R5, #+24]
   \       0x40   0x4798             BLX      R3
   \       0x42   0x0006             MOVS     R6,R0
   2390          
   2391                  MBEDTLS_SSL_DEBUG_RET(2, "ssl->f_send", ret);
   2392          
   2393                  if (ret <= 0) {
   \       0x44   0x2E01             CMP      R6,#+1
   \       0x46   0xDA01             BGE.N    ??mbedtls_ssl_flush_output_4
   2394                      return ret;
   \       0x48   0x0030             MOVS     R0,R6
   \       0x4A   0xE016             B.N      ??mbedtls_ssl_flush_output_1
   2395                  }
   2396          
   2397                  if ((size_t) ret > ssl->out_left) {
   \                     ??mbedtls_ssl_flush_output_4: (+1)
   \       0x4C   0xF8D5 0x00B4      LDR      R0,[R5, #+180]
   \       0x50   0x42B0             CMP      R0,R6
   \       0x52   0xD202             BCS.N    ??mbedtls_ssl_flush_output_5
   2398                      MBEDTLS_SSL_DEBUG_MSG(1,
   2399                                            ("f_send returned %d bytes but only %" MBEDTLS_PRINTF_SIZET
   2400                                             " bytes were sent",
   2401                                             ret, ssl->out_left));
   2402                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x58   0xE00F             B.N      ??mbedtls_ssl_flush_output_1
   2403                  }
   2404          
   2405                  ssl->out_left -= ret;
   \                     ??mbedtls_ssl_flush_output_5: (+1)
   \       0x5A   0xF8D5 0x00B4      LDR      R0,[R5, #+180]
   \       0x5E   0x1B80             SUBS     R0,R0,R6
   \       0x60   0xF8C5 0x00B4      STR      R0,[R5, #+180]
   \       0x64   0xE7DC             B.N      ??mbedtls_ssl_flush_output_2
   2406              }
   2407          
   2408          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2409              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   2410                  ssl->out_hdr = ssl->out_buf;
   2411              } else
   2412          #endif
   2413              {
   2414                  ssl->out_hdr = ssl->out_buf + 8;
   \                     ??mbedtls_ssl_flush_output_3: (+1)
   \       0x66   0xF8D5 0x0094      LDR      R0,[R5, #+148]
   \       0x6A   0x3008             ADDS     R0,R0,#+8
   \       0x6C   0xF8C5 0x009C      STR      R0,[R5, #+156]
   2415              }
   2416              mbedtls_ssl_update_out_pointers(ssl, ssl->transform_out);
   \       0x70   0x6C29             LDR      R1,[R5, #+64]
   \       0x72   0x0028             MOVS     R0,R5
   \       0x74   0x.... 0x....      BL       mbedtls_ssl_update_out_pointers
   2417          
   2418              MBEDTLS_SSL_DEBUG_MSG(2, ("<= flush output"));
   2419          
   2420              return 0;
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_flush_output_1: (+1)
   \       0x7A   0xBD70             POP      {R4-R6,PC}
   2421          }
   2422          
   2423          /*
   2424           * Functions to handle the DTLS retransmission state machine
   2425           */
   2426          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2427          /*
   2428           * Append current handshake message to current outgoing flight
   2429           */
   2430          MBEDTLS_CHECK_RETURN_CRITICAL
   2431          static int ssl_flight_append(mbedtls_ssl_context *ssl)
   2432          {
   2433              mbedtls_ssl_flight_item *msg;
   2434              MBEDTLS_SSL_DEBUG_MSG(2, ("=> ssl_flight_append"));
   2435              MBEDTLS_SSL_DEBUG_BUF(4, "message appended to flight",
   2436                                    ssl->out_msg, ssl->out_msglen);
   2437          
   2438              /* Allocate space for current message */
   2439              if ((msg = mbedtls_calloc(1, sizeof(mbedtls_ssl_flight_item))) == NULL) {
   2440                  MBEDTLS_SSL_DEBUG_MSG(1, ("alloc %" MBEDTLS_PRINTF_SIZET " bytes failed",
   2441                                            sizeof(mbedtls_ssl_flight_item)));
   2442                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   2443              }
   2444          
   2445              if ((msg->p = mbedtls_calloc(1, ssl->out_msglen)) == NULL) {
   2446                  MBEDTLS_SSL_DEBUG_MSG(1, ("alloc %" MBEDTLS_PRINTF_SIZET " bytes failed",
   2447                                            ssl->out_msglen));
   2448                  mbedtls_free(msg);
   2449                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   2450              }
   2451          
   2452              /* Copy current handshake message with headers */
   2453              memcpy(msg->p, ssl->out_msg, ssl->out_msglen);
   2454              msg->len = ssl->out_msglen;
   2455              msg->type = ssl->out_msgtype;
   2456              msg->next = NULL;
   2457          
   2458              /* Append to the current flight */
   2459              if (ssl->handshake->flight == NULL) {
   2460                  ssl->handshake->flight = msg;
   2461              } else {
   2462                  mbedtls_ssl_flight_item *cur = ssl->handshake->flight;
   2463                  while (cur->next != NULL) {
   2464                      cur = cur->next;
   2465                  }
   2466                  cur->next = msg;
   2467              }
   2468          
   2469              MBEDTLS_SSL_DEBUG_MSG(2, ("<= ssl_flight_append"));
   2470              return 0;
   2471          }
   2472          
   2473          /*
   2474           * Free the current flight of handshake messages
   2475           */
   2476          void mbedtls_ssl_flight_free(mbedtls_ssl_flight_item *flight)
   2477          {
   2478              mbedtls_ssl_flight_item *cur = flight;
   2479              mbedtls_ssl_flight_item *next;
   2480          
   2481              while (cur != NULL) {
   2482                  next = cur->next;
   2483          
   2484                  mbedtls_free(cur->p);
   2485                  mbedtls_free(cur);
   2486          
   2487                  cur = next;
   2488              }
   2489          }
   2490          
   2491          /*
   2492           * Swap transform_out and out_ctr with the alternative ones
   2493           */
   2494          MBEDTLS_CHECK_RETURN_CRITICAL
   2495          static int ssl_swap_epochs(mbedtls_ssl_context *ssl)
   2496          {
   2497              mbedtls_ssl_transform *tmp_transform;
   2498              unsigned char tmp_out_ctr[MBEDTLS_SSL_SEQUENCE_NUMBER_LEN];
   2499          
   2500              if (ssl->transform_out == ssl->handshake->alt_transform_out) {
   2501                  MBEDTLS_SSL_DEBUG_MSG(3, ("skip swap epochs"));
   2502                  return 0;
   2503              }
   2504          
   2505              MBEDTLS_SSL_DEBUG_MSG(3, ("swap epochs"));
   2506          
   2507              /* Swap transforms */
   2508              tmp_transform                     = ssl->transform_out;
   2509              ssl->transform_out                = ssl->handshake->alt_transform_out;
   2510              ssl->handshake->alt_transform_out = tmp_transform;
   2511          
   2512              /* Swap epoch + sequence_number */
   2513              memcpy(tmp_out_ctr, ssl->cur_out_ctr, sizeof(tmp_out_ctr));
   2514              memcpy(ssl->cur_out_ctr, ssl->handshake->alt_out_ctr,
   2515                     sizeof(ssl->cur_out_ctr));
   2516              memcpy(ssl->handshake->alt_out_ctr, tmp_out_ctr,
   2517                     sizeof(ssl->handshake->alt_out_ctr));
   2518          
   2519              /* Adjust to the newly activated transform */
   2520              mbedtls_ssl_update_out_pointers(ssl, ssl->transform_out);
   2521          
   2522              return 0;
   2523          }
   2524          
   2525          /*
   2526           * Retransmit the current flight of messages.
   2527           */
   2528          int mbedtls_ssl_resend(mbedtls_ssl_context *ssl)
   2529          {
   2530              int ret = 0;
   2531          
   2532              MBEDTLS_SSL_DEBUG_MSG(2, ("=> mbedtls_ssl_resend"));
   2533          
   2534              ret = mbedtls_ssl_flight_transmit(ssl);
   2535          
   2536              MBEDTLS_SSL_DEBUG_MSG(2, ("<= mbedtls_ssl_resend"));
   2537          
   2538              return ret;
   2539          }
   2540          
   2541          /*
   2542           * Transmit or retransmit the current flight of messages.
   2543           *
   2544           * Need to remember the current message in case flush_output returns
   2545           * WANT_WRITE, causing us to exit this function and come back later.
   2546           * This function must be called until state is no longer SENDING.
   2547           */
   2548          int mbedtls_ssl_flight_transmit(mbedtls_ssl_context *ssl)
   2549          {
   2550              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2551              MBEDTLS_SSL_DEBUG_MSG(2, ("=> mbedtls_ssl_flight_transmit"));
   2552          
   2553              if (ssl->handshake->retransmit_state != MBEDTLS_SSL_RETRANS_SENDING) {
   2554                  MBEDTLS_SSL_DEBUG_MSG(2, ("initialise flight transmission"));
   2555          
   2556                  ssl->handshake->cur_msg = ssl->handshake->flight;
   2557                  ssl->handshake->cur_msg_p = ssl->handshake->flight->p + 12;
   2558                  ret = ssl_swap_epochs(ssl);
   2559                  if (ret != 0) {
   2560                      return ret;
   2561                  }
   2562          
   2563                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_SENDING;
   2564              }
   2565          
   2566              while (ssl->handshake->cur_msg != NULL) {
   2567                  size_t max_frag_len;
   2568                  const mbedtls_ssl_flight_item * const cur = ssl->handshake->cur_msg;
   2569          
   2570                  int const is_finished =
   2571                      (cur->type == MBEDTLS_SSL_MSG_HANDSHAKE &&
   2572                       cur->p[0] == MBEDTLS_SSL_HS_FINISHED);
   2573          
   2574                  int const force_flush = ssl->disable_datagram_packing == 1 ?
   2575                                          SSL_FORCE_FLUSH : SSL_DONT_FORCE_FLUSH;
   2576          
   2577                  /* Swap epochs before sending Finished: we can't do it after
   2578                   * sending ChangeCipherSpec, in case write returns WANT_READ.
   2579                   * Must be done before copying, may change out_msg pointer */
   2580                  if (is_finished && ssl->handshake->cur_msg_p == (cur->p + 12)) {
   2581                      MBEDTLS_SSL_DEBUG_MSG(2, ("swap epochs to send finished message"));
   2582                      ret = ssl_swap_epochs(ssl);
   2583                      if (ret != 0) {
   2584                          return ret;
   2585                      }
   2586                  }
   2587          
   2588                  ret = ssl_get_remaining_payload_in_datagram(ssl);
   2589                  if (ret < 0) {
   2590                      return ret;
   2591                  }
   2592                  max_frag_len = (size_t) ret;
   2593          
   2594                  /* CCS is copied as is, while HS messages may need fragmentation */
   2595                  if (cur->type == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC) {
   2596                      if (max_frag_len == 0) {
   2597                          if ((ret = mbedtls_ssl_flush_output(ssl)) != 0) {
   2598                              return ret;
   2599                          }
   2600          
   2601                          continue;
   2602                      }
   2603          
   2604                      memcpy(ssl->out_msg, cur->p, cur->len);
   2605                      ssl->out_msglen  = cur->len;
   2606                      ssl->out_msgtype = cur->type;
   2607          
   2608                      /* Update position inside current message */
   2609                      ssl->handshake->cur_msg_p += cur->len;
   2610                  } else {
   2611                      const unsigned char * const p = ssl->handshake->cur_msg_p;
   2612                      const size_t hs_len = cur->len - 12;
   2613                      const size_t frag_off = p - (cur->p + 12);
   2614                      const size_t rem_len = hs_len - frag_off;
   2615                      size_t cur_hs_frag_len, max_hs_frag_len;
   2616          
   2617                      if ((max_frag_len < 12) || (max_frag_len == 12 && hs_len != 0)) {
   2618                          if (is_finished) {
   2619                              ret = ssl_swap_epochs(ssl);
   2620                              if (ret != 0) {
   2621                                  return ret;
   2622                              }
   2623                          }
   2624          
   2625                          if ((ret = mbedtls_ssl_flush_output(ssl)) != 0) {
   2626                              return ret;
   2627                          }
   2628          
   2629                          continue;
   2630                      }
   2631                      max_hs_frag_len = max_frag_len - 12;
   2632          
   2633                      cur_hs_frag_len = rem_len > max_hs_frag_len ?
   2634                                        max_hs_frag_len : rem_len;
   2635          
   2636                      if (frag_off == 0 && cur_hs_frag_len != hs_len) {
   2637                          MBEDTLS_SSL_DEBUG_MSG(2, ("fragmenting handshake message (%u > %u)",
   2638                                                    (unsigned) cur_hs_frag_len,
   2639                                                    (unsigned) max_hs_frag_len));
   2640                      }
   2641          
   2642                      /* Messages are stored with handshake headers as if not fragmented,
   2643                       * copy beginning of headers then fill fragmentation fields.
   2644                       * Handshake headers: type(1) len(3) seq(2) f_off(3) f_len(3) */
   2645                      memcpy(ssl->out_msg, cur->p, 6);
   2646          
   2647                      ssl->out_msg[6] = MBEDTLS_BYTE_2(frag_off);
   2648                      ssl->out_msg[7] = MBEDTLS_BYTE_1(frag_off);
   2649                      ssl->out_msg[8] = MBEDTLS_BYTE_0(frag_off);
   2650          
   2651                      ssl->out_msg[9] = MBEDTLS_BYTE_2(cur_hs_frag_len);
   2652                      ssl->out_msg[10] = MBEDTLS_BYTE_1(cur_hs_frag_len);
   2653                      ssl->out_msg[11] = MBEDTLS_BYTE_0(cur_hs_frag_len);
   2654          
   2655                      MBEDTLS_SSL_DEBUG_BUF(3, "handshake header", ssl->out_msg, 12);
   2656          
   2657                      /* Copy the handshake message content and set records fields */
   2658                      memcpy(ssl->out_msg + 12, p, cur_hs_frag_len);
   2659                      ssl->out_msglen = cur_hs_frag_len + 12;
   2660                      ssl->out_msgtype = cur->type;
   2661          
   2662                      /* Update position inside current message */
   2663                      ssl->handshake->cur_msg_p += cur_hs_frag_len;
   2664                  }
   2665          
   2666                  /* If done with the current message move to the next one if any */
   2667                  if (ssl->handshake->cur_msg_p >= cur->p + cur->len) {
   2668                      if (cur->next != NULL) {
   2669                          ssl->handshake->cur_msg = cur->next;
   2670                          ssl->handshake->cur_msg_p = cur->next->p + 12;
   2671                      } else {
   2672                          ssl->handshake->cur_msg = NULL;
   2673                          ssl->handshake->cur_msg_p = NULL;
   2674                      }
   2675                  }
   2676          
   2677                  /* Actually send the message out */
   2678                  if ((ret = mbedtls_ssl_write_record(ssl, force_flush)) != 0) {
   2679                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_record", ret);
   2680                      return ret;
   2681                  }
   2682              }
   2683          
   2684              if ((ret = mbedtls_ssl_flush_output(ssl)) != 0) {
   2685                  return ret;
   2686              }
   2687          
   2688              /* Update state and set timer */
   2689              if (mbedtls_ssl_is_handshake_over(ssl) == 1) {
   2690                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
   2691              } else {
   2692                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;
   2693                  mbedtls_ssl_set_timer(ssl, ssl->handshake->retransmit_timeout);
   2694              }
   2695          
   2696              MBEDTLS_SSL_DEBUG_MSG(2, ("<= mbedtls_ssl_flight_transmit"));
   2697          
   2698              return 0;
   2699          }
   2700          
   2701          /*
   2702           * To be called when the last message of an incoming flight is received.
   2703           */
   2704          void mbedtls_ssl_recv_flight_completed(mbedtls_ssl_context *ssl)
   2705          {
   2706              /* We won't need to resend that one any more */
   2707              mbedtls_ssl_flight_free(ssl->handshake->flight);
   2708              ssl->handshake->flight = NULL;
   2709              ssl->handshake->cur_msg = NULL;
   2710          
   2711              /* The next incoming flight will start with this msg_seq */
   2712              ssl->handshake->in_flight_start_seq = ssl->handshake->in_msg_seq;
   2713          
   2714              /* We don't want to remember CCS's across flight boundaries. */
   2715              ssl->handshake->buffering.seen_ccs = 0;
   2716          
   2717              /* Clear future message buffering structure. */
   2718              mbedtls_ssl_buffering_free(ssl);
   2719          
   2720              /* Cancel timer */
   2721              mbedtls_ssl_set_timer(ssl, 0);
   2722          
   2723              if (ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   2724                  ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED) {
   2725                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
   2726              } else {
   2727                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_PREPARING;
   2728              }
   2729          }
   2730          
   2731          /*
   2732           * To be called when the last message of an outgoing flight is send.
   2733           */
   2734          void mbedtls_ssl_send_flight_completed(mbedtls_ssl_context *ssl)
   2735          {
   2736              ssl_reset_retransmit_timeout(ssl);
   2737              mbedtls_ssl_set_timer(ssl, ssl->handshake->retransmit_timeout);
   2738          
   2739              if (ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   2740                  ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED) {
   2741                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
   2742              } else {
   2743                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;
   2744              }
   2745          }
   2746          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   2747          
   2748          /*
   2749           * Handshake layer functions
   2750           */

   \                                 In section .text, align 2, keep-with-next
   2751          int mbedtls_ssl_start_handshake_msg(mbedtls_ssl_context *ssl, unsigned hs_type,
   2752                                              unsigned char **buf, size_t *buf_len)
   2753          {
   \                     mbedtls_ssl_start_handshake_msg: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0004             MOVS     R4,R0
   2754              /*
   2755               * Reserve 4 bytes for handshake header. ( Section 4,RFC 8446 )
   2756               *    ...
   2757               *    HandshakeType msg_type;
   2758               *    uint24 length;
   2759               *    ...
   2760               */
   2761              *buf = ssl->out_msg + 4;
   \        0x4   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \        0x8   0x1D00             ADDS     R0,R0,#+4
   \        0xA   0x6010             STR      R0,[R2, #+0]
   2762              *buf_len = MBEDTLS_SSL_OUT_CONTENT_LEN - 4;
   \        0xC   0xF44F 0x703F      MOV      R0,#+764
   \       0x10   0x6018             STR      R0,[R3, #+0]
   2763          
   2764              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   \       0x12   0x2016             MOVS     R0,#+22
   \       0x14   0xF8C4 0x00AC      STR      R0,[R4, #+172]
   2765              ssl->out_msg[0]  = hs_type;
   \       0x18   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \       0x1C   0x7001             STRB     R1,[R0, #+0]
   2766          
   2767              return 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBC10             POP      {R4}
   \       0x22   0x4770             BX       LR
   2768          }
   2769          
   2770          /*
   2771           * Write (DTLS: or queue) current handshake (including CCS) message.
   2772           *
   2773           *  - fill in handshake headers
   2774           *  - update handshake checksum
   2775           *  - DTLS: save message for resending
   2776           *  - then pass to the record layer
   2777           *
   2778           * DTLS: except for HelloRequest, messages are only queued, and will only be
   2779           * actually sent when calling flight_transmit() or resend().
   2780           *
   2781           * Inputs:
   2782           *  - ssl->out_msglen: 4 + actual handshake message len
   2783           *      (4 is the size of handshake headers for TLS)
   2784           *  - ssl->out_msg[0]: the handshake type (ClientHello, ServerHello, etc)
   2785           *  - ssl->out_msg + 4: the handshake message body
   2786           *
   2787           * Outputs, ie state before passing to flight_append() or write_record():
   2788           *   - ssl->out_msglen: the length of the record contents
   2789           *      (including handshake headers but excluding record headers)
   2790           *   - ssl->out_msg: the record contents (handshake headers + content)
   2791           */

   \                                 In section .text, align 2, keep-with-next
   2792          int mbedtls_ssl_write_handshake_msg_ext(mbedtls_ssl_context *ssl,
   2793                                                  int update_checksum,
   2794                                                  int force_flush)
   2795          {
   \                     mbedtls_ssl_write_handshake_msg_ext: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
   2796              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x056D      MVNS     R5,#+109
   2797              const size_t hs_len = ssl->out_msglen - 4;
   \        0xE   0xF8D9 0x70B0      LDR      R7,[R9, #+176]
   \       0x12   0x1F3F             SUBS     R7,R7,#+4
   2798              const unsigned char hs_type = ssl->out_msg[0];
   \       0x14   0xF8D9 0x00A8      LDR      R0,[R9, #+168]
   \       0x18   0xF890 0x8000      LDRB     R8,[R0, #+0]
   2799          
   2800              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write handshake message"));
   2801          
   2802              /*
   2803               * Sanity checks
   2804               */
   2805              if (ssl->out_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE          &&
   2806                  ssl->out_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC) {
   \       0x1C   0xF8D9 0x00AC      LDR      R0,[R9, #+172]
   \       0x20   0x2816             CMP      R0,#+22
   \       0x22   0xD005             BEQ.N    ??mbedtls_ssl_write_handshake_msg_ext_0
   \       0x24   0xF8D9 0x00AC      LDR      R0,[R9, #+172]
   \       0x28   0x2814             CMP      R0,#+20
   \       0x2A   0xD001             BEQ.N    ??mbedtls_ssl_write_handshake_msg_ext_0
   2807                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2808                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0x2C   0x....             LDR.N    R0,??DataTable12
   \       0x2E   0xE044             B.N      ??mbedtls_ssl_write_handshake_msg_ext_1
   2809              }
   2810          
   2811              /* Whenever we send anything different from a
   2812               * HelloRequest we should be in a handshake - double check. */
   2813              if (!(ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   2814                    hs_type          == MBEDTLS_SSL_HS_HELLO_REQUEST) &&
   2815                  ssl->handshake == NULL) {
   \                     ??mbedtls_ssl_write_handshake_msg_ext_0: (+1)
   \       0x30   0xF8D9 0x00AC      LDR      R0,[R9, #+172]
   \       0x34   0x2816             CMP      R0,#+22
   \       0x36   0xD103             BNE.N    ??mbedtls_ssl_write_handshake_msg_ext_2
   \       0x38   0x4640             MOV      R0,R8
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD005             BEQ.N    ??mbedtls_ssl_write_handshake_msg_ext_3
   \                     ??mbedtls_ssl_write_handshake_msg_ext_2: (+1)
   \       0x40   0xF8D9 0x0038      LDR      R0,[R9, #+56]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD101             BNE.N    ??mbedtls_ssl_write_handshake_msg_ext_3
   2816                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2817                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0x48   0x....             LDR.N    R0,??DataTable12
   \       0x4A   0xE036             B.N      ??mbedtls_ssl_write_handshake_msg_ext_1
   2818              }
   2819          
   2820          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2821              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   2822                  ssl->handshake != NULL &&
   2823                  ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING) {
   2824                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2825                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2826              }
   2827          #endif
   2828          
   2829              /* Double-check that we did not exceed the bounds
   2830               * of the outgoing record buffer.
   2831               * This should never fail as the various message
   2832               * writing functions must obey the bounds of the
   2833               * outgoing record buffer, but better be safe.
   2834               *
   2835               * Note: We deliberately do not check for the MTU or MFL here.
   2836               */
   2837              if (ssl->out_msglen > MBEDTLS_SSL_OUT_CONTENT_LEN) {
   \                     ??mbedtls_ssl_write_handshake_msg_ext_3: (+1)
   \       0x4C   0xF8D9 0x10B0      LDR      R1,[R9, #+176]
   \       0x50   0xF240 0x3001      MOVW     R0,#+769
   \       0x54   0x4281             CMP      R1,R0
   \       0x56   0xD301             BCC.N    ??mbedtls_ssl_write_handshake_msg_ext_4
   2838                  MBEDTLS_SSL_DEBUG_MSG(1, ("Record too large: "
   2839                                            "size %" MBEDTLS_PRINTF_SIZET
   2840                                            ", maximum %" MBEDTLS_PRINTF_SIZET,
   2841                                            ssl->out_msglen,
   2842                                            (size_t) MBEDTLS_SSL_OUT_CONTENT_LEN));
   2843                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0x58   0x....             LDR.N    R0,??DataTable12
   \       0x5A   0xE02E             B.N      ??mbedtls_ssl_write_handshake_msg_ext_1
   2844              }
   2845          
   2846              /*
   2847               * Fill handshake headers
   2848               */
   2849              if (ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE) {
   \                     ??mbedtls_ssl_write_handshake_msg_ext_4: (+1)
   \       0x5C   0xF8D9 0x00AC      LDR      R0,[R9, #+172]
   \       0x60   0x2816             CMP      R0,#+22
   \       0x62   0xD120             BNE.N    ??mbedtls_ssl_write_handshake_msg_ext_5
   2850                  ssl->out_msg[1] = MBEDTLS_BYTE_2(hs_len);
   \       0x64   0x0039             MOVS     R1,R7
   \       0x66   0x0C09             LSRS     R1,R1,#+16
   \       0x68   0xF8D9 0x00A8      LDR      R0,[R9, #+168]
   \       0x6C   0x7041             STRB     R1,[R0, #+1]
   2851                  ssl->out_msg[2] = MBEDTLS_BYTE_1(hs_len);
   \       0x6E   0x0039             MOVS     R1,R7
   \       0x70   0x0A09             LSRS     R1,R1,#+8
   \       0x72   0xF8D9 0x00A8      LDR      R0,[R9, #+168]
   \       0x76   0x7081             STRB     R1,[R0, #+2]
   2852                  ssl->out_msg[3] = MBEDTLS_BYTE_0(hs_len);
   \       0x78   0xF8D9 0x00A8      LDR      R0,[R9, #+168]
   \       0x7C   0x70C7             STRB     R7,[R0, #+3]
   2853          
   2854                  /*
   2855                   * DTLS has additional fields in the Handshake layer,
   2856                   * between the length field and the actual payload:
   2857                   *      uint16 message_seq;
   2858                   *      uint24 fragment_offset;
   2859                   *      uint24 fragment_length;
   2860                   */
   2861          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2862                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   2863                      /* Make room for the additional DTLS fields */
   2864                      if (MBEDTLS_SSL_OUT_CONTENT_LEN - ssl->out_msglen < 8) {
   2865                          MBEDTLS_SSL_DEBUG_MSG(1, ("DTLS handshake message too large: "
   2866                                                    "size %" MBEDTLS_PRINTF_SIZET ", maximum %"
   2867                                                    MBEDTLS_PRINTF_SIZET,
   2868                                                    hs_len,
   2869                                                    (size_t) (MBEDTLS_SSL_OUT_CONTENT_LEN - 12)));
   2870                          return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2871                      }
   2872          
   2873                      memmove(ssl->out_msg + 12, ssl->out_msg + 4, hs_len);
   2874                      ssl->out_msglen += 8;
   2875          
   2876                      /* Write message_seq and update it, except for HelloRequest */
   2877                      if (hs_type != MBEDTLS_SSL_HS_HELLO_REQUEST) {
   2878                          MBEDTLS_PUT_UINT16_BE(ssl->handshake->out_msg_seq, ssl->out_msg, 4);
   2879                          ++(ssl->handshake->out_msg_seq);
   2880                      } else {
   2881                          ssl->out_msg[4] = 0;
   2882                          ssl->out_msg[5] = 0;
   2883                      }
   2884          
   2885                      /* Handshake hashes are computed without fragmentation,
   2886                       * so set frag_offset = 0 and frag_len = hs_len for now */
   2887                      memset(ssl->out_msg + 6, 0x00, 3);
   2888                      memcpy(ssl->out_msg + 9, ssl->out_msg + 1, 3);
   2889                  }
   2890          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   2891          
   2892                  /* Update running hashes of handshake messages seen */
   2893                  if (hs_type != MBEDTLS_SSL_HS_HELLO_REQUEST && update_checksum != 0) {
   \       0x7E   0x4640             MOV      R0,R8
   \       0x80   0xB2C0             UXTB     R0,R0
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD00F             BEQ.N    ??mbedtls_ssl_write_handshake_msg_ext_5
   \       0x86   0x2C00             CMP      R4,#+0
   \       0x88   0xD00D             BEQ.N    ??mbedtls_ssl_write_handshake_msg_ext_5
   2894                      ret = ssl->handshake->update_checksum(ssl, ssl->out_msg,
   2895                                                            ssl->out_msglen);
   \       0x8A   0xF8D9 0x20B0      LDR      R2,[R9, #+176]
   \       0x8E   0xF8D9 0x10A8      LDR      R1,[R9, #+168]
   \       0x92   0x4648             MOV      R0,R9
   \       0x94   0xF8D9 0x3038      LDR      R3,[R9, #+56]
   \       0x98   0x68DB             LDR      R3,[R3, #+12]
   \       0x9A   0x4798             BLX      R3
   \       0x9C   0x0005             MOVS     R5,R0
   2896                      if (ret != 0) {
   \       0x9E   0x2D00             CMP      R5,#+0
   \       0xA0   0xD001             BEQ.N    ??mbedtls_ssl_write_handshake_msg_ext_5
   2897                          MBEDTLS_SSL_DEBUG_RET(1, "update_checksum", ret);
   2898                          return ret;
   \       0xA2   0x0028             MOVS     R0,R5
   \       0xA4   0xE009             B.N      ??mbedtls_ssl_write_handshake_msg_ext_1
   2899                      }
   2900                  }
   2901              }
   2902          
   2903              /* Either send now, or just save to be sent (and resent) later */
   2904          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2905              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   2906                  !(ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   2907                    hs_type          == MBEDTLS_SSL_HS_HELLO_REQUEST)) {
   2908                  if ((ret = ssl_flight_append(ssl)) != 0) {
   2909                      MBEDTLS_SSL_DEBUG_RET(1, "ssl_flight_append", ret);
   2910                      return ret;
   2911                  }
   2912              } else
   2913          #endif
   2914              {
   2915                  if ((ret = mbedtls_ssl_write_record(ssl, force_flush)) != 0) {
   \                     ??mbedtls_ssl_write_handshake_msg_ext_5: (+1)
   \       0xA6   0x0031             MOVS     R1,R6
   \       0xA8   0x4648             MOV      R0,R9
   \       0xAA   0x.... 0x....      BL       mbedtls_ssl_write_record
   \       0xAE   0x0001             MOVS     R1,R0
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD001             BEQ.N    ??mbedtls_ssl_write_handshake_msg_ext_6
   2916                      MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_record", ret);
   2917                      return ret;
   \       0xB4   0x0008             MOVS     R0,R1
   \       0xB6   0xE000             B.N      ??mbedtls_ssl_write_handshake_msg_ext_1
   2918                  }
   2919              }
   2920          
   2921              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write handshake message"));
   2922          
   2923              return 0;
   \                     ??mbedtls_ssl_write_handshake_msg_ext_6: (+1)
   \       0xB8   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_write_handshake_msg_ext_1: (+1)
   \       0xBA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2924          }
   2925          

   \                                 In section .text, align 2, keep-with-next
   2926          int mbedtls_ssl_finish_handshake_msg(mbedtls_ssl_context *ssl,
   2927                                               size_t buf_len, size_t msg_len)
   2928          {
   \                     mbedtls_ssl_finish_handshake_msg: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   2929              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x066D      MVNS     R6,#+109
   2930              size_t msg_with_header_len;
   2931              ((void) buf_len);
   2932          
   2933              /* Add reserved 4 bytes for handshake header */
   2934              msg_with_header_len = msg_len + 4;
   \        0xE   0x1D2F             ADDS     R7,R5,#+4
   2935              ssl->out_msglen = msg_with_header_len;
   \       0x10   0xF8C8 0x70B0      STR      R7,[R8, #+176]
   2936              MBEDTLS_SSL_PROC_CHK(mbedtls_ssl_write_handshake_msg_ext(ssl, 0, 0));
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0x.... 0x....      BL       mbedtls_ssl_write_handshake_msg_ext
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD1FF             BNE.N    ??mbedtls_ssl_finish_handshake_msg_0
   2937          
   2938          cleanup:
   2939              return ret;
   \                     ??mbedtls_ssl_finish_handshake_msg_1: (+1)
   \                     ??mbedtls_ssl_finish_handshake_msg_0: (+1)
   \       0x22   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2940          }
   2941          
   2942          /*
   2943           * Record layer functions
   2944           */
   2945          
   2946          /*
   2947           * Write current record.
   2948           *
   2949           * Uses:
   2950           *  - ssl->out_msgtype: type of the message (AppData, Handshake, Alert, CCS)
   2951           *  - ssl->out_msglen: length of the record content (excl headers)
   2952           *  - ssl->out_msg: record content
   2953           */

   \                                 In section .text, align 2, keep-with-next
   2954          int mbedtls_ssl_write_record(mbedtls_ssl_context *ssl, int force_flush)
   2955          {
   \                     mbedtls_ssl_write_record: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x000D             MOVS     R5,R1
   2956              int ret, done = 0;
   \        0xA   0x2400             MOVS     R4,#+0
   2957              size_t len = ssl->out_msglen;
   \        0xC   0xF8D7 0x00B0      LDR      R0,[R7, #+176]
   \       0x10   0x9002             STR      R0,[SP, #+8]
   2958              int flush = force_flush;
   \       0x12   0x950B             STR      R5,[SP, #+44]
   2959          
   2960              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write record"));
   2961          
   2962              if (!done) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xF040 0x80CE      BNE.W    ??mbedtls_ssl_write_record_0
   2963                  unsigned i;
   2964                  size_t protected_record_size;
   2965          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   2966                  size_t out_buf_len = ssl->out_buf_len;
   2967          #else
   2968                  size_t out_buf_len = MBEDTLS_SSL_OUT_BUFFER_LEN;
   \       0x1A   0xF240 0x483D      MOVW     R8,#+1085
   2969          #endif
   2970                  /* Skip writing the record content type to after the encryption,
   2971                   * as it may change when using the CID extension. */
   2972                  mbedtls_ssl_protocol_version tls_ver = ssl->tls_version;
   \       0x1E   0xF9B7 0x0008      LDRSH    R0,[R7, #+8]
   \       0x22   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   2973          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   2974                  /* TLS 1.3 still uses the TLS 1.2 version identifier
   2975                   * for backwards compatibility. */
   2976                  if (tls_ver == MBEDTLS_SSL_VERSION_TLS1_3) {
   2977                      tls_ver = MBEDTLS_SSL_VERSION_TLS1_2;
   2978                  }
   2979          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   2980                  mbedtls_ssl_write_version(ssl->out_hdr + 1, ssl->conf->transport,
   2981                                            tls_ver);
   \       0x26   0xF9BD 0x2004      LDRSH    R2,[SP, #+4]
   \       0x2A   0x6838             LDR      R0,[R7, #+0]
   \       0x2C   0x7941             LDRB     R1,[R0, #+5]
   \       0x2E   0xF8D7 0x009C      LDR      R0,[R7, #+156]
   \       0x32   0x1C40             ADDS     R0,R0,#+1
   \       0x34   0x.... 0x....      BL       mbedtls_ssl_write_version
   2982          
   2983                  memcpy(ssl->out_ctr, ssl->cur_out_ctr, MBEDTLS_SSL_SEQUENCE_NUMBER_LEN);
   \       0x38   0xF05F 0x0B08      MOVS     R11,#+8
   \       0x3C   0xF117 0x0AB8      ADDS     R10,R7,#+184
   \       0x40   0xF8D7 0x9098      LDR      R9,[R7, #+152]
   \       0x44   0x465A             MOV      R2,R11
   \       0x46   0x4651             MOV      R1,R10
   \       0x48   0x4648             MOV      R0,R9
   \       0x4A   0x.... 0x....      BL       __aeabi_memcpy
   2984                  MBEDTLS_PUT_UINT16_BE(len, ssl->out_len, 0);
   \       0x4E   0x.... 0x....      LDR.W    R9,??DataTable11
   \       0x52   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD106             BNE.N    ??mbedtls_ssl_write_record_1
   \       0x5A   0x9902             LDR      R1,[SP, #+8]
   \       0x5C   0xB289             UXTH     R1,R1
   \       0x5E   0xF8D7 0x00A0      LDR      R0,[R7, #+160]
   \       0x62   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x66   0xE009             B.N      ??mbedtls_ssl_write_record_2
   \                     ??mbedtls_ssl_write_record_1: (+1)
   \       0x68   0x9802             LDR      R0,[SP, #+8]
   \       0x6A   0xB280             UXTH     R0,R0
   \       0x6C   0x.... 0x....      BL       mbedtls_bswap16
   \       0x70   0x0001             MOVS     R1,R0
   \       0x72   0xB289             UXTH     R1,R1
   \       0x74   0xF8D7 0x00A0      LDR      R0,[R7, #+160]
   \       0x78   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   2985          
   2986                  if (ssl->transform_out != NULL) {
   \                     ??mbedtls_ssl_write_record_2: (+1)
   \       0x7C   0x6C38             LDR      R0,[R7, #+64]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD05C             BEQ.N    ??mbedtls_ssl_write_record_3
   2987                      mbedtls_record rec;
   2988          
   2989                      rec.buf         = ssl->out_iv;
   \       0x82   0xF8D7 0x00A4      LDR      R0,[R7, #+164]
   \       0x86   0x9007             STR      R0,[SP, #+28]
   2990                      rec.buf_len     = out_buf_len - (ssl->out_iv - ssl->out_buf);
   \       0x88   0xF8D7 0x10A4      LDR      R1,[R7, #+164]
   \       0x8C   0xEBB8 0x0101      SUBS     R1,R8,R1
   \       0x90   0xF8D7 0x0094      LDR      R0,[R7, #+148]
   \       0x94   0x1841             ADDS     R1,R0,R1
   \       0x96   0x9108             STR      R1,[SP, #+32]
   2991                      rec.data_len    = ssl->out_msglen;
   \       0x98   0xF8D7 0x00B0      LDR      R0,[R7, #+176]
   \       0x9C   0x900A             STR      R0,[SP, #+40]
   2992                      rec.data_offset = ssl->out_msg - rec.buf;
   \       0x9E   0xF8D7 0x10A8      LDR      R1,[R7, #+168]
   \       0xA2   0x9807             LDR      R0,[SP, #+28]
   \       0xA4   0x1A09             SUBS     R1,R1,R0
   \       0xA6   0x9109             STR      R1,[SP, #+36]
   2993          
   2994                      memcpy(&rec.ctr[0], ssl->out_ctr, sizeof(rec.ctr));
   \       0xA8   0xF05F 0x0A08      MOVS     R10,#+8
   \       0xAC   0xF8D7 0x0098      LDR      R0,[R7, #+152]
   \       0xB0   0x9003             STR      R0,[SP, #+12]
   \       0xB2   0xF10D 0x0B10      ADD      R11,SP,#+16
   \       0xB6   0x4652             MOV      R2,R10
   \       0xB8   0x9903             LDR      R1,[SP, #+12]
   \       0xBA   0x4658             MOV      R0,R11
   \       0xBC   0x.... 0x....      BL       __aeabi_memcpy
   2995                      mbedtls_ssl_write_version(rec.ver, ssl->conf->transport, tls_ver);
   \       0xC0   0xF9BD 0x2004      LDRSH    R2,[SP, #+4]
   \       0xC4   0x6838             LDR      R0,[R7, #+0]
   \       0xC6   0x7941             LDRB     R1,[R0, #+5]
   \       0xC8   0xF10D 0x0019      ADD      R0,SP,#+25
   \       0xCC   0x.... 0x....      BL       mbedtls_ssl_write_version
   2996                      rec.type = ssl->out_msgtype;
   \       0xD0   0xF8D7 0x00AC      LDR      R0,[R7, #+172]
   \       0xD4   0xF88D 0x0018      STRB     R0,[SP, #+24]
   2997          
   2998          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   2999                      /* The CID is set by mbedtls_ssl_encrypt_buf(). */
   3000                      rec.cid_len = 0;
   3001          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   3002          
   3003                      if ((ret = mbedtls_ssl_encrypt_buf(ssl, ssl->transform_out, &rec,
   3004                                                         ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   \       0xD8   0x6838             LDR      R0,[R7, #+0]
   \       0xDA   0x69C0             LDR      R0,[R0, #+28]
   \       0xDC   0x9000             STR      R0,[SP, #+0]
   \       0xDE   0x6838             LDR      R0,[R7, #+0]
   \       0xE0   0x6983             LDR      R3,[R0, #+24]
   \       0xE2   0xAA04             ADD      R2,SP,#+16
   \       0xE4   0x6C39             LDR      R1,[R7, #+64]
   \       0xE6   0x0038             MOVS     R0,R7
   \       0xE8   0x.... 0x....      BL       mbedtls_ssl_encrypt_buf
   \       0xEC   0x0006             MOVS     R6,R0
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD001             BEQ.N    ??mbedtls_ssl_write_record_4
   3005                          MBEDTLS_SSL_DEBUG_RET(1, "ssl_encrypt_buf", ret);
   3006                          return ret;
   \       0xF2   0x0030             MOVS     R0,R6
   \       0xF4   0xE06B             B.N      ??mbedtls_ssl_write_record_5
   3007                      }
   3008          
   3009                      if (rec.data_offset != 0) {
   \                     ??mbedtls_ssl_write_record_4: (+1)
   \       0xF6   0x9809             LDR      R0,[SP, #+36]
   \       0xF8   0x2800             CMP      R0,#+0
   \       0xFA   0xD001             BEQ.N    ??mbedtls_ssl_write_record_6
   3010                          MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3011                          return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0xFC   0x....             LDR.N    R0,??DataTable12
   \       0xFE   0xE066             B.N      ??mbedtls_ssl_write_record_5
   3012                      }
   3013          
   3014                      /* Update the record content type and CID. */
   3015                      ssl->out_msgtype = rec.type;
   \                     ??mbedtls_ssl_write_record_6: (+1)
   \      0x100   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \      0x104   0xF8C7 0x00AC      STR      R0,[R7, #+172]
   3016          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   3017                      memcpy(ssl->out_cid, rec.cid, rec.cid_len);
   3018          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   3019                      ssl->out_msglen = len = rec.data_len;
   \      0x108   0x980A             LDR      R0,[SP, #+40]
   \      0x10A   0x9002             STR      R0,[SP, #+8]
   \      0x10C   0x9802             LDR      R0,[SP, #+8]
   \      0x10E   0xF8C7 0x00B0      STR      R0,[R7, #+176]
   3020                      MBEDTLS_PUT_UINT16_BE(rec.data_len, ssl->out_len, 0);
   \      0x112   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \      0x116   0x2801             CMP      R0,#+1
   \      0x118   0xD106             BNE.N    ??mbedtls_ssl_write_record_7
   \      0x11A   0x990A             LDR      R1,[SP, #+40]
   \      0x11C   0xB289             UXTH     R1,R1
   \      0x11E   0xF8D7 0x00A0      LDR      R0,[R7, #+160]
   \      0x122   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \      0x126   0xE009             B.N      ??mbedtls_ssl_write_record_3
   \                     ??mbedtls_ssl_write_record_7: (+1)
   \      0x128   0x980A             LDR      R0,[SP, #+40]
   \      0x12A   0xB280             UXTH     R0,R0
   \      0x12C   0x.... 0x....      BL       mbedtls_bswap16
   \      0x130   0x0001             MOVS     R1,R0
   \      0x132   0xB289             UXTH     R1,R1
   \      0x134   0xF8D7 0x00A0      LDR      R0,[R7, #+160]
   \      0x138   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   3021                  }
   3022          
   3023                  protected_record_size = len + mbedtls_ssl_out_hdr_len(ssl);
   \                     ??mbedtls_ssl_write_record_3: (+1)
   \      0x13C   0xF8DD 0x9008      LDR      R9,[SP, #+8]
   \      0x140   0x0038             MOVS     R0,R7
   \      0x142   0x.... 0x....      BL       mbedtls_ssl_out_hdr_len
   \      0x146   0x4682             MOV      R10,R0
   \      0x148   0xEB1A 0x0A09      ADDS     R10,R10,R9
   3024          
   3025          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3026                  /* In case of DTLS, double-check that we don't exceed
   3027                   * the remaining space in the datagram. */
   3028                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   3029                      ret = ssl_get_remaining_space_in_datagram(ssl);
   3030                      if (ret < 0) {
   3031                          return ret;
   3032                      }
   3033          
   3034                      if (protected_record_size > (size_t) ret) {
   3035                          /* Should never happen */
   3036                          return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3037                      }
   3038                  }
   3039          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3040          
   3041                  /* Now write the potentially updated record content type. */
   3042                  ssl->out_hdr[0] = (unsigned char) ssl->out_msgtype;
   \      0x14C   0xF8D7 0x10AC      LDR      R1,[R7, #+172]
   \      0x150   0xF8D7 0x009C      LDR      R0,[R7, #+156]
   \      0x154   0x7001             STRB     R1,[R0, #+0]
   3043          
   3044                  MBEDTLS_SSL_DEBUG_MSG(3, ("output record: msgtype = %u, "
   3045                                            "version = [%u:%u], msglen = %" MBEDTLS_PRINTF_SIZET,
   3046                                            ssl->out_hdr[0], ssl->out_hdr[1],
   3047                                            ssl->out_hdr[2], len));
   3048          
   3049                  MBEDTLS_SSL_DEBUG_BUF(4, "output record sent to network",
   3050                                        ssl->out_hdr, protected_record_size);
   3051          
   3052                  ssl->out_left += protected_record_size;
   \      0x156   0xF8D7 0x00B4      LDR      R0,[R7, #+180]
   \      0x15A   0xEB1A 0x0000      ADDS     R0,R10,R0
   \      0x15E   0xF8C7 0x00B4      STR      R0,[R7, #+180]
   3053                  ssl->out_hdr  += protected_record_size;
   \      0x162   0xF8D7 0x009C      LDR      R0,[R7, #+156]
   \      0x166   0x4450             ADD      R0,R0,R10
   \      0x168   0xF8C7 0x009C      STR      R0,[R7, #+156]
   3054                  mbedtls_ssl_update_out_pointers(ssl, ssl->transform_out);
   \      0x16C   0x6C39             LDR      R1,[R7, #+64]
   \      0x16E   0x0038             MOVS     R0,R7
   \      0x170   0x.... 0x....      BL       mbedtls_ssl_update_out_pointers
   3055          
   3056                  for (i = 8; i > mbedtls_ssl_ep_len(ssl); i--) {
   \      0x174   0xF05F 0x0908      MOVS     R9,#+8
   \                     ??mbedtls_ssl_write_record_8: (+1)
   \      0x178   0x0038             MOVS     R0,R7
   \      0x17A   0x.... 0x....      BL       mbedtls_ssl_ep_len
   \      0x17E   0x4548             CMP      R0,R9
   \      0x180   0xD211             BCS.N    ??mbedtls_ssl_write_record_9
   3057                      if (++ssl->cur_out_ctr[i - 1] != 0) {
   \      0x182   0xEB07 0x0009      ADD      R0,R7,R9
   \      0x186   0xF890 0x10B7      LDRB     R1,[R0, #+183]
   \      0x18A   0x1C49             ADDS     R1,R1,#+1
   \      0x18C   0xEB07 0x0009      ADD      R0,R7,R9
   \      0x190   0xF880 0x10B7      STRB     R1,[R0, #+183]
   \      0x194   0xEB07 0x0009      ADD      R0,R7,R9
   \      0x198   0xF890 0x00B7      LDRB     R0,[R0, #+183]
   \      0x19C   0x2800             CMP      R0,#+0
   \      0x19E   0xD102             BNE.N    ??mbedtls_ssl_write_record_9
   3058                          break;
   3059                      }
   3060                  }
   \                     ??mbedtls_ssl_write_record_10: (+1)
   \      0x1A0   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \      0x1A4   0xE7E8             B.N      ??mbedtls_ssl_write_record_8
   3061          
   3062                  /* The loop goes to its end if the counter is wrapping */
   3063                  if (i == mbedtls_ssl_ep_len(ssl)) {
   \                     ??mbedtls_ssl_write_record_9: (+1)
   \      0x1A6   0x0038             MOVS     R0,R7
   \      0x1A8   0x.... 0x....      BL       mbedtls_ssl_ep_len
   \      0x1AC   0x4581             CMP      R9,R0
   \      0x1AE   0xD102             BNE.N    ??mbedtls_ssl_write_record_0
   3064                      MBEDTLS_SSL_DEBUG_MSG(1, ("outgoing message counter would wrap"));
   3065                      return MBEDTLS_ERR_SSL_COUNTER_WRAPPING;
   \      0x1B0   0x.... 0x....      LDR.W    R0,??DataTable28
   \      0x1B4   0xE00B             B.N      ??mbedtls_ssl_write_record_5
   3066                  }
   3067              }
   3068          
   3069          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3070              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   3071                  flush == SSL_DONT_FORCE_FLUSH) {
   3072                  size_t remaining;
   3073                  ret = ssl_get_remaining_payload_in_datagram(ssl);
   3074                  if (ret < 0) {
   3075                      MBEDTLS_SSL_DEBUG_RET(1, "ssl_get_remaining_payload_in_datagram",
   3076                                            ret);
   3077                      return ret;
   3078                  }
   3079          
   3080                  remaining = (size_t) ret;
   3081                  if (remaining == 0) {
   3082                      flush = SSL_FORCE_FLUSH;
   3083                  } else {
   3084                      MBEDTLS_SSL_DEBUG_MSG(2,
   3085                                            ("Still %u bytes available in current datagram",
   3086                                             (unsigned) remaining));
   3087                  }
   3088              }
   3089          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3090          
   3091              if ((flush == SSL_FORCE_FLUSH) &&
   3092                  (ret = mbedtls_ssl_flush_output(ssl)) != 0) {
   \                     ??mbedtls_ssl_write_record_0: (+1)
   \      0x1B6   0x980B             LDR      R0,[SP, #+44]
   \      0x1B8   0x2801             CMP      R0,#+1
   \      0x1BA   0xD107             BNE.N    ??mbedtls_ssl_write_record_11
   \      0x1BC   0x0038             MOVS     R0,R7
   \      0x1BE   0x.... 0x....      BL       mbedtls_ssl_flush_output
   \      0x1C2   0x0006             MOVS     R6,R0
   \      0x1C4   0x2800             CMP      R0,#+0
   \      0x1C6   0xD001             BEQ.N    ??mbedtls_ssl_write_record_11
   3093                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_flush_output", ret);
   3094                  return ret;
   \      0x1C8   0x0030             MOVS     R0,R6
   \      0x1CA   0xE000             B.N      ??mbedtls_ssl_write_record_5
   3095              }
   3096          
   3097              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write record"));
   3098          
   3099              return 0;
   \                     ??mbedtls_ssl_write_record_11: (+1)
   \      0x1CC   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_write_record_5: (+1)
   \      0x1CE   0xB00D             ADD      SP,SP,#+52
   \      0x1D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3100          }
   3101          
   3102          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3103          
   3104          MBEDTLS_CHECK_RETURN_CRITICAL
   3105          static int ssl_hs_is_proper_fragment(mbedtls_ssl_context *ssl)
   3106          {
   3107              if (ssl->in_msglen < ssl->in_hslen ||
   3108                  memcmp(ssl->in_msg + 6, "\0\0\0",        3) != 0 ||
   3109                  memcmp(ssl->in_msg + 9, ssl->in_msg + 1, 3) != 0) {
   3110                  return 1;
   3111              }
   3112              return 0;
   3113          }
   3114          
   3115          static uint32_t ssl_get_hs_frag_len(mbedtls_ssl_context const *ssl)
   3116          {
   3117              return (ssl->in_msg[9] << 16) |
   3118                     (ssl->in_msg[10] << 8) |
   3119                     ssl->in_msg[11];
   3120          }
   3121          
   3122          static uint32_t ssl_get_hs_frag_off(mbedtls_ssl_context const *ssl)
   3123          {
   3124              return (ssl->in_msg[6] << 16) |
   3125                     (ssl->in_msg[7] << 8) |
   3126                     ssl->in_msg[8];
   3127          }
   3128          
   3129          MBEDTLS_CHECK_RETURN_CRITICAL
   3130          static int ssl_check_hs_header(mbedtls_ssl_context const *ssl)
   3131          {
   3132              uint32_t msg_len, frag_off, frag_len;
   3133          
   3134              msg_len  = ssl_get_hs_total_len(ssl);
   3135              frag_off = ssl_get_hs_frag_off(ssl);
   3136              frag_len = ssl_get_hs_frag_len(ssl);
   3137          
   3138              if (frag_off > msg_len) {
   3139                  return -1;
   3140              }
   3141          
   3142              if (frag_len > msg_len - frag_off) {
   3143                  return -1;
   3144              }
   3145          
   3146              if (frag_len + 12 > ssl->in_msglen) {
   3147                  return -1;
   3148              }
   3149          
   3150              return 0;
   3151          }
   3152          
   3153          /*
   3154           * Mark bits in bitmask (used for DTLS HS reassembly)
   3155           */
   3156          static void ssl_bitmask_set(unsigned char *mask, size_t offset, size_t len)
   3157          {
   3158              unsigned int start_bits, end_bits;
   3159          
   3160              start_bits = 8 - (offset % 8);
   3161              if (start_bits != 8) {
   3162                  size_t first_byte_idx = offset / 8;
   3163          
   3164                  /* Special case */
   3165                  if (len <= start_bits) {
   3166                      for (; len != 0; len--) {
   3167                          mask[first_byte_idx] |= 1 << (start_bits - len);
   3168                      }
   3169          
   3170                      /* Avoid potential issues with offset or len becoming invalid */
   3171                      return;
   3172                  }
   3173          
   3174                  offset += start_bits; /* Now offset % 8 == 0 */
   3175                  len -= start_bits;
   3176          
   3177                  for (; start_bits != 0; start_bits--) {
   3178                      mask[first_byte_idx] |= 1 << (start_bits - 1);
   3179                  }
   3180              }
   3181          
   3182              end_bits = len % 8;
   3183              if (end_bits != 0) {
   3184                  size_t last_byte_idx = (offset + len) / 8;
   3185          
   3186                  len -= end_bits; /* Now len % 8 == 0 */
   3187          
   3188                  for (; end_bits != 0; end_bits--) {
   3189                      mask[last_byte_idx] |= 1 << (8 - end_bits);
   3190                  }
   3191              }
   3192          
   3193              memset(mask + offset / 8, 0xFF, len / 8);
   3194          }
   3195          
   3196          /*
   3197           * Check that bitmask is full
   3198           */
   3199          MBEDTLS_CHECK_RETURN_CRITICAL
   3200          static int ssl_bitmask_check(unsigned char *mask, size_t len)
   3201          {
   3202              size_t i;
   3203          
   3204              for (i = 0; i < len / 8; i++) {
   3205                  if (mask[i] != 0xFF) {
   3206                      return -1;
   3207                  }
   3208              }
   3209          
   3210              for (i = 0; i < len % 8; i++) {
   3211                  if ((mask[len / 8] & (1 << (7 - i))) == 0) {
   3212                      return -1;
   3213                  }
   3214              }
   3215          
   3216              return 0;
   3217          }
   3218          
   3219          /* msg_len does not include the handshake header */
   3220          static size_t ssl_get_reassembly_buffer_size(size_t msg_len,
   3221                                                       unsigned add_bitmap)
   3222          {
   3223              size_t alloc_len;
   3224          
   3225              alloc_len  = 12;                                 /* Handshake header */
   3226              alloc_len += msg_len;                            /* Content buffer   */
   3227          
   3228              if (add_bitmap) {
   3229                  alloc_len += msg_len / 8 + (msg_len % 8 != 0);   /* Bitmap       */
   3230          
   3231              }
   3232              return alloc_len;
   3233          }
   3234          
   3235          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3236          

   \                                 In section .text, align 2, keep-with-next
   3237          static uint32_t ssl_get_hs_total_len(mbedtls_ssl_context const *ssl)
   3238          {
   \                     ssl_get_hs_total_len: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   3239              return (ssl->in_msg[1] << 16) |
   3240                     (ssl->in_msg[2] << 8) |
   3241                     ssl->in_msg[3];
   \        0x2   0x6EC8             LDR      R0,[R1, #+108]
   \        0x4   0x7842             LDRB     R2,[R0, #+1]
   \        0x6   0x6EC8             LDR      R0,[R1, #+108]
   \        0x8   0x7880             LDRB     R0,[R0, #+2]
   \        0xA   0x0200             LSLS     R0,R0,#+8
   \        0xC   0xEA50 0x4002      ORRS     R0,R0,R2, LSL #+16
   \       0x10   0x6EC9             LDR      R1,[R1, #+108]
   \       0x12   0x78C9             LDRB     R1,[R1, #+3]
   \       0x14   0x4308             ORRS     R0,R1,R0
   \       0x16   0x4770             BX       LR
   3242          }
   3243          

   \                                 In section .text, align 2, keep-with-next
   3244          int mbedtls_ssl_prepare_handshake_record(mbedtls_ssl_context *ssl)
   3245          {
   \                     mbedtls_ssl_prepare_handshake_record: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3246              if (ssl->in_msglen < mbedtls_ssl_hs_hdr_len(ssl)) {
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \        0xA   0x6FA1             LDR      R1,[R4, #+120]
   \        0xC   0x4281             CMP      R1,R0
   \        0xE   0xD202             BCS.N    ??mbedtls_ssl_prepare_handshake_record_0
   3247                  MBEDTLS_SSL_DEBUG_MSG(1, ("handshake message too short: %" MBEDTLS_PRINTF_SIZET,
   3248                                            ssl->in_msglen));
   3249                  return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x14   0xE012             B.N      ??mbedtls_ssl_prepare_handshake_record_1
   3250              }
   3251          
   3252              ssl->in_hslen = mbedtls_ssl_hs_hdr_len(ssl) + ssl_get_hs_total_len(ssl);
   \                     ??mbedtls_ssl_prepare_handshake_record_0: (+1)
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0x1C   0x0005             MOVS     R5,R0
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       ssl_get_hs_total_len
   \       0x24   0x1945             ADDS     R5,R0,R5
   \       0x26   0xF8C4 0x5080      STR      R5,[R4, #+128]
   3253          
   3254              MBEDTLS_SSL_DEBUG_MSG(3, ("handshake message: msglen ="
   3255                                        " %" MBEDTLS_PRINTF_SIZET ", type = %u, hslen = %"
   3256                                        MBEDTLS_PRINTF_SIZET,
   3257                                        ssl->in_msglen, ssl->in_msg[0], ssl->in_hslen));
   3258          
   3259          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3260              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   3261                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3262                  unsigned int recv_msg_seq = (ssl->in_msg[4] << 8) | ssl->in_msg[5];
   3263          
   3264                  if (ssl_check_hs_header(ssl) != 0) {
   3265                      MBEDTLS_SSL_DEBUG_MSG(1, ("invalid handshake header"));
   3266                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   3267                  }
   3268          
   3269                  if (ssl->handshake != NULL &&
   3270                      ((mbedtls_ssl_is_handshake_over(ssl) == 0 &&
   3271                        recv_msg_seq != ssl->handshake->in_msg_seq) ||
   3272                       (mbedtls_ssl_is_handshake_over(ssl) == 1 &&
   3273                        ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_HELLO))) {
   3274                      if (recv_msg_seq > ssl->handshake->in_msg_seq) {
   3275                          MBEDTLS_SSL_DEBUG_MSG(2,
   3276                                                (
   3277                                                    "received future handshake message of sequence number %u (next %u)",
   3278                                                    recv_msg_seq,
   3279                                                    ssl->handshake->in_msg_seq));
   3280                          return MBEDTLS_ERR_SSL_EARLY_MESSAGE;
   3281                      }
   3282          
   3283                      /* Retransmit only on last message from previous flight, to avoid
   3284                       * too many retransmissions.
   3285                       * Besides, No sane server ever retransmits HelloVerifyRequest */
   3286                      if (recv_msg_seq == ssl->handshake->in_flight_start_seq - 1 &&
   3287                          ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST) {
   3288                          MBEDTLS_SSL_DEBUG_MSG(2, ("received message from last flight, "
   3289                                                    "message_seq = %u, start_of_flight = %u",
   3290                                                    recv_msg_seq,
   3291                                                    ssl->handshake->in_flight_start_seq));
   3292          
   3293                          if ((ret = mbedtls_ssl_resend(ssl)) != 0) {
   3294                              MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_resend", ret);
   3295                              return ret;
   3296                          }
   3297                      } else {
   3298                          MBEDTLS_SSL_DEBUG_MSG(2, ("dropping out-of-sequence message: "
   3299                                                    "message_seq = %u, expected = %u",
   3300                                                    recv_msg_seq,
   3301                                                    ssl->handshake->in_msg_seq));
   3302                      }
   3303          
   3304                      return MBEDTLS_ERR_SSL_CONTINUE_PROCESSING;
   3305                  }
   3306                  /* Wait until message completion to increment in_msg_seq */
   3307          
   3308                  /* Message reassembly is handled alongside buffering of future
   3309                   * messages; the commonality is that both handshake fragments and
   3310                   * future messages cannot be forwarded immediately to the
   3311                   * handshake logic layer. */
   3312                  if (ssl_hs_is_proper_fragment(ssl) == 1) {
   3313                      MBEDTLS_SSL_DEBUG_MSG(2, ("found fragmented DTLS handshake message"));
   3314                      return MBEDTLS_ERR_SSL_EARLY_MESSAGE;
   3315                  }
   3316              } else
   3317          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3318              /* With TLS we don't handle fragmentation (for now) */
   3319              if (ssl->in_msglen < ssl->in_hslen) {
   \       0x2A   0x6FA1             LDR      R1,[R4, #+120]
   \       0x2C   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \       0x30   0x4281             CMP      R1,R0
   \       0x32   0xD202             BCS.N    ??mbedtls_ssl_prepare_handshake_record_2
   3320                  MBEDTLS_SSL_DEBUG_MSG(1, ("TLS handshake fragmentation not supported"));
   3321                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable28_2
   \       0x38   0xE000             B.N      ??mbedtls_ssl_prepare_handshake_record_1
   3322              }
   3323          
   3324              return 0;
   \                     ??mbedtls_ssl_prepare_handshake_record_2: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_prepare_handshake_record_1: (+1)
   \       0x3C   0xBD32             POP      {R1,R4,R5,PC}
   3325          }
   3326          

   \                                 In section .text, align 2, keep-with-next
   3327          int mbedtls_ssl_update_handshake_status(mbedtls_ssl_context *ssl)
   3328          {
   \                     mbedtls_ssl_update_handshake_status: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   3329              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x046D      MVNS     R4,#+109
   3330              mbedtls_ssl_handshake_params * const hs = ssl->handshake;
   \        0x8   0x6BB5             LDR      R5,[R6, #+56]
   3331          
   3332              if (mbedtls_ssl_is_handshake_over(ssl) == 0 && hs != NULL) {
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x.... 0x....      BL       mbedtls_ssl_is_handshake_over
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD10D             BNE.N    ??mbedtls_ssl_update_handshake_status_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD00B             BEQ.N    ??mbedtls_ssl_update_handshake_status_0
   3333                  ret = ssl->handshake->update_checksum(ssl, ssl->in_msg, ssl->in_hslen);
   \       0x18   0xF8D6 0x2080      LDR      R2,[R6, #+128]
   \       0x1C   0x6EF1             LDR      R1,[R6, #+108]
   \       0x1E   0x0030             MOVS     R0,R6
   \       0x20   0x6BB3             LDR      R3,[R6, #+56]
   \       0x22   0x68DB             LDR      R3,[R3, #+12]
   \       0x24   0x4798             BLX      R3
   \       0x26   0x0004             MOVS     R4,R0
   3334                  if (ret != 0) {
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD001             BEQ.N    ??mbedtls_ssl_update_handshake_status_0
   3335                      MBEDTLS_SSL_DEBUG_RET(1, "update_checksum", ret);
   3336                      return ret;
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0xE000             B.N      ??mbedtls_ssl_update_handshake_status_1
   3337                  }
   3338              }
   3339          
   3340              /* Handshake message is complete, increment counter */
   3341          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3342              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   3343                  ssl->handshake != NULL) {
   3344                  unsigned offset;
   3345                  mbedtls_ssl_hs_buffer *hs_buf;
   3346          
   3347                  /* Increment handshake sequence number */
   3348                  hs->in_msg_seq++;
   3349          
   3350                  /*
   3351                   * Clear up handshake buffering and reassembly structure.
   3352                   */
   3353          
   3354                  /* Free first entry */
   3355                  ssl_buffering_free_slot(ssl, 0);
   3356          
   3357                  /* Shift all other entries */
   3358                  for (offset = 0, hs_buf = &hs->buffering.hs[0];
   3359                       offset + 1 < MBEDTLS_SSL_MAX_BUFFERED_HS;
   3360                       offset++, hs_buf++) {
   3361                      *hs_buf = *(hs_buf + 1);
   3362                  }
   3363          
   3364                  /* Create a fresh last entry */
   3365                  memset(hs_buf, 0, sizeof(mbedtls_ssl_hs_buffer));
   3366              }
   3367          #endif
   3368              return 0;
   \                     ??mbedtls_ssl_update_handshake_status_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_update_handshake_status_1: (+1)
   \       0x32   0xBD70             POP      {R4-R6,PC}
   3369          }
   3370          
   3371          /*
   3372           * DTLS anti-replay: RFC 6347 4.1.2.6
   3373           *
   3374           * in_window is a field of bits numbered from 0 (lsb) to 63 (msb).
   3375           * Bit n is set iff record number in_window_top - n has been seen.
   3376           *
   3377           * Usually, in_window_top is the last record number seen and the lsb of
   3378           * in_window is set. The only exception is the initial state (record number 0
   3379           * not seen yet).
   3380           */
   3381          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   3382          void mbedtls_ssl_dtls_replay_reset(mbedtls_ssl_context *ssl)
   3383          {
   3384              ssl->in_window_top = 0;
   3385              ssl->in_window = 0;
   3386          }
   3387          
   3388          static inline uint64_t ssl_load_six_bytes(unsigned char *buf)
   3389          {
   3390              return ((uint64_t) buf[0] << 40) |
   3391                     ((uint64_t) buf[1] << 32) |
   3392                     ((uint64_t) buf[2] << 24) |
   3393                     ((uint64_t) buf[3] << 16) |
   3394                     ((uint64_t) buf[4] <<  8) |
   3395                     ((uint64_t) buf[5]);
   3396          }
   3397          
   3398          MBEDTLS_CHECK_RETURN_CRITICAL
   3399          static int mbedtls_ssl_dtls_record_replay_check(mbedtls_ssl_context *ssl, uint8_t *record_in_ctr)
   3400          {
   3401              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3402              unsigned char *original_in_ctr;
   3403          
   3404              // save original in_ctr
   3405              original_in_ctr = ssl->in_ctr;
   3406          
   3407              // use counter from record
   3408              ssl->in_ctr = record_in_ctr;
   3409          
   3410              ret = mbedtls_ssl_dtls_replay_check((mbedtls_ssl_context const *) ssl);
   3411          
   3412              // restore the counter
   3413              ssl->in_ctr = original_in_ctr;
   3414          
   3415              return ret;
   3416          }
   3417          
   3418          /*
   3419           * Return 0 if sequence number is acceptable, -1 otherwise
   3420           */
   3421          int mbedtls_ssl_dtls_replay_check(mbedtls_ssl_context const *ssl)
   3422          {
   3423              uint64_t rec_seqnum = ssl_load_six_bytes(ssl->in_ctr + 2);
   3424              uint64_t bit;
   3425          
   3426              if (ssl->conf->anti_replay == MBEDTLS_SSL_ANTI_REPLAY_DISABLED) {
   3427                  return 0;
   3428              }
   3429          
   3430              if (rec_seqnum > ssl->in_window_top) {
   3431                  return 0;
   3432              }
   3433          
   3434              bit = ssl->in_window_top - rec_seqnum;
   3435          
   3436              if (bit >= 64) {
   3437                  return -1;
   3438              }
   3439          
   3440              if ((ssl->in_window & ((uint64_t) 1 << bit)) != 0) {
   3441                  return -1;
   3442              }
   3443          
   3444              return 0;
   3445          }
   3446          
   3447          /*
   3448           * Update replay window on new validated record
   3449           */
   3450          void mbedtls_ssl_dtls_replay_update(mbedtls_ssl_context *ssl)
   3451          {
   3452              uint64_t rec_seqnum = ssl_load_six_bytes(ssl->in_ctr + 2);
   3453          
   3454              if (ssl->conf->anti_replay == MBEDTLS_SSL_ANTI_REPLAY_DISABLED) {
   3455                  return;
   3456              }
   3457          
   3458              if (rec_seqnum > ssl->in_window_top) {
   3459                  /* Update window_top and the contents of the window */
   3460                  uint64_t shift = rec_seqnum - ssl->in_window_top;
   3461          
   3462                  if (shift >= 64) {
   3463                      ssl->in_window = 1;
   3464                  } else {
   3465                      ssl->in_window <<= shift;
   3466                      ssl->in_window |= 1;
   3467                  }
   3468          
   3469                  ssl->in_window_top = rec_seqnum;
   3470              } else {
   3471                  /* Mark that number as seen in the current window */
   3472                  uint64_t bit = ssl->in_window_top - rec_seqnum;
   3473          
   3474                  if (bit < 64) { /* Always true, but be extra sure */
   3475                      ssl->in_window |= (uint64_t) 1 << bit;
   3476                  }
   3477              }
   3478          }
   3479          #endif /* MBEDTLS_SSL_DTLS_ANTI_REPLAY */
   3480          
   3481          #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && defined(MBEDTLS_SSL_SRV_C)
   3482          /*
   3483           * Check if a datagram looks like a ClientHello with a valid cookie,
   3484           * and if it doesn't, generate a HelloVerifyRequest message.
   3485           * Both input and output include full DTLS headers.
   3486           *
   3487           * - if cookie is valid, return 0
   3488           * - if ClientHello looks superficially valid but cookie is not,
   3489           *   fill obuf and set olen, then
   3490           *   return MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED
   3491           * - otherwise return a specific error code
   3492           */
   3493          MBEDTLS_CHECK_RETURN_CRITICAL
   3494          MBEDTLS_STATIC_TESTABLE
   3495          int mbedtls_ssl_check_dtls_clihlo_cookie(
   3496              mbedtls_ssl_context *ssl,
   3497              const unsigned char *cli_id, size_t cli_id_len,
   3498              const unsigned char *in, size_t in_len,
   3499              unsigned char *obuf, size_t buf_len, size_t *olen)
   3500          {
   3501              size_t sid_len, cookie_len, epoch, fragment_offset;
   3502              unsigned char *p;
   3503          
   3504              /*
   3505               * Structure of ClientHello with record and handshake headers,
   3506               * and expected values. We don't need to check a lot, more checks will be
   3507               * done when actually parsing the ClientHello - skipping those checks
   3508               * avoids code duplication and does not make cookie forging any easier.
   3509               *
   3510               *  0-0  ContentType type;                  copied, must be handshake
   3511               *  1-2  ProtocolVersion version;           copied
   3512               *  3-4  uint16 epoch;                      copied, must be 0
   3513               *  5-10 uint48 sequence_number;            copied
   3514               * 11-12 uint16 length;                     (ignored)
   3515               *
   3516               * 13-13 HandshakeType msg_type;            (ignored)
   3517               * 14-16 uint24 length;                     (ignored)
   3518               * 17-18 uint16 message_seq;                copied
   3519               * 19-21 uint24 fragment_offset;            copied, must be 0
   3520               * 22-24 uint24 fragment_length;            (ignored)
   3521               *
   3522               * 25-26 ProtocolVersion client_version;    (ignored)
   3523               * 27-58 Random random;                     (ignored)
   3524               * 59-xx SessionID session_id;              1 byte len + sid_len content
   3525               * 60+   opaque cookie<0..2^8-1>;           1 byte len + content
   3526               *       ...
   3527               *
   3528               * Minimum length is 61 bytes.
   3529               */
   3530              MBEDTLS_SSL_DEBUG_MSG(4, ("check cookie: in_len=%u",
   3531                                        (unsigned) in_len));
   3532              MBEDTLS_SSL_DEBUG_BUF(4, "cli_id", cli_id, cli_id_len);
   3533              if (in_len < 61) {
   3534                  MBEDTLS_SSL_DEBUG_MSG(4, ("check cookie: record too short"));
   3535                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3536              }
   3537          
   3538              epoch = MBEDTLS_GET_UINT16_BE(in, 3);
   3539              fragment_offset = MBEDTLS_GET_UINT24_BE(in, 19);
   3540          
   3541              if (in[0] != MBEDTLS_SSL_MSG_HANDSHAKE || epoch != 0 ||
   3542                  fragment_offset != 0) {
   3543                  MBEDTLS_SSL_DEBUG_MSG(4, ("check cookie: not a good ClientHello"));
   3544                  MBEDTLS_SSL_DEBUG_MSG(4, ("    type=%u epoch=%u fragment_offset=%u",
   3545                                            in[0], (unsigned) epoch,
   3546                                            (unsigned) fragment_offset));
   3547                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3548              }
   3549          
   3550              sid_len = in[59];
   3551              if (59 + 1 + sid_len + 1 > in_len) {
   3552                  MBEDTLS_SSL_DEBUG_MSG(4, ("check cookie: sid_len=%u > %u",
   3553                                            (unsigned) sid_len,
   3554                                            (unsigned) in_len - 61));
   3555                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3556              }
   3557              MBEDTLS_SSL_DEBUG_BUF(4, "sid received from network",
   3558                                    in + 60, sid_len);
   3559          
   3560              cookie_len = in[60 + sid_len];
   3561              if (59 + 1 + sid_len + 1 + cookie_len > in_len) {
   3562                  MBEDTLS_SSL_DEBUG_MSG(4, ("check cookie: cookie_len=%u > %u",
   3563                                            (unsigned) cookie_len,
   3564                                            (unsigned) (in_len - sid_len - 61)));
   3565                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3566              }
   3567          
   3568              MBEDTLS_SSL_DEBUG_BUF(4, "cookie received from network",
   3569                                    in + sid_len + 61, cookie_len);
   3570              if (ssl->conf->f_cookie_check(ssl->conf->p_cookie,
   3571                                            in + sid_len + 61, cookie_len,
   3572                                            cli_id, cli_id_len) == 0) {
   3573                  MBEDTLS_SSL_DEBUG_MSG(4, ("check cookie: valid"));
   3574                  return 0;
   3575              }
   3576          
   3577              /*
   3578               * If we get here, we've got an invalid cookie, let's prepare HVR.
   3579               *
   3580               *  0-0  ContentType type;                  copied
   3581               *  1-2  ProtocolVersion version;           copied
   3582               *  3-4  uint16 epoch;                      copied
   3583               *  5-10 uint48 sequence_number;            copied
   3584               * 11-12 uint16 length;                     olen - 13
   3585               *
   3586               * 13-13 HandshakeType msg_type;            hello_verify_request
   3587               * 14-16 uint24 length;                     olen - 25
   3588               * 17-18 uint16 message_seq;                copied
   3589               * 19-21 uint24 fragment_offset;            copied
   3590               * 22-24 uint24 fragment_length;            olen - 25
   3591               *
   3592               * 25-26 ProtocolVersion server_version;    0xfe 0xff
   3593               * 27-27 opaque cookie<0..2^8-1>;           cookie_len = olen - 27, cookie
   3594               *
   3595               * Minimum length is 28.
   3596               */
   3597              if (buf_len < 28) {
   3598                  return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   3599              }
   3600          
   3601              /* Copy most fields and adapt others */
   3602              memcpy(obuf, in, 25);
   3603              obuf[13] = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
   3604              obuf[25] = 0xfe;
   3605              obuf[26] = 0xff;
   3606          
   3607              /* Generate and write actual cookie */
   3608              p = obuf + 28;
   3609              if (ssl->conf->f_cookie_write(ssl->conf->p_cookie,
   3610                                            &p, obuf + buf_len,
   3611                                            cli_id, cli_id_len) != 0) {
   3612                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3613              }
   3614          
   3615              *olen = p - obuf;
   3616          
   3617              /* Go back and fill length fields */
   3618              obuf[27] = (unsigned char) (*olen - 28);
   3619          
   3620              obuf[14] = obuf[22] = MBEDTLS_BYTE_2(*olen - 25);
   3621              obuf[15] = obuf[23] = MBEDTLS_BYTE_1(*olen - 25);
   3622              obuf[16] = obuf[24] = MBEDTLS_BYTE_0(*olen - 25);
   3623          
   3624              MBEDTLS_PUT_UINT16_BE(*olen - 13, obuf, 11);
   3625          
   3626              return MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED;
   3627          }
   3628          
   3629          /*
   3630           * Handle possible client reconnect with the same UDP quadruplet
   3631           * (RFC 6347 Section 4.2.8).
   3632           *
   3633           * Called by ssl_parse_record_header() in case we receive an epoch 0 record
   3634           * that looks like a ClientHello.
   3635           *
   3636           * - if the input looks like a ClientHello without cookies,
   3637           *   send back HelloVerifyRequest, then return 0
   3638           * - if the input looks like a ClientHello with a valid cookie,
   3639           *   reset the session of the current context, and
   3640           *   return MBEDTLS_ERR_SSL_CLIENT_RECONNECT
   3641           * - if anything goes wrong, return a specific error code
   3642           *
   3643           * This function is called (through ssl_check_client_reconnect()) when an
   3644           * unexpected record is found in ssl_get_next_record(), which will discard the
   3645           * record if we return 0, and bubble up the return value otherwise (this
   3646           * includes the case of MBEDTLS_ERR_SSL_CLIENT_RECONNECT and of unexpected
   3647           * errors, and is the right thing to do in both cases).
   3648           */
   3649          MBEDTLS_CHECK_RETURN_CRITICAL
   3650          static int ssl_handle_possible_reconnect(mbedtls_ssl_context *ssl)
   3651          {
   3652              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3653              size_t len;
   3654          
   3655              if (ssl->conf->f_cookie_write == NULL ||
   3656                  ssl->conf->f_cookie_check == NULL) {
   3657                  /* If we can't use cookies to verify reachability of the peer,
   3658                   * drop the record. */
   3659                  MBEDTLS_SSL_DEBUG_MSG(1, ("no cookie callbacks, "
   3660                                            "can't check reconnect validity"));
   3661                  return 0;
   3662              }
   3663          
   3664              ret = mbedtls_ssl_check_dtls_clihlo_cookie(
   3665                  ssl,
   3666                  ssl->cli_id, ssl->cli_id_len,
   3667                  ssl->in_buf, ssl->in_left,
   3668                  ssl->out_buf, MBEDTLS_SSL_OUT_CONTENT_LEN, &len);
   3669          
   3670              MBEDTLS_SSL_DEBUG_RET(2, "mbedtls_ssl_check_dtls_clihlo_cookie", ret);
   3671          
   3672              if (ret == MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED) {
   3673                  int send_ret;
   3674                  MBEDTLS_SSL_DEBUG_MSG(1, ("sending HelloVerifyRequest"));
   3675                  MBEDTLS_SSL_DEBUG_BUF(4, "output record sent to network",
   3676                                        ssl->out_buf, len);
   3677                  /* Don't check write errors as we can't do anything here.
   3678                   * If the error is permanent we'll catch it later,
   3679                   * if it's not, then hopefully it'll work next time. */
   3680                  send_ret = ssl->f_send(ssl->p_bio, ssl->out_buf, len);
   3681                  MBEDTLS_SSL_DEBUG_RET(2, "ssl->f_send", send_ret);
   3682                  (void) send_ret;
   3683          
   3684                  return 0;
   3685              }
   3686          
   3687              if (ret == 0) {
   3688                  MBEDTLS_SSL_DEBUG_MSG(1, ("cookie is valid, resetting context"));
   3689                  if ((ret = mbedtls_ssl_session_reset_int(ssl, 1)) != 0) {
   3690                      MBEDTLS_SSL_DEBUG_RET(1, "reset", ret);
   3691                      return ret;
   3692                  }
   3693          
   3694                  return MBEDTLS_ERR_SSL_CLIENT_RECONNECT;
   3695              }
   3696          
   3697              return ret;
   3698          }
   3699          #endif /* MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE && MBEDTLS_SSL_SRV_C */
   3700          
   3701          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   3702          static int ssl_check_record_type(uint8_t record_type)
   3703          {
   \                     ssl_check_record_type: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   3704              if (record_type != MBEDTLS_SSL_MSG_HANDSHAKE &&
   3705                  record_type != MBEDTLS_SSL_MSG_ALERT &&
   3706                  record_type != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
   3707                  record_type != MBEDTLS_SSL_MSG_APPLICATION_DATA) {
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB2C0             UXTB     R0,R0
   \        0x6   0x2816             CMP      R0,#+22
   \        0x8   0xD00E             BEQ.N    ??ssl_check_record_type_0
   \        0xA   0x0008             MOVS     R0,R1
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2815             CMP      R0,#+21
   \       0x10   0xD00A             BEQ.N    ??ssl_check_record_type_0
   \       0x12   0x0008             MOVS     R0,R1
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2814             CMP      R0,#+20
   \       0x18   0xD006             BEQ.N    ??ssl_check_record_type_0
   \       0x1A   0x0008             MOVS     R0,R1
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x2817             CMP      R0,#+23
   \       0x20   0xD002             BEQ.N    ??ssl_check_record_type_0
   3708                  return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x26   0xE000             B.N      ??ssl_check_record_type_1
   3709              }
   3710          
   3711              return 0;
   \                     ??ssl_check_record_type_0: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??ssl_check_record_type_1: (+1)
   \       0x2A   0x4770             BX       LR
   3712          }
   3713          
   3714          /*
   3715           * ContentType type;
   3716           * ProtocolVersion version;
   3717           * uint16 epoch;            // DTLS only
   3718           * uint48 sequence_number;  // DTLS only
   3719           * uint16 length;
   3720           *
   3721           * Return 0 if header looks sane (and, for DTLS, the record is expected)
   3722           * MBEDTLS_ERR_SSL_INVALID_RECORD if the header looks bad,
   3723           * MBEDTLS_ERR_SSL_UNEXPECTED_RECORD (DTLS only) if sane but unexpected.
   3724           *
   3725           * With DTLS, mbedtls_ssl_read_record() will:
   3726           * 1. proceed with the record if this function returns 0
   3727           * 2. drop only the current record if this function returns UNEXPECTED_RECORD
   3728           * 3. return CLIENT_RECONNECT if this function return that value
   3729           * 4. drop the whole datagram if this function returns anything else.
   3730           * Point 2 is needed when the peer is resending, and we have already received
   3731           * the first record from a datagram but are still waiting for the others.
   3732           */
   3733          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   3734          static int ssl_parse_record_header(mbedtls_ssl_context const *ssl,
   3735                                             unsigned char *buf,
   3736                                             size_t len,
   3737                                             mbedtls_record *rec)
   3738          {
   \                     ssl_parse_record_header: (+1)
   \        0x0   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x001D             MOVS     R5,R3
   3739              mbedtls_ssl_protocol_version tls_version;
   3740          
   3741              size_t const rec_hdr_type_offset    = 0;
   \        0xC   0x2600             MOVS     R6,#+0
   3742              size_t const rec_hdr_type_len       = 1;
   \        0xE   0x2701             MOVS     R7,#+1
   3743          
   3744              size_t const rec_hdr_version_offset = rec_hdr_type_offset +
   3745                                                    rec_hdr_type_len;
   \       0x10   0x19B8             ADDS     R0,R7,R6
   \       0x12   0x9000             STR      R0,[SP, #+0]
   3746              size_t const rec_hdr_version_len    = 2;
   \       0x14   0xF05F 0x0802      MOVS     R8,#+2
   3747          
   3748              size_t const rec_hdr_ctr_len        = 8;
   \       0x18   0x2008             MOVS     R0,#+8
   \       0x1A   0x9005             STR      R0,[SP, #+20]
   3749          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3750              uint32_t     rec_epoch;
   3751              size_t const rec_hdr_ctr_offset     = rec_hdr_version_offset +
   3752                                                    rec_hdr_version_len;
   3753          
   3754          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   3755              size_t const rec_hdr_cid_offset     = rec_hdr_ctr_offset +
   3756                                                    rec_hdr_ctr_len;
   3757              size_t       rec_hdr_cid_len        = 0;
   3758          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   3759          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3760          
   3761              size_t       rec_hdr_len_offset; /* To be determined */
   3762              size_t const rec_hdr_len_len    = 2;
   \       0x1C   0xF05F 0x0902      MOVS     R9,#+2
   3763          
   3764              /*
   3765               * Check minimum lengths for record header.
   3766               */
   3767          
   3768          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3769              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   3770                  rec_hdr_len_offset = rec_hdr_ctr_offset + rec_hdr_ctr_len;
   3771              } else
   3772          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3773              {
   3774                  rec_hdr_len_offset = rec_hdr_version_offset + rec_hdr_version_len;
   \       0x20   0x9800             LDR      R0,[SP, #+0]
   \       0x22   0xEB18 0x0000      ADDS     R0,R8,R0
   \       0x26   0x9001             STR      R0,[SP, #+4]
   3775              }
   3776          
   3777              if (len < rec_hdr_len_offset + rec_hdr_len_len) {
   \       0x28   0x9906             LDR      R1,[SP, #+24]
   \       0x2A   0x9801             LDR      R0,[SP, #+4]
   \       0x2C   0xEB19 0x0000      ADDS     R0,R9,R0
   \       0x30   0x4281             CMP      R1,R0
   \       0x32   0xD202             BCS.N    ??ssl_parse_record_header_0
   3778                  MBEDTLS_SSL_DEBUG_MSG(1,
   3779                                        (
   3780                                            "datagram of length %u too small to hold DTLS record header of length %u",
   3781                                            (unsigned) len,
   3782                                            (unsigned) (rec_hdr_len_len + rec_hdr_len_len)));
   3783                  return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x38   0xE047             B.N      ??ssl_parse_record_header_1
   3784              }
   3785          
   3786              /*
   3787               * Parse and validate record content type
   3788               */
   3789          
   3790              rec->type = buf[rec_hdr_type_offset];
   \                     ??ssl_parse_record_header_0: (+1)
   \       0x3A   0x5DA0             LDRB     R0,[R4, R6]
   \       0x3C   0x7228             STRB     R0,[R5, #+8]
   3791          
   3792              /* Check record content type */
   3793          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   3794              rec->cid_len = 0;
   3795          
   3796              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   3797                  ssl->conf->cid_len != 0                                &&
   3798                  rec->type == MBEDTLS_SSL_MSG_CID) {
   3799                  /* Shift pointers to account for record header including CID
   3800                   * struct {
   3801                   *   ContentType outer_type = tls12_cid;
   3802                   *   ProtocolVersion version;
   3803                   *   uint16 epoch;
   3804                   *   uint48 sequence_number;
   3805                   *   opaque cid[cid_length]; // Additional field compared to
   3806                   *                           // default DTLS record format
   3807                   *   uint16 length;
   3808                   *   opaque enc_content[DTLSCiphertext.length];
   3809                   * } DTLSCiphertext;
   3810                   */
   3811          
   3812                  /* So far, we only support static CID lengths
   3813                   * fixed in the configuration. */
   3814                  rec_hdr_cid_len = ssl->conf->cid_len;
   3815                  rec_hdr_len_offset += rec_hdr_cid_len;
   3816          
   3817                  if (len < rec_hdr_len_offset + rec_hdr_len_len) {
   3818                      MBEDTLS_SSL_DEBUG_MSG(1,
   3819                                            (
   3820                                                "datagram of length %u too small to hold DTLS record header including CID, length %u",
   3821                                                (unsigned) len,
   3822                                                (unsigned) (rec_hdr_len_offset + rec_hdr_len_len)));
   3823                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   3824                  }
   3825          
   3826                  /* configured CID len is guaranteed at most 255, see
   3827                   * MBEDTLS_SSL_CID_OUT_LEN_MAX in check_config.h */
   3828                  rec->cid_len = (uint8_t) rec_hdr_cid_len;
   3829                  memcpy(rec->cid, buf + rec_hdr_cid_offset, rec_hdr_cid_len);
   3830              } else
   3831          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   3832              {
   3833                  if (ssl_check_record_type(rec->type)) {
   \       0x3E   0x7A28             LDRB     R0,[R5, #+8]
   \       0x40   0x.... 0x....      BL       ssl_check_record_type
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD002             BEQ.N    ??ssl_parse_record_header_2
   3834                      MBEDTLS_SSL_DEBUG_MSG(1, ("unknown record type %u",
   3835                                                (unsigned) rec->type));
   3836                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x4C   0xE03D             B.N      ??ssl_parse_record_header_1
   3837                  }
   3838              }
   3839          
   3840              /*
   3841               * Parse and validate record version
   3842               */
   3843              rec->ver[0] = buf[rec_hdr_version_offset + 0];
   \                     ??ssl_parse_record_header_2: (+1)
   \       0x4E   0x9800             LDR      R0,[SP, #+0]
   \       0x50   0x5C20             LDRB     R0,[R4, R0]
   \       0x52   0x7268             STRB     R0,[R5, #+9]
   3844              rec->ver[1] = buf[rec_hdr_version_offset + 1];
   \       0x54   0x9800             LDR      R0,[SP, #+0]
   \       0x56   0x4420             ADD      R0,R4,R0
   \       0x58   0x7840             LDRB     R0,[R0, #+1]
   \       0x5A   0x72A8             STRB     R0,[R5, #+10]
   3845              tls_version = (mbedtls_ssl_protocol_version) mbedtls_ssl_read_version(
   3846                  buf + rec_hdr_version_offset,
   3847                  ssl->conf->transport);
   \       0x5C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x60   0x7941             LDRB     R1,[R0, #+5]
   \       0x62   0x9800             LDR      R0,[SP, #+0]
   \       0x64   0x4420             ADD      R0,R4,R0
   \       0x66   0x.... 0x....      BL       mbedtls_ssl_read_version
   \       0x6A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   3848          
   3849              if (tls_version > ssl->conf->max_tls_version) {
   \       0x6E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x72   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \       0x76   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \       0x7A   0x4281             CMP      R1,R0
   \       0x7C   0xDA02             BGE.N    ??ssl_parse_record_header_3
   3850                  MBEDTLS_SSL_DEBUG_MSG(1, ("TLS version mismatch: got %u, expected max %u",
   3851                                            (unsigned) tls_version,
   3852                                            (unsigned) ssl->conf->max_tls_version));
   3853          
   3854                  return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x82   0xE022             B.N      ??ssl_parse_record_header_1
   3855              }
   3856              /*
   3857               * Parse/Copy record sequence number.
   3858               */
   3859          
   3860          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3861              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   3862                  /* Copy explicit record sequence number from input buffer. */
   3863                  memcpy(&rec->ctr[0], buf + rec_hdr_ctr_offset,
   3864                         rec_hdr_ctr_len);
   3865              } else
   3866          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3867              {
   3868                  /* Copy implicit record sequence number from SSL context structure. */
   3869                  memcpy(&rec->ctr[0], ssl->in_ctr, rec_hdr_ctr_len);
   \                     ??ssl_parse_record_header_3: (+1)
   \       0x84   0x9805             LDR      R0,[SP, #+20]
   \       0x86   0x9004             STR      R0,[SP, #+16]
   \       0x88   0xF8DA 0x005C      LDR      R0,[R10, #+92]
   \       0x8C   0x9003             STR      R0,[SP, #+12]
   \       0x8E   0x46AB             MOV      R11,R5
   \       0x90   0x9A04             LDR      R2,[SP, #+16]
   \       0x92   0x9903             LDR      R1,[SP, #+12]
   \       0x94   0x4658             MOV      R0,R11
   \       0x96   0x.... 0x....      BL       __aeabi_memcpy
   3870              }
   3871          
   3872              /*
   3873               * Parse record length.
   3874               */
   3875          
   3876              rec->data_offset = rec_hdr_len_offset + rec_hdr_len_len;
   \       0x9A   0x9801             LDR      R0,[SP, #+4]
   \       0x9C   0xEB19 0x0000      ADDS     R0,R9,R0
   \       0xA0   0x6168             STR      R0,[R5, #+20]
   3877              rec->data_len    = ((size_t) buf[rec_hdr_len_offset + 0] << 8) |
   3878                                 ((size_t) buf[rec_hdr_len_offset + 1] << 0);
   \       0xA2   0x9801             LDR      R0,[SP, #+4]
   \       0xA4   0x5C20             LDRB     R0,[R4, R0]
   \       0xA6   0x9901             LDR      R1,[SP, #+4]
   \       0xA8   0x4421             ADD      R1,R4,R1
   \       0xAA   0x7849             LDRB     R1,[R1, #+1]
   \       0xAC   0xEA51 0x2100      ORRS     R1,R1,R0, LSL #+8
   \       0xB0   0x61A9             STR      R1,[R5, #+24]
   3879              MBEDTLS_SSL_DEBUG_BUF(4, "input record header", buf, rec->data_offset);
   3880          
   3881              MBEDTLS_SSL_DEBUG_MSG(3, ("input record: msgtype = %u, "
   3882                                        "version = [0x%x], msglen = %" MBEDTLS_PRINTF_SIZET,
   3883                                        rec->type, (unsigned) tls_version, rec->data_len));
   3884          
   3885              rec->buf     = buf;
   \       0xB2   0x60EC             STR      R4,[R5, #+12]
   3886              rec->buf_len = rec->data_offset + rec->data_len;
   \       0xB4   0x6969             LDR      R1,[R5, #+20]
   \       0xB6   0x69A8             LDR      R0,[R5, #+24]
   \       0xB8   0x1841             ADDS     R1,R0,R1
   \       0xBA   0x6129             STR      R1,[R5, #+16]
   3887          
   3888              if (rec->data_len == 0) {
   \       0xBC   0x69A8             LDR      R0,[R5, #+24]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD102             BNE.N    ??ssl_parse_record_header_4
   3889                  return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0xC2   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0xC6   0xE000             B.N      ??ssl_parse_record_header_1
   3890              }
   3891          
   3892              /*
   3893               * DTLS-related tests.
   3894               * Check epoch before checking length constraint because
   3895               * the latter varies with the epoch. E.g., if a ChangeCipherSpec
   3896               * message gets duplicated before the corresponding Finished message,
   3897               * the second ChangeCipherSpec should be discarded because it belongs
   3898               * to an old epoch, but not because its length is shorter than
   3899               * the minimum record length for packets using the new record transform.
   3900               * Note that these two kinds of failures are handled differently,
   3901               * as an unexpected record is silently skipped but an invalid
   3902               * record leads to the entire datagram being dropped.
   3903               */
   3904          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3905              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   3906                  rec_epoch = (rec->ctr[0] << 8) | rec->ctr[1];
   3907          
   3908                  /* Check that the datagram is large enough to contain a record
   3909                   * of the advertised length. */
   3910                  if (len < rec->data_offset + rec->data_len) {
   3911                      MBEDTLS_SSL_DEBUG_MSG(1,
   3912                                            (
   3913                                                "Datagram of length %u too small to contain record of advertised length %u.",
   3914                                                (unsigned) len,
   3915                                                (unsigned) (rec->data_offset + rec->data_len)));
   3916                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   3917                  }
   3918          
   3919                  /* Records from other, non-matching epochs are silently discarded.
   3920                   * (The case of same-port Client reconnects must be considered in
   3921                   *  the caller). */
   3922                  if (rec_epoch != ssl->in_epoch) {
   3923                      MBEDTLS_SSL_DEBUG_MSG(1, ("record from another epoch: "
   3924                                                "expected %u, received %lu",
   3925                                                ssl->in_epoch, (unsigned long) rec_epoch));
   3926          
   3927                      /* Records from the next epoch are considered for buffering
   3928                       * (concretely: early Finished messages). */
   3929                      if (rec_epoch == (unsigned) ssl->in_epoch + 1) {
   3930                          MBEDTLS_SSL_DEBUG_MSG(2, ("Consider record for buffering"));
   3931                          return MBEDTLS_ERR_SSL_EARLY_MESSAGE;
   3932                      }
   3933          
   3934                      return MBEDTLS_ERR_SSL_UNEXPECTED_RECORD;
   3935                  }
   3936          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   3937                  /* For records from the correct epoch, check whether their
   3938                   * sequence number has been seen before. */
   3939                  else if (mbedtls_ssl_dtls_record_replay_check((mbedtls_ssl_context *) ssl,
   3940                                                                &rec->ctr[0]) != 0) {
   3941                      MBEDTLS_SSL_DEBUG_MSG(1, ("replayed record"));
   3942                      return MBEDTLS_ERR_SSL_UNEXPECTED_RECORD;
   3943                  }
   3944          #endif
   3945              }
   3946          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3947          
   3948              return 0;
   \                     ??ssl_parse_record_header_4: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \                     ??ssl_parse_record_header_1: (+1)
   \       0xCA   0xB007             ADD      SP,SP,#+28
   \       0xCC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3949          }
   3950          
   3951          
   3952          #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && defined(MBEDTLS_SSL_SRV_C)
   3953          MBEDTLS_CHECK_RETURN_CRITICAL
   3954          static int ssl_check_client_reconnect(mbedtls_ssl_context *ssl)
   3955          {
   3956              unsigned int rec_epoch = (ssl->in_ctr[0] << 8) | ssl->in_ctr[1];
   3957          
   3958              /*
   3959               * Check for an epoch 0 ClientHello. We can't use in_msg here to
   3960               * access the first byte of record content (handshake type), as we
   3961               * have an active transform (possibly iv_len != 0), so use the
   3962               * fact that the record header len is 13 instead.
   3963               */
   3964              if (rec_epoch == 0 &&
   3965                  ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   3966                  mbedtls_ssl_is_handshake_over(ssl) == 1 &&
   3967                  ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   3968                  ssl->in_left > 13 &&
   3969                  ssl->in_buf[13] == MBEDTLS_SSL_HS_CLIENT_HELLO) {
   3970                  MBEDTLS_SSL_DEBUG_MSG(1, ("possible client reconnect "
   3971                                            "from the same port"));
   3972                  return ssl_handle_possible_reconnect(ssl);
   3973              }
   3974          
   3975              return 0;
   3976          }
   3977          #endif /* MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE && MBEDTLS_SSL_SRV_C */
   3978          
   3979          /*
   3980           * If applicable, decrypt record content
   3981           */
   3982          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   3983          static int ssl_prepare_record_content(mbedtls_ssl_context *ssl,
   3984                                                mbedtls_record *rec)
   3985          {
   \                     ssl_prepare_record_content: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000D             MOVS     R5,R1
   3986              int ret, done = 0;
   \        0x8   0x2400             MOVS     R4,#+0
   3987          
   3988              MBEDTLS_SSL_DEBUG_BUF(4, "input record from network",
   3989                                    rec->buf, rec->buf_len);
   3990          
   3991              /*
   3992               * In TLS 1.3, always treat ChangeCipherSpec records
   3993               * as unencrypted. The only thing we do with them is
   3994               * check the length and content and ignore them.
   3995               */
   3996          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   3997              if (ssl->transform_in != NULL &&
   3998                  ssl->transform_in->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
   3999                  if (rec->type == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC) {
   4000                      done = 1;
   4001                  }
   4002              }
   4003          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   4004          
   4005              if (!done && ssl->transform_in != NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD150             BNE.N    ??ssl_prepare_record_content_0
   \        0xE   0x6BF8             LDR      R0,[R7, #+60]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD04D             BEQ.N    ??ssl_prepare_record_content_0
   4006                  unsigned char const old_msg_type = rec->type;
   \       0x14   0xF895 0x8008      LDRB     R8,[R5, #+8]
   4007          
   4008                  if ((ret = mbedtls_ssl_decrypt_buf(ssl, ssl->transform_in,
   4009                                                     rec)) != 0) {
   \       0x18   0x002A             MOVS     R2,R5
   \       0x1A   0x6BF9             LDR      R1,[R7, #+60]
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0x.... 0x....      BL       mbedtls_ssl_decrypt_buf
   \       0x22   0x0006             MOVS     R6,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD001             BEQ.N    ??ssl_prepare_record_content_1
   4010                      MBEDTLS_SSL_DEBUG_RET(1, "ssl_decrypt_buf", ret);
   4011          
   4012          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   4013                      if (ret == MBEDTLS_ERR_SSL_UNEXPECTED_CID &&
   4014                          ssl->conf->ignore_unexpected_cid
   4015                          == MBEDTLS_SSL_UNEXPECTED_CID_IGNORE) {
   4016                          MBEDTLS_SSL_DEBUG_MSG(3, ("ignoring unexpected CID"));
   4017                          ret = MBEDTLS_ERR_SSL_CONTINUE_PROCESSING;
   4018                      }
   4019          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   4020          
   4021                      return ret;
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xE04A             B.N      ??ssl_prepare_record_content_2
   4022                  }
   4023          
   4024                  if (old_msg_type != rec->type) {
   \                     ??ssl_prepare_record_content_1: (+1)
   \       0x2C   0x4641             MOV      R1,R8
   \       0x2E   0x7A28             LDRB     R0,[R5, #+8]
   \       0x30   0xB2C9             UXTB     R1,R1
   \       0x32   0x4281             CMP      R1,R0
   4025                      MBEDTLS_SSL_DEBUG_MSG(4, ("record type after decrypt (before %d): %d",
   4026                                                old_msg_type, rec->type));
   4027                  }
   4028          
   4029                  MBEDTLS_SSL_DEBUG_BUF(4, "input payload after decrypt",
   4030                                        rec->buf + rec->data_offset, rec->data_len);
   4031          
   4032          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   4033                  /* We have already checked the record content type
   4034                   * in ssl_parse_record_header(), failing or silently
   4035                   * dropping the record in the case of an unknown type.
   4036                   *
   4037                   * Since with the use of CIDs, the record content type
   4038                   * might change during decryption, re-check the record
   4039                   * content type, but treat a failure as fatal this time. */
   4040                  if (ssl_check_record_type(rec->type)) {
   4041                      MBEDTLS_SSL_DEBUG_MSG(1, ("unknown record type"));
   4042                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   4043                  }
   4044          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   4045          
   4046                  if (rec->data_len == 0) {
   \                     ??ssl_prepare_record_content_3: (+1)
   \       0x34   0x69A8             LDR      R0,[R5, #+24]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD116             BNE.N    ??ssl_prepare_record_content_4
   4047          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   4048                      if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_2
   4049                          && rec->type != MBEDTLS_SSL_MSG_APPLICATION_DATA) {
   \       0x3A   0xF9B7 0x1008      LDRSH    R1,[R7, #+8]
   \       0x3E   0xF240 0x3003      MOVW     R0,#+771
   \       0x42   0x4281             CMP      R1,R0
   \       0x44   0xD105             BNE.N    ??ssl_prepare_record_content_5
   \       0x46   0x7A28             LDRB     R0,[R5, #+8]
   \       0x48   0x2817             CMP      R0,#+23
   \       0x4A   0xD002             BEQ.N    ??ssl_prepare_record_content_5
   4050                          /* TLS v1.2 explicitly disallows zero-length messages which are not application data */
   4051                          MBEDTLS_SSL_DEBUG_MSG(1, ("invalid zero-length message type: %d", ssl->in_msgtype));
   4052                          return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x50   0xE037             B.N      ??ssl_prepare_record_content_2
   4053                      }
   4054          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   4055          
   4056                      ssl->nb_zero++;
   \                     ??ssl_prepare_record_content_5: (+1)
   \       0x52   0xF8D7 0x0084      LDR      R0,[R7, #+132]
   \       0x56   0x1C40             ADDS     R0,R0,#+1
   \       0x58   0xF8C7 0x0084      STR      R0,[R7, #+132]
   4057          
   4058                      /*
   4059                       * Three or more empty messages may be a DoS attack
   4060                       * (excessive CPU consumption).
   4061                       */
   4062                      if (ssl->nb_zero > 3) {
   \       0x5C   0xF8D7 0x0084      LDR      R0,[R7, #+132]
   \       0x60   0x2804             CMP      R0,#+4
   \       0x62   0xDB04             BLT.N    ??ssl_prepare_record_content_6
   4063                          MBEDTLS_SSL_DEBUG_MSG(1, ("received four consecutive empty "
   4064                                                    "messages, possible DoS attack"));
   4065                          /* Treat the records as if they were not properly authenticated,
   4066                           * thereby failing the connection if we see more than allowed
   4067                           * by the configured bad MAC threshold. */
   4068                          return MBEDTLS_ERR_SSL_INVALID_MAC;
   \       0x64   0x....             LDR.N    R0,??DataTable17
   \       0x66   0xE02C             B.N      ??ssl_prepare_record_content_2
   4069                      }
   4070                  } else {
   4071                      ssl->nb_zero = 0;
   \                     ??ssl_prepare_record_content_4: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xF8C7 0x0084      STR      R0,[R7, #+132]
   4072                  }
   4073          
   4074          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4075                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   4076                      ; /* in_ctr read from peer, not maintained internally */
   4077                  } else
   4078          #endif
   4079                  {
   4080                      unsigned i;
   4081                      for (i = MBEDTLS_SSL_SEQUENCE_NUMBER_LEN;
   \                     ??ssl_prepare_record_content_6: (+1)
   \       0x6E   0xF05F 0x0908      MOVS     R9,#+8
   4082                           i > mbedtls_ssl_ep_len(ssl); i--) {
   \                     ??ssl_prepare_record_content_7: (+1)
   \       0x72   0x0038             MOVS     R0,R7
   \       0x74   0x.... 0x....      BL       mbedtls_ssl_ep_len
   \       0x78   0x4548             CMP      R0,R9
   \       0x7A   0xD211             BCS.N    ??ssl_prepare_record_content_8
   4083                          if (++ssl->in_ctr[i - 1] != 0) {
   \       0x7C   0x6DF8             LDR      R0,[R7, #+92]
   \       0x7E   0x4448             ADD      R0,R0,R9
   \       0x80   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \       0x84   0x1C40             ADDS     R0,R0,#+1
   \       0x86   0x6DF9             LDR      R1,[R7, #+92]
   \       0x88   0x4449             ADD      R1,R1,R9
   \       0x8A   0xF801 0x0C01      STRB     R0,[R1, #-1]
   \       0x8E   0x6DF8             LDR      R0,[R7, #+92]
   \       0x90   0x4448             ADD      R0,R0,R9
   \       0x92   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD102             BNE.N    ??ssl_prepare_record_content_8
   4084                              break;
   4085                          }
   4086                      }
   \                     ??ssl_prepare_record_content_9: (+1)
   \       0x9A   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \       0x9E   0xE7E8             B.N      ??ssl_prepare_record_content_7
   4087          
   4088                      /* The loop goes to its end iff the counter is wrapping */
   4089                      if (i == mbedtls_ssl_ep_len(ssl)) {
   \                     ??ssl_prepare_record_content_8: (+1)
   \       0xA0   0x0038             MOVS     R0,R7
   \       0xA2   0x.... 0x....      BL       mbedtls_ssl_ep_len
   \       0xA6   0x4581             CMP      R9,R0
   \       0xA8   0xD102             BNE.N    ??ssl_prepare_record_content_0
   4090                          MBEDTLS_SSL_DEBUG_MSG(1, ("incoming message counter would wrap"));
   4091                          return MBEDTLS_ERR_SSL_COUNTER_WRAPPING;
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable28
   \       0xAE   0xE008             B.N      ??ssl_prepare_record_content_2
   4092                      }
   4093                  }
   4094          
   4095              }
   4096          
   4097          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   4098              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   4099                  mbedtls_ssl_dtls_replay_update(ssl);
   4100              }
   4101          #endif
   4102          
   4103              /* Check actual (decrypted) record content length against
   4104               * configured maximum. */
   4105              if (rec->data_len > MBEDTLS_SSL_IN_CONTENT_LEN) {
   \                     ??ssl_prepare_record_content_0: (+1)
   \       0xB0   0x69A9             LDR      R1,[R5, #+24]
   \       0xB2   0xF240 0x3001      MOVW     R0,#+769
   \       0xB6   0x4281             CMP      R1,R0
   \       0xB8   0xD302             BCC.N    ??ssl_prepare_record_content_10
   4106                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad message length"));
   4107                  return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0xBA   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0xBE   0xE000             B.N      ??ssl_prepare_record_content_2
   4108              }
   4109          
   4110              return 0;
   \                     ??ssl_prepare_record_content_10: (+1)
   \       0xC0   0x2000             MOVS     R0,#+0
   \                     ??ssl_prepare_record_content_2: (+1)
   \       0xC2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   4111          }
   4112          
   4113          /*
   4114           * Read a record.
   4115           *
   4116           * Silently ignore non-fatal alert (and for DTLS, invalid records as well,
   4117           * RFC 6347 4.1.2.7) and continue reading until a valid record is found.
   4118           *
   4119           */
   4120          
   4121          /* Helper functions for mbedtls_ssl_read_record(). */
   4122          MBEDTLS_CHECK_RETURN_CRITICAL
   4123          static int ssl_consume_current_message(mbedtls_ssl_context *ssl);
   4124          MBEDTLS_CHECK_RETURN_CRITICAL
   4125          static int ssl_get_next_record(mbedtls_ssl_context *ssl);
   4126          MBEDTLS_CHECK_RETURN_CRITICAL
   4127          static int ssl_record_is_in_progress(mbedtls_ssl_context *ssl);
   4128          

   \                                 In section .text, align 2, keep-with-next
   4129          int mbedtls_ssl_read_record(mbedtls_ssl_context *ssl,
   4130                                      unsigned update_hs_digest)
   4131          {
   \                     mbedtls_ssl_read_record: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000F             MOVS     R7,R1
   4132              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x046D      MVNS     R4,#+109
   4133          
   4134              MBEDTLS_SSL_DEBUG_MSG(2, ("=> read record"));
   4135          
   4136              if (ssl->keep_current_message == 0) {
   \        0xA   0xF8D6 0x0088      LDR      R0,[R6, #+136]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD135             BNE.N    ??mbedtls_ssl_read_record_0
   4137                  do {
   4138          
   4139                      ret = ssl_consume_current_message(ssl);
   \                     ??mbedtls_ssl_read_record_1: (+1)
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0x.... 0x....      BL       ssl_consume_current_message
   \       0x18   0x0004             MOVS     R4,R0
   4140                      if (ret != 0) {
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD001             BEQ.N    ??mbedtls_ssl_read_record_2
   4141                          return ret;
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xE031             B.N      ??mbedtls_ssl_read_record_3
   4142                      }
   4143          
   4144                      if (ssl_record_is_in_progress(ssl) == 0) {
   \                     ??mbedtls_ssl_read_record_2: (+1)
   \       0x22   0x0030             MOVS     R0,R6
   \       0x24   0x.... 0x....      BL       ssl_record_is_in_progress
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD10D             BNE.N    ??mbedtls_ssl_read_record_4
   4145                          int dtls_have_buffered = 0;
   \       0x2C   0x2500             MOVS     R5,#+0
   4146          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4147          
   4148                          /* We only check for buffered messages if the
   4149                           * current datagram is fully consumed. */
   4150                          if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   4151                              ssl_next_record_is_in_datagram(ssl) == 0) {
   4152                              if (ssl_load_buffered_message(ssl) == 0) {
   4153                                  dtls_have_buffered = 1;
   4154                              }
   4155                          }
   4156          
   4157          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4158                          if (dtls_have_buffered == 0) {
   \       0x2E   0x2D00             CMP      R5,#+0
   \       0x30   0xD10A             BNE.N    ??mbedtls_ssl_read_record_4
   4159                              ret = ssl_get_next_record(ssl);
   \       0x32   0x0030             MOVS     R0,R6
   \       0x34   0x.... 0x....      BL       ssl_get_next_record
   \       0x38   0x0004             MOVS     R4,R0
   4160                              if (ret == MBEDTLS_ERR_SSL_CONTINUE_PROCESSING) {
   \       0x3A   0xF514 0x4FCB      CMN      R4,#+25984
   \       0x3E   0xD007             BEQ.N    ??mbedtls_ssl_read_record_5
   4161                                  continue;
   4162                              }
   4163          
   4164                              if (ret != 0) {
   \                     ??mbedtls_ssl_read_record_6: (+1)
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD001             BEQ.N    ??mbedtls_ssl_read_record_4
   4165                                  MBEDTLS_SSL_DEBUG_RET(1, ("ssl_get_next_record"), ret);
   4166                                  return ret;
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0xE01E             B.N      ??mbedtls_ssl_read_record_3
   4167                              }
   4168                          }
   4169                      }
   4170          
   4171                      ret = mbedtls_ssl_handle_message_type(ssl);
   \                     ??mbedtls_ssl_read_record_4: (+1)
   \       0x48   0x0030             MOVS     R0,R6
   \       0x4A   0x.... 0x....      BL       mbedtls_ssl_handle_message_type
   \       0x4E   0x0004             MOVS     R4,R0
   4172          
   4173          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4174                      if (ret == MBEDTLS_ERR_SSL_EARLY_MESSAGE) {
   4175                          /* Buffer future message */
   4176                          ret = ssl_buffer_message(ssl);
   4177                          if (ret != 0) {
   4178                              return ret;
   4179                          }
   4180          
   4181                          ret = MBEDTLS_ERR_SSL_CONTINUE_PROCESSING;
   4182                      }
   4183          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4184          
   4185                  } while (MBEDTLS_ERR_SSL_NON_FATAL           == ret  ||
   4186                           MBEDTLS_ERR_SSL_CONTINUE_PROCESSING == ret);
   \                     ??mbedtls_ssl_read_record_5: (+1)
   \       0x50   0xF514 0x4FCD      CMN      R4,#+26240
   \       0x54   0xD0DD             BEQ.N    ??mbedtls_ssl_read_record_1
   \       0x56   0xF514 0x4FCB      CMN      R4,#+25984
   \       0x5A   0xD0DA             BEQ.N    ??mbedtls_ssl_read_record_1
   4187          
   4188                  if (0 != ret) {
   \       0x5C   0x2C00             CMP      R4,#+0
   \       0x5E   0xD001             BEQ.N    ??mbedtls_ssl_read_record_7
   4189                      MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ssl_handle_message_type"), ret);
   4190                      return ret;
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0xE010             B.N      ??mbedtls_ssl_read_record_3
   4191                  }
   4192          
   4193                  if (ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   4194                      update_hs_digest == 1) {
   \                     ??mbedtls_ssl_read_record_7: (+1)
   \       0x64   0x6F70             LDR      R0,[R6, #+116]
   \       0x66   0x2816             CMP      R0,#+22
   \       0x68   0xD10C             BNE.N    ??mbedtls_ssl_read_record_8
   \       0x6A   0x2F01             CMP      R7,#+1
   \       0x6C   0xD10A             BNE.N    ??mbedtls_ssl_read_record_8
   4195                      ret = mbedtls_ssl_update_handshake_status(ssl);
   \       0x6E   0x0030             MOVS     R0,R6
   \       0x70   0x.... 0x....      BL       mbedtls_ssl_update_handshake_status
   \       0x74   0x0004             MOVS     R4,R0
   4196                      if (0 != ret) {
   \       0x76   0x2C00             CMP      R4,#+0
   \       0x78   0xD004             BEQ.N    ??mbedtls_ssl_read_record_8
   4197                          MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ssl_update_handshake_status"), ret);
   4198                          return ret;
   \       0x7A   0x0020             MOVS     R0,R4
   \       0x7C   0xE003             B.N      ??mbedtls_ssl_read_record_3
   4199                      }
   4200                  }
   4201              } else {
   4202                  MBEDTLS_SSL_DEBUG_MSG(2, ("reuse previously read message"));
   4203                  ssl->keep_current_message = 0;
   \                     ??mbedtls_ssl_read_record_0: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xF8C6 0x0088      STR      R0,[R6, #+136]
   4204              }
   4205          
   4206              MBEDTLS_SSL_DEBUG_MSG(2, ("<= read record"));
   4207          
   4208              return 0;
   \                     ??mbedtls_ssl_read_record_8: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_read_record_3: (+1)
   \       0x86   0xBDF2             POP      {R1,R4-R7,PC}
   4209          }
   4210          
   4211          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4212          MBEDTLS_CHECK_RETURN_CRITICAL
   4213          static int ssl_next_record_is_in_datagram(mbedtls_ssl_context *ssl)
   4214          {
   4215              if (ssl->in_left > ssl->next_record_offset) {
   4216                  return 1;
   4217              }
   4218          
   4219              return 0;
   4220          }
   4221          
   4222          MBEDTLS_CHECK_RETURN_CRITICAL
   4223          static int ssl_load_buffered_message(mbedtls_ssl_context *ssl)
   4224          {
   4225              mbedtls_ssl_handshake_params * const hs = ssl->handshake;
   4226              mbedtls_ssl_hs_buffer *hs_buf;
   4227              int ret = 0;
   4228          
   4229              if (hs == NULL) {
   4230                  return -1;
   4231              }
   4232          
   4233              MBEDTLS_SSL_DEBUG_MSG(2, ("=> ssl_load_buffered_message"));
   4234          
   4235              if (ssl->state == MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC ||
   4236                  ssl->state == MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC) {
   4237                  /* Check if we have seen a ChangeCipherSpec before.
   4238                   * If yes, synthesize a CCS record. */
   4239                  if (!hs->buffering.seen_ccs) {
   4240                      MBEDTLS_SSL_DEBUG_MSG(2, ("CCS not seen in the current flight"));
   4241                      ret = -1;
   4242                      goto exit;
   4243                  }
   4244          
   4245                  MBEDTLS_SSL_DEBUG_MSG(2, ("Injecting buffered CCS message"));
   4246                  ssl->in_msgtype = MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC;
   4247                  ssl->in_msglen = 1;
   4248                  ssl->in_msg[0] = 1;
   4249          
   4250                  /* As long as they are equal, the exact value doesn't matter. */
   4251                  ssl->in_left            = 0;
   4252                  ssl->next_record_offset = 0;
   4253          
   4254                  hs->buffering.seen_ccs = 0;
   4255                  goto exit;
   4256              }
   4257          
   4258          #if defined(MBEDTLS_DEBUG_C)
   4259              /* Debug only */
   4260              {
   4261                  unsigned offset;
   4262                  for (offset = 1; offset < MBEDTLS_SSL_MAX_BUFFERED_HS; offset++) {
   4263                      hs_buf = &hs->buffering.hs[offset];
   4264                      if (hs_buf->is_valid == 1) {
   4265                          MBEDTLS_SSL_DEBUG_MSG(2, ("Future message with sequence number %u %s buffered.",
   4266                                                    hs->in_msg_seq + offset,
   4267                                                    hs_buf->is_complete ? "fully" : "partially"));
   4268                      }
   4269                  }
   4270              }
   4271          #endif /* MBEDTLS_DEBUG_C */
   4272          
   4273              /* Check if we have buffered and/or fully reassembled the
   4274               * next handshake message. */
   4275              hs_buf = &hs->buffering.hs[0];
   4276              if ((hs_buf->is_valid == 1) && (hs_buf->is_complete == 1)) {
   4277                  /* Synthesize a record containing the buffered HS message. */
   4278                  size_t msg_len = (hs_buf->data[1] << 16) |
   4279                                   (hs_buf->data[2] << 8) |
   4280                                   hs_buf->data[3];
   4281          
   4282                  /* Double-check that we haven't accidentally buffered
   4283                   * a message that doesn't fit into the input buffer. */
   4284                  if (msg_len + 12 > MBEDTLS_SSL_IN_CONTENT_LEN) {
   4285                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   4286                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   4287                  }
   4288          
   4289                  MBEDTLS_SSL_DEBUG_MSG(2, ("Next handshake message has been buffered - load"));
   4290                  MBEDTLS_SSL_DEBUG_BUF(3, "Buffered handshake message (incl. header)",
   4291                                        hs_buf->data, msg_len + 12);
   4292          
   4293                  ssl->in_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   4294                  ssl->in_hslen   = msg_len + 12;
   4295                  ssl->in_msglen  = msg_len + 12;
   4296                  memcpy(ssl->in_msg, hs_buf->data, ssl->in_hslen);
   4297          
   4298                  ret = 0;
   4299                  goto exit;
   4300              } else {
   4301                  MBEDTLS_SSL_DEBUG_MSG(2, ("Next handshake message %u not or only partially bufffered",
   4302                                            hs->in_msg_seq));
   4303              }
   4304          
   4305              ret = -1;
   4306          
   4307          exit:
   4308          
   4309              MBEDTLS_SSL_DEBUG_MSG(2, ("<= ssl_load_buffered_message"));
   4310              return ret;
   4311          }
   4312          
   4313          MBEDTLS_CHECK_RETURN_CRITICAL
   4314          static int ssl_buffer_make_space(mbedtls_ssl_context *ssl,
   4315                                           size_t desired)
   4316          {
   4317              int offset;
   4318              mbedtls_ssl_handshake_params * const hs = ssl->handshake;
   4319              MBEDTLS_SSL_DEBUG_MSG(2, ("Attempt to free buffered messages to have %u bytes available",
   4320                                        (unsigned) desired));
   4321          
   4322              /* Get rid of future records epoch first, if such exist. */
   4323              ssl_free_buffered_record(ssl);
   4324          
   4325              /* Check if we have enough space available now. */
   4326              if (desired <= (MBEDTLS_SSL_DTLS_MAX_BUFFERING -
   4327                              hs->buffering.total_bytes_buffered)) {
   4328                  MBEDTLS_SSL_DEBUG_MSG(2, ("Enough space available after freeing future epoch record"));
   4329                  return 0;
   4330              }
   4331          
   4332              /* We don't have enough space to buffer the next expected handshake
   4333               * message. Remove buffers used for future messages to gain space,
   4334               * starting with the most distant one. */
   4335              for (offset = MBEDTLS_SSL_MAX_BUFFERED_HS - 1;
   4336                   offset >= 0; offset--) {
   4337                  MBEDTLS_SSL_DEBUG_MSG(2,
   4338                                        (
   4339                                            "Free buffering slot %d to make space for reassembly of next handshake message",
   4340                                            offset));
   4341          
   4342                  ssl_buffering_free_slot(ssl, (uint8_t) offset);
   4343          
   4344                  /* Check if we have enough space available now. */
   4345                  if (desired <= (MBEDTLS_SSL_DTLS_MAX_BUFFERING -
   4346                                  hs->buffering.total_bytes_buffered)) {
   4347                      MBEDTLS_SSL_DEBUG_MSG(2, ("Enough space available after freeing buffered HS messages"));
   4348                      return 0;
   4349                  }
   4350              }
   4351          
   4352              return -1;
   4353          }
   4354          
   4355          MBEDTLS_CHECK_RETURN_CRITICAL
   4356          static int ssl_buffer_message(mbedtls_ssl_context *ssl)
   4357          {
   4358              int ret = 0;
   4359              mbedtls_ssl_handshake_params * const hs = ssl->handshake;
   4360          
   4361              if (hs == NULL) {
   4362                  return 0;
   4363              }
   4364          
   4365              MBEDTLS_SSL_DEBUG_MSG(2, ("=> ssl_buffer_message"));
   4366          
   4367              switch (ssl->in_msgtype) {
   4368                  case MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC:
   4369                      MBEDTLS_SSL_DEBUG_MSG(2, ("Remember CCS message"));
   4370          
   4371                      hs->buffering.seen_ccs = 1;
   4372                      break;
   4373          
   4374                  case MBEDTLS_SSL_MSG_HANDSHAKE:
   4375                  {
   4376                      unsigned recv_msg_seq_offset;
   4377                      unsigned recv_msg_seq = (ssl->in_msg[4] << 8) | ssl->in_msg[5];
   4378                      mbedtls_ssl_hs_buffer *hs_buf;
   4379                      size_t msg_len = ssl->in_hslen - 12;
   4380          
   4381                      /* We should never receive an old handshake
   4382                       * message - double-check nonetheless. */
   4383                      if (recv_msg_seq < ssl->handshake->in_msg_seq) {
   4384                          MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   4385                          return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   4386                      }
   4387          
   4388                      recv_msg_seq_offset = recv_msg_seq - ssl->handshake->in_msg_seq;
   4389                      if (recv_msg_seq_offset >= MBEDTLS_SSL_MAX_BUFFERED_HS) {
   4390                          /* Silently ignore -- message too far in the future */
   4391                          MBEDTLS_SSL_DEBUG_MSG(2,
   4392                                                ("Ignore future HS message with sequence number %u, "
   4393                                                 "buffering window %u - %u",
   4394                                                 recv_msg_seq, ssl->handshake->in_msg_seq,
   4395                                                 ssl->handshake->in_msg_seq + MBEDTLS_SSL_MAX_BUFFERED_HS -
   4396                                                 1));
   4397          
   4398                          goto exit;
   4399                      }
   4400          
   4401                      MBEDTLS_SSL_DEBUG_MSG(2, ("Buffering HS message with sequence number %u, offset %u ",
   4402                                                recv_msg_seq, recv_msg_seq_offset));
   4403          
   4404                      hs_buf = &hs->buffering.hs[recv_msg_seq_offset];
   4405          
   4406                      /* Check if the buffering for this seq nr has already commenced. */
   4407                      if (!hs_buf->is_valid) {
   4408                          size_t reassembly_buf_sz;
   4409          
   4410                          hs_buf->is_fragmented =
   4411                              (ssl_hs_is_proper_fragment(ssl) == 1);
   4412          
   4413                          /* We copy the message back into the input buffer
   4414                           * after reassembly, so check that it's not too large.
   4415                           * This is an implementation-specific limitation
   4416                           * and not one from the standard, hence it is not
   4417                           * checked in ssl_check_hs_header(). */
   4418                          if (msg_len + 12 > MBEDTLS_SSL_IN_CONTENT_LEN) {
   4419                              /* Ignore message */
   4420                              goto exit;
   4421                          }
   4422          
   4423                          /* Check if we have enough space to buffer the message. */
   4424                          if (hs->buffering.total_bytes_buffered >
   4425                              MBEDTLS_SSL_DTLS_MAX_BUFFERING) {
   4426                              MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   4427                              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   4428                          }
   4429          
   4430                          reassembly_buf_sz = ssl_get_reassembly_buffer_size(msg_len,
   4431                                                                             hs_buf->is_fragmented);
   4432          
   4433                          if (reassembly_buf_sz > (MBEDTLS_SSL_DTLS_MAX_BUFFERING -
   4434                                                   hs->buffering.total_bytes_buffered)) {
   4435                              if (recv_msg_seq_offset > 0) {
   4436                                  /* If we can't buffer a future message because
   4437                                   * of space limitations -- ignore. */
   4438                                  MBEDTLS_SSL_DEBUG_MSG(2,
   4439                                                        ("Buffering of future message of size %"
   4440                                                         MBEDTLS_PRINTF_SIZET
   4441                                                         " would exceed the compile-time limit %"
   4442                                                         MBEDTLS_PRINTF_SIZET
   4443                                                         " (already %" MBEDTLS_PRINTF_SIZET
   4444                                                         " bytes buffered) -- ignore\n",
   4445                                                         msg_len, (size_t) MBEDTLS_SSL_DTLS_MAX_BUFFERING,
   4446                                                         hs->buffering.total_bytes_buffered));
   4447                                  goto exit;
   4448                              } else {
   4449                                  MBEDTLS_SSL_DEBUG_MSG(2,
   4450                                                        ("Buffering of future message of size %"
   4451                                                         MBEDTLS_PRINTF_SIZET
   4452                                                         " would exceed the compile-time limit %"
   4453                                                         MBEDTLS_PRINTF_SIZET
   4454                                                         " (already %" MBEDTLS_PRINTF_SIZET
   4455                                                         " bytes buffered) -- attempt to make space by freeing buffered future messages\n",
   4456                                                         msg_len, (size_t) MBEDTLS_SSL_DTLS_MAX_BUFFERING,
   4457                                                         hs->buffering.total_bytes_buffered));
   4458                              }
   4459          
   4460                              if (ssl_buffer_make_space(ssl, reassembly_buf_sz) != 0) {
   4461                                  MBEDTLS_SSL_DEBUG_MSG(2,
   4462                                                        ("Reassembly of next message of size %"
   4463                                                         MBEDTLS_PRINTF_SIZET
   4464                                                         " (%" MBEDTLS_PRINTF_SIZET
   4465                                                         " with bitmap) would exceed"
   4466                                                         " the compile-time limit %"
   4467                                                         MBEDTLS_PRINTF_SIZET
   4468                                                         " (already %" MBEDTLS_PRINTF_SIZET
   4469                                                         " bytes buffered) -- fail\n",
   4470                                                         msg_len,
   4471                                                         reassembly_buf_sz,
   4472                                                         (size_t) MBEDTLS_SSL_DTLS_MAX_BUFFERING,
   4473                                                         hs->buffering.total_bytes_buffered));
   4474                                  ret = MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   4475                                  goto exit;
   4476                              }
   4477                          }
   4478          
   4479                          MBEDTLS_SSL_DEBUG_MSG(2,
   4480                                                ("initialize reassembly, total length = %"
   4481                                                 MBEDTLS_PRINTF_SIZET,
   4482                                                 msg_len));
   4483          
   4484                          hs_buf->data = mbedtls_calloc(1, reassembly_buf_sz);
   4485                          if (hs_buf->data == NULL) {
   4486                              ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
   4487                              goto exit;
   4488                          }
   4489                          hs_buf->data_len = reassembly_buf_sz;
   4490          
   4491                          /* Prepare final header: copy msg_type, length and message_seq,
   4492                           * then add standardised fragment_offset and fragment_length */
   4493                          memcpy(hs_buf->data, ssl->in_msg, 6);
   4494                          memset(hs_buf->data + 6, 0, 3);
   4495                          memcpy(hs_buf->data + 9, hs_buf->data + 1, 3);
   4496          
   4497                          hs_buf->is_valid = 1;
   4498          
   4499                          hs->buffering.total_bytes_buffered += reassembly_buf_sz;
   4500                      } else {
   4501                          /* Make sure msg_type and length are consistent */
   4502                          if (memcmp(hs_buf->data, ssl->in_msg, 4) != 0) {
   4503                              MBEDTLS_SSL_DEBUG_MSG(1, ("Fragment header mismatch - ignore"));
   4504                              /* Ignore */
   4505                              goto exit;
   4506                          }
   4507                      }
   4508          
   4509                      if (!hs_buf->is_complete) {
   4510                          size_t frag_len, frag_off;
   4511                          unsigned char * const msg = hs_buf->data + 12;
   4512          
   4513                          /*
   4514                           * Check and copy current fragment
   4515                           */
   4516          
   4517                          /* Validation of header fields already done in
   4518                           * mbedtls_ssl_prepare_handshake_record(). */
   4519                          frag_off = ssl_get_hs_frag_off(ssl);
   4520                          frag_len = ssl_get_hs_frag_len(ssl);
   4521          
   4522                          MBEDTLS_SSL_DEBUG_MSG(2, ("adding fragment, offset = %" MBEDTLS_PRINTF_SIZET
   4523                                                    ", length = %" MBEDTLS_PRINTF_SIZET,
   4524                                                    frag_off, frag_len));
   4525                          memcpy(msg + frag_off, ssl->in_msg + 12, frag_len);
   4526          
   4527                          if (hs_buf->is_fragmented) {
   4528                              unsigned char * const bitmask = msg + msg_len;
   4529                              ssl_bitmask_set(bitmask, frag_off, frag_len);
   4530                              hs_buf->is_complete = (ssl_bitmask_check(bitmask,
   4531                                                                       msg_len) == 0);
   4532                          } else {
   4533                              hs_buf->is_complete = 1;
   4534                          }
   4535          
   4536                          MBEDTLS_SSL_DEBUG_MSG(2, ("message %scomplete",
   4537                                                    hs_buf->is_complete ? "" : "not yet "));
   4538                      }
   4539          
   4540                      break;
   4541                  }
   4542          
   4543                  default:
   4544                      /* We don't buffer other types of messages. */
   4545                      break;
   4546              }
   4547          
   4548          exit:
   4549          
   4550              MBEDTLS_SSL_DEBUG_MSG(2, ("<= ssl_buffer_message"));
   4551              return ret;
   4552          }
   4553          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4554          
   4555          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   4556          static int ssl_consume_current_message(mbedtls_ssl_context *ssl)
   4557          {
   \                     ssl_consume_current_message: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4558              /*
   4559               * Consume last content-layer message and potentially
   4560               * update in_msglen which keeps track of the contents'
   4561               * consumption state.
   4562               *
   4563               * (1) Handshake messages:
   4564               *     Remove last handshake message, move content
   4565               *     and adapt in_msglen.
   4566               *
   4567               * (2) Alert messages:
   4568               *     Consume whole record content, in_msglen = 0.
   4569               *
   4570               * (3) Change cipher spec:
   4571               *     Consume whole record content, in_msglen = 0.
   4572               *
   4573               * (4) Application data:
   4574               *     Don't do anything - the record layer provides
   4575               *     the application data as a stream transport
   4576               *     and consumes through mbedtls_ssl_read only.
   4577               *
   4578               */
   4579          
   4580              /* Case (1): Handshake messages */
   4581              if (ssl->in_hslen != 0) {
   \        0x4   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD022             BEQ.N    ??ssl_consume_current_message_0
   4582                  /* Hard assertion to be sure that no application data
   4583                   * is in flight, as corrupting ssl->in_msglen during
   4584                   * ssl->in_offt != NULL is fatal. */
   4585                  if (ssl->in_offt != NULL) {
   \        0xC   0x6F20             LDR      R0,[R4, #+112]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD002             BEQ.N    ??ssl_consume_current_message_1
   4586                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   4587                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x16   0xE024             B.N      ??ssl_consume_current_message_2
   4588                  }
   4589          
   4590                  /*
   4591                   * Get next Handshake message in the current record
   4592                   */
   4593          
   4594                  /* Notes:
   4595                   * (1) in_hslen is not necessarily the size of the
   4596                   *     current handshake content: If DTLS handshake
   4597                   *     fragmentation is used, that's the fragment
   4598                   *     size instead. Using the total handshake message
   4599                   *     size here is faulty and should be changed at
   4600                   *     some point.
   4601                   * (2) While it doesn't seem to cause problems, one
   4602                   *     has to be very careful not to assume that in_hslen
   4603                   *     is always <= in_msglen in a sensible communication.
   4604                   *     Again, it's wrong for DTLS handshake fragmentation.
   4605                   *     The following check is therefore mandatory, and
   4606                   *     should not be treated as a silently corrected assertion.
   4607                   *     Additionally, ssl->in_hslen might be arbitrarily out of
   4608                   *     bounds after handling a DTLS message with an unexpected
   4609                   *     sequence number, see mbedtls_ssl_prepare_handshake_record.
   4610                   */
   4611                  if (ssl->in_hslen < ssl->in_msglen) {
   \                     ??ssl_consume_current_message_1: (+1)
   \       0x18   0xF8D4 0x1080      LDR      R1,[R4, #+128]
   \       0x1C   0x6FA0             LDR      R0,[R4, #+120]
   \       0x1E   0x4281             CMP      R1,R0
   \       0x20   0xD211             BCS.N    ??ssl_consume_current_message_3
   4612                      ssl->in_msglen -= ssl->in_hslen;
   \       0x22   0x6FA1             LDR      R1,[R4, #+120]
   \       0x24   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \       0x28   0x1A09             SUBS     R1,R1,R0
   \       0x2A   0x67A1             STR      R1,[R4, #+120]
   4613                      memmove(ssl->in_msg, ssl->in_msg + ssl->in_hslen,
   4614                              ssl->in_msglen);
   \       0x2C   0x6FA5             LDR      R5,[R4, #+120]
   \       0x2E   0x6EE1             LDR      R1,[R4, #+108]
   \       0x30   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \       0x34   0xEB01 0x0700      ADD      R7,R1,R0
   \       0x38   0x6EE6             LDR      R6,[R4, #+108]
   \       0x3A   0x002A             MOVS     R2,R5
   \       0x3C   0x0039             MOVS     R1,R7
   \       0x3E   0x0030             MOVS     R0,R6
   \       0x40   0x.... 0x....      BL       __aeabi_memmove
   4615          
   4616                      MBEDTLS_SSL_DEBUG_BUF(4, "remaining content in record",
   4617                                            ssl->in_msg, ssl->in_msglen);
   \       0x44   0xE001             B.N      ??ssl_consume_current_message_4
   4618                  } else {
   4619                      ssl->in_msglen = 0;
   \                     ??ssl_consume_current_message_3: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x67A0             STR      R0,[R4, #+120]
   4620                  }
   4621          
   4622                  ssl->in_hslen   = 0;
   \                     ??ssl_consume_current_message_4: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF8C4 0x0080      STR      R0,[R4, #+128]
   \       0x50   0xE006             B.N      ??ssl_consume_current_message_5
   4623              }
   4624              /* Case (4): Application data */
   4625              else if (ssl->in_offt != NULL) {
   \                     ??ssl_consume_current_message_0: (+1)
   \       0x52   0x6F20             LDR      R0,[R4, #+112]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD001             BEQ.N    ??ssl_consume_current_message_6
   4626                  return 0;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xE002             B.N      ??ssl_consume_current_message_2
   4627              }
   4628              /* Everything else (CCS & Alerts) */
   4629              else {
   4630                  ssl->in_msglen = 0;
   \                     ??ssl_consume_current_message_6: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x67A0             STR      R0,[R4, #+120]
   4631              }
   4632          
   4633              return 0;
   \                     ??ssl_consume_current_message_5: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   \                     ??ssl_consume_current_message_2: (+1)
   \       0x62   0xBDF2             POP      {R1,R4-R7,PC}
   4634          }
   4635          
   4636          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   4637          static int ssl_record_is_in_progress(mbedtls_ssl_context *ssl)
   4638          {
   \                     ssl_record_is_in_progress: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   4639              if (ssl->in_msglen > 0) {
   \        0x2   0x6F88             LDR      R0,[R1, #+120]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD001             BEQ.N    ??ssl_record_is_in_progress_0
   4640                  return 1;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??ssl_record_is_in_progress_1
   4641              }
   4642          
   4643              return 0;
   \                     ??ssl_record_is_in_progress_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \                     ??ssl_record_is_in_progress_1: (+1)
   \        0xE   0x4770             BX       LR
   4644          }
   4645          
   4646          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4647          
   4648          static void ssl_free_buffered_record(mbedtls_ssl_context *ssl)
   4649          {
   4650              mbedtls_ssl_handshake_params * const hs = ssl->handshake;
   4651              if (hs == NULL) {
   4652                  return;
   4653              }
   4654          
   4655              if (hs->buffering.future_record.data != NULL) {
   4656                  hs->buffering.total_bytes_buffered -=
   4657                      hs->buffering.future_record.len;
   4658          
   4659                  mbedtls_free(hs->buffering.future_record.data);
   4660                  hs->buffering.future_record.data = NULL;
   4661              }
   4662          }
   4663          
   4664          MBEDTLS_CHECK_RETURN_CRITICAL
   4665          static int ssl_load_buffered_record(mbedtls_ssl_context *ssl)
   4666          {
   4667              mbedtls_ssl_handshake_params * const hs = ssl->handshake;
   4668              unsigned char *rec;
   4669              size_t rec_len;
   4670              unsigned rec_epoch;
   4671          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   4672              size_t in_buf_len = ssl->in_buf_len;
   4673          #else
   4674              size_t in_buf_len = MBEDTLS_SSL_IN_BUFFER_LEN;
   4675          #endif
   4676              if (ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   4677                  return 0;
   4678              }
   4679          
   4680              if (hs == NULL) {
   4681                  return 0;
   4682              }
   4683          
   4684              rec       = hs->buffering.future_record.data;
   4685              rec_len   = hs->buffering.future_record.len;
   4686              rec_epoch = hs->buffering.future_record.epoch;
   4687          
   4688              if (rec == NULL) {
   4689                  return 0;
   4690              }
   4691          
   4692              /* Only consider loading future records if the
   4693               * input buffer is empty. */
   4694              if (ssl_next_record_is_in_datagram(ssl) == 1) {
   4695                  return 0;
   4696              }
   4697          
   4698              MBEDTLS_SSL_DEBUG_MSG(2, ("=> ssl_load_buffered_record"));
   4699          
   4700              if (rec_epoch != ssl->in_epoch) {
   4701                  MBEDTLS_SSL_DEBUG_MSG(2, ("Buffered record not from current epoch."));
   4702                  goto exit;
   4703              }
   4704          
   4705              MBEDTLS_SSL_DEBUG_MSG(2, ("Found buffered record from current epoch - load"));
   4706          
   4707              /* Double-check that the record is not too large */
   4708              if (rec_len > in_buf_len - (size_t) (ssl->in_hdr - ssl->in_buf)) {
   4709                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   4710                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   4711              }
   4712          
   4713              memcpy(ssl->in_hdr, rec, rec_len);
   4714              ssl->in_left = rec_len;
   4715              ssl->next_record_offset = 0;
   4716          
   4717              ssl_free_buffered_record(ssl);
   4718          
   4719          exit:
   4720              MBEDTLS_SSL_DEBUG_MSG(2, ("<= ssl_load_buffered_record"));
   4721              return 0;
   4722          }
   4723          
   4724          MBEDTLS_CHECK_RETURN_CRITICAL
   4725          static int ssl_buffer_future_record(mbedtls_ssl_context *ssl,
   4726                                              mbedtls_record const *rec)
   4727          {
   4728              mbedtls_ssl_handshake_params * const hs = ssl->handshake;
   4729          
   4730              /* Don't buffer future records outside handshakes. */
   4731              if (hs == NULL) {
   4732                  return 0;
   4733              }
   4734          
   4735              /* Only buffer handshake records (we are only interested
   4736               * in Finished messages). */
   4737              if (rec->type != MBEDTLS_SSL_MSG_HANDSHAKE) {
   4738                  return 0;
   4739              }
   4740          
   4741              /* Don't buffer more than one future epoch record. */
   4742              if (hs->buffering.future_record.data != NULL) {
   4743                  return 0;
   4744              }
   4745          
   4746              /* Don't buffer record if there's not enough buffering space remaining. */
   4747              if (rec->buf_len > (MBEDTLS_SSL_DTLS_MAX_BUFFERING -
   4748                                  hs->buffering.total_bytes_buffered)) {
   4749                  MBEDTLS_SSL_DEBUG_MSG(2, ("Buffering of future epoch record of size %" MBEDTLS_PRINTF_SIZET
   4750                                            " would exceed the compile-time limit %" MBEDTLS_PRINTF_SIZET
   4751                                            " (already %" MBEDTLS_PRINTF_SIZET
   4752                                            " bytes buffered) -- ignore\n",
   4753                                            rec->buf_len, (size_t) MBEDTLS_SSL_DTLS_MAX_BUFFERING,
   4754                                            hs->buffering.total_bytes_buffered));
   4755                  return 0;
   4756              }
   4757          
   4758              /* Buffer record */
   4759              MBEDTLS_SSL_DEBUG_MSG(2, ("Buffer record from epoch %u",
   4760                                        ssl->in_epoch + 1U));
   4761              MBEDTLS_SSL_DEBUG_BUF(3, "Buffered record", rec->buf, rec->buf_len);
   4762          
   4763              /* ssl_parse_record_header() only considers records
   4764               * of the next epoch as candidates for buffering. */
   4765              hs->buffering.future_record.epoch = ssl->in_epoch + 1;
   4766              hs->buffering.future_record.len   = rec->buf_len;
   4767          
   4768              hs->buffering.future_record.data =
   4769                  mbedtls_calloc(1, hs->buffering.future_record.len);
   4770              if (hs->buffering.future_record.data == NULL) {
   4771                  /* If we run out of RAM trying to buffer a
   4772                   * record from the next epoch, just ignore. */
   4773                  return 0;
   4774              }
   4775          
   4776              memcpy(hs->buffering.future_record.data, rec->buf, rec->buf_len);
   4777          
   4778              hs->buffering.total_bytes_buffered += rec->buf_len;
   4779              return 0;
   4780          }
   4781          
   4782          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4783          
   4784          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   4785          static int ssl_get_next_record(mbedtls_ssl_context *ssl)
   4786          {
   \                     ssl_get_next_record: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0006             MOVS     R6,R0
   4787              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x056D      MVNS     R5,#+109
   4788              mbedtls_record rec;
   4789          
   4790          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4791              /* We might have buffered a future record; if so,
   4792               * and if the epoch matches now, load it.
   4793               * On success, this call will set ssl->in_left to
   4794               * the length of the buffered record, so that
   4795               * the calls to ssl_fetch_input() below will
   4796               * essentially be no-ops. */
   4797              ret = ssl_load_buffered_record(ssl);
   4798              if (ret != 0) {
   4799                  return ret;
   4800              }
   4801          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4802          
   4803              /* Ensure that we have enough space available for the default form
   4804               * of TLS / DTLS record headers (5 Bytes for TLS, 13 Bytes for DTLS,
   4805               * with no space for CIDs counted in). */
   4806              ret = mbedtls_ssl_fetch_input(ssl, mbedtls_ssl_in_hdr_len(ssl));
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x.... 0x....      BL       mbedtls_ssl_in_hdr_len
   \       0x10   0x0001             MOVS     R1,R0
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0x.... 0x....      BL       mbedtls_ssl_fetch_input
   \       0x18   0x0004             MOVS     R4,R0
   4807              if (ret != 0) {
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD001             BEQ.N    ??ssl_get_next_record_0
   4808                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_fetch_input", ret);
   4809                  return ret;
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xE046             B.N      ??ssl_get_next_record_1
   4810              }
   4811          
   4812              ret = ssl_parse_record_header(ssl, ssl->in_hdr, ssl->in_left, &rec);
   \                     ??ssl_get_next_record_0: (+1)
   \       0x22   0x466B             MOV      R3,SP
   \       0x24   0x6FF2             LDR      R2,[R6, #+124]
   \       0x26   0x6E31             LDR      R1,[R6, #+96]
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0x.... 0x....      BL       ssl_parse_record_header
   \       0x2E   0x0005             MOVS     R5,R0
   4813              if (ret != 0) {
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xD001             BEQ.N    ??ssl_get_next_record_2
   4814          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4815                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   4816                      if (ret == MBEDTLS_ERR_SSL_EARLY_MESSAGE) {
   4817                          ret = ssl_buffer_future_record(ssl, &rec);
   4818                          if (ret != 0) {
   4819                              return ret;
   4820                          }
   4821          
   4822                          /* Fall through to handling of unexpected records */
   4823                          ret = MBEDTLS_ERR_SSL_UNEXPECTED_RECORD;
   4824                      }
   4825          
   4826                      if (ret == MBEDTLS_ERR_SSL_UNEXPECTED_RECORD) {
   4827          #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && defined(MBEDTLS_SSL_SRV_C)
   4828                          /* Reset in pointers to default state for TLS/DTLS records,
   4829                           * assuming no CID and no offset between record content and
   4830                           * record plaintext. */
   4831                          mbedtls_ssl_update_in_pointers(ssl);
   4832          
   4833                          /* Setup internal message pointers from record structure. */
   4834                          ssl->in_msgtype = rec.type;
   4835          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   4836                          ssl->in_len = ssl->in_cid + rec.cid_len;
   4837          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   4838                          ssl->in_iv  = ssl->in_msg = ssl->in_len + 2;
   4839                          ssl->in_msglen = rec.data_len;
   4840          
   4841                          ret = ssl_check_client_reconnect(ssl);
   4842                          MBEDTLS_SSL_DEBUG_RET(2, "ssl_check_client_reconnect", ret);
   4843                          if (ret != 0) {
   4844                              return ret;
   4845                          }
   4846          #endif
   4847          
   4848                          /* Skip unexpected record (but not whole datagram) */
   4849                          ssl->next_record_offset = rec.buf_len;
   4850          
   4851                          MBEDTLS_SSL_DEBUG_MSG(1, ("discarding unexpected record "
   4852                                                    "(header)"));
   4853                      } else {
   4854                          /* Skip invalid record and the rest of the datagram */
   4855                          ssl->next_record_offset = 0;
   4856                          ssl->in_left = 0;
   4857          
   4858                          MBEDTLS_SSL_DEBUG_MSG(1, ("discarding invalid record "
   4859                                                    "(header)"));
   4860                      }
   4861          
   4862                      /* Get next record */
   4863                      return MBEDTLS_ERR_SSL_CONTINUE_PROCESSING;
   4864                  } else
   4865          #endif
   4866                  {
   4867                      return ret;
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0xE03B             B.N      ??ssl_get_next_record_1
   4868                  }
   4869              }
   4870          
   4871          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4872              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   4873                  /* Remember offset of next record within datagram. */
   4874                  ssl->next_record_offset = rec.buf_len;
   4875                  if (ssl->next_record_offset < ssl->in_left) {
   4876                      MBEDTLS_SSL_DEBUG_MSG(3, ("more than one record within datagram"));
   4877                  }
   4878              } else
   4879          #endif
   4880              {
   4881                  /*
   4882                   * Fetch record contents from underlying transport.
   4883                   */
   4884                  ret = mbedtls_ssl_fetch_input(ssl, rec.buf_len);
   \                     ??ssl_get_next_record_2: (+1)
   \       0x38   0x9904             LDR      R1,[SP, #+16]
   \       0x3A   0x0030             MOVS     R0,R6
   \       0x3C   0x.... 0x....      BL       mbedtls_ssl_fetch_input
   \       0x40   0x0004             MOVS     R4,R0
   4885                  if (ret != 0) {
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD001             BEQ.N    ??ssl_get_next_record_3
   4886                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_fetch_input", ret);
   4887                      return ret;
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0xE032             B.N      ??ssl_get_next_record_1
   4888                  }
   4889          
   4890                  ssl->in_left = 0;
   \                     ??ssl_get_next_record_3: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x67F0             STR      R0,[R6, #+124]
   4891              }
   4892          
   4893              /*
   4894               * Decrypt record contents.
   4895               */
   4896          
   4897              if ((ret = ssl_prepare_record_content(ssl, &rec)) != 0) {
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x0030             MOVS     R0,R6
   \       0x52   0x.... 0x....      BL       ssl_prepare_record_content
   \       0x56   0x0005             MOVS     R5,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD001             BEQ.N    ??ssl_get_next_record_4
   4898          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4899                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   4900                      /* Silently discard invalid records */
   4901                      if (ret == MBEDTLS_ERR_SSL_INVALID_MAC) {
   4902                          /* Except when waiting for Finished as a bad mac here
   4903                           * probably means something went wrong in the handshake
   4904                           * (eg wrong psk used, mitm downgrade attempt, etc.) */
   4905                          if (ssl->state == MBEDTLS_SSL_CLIENT_FINISHED ||
   4906                              ssl->state == MBEDTLS_SSL_SERVER_FINISHED) {
   4907          #if defined(MBEDTLS_SSL_ALL_ALERT_MESSAGES)
   4908                              if (ret == MBEDTLS_ERR_SSL_INVALID_MAC) {
   4909                                  mbedtls_ssl_send_alert_message(ssl,
   4910                                                                 MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4911                                                                 MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC);
   4912                              }
   4913          #endif
   4914                              return ret;
   4915                          }
   4916          
   4917                          if (ssl->conf->badmac_limit != 0 &&
   4918                              ++ssl->badmac_seen >= ssl->conf->badmac_limit) {
   4919                              MBEDTLS_SSL_DEBUG_MSG(1, ("too many records with bad MAC"));
   4920                              return MBEDTLS_ERR_SSL_INVALID_MAC;
   4921                          }
   4922          
   4923                          /* As above, invalid records cause
   4924                           * dismissal of the whole datagram. */
   4925          
   4926                          ssl->next_record_offset = 0;
   4927                          ssl->in_left = 0;
   4928          
   4929                          MBEDTLS_SSL_DEBUG_MSG(1, ("discarding invalid record (mac)"));
   4930                          return MBEDTLS_ERR_SSL_CONTINUE_PROCESSING;
   4931                      }
   4932          
   4933                      return ret;
   4934                  } else
   4935          #endif
   4936                  {
   4937                      /* Error out (and send alert) on invalid records */
   4938          #if defined(MBEDTLS_SSL_ALL_ALERT_MESSAGES)
   4939                      if (ret == MBEDTLS_ERR_SSL_INVALID_MAC) {
   4940                          mbedtls_ssl_send_alert_message(ssl,
   4941                                                         MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4942                                                         MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC);
   4943                      }
   4944          #endif
   4945                      return ret;
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0xE027             B.N      ??ssl_get_next_record_1
   4946                  }
   4947              }
   4948          
   4949          
   4950              /* Reset in pointers to default state for TLS/DTLS records,
   4951               * assuming no CID and no offset between record content and
   4952               * record plaintext. */
   4953              mbedtls_ssl_update_in_pointers(ssl);
   \                     ??ssl_get_next_record_4: (+1)
   \       0x60   0x0030             MOVS     R0,R6
   \       0x62   0x.... 0x....      BL       mbedtls_ssl_update_in_pointers
   4954          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   4955              ssl->in_len = ssl->in_cid + rec.cid_len;
   4956          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   4957              ssl->in_iv  = ssl->in_len + 2;
   \       0x66   0x6E70             LDR      R0,[R6, #+100]
   \       0x68   0x1C80             ADDS     R0,R0,#+2
   \       0x6A   0x66B0             STR      R0,[R6, #+104]
   4958          
   4959              /* The record content type may change during decryption,
   4960               * so re-read it. */
   4961              ssl->in_msgtype = rec.type;
   \       0x6C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x70   0x6770             STR      R0,[R6, #+116]
   4962              /* Also update the input buffer, because unfortunately
   4963               * the server-side ssl_parse_client_hello() reparses the
   4964               * record header when receiving a ClientHello initiating
   4965               * a renegotiation. */
   4966              ssl->in_hdr[0] = rec.type;
   \       0x72   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \       0x76   0x6E30             LDR      R0,[R6, #+96]
   \       0x78   0x7001             STRB     R1,[R0, #+0]
   4967              ssl->in_msg    = rec.buf + rec.data_offset;
   \       0x7A   0x9903             LDR      R1,[SP, #+12]
   \       0x7C   0x9805             LDR      R0,[SP, #+20]
   \       0x7E   0x4408             ADD      R0,R1,R0
   \       0x80   0x66F0             STR      R0,[R6, #+108]
   4968              ssl->in_msglen = rec.data_len;
   \       0x82   0x9806             LDR      R0,[SP, #+24]
   \       0x84   0x67B0             STR      R0,[R6, #+120]
   4969              MBEDTLS_PUT_UINT16_BE(rec.data_len, ssl->in_len, 0);
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable28_4
   \       0x8A   0x7800             LDRB     R0,[R0, #+0]
   \       0x8C   0x2801             CMP      R0,#+1
   \       0x8E   0xD105             BNE.N    ??ssl_get_next_record_5
   \       0x90   0x9906             LDR      R1,[SP, #+24]
   \       0x92   0xB289             UXTH     R1,R1
   \       0x94   0x6E70             LDR      R0,[R6, #+100]
   \       0x96   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x9A   0xE008             B.N      ??ssl_get_next_record_6
   \                     ??ssl_get_next_record_5: (+1)
   \       0x9C   0x9806             LDR      R0,[SP, #+24]
   \       0x9E   0xB280             UXTH     R0,R0
   \       0xA0   0x.... 0x....      BL       mbedtls_bswap16
   \       0xA4   0x0001             MOVS     R1,R0
   \       0xA6   0xB289             UXTH     R1,R1
   \       0xA8   0x6E70             LDR      R0,[R6, #+100]
   \       0xAA   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   4970          
   4971              return 0;
   \                     ??ssl_get_next_record_6: (+1)
   \       0xAE   0x2000             MOVS     R0,#+0
   \                     ??ssl_get_next_record_1: (+1)
   \       0xB0   0xB008             ADD      SP,SP,#+32
   \       0xB2   0xBD70             POP      {R4-R6,PC}
   4972          }
   4973          

   \                                 In section .text, align 2, keep-with-next
   4974          int mbedtls_ssl_handle_message_type(mbedtls_ssl_context *ssl)
   4975          {
   \                     mbedtls_ssl_handle_message_type: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4976              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x056D      MVNS     R5,#+109
   4977          
   4978              /*
   4979               * Handle particular types of records
   4980               */
   4981              if (ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE) {
   \        0x8   0x6F60             LDR      R0,[R4, #+116]
   \        0xA   0x2816             CMP      R0,#+22
   \        0xC   0xD107             BNE.N    ??mbedtls_ssl_handle_message_type_0
   4982                  if ((ret = mbedtls_ssl_prepare_handshake_record(ssl)) != 0) {
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       mbedtls_ssl_prepare_handshake_record
   \       0x14   0x0005             MOVS     R5,R0
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??mbedtls_ssl_handle_message_type_0
   4983                      return ret;
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0xE038             B.N      ??mbedtls_ssl_handle_message_type_1
   4984                  }
   4985              }
   4986          
   4987              if (ssl->in_msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC) {
   \                     ??mbedtls_ssl_handle_message_type_0: (+1)
   \       0x1E   0x6F60             LDR      R0,[R4, #+116]
   \       0x20   0x2814             CMP      R0,#+20
   \       0x22   0xD10C             BNE.N    ??mbedtls_ssl_handle_message_type_2
   4988                  if (ssl->in_msglen != 1) {
   \       0x24   0x6FA0             LDR      R0,[R4, #+120]
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD002             BEQ.N    ??mbedtls_ssl_handle_message_type_3
   4989                      MBEDTLS_SSL_DEBUG_MSG(1, ("invalid CCS message, len: %" MBEDTLS_PRINTF_SIZET,
   4990                                                ssl->in_msglen));
   4991                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x2E   0xE02F             B.N      ??mbedtls_ssl_handle_message_type_1
   4992                  }
   4993          
   4994                  if (ssl->in_msg[0] != 1) {
   \                     ??mbedtls_ssl_handle_message_type_3: (+1)
   \       0x30   0x6EE0             LDR      R0,[R4, #+108]
   \       0x32   0x7800             LDRB     R0,[R0, #+0]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD002             BEQ.N    ??mbedtls_ssl_handle_message_type_2
   4995                      MBEDTLS_SSL_DEBUG_MSG(1, ("invalid CCS message, content: %02x",
   4996                                                ssl->in_msg[0]));
   4997                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x3C   0xE028             B.N      ??mbedtls_ssl_handle_message_type_1
   4998                  }
   4999          
   5000          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5001                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   5002                      ssl->state != MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC    &&
   5003                      ssl->state != MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC) {
   5004                      if (ssl->handshake == NULL) {
   5005                          MBEDTLS_SSL_DEBUG_MSG(1, ("dropping ChangeCipherSpec outside handshake"));
   5006                          return MBEDTLS_ERR_SSL_UNEXPECTED_RECORD;
   5007                      }
   5008          
   5009                      MBEDTLS_SSL_DEBUG_MSG(1, ("received out-of-order ChangeCipherSpec - remember"));
   5010                      return MBEDTLS_ERR_SSL_EARLY_MESSAGE;
   5011                  }
   5012          #endif
   5013          
   5014          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   5015                  if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
   5016          #if defined(MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE)
   5017                      MBEDTLS_SSL_DEBUG_MSG(1,
   5018                                            ("Ignore ChangeCipherSpec in TLS 1.3 compatibility mode"));
   5019                      return MBEDTLS_ERR_SSL_CONTINUE_PROCESSING;
   5020          #else
   5021                      MBEDTLS_SSL_DEBUG_MSG(1,
   5022                                            ("ChangeCipherSpec invalid in TLS 1.3 without compatibility mode"));
   5023                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   5024          #endif /* MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE */
   5025                  }
   5026          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   5027              }
   5028          
   5029              if (ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT) {
   \                     ??mbedtls_ssl_handle_message_type_2: (+1)
   \       0x3E   0x6F60             LDR      R0,[R4, #+116]
   \       0x40   0x2815             CMP      R0,#+21
   \       0x42   0xD124             BNE.N    ??mbedtls_ssl_handle_message_type_4
   5030                  if (ssl->in_msglen != 2) {
   \       0x44   0x6FA0             LDR      R0,[R4, #+120]
   \       0x46   0x2802             CMP      R0,#+2
   \       0x48   0xD002             BEQ.N    ??mbedtls_ssl_handle_message_type_5
   5031                      /* Note: Standard allows for more than one 2 byte alert
   5032                         to be packed in a single message, but Mbed TLS doesn't
   5033                         currently support this. */
   5034                      MBEDTLS_SSL_DEBUG_MSG(1, ("invalid alert message, len: %" MBEDTLS_PRINTF_SIZET,
   5035                                                ssl->in_msglen));
   5036                      return MBEDTLS_ERR_SSL_INVALID_RECORD;
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x4E   0xE01F             B.N      ??mbedtls_ssl_handle_message_type_1
   5037                  }
   5038          
   5039                  MBEDTLS_SSL_DEBUG_MSG(2, ("got an alert message, type: [%u:%u]",
   5040                                            ssl->in_msg[0], ssl->in_msg[1]));
   5041          
   5042                  /*
   5043                   * Ignore non-fatal alerts, except close_notify and no_renegotiation
   5044                   */
   5045                  if (ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_FATAL) {
   \                     ??mbedtls_ssl_handle_message_type_5: (+1)
   \       0x50   0x6EE0             LDR      R0,[R4, #+108]
   \       0x52   0x7800             LDRB     R0,[R0, #+0]
   \       0x54   0x2802             CMP      R0,#+2
   \       0x56   0xD102             BNE.N    ??mbedtls_ssl_handle_message_type_6
   5046                      MBEDTLS_SSL_DEBUG_MSG(1, ("is a fatal alert message (msg %d)",
   5047                                                ssl->in_msg[1]));
   5048                      return MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE;
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable28_5
   \       0x5C   0xE018             B.N      ??mbedtls_ssl_handle_message_type_1
   5049                  }
   5050          
   5051                  if (ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
   5052                      ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY) {
   \                     ??mbedtls_ssl_handle_message_type_6: (+1)
   \       0x5E   0x6EE0             LDR      R0,[R4, #+108]
   \       0x60   0x7800             LDRB     R0,[R0, #+0]
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0xD106             BNE.N    ??mbedtls_ssl_handle_message_type_7
   \       0x66   0x6EE0             LDR      R0,[R4, #+108]
   \       0x68   0x7840             LDRB     R0,[R0, #+1]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD102             BNE.N    ??mbedtls_ssl_handle_message_type_7
   5053                      MBEDTLS_SSL_DEBUG_MSG(2, ("is a close notify message"));
   5054                      return MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY;
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable28_6
   \       0x72   0xE00D             B.N      ??mbedtls_ssl_handle_message_type_1
   5055                  }
   5056          
   5057          #if defined(MBEDTLS_SSL_RENEGOTIATION_ENABLED)
   5058                  if (ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
   5059                      ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION) {
   \                     ??mbedtls_ssl_handle_message_type_7: (+1)
   \       0x74   0x6EE0             LDR      R0,[R4, #+108]
   \       0x76   0x7800             LDRB     R0,[R0, #+0]
   \       0x78   0x2801             CMP      R0,#+1
   \       0x7A   0xD105             BNE.N    ??mbedtls_ssl_handle_message_type_8
   \       0x7C   0x6EE0             LDR      R0,[R4, #+108]
   \       0x7E   0x7840             LDRB     R0,[R0, #+1]
   \       0x80   0x2864             CMP      R0,#+100
   \       0x82   0xD101             BNE.N    ??mbedtls_ssl_handle_message_type_8
   5060                      MBEDTLS_SSL_DEBUG_MSG(2, ("is a no renegotiation alert"));
   5061                      /* Will be handled when trying to parse ServerHello */
   5062                      return 0;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xE003             B.N      ??mbedtls_ssl_handle_message_type_1
   5063                  }
   5064          #endif
   5065                  /* Silently ignore: fetch new message */
   5066                  return MBEDTLS_ERR_SSL_NON_FATAL;
   \                     ??mbedtls_ssl_handle_message_type_8: (+1)
   \       0x88   0x.... 0x....      LDR.W    R0,??DataTable28_7
   \       0x8C   0xE000             B.N      ??mbedtls_ssl_handle_message_type_1
   5067              }
   5068          
   5069          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5070              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5071                  /* Drop unexpected ApplicationData records,
   5072                   * except at the beginning of renegotiations */
   5073                  if (ssl->in_msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA &&
   5074                      mbedtls_ssl_is_handshake_over(ssl) == 0
   5075          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5076                      && !(ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   5077                           ssl->state == MBEDTLS_SSL_SERVER_HELLO)
   5078          #endif
   5079                      ) {
   5080                      MBEDTLS_SSL_DEBUG_MSG(1, ("dropping unexpected ApplicationData"));
   5081                      return MBEDTLS_ERR_SSL_NON_FATAL;
   5082                  }
   5083          
   5084                  if (ssl->handshake != NULL &&
   5085                      mbedtls_ssl_is_handshake_over(ssl) == 1) {
   5086                      mbedtls_ssl_handshake_wrapup_free_hs_transform(ssl);
   5087                  }
   5088              }
   5089          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   5090          
   5091              return 0;
   \                     ??mbedtls_ssl_handle_message_type_4: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_handle_message_type_1: (+1)
   \       0x90   0xBD32             POP      {R1,R4,R5,PC}
   5092          }
   5093          

   \                                 In section .text, align 2, keep-with-next
   5094          int mbedtls_ssl_send_fatal_handshake_failure(mbedtls_ssl_context *ssl)
   5095          {
   \                     mbedtls_ssl_send_fatal_handshake_failure: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5096              return mbedtls_ssl_send_alert_message(ssl,
   5097                                                    MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   5098                                                    MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   \        0x4   0x2228             MOVS     R2,#+40
   \        0x6   0x2102             MOVS     R1,#+2
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   \        0xE   0xBD10             POP      {R4,PC}
   5099          }
   5100          

   \                                 In section .text, align 2, keep-with-next
   5101          int mbedtls_ssl_send_alert_message(mbedtls_ssl_context *ssl,
   5102                                             unsigned char level,
   5103                                             unsigned char message)
   5104          {
   \                     mbedtls_ssl_send_alert_message: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   5105              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x076D      MVNS     R7,#+109
   5106          
   5107              if (ssl == NULL || ssl->conf == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD002             BEQ.N    ??mbedtls_ssl_send_alert_message_0
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??mbedtls_ssl_send_alert_message_1
   5108                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \                     ??mbedtls_ssl_send_alert_message_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable28_8
   \       0x1A   0xE01D             B.N      ??mbedtls_ssl_send_alert_message_2
   5109              }
   5110          
   5111              if (ssl->out_left != 0) {
   \                     ??mbedtls_ssl_send_alert_message_1: (+1)
   \       0x1C   0xF8D4 0x00B4      LDR      R0,[R4, #+180]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD003             BEQ.N    ??mbedtls_ssl_send_alert_message_3
   5112                  return mbedtls_ssl_flush_output(ssl);
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_ssl_flush_output
   \       0x2A   0xE015             B.N      ??mbedtls_ssl_send_alert_message_2
   5113              }
   5114          
   5115              MBEDTLS_SSL_DEBUG_MSG(2, ("=> send alert message"));
   5116              MBEDTLS_SSL_DEBUG_MSG(3, ("send alert level=%u message=%u", level, message));
   5117          
   5118              ssl->out_msgtype = MBEDTLS_SSL_MSG_ALERT;
   \                     ??mbedtls_ssl_send_alert_message_3: (+1)
   \       0x2C   0x2015             MOVS     R0,#+21
   \       0x2E   0xF8C4 0x00AC      STR      R0,[R4, #+172]
   5119              ssl->out_msglen = 2;
   \       0x32   0x2002             MOVS     R0,#+2
   \       0x34   0xF8C4 0x00B0      STR      R0,[R4, #+176]
   5120              ssl->out_msg[0] = level;
   \       0x38   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \       0x3C   0x7005             STRB     R5,[R0, #+0]
   5121              ssl->out_msg[1] = message;
   \       0x3E   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \       0x42   0x7046             STRB     R6,[R0, #+1]
   5122          
   5123              if ((ret = mbedtls_ssl_write_record(ssl, SSL_FORCE_FLUSH)) != 0) {
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       mbedtls_ssl_write_record
   \       0x4C   0x0001             MOVS     R1,R0
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD001             BEQ.N    ??mbedtls_ssl_send_alert_message_4
   5124                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_record", ret);
   5125                  return ret;
   \       0x52   0x0008             MOVS     R0,R1
   \       0x54   0xE000             B.N      ??mbedtls_ssl_send_alert_message_2
   5126              }
   5127              MBEDTLS_SSL_DEBUG_MSG(2, ("<= send alert message"));
   5128          
   5129              return 0;
   \                     ??mbedtls_ssl_send_alert_message_4: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_send_alert_message_2: (+1)
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}
   5130          }
   5131          

   \                                 In section .text, align 2, keep-with-next
   5132          int mbedtls_ssl_write_change_cipher_spec(mbedtls_ssl_context *ssl)
   5133          {
   \                     mbedtls_ssl_write_change_cipher_spec: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5134              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x056D      MVNS     R5,#+109
   5135          
   5136              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write change cipher spec"));
   5137          
   5138              ssl->out_msgtype = MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC;
   \        0x8   0x2014             MOVS     R0,#+20
   \        0xA   0xF8C4 0x00AC      STR      R0,[R4, #+172]
   5139              ssl->out_msglen  = 1;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF8C4 0x00B0      STR      R0,[R4, #+176]
   5140              ssl->out_msg[0]  = 1;
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \       0x1A   0x7001             STRB     R1,[R0, #+0]
   5141          
   5142              ssl->state++;
   \       0x1C   0x6860             LDR      R0,[R4, #+4]
   \       0x1E   0x1C40             ADDS     R0,R0,#+1
   \       0x20   0x6060             STR      R0,[R4, #+4]
   5143          
   5144              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       mbedtls_ssl_write_handshake_msg
   \       0x28   0x0001             MOVS     R1,R0
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD001             BEQ.N    ??mbedtls_ssl_write_change_cipher_spec_0
   5145                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   5146                  return ret;
   \       0x2E   0x0008             MOVS     R0,R1
   \       0x30   0xE000             B.N      ??mbedtls_ssl_write_change_cipher_spec_1
   5147              }
   5148          
   5149              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write change cipher spec"));
   5150          
   5151              return 0;
   \                     ??mbedtls_ssl_write_change_cipher_spec_0: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_write_change_cipher_spec_1: (+1)
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}
   5152          }
   5153          

   \                                 In section .text, align 2, keep-with-next
   5154          int mbedtls_ssl_parse_change_cipher_spec(mbedtls_ssl_context *ssl)
   5155          {
   \                     mbedtls_ssl_parse_change_cipher_spec: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   5156              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x066D      MVNS     R6,#+109
   5157          
   5158              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse change cipher spec"));
   5159          
   5160              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       mbedtls_ssl_read_record
   \       0x12   0x0005             MOVS     R5,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD001             BEQ.N    ??mbedtls_ssl_parse_change_cipher_spec_0
   5161                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   5162                  return ret;
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xE01E             B.N      ??mbedtls_ssl_parse_change_cipher_spec_1
   5163              }
   5164          
   5165              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC) {
   \                     ??mbedtls_ssl_parse_change_cipher_spec_0: (+1)
   \       0x1C   0x6F60             LDR      R0,[R4, #+116]
   \       0x1E   0x2814             CMP      R0,#+20
   \       0x20   0xD007             BEQ.N    ??mbedtls_ssl_parse_change_cipher_spec_2
   5166                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad change cipher spec message"));
   5167                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   5168                                                 MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   \       0x22   0x220A             MOVS     R2,#+10
   \       0x24   0x2102             MOVS     R1,#+2
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   5169                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable28_9
   \       0x30   0xE013             B.N      ??mbedtls_ssl_parse_change_cipher_spec_1
   5170              }
   5171          
   5172              /* CCS records are only accepted if they have length 1 and content '1',
   5173               * so we don't need to check this here. */
   5174          
   5175              /*
   5176               * Switch to our negotiated transform and session parameters for inbound
   5177               * data.
   5178               */
   5179              MBEDTLS_SSL_DEBUG_MSG(3, ("switching to new transform spec for inbound data"));
   5180          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5181              ssl->transform_in = ssl->transform_negotiate;
   \                     ??mbedtls_ssl_parse_change_cipher_spec_2: (+1)
   \       0x32   0x6CA0             LDR      R0,[R4, #+72]
   \       0x34   0x63E0             STR      R0,[R4, #+60]
   5182          #endif
   5183              ssl->session_in = ssl->session_negotiate;
   \       0x36   0x6B60             LDR      R0,[R4, #+52]
   \       0x38   0x62A0             STR      R0,[R4, #+40]
   5184          
   5185          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5186              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5187          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   5188                  mbedtls_ssl_dtls_replay_reset(ssl);
   5189          #endif
   5190          
   5191                  /* Increment epoch */
   5192                  if (++ssl->in_epoch == 0) {
   5193                      MBEDTLS_SSL_DEBUG_MSG(1, ("DTLS epoch would wrap"));
   5194                      /* This is highly unlikely to happen for legitimate reasons, so
   5195                         treat it as an attack and don't send an alert. */
   5196                      return MBEDTLS_ERR_SSL_COUNTER_WRAPPING;
   5197                  }
   5198              } else
   5199          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   5200              memset(ssl->in_ctr, 0, MBEDTLS_SSL_SEQUENCE_NUMBER_LEN);
   \       0x3A   0x2608             MOVS     R6,#+8
   \       0x3C   0x2700             MOVS     R7,#+0
   \       0x3E   0xF8D4 0x805C      LDR      R8,[R4, #+92]
   \       0x42   0x003A             MOVS     R2,R7
   \       0x44   0x0031             MOVS     R1,R6
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0x.... 0x....      BL       __aeabi_memset
   5201          
   5202              mbedtls_ssl_update_in_pointers(ssl);
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       mbedtls_ssl_update_in_pointers
   5203          
   5204              ssl->state++;
   \       0x52   0x6860             LDR      R0,[R4, #+4]
   \       0x54   0x1C40             ADDS     R0,R0,#+1
   \       0x56   0x6060             STR      R0,[R4, #+4]
   5205          
   5206              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse change cipher spec"));
   5207          
   5208              return 0;
   \       0x58   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_parse_change_cipher_spec_1: (+1)
   \       0x5A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   5209          }
   5210          
   5211          /* Once ssl->out_hdr as the address of the beginning of the
   5212           * next outgoing record is set, deduce the other pointers.
   5213           *
   5214           * Note: For TLS, we save the implicit record sequence number
   5215           *       (entering MAC computation) in the 8 bytes before ssl->out_hdr,
   5216           *       and the caller has to make sure there's space for this.
   5217           */
   5218          

   \                                 In section .text, align 2, keep-with-next
   5219          static size_t ssl_transform_get_explicit_iv_len(
   5220              mbedtls_ssl_transform const *transform)
   5221          {
   \                     ssl_transform_get_explicit_iv_len: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   5222              return transform->ivlen - transform->fixed_ivlen;
   \        0x2   0x6848             LDR      R0,[R1, #+4]
   \        0x4   0x6889             LDR      R1,[R1, #+8]
   \        0x6   0x1A40             SUBS     R0,R0,R1
   \        0x8   0x4770             BX       LR
   5223          }
   5224          

   \                                 In section .text, align 2, keep-with-next
   5225          void mbedtls_ssl_update_out_pointers(mbedtls_ssl_context *ssl,
   5226                                               mbedtls_ssl_transform *transform)
   5227          {
   \                     mbedtls_ssl_update_out_pointers: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   5228          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5229              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5230                  ssl->out_ctr = ssl->out_hdr +  3;
   5231          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   5232                  ssl->out_cid = ssl->out_ctr + MBEDTLS_SSL_SEQUENCE_NUMBER_LEN;
   5233                  ssl->out_len = ssl->out_cid;
   5234                  if (transform != NULL) {
   5235                      ssl->out_len += transform->out_cid_len;
   5236                  }
   5237          #else /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   5238                  ssl->out_len = ssl->out_ctr + MBEDTLS_SSL_SEQUENCE_NUMBER_LEN;
   5239          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   5240                  ssl->out_iv  = ssl->out_len + 2;
   5241              } else
   5242          #endif
   5243              {
   5244                  ssl->out_len = ssl->out_hdr + 3;
   \        0x6   0xF8D5 0x009C      LDR      R0,[R5, #+156]
   \        0xA   0x1CC0             ADDS     R0,R0,#+3
   \        0xC   0xF8C5 0x00A0      STR      R0,[R5, #+160]
   5245          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   5246                  ssl->out_cid = ssl->out_len;
   5247          #endif
   5248                  ssl->out_iv  = ssl->out_hdr + 5;
   \       0x10   0xF8D5 0x009C      LDR      R0,[R5, #+156]
   \       0x14   0x1D40             ADDS     R0,R0,#+5
   \       0x16   0xF8C5 0x00A4      STR      R0,[R5, #+164]
   5249              }
   5250          
   5251              ssl->out_msg = ssl->out_iv;
   \       0x1A   0xF8D5 0x00A4      LDR      R0,[R5, #+164]
   \       0x1E   0xF8C5 0x00A8      STR      R0,[R5, #+168]
   5252              /* Adjust out_msg to make space for explicit IV, if used. */
   5253              if (transform != NULL) {
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD007             BEQ.N    ??mbedtls_ssl_update_out_pointers_0
   5254                  ssl->out_msg += ssl_transform_get_explicit_iv_len(transform);
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       ssl_transform_get_explicit_iv_len
   \       0x2C   0xF8D5 0x10A8      LDR      R1,[R5, #+168]
   \       0x30   0x4408             ADD      R0,R1,R0
   \       0x32   0xF8C5 0x00A8      STR      R0,[R5, #+168]
   5255              }
   5256          }
   \                     ??mbedtls_ssl_update_out_pointers_0: (+1)
   \       0x36   0xBD31             POP      {R0,R4,R5,PC}
   5257          
   5258          /* Once ssl->in_hdr as the address of the beginning of the
   5259           * next incoming record is set, deduce the other pointers.
   5260           *
   5261           * Note: For TLS, we save the implicit record sequence number
   5262           *       (entering MAC computation) in the 8 bytes before ssl->in_hdr,
   5263           *       and the caller has to make sure there's space for this.
   5264           */
   5265          

   \                                 In section .text, align 2, keep-with-next
   5266          void mbedtls_ssl_update_in_pointers(mbedtls_ssl_context *ssl)
   5267          {
   5268              /* This function sets the pointers to match the case
   5269               * of unprotected TLS/DTLS records, with both  ssl->in_iv
   5270               * and ssl->in_msg pointing to the beginning of the record
   5271               * content.
   5272               *
   5273               * When decrypting a protected record, ssl->in_msg
   5274               * will be shifted to point to the beginning of the
   5275               * record plaintext.
   5276               */
   5277          
   5278          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5279              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5280                  /* This sets the header pointers to match records
   5281                   * without CID. When we receive a record containing
   5282                   * a CID, the fields are shifted accordingly in
   5283                   * ssl_parse_record_header(). */
   5284                  ssl->in_ctr = ssl->in_hdr +  3;
   5285          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   5286                  ssl->in_cid = ssl->in_ctr + MBEDTLS_SSL_SEQUENCE_NUMBER_LEN;
   5287                  ssl->in_len = ssl->in_cid; /* Default: no CID */
   5288          #else /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   5289                  ssl->in_len = ssl->in_ctr + MBEDTLS_SSL_SEQUENCE_NUMBER_LEN;
   5290          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   5291                  ssl->in_iv  = ssl->in_len + 2;
   5292              } else
   5293          #endif
   5294              {
   5295                  ssl->in_ctr = ssl->in_hdr - MBEDTLS_SSL_SEQUENCE_NUMBER_LEN;
   \                     mbedtls_ssl_update_in_pointers: (+1)
   \        0x0   0x6E01             LDR      R1,[R0, #+96]
   \        0x2   0x3908             SUBS     R1,R1,#+8
   \        0x4   0x65C1             STR      R1,[R0, #+92]
   5296                  ssl->in_len = ssl->in_hdr + 3;
   \        0x6   0x6E01             LDR      R1,[R0, #+96]
   \        0x8   0x1CC9             ADDS     R1,R1,#+3
   \        0xA   0x6641             STR      R1,[R0, #+100]
   5297          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   5298                  ssl->in_cid = ssl->in_len;
   5299          #endif
   5300                  ssl->in_iv  = ssl->in_hdr + 5;
   \        0xC   0x6E01             LDR      R1,[R0, #+96]
   \        0xE   0x1D49             ADDS     R1,R1,#+5
   \       0x10   0x6681             STR      R1,[R0, #+104]
   5301              }
   5302          
   5303              /* This will be adjusted at record decryption time. */
   5304              ssl->in_msg = ssl->in_iv;
   \       0x12   0x6E81             LDR      R1,[R0, #+104]
   \       0x14   0x66C1             STR      R1,[R0, #+108]
   5305          }
   \       0x16   0x4770             BX       LR
   5306          
   5307          /*
   5308           * Setup an SSL context
   5309           */
   5310          

   \                                 In section .text, align 2, keep-with-next
   5311          void mbedtls_ssl_reset_in_out_pointers(mbedtls_ssl_context *ssl)
   5312          {
   \                     mbedtls_ssl_reset_in_out_pointers: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5313              /* Set the incoming and outgoing record pointers. */
   5314          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5315              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5316                  ssl->out_hdr = ssl->out_buf;
   5317                  ssl->in_hdr  = ssl->in_buf;
   5318              } else
   5319          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   5320              {
   5321                  ssl->out_ctr = ssl->out_buf;
   \        0x4   0xF8D4 0x0094      LDR      R0,[R4, #+148]
   \        0x8   0xF8C4 0x0098      STR      R0,[R4, #+152]
   5322                  ssl->out_hdr = ssl->out_buf + 8;
   \        0xC   0xF8D4 0x0094      LDR      R0,[R4, #+148]
   \       0x10   0x3008             ADDS     R0,R0,#+8
   \       0x12   0xF8C4 0x009C      STR      R0,[R4, #+156]
   5323                  ssl->in_hdr  = ssl->in_buf  + 8;
   \       0x16   0x6DA0             LDR      R0,[R4, #+88]
   \       0x18   0x3008             ADDS     R0,R0,#+8
   \       0x1A   0x6620             STR      R0,[R4, #+96]
   5324              }
   5325          
   5326              /* Derive other internal pointers. */
   5327              mbedtls_ssl_update_out_pointers(ssl, NULL /* no transform enabled */);
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       mbedtls_ssl_update_out_pointers
   5328              mbedtls_ssl_update_in_pointers(ssl);
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_ssl_update_in_pointers
   5329          }
   \       0x2A   0xBD10             POP      {R4,PC}
   5330          
   5331          /*
   5332           * SSL get accessors
   5333           */

   \                                 In section .text, align 2, keep-with-next
   5334          size_t mbedtls_ssl_get_bytes_avail(const mbedtls_ssl_context *ssl)
   5335          {
   5336              return ssl->in_offt == NULL ? 0 : ssl->in_msglen;
   \                     mbedtls_ssl_get_bytes_avail: (+1)
   \        0x0   0x6F01             LDR      R1,[R0, #+112]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD101             BNE.N    ??mbedtls_ssl_get_bytes_avail_0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE000             B.N      ??mbedtls_ssl_get_bytes_avail_1
   \                     ??mbedtls_ssl_get_bytes_avail_0: (+1)
   \        0xA   0x6F80             LDR      R0,[R0, #+120]
   \                     ??mbedtls_ssl_get_bytes_avail_1: (+1)
   \        0xC   0x4770             BX       LR
   5337          }
   5338          

   \                                 In section .text, align 2, keep-with-next
   5339          int mbedtls_ssl_check_pending(const mbedtls_ssl_context *ssl)
   5340          {
   \                     mbedtls_ssl_check_pending: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   5341              /*
   5342               * Case A: We're currently holding back
   5343               * a message for further processing.
   5344               */
   5345          
   5346              if (ssl->keep_current_message == 1) {
   \        0x2   0xF8D1 0x0088      LDR      R0,[R1, #+136]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??mbedtls_ssl_check_pending_0
   5347                  MBEDTLS_SSL_DEBUG_MSG(3, ("ssl_check_pending: record held back for processing"));
   5348                  return 1;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE010             B.N      ??mbedtls_ssl_check_pending_1
   5349              }
   5350          
   5351              /*
   5352               * Case B: Further records are pending in the current datagram.
   5353               */
   5354          
   5355          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5356              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   5357                  ssl->in_left > ssl->next_record_offset) {
   5358                  MBEDTLS_SSL_DEBUG_MSG(3, ("ssl_check_pending: more records within current datagram"));
   5359                  return 1;
   5360              }
   5361          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   5362          
   5363              /*
   5364               * Case C: A handshake message is being processed.
   5365               */
   5366          
   5367              if (ssl->in_hslen > 0 && ssl->in_hslen < ssl->in_msglen) {
   \                     ??mbedtls_ssl_check_pending_0: (+1)
   \        0xE   0xF8D1 0x0080      LDR      R0,[R1, #+128]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD006             BEQ.N    ??mbedtls_ssl_check_pending_2
   \       0x16   0xF8D1 0x2080      LDR      R2,[R1, #+128]
   \       0x1A   0x6F88             LDR      R0,[R1, #+120]
   \       0x1C   0x4282             CMP      R2,R0
   \       0x1E   0xD201             BCS.N    ??mbedtls_ssl_check_pending_2
   5368                  MBEDTLS_SSL_DEBUG_MSG(3,
   5369                                        ("ssl_check_pending: more handshake messages within current record"));
   5370                  return 1;
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE005             B.N      ??mbedtls_ssl_check_pending_1
   5371              }
   5372          
   5373              /*
   5374               * Case D: An application data message is being processed
   5375               */
   5376              if (ssl->in_offt != NULL) {
   \                     ??mbedtls_ssl_check_pending_2: (+1)
   \       0x24   0x6F08             LDR      R0,[R1, #+112]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ.N    ??mbedtls_ssl_check_pending_3
   5377                  MBEDTLS_SSL_DEBUG_MSG(3, ("ssl_check_pending: application data record is being processed"));
   5378                  return 1;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE000             B.N      ??mbedtls_ssl_check_pending_1
   5379              }
   5380          
   5381              /*
   5382               * In all other cases, the rest of the message can be dropped.
   5383               * As in ssl_get_next_record, this needs to be adapted if
   5384               * we implement support for multiple alerts in single records.
   5385               */
   5386          
   5387              MBEDTLS_SSL_DEBUG_MSG(3, ("ssl_check_pending: nothing pending"));
   5388              return 0;
   \                     ??mbedtls_ssl_check_pending_3: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_check_pending_1: (+1)
   \       0x30   0x4770             BX       LR
   5389          }
   5390          
   5391          

   \                                 In section .text, align 2, keep-with-next
   5392          int mbedtls_ssl_get_record_expansion(const mbedtls_ssl_context *ssl)
   5393          {
   \                     mbedtls_ssl_get_record_expansion: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x0007             MOVS     R7,R0
   5394              size_t transform_expansion = 0;
   \        0x8   0xF05F 0x0800      MOVS     R8,#+0
   5395              const mbedtls_ssl_transform *transform = ssl->transform_out;
   \        0xC   0x6C3C             LDR      R4,[R7, #+64]
   5396              unsigned block_size;
   5397          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   5398              psa_key_attributes_t attr = PSA_KEY_ATTRIBUTES_INIT;
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x2124             MOVS     R1,#+36
   \       0x12   0x.... 0x....      BL       __aeabi_memclr4
   5399              psa_key_type_t key_type;
   5400          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   5401          
   5402              size_t out_hdr_len = mbedtls_ssl_out_hdr_len(ssl);
   \       0x16   0x0038             MOVS     R0,R7
   \       0x18   0x.... 0x....      BL       mbedtls_ssl_out_hdr_len
   \       0x1C   0x4681             MOV      R9,R0
   5403          
   5404              if (transform == NULL) {
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD101             BNE.N    ??mbedtls_ssl_get_record_expansion_0
   5405                  return (int) out_hdr_len;
   \       0x22   0x4648             MOV      R0,R9
   \       0x24   0xE044             B.N      ??mbedtls_ssl_get_record_expansion_1
   5406              }
   5407          
   5408          
   5409          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   5410              if (transform->psa_alg == PSA_ALG_GCM ||
   5411                  transform->psa_alg == PSA_ALG_CCM ||
   5412                  transform->psa_alg == PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, 8) ||
   5413                  transform->psa_alg == PSA_ALG_CHACHA20_POLY1305 ||
   5414                  transform->psa_alg == MBEDTLS_SSL_NULL_CIPHER) {
   \                     ??mbedtls_ssl_get_record_expansion_0: (+1)
   \       0x26   0x6CE1             LDR      R1,[R4, #+76]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable28_10
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD012             BEQ.N    ??mbedtls_ssl_get_record_expansion_2
   \       0x30   0x6CE1             LDR      R1,[R4, #+76]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable28_11
   \       0x36   0x4281             CMP      R1,R0
   \       0x38   0xD00D             BEQ.N    ??mbedtls_ssl_get_record_expansion_2
   \       0x3A   0x6CE1             LDR      R1,[R4, #+76]
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable28_12
   \       0x40   0x4281             CMP      R1,R0
   \       0x42   0xD008             BEQ.N    ??mbedtls_ssl_get_record_expansion_2
   \       0x44   0x6CE1             LDR      R1,[R4, #+76]
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable28_13
   \       0x4A   0x4281             CMP      R1,R0
   \       0x4C   0xD003             BEQ.N    ??mbedtls_ssl_get_record_expansion_2
   \       0x4E   0x6CE0             LDR      R0,[R4, #+76]
   \       0x50   0xF1B0 0x6F80      CMP      R0,#+67108864
   \       0x54   0xD101             BNE.N    ??mbedtls_ssl_get_record_expansion_3
   5415                  transform_expansion = transform->minlen;
   \                     ??mbedtls_ssl_get_record_expansion_2: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0xE028             B.N      ??mbedtls_ssl_get_record_expansion_4
   5416              } else if (transform->psa_alg == PSA_ALG_CBC_NO_PADDING) {
   \                     ??mbedtls_ssl_get_record_expansion_3: (+1)
   \       0x5A   0x6CE1             LDR      R1,[R4, #+76]
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable28_14
   \       0x60   0x4281             CMP      R1,R0
   \       0x62   0xD120             BNE.N    ??mbedtls_ssl_get_record_expansion_5
   5417                  (void) psa_get_key_attributes(transform->psa_key_enc, &attr);
   \       0x64   0x4669             MOV      R1,SP
   \       0x66   0x6C60             LDR      R0,[R4, #+68]
   \       0x68   0x.... 0x....      BL       psa_get_key_attributes
   5418                  key_type = psa_get_key_type(&attr);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x.... 0x....      BL       psa_get_key_type
   \       0x72   0x0006             MOVS     R6,R0
   5419          
   5420                  block_size = PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type);
   \       0x74   0x0030             MOVS     R0,R6
   \       0x76   0xB280             UXTH     R0,R0
   \       0x78   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x7C   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x80   0xD107             BNE.N    ??mbedtls_ssl_get_record_expansion_6
   \       0x82   0x2501             MOVS     R5,#+1
   \       0x84   0x0030             MOVS     R0,R6
   \       0x86   0xB280             UXTH     R0,R0
   \       0x88   0x0A00             LSRS     R0,R0,#+8
   \       0x8A   0xF010 0x0007      ANDS     R0,R0,#0x7
   \       0x8E   0x4085             LSLS     R5,R5,R0
   \       0x90   0xE000             B.N      ??mbedtls_ssl_get_record_expansion_7
   \                     ??mbedtls_ssl_get_record_expansion_6: (+1)
   \       0x92   0x2500             MOVS     R5,#+0
   5421          
   5422                  /* Expansion due to the addition of the MAC. */
   5423                  transform_expansion += transform->maclen;
   \                     ??mbedtls_ssl_get_record_expansion_7: (+1)
   \       0x94   0x68E0             LDR      R0,[R4, #+12]
   \       0x96   0xEB10 0x0808      ADDS     R8,R0,R8
   5424          
   5425                  /* Expansion due to the addition of CBC padding;
   5426                   * Theoretically up to 256 bytes, but we never use
   5427                   * more than the block size of the underlying cipher. */
   5428                  transform_expansion += block_size;
   \       0x9A   0xEB15 0x0808      ADDS     R8,R5,R8
   5429          
   5430                  /* For TLS 1.2 or higher, an explicit IV is added
   5431                   * after the record header. */
   5432          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5433                  transform_expansion += block_size;
   \       0x9E   0xEB15 0x0808      ADDS     R8,R5,R8
   \       0xA2   0x4640             MOV      R0,R8
   \       0xA4   0xE002             B.N      ??mbedtls_ssl_get_record_expansion_4
   5434          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5435              } else {
   5436                  MBEDTLS_SSL_DEBUG_MSG(1,
   5437                                        ("Unsupported psa_alg spotted in mbedtls_ssl_get_record_expansion()"));
   5438                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \                     ??mbedtls_ssl_get_record_expansion_5: (+1)
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0xAA   0xE001             B.N      ??mbedtls_ssl_get_record_expansion_1
   5439              }
   5440          #else
   5441              switch (mbedtls_cipher_get_cipher_mode(&transform->cipher_ctx_enc)) {
   5442                  case MBEDTLS_MODE_GCM:
   5443                  case MBEDTLS_MODE_CCM:
   5444                  case MBEDTLS_MODE_CHACHAPOLY:
   5445                  case MBEDTLS_MODE_STREAM:
   5446                      transform_expansion = transform->minlen;
   5447                      break;
   5448          
   5449                  case MBEDTLS_MODE_CBC:
   5450          
   5451                      block_size = mbedtls_cipher_get_block_size(
   5452                          &transform->cipher_ctx_enc);
   5453          
   5454                      /* Expansion due to the addition of the MAC. */
   5455                      transform_expansion += transform->maclen;
   5456          
   5457                      /* Expansion due to the addition of CBC padding;
   5458                       * Theoretically up to 256 bytes, but we never use
   5459                       * more than the block size of the underlying cipher. */
   5460                      transform_expansion += block_size;
   5461          
   5462                      /* For TLS 1.2 or higher, an explicit IV is added
   5463                       * after the record header. */
   5464          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5465                      transform_expansion += block_size;
   5466          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5467          
   5468                      break;
   5469          
   5470                  default:
   5471                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   5472                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   5473              }
   5474          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   5475          
   5476          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   5477              if (transform->out_cid_len != 0) {
   5478                  transform_expansion += MBEDTLS_SSL_MAX_CID_EXPANSION;
   5479              }
   5480          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   5481          
   5482              return (int) (out_hdr_len + transform_expansion);
   \                     ??mbedtls_ssl_get_record_expansion_4: (+1)
   \       0xAC   0xEB10 0x0009      ADDS     R0,R0,R9
   \                     ??mbedtls_ssl_get_record_expansion_1: (+1)
   \       0xB0   0xB009             ADD      SP,SP,#+36
   \       0xB2   0xE8BD 0x83F0      POP      {R4-R9,PC}
   5483          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   5484          
   5485          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5486          /*
   5487           * Check record counters and renegotiate if they're above the limit.
   5488           */
   5489          MBEDTLS_CHECK_RETURN_CRITICAL
   5490          static int ssl_check_ctr_renegotiate(mbedtls_ssl_context *ssl)
   5491          {
   5492              size_t ep_len = mbedtls_ssl_ep_len(ssl);
   5493              int in_ctr_cmp;
   5494              int out_ctr_cmp;
   5495          
   5496              if (mbedtls_ssl_is_handshake_over(ssl) == 0 ||
   5497                  ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING ||
   5498                  ssl->conf->disable_renegotiation == MBEDTLS_SSL_RENEGOTIATION_DISABLED) {
   5499                  return 0;
   5500              }
   5501          
   5502              in_ctr_cmp = memcmp(ssl->in_ctr + ep_len,
   5503                                  &ssl->conf->renego_period[ep_len],
   5504                                  MBEDTLS_SSL_SEQUENCE_NUMBER_LEN - ep_len);
   5505              out_ctr_cmp = memcmp(&ssl->cur_out_ctr[ep_len],
   5506                                   &ssl->conf->renego_period[ep_len],
   5507                                   sizeof(ssl->cur_out_ctr) - ep_len);
   5508          
   5509              if (in_ctr_cmp <= 0 && out_ctr_cmp <= 0) {
   5510                  return 0;
   5511              }
   5512          
   5513              MBEDTLS_SSL_DEBUG_MSG(1, ("record counter limit reached: renegotiate"));
   5514              return mbedtls_ssl_renegotiate(ssl);
   5515          }
   5516          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   5517          
   5518          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   5519          
   5520          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
   5521          MBEDTLS_CHECK_RETURN_CRITICAL
   5522          static int ssl_tls13_check_new_session_ticket(mbedtls_ssl_context *ssl)
   5523          {
   5524          
   5525              if ((ssl->in_hslen == mbedtls_ssl_hs_hdr_len(ssl)) ||
   5526                  (ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET)) {
   5527                  return 0;
   5528              }
   5529          
   5530              ssl->keep_current_message = 1;
   5531          
   5532              MBEDTLS_SSL_DEBUG_MSG(3, ("NewSessionTicket received"));
   5533              mbedtls_ssl_handshake_set_state(ssl,
   5534                                              MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET);
   5535          
   5536              return MBEDTLS_ERR_SSL_WANT_READ;
   5537          }
   5538          #endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */
   5539          
   5540          MBEDTLS_CHECK_RETURN_CRITICAL
   5541          static int ssl_tls13_handle_hs_message_post_handshake(mbedtls_ssl_context *ssl)
   5542          {
   5543          
   5544              MBEDTLS_SSL_DEBUG_MSG(3, ("received post-handshake message"));
   5545          
   5546          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
   5547              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   5548                  int ret = ssl_tls13_check_new_session_ticket(ssl);
   5549                  if (ret != 0) {
   5550                      return ret;
   5551                  }
   5552              }
   5553          #endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */
   5554          
   5555              /* Fail in all other cases. */
   5556              return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   5557          }
   5558          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   5559          
   5560          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5561          /* This function is called from mbedtls_ssl_read() when a handshake message is
   5562           * received after the initial handshake. In this context, handshake messages
   5563           * may only be sent for the purpose of initiating renegotiations.
   5564           *
   5565           * This function is introduced as a separate helper since the handling
   5566           * of post-handshake handshake messages changes significantly in TLS 1.3,
   5567           * and having a helper function allows to distinguish between TLS <= 1.2 and
   5568           * TLS 1.3 in the future without bloating the logic of mbedtls_ssl_read().
   5569           */
   5570          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   5571          static int ssl_tls12_handle_hs_message_post_handshake(mbedtls_ssl_context *ssl)
   5572          {
   \                     ssl_tls12_handle_hs_message_post_handshake: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5573              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x056D      MVNS     R5,#+109
   5574          
   5575              /*
   5576               * - For client-side, expect SERVER_HELLO_REQUEST.
   5577               * - For server-side, expect CLIENT_HELLO.
   5578               * - Fail (TLS) or silently drop record (DTLS) in other cases.
   5579               */
   5580          
   5581          #if defined(MBEDTLS_SSL_CLI_C)
   5582              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
   5583                  (ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_REQUEST ||
   5584                   ssl->in_hslen  != mbedtls_ssl_hs_hdr_len(ssl))) {
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x7900             LDRB     R0,[R0, #+4]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD10D             BNE.N    ??ssl_tls12_handle_hs_message_post_handshake_0
   \       0x10   0x6EE0             LDR      R0,[R4, #+108]
   \       0x12   0x7800             LDRB     R0,[R0, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD106             BNE.N    ??ssl_tls12_handle_hs_message_post_handshake_1
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0x1E   0xF8D4 0x1080      LDR      R1,[R4, #+128]
   \       0x22   0x4281             CMP      R1,R0
   \       0x24   0xD002             BEQ.N    ??ssl_tls12_handle_hs_message_post_handshake_0
   5585                  MBEDTLS_SSL_DEBUG_MSG(1, ("handshake received (not HelloRequest)"));
   5586          
   5587                  /* With DTLS, drop the packet (probably from last handshake) */
   5588          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5589                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5590                      return 0;
   5591                  }
   5592          #endif
   5593                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   \                     ??ssl_tls12_handle_hs_message_post_handshake_1: (+1)
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable28_9
   \       0x2A   0xE00A             B.N      ??ssl_tls12_handle_hs_message_post_handshake_2
   5594              }
   5595          #endif /* MBEDTLS_SSL_CLI_C */
   5596          
   5597          #if defined(MBEDTLS_SSL_SRV_C)
   5598              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   5599                  ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_HELLO) {
   5600                  MBEDTLS_SSL_DEBUG_MSG(1, ("handshake received (not ClientHello)"));
   5601          
   5602                  /* With DTLS, drop the packet (probably from last handshake) */
   5603          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5604                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5605                      return 0;
   5606                  }
   5607          #endif
   5608                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   5609              }
   5610          #endif /* MBEDTLS_SSL_SRV_C */
   5611          
   5612          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5613              /* Determine whether renegotiation attempt should be accepted */
   5614              if (!(ssl->conf->disable_renegotiation == MBEDTLS_SSL_RENEGOTIATION_DISABLED ||
   5615                    (ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   5616                     ssl->conf->allow_legacy_renegotiation ==
   5617                     MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION))) {
   5618                  /*
   5619                   * Accept renegotiation request
   5620                   */
   5621          
   5622                  /* DTLS clients need to know renego is server-initiated */
   5623          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5624                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   5625                      ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   5626                      ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_PENDING;
   5627                  }
   5628          #endif
   5629                  ret = mbedtls_ssl_start_renegotiation(ssl);
   5630                  if (ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
   5631                      ret != 0) {
   5632                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_start_renegotiation",
   5633                                            ret);
   5634                      return ret;
   5635                  }
   5636              } else
   5637          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   5638              {
   5639                  /*
   5640                   * Refuse renegotiation
   5641                   */
   5642          
   5643                  MBEDTLS_SSL_DEBUG_MSG(3, ("refusing renegotiation, sending alert"));
   5644          
   5645                  if ((ret = mbedtls_ssl_send_alert_message(ssl,
   5646                                                            MBEDTLS_SSL_ALERT_LEVEL_WARNING,
   5647                                                            MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION)) != 0) {
   \                     ??ssl_tls12_handle_hs_message_post_handshake_0: (+1)
   \       0x2C   0x2264             MOVS     R2,#+100
   \       0x2E   0x2101             MOVS     R1,#+1
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??ssl_tls12_handle_hs_message_post_handshake_3
   5648                      return ret;
   \       0x3C   0x0008             MOVS     R0,R1
   \       0x3E   0xE000             B.N      ??ssl_tls12_handle_hs_message_post_handshake_2
   5649                  }
   5650              }
   5651          
   5652              return 0;
   \                     ??ssl_tls12_handle_hs_message_post_handshake_3: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??ssl_tls12_handle_hs_message_post_handshake_2: (+1)
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}
   5653          }
   5654          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5655          
   5656          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   5657          static int ssl_handle_hs_message_post_handshake(mbedtls_ssl_context *ssl)
   5658          {
   \                     ssl_handle_hs_message_post_handshake: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5659              /* Check protocol version and dispatch accordingly. */
   5660          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   5661              if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
   5662                  return ssl_tls13_handle_hs_message_post_handshake(ssl);
   5663              }
   5664          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   5665          
   5666          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5667              if (ssl->tls_version <= MBEDTLS_SSL_VERSION_TLS1_2) {
   \        0x4   0xF9B4 0x0008      LDRSH    R0,[R4, #+8]
   \        0x8   0xF5B0 0x7F41      CMP      R0,#+772
   \        0xC   0xDA03             BGE.N    ??ssl_handle_hs_message_post_handshake_0
   5668                  return ssl_tls12_handle_hs_message_post_handshake(ssl);
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       ssl_tls12_handle_hs_message_post_handshake
   \       0x14   0xE000             B.N      ??ssl_handle_hs_message_post_handshake_1
   5669              }
   5670          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5671          
   5672              /* Should never happen */
   5673              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \                     ??ssl_handle_hs_message_post_handshake_0: (+1)
   \       0x16   0x....             LDR.N    R0,??DataTable28_3
   \                     ??ssl_handle_hs_message_post_handshake_1: (+1)
   \       0x18   0xBD10             POP      {R4,PC}
   5674          }
   5675          
   5676          /*
   5677           * Receive application data decrypted from the SSL layer
   5678           */

   \                                 In section .text, align 2, keep-with-next
   5679          int mbedtls_ssl_read(mbedtls_ssl_context *ssl, unsigned char *buf, size_t len)
   5680          {
   \                     mbedtls_ssl_read: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0016             MOVS     R6,R2
   5681              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x046D      MVNS     R4,#+109
   5682              size_t n;
   5683          
   5684              if (ssl == NULL || ssl->conf == NULL) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD002             BEQ.N    ??mbedtls_ssl_read_0
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??mbedtls_ssl_read_1
   5685                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \                     ??mbedtls_ssl_read_0: (+1)
   \       0x18   0x....             LDR.N    R0,??DataTable28_8
   \       0x1A   0xE089             B.N      ??mbedtls_ssl_read_2
   5686              }
   5687          
   5688              MBEDTLS_SSL_DEBUG_MSG(2, ("=> read"));
   5689          
   5690          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5691              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5692                  if ((ret = mbedtls_ssl_flush_output(ssl)) != 0) {
   5693                      return ret;
   5694                  }
   5695          
   5696                  if (ssl->handshake != NULL &&
   5697                      ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING) {
   5698                      if ((ret = mbedtls_ssl_flight_transmit(ssl)) != 0) {
   5699                          return ret;
   5700                      }
   5701                  }
   5702              }
   5703          #endif
   5704          
   5705              /*
   5706               * Check if renegotiation is necessary and/or handshake is
   5707               * in process. If yes, perform/continue, and fall through
   5708               * if an unexpected packet is received while the client
   5709               * is waiting for the ServerHello.
   5710               *
   5711               * (There is no equivalent to the last condition on
   5712               *  the server-side as it is not treated as within
   5713               *  a handshake while waiting for the ClientHello
   5714               *  after a renegotiation request.)
   5715               */
   5716          
   5717          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5718              ret = ssl_check_ctr_renegotiate(ssl);
   5719              if (ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
   5720                  ret != 0) {
   5721                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_check_ctr_renegotiate", ret);
   5722                  return ret;
   5723              }
   5724          #endif
   5725          
   5726              if (ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER) {
   \                     ??mbedtls_ssl_read_1: (+1)
   \       0x1C   0x6868             LDR      R0,[R5, #+4]
   \       0x1E   0x281B             CMP      R0,#+27
   \       0x20   0xD00A             BEQ.N    ??mbedtls_ssl_read_3
   5727                  ret = mbedtls_ssl_handshake(ssl);
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       mbedtls_ssl_handshake
   \       0x28   0x0004             MOVS     R4,R0
   5728                  if (ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
   5729                      ret != 0) {
   \       0x2A   0xF514 0x4FD6      CMN      R4,#+27392
   \       0x2E   0xD003             BEQ.N    ??mbedtls_ssl_read_3
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD001             BEQ.N    ??mbedtls_ssl_read_3
   5730                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_handshake", ret);
   5731                      return ret;
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0xE07B             B.N      ??mbedtls_ssl_read_2
   5732                  }
   5733              }
   5734          
   5735              /* Loop as long as no application data record is available */
   5736              while (ssl->in_offt == NULL) {
   \                     ??mbedtls_ssl_read_3: (+1)
   \       0x38   0x6F28             LDR      R0,[R5, #+112]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD151             BNE.N    ??mbedtls_ssl_read_4
   5737                  /* Start timer if not already running */
   5738                  if (ssl->f_get_timer != NULL &&
   5739                      ssl->f_get_timer(ssl->p_timer) == -1) {
   \       0x3E   0x6D68             LDR      R0,[R5, #+84]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD00A             BEQ.N    ??mbedtls_ssl_read_5
   \       0x44   0x6CE8             LDR      R0,[R5, #+76]
   \       0x46   0x6D69             LDR      R1,[R5, #+84]
   \       0x48   0x4788             BLX      R1
   \       0x4A   0xF110 0x0F01      CMN      R0,#+1
   \       0x4E   0xD104             BNE.N    ??mbedtls_ssl_read_5
   5740                      mbedtls_ssl_set_timer(ssl, ssl->conf->read_timeout);
   \       0x50   0x6828             LDR      R0,[R5, #+0]
   \       0x52   0x6D41             LDR      R1,[R0, #+84]
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0x.... 0x....      BL       mbedtls_ssl_set_timer
   5741                  }
   5742          
   5743                  if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   \                     ??mbedtls_ssl_read_5: (+1)
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0x.... 0x....      BL       mbedtls_ssl_read_record
   \       0x62   0x0004             MOVS     R4,R0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD006             BEQ.N    ??mbedtls_ssl_read_6
   5744                      if (ret == MBEDTLS_ERR_SSL_CONN_EOF) {
   \       0x68   0xF514 0x4FE5      CMN      R4,#+29312
   \       0x6C   0xD101             BNE.N    ??mbedtls_ssl_read_7
   5745                          return 0;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xE05E             B.N      ??mbedtls_ssl_read_2
   5746                      }
   5747          
   5748                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   5749                      return ret;
   \                     ??mbedtls_ssl_read_7: (+1)
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0xE05C             B.N      ??mbedtls_ssl_read_2
   5750                  }
   5751          
   5752                  if (ssl->in_msglen  == 0 &&
   5753                      ssl->in_msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA) {
   \                     ??mbedtls_ssl_read_6: (+1)
   \       0x76   0x6FA8             LDR      R0,[R5, #+120]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD110             BNE.N    ??mbedtls_ssl_read_8
   \       0x7C   0x6F68             LDR      R0,[R5, #+116]
   \       0x7E   0x2817             CMP      R0,#+23
   \       0x80   0xD10D             BNE.N    ??mbedtls_ssl_read_8
   5754                      /*
   5755                       * OpenSSL sends empty messages to randomize the IV
   5756                       */
   5757                      if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   \       0x82   0x2101             MOVS     R1,#+1
   \       0x84   0x0028             MOVS     R0,R5
   \       0x86   0x.... 0x....      BL       mbedtls_ssl_read_record
   \       0x8A   0x0004             MOVS     R4,R0
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD006             BEQ.N    ??mbedtls_ssl_read_8
   5758                          if (ret == MBEDTLS_ERR_SSL_CONN_EOF) {
   \       0x90   0xF514 0x4FE5      CMN      R4,#+29312
   \       0x94   0xD101             BNE.N    ??mbedtls_ssl_read_9
   5759                              return 0;
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xE04A             B.N      ??mbedtls_ssl_read_2
   5760                          }
   5761          
   5762                          MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   5763                          return ret;
   \                     ??mbedtls_ssl_read_9: (+1)
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0xE048             B.N      ??mbedtls_ssl_read_2
   5764                      }
   5765                  }
   5766          
   5767                  if (ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE) {
   \                     ??mbedtls_ssl_read_8: (+1)
   \       0x9E   0x6F68             LDR      R0,[R5, #+116]
   \       0xA0   0x2816             CMP      R0,#+22
   \       0xA2   0xD108             BNE.N    ??mbedtls_ssl_read_10
   5768                      ret = ssl_handle_hs_message_post_handshake(ssl);
   \       0xA4   0x0028             MOVS     R0,R5
   \       0xA6   0x.... 0x....      BL       ssl_handle_hs_message_post_handshake
   \       0xAA   0x0004             MOVS     R4,R0
   5769                      if (ret != 0) {
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD001             BEQ.N    ??mbedtls_ssl_read_11
   5770                          MBEDTLS_SSL_DEBUG_RET(1, "ssl_handle_hs_message_post_handshake",
   5771                                                ret);
   5772                          return ret;
   \       0xB0   0x0020             MOVS     R0,R4
   \       0xB2   0xE03D             B.N      ??mbedtls_ssl_read_2
   5773                      }
   5774          
   5775                      /* At this point, we don't know whether the renegotiation triggered
   5776                       * by the post-handshake message has been completed or not. The cases
   5777                       * to consider are the following:
   5778                       * 1) The renegotiation is complete. In this case, no new record
   5779                       *    has been read yet.
   5780                       * 2) The renegotiation is incomplete because the client received
   5781                       *    an application data record while awaiting the ServerHello.
   5782                       * 3) The renegotiation is incomplete because the client received
   5783                       *    a non-handshake, non-application data message while awaiting
   5784                       *    the ServerHello.
   5785                       *
   5786                       * In each of these cases, looping will be the proper action:
   5787                       * - For 1), the next iteration will read a new record and check
   5788                       *   if it's application data.
   5789                       * - For 2), the loop condition isn't satisfied as application data
   5790                       *   is present, hence continue is the same as break
   5791                       * - For 3), the loop condition is satisfied and read_record
   5792                       *   will re-deliver the message that was held back by the client
   5793                       *   when expecting the ServerHello.
   5794                       */
   5795          
   5796                      continue;
   \                     ??mbedtls_ssl_read_11: (+1)
   \       0xB4   0xE7C0             B.N      ??mbedtls_ssl_read_3
   5797                  }
   5798          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5799                  else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING) {
   5800                      if (ssl->conf->renego_max_records >= 0) {
   5801                          if (++ssl->renego_records_seen > ssl->conf->renego_max_records) {
   5802                              MBEDTLS_SSL_DEBUG_MSG(1, ("renegotiation requested, "
   5803                                                        "but not honored by client"));
   5804                              return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   5805                          }
   5806                      }
   5807                  }
   5808          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   5809          
   5810                  /* Fatal and closure alerts handled by mbedtls_ssl_read_record() */
   5811                  if (ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT) {
   \                     ??mbedtls_ssl_read_10: (+1)
   \       0xB6   0x6F68             LDR      R0,[R5, #+116]
   \       0xB8   0x2815             CMP      R0,#+21
   \       0xBA   0xD101             BNE.N    ??mbedtls_ssl_read_12
   5812                      MBEDTLS_SSL_DEBUG_MSG(2, ("ignoring non-fatal non-closure alert"));
   5813                      return MBEDTLS_ERR_SSL_WANT_READ;
   \       0xBC   0x....             LDR.N    R0,??DataTable28_15
   \       0xBE   0xE037             B.N      ??mbedtls_ssl_read_2
   5814                  }
   5815          
   5816                  if (ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA) {
   \                     ??mbedtls_ssl_read_12: (+1)
   \       0xC0   0x6F68             LDR      R0,[R5, #+116]
   \       0xC2   0x2817             CMP      R0,#+23
   \       0xC4   0xD001             BEQ.N    ??mbedtls_ssl_read_13
   5817                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad application data message"));
   5818                      return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   \       0xC6   0x....             LDR.N    R0,??DataTable28_9
   \       0xC8   0xE032             B.N      ??mbedtls_ssl_read_2
   5819                  }
   5820          
   5821                  ssl->in_offt = ssl->in_msg;
   \                     ??mbedtls_ssl_read_13: (+1)
   \       0xCA   0x6EE8             LDR      R0,[R5, #+108]
   \       0xCC   0x6728             STR      R0,[R5, #+112]
   5822          
   5823                  /* We're going to return something now, cancel timer,
   5824                   * except if handshake (renegotiation) is in progress */
   5825                  if (mbedtls_ssl_is_handshake_over(ssl) == 1) {
   \       0xCE   0x0028             MOVS     R0,R5
   \       0xD0   0x.... 0x....      BL       mbedtls_ssl_is_handshake_over
   \       0xD4   0x2801             CMP      R0,#+1
   \       0xD6   0xD1AF             BNE.N    ??mbedtls_ssl_read_3
   5826                      mbedtls_ssl_set_timer(ssl, 0);
   \       0xD8   0x2100             MOVS     R1,#+0
   \       0xDA   0x0028             MOVS     R0,R5
   \       0xDC   0x.... 0x....      BL       mbedtls_ssl_set_timer
   \       0xE0   0xE7AA             B.N      ??mbedtls_ssl_read_3
   5827                  }
   5828          
   5829          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5830                  /* If we requested renego but received AppData, resend HelloRequest.
   5831                   * Do it now, after setting in_offt, to avoid taking this branch
   5832                   * again if ssl_write_hello_request() returns WANT_WRITE */
   5833          #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_RENEGOTIATION)
   5834                  if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   5835                      ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING) {
   5836                      if ((ret = mbedtls_ssl_resend_hello_request(ssl)) != 0) {
   5837                          MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_resend_hello_request",
   5838                                                ret);
   5839                          return ret;
   5840                      }
   5841                  }
   5842          #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_RENEGOTIATION */
   5843          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   5844              }
   5845          
   5846              n = (len < ssl->in_msglen)
   5847                  ? len : ssl->in_msglen;
   \                     ??mbedtls_ssl_read_4: (+1)
   \       0xE2   0x6FA8             LDR      R0,[R5, #+120]
   \       0xE4   0x4286             CMP      R6,R0
   \       0xE6   0xD201             BCS.N    ??mbedtls_ssl_read_14
   \       0xE8   0x46B0             MOV      R8,R6
   \       0xEA   0xE001             B.N      ??mbedtls_ssl_read_15
   \                     ??mbedtls_ssl_read_14: (+1)
   \       0xEC   0xF8D5 0x8078      LDR      R8,[R5, #+120]
   5848          
   5849              if (len != 0) {
   \                     ??mbedtls_ssl_read_15: (+1)
   \       0xF0   0x2E00             CMP      R6,#+0
   \       0xF2   0xD00C             BEQ.N    ??mbedtls_ssl_read_16
   5850                  memcpy(buf, ssl->in_offt, n);
   \       0xF4   0x46C3             MOV      R11,R8
   \       0xF6   0xF8D5 0x9070      LDR      R9,[R5, #+112]
   \       0xFA   0x46BA             MOV      R10,R7
   \       0xFC   0x465A             MOV      R2,R11
   \       0xFE   0x4649             MOV      R1,R9
   \      0x100   0x4650             MOV      R0,R10
   \      0x102   0x.... 0x....      BL       __aeabi_memcpy
   5851                  ssl->in_msglen -= n;
   \      0x106   0x6FA8             LDR      R0,[R5, #+120]
   \      0x108   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x10C   0x67A8             STR      R0,[R5, #+120]
   5852              }
   5853          
   5854              /* Zeroising the plaintext buffer to erase unused application data
   5855                 from the memory. */
   5856              mbedtls_platform_zeroize(ssl->in_offt, n);
   \                     ??mbedtls_ssl_read_16: (+1)
   \      0x10E   0x4641             MOV      R1,R8
   \      0x110   0x6F28             LDR      R0,[R5, #+112]
   \      0x112   0x.... 0x....      BL       mbedtls_platform_zeroize
   5857          
   5858              if (ssl->in_msglen == 0) {
   \      0x116   0x6FA8             LDR      R0,[R5, #+120]
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD105             BNE.N    ??mbedtls_ssl_read_17
   5859                  /* all bytes consumed */
   5860                  ssl->in_offt = NULL;
   \      0x11C   0x2000             MOVS     R0,#+0
   \      0x11E   0x6728             STR      R0,[R5, #+112]
   5861                  ssl->keep_current_message = 0;
   \      0x120   0x2000             MOVS     R0,#+0
   \      0x122   0xF8C5 0x0088      STR      R0,[R5, #+136]
   \      0x126   0xE002             B.N      ??mbedtls_ssl_read_18
   5862              } else {
   5863                  /* more data available */
   5864                  ssl->in_offt += n;
   \                     ??mbedtls_ssl_read_17: (+1)
   \      0x128   0x6F28             LDR      R0,[R5, #+112]
   \      0x12A   0x4440             ADD      R0,R0,R8
   \      0x12C   0x6728             STR      R0,[R5, #+112]
   5865              }
   5866          
   5867              MBEDTLS_SSL_DEBUG_MSG(2, ("<= read"));
   5868          
   5869              return (int) n;
   \                     ??mbedtls_ssl_read_18: (+1)
   \      0x12E   0x4640             MOV      R0,R8
   \                     ??mbedtls_ssl_read_2: (+1)
   \      0x130   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   5870          }
   5871          
   5872          /*
   5873           * Send application data to be encrypted by the SSL layer, taking care of max
   5874           * fragment length and buffer size.
   5875           *
   5876           * According to RFC 5246 Section 6.2.1:
   5877           *
   5878           *      Zero-length fragments of Application data MAY be sent as they are
   5879           *      potentially useful as a traffic analysis countermeasure.
   5880           *
   5881           * Therefore, it is possible that the input message length is 0 and the
   5882           * corresponding return code is 0 on success.
   5883           */
   5884          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   5885          static int ssl_write_real(mbedtls_ssl_context *ssl,
   5886                                    const unsigned char *buf, size_t len)
   5887          {
   \                     ssl_write_real: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0014             MOVS     R4,R2
   5888              int ret = mbedtls_ssl_get_max_out_record_payload(ssl);
   \        0xA   0x4640             MOV      R0,R8
   \        0xC   0x.... 0x....      BL       mbedtls_ssl_get_max_out_record_payload
   \       0x10   0x0006             MOVS     R6,R0
   5889              const size_t max_len = (size_t) ret;
   \       0x12   0x0037             MOVS     R7,R6
   5890          
   5891              if (ret < 0) {
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD501             BPL.N    ??ssl_write_real_0
   5892                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_get_max_out_record_payload", ret);
   5893                  return ret;
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0xE028             B.N      ??ssl_write_real_1
   5894              }
   5895          
   5896              if (len > max_len) {
   \                     ??ssl_write_real_0: (+1)
   \       0x1C   0x42A7             CMP      R7,R4
   \       0x1E   0xD200             BCS.N    ??ssl_write_real_2
   5897          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5898                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5899                      MBEDTLS_SSL_DEBUG_MSG(1, ("fragment larger than the (negotiated) "
   5900                                                "maximum fragment length: %" MBEDTLS_PRINTF_SIZET
   5901                                                " > %" MBEDTLS_PRINTF_SIZET,
   5902                                                len, max_len));
   5903                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   5904                  } else
   5905          #endif
   5906                  len = max_len;
   \       0x20   0x003C             MOVS     R4,R7
   5907              }
   5908          
   5909              if (ssl->out_left != 0) {
   \                     ??ssl_write_real_2: (+1)
   \       0x22   0xF8D8 0x00B4      LDR      R0,[R8, #+180]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD007             BEQ.N    ??ssl_write_real_3
   5910                  /*
   5911                   * The user has previously tried to send the data and
   5912                   * MBEDTLS_ERR_SSL_WANT_WRITE or the message was only partially
   5913                   * written. In this case, we expect the high-level write function
   5914                   * (e.g. mbedtls_ssl_write()) to be called with the same parameters
   5915                   */
   5916                  if ((ret = mbedtls_ssl_flush_output(ssl)) != 0) {
   \       0x2A   0x4640             MOV      R0,R8
   \       0x2C   0x.... 0x....      BL       mbedtls_ssl_flush_output
   \       0x30   0x0001             MOVS     R1,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD01A             BEQ.N    ??ssl_write_real_4
   5917                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_flush_output", ret);
   5918                      return ret;
   \       0x36   0x0008             MOVS     R0,R1
   \       0x38   0xE019             B.N      ??ssl_write_real_1
   5919                  }
   5920              } else {
   5921                  /*
   5922                   * The user is trying to send a message the first time, so we need to
   5923                   * copy the data into the internal buffers and setup the data structure
   5924                   * to keep track of partial writes
   5925                   */
   5926                  ssl->out_msglen  = len;
   \                     ??ssl_write_real_3: (+1)
   \       0x3A   0xF8C8 0x40B0      STR      R4,[R8, #+176]
   5927                  ssl->out_msgtype = MBEDTLS_SSL_MSG_APPLICATION_DATA;
   \       0x3E   0x2017             MOVS     R0,#+23
   \       0x40   0xF8C8 0x00AC      STR      R0,[R8, #+172]
   5928                  if (len > 0) {
   \       0x44   0x2C00             CMP      R4,#+0
   \       0x46   0xD008             BEQ.N    ??ssl_write_real_5
   5929                      memcpy(ssl->out_msg, buf, len);
   \       0x48   0x46A3             MOV      R11,R4
   \       0x4A   0x46A9             MOV      R9,R5
   \       0x4C   0xF8D8 0xA0A8      LDR      R10,[R8, #+168]
   \       0x50   0x465A             MOV      R2,R11
   \       0x52   0x4649             MOV      R1,R9
   \       0x54   0x4650             MOV      R0,R10
   \       0x56   0x.... 0x....      BL       __aeabi_memcpy
   5930                  }
   5931          
   5932                  if ((ret = mbedtls_ssl_write_record(ssl, SSL_FORCE_FLUSH)) != 0) {
   \                     ??ssl_write_real_5: (+1)
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x4640             MOV      R0,R8
   \       0x5E   0x.... 0x....      BL       mbedtls_ssl_write_record
   \       0x62   0x0001             MOVS     R1,R0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD001             BEQ.N    ??ssl_write_real_4
   5933                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_record", ret);
   5934                      return ret;
   \       0x68   0x0008             MOVS     R0,R1
   \       0x6A   0xE000             B.N      ??ssl_write_real_1
   5935                  }
   5936              }
   5937          
   5938              return (int) len;
   \                     ??ssl_write_real_4: (+1)
   \       0x6C   0x0020             MOVS     R0,R4
   \                     ??ssl_write_real_1: (+1)
   \       0x6E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   5939          }
   5940          
   5941          /*
   5942           * Write application data (public-facing wrapper)
   5943           */

   \                                 In section .text, align 2, keep-with-next
   5944          int mbedtls_ssl_write(mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len)
   5945          {
   \                     mbedtls_ssl_write: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   5946              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x076D      MVNS     R7,#+109
   5947          
   5948              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write"));
   5949          
   5950              if (ssl == NULL || ssl->conf == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD002             BEQ.N    ??mbedtls_ssl_write_0
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??mbedtls_ssl_write_1
   5951                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \                     ??mbedtls_ssl_write_0: (+1)
   \       0x16   0x....             LDR.N    R0,??DataTable28_8
   \       0x18   0xE00F             B.N      ??mbedtls_ssl_write_2
   5952              }
   5953          
   5954          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5955              if ((ret = ssl_check_ctr_renegotiate(ssl)) != 0) {
   5956                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_check_ctr_renegotiate", ret);
   5957                  return ret;
   5958              }
   5959          #endif
   5960          
   5961              if (ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER) {
   \                     ??mbedtls_ssl_write_1: (+1)
   \       0x1A   0x6860             LDR      R0,[R4, #+4]
   \       0x1C   0x281B             CMP      R0,#+27
   \       0x1E   0xD007             BEQ.N    ??mbedtls_ssl_write_3
   5962                  if ((ret = mbedtls_ssl_handshake(ssl)) != 0) {
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       mbedtls_ssl_handshake
   \       0x26   0x0007             MOVS     R7,R0
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD001             BEQ.N    ??mbedtls_ssl_write_3
   5963                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_handshake", ret);
   5964                      return ret;
   \       0x2C   0x0038             MOVS     R0,R7
   \       0x2E   0xE004             B.N      ??mbedtls_ssl_write_2
   5965                  }
   5966              }
   5967          
   5968              ret = ssl_write_real(ssl, buf, len);
   \                     ??mbedtls_ssl_write_3: (+1)
   \       0x30   0x0032             MOVS     R2,R6
   \       0x32   0x0029             MOVS     R1,R5
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       ssl_write_real
   5969          
   5970              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write"));
   5971          
   5972              return ret;
   \                     ??mbedtls_ssl_write_2: (+1)
   \       0x3A   0xBDF2             POP      {R1,R4-R7,PC}
   5973          }
   5974          
   5975          /*
   5976           * Notify the peer that the connection is being closed
   5977           */

   \                                 In section .text, align 2, keep-with-next
   5978          int mbedtls_ssl_close_notify(mbedtls_ssl_context *ssl)
   5979          {
   \                     mbedtls_ssl_close_notify: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5980              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x056D      MVNS     R5,#+109
   5981          
   5982              if (ssl == NULL || ssl->conf == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD002             BEQ.N    ??mbedtls_ssl_close_notify_0
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??mbedtls_ssl_close_notify_1
   5983                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \                     ??mbedtls_ssl_close_notify_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable28_8
   \       0x14   0xE00F             B.N      ??mbedtls_ssl_close_notify_2
   5984              }
   5985          
   5986              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write close notify"));
   5987          
   5988              if (mbedtls_ssl_is_handshake_over(ssl) == 1) {
   \                     ??mbedtls_ssl_close_notify_1: (+1)
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_ssl_is_handshake_over
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD109             BNE.N    ??mbedtls_ssl_close_notify_3
   5989                  if ((ret = mbedtls_ssl_send_alert_message(ssl,
   5990                                                            MBEDTLS_SSL_ALERT_LEVEL_WARNING,
   5991                                                            MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY)) != 0) {
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   \       0x2A   0x0005             MOVS     R5,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD001             BEQ.N    ??mbedtls_ssl_close_notify_3
   5992                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_send_alert_message", ret);
   5993                      return ret;
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0xE000             B.N      ??mbedtls_ssl_close_notify_2
   5994                  }
   5995              }
   5996          
   5997              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write close notify"));
   5998          
   5999              return 0;
   \                     ??mbedtls_ssl_close_notify_3: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_close_notify_2: (+1)
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
   6000          }
   6001          

   \                                 In section .text, align 2, keep-with-next
   6002          void mbedtls_ssl_transform_free(mbedtls_ssl_transform *transform)
   6003          {
   \                     mbedtls_ssl_transform_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   6004              if (transform == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD00F             BEQ.N    ??mbedtls_ssl_transform_free_0
   6005                  return;
   6006              }
   6007          
   6008          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   6009              psa_destroy_key(transform->psa_key_enc);
   \                     ??mbedtls_ssl_transform_free_1: (+1)
   \        0x8   0x6C60             LDR      R0,[R4, #+68]
   \        0xA   0x.... 0x....      BL       psa_destroy_key
   6010              psa_destroy_key(transform->psa_key_dec);
   \        0xE   0x6CA0             LDR      R0,[R4, #+72]
   \       0x10   0x.... 0x....      BL       psa_destroy_key
   6011          #else
   6012              mbedtls_cipher_free(&transform->cipher_ctx_enc);
   6013              mbedtls_cipher_free(&transform->cipher_ctx_dec);
   6014          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   6015          
   6016          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
   6017          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   6018              psa_destroy_key(transform->psa_mac_enc);
   \       0x14   0x6B60             LDR      R0,[R4, #+52]
   \       0x16   0x.... 0x....      BL       psa_destroy_key
   6019              psa_destroy_key(transform->psa_mac_dec);
   \       0x1A   0x6BA0             LDR      R0,[R4, #+56]
   \       0x1C   0x.... 0x....      BL       psa_destroy_key
   6020          #else
   6021              mbedtls_md_free(&transform->md_ctx_enc);
   6022              mbedtls_md_free(&transform->md_ctx_dec);
   6023          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   6024          #endif
   6025          
   6026              mbedtls_platform_zeroize(transform, sizeof(mbedtls_ssl_transform));
   \       0x20   0x2150             MOVS     R1,#+80
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       mbedtls_platform_zeroize
   6027          }
   \                     ??mbedtls_ssl_transform_free_0: (+1)
   \       0x28   0xBD10             POP      {R4,PC}
   6028          

   \                                 In section .text, align 2, keep-with-next
   6029          void mbedtls_ssl_set_inbound_transform(mbedtls_ssl_context *ssl,
   6030                                                 mbedtls_ssl_transform *transform)
   6031          {
   \                     mbedtls_ssl_set_inbound_transform: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000C             MOVS     R4,R1
   6032              ssl->transform_in = transform;
   \        0x8   0xF8C8 0x403C      STR      R4,[R8, #+60]
   6033              memset(ssl->in_ctr, 0, MBEDTLS_SSL_SEQUENCE_NUMBER_LEN);
   \        0xC   0x2508             MOVS     R5,#+8
   \        0xE   0x2600             MOVS     R6,#+0
   \       0x10   0xF8D8 0x705C      LDR      R7,[R8, #+92]
   \       0x14   0x0032             MOVS     R2,R6
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0x0038             MOVS     R0,R7
   \       0x1A   0x.... 0x....      BL       __aeabi_memset
   6034          }
   \       0x1E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   6035          

   \                                 In section .text, align 2, keep-with-next
   6036          void mbedtls_ssl_set_outbound_transform(mbedtls_ssl_context *ssl,
   6037                                                  mbedtls_ssl_transform *transform)
   6038          {
   \                     mbedtls_ssl_set_outbound_transform: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000C             MOVS     R4,R1
   6039              ssl->transform_out = transform;
   \        0x8   0xF8C8 0x4040      STR      R4,[R8, #+64]
   6040              memset(ssl->cur_out_ctr, 0, sizeof(ssl->cur_out_ctr));
   \        0xC   0x2508             MOVS     R5,#+8
   \        0xE   0x2600             MOVS     R6,#+0
   \       0x10   0xF118 0x07B8      ADDS     R7,R8,#+184
   \       0x14   0x0032             MOVS     R2,R6
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0x0038             MOVS     R0,R7
   \       0x1A   0x.... 0x....      BL       __aeabi_memset
   6041          }
   \       0x1E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   6042          
   6043          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   6044          
   6045          void mbedtls_ssl_buffering_free(mbedtls_ssl_context *ssl)
   6046          {
   6047              unsigned offset;
   6048              mbedtls_ssl_handshake_params * const hs = ssl->handshake;
   6049          
   6050              if (hs == NULL) {
   6051                  return;
   6052              }
   6053          
   6054              ssl_free_buffered_record(ssl);
   6055          
   6056              for (offset = 0; offset < MBEDTLS_SSL_MAX_BUFFERED_HS; offset++) {
   6057                  ssl_buffering_free_slot(ssl, offset);
   6058              }
   6059          }
   6060          
   6061          static void ssl_buffering_free_slot(mbedtls_ssl_context *ssl,
   6062                                              uint8_t slot)
   6063          {
   6064              mbedtls_ssl_handshake_params * const hs = ssl->handshake;
   6065              mbedtls_ssl_hs_buffer * const hs_buf = &hs->buffering.hs[slot];
   6066          
   6067              if (slot >= MBEDTLS_SSL_MAX_BUFFERED_HS) {
   6068                  return;
   6069              }
   6070          
   6071              if (hs_buf->is_valid == 1) {
   6072                  hs->buffering.total_bytes_buffered -= hs_buf->data_len;
   6073                  mbedtls_zeroize_and_free(hs_buf->data, hs_buf->data_len);
   6074                  memset(hs_buf, 0, sizeof(mbedtls_ssl_hs_buffer));
   6075              }
   6076          }
   6077          
   6078          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   6079          
   6080          /*
   6081           * Convert version numbers to/from wire format
   6082           * and, for DTLS, to/from TLS equivalent.
   6083           *
   6084           * For TLS this is the identity.
   6085           * For DTLS, map as follows, then use 1's complement (v -> ~v):
   6086           * 1.x <-> 3.x+1    for x != 0 (DTLS 1.2 based on TLS 1.2)
   6087           *                  DTLS 1.0 is stored as TLS 1.1 internally
   6088           */

   \                                 In section .text, align 2, keep-with-next
   6089          void mbedtls_ssl_write_version(unsigned char version[2], int transport,
   6090                                         mbedtls_ssl_protocol_version tls_version)
   6091          {
   \                     mbedtls_ssl_write_version: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   6092              uint16_t tls_version_formatted;
   6093          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   6094              if (transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   6095                  tls_version_formatted = (mbedtls_ssl_protocol_version)
   6096                      ~(tls_version - (tls_version == 0x0302 ? 0x0202 : 0x0201));
   6097              } else
   6098          #else
   6099              ((void) transport);
   6100          #endif
   6101              {
   6102                  tls_version_formatted = (uint16_t) tls_version;
   \        0x8   0x0037             MOVS     R7,R6
   \        0xA   0xB2BF             UXTH     R7,R7
   6103              }
   6104              MBEDTLS_PUT_UINT16_BE(tls_version_formatted, version, 0);
   \        0xC   0x....             LDR.N    R0,??DataTable28_4
   \        0xE   0x7800             LDRB     R0,[R0, #+0]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD105             BNE.N    ??mbedtls_ssl_write_version_0
   \       0x14   0x0039             MOVS     R1,R7
   \       0x16   0xB289             UXTH     R1,R1
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x1E   0xE008             B.N      ??mbedtls_ssl_write_version_1
   \                     ??mbedtls_ssl_write_version_0: (+1)
   \       0x20   0x0038             MOVS     R0,R7
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0x.... 0x....      BL       mbedtls_bswap16
   \       0x28   0x0001             MOVS     R1,R0
   \       0x2A   0xB289             UXTH     R1,R1
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   6105          }
   \                     ??mbedtls_ssl_write_version_1: (+1)
   \       0x32   0xBDF1             POP      {R0,R4-R7,PC}
   6106          

   \                                 In section .text, align 2, keep-with-next
   6107          uint16_t mbedtls_ssl_read_version(const unsigned char version[2],
   6108                                            int transport)
   6109          {
   \                     mbedtls_ssl_read_version: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   6110              uint16_t tls_version = MBEDTLS_GET_UINT16_BE(version, 0);
   \        0x6   0x....             LDR.N    R0,??DataTable28_4
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD103             BNE.N    ??mbedtls_ssl_read_version_0
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x14   0xE005             B.N      ??mbedtls_ssl_read_version_1
   \                     ??mbedtls_ssl_read_version_0: (+1)
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0x.... 0x....      BL       mbedtls_bswap16
   6111          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   6112              if (transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   6113                  tls_version =
   6114                      ~(tls_version - (tls_version == 0xfeff ? 0x0202 : 0x0201));
   6115              }
   6116          #else
   6117              ((void) transport);
   6118          #endif
   6119              return tls_version;
   \                     ??mbedtls_ssl_read_version_1: (+1)
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
   6120          }
   6121          
   6122          /*
   6123           * Send pending fatal alert.
   6124           * 0,   No alert message.
   6125           * !0,  if mbedtls_ssl_send_alert_message() returned in error, the error code it
   6126           *      returned, ssl->alert_reason otherwise.
   6127           */

   \                                 In section .text, align 2, keep-with-next
   6128          int mbedtls_ssl_handle_pending_alert(mbedtls_ssl_context *ssl)
   6129          {
   \                     mbedtls_ssl_handle_pending_alert: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   6130              int ret;
   6131          
   6132              /* No pending alert, return success*/
   6133              if (ssl->send_alert == 0) {
   \        0x4   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??mbedtls_ssl_handle_pending_alert_0
   6134                  return 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE012             B.N      ??mbedtls_ssl_handle_pending_alert_1
   6135              }
   6136          
   6137              ret = mbedtls_ssl_send_alert_message(ssl,
   6138                                                   MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   6139                                                   ssl->alert_type);
   \                     ??mbedtls_ssl_handle_pending_alert_0: (+1)
   \       0x10   0xF894 0x208D      LDRB     R2,[R4, #+141]
   \       0x14   0x2102             MOVS     R1,#+2
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   \       0x1C   0x0001             MOVS     R1,R0
   6140          
   6141              /* If mbedtls_ssl_send_alert_message() returned with MBEDTLS_ERR_SSL_WANT_WRITE,
   6142               * do not clear the alert to be able to send it later.
   6143               */
   6144              if (ret != MBEDTLS_ERR_SSL_WANT_WRITE) {
   \       0x1E   0xF511 0x4FD1      CMN      R1,#+26752
   \       0x22   0xD002             BEQ.N    ??mbedtls_ssl_handle_pending_alert_2
   6145                  ssl->send_alert = 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xF884 0x008C      STRB     R0,[R4, #+140]
   6146              }
   6147          
   6148              if (ret != 0) {
   \                     ??mbedtls_ssl_handle_pending_alert_2: (+1)
   \       0x2A   0x2900             CMP      R1,#+0
   \       0x2C   0xD001             BEQ.N    ??mbedtls_ssl_handle_pending_alert_3
   6149                  return ret;
   \       0x2E   0x0008             MOVS     R0,R1
   \       0x30   0xE001             B.N      ??mbedtls_ssl_handle_pending_alert_1
   6150              }
   6151          
   6152              return ssl->alert_reason;
   \                     ??mbedtls_ssl_handle_pending_alert_3: (+1)
   \       0x32   0xF8D4 0x0090      LDR      R0,[R4, #+144]
   \                     ??mbedtls_ssl_handle_pending_alert_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   6153          }
   6154          
   6155          /*
   6156           * Set pending fatal alert flag.
   6157           */

   \                                 In section .text, align 2, keep-with-next
   6158          void mbedtls_ssl_pend_fatal_alert(mbedtls_ssl_context *ssl,
   6159                                            unsigned char alert_type,
   6160                                            int alert_reason)
   6161          {
   6162              ssl->send_alert = 1;
   \                     mbedtls_ssl_pend_fatal_alert: (+1)
   \        0x0   0x2301             MOVS     R3,#+1
   \        0x2   0xF880 0x308C      STRB     R3,[R0, #+140]
   6163              ssl->alert_type = alert_type;
   \        0x6   0xF880 0x108D      STRB     R1,[R0, #+141]
   6164              ssl->alert_reason = alert_reason;
   \        0xA   0xF8C0 0x2090      STR      R2,[R0, #+144]
   6165          }
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     mbedtls_ct_zero

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     psa_generic_status_to_mbedtls

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x....'....        DC32     psa_to_ssl_errors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x0200'0003        DC32     0x2000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x0200'0004        DC32     0x2000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x0200'0005        DC32     0x2000005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x0200'0008        DC32     0x2000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0x0200'0009        DC32     0x2000009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \        0x0   0x0200'000A        DC32     0x200000a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \        0x0   0x0200'000B        DC32     0x200000b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x0200'000C        DC32     0x200000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x0200'000D        DC32     0x200000d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x0200'0010        DC32     0x2000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x0200'0011        DC32     0x2000011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x0200'0012        DC32     0x2000012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x0200'0013        DC32     0x2000013

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0xFFFF'8F80        DC32     0xffff8f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0xFFFF'9900        DC32     0xffff9900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     mbedtls_byte_order_detector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0xFFFF'9400        DC32     0xffff9400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0xFFFF'8F00        DC32     0xffff8f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0xFFFF'9600        DC32     0xffff9600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0xFFFF'8E80        DC32     0xffff8e80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0xFFFF'9800        DC32     0xffff9800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0xFFFF'8D80        DC32     0xffff8d80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0xFFFF'9480        DC32     0xffff9480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \        0x0   0xFFFF'8E00        DC32     0xffff8e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \        0x0   0xFFFF'8F80        DC32     0xffff8f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \        0x0   0xFFFF'9400        DC32     0xffff9400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \        0x0   0x....'....        DC32     mbedtls_byte_order_detector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \        0x0   0xFFFF'8880        DC32     0xffff8880

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \        0x0   0xFFFF'8780        DC32     0xffff8780

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \        0x0   0xFFFF'9980        DC32     0xffff9980

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \        0x0   0xFFFF'8F00        DC32     0xffff8f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \        0x0   0xFFFF'8900        DC32     0xffff8900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \        0x0   0x0550'0200        DC32     0x5500200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \        0x0   0x0550'0100        DC32     0x5500100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_12:
   \        0x0   0x0548'0100        DC32     0x5480100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_13:
   \        0x0   0x0510'0500        DC32     0x5100500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_14:
   \        0x0   0x0440'4000        DC32     0x4404000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_15:
   \        0x0   0xFFFF'9700        DC32     0xffff9700
   6166          
   6167          #endif /* MBEDTLS_SSL_TLS_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   local_err_translation
         8   -> psa_status_to_mbedtls
       0   mbedtls_bswap16
       8   mbedtls_ct_bool
         8   -> mbedtls_ct_compiler_opaque
       0   mbedtls_ct_bool_and
       0   mbedtls_ct_compiler_opaque
     616   mbedtls_ct_hmac
       616   -> __aeabi_memclr4
       616   -> __aeabi_memset
       616   -> local_err_translation
       616   -> mbedtls_ct_memcpy_if
       616   -> mbedtls_ct_uint_eq
       616   -> mbedtls_platform_zeroize
       616   -> psa_export_key
       616   -> psa_hash_abort
       616   -> psa_hash_clone
       616   -> psa_hash_finish
       616   -> psa_hash_setup
       616   -> psa_hash_update
      16   mbedtls_ct_if
        16   -> mbedtls_ct_compiler_opaque
       0   mbedtls_ct_size_if_else_0
      16   mbedtls_ct_uint_eq
        16   -> mbedtls_ct_uint_ne
      16   mbedtls_ct_uint_ge
        16   -> mbedtls_ct_uint_lt
      32   mbedtls_ct_uint_lt
        32   -> mbedtls_ct_bool
        32   -> mbedtls_ct_compiler_opaque
        32   -> mbedtls_ct_if
      24   mbedtls_ct_uint_ne
        24   -> mbedtls_ct_bool
        24   -> mbedtls_ct_compiler_opaque
      24   mbedtls_get_unaligned_uint16
        24   -> __aeabi_memcpy
      24   mbedtls_get_unaligned_uint32
        24   -> __aeabi_memcpy
      24   mbedtls_put_unaligned_uint16
        24   -> __aeabi_memcpy
      24   mbedtls_put_unaligned_uint32
        24   -> __aeabi_memcpy
       0   mbedtls_ssl_check_pending
      24   mbedtls_ssl_check_record
        24   -> mbedtls_platform_zeroize
       8   mbedtls_ssl_check_timer
         8   -- Indirect call
      16   mbedtls_ssl_close_notify
        16   -> mbedtls_ssl_is_handshake_over
        16   -> mbedtls_ssl_send_alert_message
     344   mbedtls_ssl_decrypt_buf
       344   -> __aeabi_memclr4
       344   -> __aeabi_memcpy
       344   -> __aeabi_memset
       344   -> local_err_translation
       344   -> mbedtls_ct_bool_and
       344   -> mbedtls_ct_compiler_opaque
       344   -> mbedtls_ct_hmac
       344   -> mbedtls_ct_memcmp
       344   -> mbedtls_ct_memcpy_offset
       344   -> mbedtls_ct_size_if_else_0
       344   -> mbedtls_ct_uint_eq
       344   -> mbedtls_ct_uint_ge
       344   -> mbedtls_platform_zeroize
       344   -> mbedtls_ssl_get_mode_from_transform
       344   -> psa_aead_decrypt
       344   -> psa_cipher_decrypt_setup
       344   -> psa_cipher_finish
       344   -> psa_cipher_set_iv
       344   -> psa_cipher_update
       344   -> ssl_build_record_nonce
       344   -> ssl_extract_add_data_from_record
       344   -> ssl_transform_aead_dynamic_iv_is_explicit
     664   mbedtls_ssl_encrypt_buf
       664   -- Indirect call
       664   -> __aeabi_memclr4
       664   -> __aeabi_memcpy
       664   -> local_err_translation
       664   -> mbedtls_platform_zeroize
       664   -> mbedtls_ssl_get_mode_from_transform
       664   -> psa_aead_encrypt
       664   -> psa_cipher_encrypt_setup
       664   -> psa_cipher_finish
       664   -> psa_cipher_set_iv
       664   -> psa_cipher_update
       664   -> psa_mac_abort
       664   -> psa_mac_sign_finish
       664   -> psa_mac_sign_setup
       664   -> psa_mac_update
       664   -> ssl_build_record_nonce
       664   -> ssl_extract_add_data_from_record
       664   -> ssl_transform_aead_dynamic_iv_is_explicit
       0   mbedtls_ssl_ep_len
      24   mbedtls_ssl_fetch_input
        24   -- Indirect call
        24   -> mbedtls_ssl_check_timer
      24   mbedtls_ssl_finish_handshake_msg
        24   -> mbedtls_ssl_write_handshake_msg_ext
      16   mbedtls_ssl_flush_output
        16   -- Indirect call
        16   -> mbedtls_ssl_update_out_pointers
       0   mbedtls_ssl_get_bytes_avail
      64   mbedtls_ssl_get_record_expansion
        64   -> __aeabi_memclr4
        64   -> mbedtls_ssl_out_hdr_len
        64   -> psa_get_key_attributes
        64   -> psa_get_key_type
      16   mbedtls_ssl_handle_message_type
        16   -> mbedtls_ssl_prepare_handshake_record
       8   mbedtls_ssl_handle_pending_alert
         8   -> mbedtls_ssl_send_alert_message
       0   mbedtls_ssl_hs_hdr_len
       0   mbedtls_ssl_in_hdr_len
       0   mbedtls_ssl_is_handshake_over
       0   mbedtls_ssl_out_hdr_len
      24   mbedtls_ssl_parse_change_cipher_spec
        24   -> __aeabi_memset
        24   -> mbedtls_ssl_read_record
        24   -> mbedtls_ssl_send_alert_message
        24   -> mbedtls_ssl_update_in_pointers
       0   mbedtls_ssl_pend_fatal_alert
      16   mbedtls_ssl_prepare_handshake_record
        16   -> mbedtls_ssl_hs_hdr_len
        16   -> ssl_get_hs_total_len
      40   mbedtls_ssl_read
        40   -- Indirect call
        40   -> __aeabi_memcpy
        40   -> mbedtls_platform_zeroize
        40   -> mbedtls_ssl_handshake
        40   -> mbedtls_ssl_is_handshake_over
        40   -> mbedtls_ssl_read_record
        40   -> mbedtls_ssl_set_timer
        40   -> ssl_handle_hs_message_post_handshake
      24   mbedtls_ssl_read_record
        24   -> mbedtls_ssl_handle_message_type
        24   -> mbedtls_ssl_update_handshake_status
        24   -> ssl_consume_current_message
        24   -> ssl_get_next_record
        24   -> ssl_record_is_in_progress
      16   mbedtls_ssl_read_version
        16   -> mbedtls_bswap16
        16   -> mbedtls_get_unaligned_uint16
       8   mbedtls_ssl_reset_in_out_pointers
         8   -> mbedtls_ssl_update_in_pointers
         8   -> mbedtls_ssl_update_out_pointers
      24   mbedtls_ssl_send_alert_message
        24   -> mbedtls_ssl_flush_output
        24   -> mbedtls_ssl_write_record
       8   mbedtls_ssl_send_fatal_handshake_failure
         8   -> mbedtls_ssl_send_alert_message
      24   mbedtls_ssl_set_inbound_transform
        24   -> __aeabi_memset
      24   mbedtls_ssl_set_outbound_transform
        24   -> __aeabi_memset
      16   mbedtls_ssl_set_timer
        16   -- Indirect call
       4   mbedtls_ssl_start_handshake_msg
       8   mbedtls_ssl_transform_free
         8   -> mbedtls_platform_zeroize
         8   -> psa_destroy_key
      16   mbedtls_ssl_update_handshake_status
        16   -- Indirect call
        16   -> mbedtls_ssl_is_handshake_over
       0   mbedtls_ssl_update_in_pointers
      16   mbedtls_ssl_update_out_pointers
        16   -> ssl_transform_get_explicit_iv_len
      24   mbedtls_ssl_write
        24   -> mbedtls_ssl_handshake
        24   -> ssl_write_real
      16   mbedtls_ssl_write_change_cipher_spec
        16   -> mbedtls_ssl_write_handshake_msg
       8   mbedtls_ssl_write_handshake_msg
         8   -> mbedtls_ssl_write_handshake_msg_ext
      32   mbedtls_ssl_write_handshake_msg_ext
        32   -- Indirect call
        32   -> mbedtls_ssl_write_record
      88   mbedtls_ssl_write_record
        88   -> __aeabi_memcpy
        88   -> mbedtls_bswap16
        88   -> mbedtls_put_unaligned_uint16
        88   -> mbedtls_ssl_encrypt_buf
        88   -> mbedtls_ssl_ep_len
        88   -> mbedtls_ssl_flush_output
        88   -> mbedtls_ssl_out_hdr_len
        88   -> mbedtls_ssl_update_out_pointers
        88   -> mbedtls_ssl_write_version
      24   mbedtls_ssl_write_version
        24   -> mbedtls_bswap16
        24   -> mbedtls_put_unaligned_uint16
      32   mbedtls_xor
        32   -> mbedtls_get_unaligned_uint32
        32   -> mbedtls_put_unaligned_uint32
       0   psa_get_key_type
      48   ssl_build_record_nonce
        48   -> __aeabi_memcpy
        48   -> __aeabi_memset
        48   -> mbedtls_xor
       0   ssl_check_record_type
      24   ssl_consume_current_message
        24   -> __aeabi_memmove
      48   ssl_extract_add_data_from_record
        48   -> __aeabi_memcpy
        48   -> mbedtls_bswap16
        48   -> mbedtls_put_unaligned_uint16
       0   ssl_get_hs_total_len
      48   ssl_get_next_record
        48   -> mbedtls_bswap16
        48   -> mbedtls_put_unaligned_uint16
        48   -> mbedtls_ssl_fetch_input
        48   -> mbedtls_ssl_in_hdr_len
        48   -> mbedtls_ssl_update_in_pointers
        48   -> ssl_parse_record_header
        48   -> ssl_prepare_record_content
       8   ssl_handle_hs_message_post_handshake
         8   -> ssl_tls12_handle_hs_message_post_handshake
      64   ssl_parse_record_header
        64   -> __aeabi_memcpy
        64   -> mbedtls_ssl_read_version
        64   -> ssl_check_record_type
      32   ssl_prepare_record_content
        32   -> mbedtls_ssl_decrypt_buf
        32   -> mbedtls_ssl_ep_len
       0   ssl_record_is_in_progress
      16   ssl_tls12_handle_hs_message_post_handshake
        16   -> mbedtls_ssl_hs_hdr_len
        16   -> mbedtls_ssl_send_alert_message
       0   ssl_transform_aead_dynamic_iv_is_explicit
       0   ssl_transform_get_explicit_iv_len
      40   ssl_write_real
        40   -> __aeabi_memcpy
        40   -> mbedtls_ssl_flush_output
        40   -> mbedtls_ssl_get_max_out_record_payload
        40   -> mbedtls_ssl_write_record


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable17
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_13
       4  ??DataTable28_14
       4  ??DataTable28_15
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
     224  ?_0
     224  ?_1
     356  ?_2
     152  ?_3
     152  ?_4
      36  ?_5
      22  local_err_translation
      16  mbedtls_bswap16
       2  mbedtls_byte_order_detector
      28  mbedtls_ct_bool
       4  mbedtls_ct_bool_and
      10  mbedtls_ct_compiler_opaque
   1'010  mbedtls_ct_hmac
      26  mbedtls_ct_if
       4  mbedtls_ct_size_if_else_0
      18  mbedtls_ct_uint_eq
      18  mbedtls_ct_uint_ge
      62  mbedtls_ct_uint_lt
      32  mbedtls_ct_uint_ne
      26  mbedtls_get_unaligned_uint16
      24  mbedtls_get_unaligned_uint32
      22  mbedtls_put_unaligned_uint16
      22  mbedtls_put_unaligned_uint32
      50  mbedtls_ssl_check_pending
      54  mbedtls_ssl_check_record
      34  mbedtls_ssl_check_timer
      56  mbedtls_ssl_close_notify
   1'102  mbedtls_ssl_decrypt_buf
     980  mbedtls_ssl_encrypt_buf
       6  mbedtls_ssl_ep_len
     170  mbedtls_ssl_fetch_input
      38  mbedtls_ssl_finish_handshake_msg
     124  mbedtls_ssl_flush_output
      14  mbedtls_ssl_get_bytes_avail
     182  mbedtls_ssl_get_record_expansion
     146  mbedtls_ssl_handle_message_type
      56  mbedtls_ssl_handle_pending_alert
       6  mbedtls_ssl_hs_hdr_len
       6  mbedtls_ssl_in_hdr_len
      16  mbedtls_ssl_is_handshake_over
      14  mbedtls_ssl_out_hdr_len
      94  mbedtls_ssl_parse_change_cipher_spec
      16  mbedtls_ssl_pend_fatal_alert
      62  mbedtls_ssl_prepare_handshake_record
     308  mbedtls_ssl_read
     136  mbedtls_ssl_read_record
      38  mbedtls_ssl_read_version
      44  mbedtls_ssl_reset_in_out_pointers
      90  mbedtls_ssl_send_alert_message
      16  mbedtls_ssl_send_fatal_handshake_failure
      34  mbedtls_ssl_set_inbound_transform
      34  mbedtls_ssl_set_outbound_transform
      26  mbedtls_ssl_set_timer
      36  mbedtls_ssl_start_handshake_msg
      42  mbedtls_ssl_transform_free
      52  mbedtls_ssl_update_handshake_status
      24  mbedtls_ssl_update_in_pointers
      56  mbedtls_ssl_update_out_pointers
      60  mbedtls_ssl_write
      54  mbedtls_ssl_write_change_cipher_spec
      16  mbedtls_ssl_write_handshake_msg
     190  mbedtls_ssl_write_handshake_msg_ext
     468  mbedtls_ssl_write_record
      52  mbedtls_ssl_write_version
      92  mbedtls_xor
       4  psa_get_key_type
      74  ssl_build_record_nonce
      44  ssl_check_record_type
     100  ssl_consume_current_message
     126  ssl_extract_add_data_from_record
      24  ssl_get_hs_total_len
     180  ssl_get_next_record
      26  ssl_handle_hs_message_post_handshake
     208  ssl_parse_record_header
     198  ssl_prepare_record_content
      16  ssl_record_is_in_progress
      68  ssl_tls12_handle_hs_message_post_handshake
      18  ssl_transform_aead_dynamic_iv_is_explicit
      10  ssl_transform_get_explicit_iv_len
     114  ssl_write_real

 
 1'146 bytes in section .rodata
 7'812 bytes in section .text
 
 7'626 bytes of CODE  memory (+ 186 bytes shared)
 1'146 bytes of CONST memory

Errors: none
Warnings: 1
