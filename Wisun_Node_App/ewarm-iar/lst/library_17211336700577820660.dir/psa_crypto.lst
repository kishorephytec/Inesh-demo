###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:53
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\psa_crypto.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\psa_crypto.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\psa_crypto.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\psa_crypto.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\psa_crypto.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\psa_crypto.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\psa_crypto.c
      1          /*
      2           *  PSA crypto layer on top of Mbed TLS crypto
      3           */
      4          /*
      5           *  Copyright The Mbed TLS Contributors
      6           *  SPDX-License-Identifier: Apache-2.0
      7           *
      8           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      9           *  not use this file except in compliance with the License.
     10           *  You may obtain a copy of the License at
     11           *
     12           *  http://www.apache.org/licenses/LICENSE-2.0
     13           *
     14           *  Unless required by applicable law or agreed to in writing, software
     15           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     16           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     17           *  See the License for the specific language governing permissions and
     18           *  limitations under the License.
     19           */
     20          
     21          #include "common.h"
     22          #include "psa_crypto_core_common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp unsigned char *psa_crypto_buffer_offset(unsigned char *, size_t)
   \                     psa_crypto_buffer_offset: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??psa_crypto_buffer_offset_0
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xE000             B.N      ??psa_crypto_buffer_offset_1
   \                     ??psa_crypto_buffer_offset_0: (+1)
   \        0x8   0x4408             ADD      R0,R0,R1
   \                     ??psa_crypto_buffer_offset_1: (+1)
   \        0xA   0x4770             BX       LR
     23          
     24          #if defined(MBEDTLS_PSA_CRYPTO_C)
     25          
     26          #if defined(MBEDTLS_PSA_CRYPTO_CONFIG)
     27          #include "check_crypto_config.h"
     28          #endif
     29          
     30          #include "psa/crypto.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_svc_key_id_is_null(uint32_t)
   \                     mbedtls_svc_key_id_is_null: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??mbedtls_svc_key_id_is_null_0
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0xE000             B.N      ??mbedtls_svc_key_id_is_null_1
   \                     ??mbedtls_svc_key_id_is_null_0: (+1)
   \        0x8   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_svc_key_id_is_null_1: (+1)
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t psa_get_key_id(psa_key_attributes_t const *)
   \                     psa_get_key_id: (+1)
   \        0x0   0x6880             LDR      R0,[R0, #+8]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t psa_get_key_lifetime(psa_key_attributes_t const *)
   \                     psa_get_key_lifetime: (+1)
   \        0x0   0x6840             LDR      R0,[R0, #+4]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_extend_key_usage_flags(uint32_t *)
   \                     psa_extend_key_usage_flags: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x04C9             LSLS     R1,R1,#+19
   \        0x4   0xD503             BPL.N    ??psa_extend_key_usage_flags_0
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0xF451 0x6180      ORRS     R1,R1,#0x400
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \                     ??psa_extend_key_usage_flags_0: (+1)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x0489             LSLS     R1,R1,#+18
   \       0x12   0xD503             BPL.N    ??psa_extend_key_usage_flags_1
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF451 0x6100      ORRS     R1,R1,#0x800
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   \                     ??psa_extend_key_usage_flags_1: (+1)
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_usage_flags(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_usage_flags: (+1)
   \        0x0   0xB513             PUSH     {R0,R1,R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0xA801             ADD      R0,SP,#+4
   \        0x6   0x.... 0x....      BL       psa_extend_key_usage_flags
   \        0xA   0x9801             LDR      R0,[SP, #+4]
   \        0xC   0x60E0             STR      R0,[R4, #+12]
   \        0xE   0xBD13             POP      {R0,R1,R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_type(psa_key_attributes_t *, uint16_t)
   \                     psa_set_key_type: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x69E8             LDR      R0,[R5, #+28]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??psa_set_key_type_0
   \        0xC   0x802C             STRH     R4,[R5, #+0]
   \        0xE   0xE006             B.N      ??psa_set_key_type_1
   \                     ??psa_set_key_type_0: (+1)
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x0021             MOVS     R1,R4
   \       0x16   0xB289             UXTH     R1,R1
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       psa_set_key_domain_parameters
   \                     ??psa_set_key_type_1: (+1)
   \       0x1E   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t psa_get_key_type(psa_key_attributes_t const *)
   \                     psa_get_key_type: (+1)
   \        0x0   0x8800             LDRH     R0,[R0, #+0]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_bits(psa_key_attributes_t *, size_t)
   \                     psa_set_key_bits: (+1)
   \        0x0   0xF64F 0x72F9      MOVW     R2,#+65529
   \        0x4   0x4291             CMP      R1,R2
   \        0x6   0xD303             BCC.N    ??psa_set_key_bits_0
   \        0x8   0xF64F 0x72FF      MOVW     R2,#+65535
   \        0xC   0x8042             STRH     R2,[R0, #+2]
   \        0xE   0xE000             B.N      ??psa_set_key_bits_1
   \                     ??psa_set_key_bits_0: (+1)
   \       0x10   0x8041             STRH     R1,[R0, #+2]
   \                     ??psa_set_key_bits_1: (+1)
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t psa_get_key_bits(psa_key_attributes_t const *)
   \                     psa_get_key_bits: (+1)
   \        0x0   0x8840             LDRH     R0,[R0, #+2]
   \        0x2   0x4770             BX       LR
     31          #include "psa/crypto_values.h"
     32          
     33          #include "psa_crypto_cipher.h"
     34          #include "psa_crypto_core.h"
     35          #include "psa_crypto_invasive.h"
     36          #include "psa_crypto_driver_wrappers.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_init(void)
   \                     psa_driver_wrapper_init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xF07F 0x0596      MVNS     R5,#+150
   \        0x6   0x.... 0x....      BL       sli_se_transparent_driver_init
   \        0xA   0x0004             MOVS     R4,R0
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD001             BEQ.N    ??psa_driver_wrapper_init_0
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0xE007             B.N      ??psa_driver_wrapper_init_1
   \                     ??psa_driver_wrapper_init_0: (+1)
   \       0x14   0x.... 0x....      BL       sli_se_opaque_driver_init
   \       0x18   0x0001             MOVS     R1,R0
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD001             BEQ.N    ??psa_driver_wrapper_init_2
   \       0x1E   0x0008             MOVS     R0,R1
   \       0x20   0xE000             B.N      ??psa_driver_wrapper_init_1
   \                     ??psa_driver_wrapper_init_2: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \                     ??psa_driver_wrapper_init_1: (+1)
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_driver_wrapper_free(void)
   \                     psa_driver_wrapper_free: (+1)
   \        0x0   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_sign_message(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_sign_message: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x001C             MOVS     R4,R3
   \        0xA   0x9D12             LDR      R5,[SP, #+72]
   \        0xC   0x9E13             LDR      R6,[SP, #+76]
   \        0xE   0x9F14             LDR      R7,[SP, #+80]
   \       0x10   0xF8DD 0x8054      LDR      R8,[SP, #+84]
   \       0x14   0xF8DD 0x9058      LDR      R9,[SP, #+88]
   \       0x18   0xF07F 0x0A96      MVNS     R10,#+150
   \       0x1C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \       0x20   0x0A00             LSRS     R0,R0,#+8
   \       0x22   0x9005             STR      R0,[SP, #+20]
   \       0x24   0x9805             LDR      R0,[SP, #+20]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ.N    ??psa_driver_wrapper_sign_message_0
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD014             BEQ.N    ??psa_driver_wrapper_sign_message_1
   \       0x2E   0xE021             B.N      ??psa_driver_wrapper_sign_message_2
   \                     ??psa_driver_wrapper_sign_message_0: (+1)
   \       0x30   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x34   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x38   0x9702             STR      R7,[SP, #+8]
   \       0x3A   0x9601             STR      R6,[SP, #+4]
   \       0x3C   0x9500             STR      R5,[SP, #+0]
   \       0x3E   0x0023             MOVS     R3,R4
   \       0x40   0x9A08             LDR      R2,[SP, #+32]
   \       0x42   0x9907             LDR      R1,[SP, #+28]
   \       0x44   0x4658             MOV      R0,R11
   \       0x46   0x.... 0x....      BL       sli_se_transparent_sign_message
   \       0x4A   0x4682             MOV      R10,R0
   \       0x4C   0xF11A 0x0F86      CMN      R10,#+134
   \       0x50   0xD001             BEQ.N    ??psa_driver_wrapper_sign_message_3
   \       0x52   0x4650             MOV      R0,R10
   \       0x54   0xE01B             B.N      ??psa_driver_wrapper_sign_message_4
   \                     ??psa_driver_wrapper_sign_message_3: (+1)
   \       0x56   0xE00D             B.N      ??psa_driver_wrapper_sign_message_5
   \                     ??psa_driver_wrapper_sign_message_1: (+1)
   \       0x58   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x5C   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x60   0x9702             STR      R7,[SP, #+8]
   \       0x62   0x9601             STR      R6,[SP, #+4]
   \       0x64   0x9500             STR      R5,[SP, #+0]
   \       0x66   0x0023             MOVS     R3,R4
   \       0x68   0x9A08             LDR      R2,[SP, #+32]
   \       0x6A   0x9907             LDR      R1,[SP, #+28]
   \       0x6C   0x4658             MOV      R0,R11
   \       0x6E   0x.... 0x....      BL       sli_se_opaque_sign_message
   \       0x72   0xE00C             B.N      ??psa_driver_wrapper_sign_message_4
   \                     ??psa_driver_wrapper_sign_message_2: (+1)
   \                     ??psa_driver_wrapper_sign_message_5: (+1)
   \       0x74   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x78   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x7C   0x9702             STR      R7,[SP, #+8]
   \       0x7E   0x9601             STR      R6,[SP, #+4]
   \       0x80   0x9500             STR      R5,[SP, #+0]
   \       0x82   0x0023             MOVS     R3,R4
   \       0x84   0x9A08             LDR      R2,[SP, #+32]
   \       0x86   0x9907             LDR      R1,[SP, #+28]
   \       0x88   0x4658             MOV      R0,R11
   \       0x8A   0x.... 0x....      BL       psa_sign_message_builtin
   \                     ??psa_driver_wrapper_sign_message_4: (+1)
   \       0x8E   0xB009             ADD      SP,SP,#+36
   \       0x90   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_verify_message(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t const *, size_t)
   \                     psa_driver_wrapper_verify_message: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
   \        0xC   0x9E10             LDR      R6,[SP, #+64]
   \        0xE   0x9F11             LDR      R7,[SP, #+68]
   \       0x10   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \       0x14   0xF8DD 0x904C      LDR      R9,[SP, #+76]
   \       0x18   0xF07F 0x0A96      MVNS     R10,#+150
   \       0x1C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \       0x20   0x0A00             LSRS     R0,R0,#+8
   \       0x22   0x9004             STR      R0,[SP, #+16]
   \       0x24   0x9804             LDR      R0,[SP, #+16]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ.N    ??psa_driver_wrapper_verify_message_0
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD013             BEQ.N    ??psa_driver_wrapper_verify_message_1
   \       0x2E   0xE01F             B.N      ??psa_driver_wrapper_verify_message_2
   \                     ??psa_driver_wrapper_verify_message_0: (+1)
   \       0x30   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x34   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x38   0x9701             STR      R7,[SP, #+4]
   \       0x3A   0x9600             STR      R6,[SP, #+0]
   \       0x3C   0x002B             MOVS     R3,R5
   \       0x3E   0x0022             MOVS     R2,R4
   \       0x40   0x9906             LDR      R1,[SP, #+24]
   \       0x42   0x4658             MOV      R0,R11
   \       0x44   0x.... 0x....      BL       sli_se_transparent_verify_message
   \       0x48   0x4682             MOV      R10,R0
   \       0x4A   0xF11A 0x0F86      CMN      R10,#+134
   \       0x4E   0xD001             BEQ.N    ??psa_driver_wrapper_verify_message_3
   \       0x50   0x4650             MOV      R0,R10
   \       0x52   0xE019             B.N      ??psa_driver_wrapper_verify_message_4
   \                     ??psa_driver_wrapper_verify_message_3: (+1)
   \       0x54   0xE00C             B.N      ??psa_driver_wrapper_verify_message_5
   \                     ??psa_driver_wrapper_verify_message_1: (+1)
   \       0x56   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x5A   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x5E   0x9701             STR      R7,[SP, #+4]
   \       0x60   0x9600             STR      R6,[SP, #+0]
   \       0x62   0x002B             MOVS     R3,R5
   \       0x64   0x0022             MOVS     R2,R4
   \       0x66   0x9906             LDR      R1,[SP, #+24]
   \       0x68   0x4658             MOV      R0,R11
   \       0x6A   0x.... 0x....      BL       sli_se_opaque_verify_message
   \       0x6E   0xE00B             B.N      ??psa_driver_wrapper_verify_message_4
   \                     ??psa_driver_wrapper_verify_message_2: (+1)
   \                     ??psa_driver_wrapper_verify_message_5: (+1)
   \       0x70   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x74   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x78   0x9701             STR      R7,[SP, #+4]
   \       0x7A   0x9600             STR      R6,[SP, #+0]
   \       0x7C   0x002B             MOVS     R3,R5
   \       0x7E   0x0022             MOVS     R2,R4
   \       0x80   0x9906             LDR      R1,[SP, #+24]
   \       0x82   0x4658             MOV      R0,R11
   \       0x84   0x.... 0x....      BL       psa_verify_message_builtin
   \                     ??psa_driver_wrapper_verify_message_4: (+1)
   \       0x88   0xB007             ADD      SP,SP,#+28
   \       0x8A   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_sign_hash(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_sign_hash: (+1)
   \        0x0   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x001C             MOVS     R4,R3
   \        0xA   0x9D12             LDR      R5,[SP, #+72]
   \        0xC   0x9E13             LDR      R6,[SP, #+76]
   \        0xE   0x9F14             LDR      R7,[SP, #+80]
   \       0x10   0xF8DD 0x8054      LDR      R8,[SP, #+84]
   \       0x14   0xF8DD 0x9058      LDR      R9,[SP, #+88]
   \       0x18   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1C   0x9006             STR      R0,[SP, #+24]
   \       0x1E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x22   0x0A00             LSRS     R0,R0,#+8
   \       0x24   0x9005             STR      R0,[SP, #+20]
   \       0x26   0x9805             LDR      R0,[SP, #+20]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??psa_driver_wrapper_sign_hash_0
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD021             BEQ.N    ??psa_driver_wrapper_sign_hash_1
   \       0x30   0xE02E             B.N      ??psa_driver_wrapper_sign_hash_2
   \                     ??psa_driver_wrapper_sign_hash_0: (+1)
   \       0x32   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x36   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x3A   0x9702             STR      R7,[SP, #+8]
   \       0x3C   0x9601             STR      R6,[SP, #+4]
   \       0x3E   0x9500             STR      R5,[SP, #+0]
   \       0x40   0x0023             MOVS     R3,R4
   \       0x42   0x9A08             LDR      R2,[SP, #+32]
   \       0x44   0x9907             LDR      R1,[SP, #+28]
   \       0x46   0x4650             MOV      R0,R10
   \       0x48   0x.... 0x....      BL       sli_se_transparent_sign_hash
   \       0x4C   0x4683             MOV      R11,R0
   \       0x4E   0xF11B 0x0F86      CMN      R11,#+134
   \       0x52   0xD001             BEQ.N    ??psa_driver_wrapper_sign_hash_3
   \       0x54   0x4658             MOV      R0,R11
   \       0x56   0xE01D             B.N      ??psa_driver_wrapper_sign_hash_4
   \                     ??psa_driver_wrapper_sign_hash_3: (+1)
   \       0x58   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x5C   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x60   0x9702             STR      R7,[SP, #+8]
   \       0x62   0x9601             STR      R6,[SP, #+4]
   \       0x64   0x9500             STR      R5,[SP, #+0]
   \       0x66   0x0023             MOVS     R3,R4
   \       0x68   0x9A08             LDR      R2,[SP, #+32]
   \       0x6A   0x9907             LDR      R1,[SP, #+28]
   \       0x6C   0x4650             MOV      R0,R10
   \       0x6E   0x.... 0x....      BL       psa_sign_hash_builtin
   \       0x72   0xE00F             B.N      ??psa_driver_wrapper_sign_hash_4
   \                     ??psa_driver_wrapper_sign_hash_1: (+1)
   \       0x74   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x78   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x7C   0x9702             STR      R7,[SP, #+8]
   \       0x7E   0x9601             STR      R6,[SP, #+4]
   \       0x80   0x9500             STR      R5,[SP, #+0]
   \       0x82   0x0023             MOVS     R3,R4
   \       0x84   0x9A08             LDR      R2,[SP, #+32]
   \       0x86   0x9907             LDR      R1,[SP, #+28]
   \       0x88   0x4650             MOV      R0,R10
   \       0x8A   0x.... 0x....      BL       sli_se_opaque_sign_hash
   \       0x8E   0xE001             B.N      ??psa_driver_wrapper_sign_hash_4
   \                     ??psa_driver_wrapper_sign_hash_2: (+1)
   \       0x90   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_sign_hash_4: (+1)
   \       0x94   0xB009             ADD      SP,SP,#+36
   \       0x96   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_verify_hash(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t const *, size_t)
   \                     psa_driver_wrapper_verify_hash: (+1)
   \        0x0   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
   \        0xC   0x9E10             LDR      R6,[SP, #+64]
   \        0xE   0x9F11             LDR      R7,[SP, #+68]
   \       0x10   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \       0x14   0xF8DD 0x904C      LDR      R9,[SP, #+76]
   \       0x18   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1C   0x9005             STR      R0,[SP, #+20]
   \       0x1E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x22   0x0A00             LSRS     R0,R0,#+8
   \       0x24   0x9004             STR      R0,[SP, #+16]
   \       0x26   0x9804             LDR      R0,[SP, #+16]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??psa_driver_wrapper_verify_hash_0
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD01F             BEQ.N    ??psa_driver_wrapper_verify_hash_1
   \       0x30   0xE02B             B.N      ??psa_driver_wrapper_verify_hash_2
   \                     ??psa_driver_wrapper_verify_hash_0: (+1)
   \       0x32   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x36   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x3A   0x9701             STR      R7,[SP, #+4]
   \       0x3C   0x9600             STR      R6,[SP, #+0]
   \       0x3E   0x002B             MOVS     R3,R5
   \       0x40   0x0022             MOVS     R2,R4
   \       0x42   0x9906             LDR      R1,[SP, #+24]
   \       0x44   0x4650             MOV      R0,R10
   \       0x46   0x.... 0x....      BL       sli_se_transparent_verify_hash
   \       0x4A   0x4683             MOV      R11,R0
   \       0x4C   0xF11B 0x0F86      CMN      R11,#+134
   \       0x50   0xD001             BEQ.N    ??psa_driver_wrapper_verify_hash_3
   \       0x52   0x4658             MOV      R0,R11
   \       0x54   0xE01B             B.N      ??psa_driver_wrapper_verify_hash_4
   \                     ??psa_driver_wrapper_verify_hash_3: (+1)
   \       0x56   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x5A   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x5E   0x9701             STR      R7,[SP, #+4]
   \       0x60   0x9600             STR      R6,[SP, #+0]
   \       0x62   0x002B             MOVS     R3,R5
   \       0x64   0x0022             MOVS     R2,R4
   \       0x66   0x9906             LDR      R1,[SP, #+24]
   \       0x68   0x4650             MOV      R0,R10
   \       0x6A   0x.... 0x....      BL       psa_verify_hash_builtin
   \       0x6E   0xE00E             B.N      ??psa_driver_wrapper_verify_hash_4
   \                     ??psa_driver_wrapper_verify_hash_1: (+1)
   \       0x70   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x74   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x78   0x9701             STR      R7,[SP, #+4]
   \       0x7A   0x9600             STR      R6,[SP, #+0]
   \       0x7C   0x002B             MOVS     R3,R5
   \       0x7E   0x0022             MOVS     R2,R4
   \       0x80   0x9906             LDR      R1,[SP, #+24]
   \       0x82   0x4650             MOV      R0,R10
   \       0x84   0x.... 0x....      BL       sli_se_opaque_verify_hash
   \       0x88   0xE001             B.N      ??psa_driver_wrapper_verify_hash_4
   \                     ??psa_driver_wrapper_verify_hash_2: (+1)
   \       0x8A   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_verify_hash_4: (+1)
   \       0x8E   0xB007             ADD      SP,SP,#+28
   \       0x90   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t psa_driver_wrapper_sign_hash_get_num_ops(psa_sign_hash_interruptible_operation_t *)
   \                     psa_driver_wrapper_sign_hash_get_num_ops: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD002             BEQ.N    ??psa_driver_wrapper_sign_hash_get_num_ops_0
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD002             BEQ.N    ??psa_driver_wrapper_sign_hash_get_num_ops_1
   \        0xE   0xE005             B.N      ??psa_driver_wrapper_sign_hash_get_num_ops_2
   \                     ??psa_driver_wrapper_sign_hash_get_num_ops_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE004             B.N      ??psa_driver_wrapper_sign_hash_get_num_ops_3
   \                     ??psa_driver_wrapper_sign_hash_get_num_ops_1: (+1)
   \       0x14   0x1D20             ADDS     R0,R4,#+4
   \       0x16   0x.... 0x....      BL       mbedtls_psa_sign_hash_get_num_ops
   \       0x1A   0xE000             B.N      ??psa_driver_wrapper_sign_hash_get_num_ops_3
   \                     ??psa_driver_wrapper_sign_hash_get_num_ops_2: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??psa_driver_wrapper_sign_hash_get_num_ops_3: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t psa_driver_wrapper_verify_hash_get_num_ops(psa_verify_hash_interruptible_operation_t *)
   \                     psa_driver_wrapper_verify_hash_get_num_ops: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD002             BEQ.N    ??psa_driver_wrapper_verify_hash_get_num_ops_0
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD002             BEQ.N    ??psa_driver_wrapper_verify_hash_get_num_ops_1
   \        0xE   0xE005             B.N      ??psa_driver_wrapper_verify_hash_get_num_ops_2
   \                     ??psa_driver_wrapper_verify_hash_get_num_ops_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE004             B.N      ??psa_driver_wrapper_verify_hash_get_num_ops_3
   \                     ??psa_driver_wrapper_verify_hash_get_num_ops_1: (+1)
   \       0x14   0x1D20             ADDS     R0,R4,#+4
   \       0x16   0x.... 0x....      BL       mbedtls_psa_verify_hash_get_num_ops
   \       0x1A   0xE000             B.N      ??psa_driver_wrapper_verify_hash_get_num_ops_3
   \                     ??psa_driver_wrapper_verify_hash_get_num_ops_2: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??psa_driver_wrapper_verify_hash_get_num_ops_3: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_sign_hash_start(psa_sign_hash_interruptible_operation_t *, psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t)
   \                     psa_driver_wrapper_sign_hash_start: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0x6874             LDR      R4,[R6, #+4]
   \        0xE   0x0A24             LSRS     R4,R4,#+8
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD10E             BNE.N    ??psa_driver_wrapper_sign_hash_start_0
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x6028             STR      R0,[R5, #+0]
   \       0x18   0x980C             LDR      R0,[SP, #+48]
   \       0x1A   0x9002             STR      R0,[SP, #+8]
   \       0x1C   0x980B             LDR      R0,[SP, #+44]
   \       0x1E   0x9001             STR      R0,[SP, #+4]
   \       0x20   0x980A             LDR      R0,[SP, #+40]
   \       0x22   0x9000             STR      R0,[SP, #+0]
   \       0x24   0x4643             MOV      R3,R8
   \       0x26   0x003A             MOVS     R2,R7
   \       0x28   0x0031             MOVS     R1,R6
   \       0x2A   0x1D28             ADDS     R0,R5,#+4
   \       0x2C   0x.... 0x....      BL       mbedtls_psa_sign_hash_start
   \       0x30   0xE001             B.N      ??psa_driver_wrapper_sign_hash_start_1
   \                     ??psa_driver_wrapper_sign_hash_start_0: (+1)
   \       0x32   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_sign_hash_start_1: (+1)
   \       0x36   0xB004             ADD      SP,SP,#+16
   \       0x38   0xE8BD 0x81F0      POP      {R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_sign_hash_complete(psa_sign_hash_interruptible_operation_t *, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_sign_hash_complete: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD106             BNE.N    ??psa_driver_wrapper_sign_hash_complete_0
   \       0x10   0x003B             MOVS     R3,R7
   \       0x12   0x0032             MOVS     R2,R6
   \       0x14   0x0029             MOVS     R1,R5
   \       0x16   0x1D20             ADDS     R0,R4,#+4
   \       0x18   0x.... 0x....      BL       mbedtls_psa_sign_hash_complete
   \       0x1C   0xE001             B.N      ??psa_driver_wrapper_sign_hash_complete_1
   \                     ??psa_driver_wrapper_sign_hash_complete_0: (+1)
   \       0x1E   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_sign_hash_complete_1: (+1)
   \       0x22   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_sign_hash_abort(psa_sign_hash_interruptible_operation_t *)
   \                     psa_driver_wrapper_sign_hash_abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD103             BNE.N    ??psa_driver_wrapper_sign_hash_abort_0
   \        0xA   0x1D20             ADDS     R0,R4,#+4
   \        0xC   0x.... 0x....      BL       mbedtls_psa_sign_hash_abort
   \       0x10   0xE001             B.N      ??psa_driver_wrapper_sign_hash_abort_1
   \                     ??psa_driver_wrapper_sign_hash_abort_0: (+1)
   \       0x12   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_sign_hash_abort_1: (+1)
   \       0x16   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_verify_hash_start(psa_verify_hash_interruptible_operation_t *, psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t const *, size_t)
   \                     psa_driver_wrapper_verify_hash_start: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0x6874             LDR      R4,[R6, #+4]
   \       0x10   0x0A24             LSRS     R4,R4,#+8
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD112             BNE.N    ??psa_driver_wrapper_verify_hash_start_0
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x6028             STR      R0,[R5, #+0]
   \       0x1A   0x9810             LDR      R0,[SP, #+64]
   \       0x1C   0x9004             STR      R0,[SP, #+16]
   \       0x1E   0x980F             LDR      R0,[SP, #+60]
   \       0x20   0x9003             STR      R0,[SP, #+12]
   \       0x22   0x980E             LDR      R0,[SP, #+56]
   \       0x24   0x9002             STR      R0,[SP, #+8]
   \       0x26   0x980D             LDR      R0,[SP, #+52]
   \       0x28   0x9001             STR      R0,[SP, #+4]
   \       0x2A   0x980C             LDR      R0,[SP, #+48]
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \       0x2E   0x4643             MOV      R3,R8
   \       0x30   0x003A             MOVS     R2,R7
   \       0x32   0x0031             MOVS     R1,R6
   \       0x34   0x1D28             ADDS     R0,R5,#+4
   \       0x36   0x.... 0x....      BL       mbedtls_psa_verify_hash_start
   \       0x3A   0xE001             B.N      ??psa_driver_wrapper_verify_hash_start_1
   \                     ??psa_driver_wrapper_verify_hash_start_0: (+1)
   \       0x3C   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_verify_hash_start_1: (+1)
   \       0x40   0xB006             ADD      SP,SP,#+24
   \       0x42   0xE8BD 0x81F0      POP      {R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_verify_hash_complete(psa_verify_hash_interruptible_operation_t *)
   \                     psa_driver_wrapper_verify_hash_complete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD103             BNE.N    ??psa_driver_wrapper_verify_hash_complete_0
   \        0xA   0x1D20             ADDS     R0,R4,#+4
   \        0xC   0x.... 0x....      BL       mbedtls_psa_verify_hash_complete
   \       0x10   0xE001             B.N      ??psa_driver_wrapper_verify_hash_complete_1
   \                     ??psa_driver_wrapper_verify_hash_complete_0: (+1)
   \       0x12   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_verify_hash_complete_1: (+1)
   \       0x16   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_verify_hash_abort(psa_verify_hash_interruptible_operation_t *)
   \                     psa_driver_wrapper_verify_hash_abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD103             BNE.N    ??psa_driver_wrapper_verify_hash_abort_0
   \        0xA   0x1D20             ADDS     R0,R4,#+4
   \        0xC   0x.... 0x....      BL       mbedtls_psa_verify_hash_abort
   \       0x10   0xE001             B.N      ??psa_driver_wrapper_verify_hash_abort_1
   \                     ??psa_driver_wrapper_verify_hash_abort_0: (+1)
   \       0x12   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_verify_hash_abort_1: (+1)
   \       0x16   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_get_key_buffer_size_from_key_data(psa_key_attributes_t const *, uint8_t const *, size_t, size_t *)
   \                     psa_driver_wrapper_get_key_buffer_size_from_key_data: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8D4 0x8004      LDR      R8,[R4, #+4]
   \       0x10   0xEA5F 0x2818      LSRS     R8,R8,#+8
   \       0x14   0xF8B4 0x9000      LDRH     R9,[R4, #+0]
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6038             STR      R0,[R7, #+0]
   \       0x1C   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x20   0xD105             BNE.N    ??psa_driver_wrapper_get_key_buffer_size_from_k_0
   \       0x22   0x603E             STR      R6,[R7, #+0]
   \       0x24   0x0039             MOVS     R1,R7
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       psa_driver_wrapper_get_key_buffer_size
   \       0x2C   0xE001             B.N      ??psa_driver_wrapper_get_key_buffer_size_from_k_1
   \                     ??psa_driver_wrapper_get_key_buffer_size_from_k_0: (+1)
   \       0x2E   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_get_key_buffer_size_from_k_1: (+1)
   \       0x32   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_generate_key(psa_key_attributes_t const *, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_generate_key: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF07F 0x0896      MVNS     R8,#+150
   \       0x10   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \       0x14   0xEA5F 0x2919      LSRS     R9,R9,#+8
   \       0x18   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x1C   0xD003             BEQ.N    ??psa_driver_wrapper_generate_key_0
   \       0x1E   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x22   0xD015             BEQ.N    ??psa_driver_wrapper_generate_key_1
   \       0x24   0xE01B             B.N      ??psa_driver_wrapper_generate_key_2
   \                     ??psa_driver_wrapper_generate_key_0: (+1)
   \       0x26   0x8820             LDRH     R0,[R4, #+0]
   \       0x28   0x0440             LSLS     R0,R0,#+17
   \       0x2A   0xD509             BPL.N    ??psa_driver_wrapper_generate_key_3
   \       0x2C   0x003B             MOVS     R3,R7
   \       0x2E   0x0032             MOVS     R2,R6
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       sli_se_transparent_generate_key
   \       0x38   0x4680             MOV      R8,R0
   \       0x3A   0xF118 0x0F86      CMN      R8,#+134
   \       0x3E   0xD111             BNE.N    ??psa_driver_wrapper_generate_key_4
   \                     ??psa_driver_wrapper_generate_key_3: (+1)
   \       0x40   0x003B             MOVS     R3,R7
   \       0x42   0x0032             MOVS     R2,R6
   \       0x44   0x0029             MOVS     R1,R5
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       psa_generate_key_internal
   \       0x4C   0x4680             MOV      R8,R0
   \       0x4E   0xE009             B.N      ??psa_driver_wrapper_generate_key_4
   \                     ??psa_driver_wrapper_generate_key_1: (+1)
   \       0x50   0x003B             MOVS     R3,R7
   \       0x52   0x0032             MOVS     R2,R6
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       sli_se_opaque_generate_key
   \       0x5C   0xE003             B.N      ??psa_driver_wrapper_generate_key_5
   \                     ??psa_driver_wrapper_generate_key_2: (+1)
   \       0x5E   0xF07F 0x0086      MVNS     R0,#+134
   \       0x62   0x4680             MOV      R8,R0
   \                     ??psa_driver_wrapper_generate_key_4: (+1)
   \       0x64   0x4640             MOV      R0,R8
   \                     ??psa_driver_wrapper_generate_key_5: (+1)
   \       0x66   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_import_key(psa_key_attributes_t const *, uint8_t const *, size_t, uint8_t *, size_t, size_t *, size_t *)
   \                     psa_driver_wrapper_import_key: (+1)
   \        0x0   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9D0E             LDR      R5,[SP, #+56]
   \        0xE   0x9E0F             LDR      R6,[SP, #+60]
   \       0x10   0x9F10             LDR      R7,[SP, #+64]
   \       0x12   0xF07F 0x0096      MVNS     R0,#+150
   \       0x16   0x9003             STR      R0,[SP, #+12]
   \       0x18   0x4658             MOV      R0,R11
   \       0x1A   0x.... 0x....      BL       psa_get_key_lifetime
   \       0x1E   0x4680             MOV      R8,R0
   \       0x20   0xEA5F 0x2818      LSRS     R8,R8,#+8
   \       0x24   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x28   0xD003             BEQ.N    ??psa_driver_wrapper_import_key_0
   \       0x2A   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x2E   0xD019             BEQ.N    ??psa_driver_wrapper_import_key_1
   \       0x30   0xE022             B.N      ??psa_driver_wrapper_import_key_2
   \                     ??psa_driver_wrapper_import_key_0: (+1)
   \       0x32   0x9702             STR      R7,[SP, #+8]
   \       0x34   0x9601             STR      R6,[SP, #+4]
   \       0x36   0x9500             STR      R5,[SP, #+0]
   \       0x38   0x0023             MOVS     R3,R4
   \       0x3A   0x4652             MOV      R2,R10
   \       0x3C   0x9904             LDR      R1,[SP, #+16]
   \       0x3E   0x4658             MOV      R0,R11
   \       0x40   0x.... 0x....      BL       sli_se_transparent_import_key
   \       0x44   0x4681             MOV      R9,R0
   \       0x46   0xF119 0x0F86      CMN      R9,#+134
   \       0x4A   0xD001             BEQ.N    ??psa_driver_wrapper_import_key_3
   \       0x4C   0x4648             MOV      R0,R9
   \       0x4E   0xE015             B.N      ??psa_driver_wrapper_import_key_4
   \                     ??psa_driver_wrapper_import_key_3: (+1)
   \       0x50   0x9702             STR      R7,[SP, #+8]
   \       0x52   0x9601             STR      R6,[SP, #+4]
   \       0x54   0x9500             STR      R5,[SP, #+0]
   \       0x56   0x0023             MOVS     R3,R4
   \       0x58   0x4652             MOV      R2,R10
   \       0x5A   0x9904             LDR      R1,[SP, #+16]
   \       0x5C   0x4658             MOV      R0,R11
   \       0x5E   0x.... 0x....      BL       psa_import_key_into_slot
   \       0x62   0xE00B             B.N      ??psa_driver_wrapper_import_key_4
   \                     ??psa_driver_wrapper_import_key_1: (+1)
   \       0x64   0x9702             STR      R7,[SP, #+8]
   \       0x66   0x9601             STR      R6,[SP, #+4]
   \       0x68   0x9500             STR      R5,[SP, #+0]
   \       0x6A   0x0023             MOVS     R3,R4
   \       0x6C   0x4652             MOV      R2,R10
   \       0x6E   0x9904             LDR      R1,[SP, #+16]
   \       0x70   0x4658             MOV      R0,R11
   \       0x72   0x.... 0x....      BL       sli_se_opaque_import_key
   \       0x76   0xE001             B.N      ??psa_driver_wrapper_import_key_4
   \                     ??psa_driver_wrapper_import_key_2: (+1)
   \       0x78   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_import_key_4: (+1)
   \       0x7C   0xB005             ADD      SP,SP,#+20
   \       0x7E   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_export_key(psa_key_attributes_t const *, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_export_key: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0C             LDR      R7,[SP, #+48]
   \        0xE   0xF8DD 0x8034      LDR      R8,[SP, #+52]
   \       0x12   0xF07F 0x0986      MVNS     R9,#+134
   \       0x16   0x4658             MOV      R0,R11
   \       0x18   0x.... 0x....      BL       psa_get_key_lifetime
   \       0x1C   0x4682             MOV      R10,R0
   \       0x1E   0xEA5F 0x2A1A      LSRS     R10,R10,#+8
   \       0x22   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x26   0xD003             BEQ.N    ??psa_driver_wrapper_export_key_0
   \       0x28   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x2C   0xD00A             BEQ.N    ??psa_driver_wrapper_export_key_1
   \       0x2E   0xE013             B.N      ??psa_driver_wrapper_export_key_2
   \                     ??psa_driver_wrapper_export_key_0: (+1)
   \       0x30   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x34   0x9700             STR      R7,[SP, #+0]
   \       0x36   0x0033             MOVS     R3,R6
   \       0x38   0x002A             MOVS     R2,R5
   \       0x3A   0x0021             MOVS     R1,R4
   \       0x3C   0x4658             MOV      R0,R11
   \       0x3E   0x.... 0x....      BL       psa_export_key_internal
   \       0x42   0xE00A             B.N      ??psa_driver_wrapper_export_key_3
   \                     ??psa_driver_wrapper_export_key_1: (+1)
   \       0x44   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x48   0x9700             STR      R7,[SP, #+0]
   \       0x4A   0x0033             MOVS     R3,R6
   \       0x4C   0x002A             MOVS     R2,R5
   \       0x4E   0x0021             MOVS     R1,R4
   \       0x50   0x4658             MOV      R0,R11
   \       0x52   0x.... 0x....      BL       sli_se_opaque_export_key
   \       0x56   0xE000             B.N      ??psa_driver_wrapper_export_key_3
   \                     ??psa_driver_wrapper_export_key_2: (+1)
   \       0x58   0x4648             MOV      R0,R9
   \                     ??psa_driver_wrapper_export_key_3: (+1)
   \       0x5A   0xE8BD 0x8FFE      POP      {R1-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_copy_key(psa_key_attributes_t *, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_copy_key: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF07F 0x0896      MVNS     R8,#+150
   \       0x10   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \       0x14   0xEA5F 0x2919      LSRS     R9,R9,#+8
   \       0x18   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x1C   0xD10A             BNE.N    ??psa_driver_wrapper_copy_key_0
   \       0x1E   0x980B             LDR      R0,[SP, #+44]
   \       0x20   0x9001             STR      R0,[SP, #+4]
   \       0x22   0x980A             LDR      R0,[SP, #+40]
   \       0x24   0x9000             STR      R0,[SP, #+0]
   \       0x26   0x003B             MOVS     R3,R7
   \       0x28   0x0032             MOVS     R2,R6
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       sli_se_opaque_copy_key
   \       0x32   0xE001             B.N      ??psa_driver_wrapper_copy_key_1
   \                     ??psa_driver_wrapper_copy_key_0: (+1)
   \       0x34   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_copy_key_1: (+1)
   \       0x38   0xE8BD 0x83FE      POP      {R1-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_cipher_encrypt(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_cipher_encrypt: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x9C17             LDR      R4,[SP, #+92]
   \        0xA   0x9D18             LDR      R5,[SP, #+96]
   \        0xC   0x9E19             LDR      R6,[SP, #+100]
   \        0xE   0x9F1A             LDR      R7,[SP, #+104]
   \       0x10   0xF8DD 0x806C      LDR      R8,[SP, #+108]
   \       0x14   0xF8DD 0x9070      LDR      R9,[SP, #+112]
   \       0x18   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1C   0x9008             STR      R0,[SP, #+32]
   \       0x1E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x22   0x0A00             LSRS     R0,R0,#+8
   \       0x24   0x9007             STR      R0,[SP, #+28]
   \       0x26   0x9807             LDR      R0,[SP, #+28]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??psa_driver_wrapper_cipher_encrypt_0
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD027             BEQ.N    ??psa_driver_wrapper_cipher_encrypt_1
   \       0x30   0xE037             B.N      ??psa_driver_wrapper_cipher_encrypt_2
   \                     ??psa_driver_wrapper_cipher_encrypt_0: (+1)
   \       0x32   0xF8CD 0x9018      STR      R9,[SP, #+24]
   \       0x36   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \       0x3A   0x9704             STR      R7,[SP, #+16]
   \       0x3C   0x9603             STR      R6,[SP, #+12]
   \       0x3E   0x9502             STR      R5,[SP, #+8]
   \       0x40   0x9401             STR      R4,[SP, #+4]
   \       0x42   0x9816             LDR      R0,[SP, #+88]
   \       0x44   0x9000             STR      R0,[SP, #+0]
   \       0x46   0x9B0C             LDR      R3,[SP, #+48]
   \       0x48   0x9A0B             LDR      R2,[SP, #+44]
   \       0x4A   0x990A             LDR      R1,[SP, #+40]
   \       0x4C   0x4650             MOV      R0,R10
   \       0x4E   0x.... 0x....      BL       sli_se_transparent_cipher_encrypt
   \       0x52   0x4683             MOV      R11,R0
   \       0x54   0xF11B 0x0F86      CMN      R11,#+134
   \       0x58   0xD001             BEQ.N    ??psa_driver_wrapper_cipher_encrypt_3
   \       0x5A   0x4658             MOV      R0,R11
   \       0x5C   0xE023             B.N      ??psa_driver_wrapper_cipher_encrypt_4
   \                     ??psa_driver_wrapper_cipher_encrypt_3: (+1)
   \       0x5E   0xF8CD 0x9018      STR      R9,[SP, #+24]
   \       0x62   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \       0x66   0x9704             STR      R7,[SP, #+16]
   \       0x68   0x9603             STR      R6,[SP, #+12]
   \       0x6A   0x9502             STR      R5,[SP, #+8]
   \       0x6C   0x9401             STR      R4,[SP, #+4]
   \       0x6E   0x9816             LDR      R0,[SP, #+88]
   \       0x70   0x9000             STR      R0,[SP, #+0]
   \       0x72   0x9B0C             LDR      R3,[SP, #+48]
   \       0x74   0x9A0B             LDR      R2,[SP, #+44]
   \       0x76   0x990A             LDR      R1,[SP, #+40]
   \       0x78   0x4650             MOV      R0,R10
   \       0x7A   0x.... 0x....      BL       mbedtls_psa_cipher_encrypt
   \       0x7E   0xE012             B.N      ??psa_driver_wrapper_cipher_encrypt_4
   \                     ??psa_driver_wrapper_cipher_encrypt_1: (+1)
   \       0x80   0xF8CD 0x9018      STR      R9,[SP, #+24]
   \       0x84   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \       0x88   0x9704             STR      R7,[SP, #+16]
   \       0x8A   0x9603             STR      R6,[SP, #+12]
   \       0x8C   0x9502             STR      R5,[SP, #+8]
   \       0x8E   0x9401             STR      R4,[SP, #+4]
   \       0x90   0x9816             LDR      R0,[SP, #+88]
   \       0x92   0x9000             STR      R0,[SP, #+0]
   \       0x94   0x9B0C             LDR      R3,[SP, #+48]
   \       0x96   0x9A0B             LDR      R2,[SP, #+44]
   \       0x98   0x990A             LDR      R1,[SP, #+40]
   \       0x9A   0x4650             MOV      R0,R10
   \       0x9C   0x.... 0x....      BL       sli_se_opaque_cipher_encrypt
   \       0xA0   0xE001             B.N      ??psa_driver_wrapper_cipher_encrypt_4
   \                     ??psa_driver_wrapper_cipher_encrypt_2: (+1)
   \       0xA2   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_cipher_encrypt_4: (+1)
   \       0xA6   0xB00D             ADD      SP,SP,#+52
   \       0xA8   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_cipher_decrypt(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_cipher_decrypt: (+1)
   \        0x0   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x001C             MOVS     R4,R3
   \        0xA   0x9D12             LDR      R5,[SP, #+72]
   \        0xC   0x9E13             LDR      R6,[SP, #+76]
   \        0xE   0x9F14             LDR      R7,[SP, #+80]
   \       0x10   0xF8DD 0x8054      LDR      R8,[SP, #+84]
   \       0x14   0xF8DD 0x9058      LDR      R9,[SP, #+88]
   \       0x18   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1C   0x9006             STR      R0,[SP, #+24]
   \       0x1E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x22   0x0A00             LSRS     R0,R0,#+8
   \       0x24   0x9005             STR      R0,[SP, #+20]
   \       0x26   0x9805             LDR      R0,[SP, #+20]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??psa_driver_wrapper_cipher_decrypt_0
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD021             BEQ.N    ??psa_driver_wrapper_cipher_decrypt_1
   \       0x30   0xE02E             B.N      ??psa_driver_wrapper_cipher_decrypt_2
   \                     ??psa_driver_wrapper_cipher_decrypt_0: (+1)
   \       0x32   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x36   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x3A   0x9702             STR      R7,[SP, #+8]
   \       0x3C   0x9601             STR      R6,[SP, #+4]
   \       0x3E   0x9500             STR      R5,[SP, #+0]
   \       0x40   0x0023             MOVS     R3,R4
   \       0x42   0x9A08             LDR      R2,[SP, #+32]
   \       0x44   0x9907             LDR      R1,[SP, #+28]
   \       0x46   0x4650             MOV      R0,R10
   \       0x48   0x.... 0x....      BL       sli_se_transparent_cipher_decrypt
   \       0x4C   0x4683             MOV      R11,R0
   \       0x4E   0xF11B 0x0F86      CMN      R11,#+134
   \       0x52   0xD001             BEQ.N    ??psa_driver_wrapper_cipher_decrypt_3
   \       0x54   0x4658             MOV      R0,R11
   \       0x56   0xE01D             B.N      ??psa_driver_wrapper_cipher_decrypt_4
   \                     ??psa_driver_wrapper_cipher_decrypt_3: (+1)
   \       0x58   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x5C   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x60   0x9702             STR      R7,[SP, #+8]
   \       0x62   0x9601             STR      R6,[SP, #+4]
   \       0x64   0x9500             STR      R5,[SP, #+0]
   \       0x66   0x0023             MOVS     R3,R4
   \       0x68   0x9A08             LDR      R2,[SP, #+32]
   \       0x6A   0x9907             LDR      R1,[SP, #+28]
   \       0x6C   0x4650             MOV      R0,R10
   \       0x6E   0x.... 0x....      BL       mbedtls_psa_cipher_decrypt
   \       0x72   0xE00F             B.N      ??psa_driver_wrapper_cipher_decrypt_4
   \                     ??psa_driver_wrapper_cipher_decrypt_1: (+1)
   \       0x74   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x78   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x7C   0x9702             STR      R7,[SP, #+8]
   \       0x7E   0x9601             STR      R6,[SP, #+4]
   \       0x80   0x9500             STR      R5,[SP, #+0]
   \       0x82   0x0023             MOVS     R3,R4
   \       0x84   0x9A08             LDR      R2,[SP, #+32]
   \       0x86   0x9907             LDR      R1,[SP, #+28]
   \       0x88   0x4650             MOV      R0,R10
   \       0x8A   0x.... 0x....      BL       sli_se_opaque_cipher_decrypt
   \       0x8E   0xE001             B.N      ??psa_driver_wrapper_cipher_decrypt_4
   \                     ??psa_driver_wrapper_cipher_decrypt_2: (+1)
   \       0x90   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_cipher_decrypt_4: (+1)
   \       0x94   0xB009             ADD      SP,SP,#+36
   \       0x96   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_cipher_encrypt_setup(psa_cipher_operation_t *, psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t)
   \                     psa_driver_wrapper_cipher_encrypt_setup: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0A             LDR      R7,[SP, #+40]
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \       0x16   0xEA5F 0x2919      LSRS     R9,R9,#+8
   \       0x1A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x1E   0xD003             BEQ.N    ??psa_driver_wrapper_cipher_encrypt_setup_0
   \       0x20   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x24   0xD029             BEQ.N    ??psa_driver_wrapper_cipher_encrypt_setup_1
   \       0x26   0xE036             B.N      ??psa_driver_wrapper_cipher_encrypt_setup_2
   \                     ??psa_driver_wrapper_cipher_encrypt_setup_0: (+1)
   \       0x28   0x9700             STR      R7,[SP, #+0]
   \       0x2A   0x0033             MOVS     R3,R6
   \       0x2C   0x002A             MOVS     R2,R5
   \       0x2E   0x0021             MOVS     R1,R4
   \       0x30   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x34   0x.... 0x....      BL       sli_se_transparent_cipher_encrypt_setup
   \       0x38   0x4683             MOV      R11,R0
   \       0x3A   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x3E   0xD102             BNE.N    ??psa_driver_wrapper_cipher_encrypt_setup_3
   \       0x40   0x2004             MOVS     R0,#+4
   \       0x42   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \                     ??psa_driver_wrapper_cipher_encrypt_setup_3: (+1)
   \       0x46   0xF07F 0x0885      MVNS     R8,#+133
   \       0x4A   0x45C3             CMP      R11,R8
   \       0x4C   0xD001             BEQ.N    ??psa_driver_wrapper_cipher_encrypt_setup_4
   \       0x4E   0x4658             MOV      R0,R11
   \       0x50   0xE023             B.N      ??psa_driver_wrapper_cipher_encrypt_setup_5
   \                     ??psa_driver_wrapper_cipher_encrypt_setup_4: (+1)
   \       0x52   0x9700             STR      R7,[SP, #+0]
   \       0x54   0x0033             MOVS     R3,R6
   \       0x56   0x002A             MOVS     R2,R5
   \       0x58   0x0021             MOVS     R1,R4
   \       0x5A   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x5E   0x.... 0x....      BL       mbedtls_psa_cipher_encrypt_setup
   \       0x62   0x0001             MOVS     R1,R0
   \       0x64   0x2900             CMP      R1,#+0
   \       0x66   0xD102             BNE.N    ??psa_driver_wrapper_cipher_encrypt_setup_6
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \                     ??psa_driver_wrapper_cipher_encrypt_setup_6: (+1)
   \       0x6E   0x4541             CMP      R1,R8
   \       0x70   0xD001             BEQ.N    ??psa_driver_wrapper_cipher_encrypt_setup_7
   \       0x72   0x0008             MOVS     R0,R1
   \       0x74   0xE011             B.N      ??psa_driver_wrapper_cipher_encrypt_setup_5
   \                     ??psa_driver_wrapper_cipher_encrypt_setup_7: (+1)
   \       0x76   0x4640             MOV      R0,R8
   \       0x78   0xE00F             B.N      ??psa_driver_wrapper_cipher_encrypt_setup_5
   \                     ??psa_driver_wrapper_cipher_encrypt_setup_1: (+1)
   \       0x7A   0x9700             STR      R7,[SP, #+0]
   \       0x7C   0x0033             MOVS     R3,R6
   \       0x7E   0x002A             MOVS     R2,R5
   \       0x80   0x0021             MOVS     R1,R4
   \       0x82   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x86   0x.... 0x....      BL       sli_se_opaque_cipher_encrypt_setup
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD102             BNE.N    ??psa_driver_wrapper_cipher_encrypt_setup_8
   \       0x8E   0x2105             MOVS     R1,#+5
   \       0x90   0xF8CA 0x1000      STR      R1,[R10, #+0]
   \                     ??psa_driver_wrapper_cipher_encrypt_setup_8: (+1)
   \       0x94   0xE001             B.N      ??psa_driver_wrapper_cipher_encrypt_setup_5
   \                     ??psa_driver_wrapper_cipher_encrypt_setup_2: (+1)
   \       0x96   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_cipher_encrypt_setup_5: (+1)
   \       0x9A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_cipher_decrypt_setup(psa_cipher_operation_t *, psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t)
   \                     psa_driver_wrapper_cipher_decrypt_setup: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0A             LDR      R7,[SP, #+40]
   \        0xE   0xF07F 0x0086      MVNS     R0,#+134
   \       0x12   0x4680             MOV      R8,R0
   \       0x14   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \       0x18   0xEA5F 0x2919      LSRS     R9,R9,#+8
   \       0x1C   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x20   0xD003             BEQ.N    ??psa_driver_wrapper_cipher_decrypt_setup_0
   \       0x22   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x26   0xD022             BEQ.N    ??psa_driver_wrapper_cipher_decrypt_setup_1
   \       0x28   0xE02F             B.N      ??psa_driver_wrapper_cipher_decrypt_setup_2
   \                     ??psa_driver_wrapper_cipher_decrypt_setup_0: (+1)
   \       0x2A   0x9700             STR      R7,[SP, #+0]
   \       0x2C   0x0033             MOVS     R3,R6
   \       0x2E   0x002A             MOVS     R2,R5
   \       0x30   0x0021             MOVS     R1,R4
   \       0x32   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x36   0x.... 0x....      BL       sli_se_transparent_cipher_decrypt_setup
   \       0x3A   0x4683             MOV      R11,R0
   \       0x3C   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x40   0xD102             BNE.N    ??psa_driver_wrapper_cipher_decrypt_setup_3
   \       0x42   0x2004             MOVS     R0,#+4
   \       0x44   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \                     ??psa_driver_wrapper_cipher_decrypt_setup_3: (+1)
   \       0x48   0xF11B 0x0F86      CMN      R11,#+134
   \       0x4C   0xD001             BEQ.N    ??psa_driver_wrapper_cipher_decrypt_setup_4
   \       0x4E   0x4658             MOV      R0,R11
   \       0x50   0xE01B             B.N      ??psa_driver_wrapper_cipher_decrypt_setup_5
   \                     ??psa_driver_wrapper_cipher_decrypt_setup_4: (+1)
   \       0x52   0x9700             STR      R7,[SP, #+0]
   \       0x54   0x0033             MOVS     R3,R6
   \       0x56   0x002A             MOVS     R2,R5
   \       0x58   0x0021             MOVS     R1,R4
   \       0x5A   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x5E   0x.... 0x....      BL       mbedtls_psa_cipher_decrypt_setup
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD102             BNE.N    ??psa_driver_wrapper_cipher_decrypt_setup_6
   \       0x66   0x2101             MOVS     R1,#+1
   \       0x68   0xF8CA 0x1000      STR      R1,[R10, #+0]
   \                     ??psa_driver_wrapper_cipher_decrypt_setup_6: (+1)
   \       0x6C   0xE00D             B.N      ??psa_driver_wrapper_cipher_decrypt_setup_5
   \                     ??psa_driver_wrapper_cipher_decrypt_setup_1: (+1)
   \       0x6E   0x9700             STR      R7,[SP, #+0]
   \       0x70   0x0033             MOVS     R3,R6
   \       0x72   0x002A             MOVS     R2,R5
   \       0x74   0x0021             MOVS     R1,R4
   \       0x76   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x7A   0x.... 0x....      BL       sli_se_opaque_cipher_decrypt_setup
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD102             BNE.N    ??psa_driver_wrapper_cipher_decrypt_setup_7
   \       0x82   0x2105             MOVS     R1,#+5
   \       0x84   0xF8CA 0x1000      STR      R1,[R10, #+0]
   \                     ??psa_driver_wrapper_cipher_decrypt_setup_7: (+1)
   \       0x88   0xE7FF             B.N      ??psa_driver_wrapper_cipher_decrypt_setup_5
   \                     ??psa_driver_wrapper_cipher_decrypt_setup_2: (+1)
   \                     ??psa_driver_wrapper_cipher_decrypt_setup_5: (+1)
   \       0x8A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_cipher_set_iv(psa_cipher_operation_t *, uint8_t const *, size_t)
   \                     psa_driver_wrapper_cipher_set_iv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD004             BEQ.N    ??psa_driver_wrapper_cipher_set_iv_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD009             BEQ.N    ??psa_driver_wrapper_cipher_set_iv_1
   \       0x12   0x2805             CMP      R0,#+5
   \       0x14   0xD00E             BEQ.N    ??psa_driver_wrapper_cipher_set_iv_2
   \       0x16   0xE014             B.N      ??psa_driver_wrapper_cipher_set_iv_3
   \                     ??psa_driver_wrapper_cipher_set_iv_0: (+1)
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x20   0x.... 0x....      BL       mbedtls_psa_cipher_set_iv
   \       0x24   0xE00F             B.N      ??psa_driver_wrapper_cipher_set_iv_4
   \                     ??psa_driver_wrapper_cipher_set_iv_1: (+1)
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x2E   0x.... 0x....      BL       sli_se_transparent_cipher_set_iv
   \       0x32   0xE008             B.N      ??psa_driver_wrapper_cipher_set_iv_4
   \                     ??psa_driver_wrapper_cipher_set_iv_2: (+1)
   \       0x34   0x0032             MOVS     R2,R6
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x3C   0x.... 0x....      BL       sli_se_opaque_cipher_set_iv
   \       0x40   0xE001             B.N      ??psa_driver_wrapper_cipher_set_iv_4
   \                     ??psa_driver_wrapper_cipher_set_iv_3: (+1)
   \       0x42   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_cipher_set_iv_4: (+1)
   \       0x46   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_cipher_update(psa_cipher_operation_t *, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_cipher_update: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \       0x10   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD004             BEQ.N    ??psa_driver_wrapper_cipher_update_0
   \       0x1A   0x2804             CMP      R0,#+4
   \       0x1C   0xD00E             BEQ.N    ??psa_driver_wrapper_cipher_update_1
   \       0x1E   0x2805             CMP      R0,#+5
   \       0x20   0xD018             BEQ.N    ??psa_driver_wrapper_cipher_update_2
   \       0x22   0xE023             B.N      ??psa_driver_wrapper_cipher_update_3
   \                     ??psa_driver_wrapper_cipher_update_0: (+1)
   \       0x24   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x28   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x2C   0x003B             MOVS     R3,R7
   \       0x2E   0x0032             MOVS     R2,R6
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x36   0x.... 0x....      BL       mbedtls_psa_cipher_update
   \       0x3A   0xE019             B.N      ??psa_driver_wrapper_cipher_update_4
   \                     ??psa_driver_wrapper_cipher_update_1: (+1)
   \       0x3C   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x40   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x44   0x003B             MOVS     R3,R7
   \       0x46   0x0032             MOVS     R2,R6
   \       0x48   0x0029             MOVS     R1,R5
   \       0x4A   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x4E   0x.... 0x....      BL       sli_se_transparent_cipher_update
   \       0x52   0xE00D             B.N      ??psa_driver_wrapper_cipher_update_4
   \                     ??psa_driver_wrapper_cipher_update_2: (+1)
   \       0x54   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x58   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x5C   0x003B             MOVS     R3,R7
   \       0x5E   0x0032             MOVS     R2,R6
   \       0x60   0x0029             MOVS     R1,R5
   \       0x62   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x66   0x.... 0x....      BL       sli_se_opaque_cipher_update
   \       0x6A   0xE001             B.N      ??psa_driver_wrapper_cipher_update_4
   \                     ??psa_driver_wrapper_cipher_update_3: (+1)
   \       0x6C   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_cipher_update_4: (+1)
   \       0x70   0xE8BD 0x83FE      POP      {R1-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_cipher_finish(psa_cipher_operation_t *, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_cipher_finish: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD004             BEQ.N    ??psa_driver_wrapper_cipher_finish_0
   \       0x10   0x2804             CMP      R0,#+4
   \       0x12   0xD00A             BEQ.N    ??psa_driver_wrapper_cipher_finish_1
   \       0x14   0x2805             CMP      R0,#+5
   \       0x16   0xD010             BEQ.N    ??psa_driver_wrapper_cipher_finish_2
   \       0x18   0xE017             B.N      ??psa_driver_wrapper_cipher_finish_3
   \                     ??psa_driver_wrapper_cipher_finish_0: (+1)
   \       0x1A   0x003B             MOVS     R3,R7
   \       0x1C   0x0032             MOVS     R2,R6
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x24   0x.... 0x....      BL       mbedtls_psa_cipher_finish
   \       0x28   0xE011             B.N      ??psa_driver_wrapper_cipher_finish_4
   \                     ??psa_driver_wrapper_cipher_finish_1: (+1)
   \       0x2A   0x003B             MOVS     R3,R7
   \       0x2C   0x0032             MOVS     R2,R6
   \       0x2E   0x0029             MOVS     R1,R5
   \       0x30   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x34   0x.... 0x....      BL       sli_se_transparent_cipher_finish
   \       0x38   0xE009             B.N      ??psa_driver_wrapper_cipher_finish_4
   \                     ??psa_driver_wrapper_cipher_finish_2: (+1)
   \       0x3A   0x003B             MOVS     R3,R7
   \       0x3C   0x0032             MOVS     R2,R6
   \       0x3E   0x0029             MOVS     R1,R5
   \       0x40   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x44   0x.... 0x....      BL       sli_se_opaque_cipher_finish
   \       0x48   0xE001             B.N      ??psa_driver_wrapper_cipher_finish_4
   \                     ??psa_driver_wrapper_cipher_finish_3: (+1)
   \       0x4A   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_cipher_finish_4: (+1)
   \       0x4E   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_cipher_abort(psa_cipher_operation_t *)
   \                     psa_driver_wrapper_cipher_abort: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0xF07F 0x0596      MVNS     R5,#+150
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD004             BEQ.N    ??psa_driver_wrapper_cipher_abort_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD007             BEQ.N    ??psa_driver_wrapper_cipher_abort_1
   \       0x12   0x2805             CMP      R0,#+5
   \       0x14   0xD00A             BEQ.N    ??psa_driver_wrapper_cipher_abort_2
   \       0x16   0xE00E             B.N      ??psa_driver_wrapper_cipher_abort_3
   \                     ??psa_driver_wrapper_cipher_abort_0: (+1)
   \       0x18   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x1C   0x.... 0x....      BL       mbedtls_psa_cipher_abort
   \       0x20   0xE00B             B.N      ??psa_driver_wrapper_cipher_abort_4
   \                     ??psa_driver_wrapper_cipher_abort_1: (+1)
   \       0x22   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x26   0x.... 0x....      BL       sli_se_transparent_cipher_abort
   \       0x2A   0xE006             B.N      ??psa_driver_wrapper_cipher_abort_4
   \                     ??psa_driver_wrapper_cipher_abort_2: (+1)
   \       0x2C   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x30   0x.... 0x....      BL       sli_se_opaque_cipher_abort
   \       0x34   0xE001             B.N      ??psa_driver_wrapper_cipher_abort_4
   \                     ??psa_driver_wrapper_cipher_abort_3: (+1)
   \       0x36   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_cipher_abort_4: (+1)
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_hash_compute(uint32_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_hash_compute: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \       0x10   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   \       0x14   0xF07F 0x0096      MVNS     R0,#+150
   \       0x18   0x9002             STR      R0,[SP, #+8]
   \       0x1A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x1E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x22   0x003B             MOVS     R3,R7
   \       0x24   0x0032             MOVS     R2,R6
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       sli_se_transparent_hash_compute
   \       0x2E   0x4683             MOV      R11,R0
   \       0x30   0xF07F 0x0A85      MVNS     R10,#+133
   \       0x34   0x45D3             CMP      R11,R10
   \       0x36   0xD001             BEQ.N    ??psa_driver_wrapper_hash_compute_0
   \       0x38   0x4658             MOV      R0,R11
   \       0x3A   0xE00F             B.N      ??psa_driver_wrapper_hash_compute_1
   \                     ??psa_driver_wrapper_hash_compute_0: (+1)
   \       0x3C   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x40   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x44   0x003B             MOVS     R3,R7
   \       0x46   0x0032             MOVS     R2,R6
   \       0x48   0x0029             MOVS     R1,R5
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       mbedtls_psa_hash_compute
   \       0x50   0x0001             MOVS     R1,R0
   \       0x52   0x4551             CMP      R1,R10
   \       0x54   0xD001             BEQ.N    ??psa_driver_wrapper_hash_compute_2
   \       0x56   0x0008             MOVS     R0,R1
   \       0x58   0xE000             B.N      ??psa_driver_wrapper_hash_compute_1
   \                     ??psa_driver_wrapper_hash_compute_2: (+1)
   \       0x5A   0x4650             MOV      R0,R10
   \                     ??psa_driver_wrapper_hash_compute_1: (+1)
   \       0x5C   0xE8BD 0x8FFE      POP      {R1-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_hash_setup(psa_hash_operation_t *, uint32_t)
   \                     psa_driver_wrapper_hash_setup: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0xF07F 0x0796      MVNS     R7,#+150
   \        0xA   0x0031             MOVS     R1,R6
   \        0xC   0x1D28             ADDS     R0,R5,#+4
   \        0xE   0x.... 0x....      BL       sli_se_transparent_hash_setup
   \       0x12   0x0004             MOVS     R4,R0
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD101             BNE.N    ??psa_driver_wrapper_hash_setup_0
   \       0x18   0x2004             MOVS     R0,#+4
   \       0x1A   0x6028             STR      R0,[R5, #+0]
   \                     ??psa_driver_wrapper_hash_setup_0: (+1)
   \       0x1C   0xF07F 0x0785      MVNS     R7,#+133
   \       0x20   0x42BC             CMP      R4,R7
   \       0x22   0xD001             BEQ.N    ??psa_driver_wrapper_hash_setup_1
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xE00D             B.N      ??psa_driver_wrapper_hash_setup_2
   \                     ??psa_driver_wrapper_hash_setup_1: (+1)
   \       0x28   0x0031             MOVS     R1,R6
   \       0x2A   0x1D28             ADDS     R0,R5,#+4
   \       0x2C   0x.... 0x....      BL       mbedtls_psa_hash_setup
   \       0x30   0x0001             MOVS     R1,R0
   \       0x32   0x2900             CMP      R1,#+0
   \       0x34   0xD101             BNE.N    ??psa_driver_wrapper_hash_setup_3
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0x6028             STR      R0,[R5, #+0]
   \                     ??psa_driver_wrapper_hash_setup_3: (+1)
   \       0x3A   0x42B9             CMP      R1,R7
   \       0x3C   0xD001             BEQ.N    ??psa_driver_wrapper_hash_setup_4
   \       0x3E   0x0008             MOVS     R0,R1
   \       0x40   0xE000             B.N      ??psa_driver_wrapper_hash_setup_2
   \                     ??psa_driver_wrapper_hash_setup_4: (+1)
   \       0x42   0x0038             MOVS     R0,R7
   \                     ??psa_driver_wrapper_hash_setup_2: (+1)
   \       0x44   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_hash_clone(psa_hash_operation_t const *, psa_hash_operation_t *)
   \                     psa_driver_wrapper_hash_clone: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD002             BEQ.N    ??psa_driver_wrapper_hash_clone_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD007             BEQ.N    ??psa_driver_wrapper_hash_clone_1
   \       0x10   0xE00D             B.N      ??psa_driver_wrapper_hash_clone_2
   \                     ??psa_driver_wrapper_hash_clone_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x6028             STR      R0,[R5, #+0]
   \       0x16   0x1D29             ADDS     R1,R5,#+4
   \       0x18   0x1D20             ADDS     R0,R4,#+4
   \       0x1A   0x.... 0x....      BL       mbedtls_psa_hash_clone
   \       0x1E   0xE008             B.N      ??psa_driver_wrapper_hash_clone_3
   \                     ??psa_driver_wrapper_hash_clone_1: (+1)
   \       0x20   0x2004             MOVS     R0,#+4
   \       0x22   0x6028             STR      R0,[R5, #+0]
   \       0x24   0x1D29             ADDS     R1,R5,#+4
   \       0x26   0x1D20             ADDS     R0,R4,#+4
   \       0x28   0x.... 0x....      BL       sli_se_transparent_hash_clone
   \       0x2C   0xE001             B.N      ??psa_driver_wrapper_hash_clone_3
   \                     ??psa_driver_wrapper_hash_clone_2: (+1)
   \       0x2E   0xF07F 0x0088      MVNS     R0,#+136
   \                     ??psa_driver_wrapper_hash_clone_3: (+1)
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_hash_update(psa_hash_operation_t *, uint8_t const *, size_t)
   \                     psa_driver_wrapper_hash_update: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD002             BEQ.N    ??psa_driver_wrapper_hash_update_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD006             BEQ.N    ??psa_driver_wrapper_hash_update_1
   \       0x12   0xE00B             B.N      ??psa_driver_wrapper_hash_update_2
   \                     ??psa_driver_wrapper_hash_update_0: (+1)
   \       0x14   0x0032             MOVS     R2,R6
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0x1D20             ADDS     R0,R4,#+4
   \       0x1A   0x.... 0x....      BL       mbedtls_psa_hash_update
   \       0x1E   0xE007             B.N      ??psa_driver_wrapper_hash_update_3
   \                     ??psa_driver_wrapper_hash_update_1: (+1)
   \       0x20   0x0032             MOVS     R2,R6
   \       0x22   0x0029             MOVS     R1,R5
   \       0x24   0x1D20             ADDS     R0,R4,#+4
   \       0x26   0x.... 0x....      BL       sli_se_transparent_hash_update
   \       0x2A   0xE001             B.N      ??psa_driver_wrapper_hash_update_3
   \                     ??psa_driver_wrapper_hash_update_2: (+1)
   \       0x2C   0xF07F 0x0088      MVNS     R0,#+136
   \                     ??psa_driver_wrapper_hash_update_3: (+1)
   \       0x30   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_hash_finish(psa_hash_operation_t *, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_hash_finish: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD002             BEQ.N    ??psa_driver_wrapper_hash_finish_0
   \       0x10   0x2804             CMP      R0,#+4
   \       0x12   0xD007             BEQ.N    ??psa_driver_wrapper_hash_finish_1
   \       0x14   0xE00D             B.N      ??psa_driver_wrapper_hash_finish_2
   \                     ??psa_driver_wrapper_hash_finish_0: (+1)
   \       0x16   0x003B             MOVS     R3,R7
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0x1D20             ADDS     R0,R4,#+4
   \       0x1E   0x.... 0x....      BL       mbedtls_psa_hash_finish
   \       0x22   0xE008             B.N      ??psa_driver_wrapper_hash_finish_3
   \                     ??psa_driver_wrapper_hash_finish_1: (+1)
   \       0x24   0x003B             MOVS     R3,R7
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0x1D20             ADDS     R0,R4,#+4
   \       0x2C   0x.... 0x....      BL       sli_se_transparent_hash_finish
   \       0x30   0xE001             B.N      ??psa_driver_wrapper_hash_finish_3
   \                     ??psa_driver_wrapper_hash_finish_2: (+1)
   \       0x32   0xF07F 0x0088      MVNS     R0,#+136
   \                     ??psa_driver_wrapper_hash_finish_3: (+1)
   \       0x36   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_hash_abort(psa_hash_operation_t *)
   \                     psa_driver_wrapper_hash_abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD002             BEQ.N    ??psa_driver_wrapper_hash_abort_0
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xD004             BEQ.N    ??psa_driver_wrapper_hash_abort_1
   \        0xE   0xE007             B.N      ??psa_driver_wrapper_hash_abort_2
   \                     ??psa_driver_wrapper_hash_abort_0: (+1)
   \       0x10   0x1D20             ADDS     R0,R4,#+4
   \       0x12   0x.... 0x....      BL       mbedtls_psa_hash_abort
   \       0x16   0xE005             B.N      ??psa_driver_wrapper_hash_abort_3
   \                     ??psa_driver_wrapper_hash_abort_1: (+1)
   \       0x18   0x1D20             ADDS     R0,R4,#+4
   \       0x1A   0x.... 0x....      BL       sli_se_transparent_hash_abort
   \       0x1E   0xE001             B.N      ??psa_driver_wrapper_hash_abort_3
   \                     ??psa_driver_wrapper_hash_abort_2: (+1)
   \       0x20   0xF07F 0x0088      MVNS     R0,#+136
   \                     ??psa_driver_wrapper_hash_abort_3: (+1)
   \       0x24   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_encrypt(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t const *, size_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_aead_encrypt: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x9C1B             LDR      R4,[SP, #+108]
   \        0xA   0x9D1C             LDR      R5,[SP, #+112]
   \        0xC   0x9E1D             LDR      R6,[SP, #+116]
   \        0xE   0x9F1E             LDR      R7,[SP, #+120]
   \       0x10   0xF8DD 0x807C      LDR      R8,[SP, #+124]
   \       0x14   0xF8DD 0x9080      LDR      R9,[SP, #+128]
   \       0x18   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1C   0x900A             STR      R0,[SP, #+40]
   \       0x1E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x22   0x0A00             LSRS     R0,R0,#+8
   \       0x24   0x9009             STR      R0,[SP, #+36]
   \       0x26   0x9809             LDR      R0,[SP, #+36]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??psa_driver_wrapper_aead_encrypt_0
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD02F             BEQ.N    ??psa_driver_wrapper_aead_encrypt_1
   \       0x30   0xE043             B.N      ??psa_driver_wrapper_aead_encrypt_2
   \                     ??psa_driver_wrapper_aead_encrypt_0: (+1)
   \       0x32   0xF8CD 0x9020      STR      R9,[SP, #+32]
   \       0x36   0xF8CD 0x801C      STR      R8,[SP, #+28]
   \       0x3A   0x9706             STR      R7,[SP, #+24]
   \       0x3C   0x9605             STR      R6,[SP, #+20]
   \       0x3E   0x9504             STR      R5,[SP, #+16]
   \       0x40   0x9403             STR      R4,[SP, #+12]
   \       0x42   0x981A             LDR      R0,[SP, #+104]
   \       0x44   0x9002             STR      R0,[SP, #+8]
   \       0x46   0x9819             LDR      R0,[SP, #+100]
   \       0x48   0x9001             STR      R0,[SP, #+4]
   \       0x4A   0x9818             LDR      R0,[SP, #+96]
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x9B0E             LDR      R3,[SP, #+56]
   \       0x50   0x9A0D             LDR      R2,[SP, #+52]
   \       0x52   0x990C             LDR      R1,[SP, #+48]
   \       0x54   0x4650             MOV      R0,R10
   \       0x56   0x.... 0x....      BL       sli_se_transparent_aead_encrypt
   \       0x5A   0x4683             MOV      R11,R0
   \       0x5C   0xF11B 0x0F86      CMN      R11,#+134
   \       0x60   0xD001             BEQ.N    ??psa_driver_wrapper_aead_encrypt_3
   \       0x62   0x4658             MOV      R0,R11
   \       0x64   0xE02B             B.N      ??psa_driver_wrapper_aead_encrypt_4
   \                     ??psa_driver_wrapper_aead_encrypt_3: (+1)
   \       0x66   0xF8CD 0x9020      STR      R9,[SP, #+32]
   \       0x6A   0xF8CD 0x801C      STR      R8,[SP, #+28]
   \       0x6E   0x9706             STR      R7,[SP, #+24]
   \       0x70   0x9605             STR      R6,[SP, #+20]
   \       0x72   0x9504             STR      R5,[SP, #+16]
   \       0x74   0x9403             STR      R4,[SP, #+12]
   \       0x76   0x981A             LDR      R0,[SP, #+104]
   \       0x78   0x9002             STR      R0,[SP, #+8]
   \       0x7A   0x9819             LDR      R0,[SP, #+100]
   \       0x7C   0x9001             STR      R0,[SP, #+4]
   \       0x7E   0x9818             LDR      R0,[SP, #+96]
   \       0x80   0x9000             STR      R0,[SP, #+0]
   \       0x82   0x9B0E             LDR      R3,[SP, #+56]
   \       0x84   0x9A0D             LDR      R2,[SP, #+52]
   \       0x86   0x990C             LDR      R1,[SP, #+48]
   \       0x88   0x4650             MOV      R0,R10
   \       0x8A   0x.... 0x....      BL       mbedtls_psa_aead_encrypt
   \       0x8E   0xE016             B.N      ??psa_driver_wrapper_aead_encrypt_4
   \                     ??psa_driver_wrapper_aead_encrypt_1: (+1)
   \       0x90   0xF8CD 0x9020      STR      R9,[SP, #+32]
   \       0x94   0xF8CD 0x801C      STR      R8,[SP, #+28]
   \       0x98   0x9706             STR      R7,[SP, #+24]
   \       0x9A   0x9605             STR      R6,[SP, #+20]
   \       0x9C   0x9504             STR      R5,[SP, #+16]
   \       0x9E   0x9403             STR      R4,[SP, #+12]
   \       0xA0   0x981A             LDR      R0,[SP, #+104]
   \       0xA2   0x9002             STR      R0,[SP, #+8]
   \       0xA4   0x9819             LDR      R0,[SP, #+100]
   \       0xA6   0x9001             STR      R0,[SP, #+4]
   \       0xA8   0x9818             LDR      R0,[SP, #+96]
   \       0xAA   0x9000             STR      R0,[SP, #+0]
   \       0xAC   0x9B0E             LDR      R3,[SP, #+56]
   \       0xAE   0x9A0D             LDR      R2,[SP, #+52]
   \       0xB0   0x990C             LDR      R1,[SP, #+48]
   \       0xB2   0x4650             MOV      R0,R10
   \       0xB4   0x.... 0x....      BL       sli_se_opaque_aead_encrypt
   \       0xB8   0xE001             B.N      ??psa_driver_wrapper_aead_encrypt_4
   \                     ??psa_driver_wrapper_aead_encrypt_2: (+1)
   \       0xBA   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_encrypt_4: (+1)
   \       0xBE   0xB00F             ADD      SP,SP,#+60
   \       0xC0   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_decrypt(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t const *, size_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_aead_decrypt: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x9C1B             LDR      R4,[SP, #+108]
   \        0xA   0x9D1C             LDR      R5,[SP, #+112]
   \        0xC   0x9E1D             LDR      R6,[SP, #+116]
   \        0xE   0x9F1E             LDR      R7,[SP, #+120]
   \       0x10   0xF8DD 0x807C      LDR      R8,[SP, #+124]
   \       0x14   0xF8DD 0x9080      LDR      R9,[SP, #+128]
   \       0x18   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1C   0x900A             STR      R0,[SP, #+40]
   \       0x1E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x22   0x0A00             LSRS     R0,R0,#+8
   \       0x24   0x9009             STR      R0,[SP, #+36]
   \       0x26   0x9809             LDR      R0,[SP, #+36]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??psa_driver_wrapper_aead_decrypt_0
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD02F             BEQ.N    ??psa_driver_wrapper_aead_decrypt_1
   \       0x30   0xE043             B.N      ??psa_driver_wrapper_aead_decrypt_2
   \                     ??psa_driver_wrapper_aead_decrypt_0: (+1)
   \       0x32   0xF8CD 0x9020      STR      R9,[SP, #+32]
   \       0x36   0xF8CD 0x801C      STR      R8,[SP, #+28]
   \       0x3A   0x9706             STR      R7,[SP, #+24]
   \       0x3C   0x9605             STR      R6,[SP, #+20]
   \       0x3E   0x9504             STR      R5,[SP, #+16]
   \       0x40   0x9403             STR      R4,[SP, #+12]
   \       0x42   0x981A             LDR      R0,[SP, #+104]
   \       0x44   0x9002             STR      R0,[SP, #+8]
   \       0x46   0x9819             LDR      R0,[SP, #+100]
   \       0x48   0x9001             STR      R0,[SP, #+4]
   \       0x4A   0x9818             LDR      R0,[SP, #+96]
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x9B0E             LDR      R3,[SP, #+56]
   \       0x50   0x9A0D             LDR      R2,[SP, #+52]
   \       0x52   0x990C             LDR      R1,[SP, #+48]
   \       0x54   0x4650             MOV      R0,R10
   \       0x56   0x.... 0x....      BL       sli_se_transparent_aead_decrypt
   \       0x5A   0x4683             MOV      R11,R0
   \       0x5C   0xF11B 0x0F86      CMN      R11,#+134
   \       0x60   0xD001             BEQ.N    ??psa_driver_wrapper_aead_decrypt_3
   \       0x62   0x4658             MOV      R0,R11
   \       0x64   0xE02B             B.N      ??psa_driver_wrapper_aead_decrypt_4
   \                     ??psa_driver_wrapper_aead_decrypt_3: (+1)
   \       0x66   0xF8CD 0x9020      STR      R9,[SP, #+32]
   \       0x6A   0xF8CD 0x801C      STR      R8,[SP, #+28]
   \       0x6E   0x9706             STR      R7,[SP, #+24]
   \       0x70   0x9605             STR      R6,[SP, #+20]
   \       0x72   0x9504             STR      R5,[SP, #+16]
   \       0x74   0x9403             STR      R4,[SP, #+12]
   \       0x76   0x981A             LDR      R0,[SP, #+104]
   \       0x78   0x9002             STR      R0,[SP, #+8]
   \       0x7A   0x9819             LDR      R0,[SP, #+100]
   \       0x7C   0x9001             STR      R0,[SP, #+4]
   \       0x7E   0x9818             LDR      R0,[SP, #+96]
   \       0x80   0x9000             STR      R0,[SP, #+0]
   \       0x82   0x9B0E             LDR      R3,[SP, #+56]
   \       0x84   0x9A0D             LDR      R2,[SP, #+52]
   \       0x86   0x990C             LDR      R1,[SP, #+48]
   \       0x88   0x4650             MOV      R0,R10
   \       0x8A   0x.... 0x....      BL       mbedtls_psa_aead_decrypt
   \       0x8E   0xE016             B.N      ??psa_driver_wrapper_aead_decrypt_4
   \                     ??psa_driver_wrapper_aead_decrypt_1: (+1)
   \       0x90   0xF8CD 0x9020      STR      R9,[SP, #+32]
   \       0x94   0xF8CD 0x801C      STR      R8,[SP, #+28]
   \       0x98   0x9706             STR      R7,[SP, #+24]
   \       0x9A   0x9605             STR      R6,[SP, #+20]
   \       0x9C   0x9504             STR      R5,[SP, #+16]
   \       0x9E   0x9403             STR      R4,[SP, #+12]
   \       0xA0   0x981A             LDR      R0,[SP, #+104]
   \       0xA2   0x9002             STR      R0,[SP, #+8]
   \       0xA4   0x9819             LDR      R0,[SP, #+100]
   \       0xA6   0x9001             STR      R0,[SP, #+4]
   \       0xA8   0x9818             LDR      R0,[SP, #+96]
   \       0xAA   0x9000             STR      R0,[SP, #+0]
   \       0xAC   0x9B0E             LDR      R3,[SP, #+56]
   \       0xAE   0x9A0D             LDR      R2,[SP, #+52]
   \       0xB0   0x990C             LDR      R1,[SP, #+48]
   \       0xB2   0x4650             MOV      R0,R10
   \       0xB4   0x.... 0x....      BL       sli_se_opaque_aead_decrypt
   \       0xB8   0xE001             B.N      ??psa_driver_wrapper_aead_decrypt_4
   \                     ??psa_driver_wrapper_aead_decrypt_2: (+1)
   \       0xBA   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_decrypt_4: (+1)
   \       0xBE   0xB00F             ADD      SP,SP,#+60
   \       0xC0   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_encrypt_setup(psa_aead_operation_t *, psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t)
   \                     psa_driver_wrapper_aead_encrypt_setup: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0A             LDR      R7,[SP, #+40]
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \       0x16   0xEA5F 0x2919      LSRS     R9,R9,#+8
   \       0x1A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x1E   0xD003             BEQ.N    ??psa_driver_wrapper_aead_encrypt_setup_0
   \       0x20   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x24   0xD01D             BEQ.N    ??psa_driver_wrapper_aead_encrypt_setup_1
   \       0x26   0xE02A             B.N      ??psa_driver_wrapper_aead_encrypt_setup_2
   \                     ??psa_driver_wrapper_aead_encrypt_setup_0: (+1)
   \       0x28   0x2004             MOVS     R0,#+4
   \       0x2A   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \       0x2E   0x9700             STR      R7,[SP, #+0]
   \       0x30   0x0033             MOVS     R3,R6
   \       0x32   0x002A             MOVS     R2,R5
   \       0x34   0x0021             MOVS     R1,R4
   \       0x36   0xF11A 0x0018      ADDS     R0,R10,#+24
   \       0x3A   0x.... 0x....      BL       sli_se_transparent_aead_encrypt_setup
   \       0x3E   0x4683             MOV      R11,R0
   \       0x40   0xF11B 0x0F86      CMN      R11,#+134
   \       0x44   0xD001             BEQ.N    ??psa_driver_wrapper_aead_encrypt_setup_3
   \       0x46   0x4658             MOV      R0,R11
   \       0x48   0xE01B             B.N      ??psa_driver_wrapper_aead_encrypt_setup_4
   \                     ??psa_driver_wrapper_aead_encrypt_setup_3: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \       0x50   0x9700             STR      R7,[SP, #+0]
   \       0x52   0x0033             MOVS     R3,R6
   \       0x54   0x002A             MOVS     R2,R5
   \       0x56   0x0021             MOVS     R1,R4
   \       0x58   0xF11A 0x0018      ADDS     R0,R10,#+24
   \       0x5C   0x.... 0x....      BL       mbedtls_psa_aead_encrypt_setup
   \       0x60   0xE00F             B.N      ??psa_driver_wrapper_aead_encrypt_setup_4
   \                     ??psa_driver_wrapper_aead_encrypt_setup_1: (+1)
   \       0x62   0x9700             STR      R7,[SP, #+0]
   \       0x64   0x0033             MOVS     R3,R6
   \       0x66   0x002A             MOVS     R2,R5
   \       0x68   0x0021             MOVS     R1,R4
   \       0x6A   0xF11A 0x0018      ADDS     R0,R10,#+24
   \       0x6E   0x.... 0x....      BL       sli_se_opaque_aead_encrypt_setup
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD102             BNE.N    ??psa_driver_wrapper_aead_encrypt_setup_5
   \       0x76   0x2105             MOVS     R1,#+5
   \       0x78   0xF8CA 0x1000      STR      R1,[R10, #+0]
   \                     ??psa_driver_wrapper_aead_encrypt_setup_5: (+1)
   \       0x7C   0xE001             B.N      ??psa_driver_wrapper_aead_encrypt_setup_4
   \                     ??psa_driver_wrapper_aead_encrypt_setup_2: (+1)
   \       0x7E   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_encrypt_setup_4: (+1)
   \       0x82   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_decrypt_setup(psa_aead_operation_t *, psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t)
   \                     psa_driver_wrapper_aead_decrypt_setup: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0A             LDR      R7,[SP, #+40]
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \       0x16   0xEA5F 0x2919      LSRS     R9,R9,#+8
   \       0x1A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x1E   0xD003             BEQ.N    ??psa_driver_wrapper_aead_decrypt_setup_0
   \       0x20   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x24   0xD01D             BEQ.N    ??psa_driver_wrapper_aead_decrypt_setup_1
   \       0x26   0xE02A             B.N      ??psa_driver_wrapper_aead_decrypt_setup_2
   \                     ??psa_driver_wrapper_aead_decrypt_setup_0: (+1)
   \       0x28   0x2004             MOVS     R0,#+4
   \       0x2A   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \       0x2E   0x9700             STR      R7,[SP, #+0]
   \       0x30   0x0033             MOVS     R3,R6
   \       0x32   0x002A             MOVS     R2,R5
   \       0x34   0x0021             MOVS     R1,R4
   \       0x36   0xF11A 0x0018      ADDS     R0,R10,#+24
   \       0x3A   0x.... 0x....      BL       sli_se_transparent_aead_decrypt_setup
   \       0x3E   0x4683             MOV      R11,R0
   \       0x40   0xF11B 0x0F86      CMN      R11,#+134
   \       0x44   0xD001             BEQ.N    ??psa_driver_wrapper_aead_decrypt_setup_3
   \       0x46   0x4658             MOV      R0,R11
   \       0x48   0xE01B             B.N      ??psa_driver_wrapper_aead_decrypt_setup_4
   \                     ??psa_driver_wrapper_aead_decrypt_setup_3: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \       0x50   0x9700             STR      R7,[SP, #+0]
   \       0x52   0x0033             MOVS     R3,R6
   \       0x54   0x002A             MOVS     R2,R5
   \       0x56   0x0021             MOVS     R1,R4
   \       0x58   0xF11A 0x0018      ADDS     R0,R10,#+24
   \       0x5C   0x.... 0x....      BL       mbedtls_psa_aead_decrypt_setup
   \       0x60   0xE00F             B.N      ??psa_driver_wrapper_aead_decrypt_setup_4
   \                     ??psa_driver_wrapper_aead_decrypt_setup_1: (+1)
   \       0x62   0x9700             STR      R7,[SP, #+0]
   \       0x64   0x0033             MOVS     R3,R6
   \       0x66   0x002A             MOVS     R2,R5
   \       0x68   0x0021             MOVS     R1,R4
   \       0x6A   0xF11A 0x0018      ADDS     R0,R10,#+24
   \       0x6E   0x.... 0x....      BL       sli_se_opaque_aead_decrypt_setup
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD102             BNE.N    ??psa_driver_wrapper_aead_decrypt_setup_5
   \       0x76   0x2105             MOVS     R1,#+5
   \       0x78   0xF8CA 0x1000      STR      R1,[R10, #+0]
   \                     ??psa_driver_wrapper_aead_decrypt_setup_5: (+1)
   \       0x7C   0xE001             B.N      ??psa_driver_wrapper_aead_decrypt_setup_4
   \                     ??psa_driver_wrapper_aead_decrypt_setup_2: (+1)
   \       0x7E   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_decrypt_setup_4: (+1)
   \       0x82   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_set_nonce(psa_aead_operation_t *, uint8_t const *, size_t)
   \                     psa_driver_wrapper_aead_set_nonce: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD004             BEQ.N    ??psa_driver_wrapper_aead_set_nonce_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD009             BEQ.N    ??psa_driver_wrapper_aead_set_nonce_1
   \       0x12   0x2805             CMP      R0,#+5
   \       0x14   0xD00E             BEQ.N    ??psa_driver_wrapper_aead_set_nonce_2
   \       0x16   0xE014             B.N      ??psa_driver_wrapper_aead_set_nonce_3
   \                     ??psa_driver_wrapper_aead_set_nonce_0: (+1)
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x20   0x.... 0x....      BL       mbedtls_psa_aead_set_nonce
   \       0x24   0xE00F             B.N      ??psa_driver_wrapper_aead_set_nonce_4
   \                     ??psa_driver_wrapper_aead_set_nonce_1: (+1)
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x2E   0x.... 0x....      BL       sli_se_transparent_aead_set_nonce
   \       0x32   0xE008             B.N      ??psa_driver_wrapper_aead_set_nonce_4
   \                     ??psa_driver_wrapper_aead_set_nonce_2: (+1)
   \       0x34   0x0032             MOVS     R2,R6
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x3C   0x.... 0x....      BL       sli_se_opaque_aead_set_nonce
   \       0x40   0xE001             B.N      ??psa_driver_wrapper_aead_set_nonce_4
   \                     ??psa_driver_wrapper_aead_set_nonce_3: (+1)
   \       0x42   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_set_nonce_4: (+1)
   \       0x46   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_set_lengths(psa_aead_operation_t *, size_t, size_t)
   \                     psa_driver_wrapper_aead_set_lengths: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD004             BEQ.N    ??psa_driver_wrapper_aead_set_lengths_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD009             BEQ.N    ??psa_driver_wrapper_aead_set_lengths_1
   \       0x12   0x2805             CMP      R0,#+5
   \       0x14   0xD00E             BEQ.N    ??psa_driver_wrapper_aead_set_lengths_2
   \       0x16   0xE014             B.N      ??psa_driver_wrapper_aead_set_lengths_3
   \                     ??psa_driver_wrapper_aead_set_lengths_0: (+1)
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x20   0x.... 0x....      BL       mbedtls_psa_aead_set_lengths
   \       0x24   0xE00F             B.N      ??psa_driver_wrapper_aead_set_lengths_4
   \                     ??psa_driver_wrapper_aead_set_lengths_1: (+1)
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x2E   0x.... 0x....      BL       sli_se_transparent_aead_set_lengths
   \       0x32   0xE008             B.N      ??psa_driver_wrapper_aead_set_lengths_4
   \                     ??psa_driver_wrapper_aead_set_lengths_2: (+1)
   \       0x34   0x0032             MOVS     R2,R6
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x3C   0x.... 0x....      BL       sli_se_opaque_aead_set_lengths
   \       0x40   0xE001             B.N      ??psa_driver_wrapper_aead_set_lengths_4
   \                     ??psa_driver_wrapper_aead_set_lengths_3: (+1)
   \       0x42   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_set_lengths_4: (+1)
   \       0x46   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_update_ad(psa_aead_operation_t *, uint8_t const *, size_t)
   \                     psa_driver_wrapper_aead_update_ad: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD004             BEQ.N    ??psa_driver_wrapper_aead_update_ad_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD009             BEQ.N    ??psa_driver_wrapper_aead_update_ad_1
   \       0x12   0x2805             CMP      R0,#+5
   \       0x14   0xD00E             BEQ.N    ??psa_driver_wrapper_aead_update_ad_2
   \       0x16   0xE014             B.N      ??psa_driver_wrapper_aead_update_ad_3
   \                     ??psa_driver_wrapper_aead_update_ad_0: (+1)
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x20   0x.... 0x....      BL       mbedtls_psa_aead_update_ad
   \       0x24   0xE00F             B.N      ??psa_driver_wrapper_aead_update_ad_4
   \                     ??psa_driver_wrapper_aead_update_ad_1: (+1)
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x2E   0x.... 0x....      BL       sli_se_transparent_aead_update_ad
   \       0x32   0xE008             B.N      ??psa_driver_wrapper_aead_update_ad_4
   \                     ??psa_driver_wrapper_aead_update_ad_2: (+1)
   \       0x34   0x0032             MOVS     R2,R6
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x3C   0x.... 0x....      BL       sli_se_opaque_aead_update_ad
   \       0x40   0xE001             B.N      ??psa_driver_wrapper_aead_update_ad_4
   \                     ??psa_driver_wrapper_aead_update_ad_3: (+1)
   \       0x42   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_update_ad_4: (+1)
   \       0x46   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_update(psa_aead_operation_t *, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_aead_update: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \       0x10   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD004             BEQ.N    ??psa_driver_wrapper_aead_update_0
   \       0x1A   0x2804             CMP      R0,#+4
   \       0x1C   0xD00E             BEQ.N    ??psa_driver_wrapper_aead_update_1
   \       0x1E   0x2805             CMP      R0,#+5
   \       0x20   0xD018             BEQ.N    ??psa_driver_wrapper_aead_update_2
   \       0x22   0xE023             B.N      ??psa_driver_wrapper_aead_update_3
   \                     ??psa_driver_wrapper_aead_update_0: (+1)
   \       0x24   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x28   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x2C   0x003B             MOVS     R3,R7
   \       0x2E   0x0032             MOVS     R2,R6
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x36   0x.... 0x....      BL       mbedtls_psa_aead_update
   \       0x3A   0xE019             B.N      ??psa_driver_wrapper_aead_update_4
   \                     ??psa_driver_wrapper_aead_update_1: (+1)
   \       0x3C   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x40   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x44   0x003B             MOVS     R3,R7
   \       0x46   0x0032             MOVS     R2,R6
   \       0x48   0x0029             MOVS     R1,R5
   \       0x4A   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x4E   0x.... 0x....      BL       sli_se_transparent_aead_update
   \       0x52   0xE00D             B.N      ??psa_driver_wrapper_aead_update_4
   \                     ??psa_driver_wrapper_aead_update_2: (+1)
   \       0x54   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x58   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x5C   0x003B             MOVS     R3,R7
   \       0x5E   0x0032             MOVS     R2,R6
   \       0x60   0x0029             MOVS     R1,R5
   \       0x62   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x66   0x.... 0x....      BL       sli_se_opaque_aead_update
   \       0x6A   0xE001             B.N      ??psa_driver_wrapper_aead_update_4
   \                     ??psa_driver_wrapper_aead_update_3: (+1)
   \       0x6C   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_update_4: (+1)
   \       0x70   0xE8BD 0x83FE      POP      {R1-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_finish(psa_aead_operation_t *, uint8_t *, size_t, size_t *, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_aead_finish: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \       0x10   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   \       0x14   0xF8DD 0xA038      LDR      R10,[SP, #+56]
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD004             BEQ.N    ??psa_driver_wrapper_aead_finish_0
   \       0x1E   0x2804             CMP      R0,#+4
   \       0x20   0xD010             BEQ.N    ??psa_driver_wrapper_aead_finish_1
   \       0x22   0x2805             CMP      R0,#+5
   \       0x24   0xD01C             BEQ.N    ??psa_driver_wrapper_aead_finish_2
   \       0x26   0xE029             B.N      ??psa_driver_wrapper_aead_finish_3
   \                     ??psa_driver_wrapper_aead_finish_0: (+1)
   \       0x28   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \       0x2C   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x30   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x34   0x003B             MOVS     R3,R7
   \       0x36   0x0032             MOVS     R2,R6
   \       0x38   0x0029             MOVS     R1,R5
   \       0x3A   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x3E   0x.... 0x....      BL       mbedtls_psa_aead_finish
   \       0x42   0xE01D             B.N      ??psa_driver_wrapper_aead_finish_4
   \                     ??psa_driver_wrapper_aead_finish_1: (+1)
   \       0x44   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \       0x48   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x4C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x50   0x003B             MOVS     R3,R7
   \       0x52   0x0032             MOVS     R2,R6
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x5A   0x.... 0x....      BL       sli_se_transparent_aead_finish
   \       0x5E   0xE00F             B.N      ??psa_driver_wrapper_aead_finish_4
   \                     ??psa_driver_wrapper_aead_finish_2: (+1)
   \       0x60   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \       0x64   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x68   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x6C   0x003B             MOVS     R3,R7
   \       0x6E   0x0032             MOVS     R2,R6
   \       0x70   0x0029             MOVS     R1,R5
   \       0x72   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x76   0x.... 0x....      BL       sli_se_opaque_aead_finish
   \       0x7A   0xE001             B.N      ??psa_driver_wrapper_aead_finish_4
   \                     ??psa_driver_wrapper_aead_finish_3: (+1)
   \       0x7C   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_finish_4: (+1)
   \       0x80   0xB004             ADD      SP,SP,#+16
   \       0x82   0xE8BD 0x87F0      POP      {R4-R10,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_verify(psa_aead_operation_t *, uint8_t *, size_t, size_t *, uint8_t const *, size_t)
   \                     psa_driver_wrapper_aead_verify: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \       0x12   0xF8DD 0x904C      LDR      R9,[SP, #+76]
   \       0x16   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD004             BEQ.N    ??psa_driver_wrapper_aead_verify_0
   \       0x1E   0x2804             CMP      R0,#+4
   \       0x20   0xD027             BEQ.N    ??psa_driver_wrapper_aead_verify_1
   \       0x22   0x2805             CMP      R0,#+5
   \       0x24   0xD031             BEQ.N    ??psa_driver_wrapper_aead_verify_2
   \       0x26   0xE03C             B.N      ??psa_driver_wrapper_aead_verify_3
   \                     ??psa_driver_wrapper_aead_verify_0: (+1)
   \       0x28   0xF07F 0x0A96      MVNS     R10,#+150
   \       0x2C   0xA803             ADD      R0,SP,#+12
   \       0x2E   0x9002             STR      R0,[SP, #+8]
   \       0x30   0x2010             MOVS     R0,#+16
   \       0x32   0x9001             STR      R0,[SP, #+4]
   \       0x34   0xA804             ADD      R0,SP,#+16
   \       0x36   0x9000             STR      R0,[SP, #+0]
   \       0x38   0x003B             MOVS     R3,R7
   \       0x3A   0x0032             MOVS     R2,R6
   \       0x3C   0x0029             MOVS     R1,R5
   \       0x3E   0xF11B 0x0018      ADDS     R0,R11,#+24
   \       0x42   0x.... 0x....      BL       mbedtls_psa_aead_finish
   \       0x46   0x0004             MOVS     R4,R0
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD10C             BNE.N    ??psa_driver_wrapper_aead_verify_4
   \       0x4C   0x9803             LDR      R0,[SP, #+12]
   \       0x4E   0x4581             CMP      R9,R0
   \       0x50   0xD106             BNE.N    ??psa_driver_wrapper_aead_verify_5
   \       0x52   0x464A             MOV      R2,R9
   \       0x54   0xA904             ADD      R1,SP,#+16
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0x.... 0x....      BL       mbedtls_ct_memcmp
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD002             BEQ.N    ??psa_driver_wrapper_aead_verify_4
   \                     ??psa_driver_wrapper_aead_verify_5: (+1)
   \       0x60   0xF07F 0x0094      MVNS     R0,#+148
   \       0x64   0x0004             MOVS     R4,R0
   \                     ??psa_driver_wrapper_aead_verify_4: (+1)
   \       0x66   0x2110             MOVS     R1,#+16
   \       0x68   0xA804             ADD      R0,SP,#+16
   \       0x6A   0x.... 0x....      BL       mbedtls_platform_zeroize
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0xE019             B.N      ??psa_driver_wrapper_aead_verify_6
   \                     ??psa_driver_wrapper_aead_verify_1: (+1)
   \       0x72   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x76   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x7A   0x003B             MOVS     R3,R7
   \       0x7C   0x0032             MOVS     R2,R6
   \       0x7E   0x0029             MOVS     R1,R5
   \       0x80   0xF11B 0x0018      ADDS     R0,R11,#+24
   \       0x84   0x.... 0x....      BL       sli_se_transparent_aead_verify
   \       0x88   0xE00D             B.N      ??psa_driver_wrapper_aead_verify_6
   \                     ??psa_driver_wrapper_aead_verify_2: (+1)
   \       0x8A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x8E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x92   0x003B             MOVS     R3,R7
   \       0x94   0x0032             MOVS     R2,R6
   \       0x96   0x0029             MOVS     R1,R5
   \       0x98   0xF11B 0x0018      ADDS     R0,R11,#+24
   \       0x9C   0x.... 0x....      BL       sli_se_opaque_aead_verify
   \       0xA0   0xE001             B.N      ??psa_driver_wrapper_aead_verify_6
   \                     ??psa_driver_wrapper_aead_verify_3: (+1)
   \       0xA2   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_verify_6: (+1)
   \       0xA6   0xB009             ADD      SP,SP,#+36
   \       0xA8   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_aead_abort(psa_aead_operation_t *)
   \                     psa_driver_wrapper_aead_abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD004             BEQ.N    ??psa_driver_wrapper_aead_abort_0
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xD007             BEQ.N    ??psa_driver_wrapper_aead_abort_1
   \        0xE   0x2805             CMP      R0,#+5
   \       0x10   0xD00A             BEQ.N    ??psa_driver_wrapper_aead_abort_2
   \       0x12   0xE00E             B.N      ??psa_driver_wrapper_aead_abort_3
   \                     ??psa_driver_wrapper_aead_abort_0: (+1)
   \       0x14   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x18   0x.... 0x....      BL       mbedtls_psa_aead_abort
   \       0x1C   0xE00B             B.N      ??psa_driver_wrapper_aead_abort_4
   \                     ??psa_driver_wrapper_aead_abort_1: (+1)
   \       0x1E   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x22   0x.... 0x....      BL       sli_se_transparent_aead_abort
   \       0x26   0xE006             B.N      ??psa_driver_wrapper_aead_abort_4
   \                     ??psa_driver_wrapper_aead_abort_2: (+1)
   \       0x28   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x2C   0x.... 0x....      BL       sli_se_opaque_aead_abort
   \       0x30   0xE001             B.N      ??psa_driver_wrapper_aead_abort_4
   \                     ??psa_driver_wrapper_aead_abort_3: (+1)
   \       0x32   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_aead_abort_4: (+1)
   \       0x36   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_mac_compute(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_mac_compute: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x9C14             LDR      R4,[SP, #+80]
   \        0xA   0x9D15             LDR      R5,[SP, #+84]
   \        0xC   0x9E16             LDR      R6,[SP, #+88]
   \        0xE   0x9F17             LDR      R7,[SP, #+92]
   \       0x10   0xF8DD 0x8060      LDR      R8,[SP, #+96]
   \       0x14   0xF07F 0x0096      MVNS     R0,#+150
   \       0x18   0x9006             STR      R0,[SP, #+24]
   \       0x1A   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x1E   0x0A00             LSRS     R0,R0,#+8
   \       0x20   0x9005             STR      R0,[SP, #+20]
   \       0x22   0x9805             LDR      R0,[SP, #+20]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD002             BEQ.N    ??psa_driver_wrapper_mac_compute_0
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD026             BEQ.N    ??psa_driver_wrapper_mac_compute_1
   \       0x2C   0xE032             B.N      ??psa_driver_wrapper_mac_compute_2
   \                     ??psa_driver_wrapper_mac_compute_0: (+1)
   \       0x2E   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0x32   0x9703             STR      R7,[SP, #+12]
   \       0x34   0x9602             STR      R6,[SP, #+8]
   \       0x36   0x9501             STR      R5,[SP, #+4]
   \       0x38   0x9400             STR      R4,[SP, #+0]
   \       0x3A   0x9B0A             LDR      R3,[SP, #+40]
   \       0x3C   0x9A09             LDR      R2,[SP, #+36]
   \       0x3E   0x9908             LDR      R1,[SP, #+32]
   \       0x40   0x4648             MOV      R0,R9
   \       0x42   0x.... 0x....      BL       sli_se_transparent_mac_compute
   \       0x46   0x4683             MOV      R11,R0
   \       0x48   0xF07F 0x0A85      MVNS     R10,#+133
   \       0x4C   0x45D3             CMP      R11,R10
   \       0x4E   0xD001             BEQ.N    ??psa_driver_wrapper_mac_compute_3
   \       0x50   0x4658             MOV      R0,R11
   \       0x52   0xE021             B.N      ??psa_driver_wrapper_mac_compute_4
   \                     ??psa_driver_wrapper_mac_compute_3: (+1)
   \       0x54   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0x58   0x9703             STR      R7,[SP, #+12]
   \       0x5A   0x9602             STR      R6,[SP, #+8]
   \       0x5C   0x9501             STR      R5,[SP, #+4]
   \       0x5E   0x9400             STR      R4,[SP, #+0]
   \       0x60   0x9B0A             LDR      R3,[SP, #+40]
   \       0x62   0x9A09             LDR      R2,[SP, #+36]
   \       0x64   0x9908             LDR      R1,[SP, #+32]
   \       0x66   0x4648             MOV      R0,R9
   \       0x68   0x.... 0x....      BL       mbedtls_psa_mac_compute
   \       0x6C   0x0001             MOVS     R1,R0
   \       0x6E   0x4551             CMP      R1,R10
   \       0x70   0xD001             BEQ.N    ??psa_driver_wrapper_mac_compute_5
   \       0x72   0x0008             MOVS     R0,R1
   \       0x74   0xE010             B.N      ??psa_driver_wrapper_mac_compute_4
   \                     ??psa_driver_wrapper_mac_compute_5: (+1)
   \       0x76   0x4650             MOV      R0,R10
   \       0x78   0xE00E             B.N      ??psa_driver_wrapper_mac_compute_4
   \                     ??psa_driver_wrapper_mac_compute_1: (+1)
   \       0x7A   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0x7E   0x9703             STR      R7,[SP, #+12]
   \       0x80   0x9602             STR      R6,[SP, #+8]
   \       0x82   0x9501             STR      R5,[SP, #+4]
   \       0x84   0x9400             STR      R4,[SP, #+0]
   \       0x86   0x9B0A             LDR      R3,[SP, #+40]
   \       0x88   0x9A09             LDR      R2,[SP, #+36]
   \       0x8A   0x9908             LDR      R1,[SP, #+32]
   \       0x8C   0x4648             MOV      R0,R9
   \       0x8E   0x.... 0x....      BL       sli_se_opaque_mac_compute
   \       0x92   0xE001             B.N      ??psa_driver_wrapper_mac_compute_4
   \                     ??psa_driver_wrapper_mac_compute_2: (+1)
   \       0x94   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_mac_compute_4: (+1)
   \       0x98   0xB00B             ADD      SP,SP,#+44
   \       0x9A   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_mac_sign_setup(psa_mac_operation_t *, psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t)
   \                     psa_driver_wrapper_mac_sign_setup: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0A             LDR      R7,[SP, #+40]
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \       0x16   0xEA5F 0x2919      LSRS     R9,R9,#+8
   \       0x1A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x1E   0xD003             BEQ.N    ??psa_driver_wrapper_mac_sign_setup_0
   \       0x20   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x24   0xD029             BEQ.N    ??psa_driver_wrapper_mac_sign_setup_1
   \       0x26   0xE036             B.N      ??psa_driver_wrapper_mac_sign_setup_2
   \                     ??psa_driver_wrapper_mac_sign_setup_0: (+1)
   \       0x28   0x9700             STR      R7,[SP, #+0]
   \       0x2A   0x0033             MOVS     R3,R6
   \       0x2C   0x002A             MOVS     R2,R5
   \       0x2E   0x0021             MOVS     R1,R4
   \       0x30   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x34   0x.... 0x....      BL       sli_se_transparent_mac_sign_setup
   \       0x38   0x4683             MOV      R11,R0
   \       0x3A   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x3E   0xD102             BNE.N    ??psa_driver_wrapper_mac_sign_setup_3
   \       0x40   0x2004             MOVS     R0,#+4
   \       0x42   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \                     ??psa_driver_wrapper_mac_sign_setup_3: (+1)
   \       0x46   0xF07F 0x0885      MVNS     R8,#+133
   \       0x4A   0x45C3             CMP      R11,R8
   \       0x4C   0xD001             BEQ.N    ??psa_driver_wrapper_mac_sign_setup_4
   \       0x4E   0x4658             MOV      R0,R11
   \       0x50   0xE023             B.N      ??psa_driver_wrapper_mac_sign_setup_5
   \                     ??psa_driver_wrapper_mac_sign_setup_4: (+1)
   \       0x52   0x9700             STR      R7,[SP, #+0]
   \       0x54   0x0033             MOVS     R3,R6
   \       0x56   0x002A             MOVS     R2,R5
   \       0x58   0x0021             MOVS     R1,R4
   \       0x5A   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x5E   0x.... 0x....      BL       mbedtls_psa_mac_sign_setup
   \       0x62   0x0001             MOVS     R1,R0
   \       0x64   0x2900             CMP      R1,#+0
   \       0x66   0xD102             BNE.N    ??psa_driver_wrapper_mac_sign_setup_6
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \                     ??psa_driver_wrapper_mac_sign_setup_6: (+1)
   \       0x6E   0x4541             CMP      R1,R8
   \       0x70   0xD001             BEQ.N    ??psa_driver_wrapper_mac_sign_setup_7
   \       0x72   0x0008             MOVS     R0,R1
   \       0x74   0xE011             B.N      ??psa_driver_wrapper_mac_sign_setup_5
   \                     ??psa_driver_wrapper_mac_sign_setup_7: (+1)
   \       0x76   0x4640             MOV      R0,R8
   \       0x78   0xE00F             B.N      ??psa_driver_wrapper_mac_sign_setup_5
   \                     ??psa_driver_wrapper_mac_sign_setup_1: (+1)
   \       0x7A   0x9700             STR      R7,[SP, #+0]
   \       0x7C   0x0033             MOVS     R3,R6
   \       0x7E   0x002A             MOVS     R2,R5
   \       0x80   0x0021             MOVS     R1,R4
   \       0x82   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x86   0x.... 0x....      BL       sli_se_opaque_mac_sign_setup
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD102             BNE.N    ??psa_driver_wrapper_mac_sign_setup_8
   \       0x8E   0x2105             MOVS     R1,#+5
   \       0x90   0xF8CA 0x1000      STR      R1,[R10, #+0]
   \                     ??psa_driver_wrapper_mac_sign_setup_8: (+1)
   \       0x94   0xE001             B.N      ??psa_driver_wrapper_mac_sign_setup_5
   \                     ??psa_driver_wrapper_mac_sign_setup_2: (+1)
   \       0x96   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_mac_sign_setup_5: (+1)
   \       0x9A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_mac_verify_setup(psa_mac_operation_t *, psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t)
   \                     psa_driver_wrapper_mac_verify_setup: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0A             LDR      R7,[SP, #+40]
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \       0x16   0xEA5F 0x2919      LSRS     R9,R9,#+8
   \       0x1A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x1E   0xD003             BEQ.N    ??psa_driver_wrapper_mac_verify_setup_0
   \       0x20   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x24   0xD029             BEQ.N    ??psa_driver_wrapper_mac_verify_setup_1
   \       0x26   0xE036             B.N      ??psa_driver_wrapper_mac_verify_setup_2
   \                     ??psa_driver_wrapper_mac_verify_setup_0: (+1)
   \       0x28   0x9700             STR      R7,[SP, #+0]
   \       0x2A   0x0033             MOVS     R3,R6
   \       0x2C   0x002A             MOVS     R2,R5
   \       0x2E   0x0021             MOVS     R1,R4
   \       0x30   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x34   0x.... 0x....      BL       sli_se_transparent_mac_verify_setup
   \       0x38   0x4683             MOV      R11,R0
   \       0x3A   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x3E   0xD102             BNE.N    ??psa_driver_wrapper_mac_verify_setup_3
   \       0x40   0x2004             MOVS     R0,#+4
   \       0x42   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \                     ??psa_driver_wrapper_mac_verify_setup_3: (+1)
   \       0x46   0xF07F 0x0885      MVNS     R8,#+133
   \       0x4A   0x45C3             CMP      R11,R8
   \       0x4C   0xD001             BEQ.N    ??psa_driver_wrapper_mac_verify_setup_4
   \       0x4E   0x4658             MOV      R0,R11
   \       0x50   0xE023             B.N      ??psa_driver_wrapper_mac_verify_setup_5
   \                     ??psa_driver_wrapper_mac_verify_setup_4: (+1)
   \       0x52   0x9700             STR      R7,[SP, #+0]
   \       0x54   0x0033             MOVS     R3,R6
   \       0x56   0x002A             MOVS     R2,R5
   \       0x58   0x0021             MOVS     R1,R4
   \       0x5A   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x5E   0x.... 0x....      BL       mbedtls_psa_mac_verify_setup
   \       0x62   0x0001             MOVS     R1,R0
   \       0x64   0x2900             CMP      R1,#+0
   \       0x66   0xD102             BNE.N    ??psa_driver_wrapper_mac_verify_setup_6
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \                     ??psa_driver_wrapper_mac_verify_setup_6: (+1)
   \       0x6E   0x4541             CMP      R1,R8
   \       0x70   0xD001             BEQ.N    ??psa_driver_wrapper_mac_verify_setup_7
   \       0x72   0x0008             MOVS     R0,R1
   \       0x74   0xE011             B.N      ??psa_driver_wrapper_mac_verify_setup_5
   \                     ??psa_driver_wrapper_mac_verify_setup_7: (+1)
   \       0x76   0x4640             MOV      R0,R8
   \       0x78   0xE00F             B.N      ??psa_driver_wrapper_mac_verify_setup_5
   \                     ??psa_driver_wrapper_mac_verify_setup_1: (+1)
   \       0x7A   0x9700             STR      R7,[SP, #+0]
   \       0x7C   0x0033             MOVS     R3,R6
   \       0x7E   0x002A             MOVS     R2,R5
   \       0x80   0x0021             MOVS     R1,R4
   \       0x82   0xF11A 0x0008      ADDS     R0,R10,#+8
   \       0x86   0x.... 0x....      BL       sli_se_opaque_mac_verify_setup
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD102             BNE.N    ??psa_driver_wrapper_mac_verify_setup_8
   \       0x8E   0x2105             MOVS     R1,#+5
   \       0x90   0xF8CA 0x1000      STR      R1,[R10, #+0]
   \                     ??psa_driver_wrapper_mac_verify_setup_8: (+1)
   \       0x94   0xE001             B.N      ??psa_driver_wrapper_mac_verify_setup_5
   \                     ??psa_driver_wrapper_mac_verify_setup_2: (+1)
   \       0x96   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_mac_verify_setup_5: (+1)
   \       0x9A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_mac_update(psa_mac_operation_t *, uint8_t const *, size_t)
   \                     psa_driver_wrapper_mac_update: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD004             BEQ.N    ??psa_driver_wrapper_mac_update_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD009             BEQ.N    ??psa_driver_wrapper_mac_update_1
   \       0x12   0x2805             CMP      R0,#+5
   \       0x14   0xD00E             BEQ.N    ??psa_driver_wrapper_mac_update_2
   \       0x16   0xE014             B.N      ??psa_driver_wrapper_mac_update_3
   \                     ??psa_driver_wrapper_mac_update_0: (+1)
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x20   0x.... 0x....      BL       mbedtls_psa_mac_update
   \       0x24   0xE00F             B.N      ??psa_driver_wrapper_mac_update_4
   \                     ??psa_driver_wrapper_mac_update_1: (+1)
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x2E   0x.... 0x....      BL       sli_se_transparent_mac_update
   \       0x32   0xE008             B.N      ??psa_driver_wrapper_mac_update_4
   \                     ??psa_driver_wrapper_mac_update_2: (+1)
   \       0x34   0x0032             MOVS     R2,R6
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x3C   0x.... 0x....      BL       sli_se_opaque_mac_update
   \       0x40   0xE001             B.N      ??psa_driver_wrapper_mac_update_4
   \                     ??psa_driver_wrapper_mac_update_3: (+1)
   \       0x42   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_mac_update_4: (+1)
   \       0x46   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_mac_sign_finish(psa_mac_operation_t *, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_mac_sign_finish: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD004             BEQ.N    ??psa_driver_wrapper_mac_sign_finish_0
   \       0x10   0x2804             CMP      R0,#+4
   \       0x12   0xD00A             BEQ.N    ??psa_driver_wrapper_mac_sign_finish_1
   \       0x14   0x2805             CMP      R0,#+5
   \       0x16   0xD010             BEQ.N    ??psa_driver_wrapper_mac_sign_finish_2
   \       0x18   0xE017             B.N      ??psa_driver_wrapper_mac_sign_finish_3
   \                     ??psa_driver_wrapper_mac_sign_finish_0: (+1)
   \       0x1A   0x003B             MOVS     R3,R7
   \       0x1C   0x0032             MOVS     R2,R6
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x24   0x.... 0x....      BL       mbedtls_psa_mac_sign_finish
   \       0x28   0xE011             B.N      ??psa_driver_wrapper_mac_sign_finish_4
   \                     ??psa_driver_wrapper_mac_sign_finish_1: (+1)
   \       0x2A   0x003B             MOVS     R3,R7
   \       0x2C   0x0032             MOVS     R2,R6
   \       0x2E   0x0029             MOVS     R1,R5
   \       0x30   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x34   0x.... 0x....      BL       sli_se_transparent_mac_sign_finish
   \       0x38   0xE009             B.N      ??psa_driver_wrapper_mac_sign_finish_4
   \                     ??psa_driver_wrapper_mac_sign_finish_2: (+1)
   \       0x3A   0x003B             MOVS     R3,R7
   \       0x3C   0x0032             MOVS     R2,R6
   \       0x3E   0x0029             MOVS     R1,R5
   \       0x40   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x44   0x.... 0x....      BL       sli_se_opaque_mac_sign_finish
   \       0x48   0xE001             B.N      ??psa_driver_wrapper_mac_sign_finish_4
   \                     ??psa_driver_wrapper_mac_sign_finish_3: (+1)
   \       0x4A   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_mac_sign_finish_4: (+1)
   \       0x4E   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_mac_verify_finish(psa_mac_operation_t *, uint8_t const *, size_t)
   \                     psa_driver_wrapper_mac_verify_finish: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD004             BEQ.N    ??psa_driver_wrapper_mac_verify_finish_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD009             BEQ.N    ??psa_driver_wrapper_mac_verify_finish_1
   \       0x12   0x2805             CMP      R0,#+5
   \       0x14   0xD00E             BEQ.N    ??psa_driver_wrapper_mac_verify_finish_2
   \       0x16   0xE014             B.N      ??psa_driver_wrapper_mac_verify_finish_3
   \                     ??psa_driver_wrapper_mac_verify_finish_0: (+1)
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x20   0x.... 0x....      BL       mbedtls_psa_mac_verify_finish
   \       0x24   0xE00F             B.N      ??psa_driver_wrapper_mac_verify_finish_4
   \                     ??psa_driver_wrapper_mac_verify_finish_1: (+1)
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x2E   0x.... 0x....      BL       sli_se_transparent_mac_verify_finish
   \       0x32   0xE008             B.N      ??psa_driver_wrapper_mac_verify_finish_4
   \                     ??psa_driver_wrapper_mac_verify_finish_2: (+1)
   \       0x34   0x0032             MOVS     R2,R6
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x3C   0x.... 0x....      BL       sli_se_opaque_mac_verify_finish
   \       0x40   0xE001             B.N      ??psa_driver_wrapper_mac_verify_finish_4
   \                     ??psa_driver_wrapper_mac_verify_finish_3: (+1)
   \       0x42   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_mac_verify_finish_4: (+1)
   \       0x46   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_mac_abort(psa_mac_operation_t *)
   \                     psa_driver_wrapper_mac_abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD004             BEQ.N    ??psa_driver_wrapper_mac_abort_0
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xD007             BEQ.N    ??psa_driver_wrapper_mac_abort_1
   \        0xE   0x2805             CMP      R0,#+5
   \       0x10   0xD00A             BEQ.N    ??psa_driver_wrapper_mac_abort_2
   \       0x12   0xE00E             B.N      ??psa_driver_wrapper_mac_abort_3
   \                     ??psa_driver_wrapper_mac_abort_0: (+1)
   \       0x14   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x18   0x.... 0x....      BL       mbedtls_psa_mac_abort
   \       0x1C   0xE00B             B.N      ??psa_driver_wrapper_mac_abort_4
   \                     ??psa_driver_wrapper_mac_abort_1: (+1)
   \       0x1E   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x22   0x.... 0x....      BL       sli_se_transparent_mac_abort
   \       0x26   0xE006             B.N      ??psa_driver_wrapper_mac_abort_4
   \                     ??psa_driver_wrapper_mac_abort_2: (+1)
   \       0x28   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x2C   0x.... 0x....      BL       sli_se_opaque_mac_abort
   \       0x30   0xE001             B.N      ??psa_driver_wrapper_mac_abort_4
   \                     ??psa_driver_wrapper_mac_abort_3: (+1)
   \       0x32   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_mac_abort_4: (+1)
   \       0x36   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_asymmetric_encrypt(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_asymmetric_encrypt: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0xF07F 0x0996      MVNS     R9,#+150
   \       0x12   0x686C             LDR      R4,[R5, #+4]
   \       0x14   0x0A24             LSRS     R4,R4,#+8
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD114             BNE.N    ??psa_driver_wrapper_asymmetric_encrypt_0
   \       0x1A   0x9814             LDR      R0,[SP, #+80]
   \       0x1C   0x9006             STR      R0,[SP, #+24]
   \       0x1E   0x9813             LDR      R0,[SP, #+76]
   \       0x20   0x9005             STR      R0,[SP, #+20]
   \       0x22   0x9812             LDR      R0,[SP, #+72]
   \       0x24   0x9004             STR      R0,[SP, #+16]
   \       0x26   0x9811             LDR      R0,[SP, #+68]
   \       0x28   0x9003             STR      R0,[SP, #+12]
   \       0x2A   0x9810             LDR      R0,[SP, #+64]
   \       0x2C   0x9002             STR      R0,[SP, #+8]
   \       0x2E   0x980F             LDR      R0,[SP, #+60]
   \       0x30   0x9001             STR      R0,[SP, #+4]
   \       0x32   0x980E             LDR      R0,[SP, #+56]
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x4643             MOV      R3,R8
   \       0x38   0x003A             MOVS     R2,R7
   \       0x3A   0x0031             MOVS     R1,R6
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x.... 0x....      BL       mbedtls_psa_asymmetric_encrypt
   \       0x42   0xE001             B.N      ??psa_driver_wrapper_asymmetric_encrypt_1
   \                     ??psa_driver_wrapper_asymmetric_encrypt_0: (+1)
   \       0x44   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_asymmetric_encrypt_1: (+1)
   \       0x48   0xB007             ADD      SP,SP,#+28
   \       0x4A   0xE8BD 0x83F0      POP      {R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_asymmetric_decrypt(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_asymmetric_decrypt: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0xF07F 0x0996      MVNS     R9,#+150
   \       0x12   0x686C             LDR      R4,[R5, #+4]
   \       0x14   0x0A24             LSRS     R4,R4,#+8
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD114             BNE.N    ??psa_driver_wrapper_asymmetric_decrypt_0
   \       0x1A   0x9814             LDR      R0,[SP, #+80]
   \       0x1C   0x9006             STR      R0,[SP, #+24]
   \       0x1E   0x9813             LDR      R0,[SP, #+76]
   \       0x20   0x9005             STR      R0,[SP, #+20]
   \       0x22   0x9812             LDR      R0,[SP, #+72]
   \       0x24   0x9004             STR      R0,[SP, #+16]
   \       0x26   0x9811             LDR      R0,[SP, #+68]
   \       0x28   0x9003             STR      R0,[SP, #+12]
   \       0x2A   0x9810             LDR      R0,[SP, #+64]
   \       0x2C   0x9002             STR      R0,[SP, #+8]
   \       0x2E   0x980F             LDR      R0,[SP, #+60]
   \       0x30   0x9001             STR      R0,[SP, #+4]
   \       0x32   0x980E             LDR      R0,[SP, #+56]
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x4643             MOV      R3,R8
   \       0x38   0x003A             MOVS     R2,R7
   \       0x3A   0x0031             MOVS     R1,R6
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x.... 0x....      BL       mbedtls_psa_asymmetric_decrypt
   \       0x42   0xE001             B.N      ??psa_driver_wrapper_asymmetric_decrypt_1
   \                     ??psa_driver_wrapper_asymmetric_decrypt_0: (+1)
   \       0x44   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_driver_wrapper_asymmetric_decrypt_1: (+1)
   \       0x48   0xB007             ADD      SP,SP,#+28
   \       0x4A   0xE8BD 0x83F0      POP      {R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t psa_driver_wrapper_key_agreement(psa_key_attributes_t const *, uint8_t const *, size_t, uint32_t, uint8_t const *, size_t, uint8_t *, size_t, size_t *)
   \                     psa_driver_wrapper_key_agreement: (+1)
   \        0x0   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x001C             MOVS     R4,R3
   \        0xA   0x9D12             LDR      R5,[SP, #+72]
   \        0xC   0x9E13             LDR      R6,[SP, #+76]
   \        0xE   0x9F14             LDR      R7,[SP, #+80]
   \       0x10   0xF8DD 0x8054      LDR      R8,[SP, #+84]
   \       0x14   0xF8DD 0x9058      LDR      R9,[SP, #+88]
   \       0x18   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1C   0x9006             STR      R0,[SP, #+24]
   \       0x1E   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \       0x22   0x0A00             LSRS     R0,R0,#+8
   \       0x24   0x9005             STR      R0,[SP, #+20]
   \       0x26   0x9805             LDR      R0,[SP, #+20]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??psa_driver_wrapper_key_agreement_0
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD021             BEQ.N    ??psa_driver_wrapper_key_agreement_1
   \       0x30   0xE02E             B.N      ??psa_driver_wrapper_key_agreement_2
   \                     ??psa_driver_wrapper_key_agreement_0: (+1)
   \       0x32   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x36   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x3A   0x9702             STR      R7,[SP, #+8]
   \       0x3C   0x9601             STR      R6,[SP, #+4]
   \       0x3E   0x9500             STR      R5,[SP, #+0]
   \       0x40   0x9B08             LDR      R3,[SP, #+32]
   \       0x42   0x9A07             LDR      R2,[SP, #+28]
   \       0x44   0x4659             MOV      R1,R11
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       sli_se_transparent_key_agreement
   \       0x4C   0x4682             MOV      R10,R0
   \       0x4E   0xF11A 0x0F86      CMN      R10,#+134
   \       0x52   0xD001             BEQ.N    ??psa_driver_wrapper_key_agreement_3
   \       0x54   0x4650             MOV      R0,R10
   \       0x56   0xE01D             B.N      ??psa_driver_wrapper_key_agreement_4
   \                     ??psa_driver_wrapper_key_agreement_3: (+1)
   \       0x58   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x5C   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x60   0x9702             STR      R7,[SP, #+8]
   \       0x62   0x9601             STR      R6,[SP, #+4]
   \       0x64   0x9500             STR      R5,[SP, #+0]
   \       0x66   0x0023             MOVS     R3,R4
   \       0x68   0x9A08             LDR      R2,[SP, #+32]
   \       0x6A   0x9907             LDR      R1,[SP, #+28]
   \       0x6C   0x4658             MOV      R0,R11
   \       0x6E   0x.... 0x....      BL       psa_key_agreement_raw_builtin
   \       0x72   0xE00F             B.N      ??psa_driver_wrapper_key_agreement_4
   \                     ??psa_driver_wrapper_key_agreement_1: (+1)
   \       0x74   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x78   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x7C   0x9702             STR      R7,[SP, #+8]
   \       0x7E   0x9601             STR      R6,[SP, #+4]
   \       0x80   0x9500             STR      R5,[SP, #+0]
   \       0x82   0x9B08             LDR      R3,[SP, #+32]
   \       0x84   0x9A07             LDR      R2,[SP, #+28]
   \       0x86   0x4659             MOV      R1,R11
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x.... 0x....      BL       sli_se_opaque_key_agreement
   \       0x8E   0xE001             B.N      ??psa_driver_wrapper_key_agreement_4
   \                     ??psa_driver_wrapper_key_agreement_2: (+1)
   \       0x90   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_driver_wrapper_key_agreement_4: (+1)
   \       0x94   0xB009             ADD      SP,SP,#+36
   \       0x96   0xE8BD 0x8FF0      POP      {R4-R11,PC}
     37          #include "psa_crypto_driver_wrappers_no_static.h"
     38          #include "psa_crypto_ecp.h"
     39          #include "psa_crypto_ffdh.h"
     40          #include "psa_crypto_hash.h"
     41          #include "psa_crypto_mac.h"
     42          #include "psa_crypto_rsa.h"
     43          #include "psa_crypto_ecp.h"
     44          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
     45          #include "psa_crypto_se.h"
     46          #endif
     47          #include "psa_crypto_slot_management.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int psa_key_lifetime_is_external(uint32_t)
   \                     psa_key_lifetime_is_external: (+1)
   \        0x0   0x0A00             LSRS     R0,R0,#+8
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD001             BEQ.N    ??psa_key_lifetime_is_external_0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE000             B.N      ??psa_key_lifetime_is_external_1
   \                     ??psa_key_lifetime_is_external_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \                     ??psa_key_lifetime_is_external_1: (+1)
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x4770             BX       LR
     48          /* Include internal declarations that are useful for implementing persistently
     49           * stored keys. */
     50          #include "psa_crypto_storage.h"
     51          
     52          #include "psa_crypto_random_impl.h"
     53          
     54          #include <stdlib.h>
     55          #include <string.h>
     56          #include "mbedtls/platform.h"
     57          
     58          #include "mbedtls/aes.h"
     59          #include "mbedtls/asn1.h"
     60          #include "mbedtls/asn1write.h"
     61          #include "mbedtls/bignum.h"
     62          #include "mbedtls/camellia.h"
     63          #include "mbedtls/chacha20.h"
     64          #include "mbedtls/chachapoly.h"
     65          #include "mbedtls/cipher.h"
     66          #include "mbedtls/ccm.h"
     67          #include "mbedtls/cmac.h"
     68          #include "mbedtls/constant_time.h"
     69          #include "mbedtls/des.h"
     70          #include "mbedtls/ecdh.h"
     71          #include "mbedtls/ecp.h"
     72          #include "mbedtls/entropy.h"
     73          #include "mbedtls/error.h"
     74          #include "mbedtls/gcm.h"
     75          #include "mbedtls/md5.h"
     76          #include "mbedtls/md.h"
     77          #include "mbedtls/pk.h"
     78          #include "pk_wrap.h"
     79          #include "mbedtls/platform_util.h"
     80          #include "mbedtls/psa_util.h"
     81          #include "mbedtls/error.h"
     82          #include "mbedtls/ripemd160.h"
     83          #include "mbedtls/rsa.h"
     84          #include "mbedtls/sha1.h"
     85          #include "mbedtls/sha256.h"
     86          #include "mbedtls/sha512.h"
     87          #include "mbedtls/threading.h"
     88          #include "md_psa.h"
     89          
     90          #include "sli_psa_crypto.h"
     91          
     92          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF) ||          \
     93              defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT) ||  \
     94              defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND)
     95          #define BUILTIN_ALG_ANY_HKDF 1
     96          #endif
     97          
     98          /****************************************************************/
     99          /* Global data, support functions and library management */
    100          /****************************************************************/
    101          

   \                                 In section .text, align 2, keep-with-next
    102          static int key_type_is_raw_bytes(psa_key_type_t type)
    103          {
    104              return PSA_KEY_TYPE_IS_UNSTRUCTURED(type);
   \                     key_type_is_raw_bytes: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB289             UXTH     R1,R1
   \        0x4   0xF411 0x41E0      ANDS     R1,R1,#0x7000
   \        0x8   0xF5B1 0x5F80      CMP      R1,#+4096
   \        0xC   0xD005             BEQ.N    ??key_type_is_raw_bytes_0
   \        0xE   0xB280             UXTH     R0,R0
   \       0x10   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x14   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x18   0xD101             BNE.N    ??key_type_is_raw_bytes_1
   \                     ??key_type_is_raw_bytes_0: (+1)
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??key_type_is_raw_bytes_2
   \                     ??key_type_is_raw_bytes_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??key_type_is_raw_bytes_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x4770             BX       LR
    105          }
    106          
    107          /* Values for psa_global_data_t::rng_state */
    108          #define RNG_NOT_INITIALIZED 0
    109          #define RNG_INITIALIZED 1
    110          #define RNG_SEEDED 2
    111          
    112          typedef struct {
    113              uint8_t initialized;
    114              uint8_t rng_state;
    115              uint8_t drivers_initialized;
    116              mbedtls_psa_random_context_t rng;
    117          } psa_global_data_t;
    118          

   \                                 In section .bss, align 4
    119          static psa_global_data_t global_data;
   \                     global_data:
   \        0x0                      DS8 12
    120          
    121          #if !defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
    122          mbedtls_psa_drbg_context_t *const mbedtls_psa_random_state =
    123              &global_data.rng.drbg;
    124          #endif
    125          
    126          #define GUARD_MODULE_INITIALIZED        \
    127              if (global_data.initialized == 0)  \
    128              return PSA_ERROR_BAD_STATE;
    129          
    130          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_IMPORT) ||       \
    131              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_PUBLIC_KEY) ||     \
    132              defined(PSA_WANT_KEY_TYPE_DH_KEY_PAIR_GENERATE)
    133          static int psa_is_dh_key_size_valid(size_t bits)
    134          {
    135              if (bits != 2048 && bits != 3072 && bits != 4096 &&
    136                  bits != 6144 && bits != 8192) {
    137                  return 0;
    138              }
    139          
    140              return 1;
    141          }
    142          #endif /* MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_IMPORT ||
    143                    MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_PUBLIC_KEY ||
    144                    PSA_WANT_KEY_TYPE_DH_KEY_PAIR_GENERATE */
    145          

   \                                 In section .text, align 2, keep-with-next
    146          psa_status_t mbedtls_to_psa_error(int ret)
    147          {
   \                     mbedtls_to_psa_error: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    148              /* Mbed TLS error codes can combine a high-level error code and a
    149               * low-level error code. The low-level error usually reflects the
    150               * root cause better, so dispatch on that preferably. */
    151              int low_level_ret = -(-ret & 0x007f);
   \        0x2   0x4251             RSBS     R1,R2,#+0
   \        0x4   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \        0x8   0x4249             RSBS     R1,R1,#+0
    152              switch (low_level_ret != 0 ? low_level_ret : ret) {
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD001             BEQ.N    ??mbedtls_to_psa_error_0
   \        0xE   0x000B             MOVS     R3,R1
   \       0x10   0xE000             B.N      ??mbedtls_to_psa_error_1
   \                     ??mbedtls_to_psa_error_0: (+1)
   \       0x12   0x0013             MOVS     R3,R2
   \                     ??mbedtls_to_psa_error_1: (+1)
   \       0x14   0x2B00             CMP      R3,#+0
   \       0x16   0xF000 0x80A2      BEQ.W    ??mbedtls_to_psa_error_2
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x1E   0x1A1B             SUBS     R3,R3,R0
   \       0x20   0xF000 0x80C6      BEQ.W    ??mbedtls_to_psa_error_3
   \       0x24   0x3B80             SUBS     R3,R3,#+128
   \       0x26   0xF000 0x80C0      BEQ.W    ??mbedtls_to_psa_error_4
   \       0x2A   0x3B80             SUBS     R3,R3,#+128
   \       0x2C   0xF000 0x80BA      BEQ.W    ??mbedtls_to_psa_error_5
   \       0x30   0x3B80             SUBS     R3,R3,#+128
   \       0x32   0xF000 0x80B4      BEQ.W    ??mbedtls_to_psa_error_6
   \       0x36   0x3B80             SUBS     R3,R3,#+128
   \       0x38   0xF000 0x80AE      BEQ.W    ??mbedtls_to_psa_error_7
   \       0x3C   0x3B80             SUBS     R3,R3,#+128
   \       0x3E   0xF000 0x80A8      BEQ.W    ??mbedtls_to_psa_error_8
   \       0x42   0x3B80             SUBS     R3,R3,#+128
   \       0x44   0xF000 0x80A2      BEQ.W    ??mbedtls_to_psa_error_9
   \       0x48   0xF44F 0x6070      MOV      R0,#+3840
   \       0x4C   0x1A1B             SUBS     R3,R3,R0
   \       0x4E   0xF000 0x80BB      BEQ.W    ??mbedtls_to_psa_error_10
   \       0x52   0x3B80             SUBS     R3,R3,#+128
   \       0x54   0xF000 0x80B5      BEQ.W    ??mbedtls_to_psa_error_11
   \       0x58   0x3B80             SUBS     R3,R3,#+128
   \       0x5A   0xF000 0x80AF      BEQ.W    ??mbedtls_to_psa_error_12
   \       0x5E   0xF44F 0x7080      MOV      R0,#+256
   \       0x62   0x1A1B             SUBS     R3,R3,R0
   \       0x64   0xF000 0x80EC      BEQ.W    ??mbedtls_to_psa_error_13
   \       0x68   0x3B80             SUBS     R3,R3,#+128
   \       0x6A   0xF000 0x80EC      BEQ.W    ??mbedtls_to_psa_error_14
   \       0x6E   0x3B80             SUBS     R3,R3,#+128
   \       0x70   0xF000 0x80EC      BEQ.W    ??mbedtls_to_psa_error_15
   \       0x74   0x3B80             SUBS     R3,R3,#+128
   \       0x76   0xF000 0x80EC      BEQ.W    ??mbedtls_to_psa_error_16
   \       0x7A   0x3B80             SUBS     R3,R3,#+128
   \       0x7C   0xF000 0x80EC      BEQ.W    ??mbedtls_to_psa_error_17
   \       0x80   0x3B80             SUBS     R3,R3,#+128
   \       0x82   0xF000 0x80EC      BEQ.W    ??mbedtls_to_psa_error_18
   \       0x86   0x3B80             SUBS     R3,R3,#+128
   \       0x88   0xF000 0x80DA      BEQ.W    ??mbedtls_to_psa_error_13
   \       0x8C   0x3B80             SUBS     R3,R3,#+128
   \       0x8E   0xF000 0x80E0      BEQ.W    ??mbedtls_to_psa_error_16
   \       0x92   0xF44F 0x6048      MOV      R0,#+3200
   \       0x96   0x1A1B             SUBS     R3,R3,R0
   \       0x98   0xF000 0x80AE      BEQ.W    ??mbedtls_to_psa_error_19
   \       0x9C   0x3B80             SUBS     R3,R3,#+128
   \       0x9E   0xF000 0x80AE      BEQ.W    ??mbedtls_to_psa_error_20
   \       0xA2   0x3B80             SUBS     R3,R3,#+128
   \       0xA4   0xF000 0x80AB      BEQ.W    ??mbedtls_to_psa_error_20
   \       0xA8   0x3B80             SUBS     R3,R3,#+128
   \       0xAA   0xF000 0x80AB      BEQ.W    ??mbedtls_to_psa_error_21
   \       0xAE   0x3B80             SUBS     R3,R3,#+128
   \       0xB0   0xF000 0x80AB      BEQ.W    ??mbedtls_to_psa_error_22
   \       0xB4   0x3B80             SUBS     R3,R3,#+128
   \       0xB6   0xF000 0x80A8      BEQ.W    ??mbedtls_to_psa_error_22
   \       0xBA   0x3B80             SUBS     R3,R3,#+128
   \       0xBC   0xF000 0x80A8      BEQ.W    ??mbedtls_to_psa_error_23
   \       0xC0   0x3B80             SUBS     R3,R3,#+128
   \       0xC2   0xF000 0x80A8      BEQ.W    ??mbedtls_to_psa_error_24
   \       0xC6   0x3B80             SUBS     R3,R3,#+128
   \       0xC8   0xF000 0x80A5      BEQ.W    ??mbedtls_to_psa_error_24
   \       0xCC   0x3B80             SUBS     R3,R3,#+128
   \       0xCE   0xF000 0x80A5      BEQ.W    ??mbedtls_to_psa_error_25
   \       0xD2   0x3B80             SUBS     R3,R3,#+128
   \       0xD4   0xF000 0x80A5      BEQ.W    ??mbedtls_to_psa_error_26
   \       0xD8   0x3B80             SUBS     R3,R3,#+128
   \       0xDA   0xF000 0x80A2      BEQ.W    ??mbedtls_to_psa_error_26
   \       0xDE   0x3B80             SUBS     R3,R3,#+128
   \       0xE0   0xF000 0x809F      BEQ.W    ??mbedtls_to_psa_error_26
   \       0xE4   0x3B80             SUBS     R3,R3,#+128
   \       0xE6   0xF000 0x809F      BEQ.W    ??mbedtls_to_psa_error_27
   \       0xEA   0x3B80             SUBS     R3,R3,#+128
   \       0xEC   0xF000 0x809F      BEQ.W    ??mbedtls_to_psa_error_28
   \       0xF0   0xF643 0x000E      MOVW     R0,#+14350
   \       0xF4   0x1A1B             SUBS     R3,R3,R0
   \       0xF6   0xF000 0x80A0      BEQ.W    ??mbedtls_to_psa_error_29
   \       0xFA   0x1E9B             SUBS     R3,R3,#+2
   \       0xFC   0xF000 0x809A      BEQ.W    ??mbedtls_to_psa_error_30
   \      0x100   0x1E9B             SUBS     R3,R3,#+2
   \      0x102   0xF000 0x80AF      BEQ.W    ??mbedtls_to_psa_error_31
   \      0x106   0x1E9B             SUBS     R3,R3,#+2
   \      0x108   0xD037             BEQ.N    ??mbedtls_to_psa_error_32
   \      0x10A   0x1E9B             SUBS     R3,R3,#+2
   \      0x10C   0xD032             BEQ.N    ??mbedtls_to_psa_error_33
   \      0x10E   0x1E9B             SUBS     R3,R3,#+2
   \      0x110   0xD02D             BEQ.N    ??mbedtls_to_psa_error_34
   \      0x112   0x1E9B             SUBS     R3,R3,#+2
   \      0x114   0xD02B             BEQ.N    ??mbedtls_to_psa_error_34
   \      0x116   0x1E9B             SUBS     R3,R3,#+2
   \      0x118   0xD029             BEQ.N    ??mbedtls_to_psa_error_34
   \      0x11A   0x1E9B             SUBS     R3,R3,#+2
   \      0x11C   0xD027             BEQ.N    ??mbedtls_to_psa_error_34
   \      0x11E   0x1E9B             SUBS     R3,R3,#+2
   \      0x120   0xD025             BEQ.N    ??mbedtls_to_psa_error_34
   \      0x122   0x3B20             SUBS     R3,R3,#+32
   \      0x124   0xD047             BEQ.N    ??mbedtls_to_psa_error_35
   \      0x126   0x1EDB             SUBS     R3,R3,#+3
   \      0x128   0x2B01             CMP      R3,#+1
   \      0x12A   0xD944             BLS.N    ??mbedtls_to_psa_error_35
   \      0x12C   0x3B1B             SUBS     R3,R3,#+27
   \      0x12E   0xD018             BEQ.N    ??mbedtls_to_psa_error_36
   \      0x130   0x1E5B             SUBS     R3,R3,#+1
   \      0x132   0xD019             BEQ.N    ??mbedtls_to_psa_error_37
   \      0x134   0x1E5B             SUBS     R3,R3,#+1
   \      0x136   0xD014             BEQ.N    ??mbedtls_to_psa_error_36
   \      0x138   0x3B10             SUBS     R3,R3,#+16
   \      0x13A   0xD05A             BEQ.N    ??mbedtls_to_psa_error_38
   \      0x13C   0x1E5B             SUBS     R3,R3,#+1
   \      0x13E   0xD022             BEQ.N    ??mbedtls_to_psa_error_39
   \      0x140   0x1E5B             SUBS     R3,R3,#+1
   \      0x142   0xD053             BEQ.N    ??mbedtls_to_psa_error_40
   \      0x144   0x1E5B             SUBS     R3,R3,#+1
   \      0x146   0xD01B             BEQ.N    ??mbedtls_to_psa_error_41
   \      0x148   0x1E5B             SUBS     R3,R3,#+1
   \      0x14A   0xD04C             BEQ.N    ??mbedtls_to_psa_error_42
   \      0x14C   0x1E9B             SUBS     R3,R3,#+2
   \      0x14E   0xD047             BEQ.N    ??mbedtls_to_psa_error_43
   \      0x150   0x1E9B             SUBS     R3,R3,#+2
   \      0x152   0xD042             BEQ.N    ??mbedtls_to_psa_error_44
   \      0x154   0x1E9B             SUBS     R3,R3,#+2
   \      0x156   0xD03D             BEQ.N    ??mbedtls_to_psa_error_45
   \      0x158   0x1E9B             SUBS     R3,R3,#+2
   \      0x15A   0xD038             BEQ.N    ??mbedtls_to_psa_error_46
   \      0x15C   0xE085             B.N      ??mbedtls_to_psa_error_47
    153                  case 0:
    154                      return PSA_SUCCESS;
   \                     ??mbedtls_to_psa_error_2: (+1)
   \      0x15E   0x2000             MOVS     R0,#+0
   \      0x160   0xE085             B.N      ??mbedtls_to_psa_error_48
    155          
    156          #if defined(MBEDTLS_AES_C)
    157                  case MBEDTLS_ERR_AES_INVALID_KEY_LENGTH:
    158                  case MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH:
    159                      return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_to_psa_error_36: (+1)
   \      0x162   0xF07F 0x0085      MVNS     R0,#+133
   \      0x166   0xE082             B.N      ??mbedtls_to_psa_error_48
    160                  case MBEDTLS_ERR_AES_BAD_INPUT_DATA:
    161                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_37: (+1)
   \      0x168   0xF07F 0x0086      MVNS     R0,#+134
   \      0x16C   0xE07F             B.N      ??mbedtls_to_psa_error_48
    162          #endif
    163          
    164          #if defined(MBEDTLS_ASN1_PARSE_C) || defined(MBEDTLS_ASN1_WRITE_C)
    165                  case MBEDTLS_ERR_ASN1_OUT_OF_DATA:
    166                  case MBEDTLS_ERR_ASN1_UNEXPECTED_TAG:
    167                  case MBEDTLS_ERR_ASN1_INVALID_LENGTH:
    168                  case MBEDTLS_ERR_ASN1_LENGTH_MISMATCH:
    169                  case MBEDTLS_ERR_ASN1_INVALID_DATA:
    170                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_34: (+1)
   \      0x16E   0xF07F 0x0086      MVNS     R0,#+134
   \      0x172   0xE07C             B.N      ??mbedtls_to_psa_error_48
    171                  case MBEDTLS_ERR_ASN1_ALLOC_FAILED:
    172                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \                     ??mbedtls_to_psa_error_33: (+1)
   \      0x174   0xF07F 0x008C      MVNS     R0,#+140
   \      0x178   0xE079             B.N      ??mbedtls_to_psa_error_48
    173                  case MBEDTLS_ERR_ASN1_BUF_TOO_SMALL:
    174                      return PSA_ERROR_BUFFER_TOO_SMALL;
   \                     ??mbedtls_to_psa_error_32: (+1)
   \      0x17A   0xF07F 0x0089      MVNS     R0,#+137
   \      0x17E   0xE076             B.N      ??mbedtls_to_psa_error_48
    175          #endif
    176          
    177          #if defined(MBEDTLS_CAMELLIA_C)
    178                  case MBEDTLS_ERR_CAMELLIA_BAD_INPUT_DATA:
    179                  case MBEDTLS_ERR_CAMELLIA_INVALID_INPUT_LENGTH:
    180                      return PSA_ERROR_NOT_SUPPORTED;
    181          #endif
    182          
    183          #if defined(MBEDTLS_CCM_C)
    184                  case MBEDTLS_ERR_CCM_BAD_INPUT:
    185                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_41: (+1)
   \      0x180   0xF07F 0x0086      MVNS     R0,#+134
   \      0x184   0xE073             B.N      ??mbedtls_to_psa_error_48
    186                  case MBEDTLS_ERR_CCM_AUTH_FAILED:
    187                      return PSA_ERROR_INVALID_SIGNATURE;
   \                     ??mbedtls_to_psa_error_39: (+1)
   \      0x186   0xF07F 0x0094      MVNS     R0,#+148
   \      0x18A   0xE070             B.N      ??mbedtls_to_psa_error_48
    188          #endif
    189          
    190          #if defined(MBEDTLS_CHACHA20_C)
    191                  case MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA:
    192                      return PSA_ERROR_INVALID_ARGUMENT;
    193          #endif
    194          
    195          #if defined(MBEDTLS_CHACHAPOLY_C)
    196                  case MBEDTLS_ERR_CHACHAPOLY_BAD_STATE:
    197                      return PSA_ERROR_BAD_STATE;
    198                  case MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED:
    199                      return PSA_ERROR_INVALID_SIGNATURE;
    200          #endif
    201          
    202          #if defined(MBEDTLS_CIPHER_C)
    203                  case MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE:
    204                      return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_to_psa_error_9: (+1)
   \      0x18C   0xF07F 0x0085      MVNS     R0,#+133
   \      0x190   0xE06D             B.N      ??mbedtls_to_psa_error_48
    205                  case MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA:
    206                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_8: (+1)
   \      0x192   0xF07F 0x0086      MVNS     R0,#+134
   \      0x196   0xE06A             B.N      ??mbedtls_to_psa_error_48
    207                  case MBEDTLS_ERR_CIPHER_ALLOC_FAILED:
    208                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \                     ??mbedtls_to_psa_error_7: (+1)
   \      0x198   0xF07F 0x008C      MVNS     R0,#+140
   \      0x19C   0xE067             B.N      ??mbedtls_to_psa_error_48
    209                  case MBEDTLS_ERR_CIPHER_INVALID_PADDING:
    210                      return PSA_ERROR_INVALID_PADDING;
   \                     ??mbedtls_to_psa_error_6: (+1)
   \      0x19E   0xF07F 0x0095      MVNS     R0,#+149
   \      0x1A2   0xE064             B.N      ??mbedtls_to_psa_error_48
    211                  case MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED:
    212                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_5: (+1)
   \      0x1A4   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1A8   0xE061             B.N      ??mbedtls_to_psa_error_48
    213                  case MBEDTLS_ERR_CIPHER_AUTH_FAILED:
    214                      return PSA_ERROR_INVALID_SIGNATURE;
   \                     ??mbedtls_to_psa_error_4: (+1)
   \      0x1AA   0xF07F 0x0094      MVNS     R0,#+148
   \      0x1AE   0xE05E             B.N      ??mbedtls_to_psa_error_48
    215                  case MBEDTLS_ERR_CIPHER_INVALID_CONTEXT:
    216                      return PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_to_psa_error_3: (+1)
   \      0x1B0   0xF07F 0x0096      MVNS     R0,#+150
   \      0x1B4   0xE05B             B.N      ??mbedtls_to_psa_error_48
    217          #endif
    218          
    219          #if !(defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) ||      \
    220                      defined(MBEDTLS_PSA_HMAC_DRBG_MD_TYPE))
    221                  /* Only check CTR_DRBG error codes if underlying mbedtls_xxx
    222                   * functions are passed a CTR_DRBG instance. */
    223                  case MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED:
    224                      return PSA_ERROR_INSUFFICIENT_ENTROPY;
    225                  case MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG:
    226                  case MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG:
    227                      return PSA_ERROR_NOT_SUPPORTED;
    228                  case MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR:
    229                      return PSA_ERROR_INSUFFICIENT_ENTROPY;
    230          #endif
    231          
    232          #if defined(MBEDTLS_DES_C)
    233                  case MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH:
    234                      return PSA_ERROR_NOT_SUPPORTED;
    235          #endif
    236          
    237                  case MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED:
    238                  case MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE:
    239                  case MBEDTLS_ERR_ENTROPY_SOURCE_FAILED:
    240                      return PSA_ERROR_INSUFFICIENT_ENTROPY;
   \                     ??mbedtls_to_psa_error_35: (+1)
   \      0x1B6   0xF07F 0x0093      MVNS     R0,#+147
   \      0x1BA   0xE058             B.N      ??mbedtls_to_psa_error_48
    241          
    242          #if defined(MBEDTLS_GCM_C)
    243                  case MBEDTLS_ERR_GCM_AUTH_FAILED:
    244                      return PSA_ERROR_INVALID_SIGNATURE;
    245                  case MBEDTLS_ERR_GCM_BUFFER_TOO_SMALL:
    246                      return PSA_ERROR_BUFFER_TOO_SMALL;
    247                  case MBEDTLS_ERR_GCM_BAD_INPUT:
    248                      return PSA_ERROR_INVALID_ARGUMENT;
    249          #endif
    250          
    251          #if !defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) &&        \
    252                      defined(MBEDTLS_PSA_HMAC_DRBG_MD_TYPE)
    253                  /* Only check HMAC_DRBG error codes if underlying mbedtls_xxx
    254                   * functions are passed a HMAC_DRBG instance. */
    255                  case MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED:
    256                      return PSA_ERROR_INSUFFICIENT_ENTROPY;
    257                  case MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG:
    258                  case MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG:
    259                      return PSA_ERROR_NOT_SUPPORTED;
    260                  case MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR:
    261                      return PSA_ERROR_INSUFFICIENT_ENTROPY;
    262          #endif
    263          
    264          #if defined(MBEDTLS_MD_LIGHT)
    265                  case MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE:
    266                      return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_to_psa_error_12: (+1)
   \      0x1BC   0xF07F 0x0085      MVNS     R0,#+133
   \      0x1C0   0xE055             B.N      ??mbedtls_to_psa_error_48
    267                  case MBEDTLS_ERR_MD_BAD_INPUT_DATA:
    268                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_11: (+1)
   \      0x1C2   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1C6   0xE052             B.N      ??mbedtls_to_psa_error_48
    269                  case MBEDTLS_ERR_MD_ALLOC_FAILED:
    270                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \                     ??mbedtls_to_psa_error_10: (+1)
   \      0x1C8   0xF07F 0x008C      MVNS     R0,#+140
   \      0x1CC   0xE04F             B.N      ??mbedtls_to_psa_error_48
    271          #if defined(MBEDTLS_FS_IO)
    272                  case MBEDTLS_ERR_MD_FILE_IO_ERROR:
    273                      return PSA_ERROR_STORAGE_FAILURE;
    274          #endif
    275          #endif
    276          
    277          #if defined(MBEDTLS_BIGNUM_C)
    278          #if defined(MBEDTLS_FS_IO)
    279                  case MBEDTLS_ERR_MPI_FILE_IO_ERROR:
    280                      return PSA_ERROR_STORAGE_FAILURE;
    281          #endif
    282                  case MBEDTLS_ERR_MPI_BAD_INPUT_DATA:
    283                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_46: (+1)
   \      0x1CE   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1D2   0xE04C             B.N      ??mbedtls_to_psa_error_48
    284                  case MBEDTLS_ERR_MPI_INVALID_CHARACTER:
    285                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_45: (+1)
   \      0x1D4   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1D8   0xE049             B.N      ??mbedtls_to_psa_error_48
    286                  case MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL:
    287                      return PSA_ERROR_BUFFER_TOO_SMALL;
   \                     ??mbedtls_to_psa_error_44: (+1)
   \      0x1DA   0xF07F 0x0089      MVNS     R0,#+137
   \      0x1DE   0xE046             B.N      ??mbedtls_to_psa_error_48
    288                  case MBEDTLS_ERR_MPI_NEGATIVE_VALUE:
    289                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_43: (+1)
   \      0x1E0   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1E4   0xE043             B.N      ??mbedtls_to_psa_error_48
    290                  case MBEDTLS_ERR_MPI_DIVISION_BY_ZERO:
    291                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_42: (+1)
   \      0x1E6   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1EA   0xE040             B.N      ??mbedtls_to_psa_error_48
    292                  case MBEDTLS_ERR_MPI_NOT_ACCEPTABLE:
    293                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_40: (+1)
   \      0x1EC   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1F0   0xE03D             B.N      ??mbedtls_to_psa_error_48
    294                  case MBEDTLS_ERR_MPI_ALLOC_FAILED:
    295                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \                     ??mbedtls_to_psa_error_38: (+1)
   \      0x1F2   0xF07F 0x008C      MVNS     R0,#+140
   \      0x1F6   0xE03A             B.N      ??mbedtls_to_psa_error_48
    296          #endif
    297          
    298          #if defined(MBEDTLS_PK_C)
    299                  case MBEDTLS_ERR_PK_ALLOC_FAILED:
    300                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \                     ??mbedtls_to_psa_error_19: (+1)
   \      0x1F8   0xF07F 0x008C      MVNS     R0,#+140
   \      0x1FC   0xE037             B.N      ??mbedtls_to_psa_error_48
    301                  case MBEDTLS_ERR_PK_TYPE_MISMATCH:
    302                  case MBEDTLS_ERR_PK_BAD_INPUT_DATA:
    303                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_20: (+1)
   \      0x1FE   0xF07F 0x0086      MVNS     R0,#+134
   \      0x202   0xE034             B.N      ??mbedtls_to_psa_error_48
    304          #if defined(MBEDTLS_PSA_CRYPTO_STORAGE_C) || defined(MBEDTLS_FS_IO) || \
    305                      defined(MBEDTLS_PSA_ITS_FILE_C)
    306                  case MBEDTLS_ERR_PK_FILE_IO_ERROR:
    307                      return PSA_ERROR_STORAGE_FAILURE;
   \                     ??mbedtls_to_psa_error_21: (+1)
   \      0x204   0xF07F 0x0091      MVNS     R0,#+145
   \      0x208   0xE031             B.N      ??mbedtls_to_psa_error_48
    308          #endif
    309                  case MBEDTLS_ERR_PK_KEY_INVALID_VERSION:
    310                  case MBEDTLS_ERR_PK_KEY_INVALID_FORMAT:
    311                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_22: (+1)
   \      0x20A   0xF07F 0x0086      MVNS     R0,#+134
   \      0x20E   0xE02E             B.N      ??mbedtls_to_psa_error_48
    312                  case MBEDTLS_ERR_PK_UNKNOWN_PK_ALG:
    313                      return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_to_psa_error_23: (+1)
   \      0x210   0xF07F 0x0085      MVNS     R0,#+133
   \      0x214   0xE02B             B.N      ??mbedtls_to_psa_error_48
    314                  case MBEDTLS_ERR_PK_PASSWORD_REQUIRED:
    315                  case MBEDTLS_ERR_PK_PASSWORD_MISMATCH:
    316                      return PSA_ERROR_NOT_PERMITTED;
   \                     ??mbedtls_to_psa_error_24: (+1)
   \      0x216   0xF07F 0x0084      MVNS     R0,#+132
   \      0x21A   0xE028             B.N      ??mbedtls_to_psa_error_48
    317                  case MBEDTLS_ERR_PK_INVALID_PUBKEY:
    318                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_25: (+1)
   \      0x21C   0xF07F 0x0086      MVNS     R0,#+134
   \      0x220   0xE025             B.N      ??mbedtls_to_psa_error_48
    319                  case MBEDTLS_ERR_PK_INVALID_ALG:
    320                  case MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE:
    321                  case MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE:
    322                      return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_to_psa_error_26: (+1)
   \      0x222   0xF07F 0x0085      MVNS     R0,#+133
   \      0x226   0xE022             B.N      ??mbedtls_to_psa_error_48
    323                  case MBEDTLS_ERR_PK_SIG_LEN_MISMATCH:
    324                      return PSA_ERROR_INVALID_SIGNATURE;
   \                     ??mbedtls_to_psa_error_27: (+1)
   \      0x228   0xF07F 0x0094      MVNS     R0,#+148
   \      0x22C   0xE01F             B.N      ??mbedtls_to_psa_error_48
    325                  case MBEDTLS_ERR_PK_BUFFER_TOO_SMALL:
    326                      return PSA_ERROR_BUFFER_TOO_SMALL;
   \                     ??mbedtls_to_psa_error_28: (+1)
   \      0x22E   0xF07F 0x0089      MVNS     R0,#+137
   \      0x232   0xE01C             B.N      ??mbedtls_to_psa_error_48
    327          #endif
    328          
    329                  case MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED:
    330                      return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??mbedtls_to_psa_error_30: (+1)
   \      0x234   0xF07F 0x0092      MVNS     R0,#+146
   \      0x238   0xE019             B.N      ??mbedtls_to_psa_error_48
    331                  case MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:
    332                      return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_to_psa_error_29: (+1)
   \      0x23A   0xF07F 0x0085      MVNS     R0,#+133
   \      0x23E   0xE016             B.N      ??mbedtls_to_psa_error_48
    333          
    334          #if defined(MBEDTLS_RSA_C)
    335                  case MBEDTLS_ERR_RSA_BAD_INPUT_DATA:
    336                      return PSA_ERROR_INVALID_ARGUMENT;
    337                  case MBEDTLS_ERR_RSA_INVALID_PADDING:
    338                      return PSA_ERROR_INVALID_PADDING;
    339                  case MBEDTLS_ERR_RSA_KEY_GEN_FAILED:
    340                      return PSA_ERROR_HARDWARE_FAILURE;
    341                  case MBEDTLS_ERR_RSA_KEY_CHECK_FAILED:
    342                      return PSA_ERROR_INVALID_ARGUMENT;
    343                  case MBEDTLS_ERR_RSA_PUBLIC_FAILED:
    344                  case MBEDTLS_ERR_RSA_PRIVATE_FAILED:
    345                      return PSA_ERROR_CORRUPTION_DETECTED;
    346                  case MBEDTLS_ERR_RSA_VERIFY_FAILED:
    347                      return PSA_ERROR_INVALID_SIGNATURE;
    348                  case MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE:
    349                      return PSA_ERROR_BUFFER_TOO_SMALL;
    350                  case MBEDTLS_ERR_RSA_RNG_FAILED:
    351                      return PSA_ERROR_INSUFFICIENT_ENTROPY;
    352          #endif
    353          
    354          #if defined(MBEDTLS_ECP_LIGHT)
    355                  case MBEDTLS_ERR_ECP_BAD_INPUT_DATA:
    356                  case MBEDTLS_ERR_ECP_INVALID_KEY:
    357                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??mbedtls_to_psa_error_13: (+1)
   \      0x240   0xF07F 0x0086      MVNS     R0,#+134
   \      0x244   0xE013             B.N      ??mbedtls_to_psa_error_48
    358                  case MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL:
    359                      return PSA_ERROR_BUFFER_TOO_SMALL;
   \                     ??mbedtls_to_psa_error_14: (+1)
   \      0x246   0xF07F 0x0089      MVNS     R0,#+137
   \      0x24A   0xE010             B.N      ??mbedtls_to_psa_error_48
    360                  case MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE:
    361                      return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_to_psa_error_15: (+1)
   \      0x24C   0xF07F 0x0085      MVNS     R0,#+133
   \      0x250   0xE00D             B.N      ??mbedtls_to_psa_error_48
    362                  case MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH:
    363                  case MBEDTLS_ERR_ECP_VERIFY_FAILED:
    364                      return PSA_ERROR_INVALID_SIGNATURE;
   \                     ??mbedtls_to_psa_error_16: (+1)
   \      0x252   0xF07F 0x0094      MVNS     R0,#+148
   \      0x256   0xE00A             B.N      ??mbedtls_to_psa_error_48
    365                  case MBEDTLS_ERR_ECP_ALLOC_FAILED:
    366                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \                     ??mbedtls_to_psa_error_17: (+1)
   \      0x258   0xF07F 0x008C      MVNS     R0,#+140
   \      0x25C   0xE007             B.N      ??mbedtls_to_psa_error_48
    367                  case MBEDTLS_ERR_ECP_RANDOM_FAILED:
    368                      return PSA_ERROR_INSUFFICIENT_ENTROPY;
   \                     ??mbedtls_to_psa_error_18: (+1)
   \      0x25E   0xF07F 0x0093      MVNS     R0,#+147
   \      0x262   0xE004             B.N      ??mbedtls_to_psa_error_48
    369          
    370          #if defined(MBEDTLS_ECP_RESTARTABLE)
    371                  case MBEDTLS_ERR_ECP_IN_PROGRESS:
    372                      return PSA_OPERATION_INCOMPLETE;
    373          #endif
    374          #endif
    375          
    376                  case MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED:
    377                      return PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_to_psa_error_31: (+1)
   \      0x264   0xF07F 0x0096      MVNS     R0,#+150
   \      0x268   0xE001             B.N      ??mbedtls_to_psa_error_48
    378          
    379                  default:
    380                      return PSA_ERROR_GENERIC_ERROR;
   \                     ??mbedtls_to_psa_error_47: (+1)
   \      0x26A   0xF07F 0x0083      MVNS     R0,#+131
   \                     ??mbedtls_to_psa_error_48: (+1)
   \      0x26E   0x4770             BX       LR
    381              }
    382          }
    383          
    384          /**
    385           * \brief                       For output buffers which contain "tags"
    386           *                              (outputs that may be checked for validity like
    387           *                              hashes, MACs and signatures), fill the unused
    388           *                              part of the output buffer (the whole buffer on
    389           *                              error, the trailing part on success) with
    390           *                              something that isn't a valid tag (barring an
    391           *                              attack on the tag and deliberately-crafted
    392           *                              input), in case the caller doesn't check the
    393           *                              return status properly.
    394           *
    395           * \param output_buffer         Pointer to buffer to wipe. May not be NULL
    396           *                              unless \p output_buffer_size is zero.
    397           * \param status                Status of function called to generate
    398           *                              output_buffer originally
    399           * \param output_buffer_size    Size of output buffer. If zero, \p output_buffer
    400           *                              could be NULL.
    401           * \param output_buffer_length  Length of data written to output_buffer, must be
    402           *                              less than \p output_buffer_size
    403           */

   \                                 In section .text, align 2, keep-with-next
    404          static void psa_wipe_tag_output_buffer(uint8_t *output_buffer, psa_status_t status,
    405                                                 size_t output_buffer_size, size_t output_buffer_length)
    406          {
   \                     psa_wipe_tag_output_buffer: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
    407              size_t offset = 0;
   \        0xC   0x2700             MOVS     R7,#+0
    408          
    409              if (output_buffer_size == 0) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD00D             BEQ.N    ??psa_wipe_tag_output_buffer_0
    410                  /* If output_buffer_size is 0 then we have nothing to do. We must not
    411                     call memset because output_buffer may be NULL in this case */
    412                  return;
    413              }
    414          
    415              if (status == PSA_SUCCESS) {
   \                     ??psa_wipe_tag_output_buffer_1: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD100             BNE.N    ??psa_wipe_tag_output_buffer_2
    416                  offset = output_buffer_length;
   \       0x16   0x0037             MOVS     R7,R6
    417              }
    418          
    419              memset(output_buffer + offset, '!', output_buffer_size - offset);
   \                     ??psa_wipe_tag_output_buffer_2: (+1)
   \       0x18   0xEBB5 0x0807      SUBS     R8,R5,R7
   \       0x1C   0xF05F 0x0921      MOVS     R9,#+33
   \       0x20   0xEB0B 0x0A07      ADD      R10,R11,R7
   \       0x24   0x464A             MOV      R2,R9
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x4650             MOV      R0,R10
   \       0x2A   0x.... 0x....      BL       __aeabi_memset
    420          }
   \                     ??psa_wipe_tag_output_buffer_0: (+1)
   \       0x2E   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}
    421          
    422          
    423          
    424          
    425          /****************************************************************/
    426          /* Key management */
    427          /****************************************************************/
    428          
    429          #if defined(PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY)

   \                                 In section .text, align 2, keep-with-next
    430          psa_ecc_family_t mbedtls_ecc_group_to_psa(mbedtls_ecp_group_id grpid,
    431                                                    size_t *bits)
    432          {
   \                     mbedtls_ecc_group_to_psa: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    433              switch (grpid) {
   \        0x2   0x0010             MOVS     R0,R2
   \        0x4   0xB2C0             UXTB     R0,R0
   \        0x6   0x2803             CMP      R0,#+3
   \        0x8   0xD104             BNE.N    ??mbedtls_ecc_group_to_psa_0
    434          #if defined(MBEDTLS_ECP_HAVE_SECP192R1)
    435                  case MBEDTLS_ECP_DP_SECP192R1:
    436                      *bits = 192;
    437                      return PSA_ECC_FAMILY_SECP_R1;
    438          #endif
    439          #if defined(MBEDTLS_ECP_HAVE_SECP224R1)
    440                  case MBEDTLS_ECP_DP_SECP224R1:
    441                      *bits = 224;
    442                      return PSA_ECC_FAMILY_SECP_R1;
    443          #endif
    444          #if defined(MBEDTLS_ECP_HAVE_SECP256R1)
    445                  case MBEDTLS_ECP_DP_SECP256R1:
    446                      *bits = 256;
   \        0xA   0xF44F 0x7080      MOV      R0,#+256
   \        0xE   0x6008             STR      R0,[R1, #+0]
    447                      return PSA_ECC_FAMILY_SECP_R1;
   \       0x10   0x2012             MOVS     R0,#+18
   \       0x12   0xE002             B.N      ??mbedtls_ecc_group_to_psa_1
    448          #endif
    449          #if defined(MBEDTLS_ECP_HAVE_SECP384R1)
    450                  case MBEDTLS_ECP_DP_SECP384R1:
    451                      *bits = 384;
    452                      return PSA_ECC_FAMILY_SECP_R1;
    453          #endif
    454          #if defined(MBEDTLS_ECP_HAVE_SECP521R1)
    455                  case MBEDTLS_ECP_DP_SECP521R1:
    456                      *bits = 521;
    457                      return PSA_ECC_FAMILY_SECP_R1;
    458          #endif
    459          #if defined(MBEDTLS_ECP_HAVE_BP256R1)
    460                  case MBEDTLS_ECP_DP_BP256R1:
    461                      *bits = 256;
    462                      return PSA_ECC_FAMILY_BRAINPOOL_P_R1;
    463          #endif
    464          #if defined(MBEDTLS_ECP_HAVE_BP384R1)
    465                  case MBEDTLS_ECP_DP_BP384R1:
    466                      *bits = 384;
    467                      return PSA_ECC_FAMILY_BRAINPOOL_P_R1;
    468          #endif
    469          #if defined(MBEDTLS_ECP_HAVE_BP512R1)
    470                  case MBEDTLS_ECP_DP_BP512R1:
    471                      *bits = 512;
    472                      return PSA_ECC_FAMILY_BRAINPOOL_P_R1;
    473          #endif
    474          #if defined(MBEDTLS_ECP_HAVE_CURVE25519)
    475                  case MBEDTLS_ECP_DP_CURVE25519:
    476                      *bits = 255;
    477                      return PSA_ECC_FAMILY_MONTGOMERY;
    478          #endif
    479          #if defined(MBEDTLS_ECP_HAVE_SECP192K1)
    480                  case MBEDTLS_ECP_DP_SECP192K1:
    481                      *bits = 192;
    482                      return PSA_ECC_FAMILY_SECP_K1;
    483          #endif
    484          #if defined(MBEDTLS_ECP_HAVE_SECP224K1)
    485                  case MBEDTLS_ECP_DP_SECP224K1:
    486                      *bits = 224;
    487                      return PSA_ECC_FAMILY_SECP_K1;
    488          #endif
    489          #if defined(MBEDTLS_ECP_HAVE_SECP256K1)
    490                  case MBEDTLS_ECP_DP_SECP256K1:
    491                      *bits = 256;
    492                      return PSA_ECC_FAMILY_SECP_K1;
    493          #endif
    494          #if defined(MBEDTLS_ECP_HAVE_CURVE448)
    495                  case MBEDTLS_ECP_DP_CURVE448:
    496                      *bits = 448;
    497                      return PSA_ECC_FAMILY_MONTGOMERY;
    498          #endif
    499                  default:
    500                      *bits = 0;
   \                     ??mbedtls_ecc_group_to_psa_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6008             STR      R0,[R1, #+0]
    501                      return 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecc_group_to_psa_1: (+1)
   \       0x1A   0x4770             BX       LR
    502              }
    503          }
    504          

   \                                 In section .text, align 2, keep-with-next
    505          mbedtls_ecp_group_id mbedtls_ecc_group_of_psa(psa_ecc_family_t curve,
    506                                                        size_t bits,
    507                                                        int bits_is_sloppy)
    508          {
   \                     mbedtls_ecc_group_of_psa: (+1)
   \        0x0   0x0003             MOVS     R3,R0
    509              switch (curve) {
   \        0x2   0x0018             MOVS     R0,R3
   \        0x4   0xB2C0             UXTB     R0,R0
   \        0x6   0x2812             CMP      R0,#+18
   \        0x8   0xD006             BEQ.N    ??mbedtls_ecc_group_of_psa_0
   \        0xA   0x2817             CMP      R0,#+23
   \        0xC   0xD00C             BEQ.N    ??mbedtls_ecc_group_of_psa_1
   \        0xE   0x2830             CMP      R0,#+48
   \       0x10   0xD008             BEQ.N    ??mbedtls_ecc_group_of_psa_2
   \       0x12   0x2841             CMP      R0,#+65
   \       0x14   0xD007             BEQ.N    ??mbedtls_ecc_group_of_psa_3
   \       0x16   0xE007             B.N      ??mbedtls_ecc_group_of_psa_4
    510                  case PSA_ECC_FAMILY_SECP_R1:
    511                      switch (bits) {
   \                     ??mbedtls_ecc_group_of_psa_0: (+1)
   \       0x18   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x1C   0xD101             BNE.N    ??mbedtls_ecc_group_of_psa_5
    512          #if defined(PSA_WANT_ECC_SECP_R1_192)
    513                          case 192:
    514                              return MBEDTLS_ECP_DP_SECP192R1;
    515          #endif
    516          #if defined(PSA_WANT_ECC_SECP_R1_224)
    517                          case 224:
    518                              return MBEDTLS_ECP_DP_SECP224R1;
    519          #endif
    520          #if defined(PSA_WANT_ECC_SECP_R1_256)
    521                          case 256:
    522                              return MBEDTLS_ECP_DP_SECP256R1;
   \       0x1E   0x2003             MOVS     R0,#+3
   \       0x20   0xE003             B.N      ??mbedtls_ecc_group_of_psa_6
    523          #endif
    524          #if defined(PSA_WANT_ECC_SECP_R1_384)
    525                          case 384:
    526                              return MBEDTLS_ECP_DP_SECP384R1;
    527          #endif
    528          #if defined(PSA_WANT_ECC_SECP_R1_521)
    529                          case 521:
    530                              return MBEDTLS_ECP_DP_SECP521R1;
    531                          case 528:
    532                              if (bits_is_sloppy) {
    533                                  return MBEDTLS_ECP_DP_SECP521R1;
    534                              }
    535                              break;
    536          #endif
    537                      }
    538                      break;
   \                     ??mbedtls_ecc_group_of_psa_5: (+1)
   \       0x22   0xE001             B.N      ??mbedtls_ecc_group_of_psa_4
    539          
    540                  case PSA_ECC_FAMILY_BRAINPOOL_P_R1:
    541                      switch (bits) {
    542          #if defined(PSA_WANT_ECC_BRAINPOOL_P_R1_256)
    543                          case 256:
    544                              return MBEDTLS_ECP_DP_BP256R1;
    545          #endif
    546          #if defined(PSA_WANT_ECC_BRAINPOOL_P_R1_384)
    547                          case 384:
    548                              return MBEDTLS_ECP_DP_BP384R1;
    549          #endif
    550          #if defined(PSA_WANT_ECC_BRAINPOOL_P_R1_512)
    551                          case 512:
    552                              return MBEDTLS_ECP_DP_BP512R1;
    553          #endif
    554                      }
    555                      break;
   \                     ??mbedtls_ecc_group_of_psa_2: (+1)
   \       0x24   0xE000             B.N      ??mbedtls_ecc_group_of_psa_4
    556          
    557                  case PSA_ECC_FAMILY_MONTGOMERY:
    558                      switch (bits) {
    559          #if defined(PSA_WANT_ECC_MONTGOMERY_255)
    560                          case 255:
    561                              return MBEDTLS_ECP_DP_CURVE25519;
    562                          case 256:
    563                              if (bits_is_sloppy) {
    564                                  return MBEDTLS_ECP_DP_CURVE25519;
    565                              }
    566                              break;
    567          #endif
    568          #if defined(PSA_WANT_ECC_MONTGOMERY_448)
    569                          case 448:
    570                              return MBEDTLS_ECP_DP_CURVE448;
    571          #endif
    572                      }
    573                      break;
   \                     ??mbedtls_ecc_group_of_psa_3: (+1)
   \       0x26   0xE7FF             B.N      ??mbedtls_ecc_group_of_psa_4
    574          
    575                  case PSA_ECC_FAMILY_SECP_K1:
    576                      switch (bits) {
    577          #if defined(PSA_WANT_ECC_SECP_K1_192)
    578                          case 192:
    579                              return MBEDTLS_ECP_DP_SECP192K1;
    580          #endif
    581          #if defined(PSA_WANT_ECC_SECP_K1_224)
    582                          case 224:
    583                              return MBEDTLS_ECP_DP_SECP224K1;
    584          #endif
    585          #if defined(PSA_WANT_ECC_SECP_K1_256)
    586                          case 256:
    587                              return MBEDTLS_ECP_DP_SECP256K1;
    588          #endif
    589                      }
    590                      break;
    591              }
    592          
    593              (void) bits_is_sloppy;
    594              return MBEDTLS_ECP_DP_NONE;
   \                     ??mbedtls_ecc_group_of_psa_1: (+1)
   \                     ??mbedtls_ecc_group_of_psa_4: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecc_group_of_psa_6: (+1)
   \       0x2A   0x4770             BX       LR
    595          }
    596          #endif /* PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY */
    597          

   \                                 In section .text, align 2, keep-with-next
    598          psa_status_t psa_validate_unstructured_key_bit_size(psa_key_type_t type,
    599                                                              size_t bits)
    600          {
   \                     psa_validate_unstructured_key_bit_size: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    601              /* Check that the bit size is acceptable for the key type */
    602              switch (type) {
   \        0x2   0x0013             MOVS     R3,R2
   \        0x4   0xB29B             UXTH     R3,R3
   \        0x6   0xF241 0x0001      MOVW     R0,#+4097
   \        0xA   0x1A1B             SUBS     R3,R3,R0
   \        0xC   0xD00E             BEQ.N    ??psa_validate_unstructured_key_bit_size_0
   \        0xE   0x3BFF             SUBS     R3,R3,#+255
   \       0x10   0xD00C             BEQ.N    ??psa_validate_unstructured_key_bit_size_0
   \       0x12   0xF44F 0x7080      MOV      R0,#+256
   \       0x16   0x1A1B             SUBS     R3,R3,R0
   \       0x18   0xD008             BEQ.N    ??psa_validate_unstructured_key_bit_size_0
   \       0x1A   0x1EDB             SUBS     R3,R3,#+3
   \       0x1C   0xD006             BEQ.N    ??psa_validate_unstructured_key_bit_size_0
   \       0x1E   0x1E9B             SUBS     R3,R3,#+2
   \       0x20   0xD004             BEQ.N    ??psa_validate_unstructured_key_bit_size_0
   \       0x22   0xF241 0x10FB      MOVW     R0,#+4603
   \       0x26   0x1A1B             SUBS     R3,R3,R0
   \       0x28   0xD001             BEQ.N    ??psa_validate_unstructured_key_bit_size_1
   \       0x2A   0xE00B             B.N      ??psa_validate_unstructured_key_bit_size_2
    603                  case PSA_KEY_TYPE_RAW_DATA:
    604                  case PSA_KEY_TYPE_HMAC:
    605                  case PSA_KEY_TYPE_DERIVE:
    606                  case PSA_KEY_TYPE_PASSWORD:
    607                  case PSA_KEY_TYPE_PASSWORD_HASH:
    608                      break;
   \                     ??psa_validate_unstructured_key_bit_size_0: (+1)
   \       0x2C   0xE00D             B.N      ??psa_validate_unstructured_key_bit_size_3
    609          #if defined(PSA_WANT_KEY_TYPE_AES)
    610                  case PSA_KEY_TYPE_AES:
    611                      if (bits != 128 && bits != 192 && bits != 256) {
   \                     ??psa_validate_unstructured_key_bit_size_1: (+1)
   \       0x2E   0x2980             CMP      R1,#+128
   \       0x30   0xD007             BEQ.N    ??psa_validate_unstructured_key_bit_size_4
   \       0x32   0x29C0             CMP      R1,#+192
   \       0x34   0xD005             BEQ.N    ??psa_validate_unstructured_key_bit_size_4
   \       0x36   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x3A   0xD002             BEQ.N    ??psa_validate_unstructured_key_bit_size_4
    612                          return PSA_ERROR_INVALID_ARGUMENT;
   \       0x3C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x40   0xE00A             B.N      ??psa_validate_unstructured_key_bit_size_5
    613                      }
    614                      break;
   \                     ??psa_validate_unstructured_key_bit_size_4: (+1)
   \       0x42   0xE002             B.N      ??psa_validate_unstructured_key_bit_size_3
    615          #endif
    616          #if defined(PSA_WANT_KEY_TYPE_ARIA)
    617                  case PSA_KEY_TYPE_ARIA:
    618                      if (bits != 128 && bits != 192 && bits != 256) {
    619                          return PSA_ERROR_INVALID_ARGUMENT;
    620                      }
    621                      break;
    622          #endif
    623          #if defined(PSA_WANT_KEY_TYPE_CAMELLIA)
    624                  case PSA_KEY_TYPE_CAMELLIA:
    625                      if (bits != 128 && bits != 192 && bits != 256) {
    626                          return PSA_ERROR_INVALID_ARGUMENT;
    627                      }
    628                      break;
    629          #endif
    630          #if defined(PSA_WANT_KEY_TYPE_DES)
    631                  case PSA_KEY_TYPE_DES:
    632                      if (bits != 64 && bits != 128 && bits != 192) {
    633                          return PSA_ERROR_INVALID_ARGUMENT;
    634                      }
    635                      break;
    636          #endif
    637          #if defined(PSA_WANT_KEY_TYPE_CHACHA20)
    638                  case PSA_KEY_TYPE_CHACHA20:
    639                      if (bits != 256) {
    640                          return PSA_ERROR_INVALID_ARGUMENT;
    641                      }
    642                      break;
    643          #endif
    644                  default:
    645                      return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_validate_unstructured_key_bit_size_2: (+1)
   \       0x44   0xF07F 0x0085      MVNS     R0,#+133
   \       0x48   0xE006             B.N      ??psa_validate_unstructured_key_bit_size_5
    646              }
    647              if (bits % 8 != 0) {
   \                     ??psa_validate_unstructured_key_bit_size_3: (+1)
   \       0x4A   0xF011 0x0F07      TST      R1,#0x7
   \       0x4E   0xD002             BEQ.N    ??psa_validate_unstructured_key_bit_size_6
    648                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x50   0xF07F 0x0086      MVNS     R0,#+134
   \       0x54   0xE000             B.N      ??psa_validate_unstructured_key_bit_size_5
    649              }
    650          
    651              return PSA_SUCCESS;
   \                     ??psa_validate_unstructured_key_bit_size_6: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??psa_validate_unstructured_key_bit_size_5: (+1)
   \       0x58   0x4770             BX       LR
    652          }
    653          
    654          /** Check whether a given key type is valid for use with a given MAC algorithm
    655           *
    656           * Upon successful return of this function, the behavior of #PSA_MAC_LENGTH
    657           * when called with the validated \p algorithm and \p key_type is well-defined.
    658           *
    659           * \param[in] algorithm     The specific MAC algorithm (can be wildcard).
    660           * \param[in] key_type      The key type of the key to be used with the
    661           *                          \p algorithm.
    662           *
    663           * \retval #PSA_SUCCESS
    664           *         The \p key_type is valid for use with the \p algorithm
    665           * \retval #PSA_ERROR_INVALID_ARGUMENT
    666           *         The \p key_type is not valid for use with the \p algorithm
    667           */

   \                                 In section .text, align 2, keep-with-next
    668          MBEDTLS_STATIC_TESTABLE psa_status_t psa_mac_key_can_do(
    669              psa_algorithm_t algorithm,
    670              psa_key_type_t key_type)
    671          {
   \                     psa_mac_key_can_do: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    672              if (PSA_ALG_IS_HMAC(algorithm)) {
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable5
   \        0x6   0xEA10 0x0302      ANDS     R3,R0,R2
   \        0xA   0xF1B3 0x7F60      CMP      R3,#+58720256
   \        0xE   0xD106             BNE.N    ??psa_mac_key_can_do_0
    673                  if (key_type == PSA_KEY_TYPE_HMAC) {
   \       0x10   0x000B             MOVS     R3,R1
   \       0x12   0xB29B             UXTH     R3,R3
   \       0x14   0xF5B3 0x5F88      CMP      R3,#+4352
   \       0x18   0xD101             BNE.N    ??psa_mac_key_can_do_0
    674                      return PSA_SUCCESS;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE020             B.N      ??psa_mac_key_can_do_1
    675                  }
    676              }
    677          
    678              if (PSA_ALG_IS_BLOCK_CIPHER_MAC(algorithm)) {
   \                     ??psa_mac_key_can_do_0: (+1)
   \       0x1E   0x4010             ANDS     R0,R0,R2
   \       0x20   0xF1B0 0x7F70      CMP      R0,#+62914560
   \       0x24   0xD11A             BNE.N    ??psa_mac_key_can_do_2
    679                  /* Check that we're calling PSA_BLOCK_CIPHER_BLOCK_LENGTH with a cipher
    680                   * key. */
    681                  if ((key_type & PSA_KEY_TYPE_CATEGORY_MASK) ==
    682                      PSA_KEY_TYPE_CATEGORY_SYMMETRIC) {
   \       0x26   0x0008             MOVS     R0,R1
   \       0x28   0xB280             UXTH     R0,R0
   \       0x2A   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x2E   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x32   0xD113             BNE.N    ??psa_mac_key_can_do_2
    683                      /* PSA_BLOCK_CIPHER_BLOCK_LENGTH returns 1 for stream ciphers and
    684                       * the block length (larger than 1) for block ciphers. */
    685                      if (PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type) > 1) {
   \       0x34   0x0008             MOVS     R0,R1
   \       0x36   0xB280             UXTH     R0,R0
   \       0x38   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x3C   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x40   0xD107             BNE.N    ??psa_mac_key_can_do_3
   \       0x42   0x2301             MOVS     R3,#+1
   \       0x44   0x0008             MOVS     R0,R1
   \       0x46   0xB280             UXTH     R0,R0
   \       0x48   0x0A00             LSRS     R0,R0,#+8
   \       0x4A   0xF010 0x0007      ANDS     R0,R0,#0x7
   \       0x4E   0x4083             LSLS     R3,R3,R0
   \       0x50   0xE000             B.N      ??psa_mac_key_can_do_4
   \                     ??psa_mac_key_can_do_3: (+1)
   \       0x52   0x2300             MOVS     R3,#+0
   \                     ??psa_mac_key_can_do_4: (+1)
   \       0x54   0x2B02             CMP      R3,#+2
   \       0x56   0xD301             BCC.N    ??psa_mac_key_can_do_2
    686                          return PSA_SUCCESS;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xE001             B.N      ??psa_mac_key_can_do_1
    687                      }
    688                  }
    689              }
    690          
    691              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_mac_key_can_do_2: (+1)
   \       0x5C   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_mac_key_can_do_1: (+1)
   \       0x60   0x4770             BX       LR
    692          }
    693          

   \                                 In section .text, align 2, keep-with-next
    694          psa_status_t psa_allocate_buffer_to_slot(psa_key_slot_t *slot,
    695                                                   size_t buffer_length)
    696          {
   \                     psa_allocate_buffer_to_slot: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    697              if (slot->key.data != NULL) {
   \        0x6   0x6A68             LDR      R0,[R5, #+36]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??psa_allocate_buffer_to_slot_0
    698                  return PSA_ERROR_ALREADY_EXISTS;
   \        0xC   0xF07F 0x008A      MVNS     R0,#+138
   \       0x10   0xE00C             B.N      ??psa_allocate_buffer_to_slot_1
    699              }
    700          
    701              slot->key.data = mbedtls_calloc(1, buffer_length);
   \                     ??psa_allocate_buffer_to_slot_0: (+1)
   \       0x12   0x0021             MOVS     R1,R4
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x.... 0x....      BL       sl_calloc
   \       0x1A   0x6268             STR      R0,[R5, #+36]
    702              if (slot->key.data == NULL) {
   \       0x1C   0x6A68             LDR      R0,[R5, #+36]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD102             BNE.N    ??psa_allocate_buffer_to_slot_2
    703                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x22   0xF07F 0x008C      MVNS     R0,#+140
   \       0x26   0xE001             B.N      ??psa_allocate_buffer_to_slot_1
    704              }
    705          
    706              slot->key.bytes = buffer_length;
   \                     ??psa_allocate_buffer_to_slot_2: (+1)
   \       0x28   0x62AC             STR      R4,[R5, #+40]
    707              return PSA_SUCCESS;
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??psa_allocate_buffer_to_slot_1: (+1)
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
    708          }
    709          

   \                                 In section .text, align 2, keep-with-next
    710          psa_status_t psa_copy_key_material_into_slot(psa_key_slot_t *slot,
    711                                                       const uint8_t *data,
    712                                                       size_t data_length)
    713          {
   \                     psa_copy_key_material_into_slot: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    714              psa_status_t status = psa_allocate_buffer_to_slot(slot,
    715                                                                data_length);
   \        0xA   0x0031             MOVS     R1,R6
   \        0xC   0x4650             MOV      R0,R10
   \        0xE   0x.... 0x....      BL       psa_allocate_buffer_to_slot
   \       0x12   0x0004             MOVS     R4,R0
    716              if (status != PSA_SUCCESS) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD001             BEQ.N    ??psa_copy_key_material_into_slot_0
    717                  return status;
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0xE009             B.N      ??psa_copy_key_material_into_slot_1
    718              }
    719          
    720              memcpy(slot->key.data, data, data_length);
   \                     ??psa_copy_key_material_into_slot_0: (+1)
   \       0x1C   0x0037             MOVS     R7,R6
   \       0x1E   0x46A8             MOV      R8,R5
   \       0x20   0xF8DA 0x9024      LDR      R9,[R10, #+36]
   \       0x24   0x003A             MOVS     R2,R7
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x4648             MOV      R0,R9
   \       0x2A   0x.... 0x....      BL       __aeabi_memcpy
    721              return PSA_SUCCESS;
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??psa_copy_key_material_into_slot_1: (+1)
   \       0x30   0xE8BD 0x87F0      POP      {R4-R10,PC}
    722          }
    723          

   \                                 In section .text, align 2, keep-with-next
    724          psa_status_t psa_import_key_into_slot(
    725              const psa_key_attributes_t *attributes,
    726              const uint8_t *data, size_t data_length,
    727              uint8_t *key_buffer, size_t key_buffer_size,
    728              size_t *key_buffer_length, size_t *bits)
    729          {
   \                     psa_import_key_into_slot: (+1)
   \        0x0   0xE92D 0x4FFA      PUSH     {R1,R3-R11,LR}
   \        0x4   0xB083             SUB      SP,SP,#+12
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x9E0F             LDR      R6,[SP, #+60]
   \        0xC   0x9F10             LDR      R7,[SP, #+64]
    730              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0A96      MVNS     R10,#+150
    731              psa_key_type_t type = attributes->core.type;
   \       0x12   0xF8B9 0x8000      LDRH     R8,[R9, #+0]
    732          
    733              /* zero-length keys are never supported. */
    734              if (data_length == 0) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??psa_import_key_into_slot_0
    735                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x1A   0xF07F 0x0085      MVNS     R0,#+133
   \       0x1E   0xE052             B.N      ??psa_import_key_into_slot_1
    736              }
    737          
    738              if (key_type_is_raw_bytes(type)) {
   \                     ??psa_import_key_into_slot_0: (+1)
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0x.... 0x....      BL       key_type_is_raw_bytes
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD034             BEQ.N    ??psa_import_key_into_slot_2
    739                  if (*bits == 0) {
   \       0x2C   0x6838             LDR      R0,[R7, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD101             BNE.N    ??psa_import_key_into_slot_3
    740                      *bits = PSA_BYTES_TO_BITS(data_length);
   \       0x32   0x00E0             LSLS     R0,R4,#+3
   \       0x34   0x6038             STR      R0,[R7, #+0]
    741                  }
    742          
    743                  status = psa_validate_unstructured_key_bit_size(attributes->core.type,
    744                                                                  *bits);
   \                     ??psa_import_key_into_slot_3: (+1)
   \       0x36   0x6839             LDR      R1,[R7, #+0]
   \       0x38   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \       0x3C   0x.... 0x....      BL       psa_validate_unstructured_key_bit_size
   \       0x40   0x0005             MOVS     R5,R0
    745                  if (status != PSA_SUCCESS) {
   \       0x42   0x2D00             CMP      R5,#+0
   \       0x44   0xD001             BEQ.N    ??psa_import_key_into_slot_4
    746                      return status;
   \       0x46   0x0028             MOVS     R0,R5
   \       0x48   0xE03D             B.N      ??psa_import_key_into_slot_1
    747                  }
    748          
    749                  /* Copy the key material. */
    750                  if (PSA_BITS_TO_BYTES(*bits) != data_length) {
   \                     ??psa_import_key_into_slot_4: (+1)
   \       0x4A   0x6838             LDR      R0,[R7, #+0]
   \       0x4C   0x1DC0             ADDS     R0,R0,#+7
   \       0x4E   0x08C0             LSRS     R0,R0,#+3
   \       0x50   0x42A0             CMP      R0,R4
   \       0x52   0xD002             BEQ.N    ??psa_import_key_into_slot_5
    751                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x54   0xF07F 0x0086      MVNS     R0,#+134
   \       0x58   0xE035             B.N      ??psa_import_key_into_slot_1
    752                  }
    753                  if (PSA_BITS_TO_BYTES(*bits) > key_buffer_size) {
   \                     ??psa_import_key_into_slot_5: (+1)
   \       0x5A   0x990E             LDR      R1,[SP, #+56]
   \       0x5C   0x6838             LDR      R0,[R7, #+0]
   \       0x5E   0x1DC0             ADDS     R0,R0,#+7
   \       0x60   0xEBB1 0x0FD0      CMP      R1,R0, LSR #+3
   \       0x64   0xD202             BCS.N    ??psa_import_key_into_slot_6
    754                      return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x66   0xF07F 0x0089      MVNS     R0,#+137
   \       0x6A   0xE02C             B.N      ??psa_import_key_into_slot_1
    755                  }
    756          
    757                  memcpy(key_buffer, data, PSA_BITS_TO_BYTES(*bits));
   \                     ??psa_import_key_into_slot_6: (+1)
   \       0x6C   0xF8D7 0xA000      LDR      R10,[R7, #+0]
   \       0x70   0xF11A 0x0A07      ADDS     R10,R10,#+7
   \       0x74   0xEA5F 0x0ADA      LSRS     R10,R10,#+3
   \       0x78   0x9803             LDR      R0,[SP, #+12]
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0xF8DD 0xB010      LDR      R11,[SP, #+16]
   \       0x80   0x4652             MOV      R2,R10
   \       0x82   0x9900             LDR      R1,[SP, #+0]
   \       0x84   0x4658             MOV      R0,R11
   \       0x86   0x.... 0x....      BL       __aeabi_memcpy
    758                  *key_buffer_length = PSA_BITS_TO_BYTES(*bits);
   \       0x8A   0x6838             LDR      R0,[R7, #+0]
   \       0x8C   0x1DC0             ADDS     R0,R0,#+7
   \       0x8E   0x08C0             LSRS     R0,R0,#+3
   \       0x90   0x6030             STR      R0,[R6, #+0]
    759          
    760                  return PSA_SUCCESS;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xE017             B.N      ??psa_import_key_into_slot_1
    761              }
    762              else if( PSA_KEY_TYPE_IS_ASYMMETRIC( type ) )
   \                     ??psa_import_key_into_slot_2: (+1)
   \       0x96   0xEA5F 0x4048      LSLS     R0,R8,#+17
   \       0x9A   0xD512             BPL.N    ??psa_import_key_into_slot_7
    763              {
    764          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR) || \
    765              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY)
    766                  if( PSA_KEY_TYPE_IS_ECC( type ) )
   \       0x9C   0x4641             MOV      R1,R8
   \       0x9E   0xB289             UXTH     R1,R1
   \       0xA0   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0xA4   0x4001             ANDS     R1,R0,R1
   \       0xA6   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0xAA   0xD10A             BNE.N    ??psa_import_key_into_slot_7
    767                  {
    768                      return( mbedtls_psa_ecp_import_key( attributes,
    769                                                          data, data_length,
    770                                                          key_buffer, key_buffer_size,
    771                                                          key_buffer_length,
    772                                                          bits ) );
   \       0xAC   0x9702             STR      R7,[SP, #+8]
   \       0xAE   0x9601             STR      R6,[SP, #+4]
   \       0xB0   0x980E             LDR      R0,[SP, #+56]
   \       0xB2   0x9000             STR      R0,[SP, #+0]
   \       0xB4   0x9B04             LDR      R3,[SP, #+16]
   \       0xB6   0x0022             MOVS     R2,R4
   \       0xB8   0x9903             LDR      R1,[SP, #+12]
   \       0xBA   0x4648             MOV      R0,R9
   \       0xBC   0x.... 0x....      BL       mbedtls_psa_ecp_import_key
   \       0xC0   0xE001             B.N      ??psa_import_key_into_slot_1
    773                  }
    774          #endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_IMPORT) ||
    775                  * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY) */
    776          #if (defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_IMPORT) && \
    777                  defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT)) || \
    778                  defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY)
    779                  if (PSA_KEY_TYPE_IS_RSA(type)) {
    780                      return mbedtls_psa_rsa_import_key(attributes,
    781                                                        data, data_length,
    782                                                        key_buffer, key_buffer_size,
    783                                                        key_buffer_length,
    784                                                        bits);
    785                  }
    786          #endif /* (defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_IMPORT) &&
    787                     defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT)) ||
    788                  * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY) */
    789              }
    790          
    791              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_import_key_into_slot_7: (+1)
   \       0xC2   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_import_key_into_slot_1: (+1)
   \       0xC6   0xB005             ADD      SP,SP,#+20
   \       0xC8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    792          }
    793          
    794          /** Calculate the intersection of two algorithm usage policies.
    795           *
    796           * Return 0 (which allows no operation) on incompatibility.
    797           */

   \                                 In section .text, align 2, keep-with-next
    798          static psa_algorithm_t psa_key_policy_algorithm_intersection(
    799              psa_key_type_t key_type,
    800              psa_algorithm_t alg1,
    801              psa_algorithm_t alg2)
    802          {
   \                     psa_key_policy_algorithm_intersection: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0015             MOVS     R5,R2
    803              /* Common case: both sides actually specify the same policy. */
    804              if (alg1 == alg2) {
   \        0x8   0x42AE             CMP      R6,R5
   \        0xA   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_0
    805                  return alg1;
   \        0xC   0x0030             MOVS     R0,R6
   \        0xE   0xE269             B.N      ??psa_key_policy_algorithm_intersection_1
    806              }
    807              /* If the policies are from the same hash-and-sign family, check
    808               * if one is a wildcard. If so the other has the specific algorithm. */
    809              if (PSA_ALG_IS_SIGN_HASH(alg1) &&
    810                  PSA_ALG_IS_SIGN_HASH(alg2) &&
    811                  (alg1 & ~PSA_ALG_HASH_MASK) == (alg2 & ~PSA_ALG_HASH_MASK)) {
   \                     ??psa_key_policy_algorithm_intersection_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0x14   0x0A31             LSRS     R1,R6,#+8
   \       0x16   0x0209             LSLS     R1,R1,#+8
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0xD01D             BEQ.N    ??psa_key_policy_algorithm_intersection_2
   \       0x1C   0x0A32             LSRS     R2,R6,#+8
   \       0x1E   0x0212             LSLS     R2,R2,#+8
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \       0x24   0x428A             CMP      R2,R1
   \       0x26   0xD017             BEQ.N    ??psa_key_policy_algorithm_intersection_2
   \       0x28   0x0A32             LSRS     R2,R6,#+8
   \       0x2A   0x0212             LSLS     R2,R2,#+8
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \       0x30   0x428A             CMP      R2,R1
   \       0x32   0xD011             BEQ.N    ??psa_key_policy_algorithm_intersection_2
   \       0x34   0x0A71             LSRS     R1,R6,#+9
   \       0x36   0x0249             LSLS     R1,R1,#+9
   \       0x38   0xF1B1 0x2F06      CMP      R1,#+100664832
   \       0x3C   0xD00C             BEQ.N    ??psa_key_policy_algorithm_intersection_2
   \       0x3E   0x0A32             LSRS     R2,R6,#+8
   \       0x40   0x0212             LSLS     R2,R2,#+8
   \       0x42   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \       0x46   0x428A             CMP      R2,R1
   \       0x48   0xD006             BEQ.N    ??psa_key_policy_algorithm_intersection_2
   \       0x4A   0x0A72             LSRS     R2,R6,#+9
   \       0x4C   0x0252             LSLS     R2,R2,#+9
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0x52   0x428A             CMP      R2,R1
   \       0x54   0xF040 0x8083      BNE.W    ??psa_key_policy_algorithm_intersection_3
   \                     ??psa_key_policy_algorithm_intersection_2: (+1)
   \       0x58   0x0A29             LSRS     R1,R5,#+8
   \       0x5A   0x0209             LSLS     R1,R1,#+8
   \       0x5C   0x4281             CMP      R1,R0
   \       0x5E   0xD01C             BEQ.N    ??psa_key_policy_algorithm_intersection_4
   \       0x60   0x0A2A             LSRS     R2,R5,#+8
   \       0x62   0x0212             LSLS     R2,R2,#+8
   \       0x64   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \       0x68   0x428A             CMP      R2,R1
   \       0x6A   0xD016             BEQ.N    ??psa_key_policy_algorithm_intersection_4
   \       0x6C   0x0A2A             LSRS     R2,R5,#+8
   \       0x6E   0x0212             LSLS     R2,R2,#+8
   \       0x70   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \       0x74   0x428A             CMP      R2,R1
   \       0x76   0xD010             BEQ.N    ??psa_key_policy_algorithm_intersection_4
   \       0x78   0x0A69             LSRS     R1,R5,#+9
   \       0x7A   0x0249             LSLS     R1,R1,#+9
   \       0x7C   0xF1B1 0x2F06      CMP      R1,#+100664832
   \       0x80   0xD00B             BEQ.N    ??psa_key_policy_algorithm_intersection_4
   \       0x82   0x0A2A             LSRS     R2,R5,#+8
   \       0x84   0x0212             LSLS     R2,R2,#+8
   \       0x86   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \       0x8A   0x428A             CMP      R2,R1
   \       0x8C   0xD005             BEQ.N    ??psa_key_policy_algorithm_intersection_4
   \       0x8E   0x0A6A             LSRS     R2,R5,#+9
   \       0x90   0x0252             LSLS     R2,R2,#+9
   \       0x92   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0x96   0x428A             CMP      R2,R1
   \       0x98   0xD161             BNE.N    ??psa_key_policy_algorithm_intersection_3
   \                     ??psa_key_policy_algorithm_intersection_4: (+1)
   \       0x9A   0x0A31             LSRS     R1,R6,#+8
   \       0x9C   0x0209             LSLS     R1,R1,#+8
   \       0x9E   0x0A2A             LSRS     R2,R5,#+8
   \       0xA0   0x0212             LSLS     R2,R2,#+8
   \       0xA2   0x4291             CMP      R1,R2
   \       0xA4   0xD15B             BNE.N    ??psa_key_policy_algorithm_intersection_3
    812                  if (PSA_ALG_SIGN_GET_HASH(alg1) == PSA_ALG_ANY_HASH) {
   \       0xA6   0x0A31             LSRS     R1,R6,#+8
   \       0xA8   0x0209             LSLS     R1,R1,#+8
   \       0xAA   0x4281             CMP      R1,R0
   \       0xAC   0xD01C             BEQ.N    ??psa_key_policy_algorithm_intersection_5
   \       0xAE   0x0A32             LSRS     R2,R6,#+8
   \       0xB0   0x0212             LSLS     R2,R2,#+8
   \       0xB2   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \       0xB6   0x428A             CMP      R2,R1
   \       0xB8   0xD016             BEQ.N    ??psa_key_policy_algorithm_intersection_5
   \       0xBA   0x0A32             LSRS     R2,R6,#+8
   \       0xBC   0x0212             LSLS     R2,R2,#+8
   \       0xBE   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \       0xC2   0x428A             CMP      R2,R1
   \       0xC4   0xD010             BEQ.N    ??psa_key_policy_algorithm_intersection_5
   \       0xC6   0x0A71             LSRS     R1,R6,#+9
   \       0xC8   0x0249             LSLS     R1,R1,#+9
   \       0xCA   0xF1B1 0x2F06      CMP      R1,#+100664832
   \       0xCE   0xD00B             BEQ.N    ??psa_key_policy_algorithm_intersection_5
   \       0xD0   0x0A32             LSRS     R2,R6,#+8
   \       0xD2   0x0212             LSLS     R2,R2,#+8
   \       0xD4   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \       0xD8   0x428A             CMP      R2,R1
   \       0xDA   0xD005             BEQ.N    ??psa_key_policy_algorithm_intersection_5
   \       0xDC   0x0A72             LSRS     R2,R6,#+9
   \       0xDE   0x0252             LSLS     R2,R2,#+9
   \       0xE0   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0xE4   0x428A             CMP      R2,R1
   \       0xE6   0xD106             BNE.N    ??psa_key_policy_algorithm_intersection_6
   \                     ??psa_key_policy_algorithm_intersection_5: (+1)
   \       0xE8   0x0631             LSLS     R1,R6,#+24
   \       0xEA   0xD004             BEQ.N    ??psa_key_policy_algorithm_intersection_6
   \       0xEC   0xF006 0x02FF      AND      R2,R6,#0xFF
   \       0xF0   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xF4   0xE000             B.N      ??psa_key_policy_algorithm_intersection_7
   \                     ??psa_key_policy_algorithm_intersection_6: (+1)
   \       0xF6   0x2200             MOVS     R2,#+0
   \                     ??psa_key_policy_algorithm_intersection_7: (+1)
   \       0xF8   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \       0xFC   0x428A             CMP      R2,R1
   \       0xFE   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_8
    813                      return alg2;
   \      0x100   0x0028             MOVS     R0,R5
   \      0x102   0xE1EF             B.N      ??psa_key_policy_algorithm_intersection_1
    814                  }
    815                  if (PSA_ALG_SIGN_GET_HASH(alg2) == PSA_ALG_ANY_HASH) {
   \                     ??psa_key_policy_algorithm_intersection_8: (+1)
   \      0x104   0x0A2A             LSRS     R2,R5,#+8
   \      0x106   0x0212             LSLS     R2,R2,#+8
   \      0x108   0x4282             CMP      R2,R0
   \      0x10A   0xD01C             BEQ.N    ??psa_key_policy_algorithm_intersection_9
   \      0x10C   0x0A2A             LSRS     R2,R5,#+8
   \      0x10E   0x0212             LSLS     R2,R2,#+8
   \      0x110   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \      0x114   0x4282             CMP      R2,R0
   \      0x116   0xD016             BEQ.N    ??psa_key_policy_algorithm_intersection_9
   \      0x118   0x0A2A             LSRS     R2,R5,#+8
   \      0x11A   0x0212             LSLS     R2,R2,#+8
   \      0x11C   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \      0x120   0x4282             CMP      R2,R0
   \      0x122   0xD010             BEQ.N    ??psa_key_policy_algorithm_intersection_9
   \      0x124   0x0A68             LSRS     R0,R5,#+9
   \      0x126   0x0240             LSLS     R0,R0,#+9
   \      0x128   0xF1B0 0x2F06      CMP      R0,#+100664832
   \      0x12C   0xD00B             BEQ.N    ??psa_key_policy_algorithm_intersection_9
   \      0x12E   0x0A2A             LSRS     R2,R5,#+8
   \      0x130   0x0212             LSLS     R2,R2,#+8
   \      0x132   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \      0x136   0x4282             CMP      R2,R0
   \      0x138   0xD005             BEQ.N    ??psa_key_policy_algorithm_intersection_9
   \      0x13A   0x0A68             LSRS     R0,R5,#+9
   \      0x13C   0x0240             LSLS     R0,R0,#+9
   \      0x13E   0x.... 0x....      LDR.W    R2,??DataTable6_5
   \      0x142   0x4290             CMP      R0,R2
   \      0x144   0xD106             BNE.N    ??psa_key_policy_algorithm_intersection_10
   \                     ??psa_key_policy_algorithm_intersection_9: (+1)
   \      0x146   0x0628             LSLS     R0,R5,#+24
   \      0x148   0xD004             BEQ.N    ??psa_key_policy_algorithm_intersection_10
   \      0x14A   0xF005 0x00FF      AND      R0,R5,#0xFF
   \      0x14E   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x152   0xE000             B.N      ??psa_key_policy_algorithm_intersection_11
   \                     ??psa_key_policy_algorithm_intersection_10: (+1)
   \      0x154   0x2000             MOVS     R0,#+0
   \                     ??psa_key_policy_algorithm_intersection_11: (+1)
   \      0x156   0x4288             CMP      R0,R1
   \      0x158   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_3
    816                      return alg1;
   \      0x15A   0x0030             MOVS     R0,R6
   \      0x15C   0xE1C2             B.N      ??psa_key_policy_algorithm_intersection_1
    817                  }
    818              }
    819              /* If the policies are from the same AEAD family, check whether
    820               * one of them is a minimum-tag-length wildcard. Calculate the most
    821               * restrictive tag length. */
    822              if (PSA_ALG_IS_AEAD(alg1) && PSA_ALG_IS_AEAD(alg2) &&
    823                  (PSA_ALG_AEAD_WITH_SHORTENED_TAG(alg1, 0) ==
    824                   PSA_ALG_AEAD_WITH_SHORTENED_TAG(alg2, 0))) {
   \                     ??psa_key_policy_algorithm_intersection_3: (+1)
   \      0x15E   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \      0x162   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \      0x166   0xD129             BNE.N    ??psa_key_policy_algorithm_intersection_12
   \      0x168   0xF015 0x40FE      ANDS     R0,R5,#0x7F000000
   \      0x16C   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \      0x170   0xD124             BNE.N    ??psa_key_policy_algorithm_intersection_12
   \      0x172   0xF436 0x117E      BICS     R1,R6,#0x3F8000
   \      0x176   0xF435 0x107E      BICS     R0,R5,#0x3F8000
   \      0x17A   0x4281             CMP      R1,R0
   \      0x17C   0xD11E             BNE.N    ??psa_key_policy_algorithm_intersection_12
    825                  size_t alg1_len = PSA_ALG_AEAD_GET_TAG_LENGTH(alg1);
   \      0x17E   0xF3C6 0x4105      UBFX     R1,R6,#+16,#+6
    826                  size_t alg2_len = PSA_ALG_AEAD_GET_TAG_LENGTH(alg2);
   \      0x182   0xF3C5 0x4205      UBFX     R2,R5,#+16,#+6
    827                  size_t restricted_len = alg1_len > alg2_len ? alg1_len : alg2_len;
   \      0x186   0x428A             CMP      R2,R1
   \      0x188   0xD201             BCS.N    ??psa_key_policy_algorithm_intersection_13
   \      0x18A   0x000B             MOVS     R3,R1
   \      0x18C   0xE000             B.N      ??psa_key_policy_algorithm_intersection_14
   \                     ??psa_key_policy_algorithm_intersection_13: (+1)
   \      0x18E   0x0013             MOVS     R3,R2
    828          
    829                  /* If both are wildcards, return most restrictive wildcard */
    830                  if (((alg1 & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG) != 0) &&
    831                      ((alg2 & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG) != 0)) {
   \                     ??psa_key_policy_algorithm_intersection_14: (+1)
   \      0x190   0x0430             LSLS     R0,R6,#+16
   \      0x192   0xD507             BPL.N    ??psa_key_policy_algorithm_intersection_15
   \      0x194   0x0428             LSLS     R0,R5,#+16
   \      0x196   0xD505             BPL.N    ??psa_key_policy_algorithm_intersection_15
    832                      return PSA_ALG_AEAD_WITH_AT_LEAST_THIS_LENGTH_TAG(
    833                          alg1, restricted_len);
   \      0x198   0xF363 0x4615      BFI      R6,R3,#+16,#+6
   \      0x19C   0xF456 0x4600      ORRS     R6,R6,#0x8000
   \      0x1A0   0x0030             MOVS     R0,R6
   \      0x1A2   0xE19F             B.N      ??psa_key_policy_algorithm_intersection_1
    834                  }
    835                  /* If only one is a wildcard, return specific algorithm if compatible. */
    836                  if (((alg1 & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG) != 0) &&
    837                      (alg1_len <= alg2_len)) {
   \                     ??psa_key_policy_algorithm_intersection_15: (+1)
   \      0x1A4   0x0430             LSLS     R0,R6,#+16
   \      0x1A6   0xD503             BPL.N    ??psa_key_policy_algorithm_intersection_16
   \      0x1A8   0x428A             CMP      R2,R1
   \      0x1AA   0xD301             BCC.N    ??psa_key_policy_algorithm_intersection_16
    838                      return alg2;
   \      0x1AC   0x0028             MOVS     R0,R5
   \      0x1AE   0xE199             B.N      ??psa_key_policy_algorithm_intersection_1
    839                  }
    840                  if (((alg2 & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG) != 0) &&
    841                      (alg2_len <= alg1_len)) {
   \                     ??psa_key_policy_algorithm_intersection_16: (+1)
   \      0x1B0   0x0428             LSLS     R0,R5,#+16
   \      0x1B2   0xD503             BPL.N    ??psa_key_policy_algorithm_intersection_12
   \      0x1B4   0x4291             CMP      R1,R2
   \      0x1B6   0xD301             BCC.N    ??psa_key_policy_algorithm_intersection_12
    842                      return alg1;
   \      0x1B8   0x0030             MOVS     R0,R6
   \      0x1BA   0xE193             B.N      ??psa_key_policy_algorithm_intersection_1
    843                  }
    844              }
    845              /* If the policies are from the same MAC family, check whether one
    846               * of them is a minimum-MAC-length policy. Calculate the most
    847               * restrictive tag length. */
    848              if (PSA_ALG_IS_MAC(alg1) && PSA_ALG_IS_MAC(alg2) &&
    849                  (PSA_ALG_FULL_LENGTH_MAC(alg1) ==
    850                   PSA_ALG_FULL_LENGTH_MAC(alg2))) {
   \                     ??psa_key_policy_algorithm_intersection_12: (+1)
   \      0x1BC   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \      0x1C0   0xF1B0 0x7F40      CMP      R0,#+50331648
   \      0x1C4   0xF040 0x818D      BNE.W    ??psa_key_policy_algorithm_intersection_17
   \      0x1C8   0xF015 0x40FE      ANDS     R0,R5,#0x7F000000
   \      0x1CC   0xF1B0 0x7F40      CMP      R0,#+50331648
   \      0x1D0   0xF040 0x8187      BNE.W    ??psa_key_policy_algorithm_intersection_17
   \      0x1D4   0xF436 0x107E      BICS     R0,R6,#0x3F8000
   \      0x1D8   0xF435 0x117E      BICS     R1,R5,#0x3F8000
   \      0x1DC   0x4288             CMP      R0,R1
   \      0x1DE   0xF040 0x8180      BNE.W    ??psa_key_policy_algorithm_intersection_17
    851                  /* Validate the combination of key type and algorithm. Since the base
    852                   * algorithm of alg1 and alg2 are the same, we only need this once. */
    853                  if (PSA_SUCCESS != psa_mac_key_can_do(alg1, key_type)) {
   \      0x1E2   0x0021             MOVS     R1,R4
   \      0x1E4   0xB289             UXTH     R1,R1
   \      0x1E6   0x0030             MOVS     R0,R6
   \      0x1E8   0x.... 0x....      BL       psa_mac_key_can_do
   \      0x1EC   0x2800             CMP      R0,#+0
   \      0x1EE   0xD001             BEQ.N    ??psa_key_policy_algorithm_intersection_18
    854                      return 0;
   \      0x1F0   0x2000             MOVS     R0,#+0
   \      0x1F2   0xE177             B.N      ??psa_key_policy_algorithm_intersection_1
    855                  }
    856          
    857                  /* Get the (exact or at-least) output lengths for both sides of the
    858                   * requested intersection. None of the currently supported algorithms
    859                   * have an output length dependent on the actual key size, so setting it
    860                   * to a bogus value of 0 is currently OK.
    861                   *
    862                   * Note that for at-least-this-length wildcard algorithms, the output
    863                   * length is set to the shortest allowed length, which allows us to
    864                   * calculate the most restrictive tag length for the intersection. */
    865                  size_t alg1_len = PSA_MAC_LENGTH(key_type, 0, alg1);
   \                     ??psa_key_policy_algorithm_intersection_18: (+1)
   \      0x1F4   0xF416 0x1F7C      TST      R6,#0x3F0000
   \      0x1F8   0xD002             BEQ.N    ??psa_key_policy_algorithm_intersection_19
   \      0x1FA   0xF3C6 0x4105      UBFX     R1,R6,#+16,#+6
   \      0x1FE   0xE0A1             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_19: (+1)
   \      0x200   0x.... 0x....      LDR.W    R1,??DataTable5
   \      0x204   0xEA11 0x0006      ANDS     R0,R1,R6
   \      0x208   0xF1B0 0x7F60      CMP      R0,#+58720256
   \      0x20C   0xF040 0x8084      BNE.W    ??psa_key_policy_algorithm_intersection_21
   \      0x210   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x214   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x218   0x.... 0x....      LDR.W    R1,??DataTable7
   \      0x21C   0x4288             CMP      R0,R1
   \      0x21E   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_22
   \      0x220   0x2110             MOVS     R1,#+16
   \      0x222   0xE08F             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_22: (+1)
   \      0x224   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x228   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x22C   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \      0x230   0x4288             CMP      R0,R1
   \      0x232   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_23
   \      0x234   0x2114             MOVS     R1,#+20
   \      0x236   0xE085             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_23: (+1)
   \      0x238   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x23C   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x240   0x.... 0x....      LDR.W    R1,??DataTable8
   \      0x244   0x4288             CMP      R0,R1
   \      0x246   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_24
   \      0x248   0x2114             MOVS     R1,#+20
   \      0x24A   0xE07B             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_24: (+1)
   \      0x24C   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x250   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x254   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \      0x258   0x4288             CMP      R0,R1
   \      0x25A   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_25
   \      0x25C   0x211C             MOVS     R1,#+28
   \      0x25E   0xE071             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_25: (+1)
   \      0x260   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x264   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x268   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \      0x26C   0x4288             CMP      R0,R1
   \      0x26E   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_26
   \      0x270   0x2120             MOVS     R1,#+32
   \      0x272   0xE067             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_26: (+1)
   \      0x274   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x278   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x27C   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \      0x280   0x4288             CMP      R0,R1
   \      0x282   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_27
   \      0x284   0x2130             MOVS     R1,#+48
   \      0x286   0xE05D             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_27: (+1)
   \      0x288   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x28C   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x290   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \      0x294   0x4281             CMP      R1,R0
   \      0x296   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_28
   \      0x298   0x2140             MOVS     R1,#+64
   \      0x29A   0xE053             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_28: (+1)
   \      0x29C   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x2A0   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x2A4   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \      0x2A8   0x4281             CMP      R1,R0
   \      0x2AA   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_29
   \      0x2AC   0x211C             MOVS     R1,#+28
   \      0x2AE   0xE049             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_29: (+1)
   \      0x2B0   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x2B4   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x2B8   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \      0x2BC   0x4281             CMP      R1,R0
   \      0x2BE   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_30
   \      0x2C0   0x2120             MOVS     R1,#+32
   \      0x2C2   0xE03F             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_30: (+1)
   \      0x2C4   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x2C8   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x2CC   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \      0x2D0   0x4281             CMP      R1,R0
   \      0x2D2   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_31
   \      0x2D4   0x211C             MOVS     R1,#+28
   \      0x2D6   0xE035             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_31: (+1)
   \      0x2D8   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x2DC   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x2E0   0x.... 0x....      LDR.W    R0,??DataTable8_8
   \      0x2E4   0x4281             CMP      R1,R0
   \      0x2E6   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_32
   \      0x2E8   0x2120             MOVS     R1,#+32
   \      0x2EA   0xE02B             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_32: (+1)
   \      0x2EC   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x2F0   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x2F4   0x.... 0x....      LDR.W    R0,??DataTable8_9
   \      0x2F8   0x4281             CMP      R1,R0
   \      0x2FA   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_33
   \      0x2FC   0x2130             MOVS     R1,#+48
   \      0x2FE   0xE021             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_33: (+1)
   \      0x300   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x304   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x308   0x.... 0x....      LDR.W    R0,??DataTable8_10
   \      0x30C   0x4281             CMP      R1,R0
   \      0x30E   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_34
   \      0x310   0x2140             MOVS     R1,#+64
   \      0x312   0xE017             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_34: (+1)
   \      0x314   0x2100             MOVS     R1,#+0
   \      0x316   0xE015             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_21: (+1)
   \      0x318   0x4031             ANDS     R1,R1,R6
   \      0x31A   0xF1B1 0x7F70      CMP      R1,#+62914560
   \      0x31E   0xD110             BNE.N    ??psa_key_policy_algorithm_intersection_35
   \      0x320   0x0020             MOVS     R0,R4
   \      0x322   0xB280             UXTH     R0,R0
   \      0x324   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \      0x328   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x32C   0xD107             BNE.N    ??psa_key_policy_algorithm_intersection_36
   \      0x32E   0x2101             MOVS     R1,#+1
   \      0x330   0x0020             MOVS     R0,R4
   \      0x332   0xB280             UXTH     R0,R0
   \      0x334   0x0A00             LSRS     R0,R0,#+8
   \      0x336   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x33A   0x4081             LSLS     R1,R1,R0
   \      0x33C   0xE002             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_36: (+1)
   \      0x33E   0x2100             MOVS     R1,#+0
   \      0x340   0xE000             B.N      ??psa_key_policy_algorithm_intersection_20
   \                     ??psa_key_policy_algorithm_intersection_35: (+1)
   \      0x342   0x2100             MOVS     R1,#+0
    866                  size_t alg2_len = PSA_MAC_LENGTH(key_type, 0, alg2);
   \                     ??psa_key_policy_algorithm_intersection_20: (+1)
   \      0x344   0xF415 0x1F7C      TST      R5,#0x3F0000
   \      0x348   0xD002             BEQ.N    ??psa_key_policy_algorithm_intersection_37
   \      0x34A   0xF3C5 0x4205      UBFX     R2,R5,#+16,#+6
   \      0x34E   0xE0A1             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_37: (+1)
   \      0x350   0x.... 0x....      LDR.W    R2,??DataTable5
   \      0x354   0xEA12 0x0005      ANDS     R0,R2,R5
   \      0x358   0xF1B0 0x7F60      CMP      R0,#+58720256
   \      0x35C   0xF040 0x8084      BNE.W    ??psa_key_policy_algorithm_intersection_39
   \      0x360   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x364   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x368   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x36C   0x4282             CMP      R2,R0
   \      0x36E   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_40
   \      0x370   0x2210             MOVS     R2,#+16
   \      0x372   0xE08F             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_40: (+1)
   \      0x374   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x378   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x37C   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \      0x380   0x4282             CMP      R2,R0
   \      0x382   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_41
   \      0x384   0x2214             MOVS     R2,#+20
   \      0x386   0xE085             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_41: (+1)
   \      0x388   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x38C   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x390   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0x394   0x4282             CMP      R2,R0
   \      0x396   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_42
   \      0x398   0x2214             MOVS     R2,#+20
   \      0x39A   0xE07B             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_42: (+1)
   \      0x39C   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x3A0   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x3A4   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \      0x3A8   0x4282             CMP      R2,R0
   \      0x3AA   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_43
   \      0x3AC   0x221C             MOVS     R2,#+28
   \      0x3AE   0xE071             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_43: (+1)
   \      0x3B0   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x3B4   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x3B8   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \      0x3BC   0x4282             CMP      R2,R0
   \      0x3BE   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_44
   \      0x3C0   0x2220             MOVS     R2,#+32
   \      0x3C2   0xE067             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_44: (+1)
   \      0x3C4   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x3C8   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x3CC   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \      0x3D0   0x4282             CMP      R2,R0
   \      0x3D2   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_45
   \      0x3D4   0x2230             MOVS     R2,#+48
   \      0x3D6   0xE05D             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_45: (+1)
   \      0x3D8   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x3DC   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x3E0   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \      0x3E4   0x4282             CMP      R2,R0
   \      0x3E6   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_46
   \      0x3E8   0x2240             MOVS     R2,#+64
   \      0x3EA   0xE053             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_46: (+1)
   \      0x3EC   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x3F0   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x3F4   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \      0x3F8   0x4282             CMP      R2,R0
   \      0x3FA   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_47
   \      0x3FC   0x221C             MOVS     R2,#+28
   \      0x3FE   0xE049             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_47: (+1)
   \      0x400   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x404   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x408   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \      0x40C   0x4282             CMP      R2,R0
   \      0x40E   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_48
   \      0x410   0x2220             MOVS     R2,#+32
   \      0x412   0xE03F             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_48: (+1)
   \      0x414   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x418   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x41C   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \      0x420   0x4282             CMP      R2,R0
   \      0x422   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_49
   \      0x424   0x221C             MOVS     R2,#+28
   \      0x426   0xE035             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_49: (+1)
   \      0x428   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x42C   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x430   0x.... 0x....      LDR.W    R0,??DataTable8_8
   \      0x434   0x4282             CMP      R2,R0
   \      0x436   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_50
   \      0x438   0x2220             MOVS     R2,#+32
   \      0x43A   0xE02B             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_50: (+1)
   \      0x43C   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x440   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x444   0x.... 0x....      LDR.W    R0,??DataTable8_9
   \      0x448   0x4282             CMP      R2,R0
   \      0x44A   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_51
   \      0x44C   0x2230             MOVS     R2,#+48
   \      0x44E   0xE021             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_51: (+1)
   \      0x450   0xF005 0x02FF      AND      R2,R5,#0xFF
   \      0x454   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x458   0x.... 0x....      LDR.W    R0,??DataTable8_10
   \      0x45C   0x4282             CMP      R2,R0
   \      0x45E   0xD101             BNE.N    ??psa_key_policy_algorithm_intersection_52
   \      0x460   0x2240             MOVS     R2,#+64
   \      0x462   0xE017             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_52: (+1)
   \      0x464   0x2200             MOVS     R2,#+0
   \      0x466   0xE015             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_39: (+1)
   \      0x468   0x402A             ANDS     R2,R2,R5
   \      0x46A   0xF1B2 0x7F70      CMP      R2,#+62914560
   \      0x46E   0xD110             BNE.N    ??psa_key_policy_algorithm_intersection_53
   \      0x470   0x0020             MOVS     R0,R4
   \      0x472   0xB280             UXTH     R0,R0
   \      0x474   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \      0x478   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x47C   0xD107             BNE.N    ??psa_key_policy_algorithm_intersection_54
   \      0x47E   0x2201             MOVS     R2,#+1
   \      0x480   0x0020             MOVS     R0,R4
   \      0x482   0xB280             UXTH     R0,R0
   \      0x484   0x0A00             LSRS     R0,R0,#+8
   \      0x486   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x48A   0x4082             LSLS     R2,R2,R0
   \      0x48C   0xE002             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_54: (+1)
   \      0x48E   0x2200             MOVS     R2,#+0
   \      0x490   0xE000             B.N      ??psa_key_policy_algorithm_intersection_38
   \                     ??psa_key_policy_algorithm_intersection_53: (+1)
   \      0x492   0x2200             MOVS     R2,#+0
    867                  size_t restricted_len = alg1_len > alg2_len ? alg1_len : alg2_len;
   \                     ??psa_key_policy_algorithm_intersection_38: (+1)
   \      0x494   0x428A             CMP      R2,R1
   \      0x496   0xD201             BCS.N    ??psa_key_policy_algorithm_intersection_55
   \      0x498   0x000B             MOVS     R3,R1
   \      0x49A   0xE000             B.N      ??psa_key_policy_algorithm_intersection_56
   \                     ??psa_key_policy_algorithm_intersection_55: (+1)
   \      0x49C   0x0013             MOVS     R3,R2
    868          
    869                  /* If both are wildcards, return most restrictive wildcard */
    870                  if (((alg1 & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG) != 0) &&
    871                      ((alg2 & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG) != 0)) {
   \                     ??psa_key_policy_algorithm_intersection_56: (+1)
   \      0x49E   0x0430             LSLS     R0,R6,#+16
   \      0x4A0   0xD507             BPL.N    ??psa_key_policy_algorithm_intersection_57
   \      0x4A2   0x0428             LSLS     R0,R5,#+16
   \      0x4A4   0xD505             BPL.N    ??psa_key_policy_algorithm_intersection_57
    872                      return PSA_ALG_AT_LEAST_THIS_LENGTH_MAC(alg1, restricted_len);
   \      0x4A6   0xF363 0x4615      BFI      R6,R3,#+16,#+6
   \      0x4AA   0xF456 0x4600      ORRS     R6,R6,#0x8000
   \      0x4AE   0x0030             MOVS     R0,R6
   \      0x4B0   0xE018             B.N      ??psa_key_policy_algorithm_intersection_1
    873                  }
    874          
    875                  /* If only one is an at-least-this-length policy, the intersection would
    876                   * be the other (fixed-length) policy as long as said fixed length is
    877                   * equal to or larger than the shortest allowed length. */
    878                  if ((alg1 & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG) != 0) {
   \                     ??psa_key_policy_algorithm_intersection_57: (+1)
   \      0x4B2   0x0430             LSLS     R0,R6,#+16
   \      0x4B4   0xD504             BPL.N    ??psa_key_policy_algorithm_intersection_58
    879                      return (alg1_len <= alg2_len) ? alg2 : 0;
   \      0x4B6   0x428A             CMP      R2,R1
   \      0x4B8   0xD200             BCS.N    ??psa_key_policy_algorithm_intersection_59
   \                     ??psa_key_policy_algorithm_intersection_60: (+1)
   \      0x4BA   0x2500             MOVS     R5,#+0
   \                     ??psa_key_policy_algorithm_intersection_59: (+1)
   \      0x4BC   0x0028             MOVS     R0,R5
   \      0x4BE   0xE011             B.N      ??psa_key_policy_algorithm_intersection_1
    880                  }
    881                  if ((alg2 & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG) != 0) {
   \                     ??psa_key_policy_algorithm_intersection_58: (+1)
   \      0x4C0   0x0428             LSLS     R0,R5,#+16
   \      0x4C2   0xD504             BPL.N    ??psa_key_policy_algorithm_intersection_61
    882                      return (alg2_len <= alg1_len) ? alg1 : 0;
   \      0x4C4   0x4291             CMP      R1,R2
   \      0x4C6   0xD200             BCS.N    ??psa_key_policy_algorithm_intersection_62
   \                     ??psa_key_policy_algorithm_intersection_63: (+1)
   \      0x4C8   0x2600             MOVS     R6,#+0
   \                     ??psa_key_policy_algorithm_intersection_62: (+1)
   \      0x4CA   0x0030             MOVS     R0,R6
   \      0x4CC   0xE00A             B.N      ??psa_key_policy_algorithm_intersection_1
    883                  }
    884          
    885                  /* If none of them are wildcards, check whether they define the same tag
    886                   * length. This is still possible here when one is default-length and
    887                   * the other specific-length. Ensure to always return the
    888                   * specific-length version for the intersection. */
    889                  if (alg1_len == alg2_len) {
   \                     ??psa_key_policy_algorithm_intersection_61: (+1)
   \      0x4CE   0x4291             CMP      R1,R2
   \      0x4D0   0xD107             BNE.N    ??psa_key_policy_algorithm_intersection_17
    890                      return PSA_ALG_TRUNCATED_MAC(alg1, alg1_len);
   \      0x4D2   0xF436 0x167E      BICS     R6,R6,#0x3F8000
   \      0x4D6   0x0409             LSLS     R1,R1,#+16
   \      0x4D8   0xF411 0x117C      ANDS     R1,R1,#0x3F0000
   \      0x4DC   0x430E             ORRS     R6,R1,R6
   \      0x4DE   0x0030             MOVS     R0,R6
   \      0x4E0   0xE000             B.N      ??psa_key_policy_algorithm_intersection_1
    891                  }
    892              }
    893              /* If the policies are incompatible, allow nothing. */
    894              return 0;
   \                     ??psa_key_policy_algorithm_intersection_17: (+1)
   \      0x4E2   0x2000             MOVS     R0,#+0
   \                     ??psa_key_policy_algorithm_intersection_1: (+1)
   \      0x4E4   0xBD70             POP      {R4-R6,PC}
    895          }
    896          

   \                                 In section .text, align 2, keep-with-next
    897          static int psa_key_algorithm_permits(psa_key_type_t key_type,
    898                                               psa_algorithm_t policy_alg,
    899                                               psa_algorithm_t requested_alg)
    900          {
   \                     psa_key_algorithm_permits: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    901              /* Common case: the policy only allows requested_alg. */
    902              if (requested_alg == policy_alg) {
   \        0x8   0x42AE             CMP      R6,R5
   \        0xA   0xD101             BNE.N    ??psa_key_algorithm_permits_0
    903                  return 1;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE21A             B.N      ??psa_key_algorithm_permits_1
    904              }
    905              /* If policy_alg is a hash-and-sign with a wildcard for the hash,
    906               * and requested_alg is the same hash-and-sign family with any hash,
    907               * then requested_alg is compliant with policy_alg. */
    908              if (PSA_ALG_IS_SIGN_HASH(requested_alg) &&
    909                  PSA_ALG_SIGN_GET_HASH(policy_alg) == PSA_ALG_ANY_HASH) {
   \                     ??psa_key_algorithm_permits_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0x14   0x0A31             LSRS     R1,R6,#+8
   \       0x16   0x0209             LSLS     R1,R1,#+8
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0xD01C             BEQ.N    ??psa_key_algorithm_permits_2
   \       0x1C   0x0A32             LSRS     R2,R6,#+8
   \       0x1E   0x0212             LSLS     R2,R2,#+8
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \       0x24   0x428A             CMP      R2,R1
   \       0x26   0xD016             BEQ.N    ??psa_key_algorithm_permits_2
   \       0x28   0x0A32             LSRS     R2,R6,#+8
   \       0x2A   0x0212             LSLS     R2,R2,#+8
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \       0x30   0x428A             CMP      R2,R1
   \       0x32   0xD010             BEQ.N    ??psa_key_algorithm_permits_2
   \       0x34   0x0A71             LSRS     R1,R6,#+9
   \       0x36   0x0249             LSLS     R1,R1,#+9
   \       0x38   0xF1B1 0x2F06      CMP      R1,#+100664832
   \       0x3C   0xD00B             BEQ.N    ??psa_key_algorithm_permits_2
   \       0x3E   0x0A31             LSRS     R1,R6,#+8
   \       0x40   0x0209             LSLS     R1,R1,#+8
   \       0x42   0x.... 0x....      LDR.W    R2,??DataTable6_4
   \       0x46   0x4291             CMP      R1,R2
   \       0x48   0xD005             BEQ.N    ??psa_key_algorithm_permits_2
   \       0x4A   0x0A72             LSRS     R2,R6,#+9
   \       0x4C   0x0252             LSLS     R2,R2,#+9
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0x52   0x428A             CMP      R2,R1
   \       0x54   0xD137             BNE.N    ??psa_key_algorithm_permits_3
   \                     ??psa_key_algorithm_permits_2: (+1)
   \       0x56   0x0A29             LSRS     R1,R5,#+8
   \       0x58   0x0209             LSLS     R1,R1,#+8
   \       0x5A   0x4281             CMP      R1,R0
   \       0x5C   0xD01C             BEQ.N    ??psa_key_algorithm_permits_4
   \       0x5E   0x0A29             LSRS     R1,R5,#+8
   \       0x60   0x0209             LSLS     R1,R1,#+8
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x66   0x4281             CMP      R1,R0
   \       0x68   0xD016             BEQ.N    ??psa_key_algorithm_permits_4
   \       0x6A   0x0A29             LSRS     R1,R5,#+8
   \       0x6C   0x0209             LSLS     R1,R1,#+8
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x72   0x4281             CMP      R1,R0
   \       0x74   0xD010             BEQ.N    ??psa_key_algorithm_permits_4
   \       0x76   0x0A68             LSRS     R0,R5,#+9
   \       0x78   0x0240             LSLS     R0,R0,#+9
   \       0x7A   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x7E   0xD00B             BEQ.N    ??psa_key_algorithm_permits_4
   \       0x80   0x0A29             LSRS     R1,R5,#+8
   \       0x82   0x0209             LSLS     R1,R1,#+8
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \       0x88   0x4281             CMP      R1,R0
   \       0x8A   0xD005             BEQ.N    ??psa_key_algorithm_permits_4
   \       0x8C   0x0A69             LSRS     R1,R5,#+9
   \       0x8E   0x0249             LSLS     R1,R1,#+9
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0x94   0x4281             CMP      R1,R0
   \       0x96   0xD106             BNE.N    ??psa_key_algorithm_permits_5
   \                     ??psa_key_algorithm_permits_4: (+1)
   \       0x98   0x0628             LSLS     R0,R5,#+24
   \       0x9A   0xD004             BEQ.N    ??psa_key_algorithm_permits_5
   \       0x9C   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0xA0   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xA4   0xE000             B.N      ??psa_key_algorithm_permits_6
   \                     ??psa_key_algorithm_permits_5: (+1)
   \       0xA6   0x2100             MOVS     R1,#+0
   \                     ??psa_key_algorithm_permits_6: (+1)
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \       0xAC   0x4281             CMP      R1,R0
   \       0xAE   0xD10A             BNE.N    ??psa_key_algorithm_permits_3
    910                  return (policy_alg & ~PSA_ALG_HASH_MASK) ==
    911                         (requested_alg & ~PSA_ALG_HASH_MASK);
   \       0xB0   0x0A2D             LSRS     R5,R5,#+8
   \       0xB2   0x022D             LSLS     R5,R5,#+8
   \       0xB4   0x0A36             LSRS     R6,R6,#+8
   \       0xB6   0x0236             LSLS     R6,R6,#+8
   \       0xB8   0x42B5             CMP      R5,R6
   \       0xBA   0xD101             BNE.N    ??psa_key_algorithm_permits_7
   \       0xBC   0x2001             MOVS     R0,#+1
   \       0xBE   0xE000             B.N      ??psa_key_algorithm_permits_8
   \                     ??psa_key_algorithm_permits_7: (+1)
   \       0xC0   0x2000             MOVS     R0,#+0
   \                     ??psa_key_algorithm_permits_8: (+1)
   \       0xC2   0xB2C0             UXTB     R0,R0
   \       0xC4   0xE1BF             B.N      ??psa_key_algorithm_permits_1
    912              }
    913              /* If policy_alg is a wildcard AEAD algorithm of the same base as
    914               * the requested algorithm, check the requested tag length to be
    915               * equal-length or longer than the wildcard-specified length. */
    916              if (PSA_ALG_IS_AEAD(policy_alg) &&
    917                  PSA_ALG_IS_AEAD(requested_alg) &&
    918                  (PSA_ALG_AEAD_WITH_SHORTENED_TAG(policy_alg, 0) ==
    919                   PSA_ALG_AEAD_WITH_SHORTENED_TAG(requested_alg, 0)) &&
    920                  ((policy_alg & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG) != 0)) {
   \                     ??psa_key_algorithm_permits_3: (+1)
   \       0xC6   0xF015 0x40FE      ANDS     R0,R5,#0x7F000000
   \       0xCA   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \       0xCE   0xD117             BNE.N    ??psa_key_algorithm_permits_9
   \       0xD0   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \       0xD4   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \       0xD8   0xD112             BNE.N    ??psa_key_algorithm_permits_9
   \       0xDA   0xF435 0x117E      BICS     R1,R5,#0x3F8000
   \       0xDE   0xF436 0x107E      BICS     R0,R6,#0x3F8000
   \       0xE2   0x4281             CMP      R1,R0
   \       0xE4   0xD10C             BNE.N    ??psa_key_algorithm_permits_9
   \       0xE6   0x0428             LSLS     R0,R5,#+16
   \       0xE8   0xD50A             BPL.N    ??psa_key_algorithm_permits_9
    921                  return PSA_ALG_AEAD_GET_TAG_LENGTH(policy_alg) <=
    922                         PSA_ALG_AEAD_GET_TAG_LENGTH(requested_alg);
   \       0xEA   0xF3C6 0x4005      UBFX     R0,R6,#+16,#+6
   \       0xEE   0xF3C5 0x4105      UBFX     R1,R5,#+16,#+6
   \       0xF2   0x4288             CMP      R0,R1
   \       0xF4   0xD301             BCC.N    ??psa_key_algorithm_permits_10
   \       0xF6   0x2001             MOVS     R0,#+1
   \       0xF8   0xE000             B.N      ??psa_key_algorithm_permits_11
   \                     ??psa_key_algorithm_permits_10: (+1)
   \       0xFA   0x2000             MOVS     R0,#+0
   \                     ??psa_key_algorithm_permits_11: (+1)
   \       0xFC   0xB2C0             UXTB     R0,R0
   \       0xFE   0xE1A2             B.N      ??psa_key_algorithm_permits_1
    923              }
    924              /* If policy_alg is a MAC algorithm of the same base as the requested
    925               * algorithm, check whether their MAC lengths are compatible. */
    926              if (PSA_ALG_IS_MAC(policy_alg) &&
    927                  PSA_ALG_IS_MAC(requested_alg) &&
    928                  (PSA_ALG_FULL_LENGTH_MAC(policy_alg) ==
    929                   PSA_ALG_FULL_LENGTH_MAC(requested_alg))) {
   \                     ??psa_key_algorithm_permits_9: (+1)
   \      0x100   0xF015 0x40FE      ANDS     R0,R5,#0x7F000000
   \      0x104   0xF1B0 0x7F40      CMP      R0,#+50331648
   \      0x108   0xF040 0x817F      BNE.W    ??psa_key_algorithm_permits_12
   \      0x10C   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \      0x110   0xF1B0 0x7F40      CMP      R0,#+50331648
   \      0x114   0xF040 0x8179      BNE.W    ??psa_key_algorithm_permits_12
   \      0x118   0xF435 0x117E      BICS     R1,R5,#0x3F8000
   \      0x11C   0xF436 0x107E      BICS     R0,R6,#0x3F8000
   \      0x120   0x4281             CMP      R1,R0
   \      0x122   0xF040 0x8172      BNE.W    ??psa_key_algorithm_permits_12
    930                  /* Validate the combination of key type and algorithm. Since the policy
    931                   * and requested algorithms are the same, we only need this once. */
    932                  if (PSA_SUCCESS != psa_mac_key_can_do(policy_alg, key_type)) {
   \      0x126   0x0021             MOVS     R1,R4
   \      0x128   0xB289             UXTH     R1,R1
   \      0x12A   0x0028             MOVS     R0,R5
   \      0x12C   0x.... 0x....      BL       psa_mac_key_can_do
   \      0x130   0x2800             CMP      R0,#+0
   \      0x132   0xD001             BEQ.N    ??psa_key_algorithm_permits_13
    933                      return 0;
   \      0x134   0x2000             MOVS     R0,#+0
   \      0x136   0xE186             B.N      ??psa_key_algorithm_permits_1
    934                  }
    935          
    936                  /* Get both the requested output length for the algorithm which is to be
    937                   * verified, and the default output length for the base algorithm.
    938                   * Note that none of the currently supported algorithms have an output
    939                   * length dependent on actual key size, so setting it to a bogus value
    940                   * of 0 is currently OK. */
    941                  size_t requested_output_length = PSA_MAC_LENGTH(
    942                      key_type, 0, requested_alg);
   \                     ??psa_key_algorithm_permits_13: (+1)
   \      0x138   0xF416 0x1F7C      TST      R6,#0x3F0000
   \      0x13C   0xD002             BEQ.N    ??psa_key_algorithm_permits_14
   \      0x13E   0xF3C6 0x4105      UBFX     R1,R6,#+16,#+6
   \      0x142   0xE0A1             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_14: (+1)
   \      0x144   0x.... 0x....      LDR.W    R1,??DataTable5
   \      0x148   0xEA11 0x0006      ANDS     R0,R1,R6
   \      0x14C   0xF1B0 0x7F60      CMP      R0,#+58720256
   \      0x150   0xF040 0x8084      BNE.W    ??psa_key_algorithm_permits_16
   \      0x154   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x158   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x15C   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x160   0x4281             CMP      R1,R0
   \      0x162   0xD101             BNE.N    ??psa_key_algorithm_permits_17
   \      0x164   0x2110             MOVS     R1,#+16
   \      0x166   0xE08F             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_17: (+1)
   \      0x168   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x16C   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x170   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \      0x174   0x4281             CMP      R1,R0
   \      0x176   0xD101             BNE.N    ??psa_key_algorithm_permits_18
   \      0x178   0x2114             MOVS     R1,#+20
   \      0x17A   0xE085             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_18: (+1)
   \      0x17C   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x180   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x184   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0x188   0x4281             CMP      R1,R0
   \      0x18A   0xD101             BNE.N    ??psa_key_algorithm_permits_19
   \      0x18C   0x2114             MOVS     R1,#+20
   \      0x18E   0xE07B             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_19: (+1)
   \      0x190   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x194   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x198   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \      0x19C   0x4281             CMP      R1,R0
   \      0x19E   0xD101             BNE.N    ??psa_key_algorithm_permits_20
   \      0x1A0   0x211C             MOVS     R1,#+28
   \      0x1A2   0xE071             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_20: (+1)
   \      0x1A4   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x1A8   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x1AC   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \      0x1B0   0x4281             CMP      R1,R0
   \      0x1B2   0xD101             BNE.N    ??psa_key_algorithm_permits_21
   \      0x1B4   0x2120             MOVS     R1,#+32
   \      0x1B6   0xE067             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_21: (+1)
   \      0x1B8   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x1BC   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x1C0   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \      0x1C4   0x4281             CMP      R1,R0
   \      0x1C6   0xD101             BNE.N    ??psa_key_algorithm_permits_22
   \      0x1C8   0x2130             MOVS     R1,#+48
   \      0x1CA   0xE05D             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_22: (+1)
   \      0x1CC   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x1D0   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x1D4   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \      0x1D8   0x4288             CMP      R0,R1
   \      0x1DA   0xD101             BNE.N    ??psa_key_algorithm_permits_23
   \      0x1DC   0x2140             MOVS     R1,#+64
   \      0x1DE   0xE053             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_23: (+1)
   \      0x1E0   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x1E4   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x1E8   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \      0x1EC   0x4281             CMP      R1,R0
   \      0x1EE   0xD101             BNE.N    ??psa_key_algorithm_permits_24
   \      0x1F0   0x211C             MOVS     R1,#+28
   \      0x1F2   0xE049             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_24: (+1)
   \      0x1F4   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x1F8   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x1FC   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \      0x200   0x4281             CMP      R1,R0
   \      0x202   0xD101             BNE.N    ??psa_key_algorithm_permits_25
   \      0x204   0x2120             MOVS     R1,#+32
   \      0x206   0xE03F             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_25: (+1)
   \      0x208   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x20C   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x210   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \      0x214   0x4281             CMP      R1,R0
   \      0x216   0xD101             BNE.N    ??psa_key_algorithm_permits_26
   \      0x218   0x211C             MOVS     R1,#+28
   \      0x21A   0xE035             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_26: (+1)
   \      0x21C   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x220   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x224   0x.... 0x....      LDR.W    R0,??DataTable8_8
   \      0x228   0x4281             CMP      R1,R0
   \      0x22A   0xD101             BNE.N    ??psa_key_algorithm_permits_27
   \      0x22C   0x2120             MOVS     R1,#+32
   \      0x22E   0xE02B             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_27: (+1)
   \      0x230   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x234   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x238   0x.... 0x....      LDR.W    R1,??DataTable8_9
   \      0x23C   0x4288             CMP      R0,R1
   \      0x23E   0xD101             BNE.N    ??psa_key_algorithm_permits_28
   \      0x240   0x2130             MOVS     R1,#+48
   \      0x242   0xE021             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_28: (+1)
   \      0x244   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x248   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x24C   0x.... 0x....      LDR.W    R0,??DataTable8_10
   \      0x250   0x4281             CMP      R1,R0
   \      0x252   0xD101             BNE.N    ??psa_key_algorithm_permits_29
   \      0x254   0x2140             MOVS     R1,#+64
   \      0x256   0xE017             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_29: (+1)
   \      0x258   0x2100             MOVS     R1,#+0
   \      0x25A   0xE015             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_16: (+1)
   \      0x25C   0x4031             ANDS     R1,R1,R6
   \      0x25E   0xF1B1 0x7F70      CMP      R1,#+62914560
   \      0x262   0xD110             BNE.N    ??psa_key_algorithm_permits_30
   \      0x264   0x0020             MOVS     R0,R4
   \      0x266   0xB280             UXTH     R0,R0
   \      0x268   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \      0x26C   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x270   0xD107             BNE.N    ??psa_key_algorithm_permits_31
   \      0x272   0x2101             MOVS     R1,#+1
   \      0x274   0x0020             MOVS     R0,R4
   \      0x276   0xB280             UXTH     R0,R0
   \      0x278   0x0A00             LSRS     R0,R0,#+8
   \      0x27A   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x27E   0x4081             LSLS     R1,R1,R0
   \      0x280   0xE002             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_31: (+1)
   \      0x282   0x2100             MOVS     R1,#+0
   \      0x284   0xE000             B.N      ??psa_key_algorithm_permits_15
   \                     ??psa_key_algorithm_permits_30: (+1)
   \      0x286   0x2100             MOVS     R1,#+0
    943                  size_t default_output_length = PSA_MAC_LENGTH(
    944                      key_type, 0,
    945                      PSA_ALG_FULL_LENGTH_MAC(requested_alg));
   \                     ??psa_key_algorithm_permits_15: (+1)
   \      0x288   0x....             LDR.N    R2,??DataTable5
   \      0x28A   0xEA12 0x0006      ANDS     R0,R2,R6
   \      0x28E   0xF1B0 0x7F60      CMP      R0,#+58720256
   \      0x292   0xF040 0x8084      BNE.W    ??psa_key_algorithm_permits_32
   \      0x296   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x29A   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x29E   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x2A2   0x4282             CMP      R2,R0
   \      0x2A4   0xD101             BNE.N    ??psa_key_algorithm_permits_33
   \      0x2A6   0x2210             MOVS     R2,#+16
   \      0x2A8   0xE08F             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_33: (+1)
   \      0x2AA   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x2AE   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x2B2   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \      0x2B6   0x4282             CMP      R2,R0
   \      0x2B8   0xD101             BNE.N    ??psa_key_algorithm_permits_35
   \      0x2BA   0x2214             MOVS     R2,#+20
   \      0x2BC   0xE085             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_35: (+1)
   \      0x2BE   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x2C2   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x2C6   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0x2CA   0x4282             CMP      R2,R0
   \      0x2CC   0xD101             BNE.N    ??psa_key_algorithm_permits_36
   \      0x2CE   0x2214             MOVS     R2,#+20
   \      0x2D0   0xE07B             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_36: (+1)
   \      0x2D2   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x2D6   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x2DA   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \      0x2DE   0x4282             CMP      R2,R0
   \      0x2E0   0xD101             BNE.N    ??psa_key_algorithm_permits_37
   \      0x2E2   0x221C             MOVS     R2,#+28
   \      0x2E4   0xE071             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_37: (+1)
   \      0x2E6   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x2EA   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x2EE   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \      0x2F2   0x4282             CMP      R2,R0
   \      0x2F4   0xD101             BNE.N    ??psa_key_algorithm_permits_38
   \      0x2F6   0x2220             MOVS     R2,#+32
   \      0x2F8   0xE067             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_38: (+1)
   \      0x2FA   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x2FE   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x302   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \      0x306   0x4282             CMP      R2,R0
   \      0x308   0xD101             BNE.N    ??psa_key_algorithm_permits_39
   \      0x30A   0x2230             MOVS     R2,#+48
   \      0x30C   0xE05D             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_39: (+1)
   \      0x30E   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x312   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x316   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \      0x31A   0x4282             CMP      R2,R0
   \      0x31C   0xD101             BNE.N    ??psa_key_algorithm_permits_40
   \      0x31E   0x2240             MOVS     R2,#+64
   \      0x320   0xE053             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_40: (+1)
   \      0x322   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x326   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x32A   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \      0x32E   0x4282             CMP      R2,R0
   \      0x330   0xD101             BNE.N    ??psa_key_algorithm_permits_41
   \      0x332   0x221C             MOVS     R2,#+28
   \      0x334   0xE049             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_41: (+1)
   \      0x336   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x33A   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x33E   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \      0x342   0x4282             CMP      R2,R0
   \      0x344   0xD101             BNE.N    ??psa_key_algorithm_permits_42
   \      0x346   0x2220             MOVS     R2,#+32
   \      0x348   0xE03F             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_42: (+1)
   \      0x34A   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x34E   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x352   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \      0x356   0x4282             CMP      R2,R0
   \      0x358   0xD101             BNE.N    ??psa_key_algorithm_permits_43
   \      0x35A   0x221C             MOVS     R2,#+28
   \      0x35C   0xE035             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_43: (+1)
   \      0x35E   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x362   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x366   0x.... 0x....      LDR.W    R2,??DataTable8_8
   \      0x36A   0x4290             CMP      R0,R2
   \      0x36C   0xD101             BNE.N    ??psa_key_algorithm_permits_44
   \      0x36E   0x2220             MOVS     R2,#+32
   \      0x370   0xE02B             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_44: (+1)
   \      0x372   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x376   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x37A   0x.... 0x....      LDR.W    R2,??DataTable8_9
   \      0x37E   0x4290             CMP      R0,R2
   \      0x380   0xD101             BNE.N    ??psa_key_algorithm_permits_45
   \      0x382   0x2230             MOVS     R2,#+48
   \      0x384   0xE021             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_45: (+1)
   \      0x386   0xF006 0x02FF      AND      R2,R6,#0xFF
   \      0x38A   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x38E   0x.... 0x....      LDR.W    R0,??DataTable8_10
   \      0x392   0x4282             CMP      R2,R0
   \      0x394   0xD101             BNE.N    ??psa_key_algorithm_permits_46
   \      0x396   0x2240             MOVS     R2,#+64
   \      0x398   0xE017             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_46: (+1)
   \      0x39A   0x2200             MOVS     R2,#+0
   \      0x39C   0xE015             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_32: (+1)
   \      0x39E   0x4032             ANDS     R2,R2,R6
   \      0x3A0   0xF1B2 0x7F70      CMP      R2,#+62914560
   \      0x3A4   0xD110             BNE.N    ??psa_key_algorithm_permits_47
   \      0x3A6   0x0020             MOVS     R0,R4
   \      0x3A8   0xB280             UXTH     R0,R0
   \      0x3AA   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \      0x3AE   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x3B2   0xD107             BNE.N    ??psa_key_algorithm_permits_48
   \      0x3B4   0x2201             MOVS     R2,#+1
   \      0x3B6   0x0020             MOVS     R0,R4
   \      0x3B8   0xB280             UXTH     R0,R0
   \      0x3BA   0x0A00             LSRS     R0,R0,#+8
   \      0x3BC   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x3C0   0x4082             LSLS     R2,R2,R0
   \      0x3C2   0xE002             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_48: (+1)
   \      0x3C4   0x2200             MOVS     R2,#+0
   \      0x3C6   0xE000             B.N      ??psa_key_algorithm_permits_34
   \                     ??psa_key_algorithm_permits_47: (+1)
   \      0x3C8   0x2200             MOVS     R2,#+0
    946          
    947                  /* If the policy is default-length, only allow an algorithm with
    948                   * a declared exact-length matching the default. */
    949                  if (PSA_MAC_TRUNCATED_LENGTH(policy_alg) == 0) {
   \                     ??psa_key_algorithm_permits_34: (+1)
   \      0x3CA   0xF3C5 0x4005      UBFX     R0,R5,#+16,#+6
   \      0x3CE   0x2800             CMP      R0,#+0
   \      0x3D0   0xD106             BNE.N    ??psa_key_algorithm_permits_49
    950                      return requested_output_length == default_output_length;
   \      0x3D2   0x4291             CMP      R1,R2
   \      0x3D4   0xD101             BNE.N    ??psa_key_algorithm_permits_50
   \      0x3D6   0x2001             MOVS     R0,#+1
   \      0x3D8   0xE000             B.N      ??psa_key_algorithm_permits_51
   \                     ??psa_key_algorithm_permits_50: (+1)
   \      0x3DA   0x2000             MOVS     R0,#+0
   \                     ??psa_key_algorithm_permits_51: (+1)
   \      0x3DC   0xB2C0             UXTB     R0,R0
   \      0x3DE   0xE032             B.N      ??psa_key_algorithm_permits_1
    951                  }
    952          
    953                  /* If the requested algorithm is default-length, allow it if the policy
    954                   * length exactly matches the default length. */
    955                  if (PSA_MAC_TRUNCATED_LENGTH(requested_alg) == 0 &&
    956                      PSA_MAC_TRUNCATED_LENGTH(policy_alg) == default_output_length) {
   \                     ??psa_key_algorithm_permits_49: (+1)
   \      0x3E0   0xF3C6 0x4005      UBFX     R0,R6,#+16,#+6
   \      0x3E4   0x2800             CMP      R0,#+0
   \      0x3E6   0xD105             BNE.N    ??psa_key_algorithm_permits_52
   \      0x3E8   0xF3C5 0x4005      UBFX     R0,R5,#+16,#+6
   \      0x3EC   0x4290             CMP      R0,R2
   \      0x3EE   0xD101             BNE.N    ??psa_key_algorithm_permits_52
    957                      return 1;
   \      0x3F0   0x2001             MOVS     R0,#+1
   \      0x3F2   0xE028             B.N      ??psa_key_algorithm_permits_1
    958                  }
    959          
    960                  /* If policy_alg is an at-least-this-length wildcard MAC algorithm,
    961                   * check for the requested MAC length to be equal to or longer than the
    962                   * minimum allowed length. */
    963                  if ((policy_alg & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG) != 0) {
   \                     ??psa_key_algorithm_permits_52: (+1)
   \      0x3F4   0x0428             LSLS     R0,R5,#+16
   \      0x3F6   0xD508             BPL.N    ??psa_key_algorithm_permits_12
    964                      return PSA_MAC_TRUNCATED_LENGTH(policy_alg) <=
    965                             requested_output_length;
   \      0x3F8   0xF3C5 0x4005      UBFX     R0,R5,#+16,#+6
   \      0x3FC   0x4281             CMP      R1,R0
   \      0x3FE   0xD301             BCC.N    ??psa_key_algorithm_permits_53
   \      0x400   0x2001             MOVS     R0,#+1
   \      0x402   0xE000             B.N      ??psa_key_algorithm_permits_54
   \                     ??psa_key_algorithm_permits_53: (+1)
   \      0x404   0x2000             MOVS     R0,#+0
   \                     ??psa_key_algorithm_permits_54: (+1)
   \      0x406   0xB2C0             UXTB     R0,R0
   \      0x408   0xE01D             B.N      ??psa_key_algorithm_permits_1
    966                  }
    967              }
    968              /* If policy_alg is a generic key agreement operation, then using it for
    969               * a key derivation with that key agreement should also be allowed. This
    970               * behaviour is expected to be defined in a future specification version. */
    971              if (PSA_ALG_IS_RAW_KEY_AGREEMENT(policy_alg) &&
    972                  PSA_ALG_IS_KEY_AGREEMENT(requested_alg)) {
   \                     ??psa_key_algorithm_permits_12: (+1)
   \      0x40A   0xF015 0x40FE      ANDS     R0,R5,#0x7F000000
   \      0x40E   0xF1B0 0x6F10      CMP      R0,#+150994944
   \      0x412   0xD117             BNE.N    ??psa_key_algorithm_permits_55
   \      0x414   0x0028             MOVS     R0,R5
   \      0x416   0xF36F 0x4018      BFC      R0,#+16,#+9
   \      0x41A   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \      0x41E   0xF1B0 0x6F00      CMP      R0,#+134217728
   \      0x422   0xD10F             BNE.N    ??psa_key_algorithm_permits_55
   \      0x424   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \      0x428   0xF1B0 0x6F10      CMP      R0,#+150994944
   \      0x42C   0xD10A             BNE.N    ??psa_key_algorithm_permits_55
    973                  return PSA_ALG_KEY_AGREEMENT_GET_BASE(requested_alg) ==
    974                         policy_alg;
   \      0x42E   0x0C36             LSRS     R6,R6,#+16
   \      0x430   0x0436             LSLS     R6,R6,#+16
   \      0x432   0xF056 0x6610      ORRS     R6,R6,#0x9000000
   \      0x436   0x42AE             CMP      R6,R5
   \      0x438   0xD101             BNE.N    ??psa_key_algorithm_permits_56
   \      0x43A   0x2001             MOVS     R0,#+1
   \      0x43C   0xE000             B.N      ??psa_key_algorithm_permits_57
   \                     ??psa_key_algorithm_permits_56: (+1)
   \      0x43E   0x2000             MOVS     R0,#+0
   \                     ??psa_key_algorithm_permits_57: (+1)
   \      0x440   0xB2C0             UXTB     R0,R0
   \      0x442   0xE000             B.N      ??psa_key_algorithm_permits_1
    975              }
    976              /* If it isn't explicitly permitted, it's forbidden. */
    977              return 0;
   \                     ??psa_key_algorithm_permits_55: (+1)
   \      0x444   0x2000             MOVS     R0,#+0
   \                     ??psa_key_algorithm_permits_1: (+1)
   \      0x446   0xBD70             POP      {R4-R6,PC}
    978          }
    979          
    980          /** Test whether a policy permits an algorithm.
    981           *
    982           * The caller must test usage flags separately.
    983           *
    984           * \note This function requires providing the key type for which the policy is
    985           *       being validated, since some algorithm policy definitions (e.g. MAC)
    986           *       have different properties depending on what kind of cipher it is
    987           *       combined with.
    988           *
    989           * \retval PSA_SUCCESS                  When \p alg is a specific algorithm
    990           *                                      allowed by the \p policy.
    991           * \retval PSA_ERROR_INVALID_ARGUMENT   When \p alg is not a specific algorithm
    992           * \retval PSA_ERROR_NOT_PERMITTED      When \p alg is a specific algorithm, but
    993           *                                      the \p policy does not allow it.
    994           */

   \                                 In section .text, align 2, keep-with-next
    995          static psa_status_t psa_key_policy_permits(const psa_key_policy_t *policy,
    996                                                     psa_key_type_t key_type,
    997                                                     psa_algorithm_t alg)
    998          {
   \                     psa_key_policy_permits: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
    999              /* '0' is not a valid algorithm */
   1000              if (alg == 0) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD102             BNE.N    ??psa_key_policy_permits_0
   1001                  return PSA_ERROR_INVALID_ARGUMENT;
   \        0xC   0xF07F 0x0086      MVNS     R0,#+134
   \       0x10   0xE07E             B.N      ??psa_key_policy_permits_1
   1002              }
   1003          
   1004              /* A requested algorithm cannot be a wildcard. */
   1005              if (PSA_ALG_IS_WILDCARD(alg)) {
   \                     ??psa_key_policy_permits_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable6_1
   \       0x14   0x0A21             LSRS     R1,R4,#+8
   \       0x16   0x0209             LSLS     R1,R1,#+8
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0xD018             BEQ.N    ??psa_key_policy_permits_2
   \       0x1C   0x0A22             LSRS     R2,R4,#+8
   \       0x1E   0x0212             LSLS     R2,R2,#+8
   \       0x20   0x....             LDR.N    R1,??DataTable6_2
   \       0x22   0x428A             CMP      R2,R1
   \       0x24   0xD013             BEQ.N    ??psa_key_policy_permits_2
   \       0x26   0x0A22             LSRS     R2,R4,#+8
   \       0x28   0x0212             LSLS     R2,R2,#+8
   \       0x2A   0x....             LDR.N    R1,??DataTable6_3
   \       0x2C   0x428A             CMP      R2,R1
   \       0x2E   0xD00E             BEQ.N    ??psa_key_policy_permits_2
   \       0x30   0x0A61             LSRS     R1,R4,#+9
   \       0x32   0x0249             LSLS     R1,R1,#+9
   \       0x34   0xF1B1 0x2F06      CMP      R1,#+100664832
   \       0x38   0xD009             BEQ.N    ??psa_key_policy_permits_2
   \       0x3A   0x0A21             LSRS     R1,R4,#+8
   \       0x3C   0x0209             LSLS     R1,R1,#+8
   \       0x3E   0x....             LDR.N    R2,??DataTable6_4
   \       0x40   0x4291             CMP      R1,R2
   \       0x42   0xD004             BEQ.N    ??psa_key_policy_permits_2
   \       0x44   0x0A62             LSRS     R2,R4,#+9
   \       0x46   0x0252             LSLS     R2,R2,#+9
   \       0x48   0x....             LDR.N    R1,??DataTable6_5
   \       0x4A   0x428A             CMP      R2,R1
   \       0x4C   0xD12D             BNE.N    ??psa_key_policy_permits_3
   \                     ??psa_key_policy_permits_2: (+1)
   \       0x4E   0x0621             LSLS     R1,R4,#+24
   \       0x50   0xD02B             BEQ.N    ??psa_key_policy_permits_3
   \       0x52   0x0A21             LSRS     R1,R4,#+8
   \       0x54   0x0209             LSLS     R1,R1,#+8
   \       0x56   0x4281             CMP      R1,R0
   \       0x58   0xD018             BEQ.N    ??psa_key_policy_permits_4
   \       0x5A   0x0A21             LSRS     R1,R4,#+8
   \       0x5C   0x0209             LSLS     R1,R1,#+8
   \       0x5E   0x....             LDR.N    R0,??DataTable6_2
   \       0x60   0x4281             CMP      R1,R0
   \       0x62   0xD013             BEQ.N    ??psa_key_policy_permits_4
   \       0x64   0x0A21             LSRS     R1,R4,#+8
   \       0x66   0x0209             LSLS     R1,R1,#+8
   \       0x68   0x....             LDR.N    R0,??DataTable6_3
   \       0x6A   0x4281             CMP      R1,R0
   \       0x6C   0xD00E             BEQ.N    ??psa_key_policy_permits_4
   \       0x6E   0x0A60             LSRS     R0,R4,#+9
   \       0x70   0x0240             LSLS     R0,R0,#+9
   \       0x72   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x76   0xD009             BEQ.N    ??psa_key_policy_permits_4
   \       0x78   0x0A20             LSRS     R0,R4,#+8
   \       0x7A   0x0200             LSLS     R0,R0,#+8
   \       0x7C   0x....             LDR.N    R1,??DataTable6_4
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0xD004             BEQ.N    ??psa_key_policy_permits_4
   \       0x82   0x0A61             LSRS     R1,R4,#+9
   \       0x84   0x0249             LSLS     R1,R1,#+9
   \       0x86   0x....             LDR.N    R0,??DataTable6_5
   \       0x88   0x4281             CMP      R1,R0
   \       0x8A   0xD106             BNE.N    ??psa_key_policy_permits_5
   \                     ??psa_key_policy_permits_4: (+1)
   \       0x8C   0x0620             LSLS     R0,R4,#+24
   \       0x8E   0xD004             BEQ.N    ??psa_key_policy_permits_5
   \       0x90   0xF004 0x01FF      AND      R1,R4,#0xFF
   \       0x94   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x98   0xE000             B.N      ??psa_key_policy_permits_6
   \                     ??psa_key_policy_permits_5: (+1)
   \       0x9A   0x2100             MOVS     R1,#+0
   \                     ??psa_key_policy_permits_6: (+1)
   \       0x9C   0x....             LDR.N    R0,??DataTable6_6
   \       0x9E   0x4281             CMP      R1,R0
   \       0xA0   0xD101             BNE.N    ??psa_key_policy_permits_7
   \       0xA2   0x2001             MOVS     R0,#+1
   \       0xA4   0xE01B             B.N      ??psa_key_policy_permits_8
   \                     ??psa_key_policy_permits_7: (+1)
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xE019             B.N      ??psa_key_policy_permits_8
   \                     ??psa_key_policy_permits_3: (+1)
   \       0xAA   0xF014 0x40FE      ANDS     R0,R4,#0x7F000000
   \       0xAE   0xF1B0 0x7F40      CMP      R0,#+50331648
   \       0xB2   0xD104             BNE.N    ??psa_key_policy_permits_9
   \       0xB4   0xF3C4 0x30C0      UBFX     R0,R4,#+15,#+1
   \       0xB8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xBC   0xE00F             B.N      ??psa_key_policy_permits_8
   \                     ??psa_key_policy_permits_9: (+1)
   \       0xBE   0xF014 0x40FE      ANDS     R0,R4,#0x7F000000
   \       0xC2   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \       0xC6   0xD104             BNE.N    ??psa_key_policy_permits_10
   \       0xC8   0xF3C4 0x30C0      UBFX     R0,R4,#+15,#+1
   \       0xCC   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xD0   0xE005             B.N      ??psa_key_policy_permits_8
   \                     ??psa_key_policy_permits_10: (+1)
   \       0xD2   0x....             LDR.N    R0,??DataTable6_6
   \       0xD4   0x4284             CMP      R4,R0
   \       0xD6   0xD101             BNE.N    ??psa_key_policy_permits_11
   \       0xD8   0x2001             MOVS     R0,#+1
   \       0xDA   0xE000             B.N      ??psa_key_policy_permits_8
   \                     ??psa_key_policy_permits_11: (+1)
   \       0xDC   0x2000             MOVS     R0,#+0
   \                     ??psa_key_policy_permits_8: (+1)
   \       0xDE   0x2800             CMP      R0,#+0
   \       0xE0   0xD002             BEQ.N    ??psa_key_policy_permits_12
   1006                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0xE2   0xF07F 0x0086      MVNS     R0,#+134
   \       0xE6   0xE013             B.N      ??psa_key_policy_permits_1
   1007              }
   1008          
   1009              if (psa_key_algorithm_permits(key_type, policy->alg, alg) ||
   1010                  psa_key_algorithm_permits(key_type, policy->alg2, alg)) {
   \                     ??psa_key_policy_permits_12: (+1)
   \       0xE8   0x0022             MOVS     R2,R4
   \       0xEA   0x6869             LDR      R1,[R5, #+4]
   \       0xEC   0x0030             MOVS     R0,R6
   \       0xEE   0xB280             UXTH     R0,R0
   \       0xF0   0x.... 0x....      BL       psa_key_algorithm_permits
   \       0xF4   0x2800             CMP      R0,#+0
   \       0xF6   0xD107             BNE.N    ??psa_key_policy_permits_13
   \       0xF8   0x0022             MOVS     R2,R4
   \       0xFA   0x68A9             LDR      R1,[R5, #+8]
   \       0xFC   0x0030             MOVS     R0,R6
   \       0xFE   0xB280             UXTH     R0,R0
   \      0x100   0x.... 0x....      BL       psa_key_algorithm_permits
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD001             BEQ.N    ??psa_key_policy_permits_14
   1011                  return PSA_SUCCESS;
   \                     ??psa_key_policy_permits_13: (+1)
   \      0x108   0x2000             MOVS     R0,#+0
   \      0x10A   0xE001             B.N      ??psa_key_policy_permits_1
   1012              } else {
   1013                  return PSA_ERROR_NOT_PERMITTED;
   \                     ??psa_key_policy_permits_14: (+1)
   \      0x10C   0xF07F 0x0084      MVNS     R0,#+132
   \                     ??psa_key_policy_permits_1: (+1)
   \      0x110   0xBD70             POP      {R4-R6,PC}
   1014              }
   1015          }
   1016          
   1017          /** Restrict a key policy based on a constraint.
   1018           *
   1019           * \note This function requires providing the key type for which the policy is
   1020           *       being restricted, since some algorithm policy definitions (e.g. MAC)
   1021           *       have different properties depending on what kind of cipher it is
   1022           *       combined with.
   1023           *
   1024           * \param[in] key_type      The key type for which to restrict the policy
   1025           * \param[in,out] policy    The policy to restrict.
   1026           * \param[in] constraint    The policy constraint to apply.
   1027           *
   1028           * \retval #PSA_SUCCESS
   1029           *         \c *policy contains the intersection of the original value of
   1030           *         \c *policy and \c *constraint.
   1031           * \retval #PSA_ERROR_INVALID_ARGUMENT
   1032           *         \c key_type, \c *policy and \c *constraint are incompatible.
   1033           *         \c *policy is unchanged.
   1034           */

   \                                 In section .text, align 2, keep-with-next
   1035          static psa_status_t psa_restrict_key_policy(
   1036              psa_key_type_t key_type,
   1037              psa_key_policy_t *policy,
   1038              const psa_key_policy_t *constraint)
   1039          {
   \                     psa_restrict_key_policy: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1040              psa_algorithm_t intersection_alg =
   1041                  psa_key_policy_algorithm_intersection(key_type, policy->alg,
   1042                                                        constraint->alg);
   \        0x8   0x6872             LDR      R2,[R6, #+4]
   \        0xA   0x6869             LDR      R1,[R5, #+4]
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0xB280             UXTH     R0,R0
   \       0x10   0x.... 0x....      BL       psa_key_policy_algorithm_intersection
   \       0x14   0x0004             MOVS     R4,R0
   1043              psa_algorithm_t intersection_alg2 =
   1044                  psa_key_policy_algorithm_intersection(key_type, policy->alg2,
   1045                                                        constraint->alg2);
   \       0x16   0x68B2             LDR      R2,[R6, #+8]
   \       0x18   0x68A9             LDR      R1,[R5, #+8]
   \       0x1A   0x0038             MOVS     R0,R7
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0x.... 0x....      BL       psa_key_policy_algorithm_intersection
   \       0x22   0x0001             MOVS     R1,R0
   1046              if (intersection_alg == 0 && policy->alg != 0 && constraint->alg != 0) {
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD108             BNE.N    ??psa_restrict_key_policy_0
   \       0x28   0x6868             LDR      R0,[R5, #+4]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD005             BEQ.N    ??psa_restrict_key_policy_0
   \       0x2E   0x6870             LDR      R0,[R6, #+4]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD002             BEQ.N    ??psa_restrict_key_policy_0
   1047                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x34   0xF07F 0x0086      MVNS     R0,#+134
   \       0x38   0xE011             B.N      ??psa_restrict_key_policy_1
   1048              }
   1049              if (intersection_alg2 == 0 && policy->alg2 != 0 && constraint->alg2 != 0) {
   \                     ??psa_restrict_key_policy_0: (+1)
   \       0x3A   0x2900             CMP      R1,#+0
   \       0x3C   0xD108             BNE.N    ??psa_restrict_key_policy_2
   \       0x3E   0x68A8             LDR      R0,[R5, #+8]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD005             BEQ.N    ??psa_restrict_key_policy_2
   \       0x44   0x68B0             LDR      R0,[R6, #+8]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD002             BEQ.N    ??psa_restrict_key_policy_2
   1050                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x4A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x4E   0xE006             B.N      ??psa_restrict_key_policy_1
   1051              }
   1052              policy->usage &= constraint->usage;
   \                     ??psa_restrict_key_policy_2: (+1)
   \       0x50   0x682A             LDR      R2,[R5, #+0]
   \       0x52   0x6830             LDR      R0,[R6, #+0]
   \       0x54   0x4002             ANDS     R2,R0,R2
   \       0x56   0x602A             STR      R2,[R5, #+0]
   1053              policy->alg = intersection_alg;
   \       0x58   0x606C             STR      R4,[R5, #+4]
   1054              policy->alg2 = intersection_alg2;
   \       0x5A   0x60A9             STR      R1,[R5, #+8]
   1055              return PSA_SUCCESS;
   \       0x5C   0x2000             MOVS     R0,#+0
   \                     ??psa_restrict_key_policy_1: (+1)
   \       0x5E   0xBDF2             POP      {R1,R4-R7,PC}
   1056          }
   1057          
   1058          /** Get the description of a key given its identifier and policy constraints
   1059           *  and lock it.
   1060           *
   1061           * The key must have allow all the usage flags set in \p usage. If \p alg is
   1062           * nonzero, the key must allow operations with this algorithm. If \p alg is
   1063           * zero, the algorithm is not checked.
   1064           *
   1065           * In case of a persistent key, the function loads the description of the key
   1066           * into a key slot if not already done.
   1067           *
   1068           * On success, the returned key slot is locked. It is the responsibility of
   1069           * the caller to unlock the key slot when it does not access it anymore.
   1070           */

   \                                 In section .text, align 2, keep-with-next
   1071          static psa_status_t psa_get_and_lock_key_slot_with_policy(
   1072              mbedtls_svc_key_id_t key,
   1073              psa_key_slot_t **p_slot,
   1074              psa_key_usage_t usage,
   1075              psa_algorithm_t alg)
   1076          {
   \                     psa_get_and_lock_key_slot_with_policy: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001D             MOVS     R5,R3
   1077              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x0A96      MVNS     R10,#+150
   1078              psa_key_slot_t *slot = NULL;
   \       0x10   0xF05F 0x0900      MOVS     R9,#+0
   1079          
   1080              status = psa_get_and_lock_key_slot( key, p_slot, PSA_INTENT_READ );
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x0039             MOVS     R1,R7
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x.... 0x....      BL       psa_get_and_lock_key_slot
   \       0x1E   0x0004             MOVS     R4,R0
   1081              if( status != PSA_SUCCESS )
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD001             BEQ.N    ??psa_get_and_lock_key_slot_with_policy_0
   1082                  return( status );
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xE02A             B.N      ??psa_get_and_lock_key_slot_with_policy_1
   1083              slot = *p_slot;
   \                     ??psa_get_and_lock_key_slot_with_policy_0: (+1)
   \       0x28   0xF8D7 0xA000      LDR      R10,[R7, #+0]
   1084          
   1085              /* Enforce that usage policy for the key slot contains all the flags
   1086               * required by the usage parameter. There is one exception: public
   1087               * keys can always be exported, so we treat public key objects as
   1088               * if they had the export flag. */
   1089              if (PSA_KEY_TYPE_IS_PUBLIC_KEY(slot->attr.type)) {
   \       0x2C   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \       0x30   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x34   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x38   0xD103             BNE.N    ??psa_get_and_lock_key_slot_with_policy_2
   1090                  usage &= ~PSA_KEY_USAGE_EXPORT;
   \       0x3A   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \       0x3E   0xEA5F 0x0848      LSLS     R8,R8,#+1
   1091              }
   1092          
   1093              if ((slot->attr.policy.usage & usage) != usage) {
   \                     ??psa_get_and_lock_key_slot_with_policy_2: (+1)
   \       0x42   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \       0x46   0xEA18 0x0000      ANDS     R0,R8,R0
   \       0x4A   0x4540             CMP      R0,R8
   \       0x4C   0xD003             BEQ.N    ??psa_get_and_lock_key_slot_with_policy_3
   1094                  status = PSA_ERROR_NOT_PERMITTED;
   \       0x4E   0xF07F 0x0084      MVNS     R0,#+132
   \       0x52   0x0004             MOVS     R4,R0
   1095                  goto error;
   \       0x54   0xE00D             B.N      ??psa_get_and_lock_key_slot_with_policy_4
   1096              }
   1097          
   1098              /* Enforce that the usage policy permits the requested algorithm. */
   1099              if (alg != 0) {
   \                     ??psa_get_and_lock_key_slot_with_policy_3: (+1)
   \       0x56   0x2D00             CMP      R5,#+0
   \       0x58   0xD009             BEQ.N    ??psa_get_and_lock_key_slot_with_policy_5
   1100                  status = psa_key_policy_permits(&slot->attr.policy,
   1101                                                  slot->attr.type,
   1102                                                  alg);
   \       0x5A   0x002A             MOVS     R2,R5
   \       0x5C   0xF8BA 0x1000      LDRH     R1,[R10, #+0]
   \       0x60   0xF11A 0x000C      ADDS     R0,R10,#+12
   \       0x64   0x.... 0x....      BL       psa_key_policy_permits
   \       0x68   0x0004             MOVS     R4,R0
   1103                  if (status != PSA_SUCCESS) {
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD101             BNE.N    ??psa_get_and_lock_key_slot_with_policy_4
   1104                      goto error;
   1105                  }
   1106              }
   1107          
   1108              return PSA_SUCCESS;
   \                     ??psa_get_and_lock_key_slot_with_policy_5: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xE005             B.N      ??psa_get_and_lock_key_slot_with_policy_1
   1109          
   1110          error:
   1111              *p_slot = NULL;
   \                     ??psa_get_and_lock_key_slot_with_policy_4: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x6038             STR      R0,[R7, #+0]
   1112              psa_unlock_key_slot(slot);
   \       0x76   0x4650             MOV      R0,R10
   \       0x78   0x.... 0x....      BL       psa_unlock_key_slot
   1113          
   1114              return status;
   \       0x7C   0x0020             MOVS     R0,R4
   \                     ??psa_get_and_lock_key_slot_with_policy_1: (+1)
   \       0x7E   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1115          }
   1116          
   1117          /** Get a key slot containing a transparent key and lock it.
   1118           *
   1119           * A transparent key is a key for which the key material is directly
   1120           * available, as opposed to a key in a secure element and/or to be used
   1121           * by a secure element.
   1122           *
   1123           * This is a temporary function that may be used instead of
   1124           * psa_get_and_lock_key_slot_with_policy() when there is no opaque key support
   1125           * for a cryptographic operation.
   1126           *
   1127           * On success, the returned key slot is locked. It is the responsibility of the
   1128           * caller to unlock the key slot when it does not access it anymore.
   1129           */

   \                                 In section .text, align 2, keep-with-next
   1130          static psa_status_t psa_get_and_lock_transparent_key_slot_with_policy(
   1131              mbedtls_svc_key_id_t key,
   1132              psa_key_slot_t **p_slot,
   1133              psa_key_usage_t usage,
   1134              psa_algorithm_t alg)
   1135          {
   \                     psa_get_and_lock_transparent_key_slot_with_policy: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   1136              psa_status_t status = psa_get_and_lock_key_slot_with_policy(key, p_slot,
   1137                                                                          usage, alg);
   \        0xC   0x4643             MOV      R3,R8
   \        0xE   0x003A             MOVS     R2,R7
   \       0x10   0x0031             MOVS     R1,R6
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x18   0x0004             MOVS     R4,R0
   1138              if (status != PSA_SUCCESS) {
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD001             BEQ.N    ??psa_get_and_lock_transparent_key_slot_with_po_0
   1139                  return status;
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xE00E             B.N      ??psa_get_and_lock_transparent_key_slot_with_po_1
   1140              }
   1141          
   1142              if (psa_key_lifetime_is_external((*p_slot)->attr.lifetime)) {
   \                     ??psa_get_and_lock_transparent_key_slot_with_po_0: (+1)
   \       0x22   0x6830             LDR      R0,[R6, #+0]
   \       0x24   0x6840             LDR      R0,[R0, #+4]
   \       0x26   0x.... 0x....      BL       psa_key_lifetime_is_external
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD007             BEQ.N    ??psa_get_and_lock_transparent_key_slot_with_po_2
   1143                  psa_unlock_key_slot(*p_slot);
   \       0x2E   0x6830             LDR      R0,[R6, #+0]
   \       0x30   0x.... 0x....      BL       psa_unlock_key_slot
   1144                  *p_slot = NULL;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x6030             STR      R0,[R6, #+0]
   1145                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x38   0xF07F 0x0085      MVNS     R0,#+133
   \       0x3C   0xE000             B.N      ??psa_get_and_lock_transparent_key_slot_with_po_1
   1146              }
   1147          
   1148              return PSA_SUCCESS;
   \                     ??psa_get_and_lock_transparent_key_slot_with_po_2: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??psa_get_and_lock_transparent_key_slot_with_po_1: (+1)
   \       0x40   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1149          }
   1150          

   \                                 In section .text, align 2, keep-with-next
   1151          psa_status_t psa_remove_key_data_from_memory(psa_key_slot_t *slot)
   1152          {
   \                     psa_remove_key_data_from_memory: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1153              if (slot->key.data != NULL) {
   \        0x4   0x6A60             LDR      R0,[R4, #+36]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD003             BEQ.N    ??psa_remove_key_data_from_memory_0
   1154                  mbedtls_zeroize_and_free(slot->key.data, slot->key.bytes);
   \        0xA   0x6AA1             LDR      R1,[R4, #+40]
   \        0xC   0x6A60             LDR      R0,[R4, #+36]
   \        0xE   0x.... 0x....      BL       mbedtls_zeroize_and_free
   1155              }
   1156          
   1157              slot->key.data = NULL;
   \                     ??psa_remove_key_data_from_memory_0: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6260             STR      R0,[R4, #+36]
   1158              slot->key.bytes = 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x62A0             STR      R0,[R4, #+40]
   1159          
   1160              return PSA_SUCCESS;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD10             POP      {R4,PC}
   1161          }
   1162          
   1163          /** Completely wipe a slot in memory, including its policy.
   1164            * Persistent storage is not affected. */

   \                                 In section .text, align 2, keep-with-next
   1165          psa_status_t psa_wipe_key_slot( psa_key_slot_t *slot )
   1166          {
   \                     psa_wipe_key_slot: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1167              psa_status_t status = psa_remove_key_data_from_memory( slot );
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       psa_remove_key_data_from_memory
   \        0xC   0x0005             MOVS     R5,R0
   1168          
   1169             /*
   1170              * As the return error code may not be handled in case of multiple errors,
   1171              * do our best to report an unexpected state. Assert with
   1172              * MBEDTLS_TEST_HOOK_TEST_ASSERT that the state is as expected:
   1173              * if the MBEDTLS_TEST_HOOKS configuration option is enabled and the
   1174              * function is called as part of the execution of a test suite, the
   1175              * execution of the test suite is stopped in error if the assertion fails.
   1176              */
   1177          
   1178              if( ( slot->state != PSA_STATE_WIPING && slot->state != PSA_STATE_DESTROYING ) ||
   1179                  slot->reader_count != 0 )
   \        0xE   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x12   0x2804             CMP      R0,#+4
   \       0x14   0xD003             BEQ.N    ??psa_wipe_key_slot_0
   \       0x16   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x1A   0x2805             CMP      R0,#+5
   \       0x1C   0xD102             BNE.N    ??psa_wipe_key_slot_1
   \                     ??psa_wipe_key_slot_0: (+1)
   \       0x1E   0x69E0             LDR      R0,[R4, #+28]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD002             BEQ.N    ??psa_wipe_key_slot_2
   1180              {
   1181                  MBEDTLS_TEST_HOOK_TEST_ASSERT( slot->state == PSA_STATE_WIPING ||
   1182                                                 slot->state == PSA_STATE_DESTROYING );
   1183                  MBEDTLS_TEST_HOOK_TEST_ASSERT( slot->reader_count == 0 );
   1184                  status = PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??psa_wipe_key_slot_1: (+1)
   \       0x24   0xF07F 0x0096      MVNS     R0,#+150
   \       0x28   0x0005             MOVS     R5,R0
   1185              }
   1186          
   1187              /* Multipart operations may still be using the key. This is safe
   1188               * because all multipart operation objects are independent from
   1189               * the key slot: if they need to access the key after the setup
   1190               * phase, they have a copy of the key. Note that this means that
   1191               * key material can linger until all operations are completed. */
   1192              /* At this point, key material and other type-specific content has
   1193               * been wiped. Clear remaining metadata. We can call memset and not
   1194               * zeroize because the metadata is not particularly sensitive. */
   1195              memset(slot, 0, sizeof(*slot));
   \                     ??psa_wipe_key_slot_2: (+1)
   \       0x2A   0xF05F 0x082C      MOVS     R8,#+44
   \       0x2E   0x2600             MOVS     R6,#+0
   \       0x30   0x0027             MOVS     R7,R4
   \       0x32   0x0032             MOVS     R2,R6
   \       0x34   0x4641             MOV      R1,R8
   \       0x36   0x0038             MOVS     R0,R7
   \       0x38   0x.... 0x....      BL       __aeabi_memset
   1196              return status;
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1197          }
   1198          

   \                                 In section .text, align 2, keep-with-next
   1199          psa_status_t psa_finish_key_destruction( psa_key_slot_t *slot )
   1200          {
   \                     psa_finish_key_destruction: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1201              psa_status_t status; /* status of the last operation */
   1202              psa_status_t overall_status = PSA_SUCCESS;
   \        0x4   0x2400             MOVS     R4,#+0
   1203          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   1204              psa_se_drv_table_entry_t *driver;
   1205          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   1206          
   1207              if( slot->state != PSA_STATE_DESTROYING )
   \        0x6   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \        0xA   0x2805             CMP      R0,#+5
   \        0xC   0xD002             BEQ.N    ??psa_finish_key_destruction_0
   1208                  return( PSA_ERROR_BAD_STATE );
   \        0xE   0xF07F 0x0088      MVNS     R0,#+136
   \       0x12   0xE021             B.N      ??psa_finish_key_destruction_1
   1209          
   1210              if (PSA_KEY_LIFETIME_IS_READ_ONLY(slot->attr.lifetime)) {
   \                     ??psa_finish_key_destruction_0: (+1)
   \       0x14   0x6868             LDR      R0,[R5, #+4]
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x28FF             CMP      R0,#+255
   \       0x1A   0xD10A             BNE.N    ??psa_finish_key_destruction_2
   1211                  /* Refuse the destruction of a read-only key (which may or may not work
   1212                   * if we attempt it, depending on whether the key is merely read-only
   1213                   * by policy or actually physically read-only).
   1214                   * Just do the best we can, which is to wipe the copy in memory
   1215                   * (done in this function's cleanup code). */
   1216                  overall_status = PSA_ERROR_NOT_PERMITTED;
   \       0x1C   0xF07F 0x0784      MVNS     R7,#+132
   1217          
   1218                  status = psa_wipe_key_slot( slot );
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0x.... 0x....      BL       psa_wipe_key_slot
   \       0x26   0x0001             MOVS     R1,R0
   1219                  /* Prioritize CORRUPTION_DETECTED from wiping over a storage error */
   1220                  if( status != PSA_SUCCESS )
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD000             BEQ.N    ??psa_finish_key_destruction_3
   1221                      overall_status = status;
   \       0x2C   0x000F             MOVS     R7,R1
   1222          
   1223                  return( overall_status );
   \                     ??psa_finish_key_destruction_3: (+1)
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0xE012             B.N      ??psa_finish_key_destruction_1
   1224              }
   1225          
   1226          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   1227              driver = psa_get_se_driver_entry(slot->attr.lifetime);
   1228              if (driver != NULL) {
   1229                  /* For a key in a secure element, we need to do three things:
   1230                   * remove the key file in internal storage, destroy the
   1231                   * key inside the secure element, and update the driver's
   1232                   * persistent data. Start a transaction that will encompass these
   1233                   * three actions. */
   1234                  psa_crypto_prepare_transaction(PSA_CRYPTO_TRANSACTION_DESTROY_KEY);
   1235                  psa_crypto_transaction.key.lifetime = slot->attr.lifetime;
   1236                  psa_crypto_transaction.key.slot = psa_key_slot_get_slot_number(slot);
   1237                  psa_crypto_transaction.key.id = slot->attr.id;
   1238                  status = psa_crypto_save_transaction();
   1239                  if (status != PSA_SUCCESS) {
   1240                      (void) psa_crypto_stop_transaction();
   1241                      /* We should still try to destroy the key in the secure
   1242                       * element and the key metadata in storage. This is especially
   1243                       * important if the error is that the storage is full.
   1244                       * But how to do it exactly without risking an inconsistent
   1245                       * state after a reset?
   1246                       * https://github.com/ARMmbed/mbed-crypto/issues/215
   1247                       */
   1248                      overall_status = status;
   1249                      goto exit;
   1250                  }
   1251          
   1252                  status = psa_destroy_se_key(driver,
   1253                                              psa_key_slot_get_slot_number(slot));
   1254                  if (overall_status == PSA_SUCCESS) {
   1255                      overall_status = status;
   1256                  }
   1257              }
   1258          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   1259          
   1260          #if defined(MBEDTLS_PSA_CRYPTO_STORAGE_C)
   1261              if (!PSA_KEY_LIFETIME_IS_VOLATILE(slot->attr.lifetime)) {
   \                     ??psa_finish_key_destruction_2: (+1)
   \       0x32   0x6868             LDR      R0,[R5, #+4]
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD006             BEQ.N    ??psa_finish_key_destruction_4
   1262                  status = psa_destroy_persistent_key(slot->attr.id);
   \       0x3A   0x68A8             LDR      R0,[R5, #+8]
   \       0x3C   0x.... 0x....      BL       psa_destroy_persistent_key
   \       0x40   0x0006             MOVS     R6,R0
   1263                  if (overall_status == PSA_SUCCESS) {
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD100             BNE.N    ??psa_finish_key_destruction_4
   1264                      overall_status = status;
   \       0x46   0x0034             MOVS     R4,R6
   1265                  }
   1266          
   1267                  /* TODO: other slots may have a copy of the same key. We should
   1268                   * invalidate them.
   1269                   * https://github.com/ARMmbed/mbed-crypto/issues/214
   1270                   */
   1271              }
   1272          #endif /* defined(MBEDTLS_PSA_CRYPTO_STORAGE_C) */
   1273          
   1274          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   1275              if (driver != NULL) {
   1276                  status = psa_save_se_persistent_data(driver);
   1277                  if (overall_status == PSA_SUCCESS) {
   1278                      overall_status = status;
   1279                  }
   1280                  status = psa_crypto_stop_transaction();
   1281                  if (overall_status == PSA_SUCCESS) {
   1282                      overall_status = status;
   1283                  }
   1284              }
   1285          exit:
   1286          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   1287          
   1288              status = psa_wipe_key_slot( slot );
   \                     ??psa_finish_key_destruction_4: (+1)
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0x.... 0x....      BL       psa_wipe_key_slot
   \       0x4E   0x0001             MOVS     R1,R0
   1289              /* Prioritize CORRUPTION_DETECTED from wiping over a storage error */
   1290              if (status != PSA_SUCCESS) {
   \       0x50   0x2900             CMP      R1,#+0
   \       0x52   0xD000             BEQ.N    ??psa_finish_key_destruction_5
   1291                  overall_status = status;
   \       0x54   0x000C             MOVS     R4,R1
   1292              }
   1293              return overall_status;
   \                     ??psa_finish_key_destruction_5: (+1)
   \       0x56   0x0020             MOVS     R0,R4
   \                     ??psa_finish_key_destruction_1: (+1)
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}
   1294          }
   1295          

   \                                 In section .text, align 2, keep-with-next
   1296          psa_status_t psa_destroy_key( mbedtls_svc_key_id_t key )
   1297          {
   \                     psa_destroy_key: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1298              psa_key_slot_t *slot;
   1299              psa_status_t status; /* status of the last operation */
   1300          
   1301              if( mbedtls_svc_key_id_is_null( key ) )
   \        0x4   0x0028             MOVS     R0,R5
   \        0x6   0x.... 0x....      BL       mbedtls_svc_key_id_is_null
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??psa_destroy_key_0
   1302                  return( PSA_SUCCESS );
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE02C             B.N      ??psa_destroy_key_1
   1303          
   1304              /*
   1305               * Get the description of the key in a key slot. In case of a persistent
   1306               * key, this will load the key description from persistent memory if not
   1307               * done yet. We cannot avoid this loading as without it we don't know if
   1308               * the key is operated by an SE or not and this information is needed by
   1309               * the current implementation.
   1310               */
   1311              status = psa_get_and_lock_key_slot( key, &slot, PSA_INTENT_DESTROY );
   \                     ??psa_destroy_key_0: (+1)
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x.... 0x....      BL       psa_get_and_lock_key_slot
   \       0x1C   0x0004             MOVS     R4,R0
   1312              if( status != PSA_SUCCESS )
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD001             BEQ.N    ??psa_destroy_key_2
   1313                  return( status );
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0xE022             B.N      ??psa_destroy_key_1
   1314          
   1315              if( psa_slot_has_no_readers( slot ) )
   \                     ??psa_destroy_key_2: (+1)
   \       0x26   0x9800             LDR      R0,[SP, #+0]
   \       0x28   0x.... 0x....      BL       psa_slot_has_no_readers
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD01A             BEQ.N    ??psa_destroy_key_3
   1316              {
   1317                  MBEDTLS_MUTEX_LOCK_CHECK( &mbedtls_psa_slots_mutex );
   \       0x30   0x.... 0x....      LDR.W    R7,??DataTable13
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \       0x3A   0x6809             LDR      R1,[R1, #+0]
   \       0x3C   0x4788             BLX      R1
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD002             BEQ.N    ??psa_destroy_key_4
   \       0x42   0xF07F 0x0088      MVNS     R0,#+136
   \       0x46   0xE011             B.N      ??psa_destroy_key_1
   1318                  status = psa_finish_key_destruction( slot );
   \                     ??psa_destroy_key_4: (+1)
   \       0x48   0x9800             LDR      R0,[SP, #+0]
   \       0x4A   0x.... 0x....      BL       psa_finish_key_destruction
   \       0x4E   0x0006             MOVS     R6,R0
   1319                  MBEDTLS_MUTEX_UNLOCK_CHECK( &mbedtls_psa_slots_mutex );
   \       0x50   0x0038             MOVS     R0,R7
   \       0x52   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \       0x56   0x6809             LDR      R1,[R1, #+0]
   \       0x58   0x4788             BLX      R1
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD002             BEQ.N    ??psa_destroy_key_5
   \       0x5E   0xF07F 0x0088      MVNS     R0,#+136
   \       0x62   0xE003             B.N      ??psa_destroy_key_1
   \                     ??psa_destroy_key_5: (+1)
   \       0x64   0xE001             B.N      ??psa_destroy_key_6
   1320              }
   1321              else
   1322                  status = PSA_ERROR_DELAYED;
   \                     ??psa_destroy_key_3: (+1)
   \       0x66   0xF07F 0x0699      MVNS     R6,#+153
   1323          
   1324              return( status );
   \                     ??psa_destroy_key_6: (+1)
   \       0x6A   0x0030             MOVS     R0,R6
   \                     ??psa_destroy_key_1: (+1)
   \       0x6C   0xBDF2             POP      {R1,R4-R7,PC}
   1325          }
   1326          
   1327          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT) || \
   1328              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY)
   1329          static psa_status_t psa_get_rsa_public_exponent(
   1330              const mbedtls_rsa_context *rsa,
   1331              psa_key_attributes_t *attributes)
   1332          {
   1333              mbedtls_mpi mpi;
   1334              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1335              uint8_t *buffer = NULL;
   1336              size_t buflen;
   1337              mbedtls_mpi_init(&mpi);
   1338          
   1339              ret = mbedtls_rsa_export(rsa, NULL, NULL, NULL, NULL, &mpi);
   1340              if (ret != 0) {
   1341                  goto exit;
   1342              }
   1343              if (mbedtls_mpi_cmp_int(&mpi, 65537) == 0) {
   1344                  /* It's the default value, which is reported as an empty string,
   1345                   * so there's nothing to do. */
   1346                  goto exit;
   1347              }
   1348          
   1349              buflen = mbedtls_mpi_size(&mpi);
   1350              buffer = mbedtls_calloc(1, buflen);
   1351              if (buffer == NULL) {
   1352                  ret = MBEDTLS_ERR_MPI_ALLOC_FAILED;
   1353                  goto exit;
   1354              }
   1355              ret = mbedtls_mpi_write_binary(&mpi, buffer, buflen);
   1356              if (ret != 0) {
   1357                  goto exit;
   1358              }
   1359              attributes->domain_parameters = buffer;
   1360              attributes->domain_parameters_size = buflen;
   1361          
   1362          exit:
   1363              mbedtls_mpi_free(&mpi);
   1364              if (ret != 0) {
   1365                  mbedtls_free(buffer);
   1366              }
   1367              return mbedtls_to_psa_error(ret);
   1368          }
   1369          #endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT) ||
   1370                  * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY) */
   1371          
   1372          /** Retrieve all the publicly-accessible attributes of a key.
   1373           */

   \                                 In section .text, align 2, keep-with-next
   1374          psa_status_t psa_get_key_attributes(mbedtls_svc_key_id_t key,
   1375                                              psa_key_attributes_t *attributes)
   1376          {
   \                     psa_get_key_attributes: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   1377              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x0796      MVNS     R7,#+150
   \        0xC   0x46B8             MOV      R8,R7
   1378              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   1379              psa_key_slot_t *slot;
   1380          
   1381              psa_reset_key_attributes(attributes);
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       psa_reset_key_attributes
   1382          
   1383              status = psa_get_and_lock_key_slot_with_policy(key, &slot, 0, 0);
   \       0x14   0x2300             MOVS     R3,#+0
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x20   0x0004             MOVS     R4,R0
   1384              if (status != PSA_SUCCESS) {
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD001             BEQ.N    ??psa_get_key_attributes_0
   1385                  return status;
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0xE015             B.N      ??psa_get_key_attributes_1
   1386              }
   1387          
   1388              attributes->core = slot->attr;
   \                     ??psa_get_key_attributes_0: (+1)
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0x9900             LDR      R1,[SP, #+0]
   \       0x2E   0x221C             MOVS     R2,#+28
   \       0x30   0x.... 0x....      BL       __aeabi_memcpy4
   1389              attributes->core.flags &= (MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY |
   1390                                         MBEDTLS_PSA_KA_MASK_DUAL_USE);
   \       0x34   0x7E30             LDRB     R0,[R6, #+24]
   \       0x36   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x3A   0x8330             STRH     R0,[R6, #+24]
   1391          
   1392          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   1393              if (psa_get_se_driver_entry(slot->attr.lifetime) != NULL) {
   1394                  psa_set_key_slot_number(attributes,
   1395                                          psa_key_slot_get_slot_number(slot));
   1396              }
   1397          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   1398          
   1399              switch (slot->attr.type) {
   1400          #if (defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_IMPORT) && \
   1401              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT)) || \
   1402              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY)
   1403                  case PSA_KEY_TYPE_RSA_KEY_PAIR:
   1404                  case PSA_KEY_TYPE_RSA_PUBLIC_KEY:
   1405                      /* TODO: reporting the public exponent for opaque keys
   1406                       * is not yet implemented.
   1407                       * https://github.com/ARMmbed/mbed-crypto/issues/216
   1408                       */
   1409                      if (!psa_key_lifetime_is_external(slot->attr.lifetime)) {
   1410                          mbedtls_rsa_context *rsa = NULL;
   1411          
   1412                          status = mbedtls_psa_rsa_load_representation(
   1413                              slot->attr.type,
   1414                              slot->key.data,
   1415                              slot->key.bytes,
   1416                              &rsa);
   1417                          if (status != PSA_SUCCESS) {
   1418                              break;
   1419                          }
   1420          
   1421                          status = psa_get_rsa_public_exponent(rsa,
   1422                                                               attributes);
   1423                          mbedtls_rsa_free(rsa);
   1424                          mbedtls_free(rsa);
   1425                      }
   1426                      break;
   1427          #endif /* (defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_IMPORT) && \
   1428                  * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT)) ||
   1429                  * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY) */
   1430                  default:
   1431                      /* Nothing else to do. */
   1432                      break;
   1433              }
   1434          
   1435              if (status != PSA_SUCCESS) {
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD002             BEQ.N    ??psa_get_key_attributes_2
   1436                  psa_reset_key_attributes(attributes);
   \       0x40   0x0030             MOVS     R0,R6
   \       0x42   0x.... 0x....      BL       psa_reset_key_attributes
   1437              }
   1438          
   1439              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_get_key_attributes_2: (+1)
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0x.... 0x....      BL       psa_unlock_key_slot
   1440          
   1441              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0x4C   0x2C00             CMP      R4,#+0
   \       0x4E   0xD101             BNE.N    ??psa_get_key_attributes_3
   \       0x50   0x0004             MOVS     R4,R0
   \       0x52   0xE7FF             B.N      ??psa_get_key_attributes_4
   \                     ??psa_get_key_attributes_3: (+1)
   \                     ??psa_get_key_attributes_4: (+1)
   \       0x54   0x0020             MOVS     R0,R4
   \                     ??psa_get_key_attributes_1: (+1)
   \       0x56   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1442          }
   1443          
   1444          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   1445          psa_status_t psa_get_key_slot_number(
   1446              const psa_key_attributes_t *attributes,
   1447              psa_key_slot_number_t *slot_number)
   1448          {
   1449              if (attributes->core.flags & MBEDTLS_PSA_KA_FLAG_HAS_SLOT_NUMBER) {
   1450                  *slot_number = attributes->slot_number;
   1451                  return PSA_SUCCESS;
   1452              } else {
   1453                  return PSA_ERROR_INVALID_ARGUMENT;
   1454              }
   1455          }
   1456          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   1457          

   \                                 In section .text, align 2, keep-with-next
   1458          static psa_status_t psa_export_key_buffer_internal(const uint8_t *key_buffer,
   1459                                                             size_t key_buffer_size,
   1460                                                             uint8_t *data,
   1461                                                             size_t data_size,
   1462                                                             size_t *data_length)
   1463          {
   \                     psa_export_key_buffer_internal: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   1464              if (key_buffer_size > data_size) {
   \       0x10   0x42AF             CMP      R7,R5
   \       0x12   0xD202             BCS.N    ??psa_export_key_buffer_internal_0
   1465                  return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x14   0xF07F 0x0089      MVNS     R0,#+137
   \       0x18   0xE015             B.N      ??psa_export_key_buffer_internal_1
   1466              }
   1467              memcpy(data, key_buffer, key_buffer_size);
   \                     ??psa_export_key_buffer_internal_0: (+1)
   \       0x1A   0x9501             STR      R5,[SP, #+4]
   \       0x1C   0x9400             STR      R4,[SP, #+0]
   \       0x1E   0x46B1             MOV      R9,R6
   \       0x20   0x9A01             LDR      R2,[SP, #+4]
   \       0x22   0x9900             LDR      R1,[SP, #+0]
   \       0x24   0x4648             MOV      R0,R9
   \       0x26   0x.... 0x....      BL       __aeabi_memcpy
   1468              memset(data + key_buffer_size, 0,
   1469                     data_size - key_buffer_size);
   \       0x2A   0xEBB7 0x0B05      SUBS     R11,R7,R5
   \       0x2E   0xF05F 0x0900      MOVS     R9,#+0
   \       0x32   0xEB06 0x0A05      ADD      R10,R6,R5
   \       0x36   0x464A             MOV      R2,R9
   \       0x38   0x4659             MOV      R1,R11
   \       0x3A   0x4650             MOV      R0,R10
   \       0x3C   0x.... 0x....      BL       __aeabi_memset
   1470              *data_length = key_buffer_size;
   \       0x40   0xF8C8 0x5000      STR      R5,[R8, #+0]
   1471              return PSA_SUCCESS;
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??psa_export_key_buffer_internal_1: (+1)
   \       0x46   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1472          }
   1473          

   \                                 In section .text, align 2, keep-with-next
   1474          psa_status_t psa_export_key_internal(
   1475              const psa_key_attributes_t *attributes,
   1476              const uint8_t *key_buffer, size_t key_buffer_size,
   1477              uint8_t *data, size_t data_size, size_t *data_length)
   1478          {
   \                     psa_export_key_internal: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   1479              psa_key_type_t type = attributes->core.type;
   \       0x10   0xF8B4 0x9000      LDRH     R9,[R4, #+0]
   1480          
   1481              if (key_type_is_raw_bytes(type) ||
   1482                  PSA_KEY_TYPE_IS_RSA(type)   ||
   1483                  PSA_KEY_TYPE_IS_ECC(type)   ||
   1484                  PSA_KEY_TYPE_IS_DH(type)) {
   \       0x14   0x4648             MOV      R0,R9
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x.... 0x....      BL       key_type_is_raw_bytes
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD115             BNE.N    ??psa_export_key_internal_0
   \       0x20   0x4649             MOV      R1,R9
   \       0x22   0xB289             UXTH     R1,R1
   \       0x24   0xF431 0x5140      BICS     R1,R1,#0x3000
   \       0x28   0xF244 0x0001      MOVW     R0,#+16385
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD00D             BEQ.N    ??psa_export_key_internal_0
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x34   0x4649             MOV      R1,R9
   \       0x36   0xB289             UXTH     R1,R1
   \       0x38   0x4001             ANDS     R1,R0,R1
   \       0x3A   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x3E   0xD005             BEQ.N    ??psa_export_key_internal_0
   \       0x40   0x4649             MOV      R1,R9
   \       0x42   0xB289             UXTH     R1,R1
   \       0x44   0x4008             ANDS     R0,R0,R1
   \       0x46   0xF5B0 0x4F84      CMP      R0,#+16896
   \       0x4A   0xD108             BNE.N    ??psa_export_key_internal_1
   1485                  return psa_export_key_buffer_internal(
   1486                      key_buffer, key_buffer_size,
   1487                      data, data_size, data_length);
   \                     ??psa_export_key_internal_0: (+1)
   \       0x4C   0x9809             LDR      R0,[SP, #+36]
   \       0x4E   0x9000             STR      R0,[SP, #+0]
   \       0x50   0x4643             MOV      R3,R8
   \       0x52   0x003A             MOVS     R2,R7
   \       0x54   0x0031             MOVS     R1,R6
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0x.... 0x....      BL       psa_export_key_buffer_internal
   \       0x5C   0xE001             B.N      ??psa_export_key_internal_2
   1488              } else {
   1489                  /* This shouldn't happen in the reference implementation, but
   1490                     it is valid for a special-purpose implementation to omit
   1491                     support for exporting certain key types. */
   1492                  return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_export_key_internal_1: (+1)
   \       0x5E   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_export_key_internal_2: (+1)
   \       0x62   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1493              }
   1494          }
   1495          

   \                                 In section .text, align 2, keep-with-next
   1496          psa_status_t psa_export_key(mbedtls_svc_key_id_t key,
   1497                                      uint8_t *data,
   1498                                      size_t data_size,
   1499                                      size_t *data_length)
   1500          {
   \                     psa_export_key: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0x001F             MOVS     R7,R3
   1501              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0x46C2             MOV      R10,R8
   1502              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   1503              psa_key_slot_t *slot;
   1504          
   1505              /* Reject a zero-length output buffer now, since this can never be a
   1506               * valid key representation. This way we know that data must be a valid
   1507               * pointer and we can do things like memset(data, ..., data_size). */
   1508              if (data_size == 0) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD102             BNE.N    ??psa_export_key_0
   1509                  return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x18   0xF07F 0x0089      MVNS     R0,#+137
   \       0x1C   0xE029             B.N      ??psa_export_key_1
   1510              }
   1511          
   1512              /* Set the key to empty now, so that even when there are errors, we always
   1513               * set data_length to a value between 0 and data_size. On error, setting
   1514               * the key to empty is a good choice because an empty key representation is
   1515               * unlikely to be accepted anywhere. */
   1516              *data_length = 0;
   \                     ??psa_export_key_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6038             STR      R0,[R7, #+0]
   1517          
   1518              /* Export requires the EXPORT flag. There is an exception for public keys,
   1519               * which don't require any flag, but
   1520               * psa_get_and_lock_key_slot_with_policy() takes care of this.
   1521               */
   1522              status = psa_get_and_lock_key_slot_with_policy(key, &slot,
   1523                                                             PSA_KEY_USAGE_EXPORT, 0);
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x2201             MOVS     R2,#+1
   \       0x26   0xA902             ADD      R1,SP,#+8
   \       0x28   0x4648             MOV      R0,R9
   \       0x2A   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x2E   0x0005             MOVS     R5,R0
   1524              if (status != PSA_SUCCESS) {
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xD001             BEQ.N    ??psa_export_key_2
   1525                  return status;
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0xE01C             B.N      ??psa_export_key_1
   1526              }
   1527          
   1528              psa_key_attributes_t attributes = {
   1529                  .core = slot->attr
   1530              };
   \                     ??psa_export_key_2: (+1)
   \       0x38   0xA803             ADD      R0,SP,#+12
   \       0x3A   0x2124             MOVS     R1,#+36
   \       0x3C   0x.... 0x....      BL       __aeabi_memclr4
   \       0x40   0xA803             ADD      R0,SP,#+12
   \       0x42   0x9902             LDR      R1,[SP, #+8]
   \       0x44   0x221C             MOVS     R2,#+28
   \       0x46   0x.... 0x....      BL       __aeabi_memcpy4
   1531              status = psa_driver_wrapper_export_key(&attributes,
   1532                                                     slot->key.data, slot->key.bytes,
   1533                                                     data, data_size, data_length);
   \       0x4A   0x9701             STR      R7,[SP, #+4]
   \       0x4C   0x9400             STR      R4,[SP, #+0]
   \       0x4E   0x0033             MOVS     R3,R6
   \       0x50   0x9802             LDR      R0,[SP, #+8]
   \       0x52   0x6A82             LDR      R2,[R0, #+40]
   \       0x54   0x9802             LDR      R0,[SP, #+8]
   \       0x56   0x6A41             LDR      R1,[R0, #+36]
   \       0x58   0xA803             ADD      R0,SP,#+12
   \       0x5A   0x.... 0x....      BL       psa_driver_wrapper_export_key
   \       0x5E   0x4682             MOV      R10,R0
   1534          
   1535              unlock_status = psa_unlock_key_slot(slot);
   \       0x60   0x9802             LDR      R0,[SP, #+8]
   \       0x62   0x.... 0x....      BL       psa_unlock_key_slot
   1536          
   1537              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0x66   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x6A   0xD101             BNE.N    ??psa_export_key_3
   \       0x6C   0x4682             MOV      R10,R0
   \       0x6E   0xE7FF             B.N      ??psa_export_key_4
   \                     ??psa_export_key_3: (+1)
   \                     ??psa_export_key_4: (+1)
   \       0x70   0x4650             MOV      R0,R10
   \                     ??psa_export_key_1: (+1)
   \       0x72   0xB00C             ADD      SP,SP,#+48
   \       0x74   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1538          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   1539          

   \                                 In section .text, align 2, keep-with-next
   1540          psa_status_t psa_export_public_key_internal(
   1541              const psa_key_attributes_t *attributes,
   1542              const uint8_t *key_buffer,
   1543              size_t key_buffer_size,
   1544              uint8_t *data,
   1545              size_t data_size,
   1546              size_t *data_length)
   1547          {
   \                     psa_export_public_key_internal: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \       0x10   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   1548              psa_key_type_t type = attributes->core.type;
   \       0x14   0xF8B4 0xA000      LDRH     R10,[R4, #+0]
   1549          
   1550              if (PSA_KEY_TYPE_IS_PUBLIC_KEY(type) &&
   1551                  (PSA_KEY_TYPE_IS_RSA(type) || PSA_KEY_TYPE_IS_ECC(type) ||
   1552                   PSA_KEY_TYPE_IS_DH(type))) {
   \       0x18   0x4650             MOV      R0,R10
   \       0x1A   0xB280             UXTH     R0,R0
   \       0x1C   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x20   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x24   0xD11E             BNE.N    ??psa_export_public_key_internal_0
   \       0x26   0x4651             MOV      R1,R10
   \       0x28   0xB289             UXTH     R1,R1
   \       0x2A   0xF431 0x5140      BICS     R1,R1,#0x3000
   \       0x2E   0xF244 0x0001      MOVW     R0,#+16385
   \       0x32   0x4281             CMP      R1,R0
   \       0x34   0xD00D             BEQ.N    ??psa_export_public_key_internal_1
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x3A   0x4651             MOV      R1,R10
   \       0x3C   0xB289             UXTH     R1,R1
   \       0x3E   0x4001             ANDS     R1,R0,R1
   \       0x40   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x44   0xD005             BEQ.N    ??psa_export_public_key_internal_1
   \       0x46   0x4651             MOV      R1,R10
   \       0x48   0xB289             UXTH     R1,R1
   \       0x4A   0x4008             ANDS     R0,R0,R1
   \       0x4C   0xF5B0 0x4F84      CMP      R0,#+16896
   \       0x50   0xD108             BNE.N    ??psa_export_public_key_internal_0
   1553                  /* Exporting public -> public */
   1554                  return psa_export_key_buffer_internal(
   1555                      key_buffer, key_buffer_size,
   1556                      data, data_size, data_length);
   \                     ??psa_export_public_key_internal_1: (+1)
   \       0x52   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x56   0x4643             MOV      R3,R8
   \       0x58   0x003A             MOVS     R2,R7
   \       0x5A   0x0031             MOVS     R1,R6
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0x.... 0x....      BL       psa_export_key_buffer_internal
   \       0x62   0xE028             B.N      ??psa_export_public_key_internal_2
   1557              } else if (PSA_KEY_TYPE_IS_RSA(type)) {
   \                     ??psa_export_public_key_internal_0: (+1)
   \       0x64   0x4651             MOV      R1,R10
   \       0x66   0xB289             UXTH     R1,R1
   \       0x68   0xF431 0x5140      BICS     R1,R1,#0x3000
   \       0x6C   0xF244 0x0001      MOVW     R0,#+16385
   \       0x70   0x4281             CMP      R1,R0
   \       0x72   0xD102             BNE.N    ??psa_export_public_key_internal_3
   1558          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT) || \
   1559                  defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY)
   1560                  return mbedtls_psa_rsa_export_public_key(attributes,
   1561                                                           key_buffer,
   1562                                                           key_buffer_size,
   1563                                                           data,
   1564                                                           data_size,
   1565                                                           data_length);
   1566          #else
   1567                  /* We don't know how to convert a private RSA key to public. */
   1568                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x74   0xF07F 0x0085      MVNS     R0,#+133
   \       0x78   0xE01D             B.N      ??psa_export_public_key_internal_2
   1569          #endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT) ||
   1570                  * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY) */
   1571              } else if (PSA_KEY_TYPE_IS_ECC(type)) {
   \                     ??psa_export_public_key_internal_3: (+1)
   \       0x7A   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x7E   0x4651             MOV      R1,R10
   \       0x80   0xB289             UXTH     R1,R1
   \       0x82   0x4001             ANDS     R1,R0,R1
   \       0x84   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x88   0xD10A             BNE.N    ??psa_export_public_key_internal_4
   1572          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_EXPORT) || \
   1573                  defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY)
   1574                  return mbedtls_psa_ecp_export_public_key(attributes,
   1575                                                           key_buffer,
   1576                                                           key_buffer_size,
   1577                                                           data,
   1578                                                           data_size,
   1579                                                           data_length);
   \       0x8A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x8E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x92   0x003B             MOVS     R3,R7
   \       0x94   0x0032             MOVS     R2,R6
   \       0x96   0x0029             MOVS     R1,R5
   \       0x98   0x0020             MOVS     R0,R4
   \       0x9A   0x.... 0x....      BL       mbedtls_psa_ecp_export_public_key
   \       0x9E   0xE00A             B.N      ??psa_export_public_key_internal_2
   1580          #else
   1581                  /* We don't know how to convert a private ECC key to public */
   1582                  return PSA_ERROR_NOT_SUPPORTED;
   1583          #endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_EXPORT) ||
   1584                  * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY) */
   1585              } else if (PSA_KEY_TYPE_IS_DH(type)) {
   \                     ??psa_export_public_key_internal_4: (+1)
   \       0xA0   0x4651             MOV      R1,R10
   \       0xA2   0xB289             UXTH     R1,R1
   \       0xA4   0x4008             ANDS     R0,R0,R1
   \       0xA6   0xF5B0 0x4F84      CMP      R0,#+16896
   \       0xAA   0xD102             BNE.N    ??psa_export_public_key_internal_5
   1586          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_EXPORT) || \
   1587                  defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_PUBLIC_KEY)
   1588                  return mbedtls_psa_ffdh_export_public_key(attributes,
   1589                                                            key_buffer,
   1590                                                            key_buffer_size,
   1591                                                            data, data_size,
   1592                                                            data_length);
   1593          #else
   1594                  return PSA_ERROR_NOT_SUPPORTED;
   \       0xAC   0xF07F 0x0085      MVNS     R0,#+133
   \       0xB0   0xE001             B.N      ??psa_export_public_key_internal_2
   1595          #endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_EXPORT) ||
   1596                  * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_PUBLIC_KEY) */
   1597              } else {
   1598                  (void) key_buffer;
   1599                  (void) key_buffer_size;
   1600                  (void) data;
   1601                  (void) data_size;
   1602                  (void) data_length;
   1603                  return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_export_public_key_internal_5: (+1)
   \       0xB2   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_export_public_key_internal_2: (+1)
   \       0xB6   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   1604              }
   1605          }
   1606          

   \                                 In section .text, align 2, keep-with-next
   1607          psa_status_t psa_export_public_key(mbedtls_svc_key_id_t key,
   1608                                             uint8_t *data,
   1609                                             size_t data_size,
   1610                                             size_t *data_length)
   1611          {
   \                     psa_export_public_key: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0x001F             MOVS     R7,R3
   1612              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0x46C2             MOV      R10,R8
   1613              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   1614              psa_key_slot_t *slot;
   1615              psa_key_attributes_t attributes;
   1616          
   1617              /* Reject a zero-length output buffer now, since this can never be a
   1618               * valid key representation. This way we know that data must be a valid
   1619               * pointer and we can do things like memset(data, ..., data_size). */
   1620              if (data_size == 0) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD102             BNE.N    ??psa_export_public_key_0
   1621                  return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x18   0xF07F 0x0089      MVNS     R0,#+137
   \       0x1C   0xE035             B.N      ??psa_export_public_key_1
   1622              }
   1623          
   1624              /* Set the key to empty now, so that even when there are errors, we always
   1625               * set data_length to a value between 0 and data_size. On error, setting
   1626               * the key to empty is a good choice because an empty key representation is
   1627               * unlikely to be accepted anywhere. */
   1628              *data_length = 0;
   \                     ??psa_export_public_key_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6038             STR      R0,[R7, #+0]
   1629          
   1630              /* Exporting a public key doesn't require a usage flag. */
   1631              status = psa_get_and_lock_key_slot_with_policy(key, &slot, 0, 0);
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0xA902             ADD      R1,SP,#+8
   \       0x28   0x4648             MOV      R0,R9
   \       0x2A   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x2E   0x0005             MOVS     R5,R0
   1632              if (status != PSA_SUCCESS) {
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xD001             BEQ.N    ??psa_export_public_key_2
   1633                  return status;
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0xE028             B.N      ??psa_export_public_key_1
   1634              }
   1635          
   1636              if (!PSA_KEY_TYPE_IS_ASYMMETRIC(slot->attr.type)) {
   \                     ??psa_export_public_key_2: (+1)
   \       0x38   0x9802             LDR      R0,[SP, #+8]
   \       0x3A   0x8800             LDRH     R0,[R0, #+0]
   \       0x3C   0x0440             LSLS     R0,R0,#+17
   \       0x3E   0xD402             BMI.N    ??psa_export_public_key_3
   1637                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x40   0xF07F 0x0A86      MVNS     R10,#+134
   1638                  goto exit;
   \       0x44   0xE018             B.N      ??psa_export_public_key_4
   1639              }
   1640          
   1641              attributes = (psa_key_attributes_t) {
   1642                  .core = slot->attr
   1643              };
   \                     ??psa_export_public_key_3: (+1)
   \       0x46   0xA803             ADD      R0,SP,#+12
   \       0x48   0x2124             MOVS     R1,#+36
   \       0x4A   0x.... 0x....      BL       __aeabi_memclr4
   \       0x4E   0xA803             ADD      R0,SP,#+12
   \       0x50   0x9902             LDR      R1,[SP, #+8]
   \       0x52   0x221C             MOVS     R2,#+28
   \       0x54   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x58   0xA80C             ADD      R0,SP,#+48
   \       0x5A   0xA903             ADD      R1,SP,#+12
   \       0x5C   0x2224             MOVS     R2,#+36
   \       0x5E   0x.... 0x....      BL       __aeabi_memcpy4
   1644              status = psa_driver_wrapper_export_public_key(
   1645                  &attributes, slot->key.data, slot->key.bytes,
   1646                  data, data_size, data_length);
   \       0x62   0x9701             STR      R7,[SP, #+4]
   \       0x64   0x9400             STR      R4,[SP, #+0]
   \       0x66   0x0033             MOVS     R3,R6
   \       0x68   0x9802             LDR      R0,[SP, #+8]
   \       0x6A   0x6A82             LDR      R2,[R0, #+40]
   \       0x6C   0x9802             LDR      R0,[SP, #+8]
   \       0x6E   0x6A41             LDR      R1,[R0, #+36]
   \       0x70   0xA80C             ADD      R0,SP,#+48
   \       0x72   0x.... 0x....      BL       psa_driver_wrapper_export_public_key
   \       0x76   0x4682             MOV      R10,R0
   1647          
   1648          exit:
   1649              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_export_public_key_4: (+1)
   \       0x78   0x9802             LDR      R0,[SP, #+8]
   \       0x7A   0x.... 0x....      BL       psa_unlock_key_slot
   1650          
   1651              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0x7E   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x82   0xD101             BNE.N    ??psa_export_public_key_5
   \       0x84   0x4682             MOV      R10,R0
   \       0x86   0xE7FF             B.N      ??psa_export_public_key_6
   \                     ??psa_export_public_key_5: (+1)
   \                     ??psa_export_public_key_6: (+1)
   \       0x88   0x4650             MOV      R0,R10
   \                     ??psa_export_public_key_1: (+1)
   \       0x8A   0xB016             ADD      SP,SP,#+88
   \       0x8C   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1652          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   1653          
   1654          MBEDTLS_STATIC_ASSERT(
   1655              (MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY & MBEDTLS_PSA_KA_MASK_DUAL_USE) == 0,
   1656              "One or more key attribute flag is listed as both external-only and dual-use")
   1657          MBEDTLS_STATIC_ASSERT(
   1658              (PSA_KA_MASK_INTERNAL_ONLY & MBEDTLS_PSA_KA_MASK_DUAL_USE) == 0,
   1659              "One or more key attribute flag is listed as both internal-only and dual-use")
   1660          MBEDTLS_STATIC_ASSERT(
   1661              (PSA_KA_MASK_INTERNAL_ONLY & MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY) == 0,
   1662              "One or more key attribute flag is listed as both internal-only and external-only")
   1663          
   1664          /** Validate that a key policy is internally well-formed.
   1665           *
   1666           * This function only rejects invalid policies. It does not validate the
   1667           * consistency of the policy with respect to other attributes of the key
   1668           * such as the key type.
   1669           */

   \                                 In section .text, align 2, keep-with-next
   1670          static psa_status_t psa_validate_key_policy(const psa_key_policy_t *policy)
   1671          {
   \                     psa_validate_key_policy: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1672              if ((policy->usage & ~(PSA_KEY_USAGE_EXPORT |
   1673                                     PSA_KEY_USAGE_COPY |
   1674                                     PSA_KEY_USAGE_ENCRYPT |
   1675                                     PSA_KEY_USAGE_DECRYPT |
   1676                                     PSA_KEY_USAGE_SIGN_MESSAGE |
   1677                                     PSA_KEY_USAGE_VERIFY_MESSAGE |
   1678                                     PSA_KEY_USAGE_SIGN_HASH |
   1679                                     PSA_KEY_USAGE_VERIFY_HASH |
   1680                                     PSA_KEY_USAGE_VERIFY_DERIVATION |
   1681                                     PSA_KEY_USAGE_DERIVE)) != 0) {
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \        0x8   0x4202             TST      R2,R0
   \        0xA   0xD002             BEQ.N    ??psa_validate_key_policy_0
   1682                  return PSA_ERROR_INVALID_ARGUMENT;
   \        0xC   0xF07F 0x0086      MVNS     R0,#+134
   \       0x10   0xE000             B.N      ??psa_validate_key_policy_1
   1683              }
   1684          
   1685              return PSA_SUCCESS;
   \                     ??psa_validate_key_policy_0: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \                     ??psa_validate_key_policy_1: (+1)
   \       0x14   0x4770             BX       LR
   1686          }
   1687          
   1688          /** Validate the internal consistency of key attributes.
   1689           *
   1690           * This function only rejects invalid attribute values. If does not
   1691           * validate the consistency of the attributes with any key data that may
   1692           * be involved in the creation of the key.
   1693           *
   1694           * Call this function early in the key creation process.
   1695           *
   1696           * \param[in] attributes    Key attributes for the new key.
   1697           * \param[out] p_drv        On any return, the driver for the key, if any.
   1698           *                          NULL for a transparent key.
   1699           *
   1700           */

   \                                 In section .text, align 2, keep-with-next
   1701          static psa_status_t psa_validate_key_attributes(
   1702              const psa_key_attributes_t *attributes,
   1703              psa_se_drv_table_entry_t **p_drv)
   1704          {
   \                     psa_validate_key_attributes: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000F             MOVS     R7,R1
   1705              psa_status_t status = PSA_ERROR_INVALID_ARGUMENT;
   \        0x8   0xF07F 0x0886      MVNS     R8,#+134
   \        0xC   0x4645             MOV      R5,R8
   1706              psa_key_lifetime_t lifetime = psa_get_key_lifetime(attributes);
   \        0xE   0x4650             MOV      R0,R10
   \       0x10   0x.... 0x....      BL       psa_get_key_lifetime
   \       0x14   0x4681             MOV      R9,R0
   1707              mbedtls_svc_key_id_t key = psa_get_key_id(attributes);
   \       0x16   0x4650             MOV      R0,R10
   \       0x18   0x.... 0x....      BL       psa_get_key_id
   \       0x1C   0x0004             MOVS     R4,R0
   1708          
   1709              status = psa_validate_key_location(lifetime, p_drv);
   \       0x1E   0x0039             MOVS     R1,R7
   \       0x20   0x4648             MOV      R0,R9
   \       0x22   0x.... 0x....      BL       psa_validate_key_location
   \       0x26   0x0006             MOVS     R6,R0
   1710              if (status != PSA_SUCCESS) {
   \       0x28   0x2E00             CMP      R6,#+0
   \       0x2A   0xD001             BEQ.N    ??psa_validate_key_attributes_0
   1711                  return status;
   \       0x2C   0x0030             MOVS     R0,R6
   \       0x2E   0xE035             B.N      ??psa_validate_key_attributes_1
   1712              }
   1713          
   1714              status = psa_validate_key_persistence(lifetime);
   \                     ??psa_validate_key_attributes_0: (+1)
   \       0x30   0x4648             MOV      R0,R9
   \       0x32   0x.... 0x....      BL       psa_validate_key_persistence
   \       0x36   0x0005             MOVS     R5,R0
   1715              if (status != PSA_SUCCESS) {
   \       0x38   0x2D00             CMP      R5,#+0
   \       0x3A   0xD001             BEQ.N    ??psa_validate_key_attributes_2
   1716                  return status;
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0xE02D             B.N      ??psa_validate_key_attributes_1
   1717              }
   1718          
   1719              if (PSA_KEY_LIFETIME_IS_VOLATILE(lifetime)) {
   \                     ??psa_validate_key_attributes_2: (+1)
   \       0x40   0x4648             MOV      R0,R9
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD103             BNE.N    ??psa_validate_key_attributes_3
   1720                  if (MBEDTLS_SVC_KEY_ID_GET_KEY_ID(key) != 0) {
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD00B             BEQ.N    ??psa_validate_key_attributes_4
   1721                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0xE025             B.N      ??psa_validate_key_attributes_1
   1722                  }
   1723              } else {
   1724                  if (!psa_is_valid_key_id(psa_get_key_id(attributes), 0)) {
   \                     ??psa_validate_key_attributes_3: (+1)
   \       0x50   0x4650             MOV      R0,R10
   \       0x52   0x.... 0x....      BL       psa_get_key_id
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x.... 0x....      BL       psa_is_valid_key_id
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD101             BNE.N    ??psa_validate_key_attributes_4
   1725                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x60   0x4640             MOV      R0,R8
   \       0x62   0xE01B             B.N      ??psa_validate_key_attributes_1
   1726                  }
   1727              }
   1728          
   1729              status = psa_validate_key_policy(&attributes->core.policy);
   \                     ??psa_validate_key_attributes_4: (+1)
   \       0x64   0xF11A 0x000C      ADDS     R0,R10,#+12
   \       0x68   0x.... 0x....      BL       psa_validate_key_policy
   \       0x6C   0x0006             MOVS     R6,R0
   1730              if (status != PSA_SUCCESS) {
   \       0x6E   0x2E00             CMP      R6,#+0
   \       0x70   0xD001             BEQ.N    ??psa_validate_key_attributes_5
   1731                  return status;
   \       0x72   0x0030             MOVS     R0,R6
   \       0x74   0xE012             B.N      ??psa_validate_key_attributes_1
   1732              }
   1733          
   1734              /* Refuse to create overly large keys.
   1735               * Note that this doesn't trigger on import if the attributes don't
   1736               * explicitly specify a size (so psa_get_key_bits returns 0), so
   1737               * psa_import_key() needs its own checks. */
   1738              if (psa_get_key_bits(attributes) > PSA_MAX_KEY_BITS) {
   \                     ??psa_validate_key_attributes_5: (+1)
   \       0x76   0x4650             MOV      R0,R10
   \       0x78   0x.... 0x....      BL       psa_get_key_bits
   \       0x7C   0xF64F 0x71F9      MOVW     R1,#+65529
   \       0x80   0x4288             CMP      R0,R1
   \       0x82   0xD302             BCC.N    ??psa_validate_key_attributes_6
   1739                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x84   0xF07F 0x0085      MVNS     R0,#+133
   \       0x88   0xE008             B.N      ??psa_validate_key_attributes_1
   1740              }
   1741          
   1742              /* Reject invalid flags. These should not be reachable through the API. */
   1743              if (attributes->core.flags & ~(MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY |
   1744                                             MBEDTLS_PSA_KA_MASK_DUAL_USE)) {
   \                     ??psa_validate_key_attributes_6: (+1)
   \       0x8A   0xF8BA 0x1018      LDRH     R1,[R10, #+24]
   \       0x8E   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0x92   0x4201             TST      R1,R0
   \       0x94   0xD001             BEQ.N    ??psa_validate_key_attributes_7
   1745                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x96   0x4640             MOV      R0,R8
   \       0x98   0xE000             B.N      ??psa_validate_key_attributes_1
   1746              }
   1747          
   1748              return PSA_SUCCESS;
   \                     ??psa_validate_key_attributes_7: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \                     ??psa_validate_key_attributes_1: (+1)
   \       0x9C   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1749          }
   1750          
   1751          /** Prepare a key slot to receive key material.
   1752           *
   1753           * This function allocates a key slot and sets its metadata.
   1754           *
   1755           * If this function fails, call psa_fail_key_creation().
   1756           *
   1757           * This function is intended to be used as follows:
   1758           * -# Call psa_start_key_creation() to allocate a key slot, prepare
   1759           *    it with the specified attributes, and in case of a volatile key assign it
   1760           *    a volatile key identifier.
   1761           * -# Populate the slot with the key material.
   1762           * -# Call psa_finish_key_creation() to finalize the creation of the slot.
   1763           * In case of failure at any step, stop the sequence and call
   1764           * psa_fail_key_creation().
   1765           *
   1766           * On success, the key slot is locked. It is the responsibility of the caller
   1767           * to unlock the key slot when it does not access it anymore.
   1768           *
   1769           * \param method            An identification of the calling function.
   1770           * \param[in] attributes    Key attributes for the new key.
   1771           * \param[out] p_slot       On success, a pointer to the prepared slot.
   1772           * \param[out] p_drv        On any return, the driver for the key, if any.
   1773           *                          NULL for a transparent key.
   1774           *
   1775           * \retval #PSA_SUCCESS
   1776           *         The key slot is ready to receive key material.
   1777           * \return If this function fails, the key slot is an invalid state.
   1778           *         You must call psa_fail_key_creation() to wipe and free the slot.
   1779           */

   \                                 In section .text, align 2, keep-with-next
   1780          static psa_status_t psa_start_key_creation(
   1781              psa_key_creation_method_t method,
   1782              const psa_key_attributes_t *attributes,
   1783              psa_key_slot_t **p_slot,
   1784              psa_se_drv_table_entry_t **p_drv)
   1785          {
   \                     psa_start_key_creation: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   1786              psa_status_t status;
   1787              psa_key_id_t volatile_key_id;
   1788              psa_key_slot_t *slot;
   1789          
   1790              (void) method;
   1791              *p_drv = NULL;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1792          
   1793              status = psa_validate_key_attributes(attributes, p_drv);
   \       0x12   0x4641             MOV      R1,R8
   \       0x14   0x0030             MOVS     R0,R6
   \       0x16   0x.... 0x....      BL       psa_validate_key_attributes
   \       0x1A   0x0005             MOVS     R5,R0
   1794              if (status != PSA_SUCCESS) {
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD001             BEQ.N    ??psa_start_key_creation_0
   1795                  return status;
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0xE03B             B.N      ??psa_start_key_creation_1
   1796              }
   1797          
   1798              MBEDTLS_MUTEX_LOCK_CHECK( &mbedtls_psa_slots_mutex );
   \                     ??psa_start_key_creation_0: (+1)
   \       0x24   0x.... 0x....      LDR.W    R9,??DataTable13
   \       0x28   0x4648             MOV      R0,R9
   \       0x2A   0x....             LDR.N    R1,??DataTable13_1
   \       0x2C   0x6809             LDR      R1,[R1, #+0]
   \       0x2E   0x4788             BLX      R1
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD002             BEQ.N    ??psa_start_key_creation_2
   \       0x34   0xF07F 0x0088      MVNS     R0,#+136
   \       0x38   0xE030             B.N      ??psa_start_key_creation_1
   1799              status = psa_get_empty_key_slot( &volatile_key_id, p_slot );
   \                     ??psa_start_key_creation_2: (+1)
   \       0x3A   0x0039             MOVS     R1,R7
   \       0x3C   0x4668             MOV      R0,SP
   \       0x3E   0x.... 0x....      BL       psa_get_empty_key_slot
   \       0x42   0x0004             MOVS     R4,R0
   1800              if( status != PSA_SUCCESS )
   \       0x44   0x2C00             CMP      R4,#+0
   \       0x46   0xD00A             BEQ.N    ??psa_start_key_creation_3
   1801              {
   1802                  MBEDTLS_MUTEX_UNLOCK_CHECK( &mbedtls_psa_slots_mutex );
   \       0x48   0x4648             MOV      R0,R9
   \       0x4A   0x....             LDR.N    R1,??DataTable13_2
   \       0x4C   0x6809             LDR      R1,[R1, #+0]
   \       0x4E   0x4788             BLX      R1
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD002             BEQ.N    ??psa_start_key_creation_4
   \       0x54   0xF07F 0x0088      MVNS     R0,#+136
   \       0x58   0xE020             B.N      ??psa_start_key_creation_1
   1803                  return( status );
   \                     ??psa_start_key_creation_4: (+1)
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0xE01E             B.N      ??psa_start_key_creation_1
   1804              }
   1805              slot = *p_slot;
   \                     ??psa_start_key_creation_3: (+1)
   \       0x5E   0x683D             LDR      R5,[R7, #+0]
   1806          
   1807              /* We're storing the declared bit-size of the key. It's up to each
   1808               * creation mechanism to verify that this information is correct.
   1809               * It's automatically correct for mechanisms that use the bit-size as
   1810               * an input (generate, device) but not for those where the bit-size
   1811               * is optional (import, copy). In case of a volatile key, assign it the
   1812               * volatile key identifier associated to the slot returned to contain its
   1813               * definition. */
   1814          
   1815              slot->attr = attributes->core;
   \       0x60   0x0028             MOVS     R0,R5
   \       0x62   0x0031             MOVS     R1,R6
   \       0x64   0x221C             MOVS     R2,#+28
   \       0x66   0x.... 0x....      BL       __aeabi_memcpy4
   1816              if (PSA_KEY_LIFETIME_IS_VOLATILE(slot->attr.lifetime)) {
   \       0x6A   0x6868             LDR      R0,[R5, #+4]
   \       0x6C   0xB2C0             UXTB     R0,R0
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD101             BNE.N    ??psa_start_key_creation_5
   1817          #if !defined(MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER)
   1818                  slot->attr.id = volatile_key_id;
   \       0x72   0x9800             LDR      R0,[SP, #+0]
   \       0x74   0x60A8             STR      R0,[R5, #+8]
   1819          #else
   1820                  slot->attr.id.key_id = volatile_key_id;
   1821          #endif
   1822              }
   1823          
   1824              /* Erase external-only flags from the internal copy. To access
   1825               * external-only flags, query `attributes`. Thanks to the check
   1826               * in psa_validate_key_attributes(), this leaves the dual-use
   1827               * flags and any internal flag that psa_get_empty_key_slot()
   1828               * may have set. */
   1829              slot->attr.flags &= ~MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY;
   \                     ??psa_start_key_creation_5: (+1)
   \       0x76   0x8B29             LDRH     R1,[R5, #+24]
   \       0x78   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0x7C   0x4001             ANDS     R1,R0,R1
   \       0x7E   0x8329             STRH     R1,[R5, #+24]
   1830          
   1831          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   1832              /* For a key in a secure element, we need to do three things
   1833               * when creating or registering a persistent key:
   1834               * create the key file in internal storage, create the
   1835               * key inside the secure element, and update the driver's
   1836               * persistent data. This is done by starting a transaction that will
   1837               * encompass these three actions.
   1838               * For registering a volatile key, we just need to find an appropriate
   1839               * slot number inside the SE. Since the key is designated volatile, creating
   1840               * a transaction is not required. */
   1841              /* The first thing to do is to find a slot number for the new key.
   1842               * We save the slot number in persistent storage as part of the
   1843               * transaction data. It will be needed to recover if the power
   1844               * fails during the key creation process, to clean up on the secure
   1845               * element side after restarting. Obtaining a slot number from the
   1846               * secure element driver updates its persistent state, but we do not yet
   1847               * save the driver's persistent state, so that if the power fails,
   1848               * we can roll back to a state where the key doesn't exist. */
   1849              if (*p_drv != NULL) {
   1850                  psa_key_slot_number_t slot_number;
   1851                  status = psa_find_se_slot_for_key( attributes, method, *p_drv,
   1852                                                     &slot_number );
   1853                  if( status != PSA_SUCCESS )
   1854                  {
   1855                      MBEDTLS_MUTEX_UNLOCK_CHECK( &mbedtls_psa_slots_mutex );
   1856                      return( status );
   1857                  }
   1858          
   1859                  if (!PSA_KEY_LIFETIME_IS_VOLATILE(attributes->core.lifetime)) {
   1860                      psa_crypto_prepare_transaction(PSA_CRYPTO_TRANSACTION_CREATE_KEY);
   1861                      psa_crypto_transaction.key.lifetime = slot->attr.lifetime;
   1862                      psa_crypto_transaction.key.slot = slot_number;
   1863                      psa_crypto_transaction.key.id = slot->attr.id;
   1864                      status = psa_crypto_save_transaction( );
   1865                      if( status != PSA_SUCCESS )
   1866                      {
   1867                          (void) psa_crypto_stop_transaction( );
   1868                          MBEDTLS_MUTEX_UNLOCK_CHECK( &mbedtls_psa_slots_mutex );
   1869                          return( status );
   1870                      }
   1871                  }
   1872          
   1873                  status = psa_copy_key_material_into_slot(
   1874                      slot, (uint8_t *) (&slot_number), sizeof(slot_number));
   1875              }
   1876          
   1877              if (*p_drv == NULL && method == PSA_KEY_CREATION_REGISTER) {
   1878                  /* Key registration only makes sense with a secure element. */
   1879                  MBEDTLS_MUTEX_UNLOCK_CHECK( &mbedtls_psa_slots_mutex );
   1880                  return( PSA_ERROR_INVALID_ARGUMENT );
   1881              }
   1882          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   1883              psa_slot_change_state( slot, PSA_STATE_CREATING );
   \       0x80   0x2101             MOVS     R1,#+1
   \       0x82   0x0028             MOVS     R0,R5
   \       0x84   0x.... 0x....      BL       psa_slot_change_state
   1884          
   1885              MBEDTLS_MUTEX_UNLOCK_CHECK( &mbedtls_psa_slots_mutex );
   \       0x88   0x4648             MOV      R0,R9
   \       0x8A   0x....             LDR.N    R1,??DataTable13_2
   \       0x8C   0x6809             LDR      R1,[R1, #+0]
   \       0x8E   0x4788             BLX      R1
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD002             BEQ.N    ??psa_start_key_creation_6
   \       0x94   0xF07F 0x0088      MVNS     R0,#+136
   \       0x98   0xE000             B.N      ??psa_start_key_creation_1
   1886              return( PSA_SUCCESS );
   \                     ??psa_start_key_creation_6: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \                     ??psa_start_key_creation_1: (+1)
   \       0x9C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   1887          }
   1888          
   1889          /** Finalize the creation of a key once its key material has been set.
   1890           *
   1891           * This entails writing the key to persistent storage.
   1892           *
   1893           * If this function fails, call psa_fail_key_creation().
   1894           * See the documentation of psa_start_key_creation() for the intended use
   1895           * of this function.
   1896           *
   1897           * If the finalization succeeds, the function unlocks the key slot (it was
   1898           * locked by psa_start_key_creation()) and the key slot cannot be accessed
   1899           * anymore as part of the key creation process.
   1900           *
   1901           * \param[in,out] slot  Pointer to the slot with key material.
   1902           * \param[in] driver    The secure element driver for the key,
   1903           *                      or NULL for a transparent key.
   1904           * \param[out] key      On success, identifier of the key. Note that the
   1905           *                      key identifier is also stored in the key slot.
   1906           *
   1907           * \retval #PSA_SUCCESS
   1908           *         The key was successfully created.
   1909           * \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
   1910           * \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
   1911           * \retval #PSA_ERROR_ALREADY_EXISTS \emptydescription
   1912           * \retval #PSA_ERROR_DATA_INVALID \emptydescription
   1913           * \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
   1914           * \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
   1915           *
   1916           * \return If this function fails, the key slot is an invalid state.
   1917           *         You must call psa_fail_key_creation() to wipe and free the slot.
   1918           */

   \                                 In section .text, align 2, keep-with-next
   1919          static psa_status_t psa_finish_key_creation(
   1920              psa_key_slot_t *slot,
   1921              psa_se_drv_table_entry_t *driver,
   1922              mbedtls_svc_key_id_t *key)
   1923          {
   \                     psa_finish_key_creation: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   1924              psa_status_t status = PSA_SUCCESS;
   \        0xA   0x2400             MOVS     R4,#+0
   1925              (void) slot;
   1926              (void) driver;
   1927          
   1928              MBEDTLS_MUTEX_LOCK_CHECK( &mbedtls_psa_slots_mutex );
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable13
   \       0x10   0x4640             MOV      R0,R8
   \       0x12   0x....             LDR.N    R1,??DataTable13_1
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0x4788             BLX      R1
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD002             BEQ.N    ??psa_finish_key_creation_0
   \       0x1C   0xF07F 0x0088      MVNS     R0,#+136
   \       0x20   0xE02D             B.N      ??psa_finish_key_creation_1
   1929          #if defined(MBEDTLS_PSA_CRYPTO_STORAGE_C)
   1930              if (!PSA_KEY_LIFETIME_IS_VOLATILE(slot->attr.lifetime)) {
   \                     ??psa_finish_key_creation_0: (+1)
   \       0x22   0x6868             LDR      R0,[R5, #+4]
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD005             BEQ.N    ??psa_finish_key_creation_2
   1931          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   1932                  if (driver != NULL) {
   1933                      psa_se_key_data_storage_t data;
   1934                      psa_key_slot_number_t slot_number =
   1935                          psa_key_slot_get_slot_number(slot);
   1936          
   1937                      MBEDTLS_STATIC_ASSERT(sizeof(slot_number) ==
   1938                                            sizeof(data.slot_number),
   1939                                            "Slot number size does not match psa_se_key_data_storage_t");
   1940          
   1941                      memcpy(&data.slot_number, &slot_number, sizeof(slot_number));
   1942                      status = psa_save_persistent_key(&slot->attr,
   1943                                                       (uint8_t *) &data,
   1944                                                       sizeof(data));
   1945                  } else
   1946          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   1947                  {
   1948                      /* Key material is saved in export representation in the slot, so
   1949                       * just pass the slot buffer for storage. */
   1950                      status = psa_save_persistent_key(&slot->attr,
   1951                                                       slot->key.data,
   1952                                                       slot->key.bytes);
   \       0x2A   0x6AAA             LDR      R2,[R5, #+40]
   \       0x2C   0x6A69             LDR      R1,[R5, #+36]
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0x.... 0x....      BL       psa_save_persistent_key
   \       0x34   0x0004             MOVS     R4,R0
   1953                  }
   1954              }
   1955              if( status != PSA_SUCCESS )
   \                     ??psa_finish_key_creation_2: (+1)
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD00A             BEQ.N    ??psa_finish_key_creation_3
   1956              {
   1957                  MBEDTLS_MUTEX_UNLOCK_CHECK( &mbedtls_psa_slots_mutex );
   \       0x3A   0x4640             MOV      R0,R8
   \       0x3C   0x....             LDR.N    R1,??DataTable13_2
   \       0x3E   0x6809             LDR      R1,[R1, #+0]
   \       0x40   0x4788             BLX      R1
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD002             BEQ.N    ??psa_finish_key_creation_4
   \       0x46   0xF07F 0x0088      MVNS     R0,#+136
   \       0x4A   0xE018             B.N      ??psa_finish_key_creation_1
   1958                  return( status );
   \                     ??psa_finish_key_creation_4: (+1)
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0xE016             B.N      ??psa_finish_key_creation_1
   1959              }
   1960          #endif /* defined(MBEDTLS_PSA_CRYPTO_STORAGE_C) */
   1961          
   1962          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   1963              /* Finish the transaction for a key creation. This does not
   1964               * happen when registering an existing key. Detect this case
   1965               * by checking whether a transaction is in progress (actual
   1966               * creation of a persistent key in a secure element requires a transaction,
   1967               * but registration or volatile key creation doesn't use one). */
   1968              if( driver != NULL &&
   1969                  psa_crypto_transaction.unknown.type == PSA_CRYPTO_TRANSACTION_CREATE_KEY )
   1970              {
   1971                  status = psa_save_se_persistent_data( driver );
   1972                  if( status != PSA_SUCCESS )
   1973                  {
   1974                      psa_destroy_persistent_key( slot->attr.id );
   1975                      MBEDTLS_MUTEX_UNLOCK_CHECK( &mbedtls_psa_slots_mutex );
   1976                      return( status );
   1977                  }
   1978                  status = psa_crypto_stop_transaction();
   1979              }
   1980          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   1981          
   1982              if (status == PSA_SUCCESS) {
   \                     ??psa_finish_key_creation_3: (+1)
   \       0x50   0x2C00             CMP      R4,#+0
   \       0x52   0xD10A             BNE.N    ??psa_finish_key_creation_5
   1983                  *key = slot->attr.id;
   \       0x54   0x68A8             LDR      R0,[R5, #+8]
   \       0x56   0x6038             STR      R0,[R7, #+0]
   1984                  status = psa_slot_change_state( slot, PSA_STATE_UNUSED );
   \       0x58   0x2102             MOVS     R1,#+2
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0x.... 0x....      BL       psa_slot_change_state
   \       0x60   0x0004             MOVS     R4,R0
   1985                  if( status != PSA_SUCCESS ) {
   \       0x62   0x2C00             CMP      R4,#+0
   \       0x64   0xD001             BEQ.N    ??psa_finish_key_creation_5
   1986                      *key = MBEDTLS_SVC_KEY_ID_INIT;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x6038             STR      R0,[R7, #+0]
   1987                  }
   1988              }
   1989          
   1990              MBEDTLS_MUTEX_UNLOCK_CHECK( &mbedtls_psa_slots_mutex );
   \                     ??psa_finish_key_creation_5: (+1)
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0x....             LDR.N    R1,??DataTable13_2
   \       0x6E   0x6809             LDR      R1,[R1, #+0]
   \       0x70   0x4788             BLX      R1
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD002             BEQ.N    ??psa_finish_key_creation_6
   \       0x76   0xF07F 0x0088      MVNS     R0,#+136
   \       0x7A   0xE000             B.N      ??psa_finish_key_creation_1
   1991              return( status );
   \                     ??psa_finish_key_creation_6: (+1)
   \       0x7C   0x0020             MOVS     R0,R4
   \                     ??psa_finish_key_creation_1: (+1)
   \       0x7E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1992          }
   1993          
   1994          /** Abort the creation of a key.
   1995           *
   1996           * You may call this function after calling psa_start_key_creation(),
   1997           * or after psa_finish_key_creation() fails. In other circumstances, this
   1998           * function may not clean up persistent storage.
   1999           * See the documentation of psa_start_key_creation() for the intended use
   2000           * of this function.
   2001           *
   2002           * \param[in,out] slot  Pointer to the slot with key material.
   2003           * \param[in] driver    The secure element driver for the key,
   2004           *                      or NULL for a transparent key.
   2005           */

   \                                 In section .text, align 2, keep-with-next
   2006          static void psa_fail_key_creation(psa_key_slot_t *slot,
   2007                                            psa_se_drv_table_entry_t *driver)
   2008          {
   \                     psa_fail_key_creation: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2009              (void) driver;
   2010          
   2011              if (slot == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD00F             BEQ.N    ??psa_fail_key_creation_0
   2012                  return;
   2013              }
   2014          
   2015          #if defined(MBEDTLS_THREADING_C)
   2016              (void) mbedtls_mutex_lock( &mbedtls_psa_slots_mutex );
   \                     ??psa_fail_key_creation_1: (+1)
   \        0xA   0x....             LDR.N    R6,??DataTable13
   \        0xC   0x0030             MOVS     R0,R6
   \        0xE   0x....             LDR.N    R1,??DataTable13_1
   \       0x10   0x6809             LDR      R1,[R1, #+0]
   \       0x12   0x4788             BLX      R1
   2017          #endif
   2018          
   2019          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   2020              /* TODO: If the key has already been created in the secure
   2021               * element, and the failure happened later (when saving metadata
   2022               * to internal storage), we need to destroy the key in the secure
   2023               * element.
   2024               * https://github.com/ARMmbed/mbed-crypto/issues/217
   2025               */
   2026          
   2027              /* Abort the ongoing transaction if any (there may not be one if
   2028               * the creation process failed before starting one, or if the
   2029               * key creation is a registration of a key in a secure element).
   2030               * Earlier functions must already have done what it takes to undo any
   2031               * partial creation. All that's left is to update the transaction data
   2032               * itself. */
   2033              (void) psa_crypto_stop_transaction();
   2034          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   2035          
   2036              (void) psa_slot_change_state( slot, PSA_STATE_WIPING );
   \       0x14   0x2104             MOVS     R1,#+4
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       psa_slot_change_state
   2037              (void) psa_wipe_key_slot( slot );
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       psa_wipe_key_slot
   2038          #if defined(MBEDTLS_THREADING_C)
   2039              (void) mbedtls_mutex_unlock( &mbedtls_psa_slots_mutex );
   \       0x22   0x0030             MOVS     R0,R6
   \       0x24   0x....             LDR.N    R1,??DataTable13_2
   \       0x26   0x6809             LDR      R1,[R1, #+0]
   \       0x28   0x4788             BLX      R1
   2040          #endif
   2041          }
   \                     ??psa_fail_key_creation_0: (+1)
   \       0x2A   0xBD70             POP      {R4-R6,PC}
   2042          
   2043          /** Validate optional attributes during key creation.
   2044           *
   2045           * Some key attributes are optional during key creation. If they are
   2046           * specified in the attributes structure, check that they are consistent
   2047           * with the data in the slot.
   2048           *
   2049           * This function should be called near the end of key creation, after
   2050           * the slot in memory is fully populated but before saving persistent data.
   2051           */

   \                                 In section .text, align 2, keep-with-next
   2052          static psa_status_t psa_validate_optional_attributes(
   2053              const psa_key_slot_t *slot,
   2054              const psa_key_attributes_t *attributes)
   2055          {
   \                     psa_validate_optional_attributes: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   2056              if (attributes->core.type != 0) {
   \        0x2   0x8808             LDRH     R0,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD006             BEQ.N    ??psa_validate_optional_attributes_0
   2057                  if (attributes->core.type != slot->attr.type) {
   \        0x8   0x880B             LDRH     R3,[R1, #+0]
   \        0xA   0x8810             LDRH     R0,[R2, #+0]
   \        0xC   0x4283             CMP      R3,R0
   \        0xE   0xD002             BEQ.N    ??psa_validate_optional_attributes_0
   2058                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x10   0xF07F 0x0086      MVNS     R0,#+134
   \       0x14   0xE010             B.N      ??psa_validate_optional_attributes_1
   2059                  }
   2060              }
   2061          
   2062              if (attributes->domain_parameters_size != 0) {
   \                     ??psa_validate_optional_attributes_0: (+1)
   \       0x16   0x6A08             LDR      R0,[R1, #+32]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD002             BEQ.N    ??psa_validate_optional_attributes_2
   2063          #if (defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_IMPORT) && \
   2064                  defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT)) || \
   2065                  defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY)
   2066                  if (PSA_KEY_TYPE_IS_RSA(slot->attr.type)) {
   2067                      mbedtls_rsa_context *rsa = NULL;
   2068                      mbedtls_mpi actual, required;
   2069                      int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2070          
   2071                      psa_status_t status = mbedtls_psa_rsa_load_representation(
   2072                          slot->attr.type,
   2073                          slot->key.data,
   2074                          slot->key.bytes,
   2075                          &rsa);
   2076                      if (status != PSA_SUCCESS) {
   2077                          return status;
   2078                      }
   2079          
   2080                      mbedtls_mpi_init(&actual);
   2081                      mbedtls_mpi_init(&required);
   2082                      ret = mbedtls_rsa_export(rsa,
   2083                                               NULL, NULL, NULL, NULL, &actual);
   2084                      mbedtls_rsa_free(rsa);
   2085                      mbedtls_free(rsa);
   2086                      if (ret != 0) {
   2087                          goto rsa_exit;
   2088                      }
   2089                      ret = mbedtls_mpi_read_binary(&required,
   2090                                                    attributes->domain_parameters,
   2091                                                    attributes->domain_parameters_size);
   2092                      if (ret != 0) {
   2093                          goto rsa_exit;
   2094                      }
   2095                      if (mbedtls_mpi_cmp_mpi(&actual, &required) != 0) {
   2096                          ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
   2097                      }
   2098          rsa_exit:
   2099                      mbedtls_mpi_free(&actual);
   2100                      mbedtls_mpi_free(&required);
   2101                      if (ret != 0) {
   2102                          return mbedtls_to_psa_error(ret);
   2103                      }
   2104                  } else
   2105          #endif /* (defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_IMPORT) &&
   2106                  *  defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT)) ||
   2107                  * defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY) */
   2108                  {
   2109                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x1C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x20   0xE00A             B.N      ??psa_validate_optional_attributes_1
   2110                  }
   2111              }
   2112          
   2113              if (attributes->core.bits != 0) {
   \                     ??psa_validate_optional_attributes_2: (+1)
   \       0x22   0x8848             LDRH     R0,[R1, #+2]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD006             BEQ.N    ??psa_validate_optional_attributes_3
   2114                  if (attributes->core.bits != slot->attr.bits) {
   \       0x28   0x884B             LDRH     R3,[R1, #+2]
   \       0x2A   0x8850             LDRH     R0,[R2, #+2]
   \       0x2C   0x4283             CMP      R3,R0
   \       0x2E   0xD002             BEQ.N    ??psa_validate_optional_attributes_3
   2115                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x30   0xF07F 0x0086      MVNS     R0,#+134
   \       0x34   0xE000             B.N      ??psa_validate_optional_attributes_1
   2116                  }
   2117              }
   2118          
   2119              return PSA_SUCCESS;
   \                     ??psa_validate_optional_attributes_3: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??psa_validate_optional_attributes_1: (+1)
   \       0x38   0x4770             BX       LR
   2120          }
   2121          

   \                                 In section .text, align 2, keep-with-next
   2122          psa_status_t psa_import_key(const psa_key_attributes_t *attributes,
   2123                                      const uint8_t *data,
   2124                                      size_t data_length,
   2125                                      mbedtls_svc_key_id_t *key)
   2126          {
   \                     psa_import_key: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001F             MOVS     R7,R3
   2127              psa_status_t status;
   2128              psa_key_slot_t *slot = NULL;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9003             STR      R0,[SP, #+12]
   2129              psa_se_drv_table_entry_t *driver = NULL;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9005             STR      R0,[SP, #+20]
   2130              size_t bits;
   2131              size_t storage_size = data_length;
   \       0x16   0x9506             STR      R5,[SP, #+24]
   2132          
   2133              *key = MBEDTLS_SVC_KEY_ID_INIT;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6038             STR      R0,[R7, #+0]
   2134          
   2135              /* Reject zero-length symmetric keys (including raw data key objects).
   2136               * This also rejects any key which might be encoded as an empty string,
   2137               * which is never valid. */
   2138              if (data_length == 0) {
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD102             BNE.N    ??psa_import_key_0
   2139                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x20   0xF07F 0x0086      MVNS     R0,#+134
   \       0x24   0xE06B             B.N      ??psa_import_key_1
   2140              }
   2141          
   2142              /* Ensure that the bytes-to-bits conversion cannot overflow. */
   2143              if (data_length > SIZE_MAX / 8) {
   \                     ??psa_import_key_0: (+1)
   \       0x26   0xF1B5 0x5F00      CMP      R5,#+536870912
   \       0x2A   0xD302             BCC.N    ??psa_import_key_2
   2144                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x2C   0xF07F 0x0085      MVNS     R0,#+133
   \       0x30   0xE065             B.N      ??psa_import_key_1
   2145              }
   2146          
   2147              status = psa_start_key_creation(PSA_KEY_CREATION_IMPORT, attributes,
   2148                                              &slot, &driver);
   \                     ??psa_import_key_2: (+1)
   \       0x32   0xAB05             ADD      R3,SP,#+20
   \       0x34   0xAA03             ADD      R2,SP,#+12
   \       0x36   0x4641             MOV      R1,R8
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x.... 0x....      BL       psa_start_key_creation
   \       0x3E   0x0004             MOVS     R4,R0
   2149              if (status != PSA_SUCCESS) {
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD155             BNE.N    ??psa_import_key_3
   2150                  goto exit;
   2151              }
   2152          
   2153              /* In the case of a transparent key or an opaque key stored in local
   2154               * storage ( thus not in the case of importing a key in a secure element
   2155               * with storage ( MBEDTLS_PSA_CRYPTO_SE_C ) ),we have to allocate a
   2156               * buffer to hold the imported key material. */
   2157              if (slot->key.data == NULL) {
   \                     ??psa_import_key_4: (+1)
   \       0x44   0x9803             LDR      R0,[SP, #+12]
   \       0x46   0x6A40             LDR      R0,[R0, #+36]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD115             BNE.N    ??psa_import_key_5
   2158                  if (psa_key_lifetime_is_external(attributes->core.lifetime)) {
   \       0x4C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x50   0x.... 0x....      BL       psa_key_lifetime_is_external
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD008             BEQ.N    ??psa_import_key_6
   2159                      status = psa_driver_wrapper_get_key_buffer_size_from_key_data(
   2160                          attributes, data, data_length, &storage_size);
   \       0x58   0xAB06             ADD      R3,SP,#+24
   \       0x5A   0x002A             MOVS     R2,R5
   \       0x5C   0x0031             MOVS     R1,R6
   \       0x5E   0x4640             MOV      R0,R8
   \       0x60   0x.... 0x....      BL       psa_driver_wrapper_get_key_buffer_size_from_key_data
   \       0x64   0x0004             MOVS     R4,R0
   2161                      if (status != PSA_SUCCESS) {
   \       0x66   0x2C00             CMP      R4,#+0
   \       0x68   0xD142             BNE.N    ??psa_import_key_3
   2162                          goto exit;
   2163                      }
   2164                  }
   2165                  status = psa_allocate_buffer_to_slot(slot, storage_size);
   \                     ??psa_import_key_6: (+1)
   \       0x6A   0x9906             LDR      R1,[SP, #+24]
   \       0x6C   0x9803             LDR      R0,[SP, #+12]
   \       0x6E   0x.... 0x....      BL       psa_allocate_buffer_to_slot
   \       0x72   0x0004             MOVS     R4,R0
   2166                  if (status != PSA_SUCCESS) {
   \       0x74   0x2C00             CMP      R4,#+0
   \       0x76   0xD13B             BNE.N    ??psa_import_key_3
   2167                      goto exit;
   2168                  }
   2169              }
   2170          
   2171              bits = slot->attr.bits;
   \                     ??psa_import_key_5: (+1)
   \       0x78   0x9803             LDR      R0,[SP, #+12]
   \       0x7A   0x8840             LDRH     R0,[R0, #+2]
   \       0x7C   0x9004             STR      R0,[SP, #+16]
   2172              status = psa_driver_wrapper_import_key(attributes,
   2173                                                     data, data_length,
   2174                                                     slot->key.data,
   2175                                                     slot->key.bytes,
   2176                                                     &slot->key.bytes, &bits);
   \       0x7E   0xA804             ADD      R0,SP,#+16
   \       0x80   0x9002             STR      R0,[SP, #+8]
   \       0x82   0x9803             LDR      R0,[SP, #+12]
   \       0x84   0x3028             ADDS     R0,R0,#+40
   \       0x86   0x9001             STR      R0,[SP, #+4]
   \       0x88   0x9803             LDR      R0,[SP, #+12]
   \       0x8A   0x6A80             LDR      R0,[R0, #+40]
   \       0x8C   0x9000             STR      R0,[SP, #+0]
   \       0x8E   0x9803             LDR      R0,[SP, #+12]
   \       0x90   0x6A43             LDR      R3,[R0, #+36]
   \       0x92   0x002A             MOVS     R2,R5
   \       0x94   0x0031             MOVS     R1,R6
   \       0x96   0x4640             MOV      R0,R8
   \       0x98   0x.... 0x....      BL       psa_driver_wrapper_import_key
   \       0x9C   0x0004             MOVS     R4,R0
   2177              if (status != PSA_SUCCESS) {
   \       0x9E   0x2C00             CMP      R4,#+0
   \       0xA0   0xD126             BNE.N    ??psa_import_key_3
   2178                  goto exit;
   2179              }
   2180          
   2181              if (slot->attr.bits == 0) {
   \                     ??psa_import_key_7: (+1)
   \       0xA2   0x9803             LDR      R0,[SP, #+12]
   \       0xA4   0x8840             LDRH     R0,[R0, #+2]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD103             BNE.N    ??psa_import_key_8
   2182                  slot->attr.bits = (psa_key_bits_t) bits;
   \       0xAA   0x9804             LDR      R0,[SP, #+16]
   \       0xAC   0x9903             LDR      R1,[SP, #+12]
   \       0xAE   0x8048             STRH     R0,[R1, #+2]
   \       0xB0   0xE008             B.N      ??psa_import_key_9
   2183              } else if (bits != slot->attr.bits) {
   \                     ??psa_import_key_8: (+1)
   \       0xB2   0x9804             LDR      R0,[SP, #+16]
   \       0xB4   0x9903             LDR      R1,[SP, #+12]
   \       0xB6   0x8849             LDRH     R1,[R1, #+2]
   \       0xB8   0x4288             CMP      R0,R1
   \       0xBA   0xD003             BEQ.N    ??psa_import_key_9
   2184                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0xBC   0xF07F 0x0086      MVNS     R0,#+134
   \       0xC0   0x0004             MOVS     R4,R0
   2185                  goto exit;
   \       0xC2   0xE015             B.N      ??psa_import_key_3
   2186              }
   2187          
   2188              /* Enforce a size limit, and in particular ensure that the bit
   2189               * size fits in its representation type.*/
   2190              if (bits > PSA_MAX_KEY_BITS) {
   \                     ??psa_import_key_9: (+1)
   \       0xC4   0x9904             LDR      R1,[SP, #+16]
   \       0xC6   0xF64F 0x70F9      MOVW     R0,#+65529
   \       0xCA   0x4281             CMP      R1,R0
   \       0xCC   0xD303             BCC.N    ??psa_import_key_10
   2191                  status = PSA_ERROR_NOT_SUPPORTED;
   \       0xCE   0xF07F 0x0085      MVNS     R0,#+133
   \       0xD2   0x0004             MOVS     R4,R0
   2192                  goto exit;
   \       0xD4   0xE00C             B.N      ??psa_import_key_3
   2193              }
   2194              status = psa_validate_optional_attributes(slot, attributes);
   \                     ??psa_import_key_10: (+1)
   \       0xD6   0x4641             MOV      R1,R8
   \       0xD8   0x9803             LDR      R0,[SP, #+12]
   \       0xDA   0x.... 0x....      BL       psa_validate_optional_attributes
   \       0xDE   0x0004             MOVS     R4,R0
   2195              if (status != PSA_SUCCESS) {
   \       0xE0   0x2C00             CMP      R4,#+0
   \       0xE2   0xD105             BNE.N    ??psa_import_key_3
   2196                  goto exit;
   2197              }
   2198          
   2199              status = psa_finish_key_creation(slot, driver, key);
   \                     ??psa_import_key_11: (+1)
   \       0xE4   0x003A             MOVS     R2,R7
   \       0xE6   0x9905             LDR      R1,[SP, #+20]
   \       0xE8   0x9803             LDR      R0,[SP, #+12]
   \       0xEA   0x.... 0x....      BL       psa_finish_key_creation
   \       0xEE   0x0004             MOVS     R4,R0
   2200          exit:
   2201              if (status != PSA_SUCCESS) {
   \                     ??psa_import_key_3: (+1)
   \       0xF0   0x2C00             CMP      R4,#+0
   \       0xF2   0xD003             BEQ.N    ??psa_import_key_12
   2202                  psa_fail_key_creation(slot, driver);
   \       0xF4   0x9905             LDR      R1,[SP, #+20]
   \       0xF6   0x9803             LDR      R0,[SP, #+12]
   \       0xF8   0x.... 0x....      BL       psa_fail_key_creation
   2203              }
   2204          
   2205              return status;
   \                     ??psa_import_key_12: (+1)
   \       0xFC   0x0020             MOVS     R0,R4
   \                     ??psa_import_key_1: (+1)
   \       0xFE   0xB008             ADD      SP,SP,#+32
   \      0x100   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2206          }
   2207          
   2208          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   2209          psa_status_t mbedtls_psa_register_se_key(
   2210              const psa_key_attributes_t *attributes)
   2211          {
   2212              psa_status_t status;
   2213              psa_key_slot_t *slot = NULL;
   2214              psa_se_drv_table_entry_t *driver = NULL;
   2215              mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
   2216          
   2217              /* Leaving attributes unspecified is not currently supported.
   2218               * It could make sense to query the key type and size from the
   2219               * secure element, but not all secure elements support this
   2220               * and the driver HAL doesn't currently support it. */
   2221              if (psa_get_key_type(attributes) == PSA_KEY_TYPE_NONE) {
   2222                  return PSA_ERROR_NOT_SUPPORTED;
   2223              }
   2224              if (psa_get_key_bits(attributes) == 0) {
   2225                  return PSA_ERROR_NOT_SUPPORTED;
   2226              }
   2227          
   2228              status = psa_start_key_creation(PSA_KEY_CREATION_REGISTER, attributes,
   2229                                              &slot, &driver);
   2230              if (status != PSA_SUCCESS) {
   2231                  goto exit;
   2232              }
   2233          
   2234              status = psa_finish_key_creation(slot, driver, &key);
   2235          
   2236          exit:
   2237              if (status != PSA_SUCCESS) {
   2238                  psa_fail_key_creation(slot, driver);
   2239              }
   2240          
   2241              /* Registration doesn't keep the key in RAM. */
   2242              psa_close_key(key);
   2243              return status;
   2244          }
   2245          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   2246          

   \                                 In section .text, align 2, keep-with-next
   2247          psa_status_t psa_copy_key(mbedtls_svc_key_id_t source_key,
   2248                                    const psa_key_attributes_t *specified_attributes,
   2249                                    mbedtls_svc_key_id_t *target_key)
   2250          {
   \                     psa_copy_key: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   2251              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x0796      MVNS     R7,#+150
   \       0x10   0x46BA             MOV      R10,R7
   2252              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   2253              psa_key_slot_t *source_slot = NULL;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9002             STR      R0,[SP, #+8]
   2254              psa_key_slot_t *target_slot = NULL;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x9003             STR      R0,[SP, #+12]
   2255              psa_key_attributes_t actual_attributes = *specified_attributes;
   \       0x1A   0xA806             ADD      R0,SP,#+24
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0x2224             MOVS     R2,#+36
   \       0x20   0x.... 0x....      BL       __aeabi_memcpy4
   2256              psa_se_drv_table_entry_t *driver = NULL;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x9004             STR      R0,[SP, #+16]
   2257              size_t storage_size = 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x9005             STR      R0,[SP, #+20]
   2258              bool source_key_is_unconditionally_copyable = false;
   \       0x2C   0xF05F 0x0800      MOVS     R8,#+0
   2259          
   2260              *target_key = MBEDTLS_SVC_KEY_ID_INIT;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6030             STR      R0,[R6, #+0]
   2261          
   2262              status = psa_get_and_lock_key_slot_with_policy(
   2263                  source_key, &source_slot, 0, 0);
   \       0x34   0x2300             MOVS     R3,#+0
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0xA902             ADD      R1,SP,#+8
   \       0x3A   0x4648             MOV      R0,R9
   \       0x3C   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x40   0x0004             MOVS     R4,R0
   2264              if (status != PSA_SUCCESS) {
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xF040 0x8092      BNE.W    ??psa_copy_key_0
   2265                  goto exit;
   2266              }
   2267          
   2268              source_key_is_unconditionally_copyable =
   2269                sli_psa_key_is_unconditionally_copyable(source_slot->attr.id);
   \                     ??psa_copy_key_1: (+1)
   \       0x48   0x9802             LDR      R0,[SP, #+8]
   \       0x4A   0x6880             LDR      R0,[R0, #+8]
   \       0x4C   0x.... 0x....      BL       sli_psa_key_is_unconditionally_copyable
   \       0x50   0x4680             MOV      R8,R0
   2270          
   2271              if (!source_key_is_unconditionally_copyable &&
   2272                  ((source_slot->attr.policy.usage & PSA_KEY_USAGE_COPY)
   2273                   != PSA_KEY_USAGE_COPY)) {
   \       0x52   0x4640             MOV      R0,R8
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD107             BNE.N    ??psa_copy_key_2
   \       0x5A   0x9802             LDR      R0,[SP, #+8]
   \       0x5C   0x7B00             LDRB     R0,[R0, #+12]
   \       0x5E   0x0780             LSLS     R0,R0,#+30
   \       0x60   0xD403             BMI.N    ??psa_copy_key_2
   2274                  status = PSA_ERROR_NOT_PERMITTED;
   \       0x62   0xF07F 0x0084      MVNS     R0,#+132
   \       0x66   0x0004             MOVS     R4,R0
   2275                  goto exit;
   \       0x68   0xE080             B.N      ??psa_copy_key_0
   2276              }
   2277          
   2278              status = psa_validate_optional_attributes(source_slot,
   2279                                                        specified_attributes);
   \                     ??psa_copy_key_2: (+1)
   \       0x6A   0x0029             MOVS     R1,R5
   \       0x6C   0x9802             LDR      R0,[SP, #+8]
   \       0x6E   0x.... 0x....      BL       psa_validate_optional_attributes
   \       0x72   0x0004             MOVS     R4,R0
   2280              if (status != PSA_SUCCESS) {
   \       0x74   0x2C00             CMP      R4,#+0
   \       0x76   0xD179             BNE.N    ??psa_copy_key_0
   2281                  goto exit;
   2282              }
   2283          
   2284              /* The target key type and number of bits have been validated by
   2285               * psa_validate_optional_attributes() to be either equal to zero or
   2286               * equal to the ones of the source key. So it is safe to inherit
   2287               * them from the source key now."
   2288               * */
   2289              actual_attributes.core.bits = source_slot->attr.bits;
   \                     ??psa_copy_key_3: (+1)
   \       0x78   0x9802             LDR      R0,[SP, #+8]
   \       0x7A   0x8840             LDRH     R0,[R0, #+2]
   \       0x7C   0xF8AD 0x001A      STRH     R0,[SP, #+26]
   2290              actual_attributes.core.type = source_slot->attr.type;
   \       0x80   0x9802             LDR      R0,[SP, #+8]
   \       0x82   0x8800             LDRH     R0,[R0, #+0]
   \       0x84   0xF8AD 0x0018      STRH     R0,[SP, #+24]
   2291          
   2292          
   2293              status = psa_restrict_key_policy(source_slot->attr.type,
   2294                                               &actual_attributes.core.policy,
   2295                                               &source_slot->attr.policy);
   \       0x88   0x9802             LDR      R0,[SP, #+8]
   \       0x8A   0xF110 0x020C      ADDS     R2,R0,#+12
   \       0x8E   0xA909             ADD      R1,SP,#+36
   \       0x90   0x9802             LDR      R0,[SP, #+8]
   \       0x92   0x8800             LDRH     R0,[R0, #+0]
   \       0x94   0x.... 0x....      BL       psa_restrict_key_policy
   \       0x98   0x0004             MOVS     R4,R0
   2296              if (status != PSA_SUCCESS) {
   \       0x9A   0x2C00             CMP      R4,#+0
   \       0x9C   0xD166             BNE.N    ??psa_copy_key_0
   2297                  goto exit;
   2298              }
   2299          
   2300              status = psa_start_key_creation(PSA_KEY_CREATION_COPY, &actual_attributes,
   2301                                              &target_slot, &driver);
   \                     ??psa_copy_key_4: (+1)
   \       0x9E   0xAB04             ADD      R3,SP,#+16
   \       0xA0   0xAA03             ADD      R2,SP,#+12
   \       0xA2   0xA906             ADD      R1,SP,#+24
   \       0xA4   0x2003             MOVS     R0,#+3
   \       0xA6   0x.... 0x....      BL       psa_start_key_creation
   \       0xAA   0x0004             MOVS     R4,R0
   2302              if (status != PSA_SUCCESS) {
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD15D             BNE.N    ??psa_copy_key_0
   2303                  goto exit;
   2304              }
   2305              if (!source_key_is_unconditionally_copyable &&
   2306                  PSA_KEY_LIFETIME_GET_LOCATION(target_slot->attr.lifetime) !=
   2307                  PSA_KEY_LIFETIME_GET_LOCATION(source_slot->attr.lifetime)) {
   \                     ??psa_copy_key_5: (+1)
   \       0xB0   0x4640             MOV      R0,R8
   \       0xB2   0xB2C0             UXTB     R0,R0
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD10B             BNE.N    ??psa_copy_key_6
   \       0xB8   0x9803             LDR      R0,[SP, #+12]
   \       0xBA   0x6840             LDR      R0,[R0, #+4]
   \       0xBC   0x0A00             LSRS     R0,R0,#+8
   \       0xBE   0x9902             LDR      R1,[SP, #+8]
   \       0xC0   0x6849             LDR      R1,[R1, #+4]
   \       0xC2   0xEBB0 0x2F11      CMP      R0,R1, LSR #+8
   \       0xC6   0xD003             BEQ.N    ??psa_copy_key_6
   2308                  /*
   2309                   * If the source and target keys are stored in different locations,
   2310                   * the source key would need to be exported as plaintext and re-imported
   2311                   * in the other location. This has security implications which have not
   2312                   * been fully mapped. For now, this can be achieved through
   2313                   * appropriate API invocations from the application, if needed.
   2314                   * */
   2315                  status = PSA_ERROR_NOT_SUPPORTED;
   \       0xC8   0xF07F 0x0085      MVNS     R0,#+133
   \       0xCC   0x0004             MOVS     R4,R0
   2316                  goto exit;
   \       0xCE   0xE04D             B.N      ??psa_copy_key_0
   2317              }
   2318              /*
   2319               * When the source and target keys are within the same location,
   2320               * - For transparent keys it is a blind copy without any driver invocation,
   2321               * - For opaque keys this translates to an invocation of the drivers'
   2322               *   copy_key entry point through the dispatch layer.
   2323               * */
   2324              if (psa_key_lifetime_is_external(actual_attributes.core.lifetime)) {
   \                     ??psa_copy_key_6: (+1)
   \       0xD0   0x9807             LDR      R0,[SP, #+28]
   \       0xD2   0x.... 0x....      BL       psa_key_lifetime_is_external
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD02A             BEQ.N    ??psa_copy_key_7
   2325                  status = psa_driver_wrapper_get_key_buffer_size(&actual_attributes,
   2326                                                                  &storage_size);
   \       0xDA   0xA905             ADD      R1,SP,#+20
   \       0xDC   0xA806             ADD      R0,SP,#+24
   \       0xDE   0x.... 0x....      BL       psa_driver_wrapper_get_key_buffer_size
   \       0xE2   0x0004             MOVS     R4,R0
   2327                  if (status != PSA_SUCCESS) {
   \       0xE4   0x2C00             CMP      R4,#+0
   \       0xE6   0xD141             BNE.N    ??psa_copy_key_0
   2328                      goto exit;
   2329                  }
   2330          
   2331                  status = psa_allocate_buffer_to_slot(target_slot, storage_size);
   \                     ??psa_copy_key_8: (+1)
   \       0xE8   0x9905             LDR      R1,[SP, #+20]
   \       0xEA   0x9803             LDR      R0,[SP, #+12]
   \       0xEC   0x.... 0x....      BL       psa_allocate_buffer_to_slot
   \       0xF0   0x0004             MOVS     R4,R0
   2332                  if (status != PSA_SUCCESS) {
   \       0xF2   0x2C00             CMP      R4,#+0
   \       0xF4   0xD13A             BNE.N    ??psa_copy_key_0
   2333                      goto exit;
   2334                  }
   2335          
   2336                  if (psa_key_lifetime_is_external(source_slot->attr.lifetime)) {
   \                     ??psa_copy_key_9: (+1)
   \       0xF6   0x9802             LDR      R0,[SP, #+8]
   \       0xF8   0x6840             LDR      R0,[R0, #+4]
   \       0xFA   0x.... 0x....      BL       psa_key_lifetime_is_external
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD003             BEQ.N    ??psa_copy_key_10
   2337                    // Silicon Labs's opaque driver for key copying is only able to
   2338                    // import transparent keys.
   2339                    status = PSA_ERROR_NOT_SUPPORTED;
   \      0x102   0xF07F 0x0085      MVNS     R0,#+133
   \      0x106   0x0004             MOVS     R4,R0
   2340                    goto exit;
   \      0x108   0xE030             B.N      ??psa_copy_key_0
   2341                  }
   2342          
   2343                  status = psa_driver_wrapper_copy_key(&actual_attributes,
   2344                                                       source_slot->key.data,
   2345                                                       source_slot->key.bytes,
   2346                                                       target_slot->key.data,
   2347                                                       target_slot->key.bytes,
   2348                                                       &target_slot->key.bytes);
   \                     ??psa_copy_key_10: (+1)
   \      0x10A   0x9803             LDR      R0,[SP, #+12]
   \      0x10C   0x3028             ADDS     R0,R0,#+40
   \      0x10E   0x9001             STR      R0,[SP, #+4]
   \      0x110   0x9803             LDR      R0,[SP, #+12]
   \      0x112   0x6A80             LDR      R0,[R0, #+40]
   \      0x114   0x9000             STR      R0,[SP, #+0]
   \      0x116   0x9803             LDR      R0,[SP, #+12]
   \      0x118   0x6A43             LDR      R3,[R0, #+36]
   \      0x11A   0x9802             LDR      R0,[SP, #+8]
   \      0x11C   0x6A82             LDR      R2,[R0, #+40]
   \      0x11E   0x9802             LDR      R0,[SP, #+8]
   \      0x120   0x6A41             LDR      R1,[R0, #+36]
   \      0x122   0xA806             ADD      R0,SP,#+24
   \      0x124   0x.... 0x....      BL       psa_driver_wrapper_copy_key
   \      0x128   0x0004             MOVS     R4,R0
   2349                  if (status != PSA_SUCCESS) {
   \      0x12A   0x2C00             CMP      R4,#+0
   \      0x12C   0xD018             BEQ.N    ??psa_copy_key_11
   2350                      goto exit;
   \      0x12E   0xE01D             B.N      ??psa_copy_key_0
   2351                  }
   2352              } else if (source_key_is_unconditionally_copyable &&
   2353                         psa_key_lifetime_is_external(source_slot->attr.lifetime)) {
   \                     ??psa_copy_key_7: (+1)
   \      0x130   0x4640             MOV      R0,R8
   \      0x132   0xB2C0             UXTB     R0,R0
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD009             BEQ.N    ??psa_copy_key_12
   \      0x138   0x9802             LDR      R0,[SP, #+8]
   \      0x13A   0x6840             LDR      R0,[R0, #+4]
   \      0x13C   0x.... 0x....      BL       psa_key_lifetime_is_external
   \      0x140   0x2800             CMP      R0,#+0
   \      0x142   0xD003             BEQ.N    ??psa_copy_key_12
   2354                /* We can't copy from an opaque key into a transparent one. */
   2355                status = PSA_ERROR_NOT_PERMITTED;
   \      0x144   0xF07F 0x0084      MVNS     R0,#+132
   \      0x148   0x0004             MOVS     R4,R0
   2356                goto exit;
   \      0x14A   0xE00F             B.N      ??psa_copy_key_0
   2357              } else {
   2358                  status = psa_copy_key_material_into_slot(target_slot,
   2359                                                           source_slot->key.data,
   2360                                                           source_slot->key.bytes);
   \                     ??psa_copy_key_12: (+1)
   \      0x14C   0x9802             LDR      R0,[SP, #+8]
   \      0x14E   0x6A82             LDR      R2,[R0, #+40]
   \      0x150   0x9802             LDR      R0,[SP, #+8]
   \      0x152   0x6A41             LDR      R1,[R0, #+36]
   \      0x154   0x9803             LDR      R0,[SP, #+12]
   \      0x156   0x.... 0x....      BL       psa_copy_key_material_into_slot
   \      0x15A   0x0004             MOVS     R4,R0
   2361                  if (status != PSA_SUCCESS) {
   \      0x15C   0x2C00             CMP      R4,#+0
   \      0x15E   0xD105             BNE.N    ??psa_copy_key_0
   2362                      goto exit;
   2363                  }
   2364              }
   2365              status = psa_finish_key_creation(target_slot, driver, target_key);
   \                     ??psa_copy_key_11: (+1)
   \      0x160   0x0032             MOVS     R2,R6
   \      0x162   0x9904             LDR      R1,[SP, #+16]
   \      0x164   0x9803             LDR      R0,[SP, #+12]
   \      0x166   0x.... 0x....      BL       psa_finish_key_creation
   \      0x16A   0x0004             MOVS     R4,R0
   2366          exit:
   2367              if (status != PSA_SUCCESS) {
   \                     ??psa_copy_key_0: (+1)
   \      0x16C   0x2C00             CMP      R4,#+0
   \      0x16E   0xD003             BEQ.N    ??psa_copy_key_13
   2368                  psa_fail_key_creation(target_slot, driver);
   \      0x170   0x9904             LDR      R1,[SP, #+16]
   \      0x172   0x9803             LDR      R0,[SP, #+12]
   \      0x174   0x.... 0x....      BL       psa_fail_key_creation
   2369              }
   2370          
   2371              unlock_status = psa_unlock_key_slot(source_slot);
   \                     ??psa_copy_key_13: (+1)
   \      0x178   0x9802             LDR      R0,[SP, #+8]
   \      0x17A   0x.... 0x....      BL       psa_unlock_key_slot
   2372          
   2373              return (status == PSA_SUCCESS) ? unlock_status : status;
   \      0x17E   0x2C00             CMP      R4,#+0
   \      0x180   0xD101             BNE.N    ??psa_copy_key_14
   \      0x182   0x0004             MOVS     R4,R0
   \      0x184   0xE7FF             B.N      ??psa_copy_key_15
   \                     ??psa_copy_key_14: (+1)
   \                     ??psa_copy_key_15: (+1)
   \      0x186   0x0020             MOVS     R0,R4
   \      0x188   0xB010             ADD      SP,SP,#+64
   \      0x18A   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2374          }
   2375          
   2376          
   2377          
   2378          /****************************************************************/
   2379          /* Message digests */
   2380          /****************************************************************/
   2381          

   \                                 In section .text, align 2, keep-with-next
   2382          psa_status_t psa_hash_abort(psa_hash_operation_t *operation)
   2383          {
   \                     psa_hash_abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2384              /* Aborting a non-active operation is allowed */
   2385              if (operation->id == 0) {
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD101             BNE.N    ??psa_hash_abort_0
   2386                  return PSA_SUCCESS;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE004             B.N      ??psa_hash_abort_1
   2387              }
   2388          
   2389              psa_status_t status = psa_driver_wrapper_hash_abort(operation);
   \                     ??psa_hash_abort_0: (+1)
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       psa_driver_wrapper_hash_abort
   2390              operation->id = 0;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6021             STR      R1,[R4, #+0]
   2391          
   2392              return status;
   \                     ??psa_hash_abort_1: (+1)
   \       0x18   0xBD10             POP      {R4,PC}
   2393          }
   2394          

   \                                 In section .text, align 2, keep-with-next
   2395          psa_status_t psa_hash_setup(psa_hash_operation_t *operation,
   2396                                      psa_algorithm_t alg)
   2397          {
   \                     psa_hash_setup: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   2398              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x0796      MVNS     R7,#+150
   2399          
   2400              /* A context must be freshly initialized before it can be set up. */
   2401              if (operation->id != 0) {
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD002             BEQ.N    ??psa_hash_setup_0
   2402                  status = PSA_ERROR_BAD_STATE;
   \       0x12   0xF07F 0x0488      MVNS     R4,#+136
   2403                  goto exit;
   \       0x16   0xE016             B.N      ??psa_hash_setup_1
   2404              }
   2405          
   2406              if (!PSA_ALG_IS_HASH(alg)) {
   \                     ??psa_hash_setup_0: (+1)
   \       0x18   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \       0x1C   0xF1B0 0x7F00      CMP      R0,#+33554432
   \       0x20   0xD002             BEQ.N    ??psa_hash_setup_2
   2407                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x22   0xF07F 0x0486      MVNS     R4,#+134
   2408                  goto exit;
   \       0x26   0xE00E             B.N      ??psa_hash_setup_1
   2409              }
   2410          
   2411              /* Ensure all of the context is zeroized, since PSA_HASH_OPERATION_INIT only
   2412               * directly zeroes the int-sized dummy member of the context union. */
   2413              memset(&operation->ctx, 0, sizeof(operation->ctx));
   \                     ??psa_hash_setup_2: (+1)
   \       0x28   0xF05F 0x08DC      MOVS     R8,#+220
   \       0x2C   0xF05F 0x0900      MOVS     R9,#+0
   \       0x30   0x1D2C             ADDS     R4,R5,#+4
   \       0x32   0x464A             MOV      R2,R9
   \       0x34   0x4641             MOV      R1,R8
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       __aeabi_memset
   2414          
   2415              status = psa_driver_wrapper_hash_setup(operation, alg);
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0x0028             MOVS     R0,R5
   \       0x40   0x.... 0x....      BL       psa_driver_wrapper_hash_setup
   \       0x44   0x0004             MOVS     R4,R0
   2416          
   2417          exit:
   2418              if (status != PSA_SUCCESS) {
   \                     ??psa_hash_setup_1: (+1)
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD002             BEQ.N    ??psa_hash_setup_3
   2419                  psa_hash_abort(operation);
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0x.... 0x....      BL       psa_hash_abort
   2420              }
   2421          
   2422              return status;
   \                     ??psa_hash_setup_3: (+1)
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2423          }
   2424          

   \                                 In section .text, align 2, keep-with-next
   2425          psa_status_t psa_hash_update(psa_hash_operation_t *operation,
   2426                                       const uint8_t *input,
   2427                                       size_t input_length)
   2428          {
   \                     psa_hash_update: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   2429              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0796      MVNS     R7,#+150
   2430          
   2431              if (operation->id == 0) {
   \        0xE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??psa_hash_update_0
   2432                  status = PSA_ERROR_BAD_STATE;
   \       0x16   0xF07F 0x0588      MVNS     R5,#+136
   2433                  goto exit;
   \       0x1A   0xE009             B.N      ??psa_hash_update_1
   2434              }
   2435          
   2436              /* Don't require hash implementations to behave correctly on a
   2437               * zero-length input, which may have an invalid pointer. */
   2438              if (input_length == 0) {
   \                     ??psa_hash_update_0: (+1)
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD101             BNE.N    ??psa_hash_update_2
   2439                  return PSA_SUCCESS;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xE00B             B.N      ??psa_hash_update_3
   2440              }
   2441          
   2442              status = psa_driver_wrapper_hash_update(operation, input, input_length);
   \                     ??psa_hash_update_2: (+1)
   \       0x24   0x0022             MOVS     R2,R4
   \       0x26   0x0031             MOVS     R1,R6
   \       0x28   0x4640             MOV      R0,R8
   \       0x2A   0x.... 0x....      BL       psa_driver_wrapper_hash_update
   \       0x2E   0x0005             MOVS     R5,R0
   2443          
   2444          exit:
   2445              if (status != PSA_SUCCESS) {
   \                     ??psa_hash_update_1: (+1)
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xD002             BEQ.N    ??psa_hash_update_4
   2446                  psa_hash_abort(operation);
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0x.... 0x....      BL       psa_hash_abort
   2447              }
   2448          
   2449              return status;
   \                     ??psa_hash_update_4: (+1)
   \       0x3A   0x0028             MOVS     R0,R5
   \                     ??psa_hash_update_3: (+1)
   \       0x3C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2450          }
   2451          

   \                                 In section .text, align 2, keep-with-next
   2452          psa_status_t psa_hash_finish(psa_hash_operation_t *operation,
   2453                                       uint8_t *hash,
   2454                                       size_t hash_size,
   2455                                       size_t *hash_length)
   2456          {
   \                     psa_hash_finish: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   2457              *hash_length = 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6038             STR      R0,[R7, #+0]
   2458              if (operation->id == 0) {
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??psa_hash_finish_0
   2459                  return PSA_ERROR_BAD_STATE;
   \       0x16   0xF07F 0x0088      MVNS     R0,#+136
   \       0x1A   0xE00A             B.N      ??psa_hash_finish_1
   2460              }
   2461          
   2462              psa_status_t status = psa_driver_wrapper_hash_finish(
   2463                  operation, hash, hash_size, hash_length);
   \                     ??psa_hash_finish_0: (+1)
   \       0x1C   0x003B             MOVS     R3,R7
   \       0x1E   0x0032             MOVS     R2,R6
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       psa_driver_wrapper_hash_finish
   \       0x28   0x4680             MOV      R8,R0
   2464              psa_hash_abort(operation);
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x.... 0x....      BL       psa_hash_abort
   2465              return status;
   \       0x30   0x4640             MOV      R0,R8
   \                     ??psa_hash_finish_1: (+1)
   \       0x32   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2466          }
   2467          

   \                                 In section .text, align 2, keep-with-next
   2468          psa_status_t psa_hash_verify(psa_hash_operation_t *operation,
   2469                                       const uint8_t *hash,
   2470                                       size_t hash_length)
   2471          {
   \                     psa_hash_verify: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   2472              uint8_t actual_hash[PSA_HASH_MAX_SIZE];
   2473              size_t actual_hash_length;
   2474              psa_status_t status = psa_hash_finish(
   2475                  operation,
   2476                  actual_hash, sizeof(actual_hash),
   2477                  &actual_hash_length);
   \        0xA   0x466B             MOV      R3,SP
   \        0xC   0x2220             MOVS     R2,#+32
   \        0xE   0xA901             ADD      R1,SP,#+4
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       psa_hash_finish
   \       0x16   0x0004             MOVS     R4,R0
   2478          
   2479              if (status != PSA_SUCCESS) {
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD110             BNE.N    ??psa_hash_verify_0
   2480                  goto exit;
   2481              }
   2482          
   2483              if (actual_hash_length != hash_length) {
   \                     ??psa_hash_verify_1: (+1)
   \       0x1C   0x9800             LDR      R0,[SP, #+0]
   \       0x1E   0x42B8             CMP      R0,R7
   \       0x20   0xD003             BEQ.N    ??psa_hash_verify_2
   2484                  status = PSA_ERROR_INVALID_SIGNATURE;
   \       0x22   0xF07F 0x0094      MVNS     R0,#+148
   \       0x26   0x0004             MOVS     R4,R0
   2485                  goto exit;
   \       0x28   0xE009             B.N      ??psa_hash_verify_0
   2486              }
   2487          
   2488              if (mbedtls_ct_memcmp(hash, actual_hash, actual_hash_length) != 0) {
   \                     ??psa_hash_verify_2: (+1)
   \       0x2A   0x9A00             LDR      R2,[SP, #+0]
   \       0x2C   0xA901             ADD      R1,SP,#+4
   \       0x2E   0x0030             MOVS     R0,R6
   \       0x30   0x.... 0x....      BL       mbedtls_ct_memcmp
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD002             BEQ.N    ??psa_hash_verify_0
   2489                  status = PSA_ERROR_INVALID_SIGNATURE;
   \       0x38   0xF07F 0x0094      MVNS     R0,#+148
   \       0x3C   0x0004             MOVS     R4,R0
   2490              }
   2491          
   2492          exit:
   2493              mbedtls_platform_zeroize(actual_hash, sizeof(actual_hash));
   \                     ??psa_hash_verify_0: (+1)
   \       0x3E   0x2120             MOVS     R1,#+32
   \       0x40   0xA801             ADD      R0,SP,#+4
   \       0x42   0x.... 0x....      BL       mbedtls_platform_zeroize
   2494              if (status != PSA_SUCCESS) {
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD002             BEQ.N    ??psa_hash_verify_3
   2495                  psa_hash_abort(operation);
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0x.... 0x....      BL       psa_hash_abort
   2496              }
   2497          
   2498              return status;
   \                     ??psa_hash_verify_3: (+1)
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0xB009             ADD      SP,SP,#+36
   \       0x54   0xBDF0             POP      {R4-R7,PC}
   2499          }
   2500          

   \                                 In section .text, align 2, keep-with-next
   2501          psa_status_t psa_hash_compute(psa_algorithm_t alg,
   2502                                        const uint8_t *input, size_t input_length,
   2503                                        uint8_t *hash, size_t hash_size,
   2504                                        size_t *hash_length)
   2505          {
   \                     psa_hash_compute: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8024      LDR      R8,[SP, #+36]
   2506              *hash_length = 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xF8C8 0x0000      STR      R0,[R8, #+0]
   2507              if (!PSA_ALG_IS_HASH(alg)) {
   \       0x16   0xF014 0x40FE      ANDS     R0,R4,#0x7F000000
   \       0x1A   0xF1B0 0x7F00      CMP      R0,#+33554432
   \       0x1E   0xD002             BEQ.N    ??psa_hash_compute_0
   2508                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x20   0xF07F 0x0086      MVNS     R0,#+134
   \       0x24   0xE009             B.N      ??psa_hash_compute_1
   2509              }
   2510          
   2511              return psa_driver_wrapper_hash_compute(alg, input, input_length,
   2512                                                     hash, hash_size, hash_length);
   \                     ??psa_hash_compute_0: (+1)
   \       0x26   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x2A   0x9808             LDR      R0,[SP, #+32]
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \       0x2E   0x003B             MOVS     R3,R7
   \       0x30   0x0032             MOVS     R2,R6
   \       0x32   0x0029             MOVS     R1,R5
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       psa_driver_wrapper_hash_compute
   \                     ??psa_hash_compute_1: (+1)
   \       0x3A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   2513          }
   2514          

   \                                 In section .text, align 2, keep-with-next
   2515          psa_status_t psa_hash_compare(psa_algorithm_t alg,
   2516                                        const uint8_t *input, size_t input_length,
   2517                                        const uint8_t *hash, size_t hash_length)
   2518          {
   \                     psa_hash_compare: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0xF8DD 0x9048      LDR      R9,[SP, #+72]
   2519              uint8_t actual_hash[PSA_HASH_MAX_SIZE];
   2520              size_t actual_hash_length;
   2521          
   2522              if (!PSA_ALG_IS_HASH(alg)) {
   \       0x12   0xF015 0x40FE      ANDS     R0,R5,#0x7F000000
   \       0x16   0xF1B0 0x7F00      CMP      R0,#+33554432
   \       0x1A   0xD002             BEQ.N    ??psa_hash_compare_0
   2523                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x1C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x20   0xE022             B.N      ??psa_hash_compare_1
   2524              }
   2525          
   2526              psa_status_t status = psa_driver_wrapper_hash_compute(
   2527                  alg, input, input_length,
   2528                  actual_hash, sizeof(actual_hash),
   2529                  &actual_hash_length);
   \                     ??psa_hash_compare_0: (+1)
   \       0x22   0xA802             ADD      R0,SP,#+8
   \       0x24   0x9001             STR      R0,[SP, #+4]
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0xAB03             ADD      R3,SP,#+12
   \       0x2C   0x003A             MOVS     R2,R7
   \       0x2E   0x0031             MOVS     R1,R6
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x.... 0x....      BL       psa_driver_wrapper_hash_compute
   \       0x36   0x0004             MOVS     R4,R0
   2530              if (status != PSA_SUCCESS) {
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD110             BNE.N    ??psa_hash_compare_2
   2531                  goto exit;
   2532              }
   2533              if (actual_hash_length != hash_length) {
   \                     ??psa_hash_compare_3: (+1)
   \       0x3C   0x9802             LDR      R0,[SP, #+8]
   \       0x3E   0x4548             CMP      R0,R9
   \       0x40   0xD003             BEQ.N    ??psa_hash_compare_4
   2534                  status = PSA_ERROR_INVALID_SIGNATURE;
   \       0x42   0xF07F 0x0094      MVNS     R0,#+148
   \       0x46   0x0004             MOVS     R4,R0
   2535                  goto exit;
   \       0x48   0xE009             B.N      ??psa_hash_compare_2
   2536              }
   2537              if (mbedtls_ct_memcmp(hash, actual_hash, actual_hash_length) != 0) {
   \                     ??psa_hash_compare_4: (+1)
   \       0x4A   0x9A02             LDR      R2,[SP, #+8]
   \       0x4C   0xA903             ADD      R1,SP,#+12
   \       0x4E   0x4640             MOV      R0,R8
   \       0x50   0x.... 0x....      BL       mbedtls_ct_memcmp
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD002             BEQ.N    ??psa_hash_compare_2
   2538                  status = PSA_ERROR_INVALID_SIGNATURE;
   \       0x58   0xF07F 0x0094      MVNS     R0,#+148
   \       0x5C   0x0004             MOVS     R4,R0
   2539              }
   2540          
   2541          exit:
   2542              mbedtls_platform_zeroize(actual_hash, sizeof(actual_hash));
   \                     ??psa_hash_compare_2: (+1)
   \       0x5E   0x2120             MOVS     R1,#+32
   \       0x60   0xA803             ADD      R0,SP,#+12
   \       0x62   0x.... 0x....      BL       mbedtls_platform_zeroize
   2543              return status;
   \       0x66   0x0020             MOVS     R0,R4
   \                     ??psa_hash_compare_1: (+1)
   \       0x68   0xB00B             ADD      SP,SP,#+44
   \       0x6A   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2544          }
   2545          

   \                                 In section .text, align 2, keep-with-next
   2546          psa_status_t psa_hash_clone(const psa_hash_operation_t *source_operation,
   2547                                      psa_hash_operation_t *target_operation)
   2548          {
   \                     psa_hash_clone: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000D             MOVS     R5,R1
   2549              if (source_operation->id == 0 ||
   2550                  target_operation->id != 0) {
   \        0x6   0x6830             LDR      R0,[R6, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??psa_hash_clone_0
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD002             BEQ.N    ??psa_hash_clone_1
   2551                  return PSA_ERROR_BAD_STATE;
   \                     ??psa_hash_clone_0: (+1)
   \       0x12   0xF07F 0x0088      MVNS     R0,#+136
   \       0x16   0xE00A             B.N      ??psa_hash_clone_2
   2552              }
   2553          
   2554              psa_status_t status = psa_driver_wrapper_hash_clone(source_operation,
   2555                                                                  target_operation);
   \                     ??psa_hash_clone_1: (+1)
   \       0x18   0x0029             MOVS     R1,R5
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x.... 0x....      BL       psa_driver_wrapper_hash_clone
   \       0x20   0x0004             MOVS     R4,R0
   2556              if (status != PSA_SUCCESS) {
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD002             BEQ.N    ??psa_hash_clone_3
   2557                  psa_hash_abort(target_operation);
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       psa_hash_abort
   2558              }
   2559          
   2560              return status;
   \                     ??psa_hash_clone_3: (+1)
   \       0x2C   0x0020             MOVS     R0,R4
   \                     ??psa_hash_clone_2: (+1)
   \       0x2E   0xBD70             POP      {R4-R6,PC}
   2561          }
   2562          
   2563          
   2564          /****************************************************************/
   2565          /* MAC */
   2566          /****************************************************************/
   2567          

   \                                 In section .text, align 2, keep-with-next
   2568          psa_status_t psa_mac_abort(psa_mac_operation_t *operation)
   2569          {
   \                     psa_mac_abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2570              /* Aborting a non-active operation is allowed */
   2571              if (operation->id == 0) {
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD101             BNE.N    ??psa_mac_abort_0
   2572                  return PSA_SUCCESS;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE00A             B.N      ??psa_mac_abort_1
   2573              }
   2574          
   2575              psa_status_t status = psa_driver_wrapper_mac_abort(operation);
   \                     ??psa_mac_abort_0: (+1)
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       psa_driver_wrapper_mac_abort
   2576              operation->mac_size = 0;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x7121             STRB     R1,[R4, #+4]
   2577              operation->is_sign = 0;
   \       0x18   0x6861             LDR      R1,[R4, #+4]
   \       0x1A   0xF431 0x7180      BICS     R1,R1,#0x100
   \       0x1E   0x6061             STR      R1,[R4, #+4]
   2578              operation->id = 0;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6021             STR      R1,[R4, #+0]
   2579          
   2580              return status;
   \                     ??psa_mac_abort_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   2581          }
   2582          

   \                                 In section .text, align 2, keep-with-next
   2583          static psa_status_t psa_mac_finalize_alg_and_key_validation(
   2584              psa_algorithm_t alg,
   2585              const psa_key_attributes_t *attributes,
   2586              uint8_t *mac_size)
   2587          {
   \                     psa_mac_finalize_alg_and_key_validation: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   2588              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0996      MVNS     R9,#+150
   2589              psa_key_type_t key_type = psa_get_key_type(attributes);
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       psa_get_key_type
   \       0x14   0x0007             MOVS     R7,R0
   2590              size_t key_bits = psa_get_key_bits(attributes);
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x.... 0x....      BL       psa_get_key_bits
   \       0x1C   0x4680             MOV      R8,R0
   2591          
   2592              if (!PSA_ALG_IS_MAC(alg)) {
   \       0x1E   0xF014 0x40FE      ANDS     R0,R4,#0x7F000000
   \       0x22   0xF1B0 0x7F40      CMP      R0,#+50331648
   \       0x26   0xD002             BEQ.N    ??psa_mac_finalize_alg_and_key_validation_0
   2593                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x28   0xF07F 0x0086      MVNS     R0,#+134
   \       0x2C   0xE169             B.N      ??psa_mac_finalize_alg_and_key_validation_1
   2594              }
   2595          
   2596              /* Validate the combination of key type and algorithm */
   2597              status = psa_mac_key_can_do(alg, key_type);
   \                     ??psa_mac_finalize_alg_and_key_validation_0: (+1)
   \       0x2E   0x0039             MOVS     R1,R7
   \       0x30   0xB289             UXTH     R1,R1
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       psa_mac_key_can_do
   \       0x38   0x0001             MOVS     R1,R0
   2598              if (status != PSA_SUCCESS) {
   \       0x3A   0x2900             CMP      R1,#+0
   \       0x3C   0xD001             BEQ.N    ??psa_mac_finalize_alg_and_key_validation_2
   2599                  return status;
   \       0x3E   0x0008             MOVS     R0,R1
   \       0x40   0xE15F             B.N      ??psa_mac_finalize_alg_and_key_validation_1
   2600              }
   2601          
   2602              /* Get the output length for the algorithm and key combination */
   2603              *mac_size = PSA_MAC_LENGTH(key_type, key_bits, alg);
   \                     ??psa_mac_finalize_alg_and_key_validation_2: (+1)
   \       0x42   0xF414 0x1F7C      TST      R4,#0x3F0000
   \       0x46   0xD004             BEQ.N    ??psa_mac_finalize_alg_and_key_validation_3
   \       0x48   0x0022             MOVS     R2,R4
   \       0x4A   0x0C12             LSRS     R2,R2,#+16
   \       0x4C   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \       0x50   0xE0A1             B.N      ??psa_mac_finalize_alg_and_key_validation_4
   \                     ??psa_mac_finalize_alg_and_key_validation_3: (+1)
   \       0x52   0x.... 0x....      LDR.W    R2,??DataTable17
   \       0x56   0xEA12 0x0004      ANDS     R0,R2,R4
   \       0x5A   0xF1B0 0x7F60      CMP      R0,#+58720256
   \       0x5E   0xF040 0x8084      BNE.W    ??psa_mac_finalize_alg_and_key_validation_5
   \       0x62   0xF004 0x02FF      AND      R2,R4,#0xFF
   \       0x66   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable18
   \       0x6E   0x4282             CMP      R2,R0
   \       0x70   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_6
   \       0x72   0x2210             MOVS     R2,#+16
   \       0x74   0xE08F             B.N      ??psa_mac_finalize_alg_and_key_validation_7
   \                     ??psa_mac_finalize_alg_and_key_validation_6: (+1)
   \       0x76   0xF004 0x02FF      AND      R2,R4,#0xFF
   \       0x7A   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \       0x82   0x4282             CMP      R2,R0
   \       0x84   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_8
   \       0x86   0x2214             MOVS     R2,#+20
   \       0x88   0xE06E             B.N      ??psa_mac_finalize_alg_and_key_validation_9
   \                     ??psa_mac_finalize_alg_and_key_validation_8: (+1)
   \       0x8A   0xF004 0x02FF      AND      R2,R4,#0xFF
   \       0x8E   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \       0x96   0x4282             CMP      R2,R0
   \       0x98   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_10
   \       0x9A   0x2214             MOVS     R2,#+20
   \       0x9C   0xE064             B.N      ??psa_mac_finalize_alg_and_key_validation_9
   \                     ??psa_mac_finalize_alg_and_key_validation_10: (+1)
   \       0x9E   0xF004 0x02FF      AND      R2,R4,#0xFF
   \       0xA2   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \       0xAA   0x4282             CMP      R2,R0
   \       0xAC   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_11
   \       0xAE   0x221C             MOVS     R2,#+28
   \       0xB0   0xE05A             B.N      ??psa_mac_finalize_alg_and_key_validation_12
   \                     ??psa_mac_finalize_alg_and_key_validation_11: (+1)
   \       0xB2   0xF004 0x02FF      AND      R2,R4,#0xFF
   \       0xB6   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xBA   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \       0xBE   0x4282             CMP      R2,R0
   \       0xC0   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_13
   \       0xC2   0x2220             MOVS     R2,#+32
   \       0xC4   0xE050             B.N      ??psa_mac_finalize_alg_and_key_validation_12
   \                     ??psa_mac_finalize_alg_and_key_validation_13: (+1)
   \       0xC6   0xF004 0x02FF      AND      R2,R4,#0xFF
   \       0xCA   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xCE   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \       0xD2   0x4282             CMP      R2,R0
   \       0xD4   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_14
   \       0xD6   0x2230             MOVS     R2,#+48
   \       0xD8   0xE046             B.N      ??psa_mac_finalize_alg_and_key_validation_15
   \                     ??psa_mac_finalize_alg_and_key_validation_14: (+1)
   \       0xDA   0xF004 0x02FF      AND      R2,R4,#0xFF
   \       0xDE   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xE2   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \       0xE6   0x4282             CMP      R2,R0
   \       0xE8   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_16
   \       0xEA   0x2240             MOVS     R2,#+64
   \       0xEC   0xE03C             B.N      ??psa_mac_finalize_alg_and_key_validation_15
   \                     ??psa_mac_finalize_alg_and_key_validation_16: (+1)
   \       0xEE   0xF004 0x02FF      AND      R2,R4,#0xFF
   \       0xF2   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xF6   0x.... 0x....      LDR.W    R0,??DataTable18_7
   \       0xFA   0x4282             CMP      R2,R0
   \       0xFC   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_17
   \       0xFE   0x221C             MOVS     R2,#+28
   \      0x100   0xE032             B.N      ??psa_mac_finalize_alg_and_key_validation_18
   \                     ??psa_mac_finalize_alg_and_key_validation_17: (+1)
   \      0x102   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x106   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x10A   0x.... 0x....      LDR.W    R0,??DataTable18_8
   \      0x10E   0x4282             CMP      R2,R0
   \      0x110   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_19
   \      0x112   0x2220             MOVS     R2,#+32
   \      0x114   0xE028             B.N      ??psa_mac_finalize_alg_and_key_validation_18
   \                     ??psa_mac_finalize_alg_and_key_validation_19: (+1)
   \      0x116   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x11A   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x11E   0x.... 0x....      LDR.W    R0,??DataTable19
   \      0x122   0x4282             CMP      R2,R0
   \      0x124   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_20
   \      0x126   0x221C             MOVS     R2,#+28
   \      0x128   0xE01E             B.N      ??psa_mac_finalize_alg_and_key_validation_21
   \                     ??psa_mac_finalize_alg_and_key_validation_20: (+1)
   \      0x12A   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x12E   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x132   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \      0x136   0x4282             CMP      R2,R0
   \      0x138   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_22
   \      0x13A   0x2220             MOVS     R2,#+32
   \      0x13C   0xE014             B.N      ??psa_mac_finalize_alg_and_key_validation_21
   \                     ??psa_mac_finalize_alg_and_key_validation_22: (+1)
   \      0x13E   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x142   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x146   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \      0x14A   0x4282             CMP      R2,R0
   \      0x14C   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_23
   \      0x14E   0x2230             MOVS     R2,#+48
   \      0x150   0xE00A             B.N      ??psa_mac_finalize_alg_and_key_validation_24
   \                     ??psa_mac_finalize_alg_and_key_validation_23: (+1)
   \      0x152   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x156   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x15A   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \      0x15E   0x4282             CMP      R2,R0
   \      0x160   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_25
   \      0x162   0x2240             MOVS     R2,#+64
   \      0x164   0xE000             B.N      ??psa_mac_finalize_alg_and_key_validation_24
   \                     ??psa_mac_finalize_alg_and_key_validation_25: (+1)
   \      0x166   0x2200             MOVS     R2,#+0
   \                     ??psa_mac_finalize_alg_and_key_validation_24: (+1)
   \                     ??psa_mac_finalize_alg_and_key_validation_21: (+1)
   \                     ??psa_mac_finalize_alg_and_key_validation_18: (+1)
   \                     ??psa_mac_finalize_alg_and_key_validation_15: (+1)
   \                     ??psa_mac_finalize_alg_and_key_validation_12: (+1)
   \                     ??psa_mac_finalize_alg_and_key_validation_9: (+1)
   \      0x168   0xE015             B.N      ??psa_mac_finalize_alg_and_key_validation_7
   \                     ??psa_mac_finalize_alg_and_key_validation_5: (+1)
   \      0x16A   0x4022             ANDS     R2,R2,R4
   \      0x16C   0xF1B2 0x7F70      CMP      R2,#+62914560
   \      0x170   0xD110             BNE.N    ??psa_mac_finalize_alg_and_key_validation_26
   \      0x172   0x0038             MOVS     R0,R7
   \      0x174   0xB280             UXTH     R0,R0
   \      0x176   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \      0x17A   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x17E   0xD107             BNE.N    ??psa_mac_finalize_alg_and_key_validation_27
   \      0x180   0x2201             MOVS     R2,#+1
   \      0x182   0x0038             MOVS     R0,R7
   \      0x184   0xB280             UXTH     R0,R0
   \      0x186   0x0A00             LSRS     R0,R0,#+8
   \      0x188   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x18C   0x4082             LSLS     R2,R2,R0
   \      0x18E   0xE002             B.N      ??psa_mac_finalize_alg_and_key_validation_28
   \                     ??psa_mac_finalize_alg_and_key_validation_27: (+1)
   \      0x190   0x2200             MOVS     R2,#+0
   \      0x192   0xE000             B.N      ??psa_mac_finalize_alg_and_key_validation_28
   \                     ??psa_mac_finalize_alg_and_key_validation_26: (+1)
   \      0x194   0x2200             MOVS     R2,#+0
   \                     ??psa_mac_finalize_alg_and_key_validation_28: (+1)
   \                     ??psa_mac_finalize_alg_and_key_validation_7: (+1)
   \                     ??psa_mac_finalize_alg_and_key_validation_4: (+1)
   \      0x196   0x7032             STRB     R2,[R6, #+0]
   2604          
   2605              if (*mac_size < 4) {
   \      0x198   0x7830             LDRB     R0,[R6, #+0]
   \      0x19A   0x2804             CMP      R0,#+4
   \      0x19C   0xDA02             BGE.N    ??psa_mac_finalize_alg_and_key_validation_29
   2606                  /* A very short MAC is too short for security since it can be
   2607                   * brute-forced. Ancient protocols with 32-bit MACs do exist,
   2608                   * so we make this our minimum, even though 32 bits is still
   2609                   * too small for security. */
   2610                  return PSA_ERROR_NOT_SUPPORTED;
   \      0x19E   0xF07F 0x0085      MVNS     R0,#+133
   \      0x1A2   0xE0AE             B.N      ??psa_mac_finalize_alg_and_key_validation_1
   2611              }
   2612          
   2613              if (*mac_size > PSA_MAC_LENGTH(key_type, key_bits,
   2614                                             PSA_ALG_FULL_LENGTH_MAC(alg))) {
   \                     ??psa_mac_finalize_alg_and_key_validation_29: (+1)
   \      0x1A4   0x.... 0x....      LDR.W    R2,??DataTable17
   \      0x1A8   0xEA12 0x0004      ANDS     R0,R2,R4
   \      0x1AC   0xF1B0 0x7F60      CMP      R0,#+58720256
   \      0x1B0   0xF040 0x8084      BNE.W    ??psa_mac_finalize_alg_and_key_validation_30
   \      0x1B4   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x1B8   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x1BC   0x.... 0x....      LDR.W    R0,??DataTable18
   \      0x1C0   0x4282             CMP      R2,R0
   \      0x1C2   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_31
   \      0x1C4   0x2010             MOVS     R0,#+16
   \      0x1C6   0xE08F             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_31: (+1)
   \      0x1C8   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x1CC   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x1D0   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \      0x1D4   0x4282             CMP      R2,R0
   \      0x1D6   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_33
   \      0x1D8   0x2014             MOVS     R0,#+20
   \      0x1DA   0xE085             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_33: (+1)
   \      0x1DC   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x1E0   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x1E4   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \      0x1E8   0x4282             CMP      R2,R0
   \      0x1EA   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_34
   \      0x1EC   0x2014             MOVS     R0,#+20
   \      0x1EE   0xE07B             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_34: (+1)
   \      0x1F0   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x1F4   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x1F8   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \      0x1FC   0x4282             CMP      R2,R0
   \      0x1FE   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_35
   \      0x200   0x201C             MOVS     R0,#+28
   \      0x202   0xE071             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_35: (+1)
   \      0x204   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x208   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x20C   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \      0x210   0x4282             CMP      R2,R0
   \      0x212   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_36
   \      0x214   0x2020             MOVS     R0,#+32
   \      0x216   0xE067             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_36: (+1)
   \      0x218   0xF004 0x00FF      AND      R0,R4,#0xFF
   \      0x21C   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x220   0x.... 0x....      LDR.W    R2,??DataTable18_5
   \      0x224   0x4290             CMP      R0,R2
   \      0x226   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_37
   \      0x228   0x2030             MOVS     R0,#+48
   \      0x22A   0xE05D             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_37: (+1)
   \      0x22C   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x230   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x234   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \      0x238   0x4282             CMP      R2,R0
   \      0x23A   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_38
   \      0x23C   0x2040             MOVS     R0,#+64
   \      0x23E   0xE053             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_38: (+1)
   \      0x240   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x244   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x248   0x.... 0x....      LDR.W    R0,??DataTable18_7
   \      0x24C   0x4282             CMP      R2,R0
   \      0x24E   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_39
   \      0x250   0x201C             MOVS     R0,#+28
   \      0x252   0xE049             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_39: (+1)
   \      0x254   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x258   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x25C   0x.... 0x....      LDR.W    R0,??DataTable18_8
   \      0x260   0x4282             CMP      R2,R0
   \      0x262   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_40
   \      0x264   0x2020             MOVS     R0,#+32
   \      0x266   0xE03F             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_40: (+1)
   \      0x268   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x26C   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x270   0x.... 0x....      LDR.W    R0,??DataTable19
   \      0x274   0x4282             CMP      R2,R0
   \      0x276   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_41
   \      0x278   0x201C             MOVS     R0,#+28
   \      0x27A   0xE035             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_41: (+1)
   \      0x27C   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x280   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x284   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \      0x288   0x4282             CMP      R2,R0
   \      0x28A   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_42
   \      0x28C   0x2020             MOVS     R0,#+32
   \      0x28E   0xE02B             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_42: (+1)
   \      0x290   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x294   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x298   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \      0x29C   0x4282             CMP      R2,R0
   \      0x29E   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_43
   \      0x2A0   0x2030             MOVS     R0,#+48
   \      0x2A2   0xE021             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_43: (+1)
   \      0x2A4   0xF004 0x02FF      AND      R2,R4,#0xFF
   \      0x2A8   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \      0x2AC   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \      0x2B0   0x4282             CMP      R2,R0
   \      0x2B2   0xD101             BNE.N    ??psa_mac_finalize_alg_and_key_validation_44
   \      0x2B4   0x2040             MOVS     R0,#+64
   \      0x2B6   0xE017             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_44: (+1)
   \      0x2B8   0x2000             MOVS     R0,#+0
   \      0x2BA   0xE015             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_30: (+1)
   \      0x2BC   0x4022             ANDS     R2,R2,R4
   \      0x2BE   0xF1B2 0x7F70      CMP      R2,#+62914560
   \      0x2C2   0xD110             BNE.N    ??psa_mac_finalize_alg_and_key_validation_45
   \      0x2C4   0x0038             MOVS     R0,R7
   \      0x2C6   0xB280             UXTH     R0,R0
   \      0x2C8   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \      0x2CC   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x2D0   0xD107             BNE.N    ??psa_mac_finalize_alg_and_key_validation_46
   \      0x2D2   0x2001             MOVS     R0,#+1
   \      0x2D4   0x003A             MOVS     R2,R7
   \      0x2D6   0xB292             UXTH     R2,R2
   \      0x2D8   0x0A12             LSRS     R2,R2,#+8
   \      0x2DA   0xF012 0x0207      ANDS     R2,R2,#0x7
   \      0x2DE   0x4090             LSLS     R0,R0,R2
   \      0x2E0   0xE002             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_46: (+1)
   \      0x2E2   0x2000             MOVS     R0,#+0
   \      0x2E4   0xE000             B.N      ??psa_mac_finalize_alg_and_key_validation_32
   \                     ??psa_mac_finalize_alg_and_key_validation_45: (+1)
   \      0x2E6   0x2000             MOVS     R0,#+0
   \                     ??psa_mac_finalize_alg_and_key_validation_32: (+1)
   \      0x2E8   0x7832             LDRB     R2,[R6, #+0]
   \      0x2EA   0x4290             CMP      R0,R2
   \      0x2EC   0xD202             BCS.N    ??psa_mac_finalize_alg_and_key_validation_47
   2615                  /* It's impossible to "truncate" to a larger length than the full length
   2616                   * of the algorithm. */
   2617                  return PSA_ERROR_INVALID_ARGUMENT;
   \      0x2EE   0xF07F 0x0086      MVNS     R0,#+134
   \      0x2F2   0xE006             B.N      ??psa_mac_finalize_alg_and_key_validation_1
   2618              }
   2619          
   2620              if (*mac_size > PSA_MAC_MAX_SIZE) {
   \                     ??psa_mac_finalize_alg_and_key_validation_47: (+1)
   \      0x2F4   0x7830             LDRB     R0,[R6, #+0]
   \      0x2F6   0x2821             CMP      R0,#+33
   \      0x2F8   0xD302             BCC.N    ??psa_mac_finalize_alg_and_key_validation_48
   2621                  /* PSA_MAC_LENGTH returns the correct length even for a MAC algorithm
   2622                   * that is disabled in the compile-time configuration. The result can
   2623                   * therefore be larger than PSA_MAC_MAX_SIZE, which does take the
   2624                   * configuration into account. In this case, force a return of
   2625                   * PSA_ERROR_NOT_SUPPORTED here. Otherwise psa_mac_verify(), or
   2626                   * psa_mac_compute(mac_size=PSA_MAC_MAX_SIZE), would return
   2627                   * PSA_ERROR_BUFFER_TOO_SMALL for an unsupported algorithm whose MAC size
   2628                   * is larger than PSA_MAC_MAX_SIZE, which is misleading and which breaks
   2629                   * systematically generated tests. */
   2630                  return PSA_ERROR_NOT_SUPPORTED;
   \      0x2FA   0xF07F 0x0085      MVNS     R0,#+133
   \      0x2FE   0xE000             B.N      ??psa_mac_finalize_alg_and_key_validation_1
   2631              }
   2632          
   2633              return PSA_SUCCESS;
   \                     ??psa_mac_finalize_alg_and_key_validation_48: (+1)
   \      0x300   0x2000             MOVS     R0,#+0
   \                     ??psa_mac_finalize_alg_and_key_validation_1: (+1)
   \      0x302   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2634          }
   2635          

   \                                 In section .text, align 2, keep-with-next
   2636          static psa_status_t psa_mac_setup(psa_mac_operation_t *operation,
   2637                                            mbedtls_svc_key_id_t key,
   2638                                            psa_algorithm_t alg,
   2639                                            int is_sign)
   2640          {
   \                     psa_mac_setup: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x001D             MOVS     R5,R3
   2641              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0x46C2             MOV      R10,R8
   2642              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   2643              psa_key_slot_t *slot = NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9001             STR      R0,[SP, #+4]
   2644              psa_key_attributes_t attributes;
   2645          
   2646              /* A context must be freshly initialized before it can be set up. */
   2647              if (operation->id != 0) {
   \       0x18   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD002             BEQ.N    ??psa_mac_setup_0
   2648                  status = PSA_ERROR_BAD_STATE;
   \       0x20   0xF07F 0x0488      MVNS     R4,#+136
   2649                  goto exit;
   \       0x24   0xE042             B.N      ??psa_mac_setup_1
   2650              }
   2651          
   2652              status = psa_get_and_lock_key_slot_with_policy(
   2653                  key,
   2654                  &slot,
   2655                  is_sign ? PSA_KEY_USAGE_SIGN_MESSAGE : PSA_KEY_USAGE_VERIFY_MESSAGE,
   2656                  alg);
   \                     ??psa_mac_setup_0: (+1)
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xD002             BEQ.N    ??psa_mac_setup_2
   \       0x2A   0xF44F 0x6280      MOV      R2,#+1024
   \       0x2E   0xE001             B.N      ??psa_mac_setup_3
   \                     ??psa_mac_setup_2: (+1)
   \       0x30   0xF44F 0x6200      MOV      R2,#+2048
   \                     ??psa_mac_setup_3: (+1)
   \       0x34   0x003B             MOVS     R3,R7
   \       0x36   0xA901             ADD      R1,SP,#+4
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x3E   0x0004             MOVS     R4,R0
   2657              if (status != PSA_SUCCESS) {
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD133             BNE.N    ??psa_mac_setup_1
   2658                  goto exit;
   2659              }
   2660          
   2661              attributes = (psa_key_attributes_t) {
   2662                  .core = slot->attr
   2663              };
   \                     ??psa_mac_setup_4: (+1)
   \       0x44   0xA80B             ADD      R0,SP,#+44
   \       0x46   0x2124             MOVS     R1,#+36
   \       0x48   0x.... 0x....      BL       __aeabi_memclr4
   \       0x4C   0xA80B             ADD      R0,SP,#+44
   \       0x4E   0x9901             LDR      R1,[SP, #+4]
   \       0x50   0x221C             MOVS     R2,#+28
   \       0x52   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x56   0xA802             ADD      R0,SP,#+8
   \       0x58   0xA90B             ADD      R1,SP,#+44
   \       0x5A   0x2224             MOVS     R2,#+36
   \       0x5C   0x.... 0x....      BL       __aeabi_memcpy4
   2664          
   2665              status = psa_mac_finalize_alg_and_key_validation(alg, &attributes,
   2666                                                               &operation->mac_size);
   \       0x60   0xF119 0x0204      ADDS     R2,R9,#+4
   \       0x64   0xA902             ADD      R1,SP,#+8
   \       0x66   0x0038             MOVS     R0,R7
   \       0x68   0x.... 0x....      BL       psa_mac_finalize_alg_and_key_validation
   \       0x6C   0x0004             MOVS     R4,R0
   2667              if (status != PSA_SUCCESS) {
   \       0x6E   0x2C00             CMP      R4,#+0
   \       0x70   0xD11C             BNE.N    ??psa_mac_setup_1
   2668                  goto exit;
   2669              }
   2670          
   2671              operation->is_sign = is_sign;
   \                     ??psa_mac_setup_5: (+1)
   \       0x72   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x76   0xF365 0x2008      BFI      R0,R5,#+8,#+1
   \       0x7A   0xF8C9 0x0004      STR      R0,[R9, #+4]
   2672              /* Dispatch the MAC setup call with validated input */
   2673              if (is_sign) {
   \       0x7E   0x2D00             CMP      R5,#+0
   \       0x80   0xD00A             BEQ.N    ??psa_mac_setup_6
   2674                  status = psa_driver_wrapper_mac_sign_setup(operation,
   2675                                                             &attributes,
   2676                                                             slot->key.data,
   2677                                                             slot->key.bytes,
   2678                                                             alg);
   \       0x82   0x9700             STR      R7,[SP, #+0]
   \       0x84   0x9801             LDR      R0,[SP, #+4]
   \       0x86   0x6A83             LDR      R3,[R0, #+40]
   \       0x88   0x9801             LDR      R0,[SP, #+4]
   \       0x8A   0x6A42             LDR      R2,[R0, #+36]
   \       0x8C   0xA902             ADD      R1,SP,#+8
   \       0x8E   0x4648             MOV      R0,R9
   \       0x90   0x.... 0x....      BL       psa_driver_wrapper_mac_sign_setup
   \       0x94   0x0004             MOVS     R4,R0
   \       0x96   0xE009             B.N      ??psa_mac_setup_1
   2679              } else {
   2680                  status = psa_driver_wrapper_mac_verify_setup(operation,
   2681                                                               &attributes,
   2682                                                               slot->key.data,
   2683                                                               slot->key.bytes,
   2684                                                               alg);
   \                     ??psa_mac_setup_6: (+1)
   \       0x98   0x9700             STR      R7,[SP, #+0]
   \       0x9A   0x9801             LDR      R0,[SP, #+4]
   \       0x9C   0x6A83             LDR      R3,[R0, #+40]
   \       0x9E   0x9801             LDR      R0,[SP, #+4]
   \       0xA0   0x6A42             LDR      R2,[R0, #+36]
   \       0xA2   0xA902             ADD      R1,SP,#+8
   \       0xA4   0x4648             MOV      R0,R9
   \       0xA6   0x.... 0x....      BL       psa_driver_wrapper_mac_verify_setup
   \       0xAA   0x0004             MOVS     R4,R0
   2685              }
   2686          
   2687          exit:
   2688              if (status != PSA_SUCCESS) {
   \                     ??psa_mac_setup_1: (+1)
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD002             BEQ.N    ??psa_mac_setup_7
   2689                  psa_mac_abort(operation);
   \       0xB0   0x4648             MOV      R0,R9
   \       0xB2   0x.... 0x....      BL       psa_mac_abort
   2690              }
   2691          
   2692              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_mac_setup_7: (+1)
   \       0xB6   0x9801             LDR      R0,[SP, #+4]
   \       0xB8   0x.... 0x....      BL       psa_unlock_key_slot
   2693          
   2694              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0xBC   0x2C00             CMP      R4,#+0
   \       0xBE   0xD000             BEQ.N    ??psa_mac_setup_8
   \                     ??psa_mac_setup_9: (+1)
   \       0xC0   0x0020             MOVS     R0,R4
   \                     ??psa_mac_setup_8: (+1)
   \       0xC2   0xB014             ADD      SP,SP,#+80
   \       0xC4   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2695          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   2696          

   \                                 In section .text, align 2, keep-with-next
   2697          psa_status_t psa_mac_sign_setup(psa_mac_operation_t *operation,
   2698                                          mbedtls_svc_key_id_t key,
   2699                                          psa_algorithm_t alg)
   2700          {
   \                     psa_mac_sign_setup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   2701              return psa_mac_setup(operation, key, alg, 1);
   \        0x8   0x2301             MOVS     R3,#+1
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       psa_mac_setup
   \       0x14   0xBD70             POP      {R4-R6,PC}
   2702          }
   2703          

   \                                 In section .text, align 2, keep-with-next
   2704          psa_status_t psa_mac_verify_setup(psa_mac_operation_t *operation,
   2705                                            mbedtls_svc_key_id_t key,
   2706                                            psa_algorithm_t alg)
   2707          {
   \                     psa_mac_verify_setup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   2708              return psa_mac_setup(operation, key, alg, 0);
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       psa_mac_setup
   \       0x14   0xBD70             POP      {R4-R6,PC}
   2709          }
   2710          

   \                                 In section .text, align 2, keep-with-next
   2711          psa_status_t psa_mac_update(psa_mac_operation_t *operation,
   2712                                      const uint8_t *input,
   2713                                      size_t input_length)
   2714          {
   \                     psa_mac_update: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   2715              if (operation->id == 0) {
   \        0x8   0x6838             LDR      R0,[R7, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD102             BNE.N    ??psa_mac_update_0
   2716                  return PSA_ERROR_BAD_STATE;
   \        0xE   0xF07F 0x0088      MVNS     R0,#+136
   \       0x12   0xE00F             B.N      ??psa_mac_update_1
   2717              }
   2718          
   2719              /* Don't require hash implementations to behave correctly on a
   2720               * zero-length input, which may have an invalid pointer. */
   2721              if (input_length == 0) {
   \                     ??psa_mac_update_0: (+1)
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD101             BNE.N    ??psa_mac_update_2
   2722                  return PSA_SUCCESS;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE00B             B.N      ??psa_mac_update_1
   2723              }
   2724          
   2725              psa_status_t status = psa_driver_wrapper_mac_update(operation,
   2726                                                                  input, input_length);
   \                     ??psa_mac_update_2: (+1)
   \       0x1C   0x0022             MOVS     R2,R4
   \       0x1E   0x0031             MOVS     R1,R6
   \       0x20   0x0038             MOVS     R0,R7
   \       0x22   0x.... 0x....      BL       psa_driver_wrapper_mac_update
   \       0x26   0x0005             MOVS     R5,R0
   2727              if (status != PSA_SUCCESS) {
   \       0x28   0x2D00             CMP      R5,#+0
   \       0x2A   0xD002             BEQ.N    ??psa_mac_update_3
   2728                  psa_mac_abort(operation);
   \       0x2C   0x0038             MOVS     R0,R7
   \       0x2E   0x.... 0x....      BL       psa_mac_abort
   2729              }
   2730          
   2731              return status;
   \                     ??psa_mac_update_3: (+1)
   \       0x32   0x0028             MOVS     R0,R5
   \                     ??psa_mac_update_1: (+1)
   \       0x34   0xBDF2             POP      {R1,R4-R7,PC}
   2732          }
   2733          

   \                                 In section .text, align 2, keep-with-next
   2734          psa_status_t psa_mac_sign_finish(psa_mac_operation_t *operation,
   2735                                           uint8_t *mac,
   2736                                           size_t mac_size,
   2737                                           size_t *mac_length)
   2738          {
   \                     psa_mac_sign_finish: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   2739              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x0996      MVNS     R9,#+150
   \       0x10   0x46C8             MOV      R8,R9
   2740              psa_status_t abort_status = PSA_ERROR_CORRUPTION_DETECTED;
   2741          
   2742              if (operation->id == 0) {
   \       0x12   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD102             BNE.N    ??psa_mac_sign_finish_0
   2743                  status = PSA_ERROR_BAD_STATE;
   \       0x1A   0xF07F 0x0488      MVNS     R4,#+136
   2744                  goto exit;
   \       0x1E   0xE01E             B.N      ??psa_mac_sign_finish_1
   2745              }
   2746          
   2747              if (!operation->is_sign) {
   \                     ??psa_mac_sign_finish_0: (+1)
   \       0x20   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x24   0xF3C0 0x2000      UBFX     R0,R0,#+8,#+1
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD102             BNE.N    ??psa_mac_sign_finish_2
   2748                  status = PSA_ERROR_BAD_STATE;
   \       0x2C   0xF07F 0x0488      MVNS     R4,#+136
   2749                  goto exit;
   \       0x30   0xE015             B.N      ??psa_mac_sign_finish_1
   2750              }
   2751          
   2752              /* Sanity check. This will guarantee that mac_size != 0 (and so mac != NULL)
   2753               * once all the error checks are done. */
   2754              if (operation->mac_size == 0) {
   \                     ??psa_mac_sign_finish_2: (+1)
   \       0x32   0xF89A 0x0004      LDRB     R0,[R10, #+4]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD102             BNE.N    ??psa_mac_sign_finish_3
   2755                  status = PSA_ERROR_BAD_STATE;
   \       0x3A   0xF07F 0x0488      MVNS     R4,#+136
   2756                  goto exit;
   \       0x3E   0xE00E             B.N      ??psa_mac_sign_finish_1
   2757              }
   2758          
   2759              if (mac_size < operation->mac_size) {
   \                     ??psa_mac_sign_finish_3: (+1)
   \       0x40   0xF89A 0x0004      LDRB     R0,[R10, #+4]
   \       0x44   0x4286             CMP      R6,R0
   \       0x46   0xD202             BCS.N    ??psa_mac_sign_finish_4
   2760                  status = PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x48   0xF07F 0x0489      MVNS     R4,#+137
   2761                  goto exit;
   \       0x4C   0xE007             B.N      ??psa_mac_sign_finish_1
   2762              }
   2763          
   2764              status = psa_driver_wrapper_mac_sign_finish(operation,
   2765                                                          mac, operation->mac_size,
   2766                                                          mac_length);
   \                     ??psa_mac_sign_finish_4: (+1)
   \       0x4E   0x003B             MOVS     R3,R7
   \       0x50   0xF89A 0x2004      LDRB     R2,[R10, #+4]
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x4650             MOV      R0,R10
   \       0x58   0x.... 0x....      BL       psa_driver_wrapper_mac_sign_finish
   \       0x5C   0x0004             MOVS     R4,R0
   2767          
   2768          exit:
   2769              /* In case of success, set the potential excess room in the output buffer
   2770               * to an invalid value, to avoid potentially leaking a longer MAC.
   2771               * In case of error, set the output length and content to a safe default,
   2772               * such that in case the caller misses an error check, the output would be
   2773               * an unachievable MAC.
   2774               */
   2775              if (status != PSA_SUCCESS) {
   \                     ??psa_mac_sign_finish_1: (+1)
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xD003             BEQ.N    ??psa_mac_sign_finish_5
   2776                  *mac_length = mac_size;
   \       0x62   0x603E             STR      R6,[R7, #+0]
   2777                  operation->mac_size = 0;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF88A 0x0004      STRB     R0,[R10, #+4]
   2778              }
   2779          
   2780              psa_wipe_tag_output_buffer(mac, status, mac_size, *mac_length);
   \                     ??psa_mac_sign_finish_5: (+1)
   \       0x6A   0x683B             LDR      R3,[R7, #+0]
   \       0x6C   0x0032             MOVS     R2,R6
   \       0x6E   0x0021             MOVS     R1,R4
   \       0x70   0x0028             MOVS     R0,R5
   \       0x72   0x.... 0x....      BL       psa_wipe_tag_output_buffer
   2781          
   2782              abort_status = psa_mac_abort(operation);
   \       0x76   0x4650             MOV      R0,R10
   \       0x78   0x.... 0x....      BL       psa_mac_abort
   2783          
   2784              return status == PSA_SUCCESS ? abort_status : status;
   \       0x7C   0x2C00             CMP      R4,#+0
   \       0x7E   0xD101             BNE.N    ??psa_mac_sign_finish_6
   \       0x80   0x0004             MOVS     R4,R0
   \       0x82   0xE7FF             B.N      ??psa_mac_sign_finish_7
   \                     ??psa_mac_sign_finish_6: (+1)
   \                     ??psa_mac_sign_finish_7: (+1)
   \       0x84   0x0020             MOVS     R0,R4
   \       0x86   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2785          }
   2786          

   \                                 In section .text, align 2, keep-with-next
   2787          psa_status_t psa_mac_verify_finish(psa_mac_operation_t *operation,
   2788                                             const uint8_t *mac,
   2789                                             size_t mac_length)
   2790          {
   \                     psa_mac_verify_finish: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   2791              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0796      MVNS     R7,#+150
   \        0xE   0x46B9             MOV      R9,R7
   2792              psa_status_t abort_status = PSA_ERROR_CORRUPTION_DETECTED;
   2793          
   2794              if (operation->id == 0) {
   \       0x10   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD102             BNE.N    ??psa_mac_verify_finish_0
   2795                  status = PSA_ERROR_BAD_STATE;
   \       0x18   0xF07F 0x0488      MVNS     R4,#+136
   2796                  goto exit;
   \       0x1C   0xE015             B.N      ??psa_mac_verify_finish_1
   2797              }
   2798          
   2799              if (operation->is_sign) {
   \                     ??psa_mac_verify_finish_0: (+1)
   \       0x1E   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x22   0xF3C0 0x2000      UBFX     R0,R0,#+8,#+1
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ.N    ??psa_mac_verify_finish_2
   2800                  status = PSA_ERROR_BAD_STATE;
   \       0x2A   0xF07F 0x0488      MVNS     R4,#+136
   2801                  goto exit;
   \       0x2E   0xE00C             B.N      ??psa_mac_verify_finish_1
   2802              }
   2803          
   2804              if (operation->mac_size != mac_length) {
   \                     ??psa_mac_verify_finish_2: (+1)
   \       0x30   0xF898 0x0004      LDRB     R0,[R8, #+4]
   \       0x34   0x42B0             CMP      R0,R6
   \       0x36   0xD002             BEQ.N    ??psa_mac_verify_finish_3
   2805                  status = PSA_ERROR_INVALID_SIGNATURE;
   \       0x38   0xF07F 0x0494      MVNS     R4,#+148
   2806                  goto exit;
   \       0x3C   0xE005             B.N      ??psa_mac_verify_finish_1
   2807              }
   2808          
   2809              status = psa_driver_wrapper_mac_verify_finish(operation,
   2810                                                            mac, mac_length);
   \                     ??psa_mac_verify_finish_3: (+1)
   \       0x3E   0x0032             MOVS     R2,R6
   \       0x40   0x0029             MOVS     R1,R5
   \       0x42   0x4640             MOV      R0,R8
   \       0x44   0x.... 0x....      BL       psa_driver_wrapper_mac_verify_finish
   \       0x48   0x0004             MOVS     R4,R0
   2811          
   2812          exit:
   2813              abort_status = psa_mac_abort(operation);
   \                     ??psa_mac_verify_finish_1: (+1)
   \       0x4A   0x4640             MOV      R0,R8
   \       0x4C   0x.... 0x....      BL       psa_mac_abort
   2814          
   2815              return status == PSA_SUCCESS ? abort_status : status;
   \       0x50   0x2C00             CMP      R4,#+0
   \       0x52   0xD101             BNE.N    ??psa_mac_verify_finish_4
   \       0x54   0x0004             MOVS     R4,R0
   \       0x56   0xE7FF             B.N      ??psa_mac_verify_finish_5
   \                     ??psa_mac_verify_finish_4: (+1)
   \                     ??psa_mac_verify_finish_5: (+1)
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2816          }
   2817          

   \                                 In section .text, align 2, keep-with-next
   2818          static psa_status_t psa_mac_compute_internal(mbedtls_svc_key_id_t key,
   2819                                                       psa_algorithm_t alg,
   2820                                                       const uint8_t *input,
   2821                                                       size_t input_length,
   2822                                                       uint8_t *mac,
   2823                                                       size_t mac_size,
   2824                                                       size_t *mac_length,
   2825                                                       int is_sign)
   2826          {
   \                     psa_mac_compute_internal: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB09A             SUB      SP,SP,#+104
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x4693             MOV      R11,R2
   \        0xA   0x469A             MOV      R10,R3
   \        0xC   0x9E24             LDR      R6,[SP, #+144]
   \        0xE   0x9F25             LDR      R7,[SP, #+148]
   \       0x10   0xF8DD 0x8098      LDR      R8,[SP, #+152]
   \       0x14   0x9D27             LDR      R5,[SP, #+156]
   2827              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   2828              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x1C   0x9007             STR      R0,[SP, #+28]
   2829              psa_key_slot_t *slot;
   2830              uint8_t operation_mac_size = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF88D 0x0014      STRB     R0,[SP, #+20]
   2831              psa_key_attributes_t attributes;
   2832          
   2833              status = psa_get_and_lock_key_slot_with_policy(
   2834                  key,
   2835                  &slot,
   2836                  is_sign ? PSA_KEY_USAGE_SIGN_MESSAGE : PSA_KEY_USAGE_VERIFY_MESSAGE,
   2837                  alg);
   \       0x24   0x2D00             CMP      R5,#+0
   \       0x26   0xD002             BEQ.N    ??psa_mac_compute_internal_0
   \       0x28   0xF44F 0x6280      MOV      R2,#+1024
   \       0x2C   0xE001             B.N      ??psa_mac_compute_internal_1
   \                     ??psa_mac_compute_internal_0: (+1)
   \       0x2E   0xF44F 0x6200      MOV      R2,#+2048
   \                     ??psa_mac_compute_internal_1: (+1)
   \       0x32   0x464B             MOV      R3,R9
   \       0x34   0xA906             ADD      R1,SP,#+24
   \       0x36   0x981A             LDR      R0,[SP, #+104]
   \       0x38   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x3C   0x0004             MOVS     R4,R0
   2838              if (status != PSA_SUCCESS) {
   \       0x3E   0x2C00             CMP      R4,#+0
   \       0x40   0xD130             BNE.N    ??psa_mac_compute_internal_2
   2839                  goto exit;
   2840              }
   2841          
   2842              attributes = (psa_key_attributes_t) {
   2843                  .core = slot->attr
   2844              };
   \                     ??psa_mac_compute_internal_3: (+1)
   \       0x42   0xA808             ADD      R0,SP,#+32
   \       0x44   0x2124             MOVS     R1,#+36
   \       0x46   0x.... 0x....      BL       __aeabi_memclr4
   \       0x4A   0xA808             ADD      R0,SP,#+32
   \       0x4C   0x9906             LDR      R1,[SP, #+24]
   \       0x4E   0x221C             MOVS     R2,#+28
   \       0x50   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x54   0xA811             ADD      R0,SP,#+68
   \       0x56   0xA908             ADD      R1,SP,#+32
   \       0x58   0x2224             MOVS     R2,#+36
   \       0x5A   0x.... 0x....      BL       __aeabi_memcpy4
   2845          
   2846              status = psa_mac_finalize_alg_and_key_validation(alg, &attributes,
   2847                                                               &operation_mac_size);
   \       0x5E   0xAA05             ADD      R2,SP,#+20
   \       0x60   0xA911             ADD      R1,SP,#+68
   \       0x62   0x4648             MOV      R0,R9
   \       0x64   0x.... 0x....      BL       psa_mac_finalize_alg_and_key_validation
   \       0x68   0x0004             MOVS     R4,R0
   2848              if (status != PSA_SUCCESS) {
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD11A             BNE.N    ??psa_mac_compute_internal_2
   2849                  goto exit;
   2850              }
   2851          
   2852              if (mac_size < operation_mac_size) {
   \                     ??psa_mac_compute_internal_4: (+1)
   \       0x6E   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \       0x72   0x4287             CMP      R7,R0
   \       0x74   0xD203             BCS.N    ??psa_mac_compute_internal_5
   2853                  status = PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x76   0xF07F 0x0089      MVNS     R0,#+137
   \       0x7A   0x0004             MOVS     R4,R0
   2854                  goto exit;
   \       0x7C   0xE012             B.N      ??psa_mac_compute_internal_2
   2855              }
   2856          
   2857              status = psa_driver_wrapper_mac_compute(
   2858                  &attributes,
   2859                  slot->key.data, slot->key.bytes,
   2860                  alg,
   2861                  input, input_length,
   2862                  mac, operation_mac_size, mac_length);
   \                     ??psa_mac_compute_internal_5: (+1)
   \       0x7E   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0x82   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \       0x86   0x9003             STR      R0,[SP, #+12]
   \       0x88   0x9602             STR      R6,[SP, #+8]
   \       0x8A   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0x8E   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \       0x92   0x464B             MOV      R3,R9
   \       0x94   0x9806             LDR      R0,[SP, #+24]
   \       0x96   0x6A82             LDR      R2,[R0, #+40]
   \       0x98   0x9806             LDR      R0,[SP, #+24]
   \       0x9A   0x6A41             LDR      R1,[R0, #+36]
   \       0x9C   0xA811             ADD      R0,SP,#+68
   \       0x9E   0x.... 0x....      BL       psa_driver_wrapper_mac_compute
   \       0xA2   0x0004             MOVS     R4,R0
   2863          
   2864          exit:
   2865              /* In case of success, set the potential excess room in the output buffer
   2866               * to an invalid value, to avoid potentially leaking a longer MAC.
   2867               * In case of error, set the output length and content to a safe default,
   2868               * such that in case the caller misses an error check, the output would be
   2869               * an unachievable MAC.
   2870               */
   2871              if (status != PSA_SUCCESS) {
   \                     ??psa_mac_compute_internal_2: (+1)
   \       0xA4   0x2C00             CMP      R4,#+0
   \       0xA6   0xD004             BEQ.N    ??psa_mac_compute_internal_6
   2872                  *mac_length = mac_size;
   \       0xA8   0xF8C8 0x7000      STR      R7,[R8, #+0]
   2873                  operation_mac_size = 0;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xF88D 0x0014      STRB     R0,[SP, #+20]
   2874              }
   2875          
   2876              psa_wipe_tag_output_buffer(mac, status, mac_size, *mac_length);
   \                     ??psa_mac_compute_internal_6: (+1)
   \       0xB2   0xF8D8 0x3000      LDR      R3,[R8, #+0]
   \       0xB6   0x003A             MOVS     R2,R7
   \       0xB8   0x0021             MOVS     R1,R4
   \       0xBA   0x0030             MOVS     R0,R6
   \       0xBC   0x.... 0x....      BL       psa_wipe_tag_output_buffer
   2877          
   2878              unlock_status = psa_unlock_key_slot(slot);
   \       0xC0   0x9806             LDR      R0,[SP, #+24]
   \       0xC2   0x.... 0x....      BL       psa_unlock_key_slot
   2879          
   2880              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0xC6   0x2C00             CMP      R4,#+0
   \       0xC8   0xD000             BEQ.N    ??psa_mac_compute_internal_7
   \                     ??psa_mac_compute_internal_8: (+1)
   \       0xCA   0x0020             MOVS     R0,R4
   \                     ??psa_mac_compute_internal_7: (+1)
   \       0xCC   0xB01B             ADD      SP,SP,#+108
   \       0xCE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2881          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   2882          

   \                                 In section .text, align 2, keep-with-next
   2883          psa_status_t psa_mac_compute(mbedtls_svc_key_id_t key,
   2884                                       psa_algorithm_t alg,
   2885                                       const uint8_t *input,
   2886                                       size_t input_length,
   2887                                       uint8_t *mac,
   2888                                       size_t mac_size,
   2889                                       size_t *mac_length)
   2890          {
   \                     psa_mac_compute: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   2891              return psa_mac_compute_internal(key, alg,
   2892                                              input, input_length,
   2893                                              mac, mac_size, mac_length, 1);
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x9003             STR      R0,[SP, #+12]
   \       0x10   0x980C             LDR      R0,[SP, #+48]
   \       0x12   0x9002             STR      R0,[SP, #+8]
   \       0x14   0x980B             LDR      R0,[SP, #+44]
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x980A             LDR      R0,[SP, #+40]
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x003B             MOVS     R3,R7
   \       0x1E   0x0032             MOVS     R2,R6
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       psa_mac_compute_internal
   \       0x28   0xB005             ADD      SP,SP,#+20
   \       0x2A   0xBDF0             POP      {R4-R7,PC}
   2894          }
   2895          

   \                                 In section .text, align 2, keep-with-next
   2896          psa_status_t psa_mac_verify(mbedtls_svc_key_id_t key,
   2897                                      psa_algorithm_t alg,
   2898                                      const uint8_t *input,
   2899                                      size_t input_length,
   2900                                      const uint8_t *mac,
   2901                                      size_t mac_length)
   2902          {
   \                     psa_mac_verify: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0xF8DD 0x8058      LDR      R8,[SP, #+88]
   \       0x12   0xF8DD 0x905C      LDR      R9,[SP, #+92]
   2903              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x0A96      MVNS     R10,#+150
   2904              uint8_t actual_mac[PSA_MAC_MAX_SIZE];
   2905              size_t actual_mac_length;
   2906          
   2907              status = psa_mac_compute_internal(key, alg,
   2908                                                input, input_length,
   2909                                                actual_mac, sizeof(actual_mac),
   2910                                                &actual_mac_length, 0);
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9003             STR      R0,[SP, #+12]
   \       0x1E   0xA804             ADD      R0,SP,#+16
   \       0x20   0x9002             STR      R0,[SP, #+8]
   \       0x22   0x2020             MOVS     R0,#+32
   \       0x24   0x9001             STR      R0,[SP, #+4]
   \       0x26   0xA805             ADD      R0,SP,#+20
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0x003B             MOVS     R3,R7
   \       0x2C   0x0032             MOVS     R2,R6
   \       0x2E   0x0029             MOVS     R1,R5
   \       0x30   0x4658             MOV      R0,R11
   \       0x32   0x.... 0x....      BL       psa_mac_compute_internal
   \       0x36   0x0004             MOVS     R4,R0
   2911              if (status != PSA_SUCCESS) {
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD110             BNE.N    ??psa_mac_verify_0
   2912                  goto exit;
   2913              }
   2914          
   2915              if (mac_length != actual_mac_length) {
   \                     ??psa_mac_verify_1: (+1)
   \       0x3C   0x9804             LDR      R0,[SP, #+16]
   \       0x3E   0x4581             CMP      R9,R0
   \       0x40   0xD003             BEQ.N    ??psa_mac_verify_2
   2916                  status = PSA_ERROR_INVALID_SIGNATURE;
   \       0x42   0xF07F 0x0094      MVNS     R0,#+148
   \       0x46   0x0004             MOVS     R4,R0
   2917                  goto exit;
   \       0x48   0xE009             B.N      ??psa_mac_verify_0
   2918              }
   2919              if (mbedtls_ct_memcmp(mac, actual_mac, actual_mac_length) != 0) {
   \                     ??psa_mac_verify_2: (+1)
   \       0x4A   0x9A04             LDR      R2,[SP, #+16]
   \       0x4C   0xA905             ADD      R1,SP,#+20
   \       0x4E   0x4640             MOV      R0,R8
   \       0x50   0x.... 0x....      BL       mbedtls_ct_memcmp
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD002             BEQ.N    ??psa_mac_verify_0
   2920                  status = PSA_ERROR_INVALID_SIGNATURE;
   \       0x58   0xF07F 0x0094      MVNS     R0,#+148
   \       0x5C   0x0004             MOVS     R4,R0
   2921                  goto exit;
   2922              }
   2923          
   2924          exit:
   2925              mbedtls_platform_zeroize(actual_mac, sizeof(actual_mac));
   \                     ??psa_mac_verify_0: (+1)
   \       0x5E   0x2120             MOVS     R1,#+32
   \       0x60   0xA805             ADD      R0,SP,#+20
   \       0x62   0x.... 0x....      BL       mbedtls_platform_zeroize
   2926          
   2927              return status;
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0xB00D             ADD      SP,SP,#+52
   \       0x6A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2928          }
   2929          
   2930          /****************************************************************/
   2931          /* Asymmetric cryptography */
   2932          /****************************************************************/
   2933          

   \                                 In section .text, align 2, keep-with-next
   2934          static psa_status_t psa_sign_verify_check_alg(int input_is_message,
   2935                                                        psa_algorithm_t alg)
   2936          {
   \                     psa_sign_verify_check_alg: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
   2937              if (input_is_message) {
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD07B             BEQ.N    ??psa_sign_verify_check_alg_0
   2938                  if (!PSA_ALG_IS_SIGN_MESSAGE(alg)) {
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable25
   \        0xC   0x0A0B             LSRS     R3,R1,#+8
   \        0xE   0x021B             LSLS     R3,R3,#+8
   \       0x10   0x4283             CMP      R3,R0
   \       0x12   0xD023             BEQ.N    ??psa_sign_verify_check_alg_1
   \       0x14   0x0A0C             LSRS     R4,R1,#+8
   \       0x16   0x0224             LSLS     R4,R4,#+8
   \       0x18   0x.... 0x....      LDR.W    R3,??DataTable25_1
   \       0x1C   0x429C             CMP      R4,R3
   \       0x1E   0xD01D             BEQ.N    ??psa_sign_verify_check_alg_1
   \       0x20   0x0A0C             LSRS     R4,R1,#+8
   \       0x22   0x0224             LSLS     R4,R4,#+8
   \       0x24   0x.... 0x....      LDR.W    R3,??DataTable25_2
   \       0x28   0x429C             CMP      R4,R3
   \       0x2A   0xD017             BEQ.N    ??psa_sign_verify_check_alg_1
   \       0x2C   0x0A4B             LSRS     R3,R1,#+9
   \       0x2E   0x025B             LSLS     R3,R3,#+9
   \       0x30   0xF1B3 0x2F06      CMP      R3,#+100664832
   \       0x34   0xD012             BEQ.N    ??psa_sign_verify_check_alg_1
   \       0x36   0x0A0C             LSRS     R4,R1,#+8
   \       0x38   0x0224             LSLS     R4,R4,#+8
   \       0x3A   0x.... 0x....      LDR.W    R3,??DataTable25_3
   \       0x3E   0x429C             CMP      R4,R3
   \       0x40   0xD00C             BEQ.N    ??psa_sign_verify_check_alg_1
   \       0x42   0x0A4C             LSRS     R4,R1,#+9
   \       0x44   0x0264             LSLS     R4,R4,#+9
   \       0x46   0x.... 0x....      LDR.W    R3,??DataTable25_4
   \       0x4A   0x429C             CMP      R4,R3
   \       0x4C   0xD006             BEQ.N    ??psa_sign_verify_check_alg_1
   \       0x4E   0x.... 0x....      LDR.W    R3,??DataTable25_5
   \       0x52   0x4299             CMP      R1,R3
   \       0x54   0xD002             BEQ.N    ??psa_sign_verify_check_alg_1
   2939                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x56   0xF07F 0x0086      MVNS     R0,#+134
   \       0x5A   0xE078             B.N      ??psa_sign_verify_check_alg_2
   2940                  }
   2941          
   2942                  if (PSA_ALG_IS_SIGN_HASH(alg)) {
   \                     ??psa_sign_verify_check_alg_1: (+1)
   \       0x5C   0x0A0B             LSRS     R3,R1,#+8
   \       0x5E   0x021B             LSLS     R3,R3,#+8
   \       0x60   0x4283             CMP      R3,R0
   \       0x62   0xD01C             BEQ.N    ??psa_sign_verify_check_alg_3
   \       0x64   0x0A0C             LSRS     R4,R1,#+8
   \       0x66   0x0224             LSLS     R4,R4,#+8
   \       0x68   0x.... 0x....      LDR.W    R3,??DataTable25_1
   \       0x6C   0x429C             CMP      R4,R3
   \       0x6E   0xD016             BEQ.N    ??psa_sign_verify_check_alg_3
   \       0x70   0x0A0C             LSRS     R4,R1,#+8
   \       0x72   0x0224             LSLS     R4,R4,#+8
   \       0x74   0x.... 0x....      LDR.W    R3,??DataTable25_2
   \       0x78   0x429C             CMP      R4,R3
   \       0x7A   0xD010             BEQ.N    ??psa_sign_verify_check_alg_3
   \       0x7C   0x0A4B             LSRS     R3,R1,#+9
   \       0x7E   0x025B             LSLS     R3,R3,#+9
   \       0x80   0xF1B3 0x2F06      CMP      R3,#+100664832
   \       0x84   0xD00B             BEQ.N    ??psa_sign_verify_check_alg_3
   \       0x86   0x0A0C             LSRS     R4,R1,#+8
   \       0x88   0x0224             LSLS     R4,R4,#+8
   \       0x8A   0x.... 0x....      LDR.W    R3,??DataTable25_3
   \       0x8E   0x429C             CMP      R4,R3
   \       0x90   0xD005             BEQ.N    ??psa_sign_verify_check_alg_3
   \       0x92   0x0A4C             LSRS     R4,R1,#+9
   \       0x94   0x0264             LSLS     R4,R4,#+9
   \       0x96   0x.... 0x....      LDR.W    R3,??DataTable25_4
   \       0x9A   0x429C             CMP      R4,R3
   \       0x9C   0xD156             BNE.N    ??psa_sign_verify_check_alg_4
   2943                      if (!PSA_ALG_IS_HASH(PSA_ALG_SIGN_GET_HASH(alg))) {
   \                     ??psa_sign_verify_check_alg_3: (+1)
   \       0x9E   0x0A0B             LSRS     R3,R1,#+8
   \       0xA0   0x021B             LSLS     R3,R3,#+8
   \       0xA2   0x4283             CMP      R3,R0
   \       0xA4   0xD01C             BEQ.N    ??psa_sign_verify_check_alg_5
   \       0xA6   0x0A0B             LSRS     R3,R1,#+8
   \       0xA8   0x021B             LSLS     R3,R3,#+8
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \       0xAE   0x4283             CMP      R3,R0
   \       0xB0   0xD016             BEQ.N    ??psa_sign_verify_check_alg_5
   \       0xB2   0x0A0B             LSRS     R3,R1,#+8
   \       0xB4   0x021B             LSLS     R3,R3,#+8
   \       0xB6   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \       0xBA   0x4283             CMP      R3,R0
   \       0xBC   0xD010             BEQ.N    ??psa_sign_verify_check_alg_5
   \       0xBE   0x0A48             LSRS     R0,R1,#+9
   \       0xC0   0x0240             LSLS     R0,R0,#+9
   \       0xC2   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0xC6   0xD00B             BEQ.N    ??psa_sign_verify_check_alg_5
   \       0xC8   0x0A0B             LSRS     R3,R1,#+8
   \       0xCA   0x021B             LSLS     R3,R3,#+8
   \       0xCC   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \       0xD0   0x4283             CMP      R3,R0
   \       0xD2   0xD005             BEQ.N    ??psa_sign_verify_check_alg_5
   \       0xD4   0x0A4B             LSRS     R3,R1,#+9
   \       0xD6   0x025B             LSLS     R3,R3,#+9
   \       0xD8   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0xDC   0x4283             CMP      R3,R0
   \       0xDE   0xD106             BNE.N    ??psa_sign_verify_check_alg_6
   \                     ??psa_sign_verify_check_alg_5: (+1)
   \       0xE0   0x0608             LSLS     R0,R1,#+24
   \       0xE2   0xD004             BEQ.N    ??psa_sign_verify_check_alg_6
   \       0xE4   0xF001 0x00FF      AND      R0,R1,#0xFF
   \       0xE8   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \       0xEC   0xE000             B.N      ??psa_sign_verify_check_alg_7
   \                     ??psa_sign_verify_check_alg_6: (+1)
   \       0xEE   0x2000             MOVS     R0,#+0
   \                     ??psa_sign_verify_check_alg_7: (+1)
   \       0xF0   0xF010 0x40FE      ANDS     R0,R0,#0x7F000000
   \       0xF4   0xF1B0 0x7F00      CMP      R0,#+33554432
   \       0xF8   0xD028             BEQ.N    ??psa_sign_verify_check_alg_4
   2944                          return PSA_ERROR_INVALID_ARGUMENT;
   \       0xFA   0xF07F 0x0086      MVNS     R0,#+134
   \       0xFE   0xE026             B.N      ??psa_sign_verify_check_alg_2
   2945                      }
   2946                  }
   2947              } else {
   2948                  if (!PSA_ALG_IS_SIGN_HASH(alg)) {
   \                     ??psa_sign_verify_check_alg_0: (+1)
   \      0x100   0x0A0B             LSRS     R3,R1,#+8
   \      0x102   0x021B             LSLS     R3,R3,#+8
   \      0x104   0x.... 0x....      LDR.W    R0,??DataTable25
   \      0x108   0x4283             CMP      R3,R0
   \      0x10A   0xD01F             BEQ.N    ??psa_sign_verify_check_alg_4
   \      0x10C   0x0A0B             LSRS     R3,R1,#+8
   \      0x10E   0x021B             LSLS     R3,R3,#+8
   \      0x110   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \      0x114   0x4283             CMP      R3,R0
   \      0x116   0xD019             BEQ.N    ??psa_sign_verify_check_alg_4
   \      0x118   0x0A0B             LSRS     R3,R1,#+8
   \      0x11A   0x021B             LSLS     R3,R3,#+8
   \      0x11C   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \      0x120   0x4283             CMP      R3,R0
   \      0x122   0xD013             BEQ.N    ??psa_sign_verify_check_alg_4
   \      0x124   0x0A48             LSRS     R0,R1,#+9
   \      0x126   0x0240             LSLS     R0,R0,#+9
   \      0x128   0xF1B0 0x2F06      CMP      R0,#+100664832
   \      0x12C   0xD00E             BEQ.N    ??psa_sign_verify_check_alg_4
   \      0x12E   0x0A0B             LSRS     R3,R1,#+8
   \      0x130   0x021B             LSLS     R3,R3,#+8
   \      0x132   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \      0x136   0x4283             CMP      R3,R0
   \      0x138   0xD008             BEQ.N    ??psa_sign_verify_check_alg_4
   \      0x13A   0x0A4B             LSRS     R3,R1,#+9
   \      0x13C   0x025B             LSLS     R3,R3,#+9
   \      0x13E   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \      0x142   0x4283             CMP      R3,R0
   \      0x144   0xD002             BEQ.N    ??psa_sign_verify_check_alg_4
   2949                      return PSA_ERROR_INVALID_ARGUMENT;
   \      0x146   0xF07F 0x0086      MVNS     R0,#+134
   \      0x14A   0xE000             B.N      ??psa_sign_verify_check_alg_2
   2950                  }
   2951              }
   2952          
   2953              return PSA_SUCCESS;
   \                     ??psa_sign_verify_check_alg_4: (+1)
   \      0x14C   0x2000             MOVS     R0,#+0
   \                     ??psa_sign_verify_check_alg_2: (+1)
   \      0x14E   0xBC10             POP      {R4}
   \      0x150   0x4770             BX       LR
   2954          }
   2955          

   \                                 In section .text, align 2, keep-with-next
   2956          static psa_status_t psa_sign_internal(mbedtls_svc_key_id_t key,
   2957                                                int input_is_message,
   2958                                                psa_algorithm_t alg,
   2959                                                const uint8_t *input,
   2960                                                size_t input_length,
   2961                                                uint8_t *signature,
   2962                                                size_t signature_size,
   2963                                                size_t *signature_length)
   2964          {
   \                     psa_sign_internal: (+1)
   \        0x0   0xE92D 0x4FF9      PUSH     {R0,R3-R11,LR}
   \        0x4   0xB099             SUB      SP,SP,#+100
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0xF8DD 0xA090      LDR      R10,[SP, #+144]
   \        0xE   0x9F25             LDR      R7,[SP, #+148]
   \       0x10   0x9E26             LDR      R6,[SP, #+152]
   \       0x12   0xF8DD 0x809C      LDR      R8,[SP, #+156]
   2965              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1A   0x0004             MOVS     R4,R0
   2966              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x1C   0x9006             STR      R0,[SP, #+24]
   2967              psa_key_slot_t *slot;
   2968              psa_key_attributes_t attributes;
   2969          
   2970              *signature_length = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF8C8 0x0000      STR      R0,[R8, #+0]
   2971          
   2972              status = psa_sign_verify_check_alg(input_is_message, alg);
   \       0x24   0x4649             MOV      R1,R9
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       psa_sign_verify_check_alg
   \       0x2C   0x4683             MOV      R11,R0
   2973              if (status != PSA_SUCCESS) {
   \       0x2E   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x32   0xD001             BEQ.N    ??psa_sign_internal_0
   2974                  return status;
   \       0x34   0x4658             MOV      R0,R11
   \       0x36   0xE05E             B.N      ??psa_sign_internal_1
   2975              }
   2976          
   2977              /* Immediately reject a zero-length signature buffer. This guarantees
   2978               * that signature must be a valid pointer. (On the other hand, the input
   2979               * buffer can in principle be empty since it doesn't actually have
   2980               * to be a hash.) */
   2981              if (signature_size == 0) {
   \                     ??psa_sign_internal_0: (+1)
   \       0x38   0x2E00             CMP      R6,#+0
   \       0x3A   0xD102             BNE.N    ??psa_sign_internal_2
   2982                  return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x3C   0xF07F 0x0089      MVNS     R0,#+137
   \       0x40   0xE059             B.N      ??psa_sign_internal_1
   2983              }
   2984          
   2985              status = psa_get_and_lock_key_slot_with_policy(
   2986                  key, &slot,
   2987                  input_is_message ? PSA_KEY_USAGE_SIGN_MESSAGE :
   2988                  PSA_KEY_USAGE_SIGN_HASH,
   2989                  alg);
   \                     ??psa_sign_internal_2: (+1)
   \       0x42   0x2D00             CMP      R5,#+0
   \       0x44   0xD002             BEQ.N    ??psa_sign_internal_3
   \       0x46   0xF44F 0x6280      MOV      R2,#+1024
   \       0x4A   0xE001             B.N      ??psa_sign_internal_4
   \                     ??psa_sign_internal_3: (+1)
   \       0x4C   0xF44F 0x5280      MOV      R2,#+4096
   \                     ??psa_sign_internal_4: (+1)
   \       0x50   0x464B             MOV      R3,R9
   \       0x52   0xA905             ADD      R1,SP,#+20
   \       0x54   0x9819             LDR      R0,[SP, #+100]
   \       0x56   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x5A   0x0004             MOVS     R4,R0
   2990          
   2991              if (status != PSA_SUCCESS) {
   \       0x5C   0x2C00             CMP      R4,#+0
   \       0x5E   0xD13D             BNE.N    ??psa_sign_internal_5
   2992                  goto exit;
   2993              }
   2994          
   2995              if (!PSA_KEY_TYPE_IS_KEY_PAIR(slot->attr.type)) {
   \                     ??psa_sign_internal_6: (+1)
   \       0x60   0x9805             LDR      R0,[SP, #+20]
   \       0x62   0x8800             LDRH     R0,[R0, #+0]
   \       0x64   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x68   0xF5B0 0x4FE0      CMP      R0,#+28672
   \       0x6C   0xD003             BEQ.N    ??psa_sign_internal_7
   2996                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x6E   0xF07F 0x0086      MVNS     R0,#+134
   \       0x72   0x0004             MOVS     R4,R0
   2997                  goto exit;
   \       0x74   0xE032             B.N      ??psa_sign_internal_5
   2998              }
   2999          
   3000              attributes = (psa_key_attributes_t) {
   3001                  .core = slot->attr
   3002              };
   \                     ??psa_sign_internal_7: (+1)
   \       0x76   0xA807             ADD      R0,SP,#+28
   \       0x78   0x2124             MOVS     R1,#+36
   \       0x7A   0x.... 0x....      BL       __aeabi_memclr4
   \       0x7E   0xA807             ADD      R0,SP,#+28
   \       0x80   0x9905             LDR      R1,[SP, #+20]
   \       0x82   0x221C             MOVS     R2,#+28
   \       0x84   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x88   0xA810             ADD      R0,SP,#+64
   \       0x8A   0xA907             ADD      R1,SP,#+28
   \       0x8C   0x2224             MOVS     R2,#+36
   \       0x8E   0x.... 0x....      BL       __aeabi_memcpy4
   3003          
   3004              if (input_is_message) {
   \       0x92   0x2D00             CMP      R5,#+0
   \       0x94   0xD011             BEQ.N    ??psa_sign_internal_8
   3005                  status = psa_driver_wrapper_sign_message(
   3006                      &attributes, slot->key.data, slot->key.bytes,
   3007                      alg, input, input_length,
   3008                      signature, signature_size, signature_length);
   \       0x96   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0x9A   0x9603             STR      R6,[SP, #+12]
   \       0x9C   0x9702             STR      R7,[SP, #+8]
   \       0x9E   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0xA2   0x981A             LDR      R0,[SP, #+104]
   \       0xA4   0x9000             STR      R0,[SP, #+0]
   \       0xA6   0x464B             MOV      R3,R9
   \       0xA8   0x9805             LDR      R0,[SP, #+20]
   \       0xAA   0x6A82             LDR      R2,[R0, #+40]
   \       0xAC   0x9805             LDR      R0,[SP, #+20]
   \       0xAE   0x6A41             LDR      R1,[R0, #+36]
   \       0xB0   0xA810             ADD      R0,SP,#+64
   \       0xB2   0x.... 0x....      BL       psa_driver_wrapper_sign_message
   \       0xB6   0x0004             MOVS     R4,R0
   \       0xB8   0xE010             B.N      ??psa_sign_internal_5
   3009              } else {
   3010          
   3011                  status = psa_driver_wrapper_sign_hash(
   3012                      &attributes, slot->key.data, slot->key.bytes,
   3013                      alg, input, input_length,
   3014                      signature, signature_size, signature_length);
   \                     ??psa_sign_internal_8: (+1)
   \       0xBA   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0xBE   0x9603             STR      R6,[SP, #+12]
   \       0xC0   0x9702             STR      R7,[SP, #+8]
   \       0xC2   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0xC6   0x981A             LDR      R0,[SP, #+104]
   \       0xC8   0x9000             STR      R0,[SP, #+0]
   \       0xCA   0x464B             MOV      R3,R9
   \       0xCC   0x9805             LDR      R0,[SP, #+20]
   \       0xCE   0x6A82             LDR      R2,[R0, #+40]
   \       0xD0   0x9805             LDR      R0,[SP, #+20]
   \       0xD2   0x6A41             LDR      R1,[R0, #+36]
   \       0xD4   0xA810             ADD      R0,SP,#+64
   \       0xD6   0x.... 0x....      BL       psa_driver_wrapper_sign_hash
   \       0xDA   0x0004             MOVS     R4,R0
   3015              }
   3016          
   3017          
   3018          exit:
   3019              psa_wipe_tag_output_buffer(signature, status, signature_size,
   3020                                         *signature_length);
   \                     ??psa_sign_internal_5: (+1)
   \       0xDC   0xF8D8 0x3000      LDR      R3,[R8, #+0]
   \       0xE0   0x0032             MOVS     R2,R6
   \       0xE2   0x0021             MOVS     R1,R4
   \       0xE4   0x0038             MOVS     R0,R7
   \       0xE6   0x.... 0x....      BL       psa_wipe_tag_output_buffer
   3021          
   3022              unlock_status = psa_unlock_key_slot(slot);
   \       0xEA   0x9805             LDR      R0,[SP, #+20]
   \       0xEC   0x.... 0x....      BL       psa_unlock_key_slot
   3023          
   3024              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0xF0   0x2C00             CMP      R4,#+0
   \       0xF2   0xD000             BEQ.N    ??psa_sign_internal_9
   \                     ??psa_sign_internal_10: (+1)
   \       0xF4   0x0020             MOVS     R0,R4
   \                     ??psa_sign_internal_9: (+1)
   \                     ??psa_sign_internal_1: (+1)
   \       0xF6   0xB01B             ADD      SP,SP,#+108
   \       0xF8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3025          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   3026          

   \                                 In section .text, align 2, keep-with-next
   3027          static psa_status_t psa_verify_internal(mbedtls_svc_key_id_t key,
   3028                                                  int input_is_message,
   3029                                                  psa_algorithm_t alg,
   3030                                                  const uint8_t *input,
   3031                                                  size_t input_length,
   3032                                                  const uint8_t *signature,
   3033                                                  size_t signature_length)
   3034          {
   \                     psa_verify_internal: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB090             SUB      SP,SP,#+64
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0x469A             MOV      R10,R3
   \        0xC   0x9E1A             LDR      R6,[SP, #+104]
   \        0xE   0x9F1B             LDR      R7,[SP, #+108]
   \       0x10   0xF8DD 0x8070      LDR      R8,[SP, #+112]
   3035              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x14   0xF07F 0x0096      MVNS     R0,#+150
   \       0x18   0x0005             MOVS     R5,R0
   3036              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x1A   0x9005             STR      R0,[SP, #+20]
   3037              psa_key_slot_t *slot;
   3038          
   3039              status = psa_sign_verify_check_alg(input_is_message, alg);
   \       0x1C   0x4649             MOV      R1,R9
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       psa_sign_verify_check_alg
   \       0x24   0x4683             MOV      R11,R0
   3040              if (status != PSA_SUCCESS) {
   \       0x26   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x2A   0xD001             BEQ.N    ??psa_verify_internal_0
   3041                  return status;
   \       0x2C   0x4658             MOV      R0,R11
   \       0x2E   0xE043             B.N      ??psa_verify_internal_1
   3042              }
   3043          
   3044              status = psa_get_and_lock_key_slot_with_policy(
   3045                  key, &slot,
   3046                  input_is_message ? PSA_KEY_USAGE_VERIFY_MESSAGE :
   3047                  PSA_KEY_USAGE_VERIFY_HASH,
   3048                  alg);
   \                     ??psa_verify_internal_0: (+1)
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD002             BEQ.N    ??psa_verify_internal_2
   \       0x34   0xF44F 0x6200      MOV      R2,#+2048
   \       0x38   0xE001             B.N      ??psa_verify_internal_3
   \                     ??psa_verify_internal_2: (+1)
   \       0x3A   0xF44F 0x5200      MOV      R2,#+8192
   \                     ??psa_verify_internal_3: (+1)
   \       0x3E   0x464B             MOV      R3,R9
   \       0x40   0xA904             ADD      R1,SP,#+16
   \       0x42   0x9810             LDR      R0,[SP, #+64]
   \       0x44   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x48   0x0005             MOVS     R5,R0
   3049          
   3050              if (status != PSA_SUCCESS) {
   \       0x4A   0x2D00             CMP      R5,#+0
   \       0x4C   0xD001             BEQ.N    ??psa_verify_internal_4
   3051                  return status;
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0xE032             B.N      ??psa_verify_internal_1
   3052              }
   3053          
   3054              psa_key_attributes_t attributes = {
   3055                  .core = slot->attr
   3056              };
   \                     ??psa_verify_internal_4: (+1)
   \       0x52   0xA806             ADD      R0,SP,#+24
   \       0x54   0x2124             MOVS     R1,#+36
   \       0x56   0x.... 0x....      BL       __aeabi_memclr4
   \       0x5A   0xA806             ADD      R0,SP,#+24
   \       0x5C   0x9904             LDR      R1,[SP, #+16]
   \       0x5E   0x221C             MOVS     R2,#+28
   \       0x60   0x.... 0x....      BL       __aeabi_memcpy4
   3057          
   3058              if (input_is_message) {
   \       0x64   0x2C00             CMP      R4,#+0
   \       0x66   0xD00F             BEQ.N    ??psa_verify_internal_5
   3059                  status = psa_driver_wrapper_verify_message(
   3060                      &attributes, slot->key.data, slot->key.bytes,
   3061                      alg, input, input_length,
   3062                      signature, signature_length);
   \       0x68   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x6C   0x9702             STR      R7,[SP, #+8]
   \       0x6E   0x9601             STR      R6,[SP, #+4]
   \       0x70   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \       0x74   0x464B             MOV      R3,R9
   \       0x76   0x9804             LDR      R0,[SP, #+16]
   \       0x78   0x6A82             LDR      R2,[R0, #+40]
   \       0x7A   0x9804             LDR      R0,[SP, #+16]
   \       0x7C   0x6A41             LDR      R1,[R0, #+36]
   \       0x7E   0xA806             ADD      R0,SP,#+24
   \       0x80   0x.... 0x....      BL       psa_driver_wrapper_verify_message
   \       0x84   0x4683             MOV      R11,R0
   \       0x86   0xE00E             B.N      ??psa_verify_internal_6
   3063              } else {
   3064                  status = psa_driver_wrapper_verify_hash(
   3065                      &attributes, slot->key.data, slot->key.bytes,
   3066                      alg, input, input_length,
   3067                      signature, signature_length);
   \                     ??psa_verify_internal_5: (+1)
   \       0x88   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x8C   0x9702             STR      R7,[SP, #+8]
   \       0x8E   0x9601             STR      R6,[SP, #+4]
   \       0x90   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \       0x94   0x464B             MOV      R3,R9
   \       0x96   0x9804             LDR      R0,[SP, #+16]
   \       0x98   0x6A82             LDR      R2,[R0, #+40]
   \       0x9A   0x9804             LDR      R0,[SP, #+16]
   \       0x9C   0x6A41             LDR      R1,[R0, #+36]
   \       0x9E   0xA806             ADD      R0,SP,#+24
   \       0xA0   0x.... 0x....      BL       psa_driver_wrapper_verify_hash
   \       0xA4   0x4683             MOV      R11,R0
   3068              }
   3069          
   3070              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_verify_internal_6: (+1)
   \       0xA6   0x9804             LDR      R0,[SP, #+16]
   \       0xA8   0x.... 0x....      BL       psa_unlock_key_slot
   3071          
   3072              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0xAC   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xB0   0xD101             BNE.N    ??psa_verify_internal_7
   \       0xB2   0x4683             MOV      R11,R0
   \       0xB4   0xE7FF             B.N      ??psa_verify_internal_8
   \                     ??psa_verify_internal_7: (+1)
   \                     ??psa_verify_internal_8: (+1)
   \       0xB6   0x4658             MOV      R0,R11
   \                     ??psa_verify_internal_1: (+1)
   \       0xB8   0xB011             ADD      SP,SP,#+68
   \       0xBA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3073          
   3074          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   3075          

   \                                 In section .text, align 2, keep-with-next
   3076          psa_status_t psa_sign_message_builtin(
   3077              const psa_key_attributes_t *attributes,
   3078              const uint8_t *key_buffer,
   3079              size_t key_buffer_size,
   3080              psa_algorithm_t alg,
   3081              const uint8_t *input,
   3082              size_t input_length,
   3083              uint8_t *signature,
   3084              size_t signature_size,
   3085              size_t *signature_length)
   3086          {
   \                     psa_sign_message_builtin: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08E             SUB      SP,SP,#+56
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0xF8DD 0x8060      LDR      R8,[SP, #+96]
   \       0x12   0xF8DD 0x9064      LDR      R9,[SP, #+100]
   3087              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x0A96      MVNS     R10,#+150
   3088          
   3089              if (PSA_ALG_IS_SIGN_HASH(alg)) {
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable25
   \       0x1E   0x0A39             LSRS     R1,R7,#+8
   \       0x20   0x0209             LSLS     R1,R1,#+8
   \       0x22   0x4281             CMP      R1,R0
   \       0x24   0xD01C             BEQ.N    ??psa_sign_message_builtin_0
   \       0x26   0x0A3A             LSRS     R2,R7,#+8
   \       0x28   0x0212             LSLS     R2,R2,#+8
   \       0x2A   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \       0x2E   0x428A             CMP      R2,R1
   \       0x30   0xD016             BEQ.N    ??psa_sign_message_builtin_0
   \       0x32   0x0A3A             LSRS     R2,R7,#+8
   \       0x34   0x0212             LSLS     R2,R2,#+8
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \       0x3A   0x428A             CMP      R2,R1
   \       0x3C   0xD010             BEQ.N    ??psa_sign_message_builtin_0
   \       0x3E   0x0A79             LSRS     R1,R7,#+9
   \       0x40   0x0249             LSLS     R1,R1,#+9
   \       0x42   0xF1B1 0x2F06      CMP      R1,#+100664832
   \       0x46   0xD00B             BEQ.N    ??psa_sign_message_builtin_0
   \       0x48   0x0A39             LSRS     R1,R7,#+8
   \       0x4A   0x0209             LSLS     R1,R1,#+8
   \       0x4C   0x.... 0x....      LDR.W    R2,??DataTable25_3
   \       0x50   0x4291             CMP      R1,R2
   \       0x52   0xD005             BEQ.N    ??psa_sign_message_builtin_0
   \       0x54   0x0A79             LSRS     R1,R7,#+9
   \       0x56   0x0249             LSLS     R1,R1,#+9
   \       0x58   0x.... 0x....      LDR.W    R2,??DataTable25_4
   \       0x5C   0x4291             CMP      R1,R2
   \       0x5E   0xD147             BNE.N    ??psa_sign_message_builtin_1
   3090                  size_t hash_length;
   3091                  uint8_t hash[PSA_HASH_MAX_SIZE];
   3092          
   3093                  status = psa_driver_wrapper_hash_compute(
   3094                      PSA_ALG_SIGN_GET_HASH(alg),
   3095                      input, input_length,
   3096                      hash, sizeof(hash), &hash_length);
   \                     ??psa_sign_message_builtin_0: (+1)
   \       0x60   0x0A39             LSRS     R1,R7,#+8
   \       0x62   0x0209             LSLS     R1,R1,#+8
   \       0x64   0x4281             CMP      R1,R0
   \       0x66   0xD01C             BEQ.N    ??psa_sign_message_builtin_2
   \       0x68   0x0A39             LSRS     R1,R7,#+8
   \       0x6A   0x0209             LSLS     R1,R1,#+8
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \       0x70   0x4281             CMP      R1,R0
   \       0x72   0xD016             BEQ.N    ??psa_sign_message_builtin_2
   \       0x74   0x0A39             LSRS     R1,R7,#+8
   \       0x76   0x0209             LSLS     R1,R1,#+8
   \       0x78   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \       0x7C   0x4281             CMP      R1,R0
   \       0x7E   0xD010             BEQ.N    ??psa_sign_message_builtin_2
   \       0x80   0x0A78             LSRS     R0,R7,#+9
   \       0x82   0x0240             LSLS     R0,R0,#+9
   \       0x84   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x88   0xD00B             BEQ.N    ??psa_sign_message_builtin_2
   \       0x8A   0x0A39             LSRS     R1,R7,#+8
   \       0x8C   0x0209             LSLS     R1,R1,#+8
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \       0x92   0x4281             CMP      R1,R0
   \       0x94   0xD005             BEQ.N    ??psa_sign_message_builtin_2
   \       0x96   0x0A78             LSRS     R0,R7,#+9
   \       0x98   0x0240             LSLS     R0,R0,#+9
   \       0x9A   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x9E   0x4288             CMP      R0,R1
   \       0xA0   0xD106             BNE.N    ??psa_sign_message_builtin_3
   \                     ??psa_sign_message_builtin_2: (+1)
   \       0xA2   0x0638             LSLS     R0,R7,#+24
   \       0xA4   0xD004             BEQ.N    ??psa_sign_message_builtin_3
   \       0xA6   0xF007 0x00FF      AND      R0,R7,#0xFF
   \       0xAA   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \       0xAE   0xE000             B.N      ??psa_sign_message_builtin_4
   \                     ??psa_sign_message_builtin_3: (+1)
   \       0xB0   0x2000             MOVS     R0,#+0
   \                     ??psa_sign_message_builtin_4: (+1)
   \       0xB2   0xA905             ADD      R1,SP,#+20
   \       0xB4   0x9101             STR      R1,[SP, #+4]
   \       0xB6   0x2120             MOVS     R1,#+32
   \       0xB8   0x9100             STR      R1,[SP, #+0]
   \       0xBA   0xAB06             ADD      R3,SP,#+24
   \       0xBC   0x464A             MOV      R2,R9
   \       0xBE   0x4641             MOV      R1,R8
   \       0xC0   0x.... 0x....      BL       psa_driver_wrapper_hash_compute
   \       0xC4   0x0004             MOVS     R4,R0
   3097          
   3098                  if (status != PSA_SUCCESS) {
   \       0xC6   0x2C00             CMP      R4,#+0
   \       0xC8   0xD001             BEQ.N    ??psa_sign_message_builtin_5
   3099                      return status;
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0xE012             B.N      ??psa_sign_message_builtin_6
   3100                  }
   3101          
   3102                  return psa_driver_wrapper_sign_hash(
   3103                      attributes, key_buffer, key_buffer_size,
   3104                      alg, hash, hash_length,
   3105                      signature, signature_size, signature_length);
   \                     ??psa_sign_message_builtin_5: (+1)
   \       0xCE   0x981C             LDR      R0,[SP, #+112]
   \       0xD0   0x9004             STR      R0,[SP, #+16]
   \       0xD2   0x981B             LDR      R0,[SP, #+108]
   \       0xD4   0x9003             STR      R0,[SP, #+12]
   \       0xD6   0x981A             LDR      R0,[SP, #+104]
   \       0xD8   0x9002             STR      R0,[SP, #+8]
   \       0xDA   0x9805             LDR      R0,[SP, #+20]
   \       0xDC   0x9001             STR      R0,[SP, #+4]
   \       0xDE   0xA806             ADD      R0,SP,#+24
   \       0xE0   0x9000             STR      R0,[SP, #+0]
   \       0xE2   0x003B             MOVS     R3,R7
   \       0xE4   0x0032             MOVS     R2,R6
   \       0xE6   0x0029             MOVS     R1,R5
   \       0xE8   0x4658             MOV      R0,R11
   \       0xEA   0x.... 0x....      BL       psa_driver_wrapper_sign_hash
   \       0xEE   0xE001             B.N      ??psa_sign_message_builtin_6
   3106              }
   3107          
   3108              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_sign_message_builtin_1: (+1)
   \       0xF0   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_sign_message_builtin_6: (+1)
   \       0xF4   0xB00F             ADD      SP,SP,#+60
   \       0xF6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3109          }
   3110          

   \                                 In section .text, align 2, keep-with-next
   3111          psa_status_t psa_sign_message(mbedtls_svc_key_id_t key,
   3112                                        psa_algorithm_t alg,
   3113                                        const uint8_t *input,
   3114                                        size_t input_length,
   3115                                        uint8_t *signature,
   3116                                        size_t signature_size,
   3117                                        size_t *signature_length)
   3118          {
   \                     psa_sign_message: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3119              return psa_sign_internal(
   3120                  key, 1, alg, input, input_length,
   3121                  signature, signature_size, signature_length);
   \        0xC   0x980C             LDR      R0,[SP, #+48]
   \        0xE   0x9003             STR      R0,[SP, #+12]
   \       0x10   0x980B             LDR      R0,[SP, #+44]
   \       0x12   0x9002             STR      R0,[SP, #+8]
   \       0x14   0x980A             LDR      R0,[SP, #+40]
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x9700             STR      R7,[SP, #+0]
   \       0x1A   0x0033             MOVS     R3,R6
   \       0x1C   0x002A             MOVS     R2,R5
   \       0x1E   0x2101             MOVS     R1,#+1
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       psa_sign_internal
   \       0x26   0xB005             ADD      SP,SP,#+20
   \       0x28   0xBDF0             POP      {R4-R7,PC}
   3122          }
   3123          

   \                                 In section .text, align 2, keep-with-next
   3124          psa_status_t psa_verify_message_builtin(
   3125              const psa_key_attributes_t *attributes,
   3126              const uint8_t *key_buffer,
   3127              size_t key_buffer_size,
   3128              psa_algorithm_t alg,
   3129              const uint8_t *input,
   3130              size_t input_length,
   3131              const uint8_t *signature,
   3132              size_t signature_length)
   3133          {
   \                     psa_verify_message_builtin: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0xF8DD 0x8058      LDR      R8,[SP, #+88]
   \       0x12   0xF8DD 0x905C      LDR      R9,[SP, #+92]
   3134              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x0A96      MVNS     R10,#+150
   3135          
   3136              if (PSA_ALG_IS_SIGN_HASH(alg)) {
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable25
   \       0x1E   0x0A39             LSRS     R1,R7,#+8
   \       0x20   0x0209             LSLS     R1,R1,#+8
   \       0x22   0x4281             CMP      R1,R0
   \       0x24   0xD01C             BEQ.N    ??psa_verify_message_builtin_0
   \       0x26   0x0A3A             LSRS     R2,R7,#+8
   \       0x28   0x0212             LSLS     R2,R2,#+8
   \       0x2A   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \       0x2E   0x428A             CMP      R2,R1
   \       0x30   0xD016             BEQ.N    ??psa_verify_message_builtin_0
   \       0x32   0x0A3A             LSRS     R2,R7,#+8
   \       0x34   0x0212             LSLS     R2,R2,#+8
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \       0x3A   0x428A             CMP      R2,R1
   \       0x3C   0xD010             BEQ.N    ??psa_verify_message_builtin_0
   \       0x3E   0x0A79             LSRS     R1,R7,#+9
   \       0x40   0x0249             LSLS     R1,R1,#+9
   \       0x42   0xF1B1 0x2F06      CMP      R1,#+100664832
   \       0x46   0xD00B             BEQ.N    ??psa_verify_message_builtin_0
   \       0x48   0x0A3A             LSRS     R2,R7,#+8
   \       0x4A   0x0212             LSLS     R2,R2,#+8
   \       0x4C   0x.... 0x....      LDR.W    R1,??DataTable25_3
   \       0x50   0x428A             CMP      R2,R1
   \       0x52   0xD005             BEQ.N    ??psa_verify_message_builtin_0
   \       0x54   0x0A7A             LSRS     R2,R7,#+9
   \       0x56   0x0252             LSLS     R2,R2,#+9
   \       0x58   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \       0x5C   0x428A             CMP      R2,R1
   \       0x5E   0xD145             BNE.N    ??psa_verify_message_builtin_1
   3137                  size_t hash_length;
   3138                  uint8_t hash[PSA_HASH_MAX_SIZE];
   3139          
   3140                  status = psa_driver_wrapper_hash_compute(
   3141                      PSA_ALG_SIGN_GET_HASH(alg),
   3142                      input, input_length,
   3143                      hash, sizeof(hash), &hash_length);
   \                     ??psa_verify_message_builtin_0: (+1)
   \       0x60   0x0A39             LSRS     R1,R7,#+8
   \       0x62   0x0209             LSLS     R1,R1,#+8
   \       0x64   0x4281             CMP      R1,R0
   \       0x66   0xD01C             BEQ.N    ??psa_verify_message_builtin_2
   \       0x68   0x0A39             LSRS     R1,R7,#+8
   \       0x6A   0x0209             LSLS     R1,R1,#+8
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \       0x70   0x4281             CMP      R1,R0
   \       0x72   0xD016             BEQ.N    ??psa_verify_message_builtin_2
   \       0x74   0x0A39             LSRS     R1,R7,#+8
   \       0x76   0x0209             LSLS     R1,R1,#+8
   \       0x78   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \       0x7C   0x4281             CMP      R1,R0
   \       0x7E   0xD010             BEQ.N    ??psa_verify_message_builtin_2
   \       0x80   0x0A78             LSRS     R0,R7,#+9
   \       0x82   0x0240             LSLS     R0,R0,#+9
   \       0x84   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x88   0xD00B             BEQ.N    ??psa_verify_message_builtin_2
   \       0x8A   0x0A39             LSRS     R1,R7,#+8
   \       0x8C   0x0209             LSLS     R1,R1,#+8
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \       0x92   0x4281             CMP      R1,R0
   \       0x94   0xD005             BEQ.N    ??psa_verify_message_builtin_2
   \       0x96   0x0A79             LSRS     R1,R7,#+9
   \       0x98   0x0249             LSLS     R1,R1,#+9
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \       0x9E   0x4281             CMP      R1,R0
   \       0xA0   0xD106             BNE.N    ??psa_verify_message_builtin_3
   \                     ??psa_verify_message_builtin_2: (+1)
   \       0xA2   0x0638             LSLS     R0,R7,#+24
   \       0xA4   0xD004             BEQ.N    ??psa_verify_message_builtin_3
   \       0xA6   0xF007 0x00FF      AND      R0,R7,#0xFF
   \       0xAA   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \       0xAE   0xE000             B.N      ??psa_verify_message_builtin_4
   \                     ??psa_verify_message_builtin_3: (+1)
   \       0xB0   0x2000             MOVS     R0,#+0
   \                     ??psa_verify_message_builtin_4: (+1)
   \       0xB2   0xA904             ADD      R1,SP,#+16
   \       0xB4   0x9101             STR      R1,[SP, #+4]
   \       0xB6   0x2120             MOVS     R1,#+32
   \       0xB8   0x9100             STR      R1,[SP, #+0]
   \       0xBA   0xAB05             ADD      R3,SP,#+20
   \       0xBC   0x464A             MOV      R2,R9
   \       0xBE   0x4641             MOV      R1,R8
   \       0xC0   0x.... 0x....      BL       psa_driver_wrapper_hash_compute
   \       0xC4   0x0004             MOVS     R4,R0
   3144          
   3145                  if (status != PSA_SUCCESS) {
   \       0xC6   0x2C00             CMP      R4,#+0
   \       0xC8   0xD001             BEQ.N    ??psa_verify_message_builtin_5
   3146                      return status;
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0xE010             B.N      ??psa_verify_message_builtin_6
   3147                  }
   3148          
   3149                  return psa_driver_wrapper_verify_hash(
   3150                      attributes, key_buffer, key_buffer_size,
   3151                      alg, hash, hash_length,
   3152                      signature, signature_length);
   \                     ??psa_verify_message_builtin_5: (+1)
   \       0xCE   0x9819             LDR      R0,[SP, #+100]
   \       0xD0   0x9003             STR      R0,[SP, #+12]
   \       0xD2   0x9818             LDR      R0,[SP, #+96]
   \       0xD4   0x9002             STR      R0,[SP, #+8]
   \       0xD6   0x9804             LDR      R0,[SP, #+16]
   \       0xD8   0x9001             STR      R0,[SP, #+4]
   \       0xDA   0xA805             ADD      R0,SP,#+20
   \       0xDC   0x9000             STR      R0,[SP, #+0]
   \       0xDE   0x003B             MOVS     R3,R7
   \       0xE0   0x0032             MOVS     R2,R6
   \       0xE2   0x0029             MOVS     R1,R5
   \       0xE4   0x4658             MOV      R0,R11
   \       0xE6   0x.... 0x....      BL       psa_driver_wrapper_verify_hash
   \       0xEA   0xE001             B.N      ??psa_verify_message_builtin_6
   3153              }
   3154          
   3155              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_verify_message_builtin_1: (+1)
   \       0xEC   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_verify_message_builtin_6: (+1)
   \       0xF0   0xB00D             ADD      SP,SP,#+52
   \       0xF2   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3156          }
   3157          

   \                                 In section .text, align 2, keep-with-next
   3158          psa_status_t psa_verify_message(mbedtls_svc_key_id_t key,
   3159                                          psa_algorithm_t alg,
   3160                                          const uint8_t *input,
   3161                                          size_t input_length,
   3162                                          const uint8_t *signature,
   3163                                          size_t signature_length)
   3164          {
   \                     psa_verify_message: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   3165              return psa_verify_internal(
   3166                  key, 1, alg, input, input_length,
   3167                  signature, signature_length);
   \        0xA   0x9809             LDR      R0,[SP, #+36]
   \        0xC   0x9002             STR      R0,[SP, #+8]
   \        0xE   0x9808             LDR      R0,[SP, #+32]
   \       0x10   0x9001             STR      R0,[SP, #+4]
   \       0x12   0x9700             STR      R7,[SP, #+0]
   \       0x14   0x0033             MOVS     R3,R6
   \       0x16   0x002A             MOVS     R2,R5
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       psa_verify_internal
   \       0x20   0xBDFE             POP      {R1-R7,PC}
   3168          }
   3169          

   \                                 In section .text, align 2, keep-with-next
   3170          psa_status_t psa_sign_hash_builtin(
   3171              const psa_key_attributes_t *attributes,
   3172              const uint8_t *key_buffer, size_t key_buffer_size,
   3173              psa_algorithm_t alg, const uint8_t *hash, size_t hash_length,
   3174              uint8_t *signature, size_t signature_size, size_t *signature_length)
   3175          {
   \                     psa_sign_hash_builtin: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3176              if (attributes->core.type == PSA_KEY_TYPE_RSA_KEY_PAIR) {
   \        0xC   0x8821             LDRH     R1,[R4, #+0]
   \        0xE   0xF247 0x0001      MOVW     R0,#+28673
   \       0x12   0x4281             CMP      R1,R0
   \       0x14   0xD114             BNE.N    ??psa_sign_hash_builtin_0
   3177                  if (PSA_ALG_IS_RSA_PKCS1V15_SIGN(alg) ||
   3178                      PSA_ALG_IS_RSA_PSS(alg)) {
   \       0x16   0x0A39             LSRS     R1,R7,#+8
   \       0x18   0x0209             LSLS     R1,R1,#+8
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \       0x1E   0x4281             CMP      R1,R0
   \       0x20   0xD02E             BEQ.N    ??psa_sign_hash_builtin_1
   \       0x22   0x0A39             LSRS     R1,R7,#+8
   \       0x24   0x0209             LSLS     R1,R1,#+8
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable25
   \       0x2A   0x4281             CMP      R1,R0
   \       0x2C   0xD028             BEQ.N    ??psa_sign_hash_builtin_1
   \       0x2E   0x0A39             LSRS     R1,R7,#+8
   \       0x30   0x0209             LSLS     R1,R1,#+8
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \       0x36   0x4281             CMP      R1,R0
   \       0x38   0xD022             BEQ.N    ??psa_sign_hash_builtin_1
   3179          #if defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN) || \
   3180                      defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS)
   3181                      return mbedtls_psa_rsa_sign_hash(
   3182                          attributes,
   3183                          key_buffer, key_buffer_size,
   3184                          alg, hash, hash_length,
   3185                          signature, signature_size, signature_length);
   3186          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN) ||
   3187                  * defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS) */
   3188                  } else {
   3189                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x3A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x3E   0xE021             B.N      ??psa_sign_hash_builtin_2
   3190                  }
   3191              } else if (PSA_KEY_TYPE_IS_ECC(attributes->core.type)) {
   \                     ??psa_sign_hash_builtin_0: (+1)
   \       0x40   0x8821             LDRH     R1,[R4, #+0]
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable27
   \       0x46   0x4001             ANDS     R1,R0,R1
   \       0x48   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x4C   0xD118             BNE.N    ??psa_sign_hash_builtin_1
   3192                  if (PSA_ALG_IS_ECDSA(alg)) {
   \       0x4E   0x0A78             LSRS     R0,R7,#+9
   \       0x50   0x0240             LSLS     R0,R0,#+9
   \       0x52   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x56   0xD110             BNE.N    ??psa_sign_hash_builtin_3
   3193          #if defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   3194                      defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)
   3195                      return mbedtls_psa_ecdsa_sign_hash(
   3196                          attributes,
   3197                          key_buffer, key_buffer_size,
   3198                          alg, hash, hash_length,
   3199                          signature, signature_size, signature_length);
   \       0x58   0x980E             LDR      R0,[SP, #+56]
   \       0x5A   0x9004             STR      R0,[SP, #+16]
   \       0x5C   0x980D             LDR      R0,[SP, #+52]
   \       0x5E   0x9003             STR      R0,[SP, #+12]
   \       0x60   0x980C             LDR      R0,[SP, #+48]
   \       0x62   0x9002             STR      R0,[SP, #+8]
   \       0x64   0x980B             LDR      R0,[SP, #+44]
   \       0x66   0x9001             STR      R0,[SP, #+4]
   \       0x68   0x980A             LDR      R0,[SP, #+40]
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0x003B             MOVS     R3,R7
   \       0x6E   0x0032             MOVS     R2,R6
   \       0x70   0x0029             MOVS     R1,R5
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0x.... 0x....      BL       mbedtls_psa_ecdsa_sign_hash
   \       0x78   0xE004             B.N      ??psa_sign_hash_builtin_2
   3200          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   3201                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) */
   3202                  } else {
   3203                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_sign_hash_builtin_3: (+1)
   \       0x7A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x7E   0xE001             B.N      ??psa_sign_hash_builtin_2
   3204                  }
   3205              }
   3206          
   3207              (void) key_buffer;
   3208              (void) key_buffer_size;
   3209              (void) hash;
   3210              (void) hash_length;
   3211              (void) signature;
   3212              (void) signature_size;
   3213              (void) signature_length;
   3214          
   3215              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_sign_hash_builtin_1: (+1)
   \       0x80   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_sign_hash_builtin_2: (+1)
   \       0x84   0xB005             ADD      SP,SP,#+20
   \       0x86   0xBDF0             POP      {R4-R7,PC}
   3216          }
   3217          

   \                                 In section .text, align 2, keep-with-next
   3218          psa_status_t psa_sign_hash(mbedtls_svc_key_id_t key,
   3219                                     psa_algorithm_t alg,
   3220                                     const uint8_t *hash,
   3221                                     size_t hash_length,
   3222                                     uint8_t *signature,
   3223                                     size_t signature_size,
   3224                                     size_t *signature_length)
   3225          {
   \                     psa_sign_hash: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3226              return psa_sign_internal(
   3227                  key, 0, alg, hash, hash_length,
   3228                  signature, signature_size, signature_length);
   \        0xC   0x980C             LDR      R0,[SP, #+48]
   \        0xE   0x9003             STR      R0,[SP, #+12]
   \       0x10   0x980B             LDR      R0,[SP, #+44]
   \       0x12   0x9002             STR      R0,[SP, #+8]
   \       0x14   0x980A             LDR      R0,[SP, #+40]
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x9700             STR      R7,[SP, #+0]
   \       0x1A   0x0033             MOVS     R3,R6
   \       0x1C   0x002A             MOVS     R2,R5
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       psa_sign_internal
   \       0x26   0xB005             ADD      SP,SP,#+20
   \       0x28   0xBDF0             POP      {R4-R7,PC}
   3229          }
   3230          

   \                                 In section .text, align 2, keep-with-next
   3231          psa_status_t psa_verify_hash_builtin(
   3232              const psa_key_attributes_t *attributes,
   3233              const uint8_t *key_buffer, size_t key_buffer_size,
   3234              psa_algorithm_t alg, const uint8_t *hash, size_t hash_length,
   3235              const uint8_t *signature, size_t signature_length)
   3236          {
   \                     psa_verify_hash_builtin: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3237              if (PSA_KEY_TYPE_IS_RSA(attributes->core.type)) {
   \        0xC   0x8821             LDRH     R1,[R4, #+0]
   \        0xE   0xF431 0x5140      BICS     R1,R1,#0x3000
   \       0x12   0xF244 0x0001      MOVW     R0,#+16385
   \       0x16   0x4281             CMP      R1,R0
   \       0x18   0xD114             BNE.N    ??psa_verify_hash_builtin_0
   3238                  if (PSA_ALG_IS_RSA_PKCS1V15_SIGN(alg) ||
   3239                      PSA_ALG_IS_RSA_PSS(alg)) {
   \       0x1A   0x0A39             LSRS     R1,R7,#+8
   \       0x1C   0x0209             LSLS     R1,R1,#+8
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \       0x22   0x4281             CMP      R1,R0
   \       0x24   0xD02C             BEQ.N    ??psa_verify_hash_builtin_1
   \       0x26   0x0A39             LSRS     R1,R7,#+8
   \       0x28   0x0209             LSLS     R1,R1,#+8
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable25
   \       0x2E   0x4281             CMP      R1,R0
   \       0x30   0xD026             BEQ.N    ??psa_verify_hash_builtin_1
   \       0x32   0x0A39             LSRS     R1,R7,#+8
   \       0x34   0x0209             LSLS     R1,R1,#+8
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \       0x3A   0x4281             CMP      R1,R0
   \       0x3C   0xD020             BEQ.N    ??psa_verify_hash_builtin_1
   3240          #if defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN) || \
   3241                      defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS)
   3242                      return mbedtls_psa_rsa_verify_hash(
   3243                          attributes,
   3244                          key_buffer, key_buffer_size,
   3245                          alg, hash, hash_length,
   3246                          signature, signature_length);
   3247          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN) ||
   3248                  * defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS) */
   3249                  } else {
   3250                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x3E   0xF07F 0x0086      MVNS     R0,#+134
   \       0x42   0xE01F             B.N      ??psa_verify_hash_builtin_2
   3251                  }
   3252              } else if (PSA_KEY_TYPE_IS_ECC(attributes->core.type)) {
   \                     ??psa_verify_hash_builtin_0: (+1)
   \       0x44   0x8821             LDRH     R1,[R4, #+0]
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable27
   \       0x4A   0x4001             ANDS     R1,R0,R1
   \       0x4C   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x50   0xD116             BNE.N    ??psa_verify_hash_builtin_1
   3253                  if (PSA_ALG_IS_ECDSA(alg)) {
   \       0x52   0x0A78             LSRS     R0,R7,#+9
   \       0x54   0x0240             LSLS     R0,R0,#+9
   \       0x56   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x5A   0xD10E             BNE.N    ??psa_verify_hash_builtin_3
   3254          #if defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   3255                      defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)
   3256                      return mbedtls_psa_ecdsa_verify_hash(
   3257                          attributes,
   3258                          key_buffer, key_buffer_size,
   3259                          alg, hash, hash_length,
   3260                          signature, signature_length);
   \       0x5C   0x980D             LDR      R0,[SP, #+52]
   \       0x5E   0x9003             STR      R0,[SP, #+12]
   \       0x60   0x980C             LDR      R0,[SP, #+48]
   \       0x62   0x9002             STR      R0,[SP, #+8]
   \       0x64   0x980B             LDR      R0,[SP, #+44]
   \       0x66   0x9001             STR      R0,[SP, #+4]
   \       0x68   0x980A             LDR      R0,[SP, #+40]
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0x003B             MOVS     R3,R7
   \       0x6E   0x0032             MOVS     R2,R6
   \       0x70   0x0029             MOVS     R1,R5
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0x.... 0x....      BL       mbedtls_psa_ecdsa_verify_hash
   \       0x78   0xE004             B.N      ??psa_verify_hash_builtin_2
   3261          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   3262                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) */
   3263                  } else {
   3264                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_verify_hash_builtin_3: (+1)
   \       0x7A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x7E   0xE001             B.N      ??psa_verify_hash_builtin_2
   3265                  }
   3266              }
   3267          
   3268              (void) key_buffer;
   3269              (void) key_buffer_size;
   3270              (void) hash;
   3271              (void) hash_length;
   3272              (void) signature;
   3273              (void) signature_length;
   3274          
   3275              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_verify_hash_builtin_1: (+1)
   \       0x80   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_verify_hash_builtin_2: (+1)
   \       0x84   0xB005             ADD      SP,SP,#+20
   \       0x86   0xBDF0             POP      {R4-R7,PC}
   3276          }
   3277          

   \                                 In section .text, align 2, keep-with-next
   3278          psa_status_t psa_verify_hash(mbedtls_svc_key_id_t key,
   3279                                       psa_algorithm_t alg,
   3280                                       const uint8_t *hash,
   3281                                       size_t hash_length,
   3282                                       const uint8_t *signature,
   3283                                       size_t signature_length)
   3284          {
   \                     psa_verify_hash: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   3285              return psa_verify_internal(
   3286                  key, 0, alg, hash, hash_length,
   3287                  signature, signature_length);
   \        0xA   0x9809             LDR      R0,[SP, #+36]
   \        0xC   0x9002             STR      R0,[SP, #+8]
   \        0xE   0x9808             LDR      R0,[SP, #+32]
   \       0x10   0x9001             STR      R0,[SP, #+4]
   \       0x12   0x9700             STR      R7,[SP, #+0]
   \       0x14   0x0033             MOVS     R3,R6
   \       0x16   0x002A             MOVS     R2,R5
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       psa_verify_internal
   \       0x20   0xBDFE             POP      {R1-R7,PC}
   3288          }
   3289          

   \                                 In section .text, align 2, keep-with-next
   3290          psa_status_t psa_asymmetric_encrypt(mbedtls_svc_key_id_t key,
   3291                                              psa_algorithm_t alg,
   3292                                              const uint8_t *input,
   3293                                              size_t input_length,
   3294                                              const uint8_t *salt,
   3295                                              size_t salt_length,
   3296                                              uint8_t *output,
   3297                                              size_t output_size,
   3298                                              size_t *output_length)
   3299          {
   \                     psa_asymmetric_encrypt: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB09B             SUB      SP,SP,#+108
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0x9C25             LDR      R4,[SP, #+148]
   \       0x10   0xF8DD 0x80A0      LDR      R8,[SP, #+160]
   3300              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x14   0xF07F 0x0096      MVNS     R0,#+150
   \       0x18   0x4683             MOV      R11,R0
   3301              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x1A   0x9008             STR      R0,[SP, #+32]
   3302              psa_key_slot_t *slot;
   3303              psa_key_attributes_t attributes;
   3304          
   3305              (void) input;
   3306              (void) input_length;
   3307              (void) salt;
   3308              (void) output;
   3309              (void) output_size;
   3310          
   3311              *output_length = 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xF8C8 0x0000      STR      R0,[R8, #+0]
   3312          
   3313              if (!PSA_ALG_IS_RSA_OAEP(alg) && salt_length != 0) {
   \       0x22   0xEA5F 0x2119      LSRS     R1,R9,#+8
   \       0x26   0x0209             LSLS     R1,R1,#+8
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable30
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD004             BEQ.N    ??psa_asymmetric_encrypt_0
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD002             BEQ.N    ??psa_asymmetric_encrypt_0
   3314                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x34   0xF07F 0x0086      MVNS     R0,#+134
   \       0x38   0xE047             B.N      ??psa_asymmetric_encrypt_1
   3315              }
   3316          
   3317              status = psa_get_and_lock_transparent_key_slot_with_policy(
   3318                  key, &slot, PSA_KEY_USAGE_ENCRYPT, alg);
   \                     ??psa_asymmetric_encrypt_0: (+1)
   \       0x3A   0x464B             MOV      R3,R9
   \       0x3C   0xF44F 0x7280      MOV      R2,#+256
   \       0x40   0xA907             ADD      R1,SP,#+28
   \       0x42   0x4650             MOV      R0,R10
   \       0x44   0x.... 0x....      BL       psa_get_and_lock_transparent_key_slot_with_policy
   \       0x48   0x0005             MOVS     R5,R0
   3319              if (status != PSA_SUCCESS) {
   \       0x4A   0x2D00             CMP      R5,#+0
   \       0x4C   0xD001             BEQ.N    ??psa_asymmetric_encrypt_2
   3320                  return status;
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0xE03B             B.N      ??psa_asymmetric_encrypt_1
   3321              }
   3322              if (!(PSA_KEY_TYPE_IS_PUBLIC_KEY(slot->attr.type) ||
   3323                    PSA_KEY_TYPE_IS_KEY_PAIR(slot->attr.type))) {
   \                     ??psa_asymmetric_encrypt_2: (+1)
   \       0x52   0x9807             LDR      R0,[SP, #+28]
   \       0x54   0x8800             LDRH     R0,[R0, #+0]
   \       0x56   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x5A   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x5E   0xD009             BEQ.N    ??psa_asymmetric_encrypt_3
   \       0x60   0x9807             LDR      R0,[SP, #+28]
   \       0x62   0x8800             LDRH     R0,[R0, #+0]
   \       0x64   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x68   0xF5B0 0x4FE0      CMP      R0,#+28672
   \       0x6C   0xD002             BEQ.N    ??psa_asymmetric_encrypt_3
   3324                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x6E   0xF07F 0x0B86      MVNS     R11,#+134
   3325                  goto exit;
   \       0x72   0xE021             B.N      ??psa_asymmetric_encrypt_4
   3326              }
   3327          
   3328              attributes = (psa_key_attributes_t) {
   3329                  .core = slot->attr
   3330              };
   \                     ??psa_asymmetric_encrypt_3: (+1)
   \       0x74   0xA809             ADD      R0,SP,#+36
   \       0x76   0x2124             MOVS     R1,#+36
   \       0x78   0x.... 0x....      BL       __aeabi_memclr4
   \       0x7C   0xA809             ADD      R0,SP,#+36
   \       0x7E   0x9907             LDR      R1,[SP, #+28]
   \       0x80   0x221C             MOVS     R2,#+28
   \       0x82   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x86   0xA812             ADD      R0,SP,#+72
   \       0x88   0xA909             ADD      R1,SP,#+36
   \       0x8A   0x2224             MOVS     R2,#+36
   \       0x8C   0x.... 0x....      BL       __aeabi_memcpy4
   3331          
   3332              status = psa_driver_wrapper_asymmetric_encrypt(
   3333                  &attributes, slot->key.data, slot->key.bytes,
   3334                  alg, input, input_length, salt, salt_length,
   3335                  output, output_size, output_length);
   \       0x90   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \       0x94   0x9827             LDR      R0,[SP, #+156]
   \       0x96   0x9005             STR      R0,[SP, #+20]
   \       0x98   0x9826             LDR      R0,[SP, #+152]
   \       0x9A   0x9004             STR      R0,[SP, #+16]
   \       0x9C   0x9403             STR      R4,[SP, #+12]
   \       0x9E   0x9824             LDR      R0,[SP, #+144]
   \       0xA0   0x9002             STR      R0,[SP, #+8]
   \       0xA2   0x9701             STR      R7,[SP, #+4]
   \       0xA4   0x9600             STR      R6,[SP, #+0]
   \       0xA6   0x464B             MOV      R3,R9
   \       0xA8   0x9807             LDR      R0,[SP, #+28]
   \       0xAA   0x6A82             LDR      R2,[R0, #+40]
   \       0xAC   0x9807             LDR      R0,[SP, #+28]
   \       0xAE   0x6A41             LDR      R1,[R0, #+36]
   \       0xB0   0xA812             ADD      R0,SP,#+72
   \       0xB2   0x.... 0x....      BL       psa_driver_wrapper_asymmetric_encrypt
   \       0xB6   0x4683             MOV      R11,R0
   3336          exit:
   3337              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_asymmetric_encrypt_4: (+1)
   \       0xB8   0x9807             LDR      R0,[SP, #+28]
   \       0xBA   0x.... 0x....      BL       psa_unlock_key_slot
   3338          
   3339              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0xBE   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xC2   0xD101             BNE.N    ??psa_asymmetric_encrypt_5
   \       0xC4   0x4683             MOV      R11,R0
   \       0xC6   0xE7FF             B.N      ??psa_asymmetric_encrypt_6
   \                     ??psa_asymmetric_encrypt_5: (+1)
   \                     ??psa_asymmetric_encrypt_6: (+1)
   \       0xC8   0x4658             MOV      R0,R11
   \                     ??psa_asymmetric_encrypt_1: (+1)
   \       0xCA   0xB01B             ADD      SP,SP,#+108
   \       0xCC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3340          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   3341          

   \                                 In section .text, align 2, keep-with-next
   3342          psa_status_t psa_asymmetric_decrypt(mbedtls_svc_key_id_t key,
   3343                                              psa_algorithm_t alg,
   3344                                              const uint8_t *input,
   3345                                              size_t input_length,
   3346                                              const uint8_t *salt,
   3347                                              size_t salt_length,
   3348                                              uint8_t *output,
   3349                                              size_t output_size,
   3350                                              size_t *output_length)
   3351          {
   \                     psa_asymmetric_decrypt: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB09B             SUB      SP,SP,#+108
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0x9C25             LDR      R4,[SP, #+148]
   \       0x10   0xF8DD 0x80A0      LDR      R8,[SP, #+160]
   3352              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x14   0xF07F 0x0096      MVNS     R0,#+150
   \       0x18   0x4683             MOV      R11,R0
   3353              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x1A   0x9008             STR      R0,[SP, #+32]
   3354              psa_key_slot_t *slot;
   3355              psa_key_attributes_t attributes;
   3356          
   3357              (void) input;
   3358              (void) input_length;
   3359              (void) salt;
   3360              (void) output;
   3361              (void) output_size;
   3362          
   3363              *output_length = 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xF8C8 0x0000      STR      R0,[R8, #+0]
   3364          
   3365              if (!PSA_ALG_IS_RSA_OAEP(alg) && salt_length != 0) {
   \       0x22   0xEA5F 0x2119      LSRS     R1,R9,#+8
   \       0x26   0x0209             LSLS     R1,R1,#+8
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable30
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD004             BEQ.N    ??psa_asymmetric_decrypt_0
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD002             BEQ.N    ??psa_asymmetric_decrypt_0
   3366                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x34   0xF07F 0x0086      MVNS     R0,#+134
   \       0x38   0xE040             B.N      ??psa_asymmetric_decrypt_1
   3367              }
   3368          
   3369              status = psa_get_and_lock_transparent_key_slot_with_policy(
   3370                  key, &slot, PSA_KEY_USAGE_DECRYPT, alg);
   \                     ??psa_asymmetric_decrypt_0: (+1)
   \       0x3A   0x464B             MOV      R3,R9
   \       0x3C   0xF44F 0x7200      MOV      R2,#+512
   \       0x40   0xA907             ADD      R1,SP,#+28
   \       0x42   0x4650             MOV      R0,R10
   \       0x44   0x.... 0x....      BL       psa_get_and_lock_transparent_key_slot_with_policy
   \       0x48   0x0005             MOVS     R5,R0
   3371              if (status != PSA_SUCCESS) {
   \       0x4A   0x2D00             CMP      R5,#+0
   \       0x4C   0xD001             BEQ.N    ??psa_asymmetric_decrypt_2
   3372                  return status;
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0xE034             B.N      ??psa_asymmetric_decrypt_1
   3373              }
   3374              if (!PSA_KEY_TYPE_IS_KEY_PAIR(slot->attr.type)) {
   \                     ??psa_asymmetric_decrypt_2: (+1)
   \       0x52   0x9807             LDR      R0,[SP, #+28]
   \       0x54   0x8800             LDRH     R0,[R0, #+0]
   \       0x56   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x5A   0xF5B0 0x4FE0      CMP      R0,#+28672
   \       0x5E   0xD002             BEQ.N    ??psa_asymmetric_decrypt_3
   3375                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x60   0xF07F 0x0B86      MVNS     R11,#+134
   3376                  goto exit;
   \       0x64   0xE021             B.N      ??psa_asymmetric_decrypt_4
   3377              }
   3378          
   3379              attributes = (psa_key_attributes_t) {
   3380                  .core = slot->attr
   3381              };
   \                     ??psa_asymmetric_decrypt_3: (+1)
   \       0x66   0xA809             ADD      R0,SP,#+36
   \       0x68   0x2124             MOVS     R1,#+36
   \       0x6A   0x.... 0x....      BL       __aeabi_memclr4
   \       0x6E   0xA809             ADD      R0,SP,#+36
   \       0x70   0x9907             LDR      R1,[SP, #+28]
   \       0x72   0x221C             MOVS     R2,#+28
   \       0x74   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x78   0xA812             ADD      R0,SP,#+72
   \       0x7A   0xA909             ADD      R1,SP,#+36
   \       0x7C   0x2224             MOVS     R2,#+36
   \       0x7E   0x.... 0x....      BL       __aeabi_memcpy4
   3382          
   3383              status = psa_driver_wrapper_asymmetric_decrypt(
   3384                  &attributes, slot->key.data, slot->key.bytes,
   3385                  alg, input, input_length, salt, salt_length,
   3386                  output, output_size, output_length);
   \       0x82   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \       0x86   0x9827             LDR      R0,[SP, #+156]
   \       0x88   0x9005             STR      R0,[SP, #+20]
   \       0x8A   0x9826             LDR      R0,[SP, #+152]
   \       0x8C   0x9004             STR      R0,[SP, #+16]
   \       0x8E   0x9403             STR      R4,[SP, #+12]
   \       0x90   0x9824             LDR      R0,[SP, #+144]
   \       0x92   0x9002             STR      R0,[SP, #+8]
   \       0x94   0x9701             STR      R7,[SP, #+4]
   \       0x96   0x9600             STR      R6,[SP, #+0]
   \       0x98   0x464B             MOV      R3,R9
   \       0x9A   0x9807             LDR      R0,[SP, #+28]
   \       0x9C   0x6A82             LDR      R2,[R0, #+40]
   \       0x9E   0x9807             LDR      R0,[SP, #+28]
   \       0xA0   0x6A41             LDR      R1,[R0, #+36]
   \       0xA2   0xA812             ADD      R0,SP,#+72
   \       0xA4   0x.... 0x....      BL       psa_driver_wrapper_asymmetric_decrypt
   \       0xA8   0x4683             MOV      R11,R0
   3387          
   3388          exit:
   3389              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_asymmetric_decrypt_4: (+1)
   \       0xAA   0x9807             LDR      R0,[SP, #+28]
   \       0xAC   0x.... 0x....      BL       psa_unlock_key_slot
   3390          
   3391              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0xB0   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xB4   0xD101             BNE.N    ??psa_asymmetric_decrypt_5
   \       0xB6   0x4683             MOV      R11,R0
   \       0xB8   0xE7FF             B.N      ??psa_asymmetric_decrypt_6
   \                     ??psa_asymmetric_decrypt_5: (+1)
   \                     ??psa_asymmetric_decrypt_6: (+1)
   \       0xBA   0x4658             MOV      R0,R11
   \                     ??psa_asymmetric_decrypt_1: (+1)
   \       0xBC   0xB01B             ADD      SP,SP,#+108
   \       0xBE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3392          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   3393          
   3394          /****************************************************************/
   3395          /* Asymmetric interruptible cryptography                        */
   3396          /****************************************************************/
   3397          

   \                                 In section .data, align 4
   3398          static uint32_t psa_interruptible_max_ops = PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED;
   \                     psa_interruptible_max_ops:
   \        0x0   0xFFFF'FFFF        DC32 4'294'967'295
   3399          

   \                                 In section .text, align 2, keep-with-next
   3400          void psa_interruptible_set_max_ops(uint32_t max_ops)
   3401          {
   3402              psa_interruptible_max_ops = max_ops;
   \                     psa_interruptible_set_max_ops: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable31
   \        0x4   0x6008             STR      R0,[R1, #+0]
   3403          }
   \        0x6   0x4770             BX       LR
   3404          

   \                                 In section .text, align 2, keep-with-next
   3405          uint32_t psa_interruptible_get_max_ops(void)
   3406          {
   3407              return psa_interruptible_max_ops;
   \                     psa_interruptible_get_max_ops: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable31
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
   3408          }
   3409          

   \                                 In section .text, align 2, keep-with-next
   3410          uint32_t psa_sign_hash_get_num_ops(
   3411              const psa_sign_hash_interruptible_operation_t *operation)
   3412          {
   3413              return operation->num_ops;
   \                     psa_sign_hash_get_num_ops: (+1)
   \        0x0   0x68C0             LDR      R0,[R0, #+12]
   \        0x2   0x4770             BX       LR
   3414          }
   3415          

   \                                 In section .text, align 2, keep-with-next
   3416          uint32_t psa_verify_hash_get_num_ops(
   3417              const psa_verify_hash_interruptible_operation_t *operation)
   3418          {
   3419              return operation->num_ops;
   \                     psa_verify_hash_get_num_ops: (+1)
   \        0x0   0x68C0             LDR      R0,[R0, #+12]
   \        0x2   0x4770             BX       LR
   3420          }
   3421          

   \                                 In section .text, align 2, keep-with-next
   3422          static psa_status_t psa_sign_hash_abort_internal(
   3423              psa_sign_hash_interruptible_operation_t *operation)
   3424          {
   \                     psa_sign_hash_abort_internal: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3425              if (operation->id == 0) {
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD101             BNE.N    ??psa_sign_hash_abort_internal_0
   3426                  /* The object has (apparently) been initialized but it is not (yet)
   3427                   * in use. It's ok to call abort on such an object, and there's
   3428                   * nothing to do. */
   3429                  return PSA_SUCCESS;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE006             B.N      ??psa_sign_hash_abort_internal_1
   3430              }
   3431          
   3432              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??psa_sign_hash_abort_internal_0: (+1)
   \        0xE   0xF07F 0x0596      MVNS     R5,#+150
   3433          
   3434              status = psa_driver_wrapper_sign_hash_abort(operation);
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       psa_driver_wrapper_sign_hash_abort
   3435          
   3436              operation->id = 0;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6021             STR      R1,[R4, #+0]
   3437          
   3438              /* Do not clear either the error_occurred or num_ops elements here as they
   3439               * only want to be cleared by the application calling abort, not by abort
   3440               * being called at completion of an operation. */
   3441          
   3442              return status;
   \                     ??psa_sign_hash_abort_internal_1: (+1)
   \       0x1C   0xBD32             POP      {R1,R4,R5,PC}
   3443          }
   3444          

   \                                 In section .text, align 2, keep-with-next
   3445          psa_status_t psa_sign_hash_start(
   3446              psa_sign_hash_interruptible_operation_t *operation,
   3447              mbedtls_svc_key_id_t key, psa_algorithm_t alg,
   3448              const uint8_t *hash, size_t hash_length)
   3449          {
   \                     psa_sign_hash_start: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB096             SUB      SP,SP,#+88
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   3450              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0x4644             MOV      R4,R8
   3451              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   3452              psa_key_slot_t *slot;
   3453              psa_key_attributes_t attributes;
   3454          
   3455              /* Check that start has not been previously called, or operation has not
   3456               * previously errored. */
   3457              if (operation->id != 0 || operation->error_occurred) {
   \       0x14   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD103             BNE.N    ??psa_sign_hash_start_0
   \       0x1C   0xF899 0x0008      LDRB     R0,[R9, #+8]
   \       0x20   0x07C0             LSLS     R0,R0,#+31
   \       0x22   0xD502             BPL.N    ??psa_sign_hash_start_1
   3458                  return PSA_ERROR_BAD_STATE;
   \                     ??psa_sign_hash_start_0: (+1)
   \       0x24   0xF07F 0x0088      MVNS     R0,#+136
   \       0x28   0xE05B             B.N      ??psa_sign_hash_start_2
   3459              }
   3460          
   3461              status = psa_sign_verify_check_alg(0, alg);
   \                     ??psa_sign_hash_start_1: (+1)
   \       0x2A   0x0031             MOVS     R1,R6
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x.... 0x....      BL       psa_sign_verify_check_alg
   \       0x32   0x4682             MOV      R10,R0
   3462              if (status != PSA_SUCCESS) {
   \       0x34   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x38   0xD007             BEQ.N    ??psa_sign_hash_start_3
   3463                  operation->error_occurred = 1;
   \       0x3A   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x3E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x42   0xF8C9 0x0008      STR      R0,[R9, #+8]
   3464                  return status;
   \       0x46   0x4650             MOV      R0,R10
   \       0x48   0xE04B             B.N      ??psa_sign_hash_start_2
   3465              }
   3466          
   3467              status = psa_get_and_lock_key_slot_with_policy(key, &slot,
   3468                                                             PSA_KEY_USAGE_SIGN_HASH,
   3469                                                             alg);
   \                     ??psa_sign_hash_start_3: (+1)
   \       0x4A   0x0033             MOVS     R3,R6
   \       0x4C   0xF44F 0x5280      MOV      R2,#+4096
   \       0x50   0xA903             ADD      R1,SP,#+12
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x58   0x0004             MOVS     R4,R0
   3470          
   3471              if (status != PSA_SUCCESS) {
   \       0x5A   0x2C00             CMP      R4,#+0
   \       0x5C   0xD128             BNE.N    ??psa_sign_hash_start_4
   3472                  goto exit;
   3473              }
   3474          
   3475              if (!PSA_KEY_TYPE_IS_KEY_PAIR(slot->attr.type)) {
   \                     ??psa_sign_hash_start_5: (+1)
   \       0x5E   0x9803             LDR      R0,[SP, #+12]
   \       0x60   0x8800             LDRH     R0,[R0, #+0]
   \       0x62   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x66   0xF5B0 0x4FE0      CMP      R0,#+28672
   \       0x6A   0xD003             BEQ.N    ??psa_sign_hash_start_6
   3476                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x6C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x70   0x0004             MOVS     R4,R0
   3477                  goto exit;
   \       0x72   0xE01D             B.N      ??psa_sign_hash_start_4
   3478              }
   3479          
   3480              attributes = (psa_key_attributes_t) {
   3481                  .core = slot->attr
   3482              };
   \                     ??psa_sign_hash_start_6: (+1)
   \       0x74   0xA804             ADD      R0,SP,#+16
   \       0x76   0x2124             MOVS     R1,#+36
   \       0x78   0x.... 0x....      BL       __aeabi_memclr4
   \       0x7C   0xA804             ADD      R0,SP,#+16
   \       0x7E   0x9903             LDR      R1,[SP, #+12]
   \       0x80   0x221C             MOVS     R2,#+28
   \       0x82   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x86   0xA80D             ADD      R0,SP,#+52
   \       0x88   0xA904             ADD      R1,SP,#+16
   \       0x8A   0x2224             MOVS     R2,#+36
   \       0x8C   0x.... 0x....      BL       __aeabi_memcpy4
   3483          
   3484              /* Ensure ops count gets reset, in case of operation re-use. */
   3485              operation->num_ops = 0;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xF8C9 0x000C      STR      R0,[R9, #+12]
   3486          
   3487              status = psa_driver_wrapper_sign_hash_start(operation, &attributes,
   3488                                                          slot->key.data,
   3489                                                          slot->key.bytes, alg,
   3490                                                          hash, hash_length);
   \       0x96   0x981E             LDR      R0,[SP, #+120]
   \       0x98   0x9002             STR      R0,[SP, #+8]
   \       0x9A   0x9701             STR      R7,[SP, #+4]
   \       0x9C   0x9600             STR      R6,[SP, #+0]
   \       0x9E   0x9803             LDR      R0,[SP, #+12]
   \       0xA0   0x6A83             LDR      R3,[R0, #+40]
   \       0xA2   0x9803             LDR      R0,[SP, #+12]
   \       0xA4   0x6A42             LDR      R2,[R0, #+36]
   \       0xA6   0xA90D             ADD      R1,SP,#+52
   \       0xA8   0x4648             MOV      R0,R9
   \       0xAA   0x.... 0x....      BL       psa_driver_wrapper_sign_hash_start
   \       0xAE   0x0004             MOVS     R4,R0
   3491          exit:
   3492          
   3493              if (status != PSA_SUCCESS) {
   \                     ??psa_sign_hash_start_4: (+1)
   \       0xB0   0x2C00             CMP      R4,#+0
   \       0xB2   0xD008             BEQ.N    ??psa_sign_hash_start_7
   3494                  operation->error_occurred = 1;
   \       0xB4   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0xB8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xBC   0xF8C9 0x0008      STR      R0,[R9, #+8]
   3495                  psa_sign_hash_abort_internal(operation);
   \       0xC0   0x4648             MOV      R0,R9
   \       0xC2   0x.... 0x....      BL       psa_sign_hash_abort_internal
   3496              }
   3497          
   3498              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_sign_hash_start_7: (+1)
   \       0xC6   0x9803             LDR      R0,[SP, #+12]
   \       0xC8   0x.... 0x....      BL       psa_unlock_key_slot
   3499          
   3500              if (unlock_status != PSA_SUCCESS) {
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD005             BEQ.N    ??psa_sign_hash_start_8
   3501                  operation->error_occurred = 1;
   \       0xD0   0xF8D9 0x1008      LDR      R1,[R9, #+8]
   \       0xD4   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0xD8   0xF8C9 0x1008      STR      R1,[R9, #+8]
   3502              }
   3503          
   3504              return (status == PSA_SUCCESS) ? unlock_status : status;
   \                     ??psa_sign_hash_start_8: (+1)
   \       0xDC   0x2C00             CMP      R4,#+0
   \       0xDE   0xD000             BEQ.N    ??psa_sign_hash_start_9
   \                     ??psa_sign_hash_start_10: (+1)
   \       0xE0   0x0020             MOVS     R0,R4
   \                     ??psa_sign_hash_start_9: (+1)
   \                     ??psa_sign_hash_start_2: (+1)
   \       0xE2   0xB016             ADD      SP,SP,#+88
   \       0xE4   0xE8BD 0x87F0      POP      {R4-R10,PC}
   3505          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   3506          
   3507          

   \                                 In section .text, align 2, keep-with-next
   3508          psa_status_t psa_sign_hash_complete(
   3509              psa_sign_hash_interruptible_operation_t *operation,
   3510              uint8_t *signature, size_t signature_size,
   3511              size_t *signature_length)
   3512          {
   \                     psa_sign_hash_complete: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x4698             MOV      R8,R3
   3513              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x0996      MVNS     R9,#+150
   3514          
   3515              *signature_length = 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xF8C8 0x0000      STR      R0,[R8, #+0]
   3516          
   3517              /* Check that start has been called first, and that operation has not
   3518               * previously errored. */
   3519              if (operation->id == 0 || operation->error_occurred) {
   \       0x16   0x6830             LDR      R0,[R6, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD002             BEQ.N    ??psa_sign_hash_complete_0
   \       0x1C   0x7A30             LDRB     R0,[R6, #+8]
   \       0x1E   0x07C0             LSLS     R0,R0,#+31
   \       0x20   0xD502             BPL.N    ??psa_sign_hash_complete_1
   3520                  status = PSA_ERROR_BAD_STATE;
   \                     ??psa_sign_hash_complete_0: (+1)
   \       0x22   0xF07F 0x0588      MVNS     R5,#+136
   3521                  goto exit;
   \       0x26   0xE00F             B.N      ??psa_sign_hash_complete_2
   3522              }
   3523          
   3524              /* Immediately reject a zero-length signature buffer. This guarantees that
   3525               * signature must be a valid pointer. */
   3526              if (signature_size == 0) {
   \                     ??psa_sign_hash_complete_1: (+1)
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD102             BNE.N    ??psa_sign_hash_complete_3
   3527                  status = PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x2C   0xF07F 0x0589      MVNS     R5,#+137
   3528                  goto exit;
   \       0x30   0xE00A             B.N      ??psa_sign_hash_complete_2
   3529              }
   3530          
   3531              status = psa_driver_wrapper_sign_hash_complete(operation, signature,
   3532                                                             signature_size,
   3533                                                             signature_length);
   \                     ??psa_sign_hash_complete_3: (+1)
   \       0x32   0x4643             MOV      R3,R8
   \       0x34   0x0022             MOVS     R2,R4
   \       0x36   0x0039             MOVS     R1,R7
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0x.... 0x....      BL       psa_driver_wrapper_sign_hash_complete
   \       0x3E   0x0005             MOVS     R5,R0
   3534          
   3535              /* Update ops count with work done. */
   3536              operation->num_ops = psa_driver_wrapper_sign_hash_get_num_ops(operation);
   \       0x40   0x0030             MOVS     R0,R6
   \       0x42   0x.... 0x....      BL       psa_driver_wrapper_sign_hash_get_num_ops
   \       0x46   0x60F0             STR      R0,[R6, #+12]
   3537          
   3538          exit:
   3539          
   3540              psa_wipe_tag_output_buffer(signature, status, signature_size,
   3541                                         *signature_length);
   \                     ??psa_sign_hash_complete_2: (+1)
   \       0x48   0xF8D8 0x3000      LDR      R3,[R8, #+0]
   \       0x4C   0x0022             MOVS     R2,R4
   \       0x4E   0x0029             MOVS     R1,R5
   \       0x50   0x0038             MOVS     R0,R7
   \       0x52   0x.... 0x....      BL       psa_wipe_tag_output_buffer
   3542          
   3543              if (status != PSA_OPERATION_INCOMPLETE) {
   \       0x56   0xF115 0x0FF8      CMN      R5,#+248
   \       0x5A   0xD008             BEQ.N    ??psa_sign_hash_complete_4
   3544                  if (status != PSA_SUCCESS) {
   \       0x5C   0x2D00             CMP      R5,#+0
   \       0x5E   0xD003             BEQ.N    ??psa_sign_hash_complete_5
   3545                      operation->error_occurred = 1;
   \       0x60   0x68B0             LDR      R0,[R6, #+8]
   \       0x62   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x66   0x60B0             STR      R0,[R6, #+8]
   3546                  }
   3547          
   3548                  psa_sign_hash_abort_internal(operation);
   \                     ??psa_sign_hash_complete_5: (+1)
   \       0x68   0x0030             MOVS     R0,R6
   \       0x6A   0x.... 0x....      BL       psa_sign_hash_abort_internal
   3549              }
   3550          
   3551              return status;
   \                     ??psa_sign_hash_complete_4: (+1)
   \       0x6E   0x0028             MOVS     R0,R5
   \       0x70   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   3552          }
   3553          

   \                                 In section .text, align 2, keep-with-next
   3554          psa_status_t psa_sign_hash_abort(
   3555              psa_sign_hash_interruptible_operation_t *operation)
   3556          {
   \                     psa_sign_hash_abort: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3557              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x0596      MVNS     R5,#+150
   3558          
   3559              status = psa_sign_hash_abort_internal(operation);
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       psa_sign_hash_abort_internal
   3560          
   3561              /* We clear the number of ops done here, so that it is not cleared when
   3562               * the operation fails or succeeds, only on manual abort. */
   3563              operation->num_ops = 0;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x60E1             STR      R1,[R4, #+12]
   3564          
   3565              /* Likewise, failure state. */
   3566              operation->error_occurred = 0;
   \       0x12   0x68A1             LDR      R1,[R4, #+8]
   \       0x14   0x0849             LSRS     R1,R1,#+1
   \       0x16   0x0049             LSLS     R1,R1,#+1
   \       0x18   0x60A1             STR      R1,[R4, #+8]
   3567          
   3568              return status;
   \       0x1A   0xBD32             POP      {R1,R4,R5,PC}
   3569          }
   3570          

   \                                 In section .text, align 2, keep-with-next
   3571          static psa_status_t psa_verify_hash_abort_internal(
   3572              psa_verify_hash_interruptible_operation_t *operation)
   3573          {
   \                     psa_verify_hash_abort_internal: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3574              if (operation->id == 0) {
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD101             BNE.N    ??psa_verify_hash_abort_internal_0
   3575                  /* The object has (apparently) been initialized but it is not (yet)
   3576                   * in use. It's ok to call abort on such an object, and there's
   3577                   * nothing to do. */
   3578                  return PSA_SUCCESS;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE006             B.N      ??psa_verify_hash_abort_internal_1
   3579              }
   3580          
   3581              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??psa_verify_hash_abort_internal_0: (+1)
   \        0xE   0xF07F 0x0596      MVNS     R5,#+150
   3582          
   3583              status = psa_driver_wrapper_verify_hash_abort(operation);
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       psa_driver_wrapper_verify_hash_abort
   3584          
   3585              operation->id = 0;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6021             STR      R1,[R4, #+0]
   3586          
   3587              /* Do not clear either the error_occurred or num_ops elements here as they
   3588               * only want to be cleared by the application calling abort, not by abort
   3589               * being called at completion of an operation. */
   3590          
   3591              return status;
   \                     ??psa_verify_hash_abort_internal_1: (+1)
   \       0x1C   0xBD32             POP      {R1,R4,R5,PC}
   3592          }
   3593          

   \                                 In section .text, align 2, keep-with-next
   3594          psa_status_t psa_verify_hash_start(
   3595              psa_verify_hash_interruptible_operation_t *operation,
   3596              mbedtls_svc_key_id_t key, psa_algorithm_t alg,
   3597              const uint8_t *hash, size_t hash_length,
   3598              const uint8_t *signature, size_t signature_length)
   3599          {
   \                     psa_verify_hash_start: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   3600              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   \       0x12   0x4644             MOV      R4,R8
   3601              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   3602              psa_key_slot_t *slot;
   3603          
   3604              /* Check that start has not been previously called, or operation has not
   3605               * previously errored. */
   3606              if (operation->id != 0 || operation->error_occurred) {
   \       0x14   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD103             BNE.N    ??psa_verify_hash_start_0
   \       0x1C   0xF899 0x0008      LDRB     R0,[R9, #+8]
   \       0x20   0x07C0             LSLS     R0,R0,#+31
   \       0x22   0xD502             BPL.N    ??psa_verify_hash_start_1
   3607                  return PSA_ERROR_BAD_STATE;
   \                     ??psa_verify_hash_start_0: (+1)
   \       0x24   0xF07F 0x0088      MVNS     R0,#+136
   \       0x28   0xE05B             B.N      ??psa_verify_hash_start_2
   3608              }
   3609          
   3610              status = psa_sign_verify_check_alg(0, alg);
   \                     ??psa_verify_hash_start_1: (+1)
   \       0x2A   0x0031             MOVS     R1,R6
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x.... 0x....      BL       psa_sign_verify_check_alg
   \       0x32   0x4682             MOV      R10,R0
   3611              if (status != PSA_SUCCESS) {
   \       0x34   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x38   0xD007             BEQ.N    ??psa_verify_hash_start_3
   3612                  operation->error_occurred = 1;
   \       0x3A   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x3E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x42   0xF8C9 0x0008      STR      R0,[R9, #+8]
   3613                  return status;
   \       0x46   0x4650             MOV      R0,R10
   \       0x48   0xE04B             B.N      ??psa_verify_hash_start_2
   3614              }
   3615          
   3616              status = psa_get_and_lock_key_slot_with_policy(key, &slot,
   3617                                                             PSA_KEY_USAGE_VERIFY_HASH,
   3618                                                             alg);
   \                     ??psa_verify_hash_start_3: (+1)
   \       0x4A   0x0033             MOVS     R3,R6
   \       0x4C   0xF44F 0x5200      MOV      R2,#+8192
   \       0x50   0xA905             ADD      R1,SP,#+20
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x58   0x0004             MOVS     R4,R0
   3619          
   3620              if (status != PSA_SUCCESS) {
   \       0x5A   0x2C00             CMP      R4,#+0
   \       0x5C   0xD007             BEQ.N    ??psa_verify_hash_start_4
   3621                  operation->error_occurred = 1;
   \       0x5E   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x62   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x66   0xF8C9 0x0008      STR      R0,[R9, #+8]
   3622                  return status;
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0xE039             B.N      ??psa_verify_hash_start_2
   3623              }
   3624          
   3625              psa_key_attributes_t attributes = {
   3626                  .core = slot->attr
   3627              };
   \                     ??psa_verify_hash_start_4: (+1)
   \       0x6E   0xA806             ADD      R0,SP,#+24
   \       0x70   0x2124             MOVS     R1,#+36
   \       0x72   0x.... 0x....      BL       __aeabi_memclr4
   \       0x76   0xA806             ADD      R0,SP,#+24
   \       0x78   0x9905             LDR      R1,[SP, #+20]
   \       0x7A   0x221C             MOVS     R2,#+28
   \       0x7C   0x.... 0x....      BL       __aeabi_memcpy4
   3628          
   3629              /* Ensure ops count gets reset, in case of operation re-use. */
   3630              operation->num_ops = 0;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xF8C9 0x000C      STR      R0,[R9, #+12]
   3631          
   3632              status = psa_driver_wrapper_verify_hash_start(operation, &attributes,
   3633                                                            slot->key.data,
   3634                                                            slot->key.bytes,
   3635                                                            alg, hash, hash_length,
   3636                                                            signature, signature_length);
   \       0x86   0x981A             LDR      R0,[SP, #+104]
   \       0x88   0x9004             STR      R0,[SP, #+16]
   \       0x8A   0x9819             LDR      R0,[SP, #+100]
   \       0x8C   0x9003             STR      R0,[SP, #+12]
   \       0x8E   0x9818             LDR      R0,[SP, #+96]
   \       0x90   0x9002             STR      R0,[SP, #+8]
   \       0x92   0x9701             STR      R7,[SP, #+4]
   \       0x94   0x9600             STR      R6,[SP, #+0]
   \       0x96   0x9805             LDR      R0,[SP, #+20]
   \       0x98   0x6A83             LDR      R3,[R0, #+40]
   \       0x9A   0x9805             LDR      R0,[SP, #+20]
   \       0x9C   0x6A42             LDR      R2,[R0, #+36]
   \       0x9E   0xA906             ADD      R1,SP,#+24
   \       0xA0   0x4648             MOV      R0,R9
   \       0xA2   0x.... 0x....      BL       psa_driver_wrapper_verify_hash_start
   \       0xA6   0x4682             MOV      R10,R0
   3637          
   3638              if (status != PSA_SUCCESS) {
   \       0xA8   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xAC   0xD008             BEQ.N    ??psa_verify_hash_start_5
   3639                  operation->error_occurred = 1;
   \       0xAE   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0xB2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xB6   0xF8C9 0x0008      STR      R0,[R9, #+8]
   3640                  psa_verify_hash_abort_internal(operation);
   \       0xBA   0x4648             MOV      R0,R9
   \       0xBC   0x.... 0x....      BL       psa_verify_hash_abort_internal
   3641              }
   3642          
   3643              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_verify_hash_start_5: (+1)
   \       0xC0   0x9805             LDR      R0,[SP, #+20]
   \       0xC2   0x.... 0x....      BL       psa_unlock_key_slot
   3644          
   3645              if (unlock_status != PSA_SUCCESS) {
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD005             BEQ.N    ??psa_verify_hash_start_6
   3646                  operation->error_occurred = 1;
   \       0xCA   0xF8D9 0x1008      LDR      R1,[R9, #+8]
   \       0xCE   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0xD2   0xF8C9 0x1008      STR      R1,[R9, #+8]
   3647              }
   3648          
   3649              return (status == PSA_SUCCESS) ? unlock_status : status;
   \                     ??psa_verify_hash_start_6: (+1)
   \       0xD6   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xDA   0xD101             BNE.N    ??psa_verify_hash_start_7
   \       0xDC   0x4682             MOV      R10,R0
   \       0xDE   0xE7FF             B.N      ??psa_verify_hash_start_8
   \                     ??psa_verify_hash_start_7: (+1)
   \                     ??psa_verify_hash_start_8: (+1)
   \       0xE0   0x4650             MOV      R0,R10
   \                     ??psa_verify_hash_start_2: (+1)
   \       0xE2   0xB010             ADD      SP,SP,#+64
   \       0xE4   0xE8BD 0x87F0      POP      {R4-R10,PC}
   3650          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   3651          

   \                                 In section .text, align 2, keep-with-next
   3652          psa_status_t psa_verify_hash_complete(
   3653              psa_verify_hash_interruptible_operation_t *operation)
   3654          {
   \                     psa_verify_hash_complete: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   3655              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x0696      MVNS     R6,#+150
   3656          
   3657              /* Check that start has been called first, and that operation has not
   3658               * previously errored. */
   3659              if (operation->id == 0 || operation->error_occurred) {
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD002             BEQ.N    ??psa_verify_hash_complete_0
   \        0xE   0x7A28             LDRB     R0,[R5, #+8]
   \       0x10   0x07C0             LSLS     R0,R0,#+31
   \       0x12   0xD502             BPL.N    ??psa_verify_hash_complete_1
   3660                  status = PSA_ERROR_BAD_STATE;
   \                     ??psa_verify_hash_complete_0: (+1)
   \       0x14   0xF07F 0x0488      MVNS     R4,#+136
   3661                  goto exit;
   \       0x18   0xE007             B.N      ??psa_verify_hash_complete_2
   3662              }
   3663          
   3664              status = psa_driver_wrapper_verify_hash_complete(operation);
   \                     ??psa_verify_hash_complete_1: (+1)
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0x.... 0x....      BL       psa_driver_wrapper_verify_hash_complete
   \       0x20   0x0004             MOVS     R4,R0
   3665          
   3666              /* Update ops count with work done. */
   3667              operation->num_ops = psa_driver_wrapper_verify_hash_get_num_ops(
   3668                  operation);
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       psa_driver_wrapper_verify_hash_get_num_ops
   \       0x28   0x60E8             STR      R0,[R5, #+12]
   3669          
   3670          exit:
   3671          
   3672              if (status != PSA_OPERATION_INCOMPLETE) {
   \                     ??psa_verify_hash_complete_2: (+1)
   \       0x2A   0xF114 0x0FF8      CMN      R4,#+248
   \       0x2E   0xD008             BEQ.N    ??psa_verify_hash_complete_3
   3673                  if (status != PSA_SUCCESS) {
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD003             BEQ.N    ??psa_verify_hash_complete_4
   3674                      operation->error_occurred = 1;
   \       0x34   0x68A8             LDR      R0,[R5, #+8]
   \       0x36   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x3A   0x60A8             STR      R0,[R5, #+8]
   3675                  }
   3676          
   3677                  psa_verify_hash_abort_internal(operation);
   \                     ??psa_verify_hash_complete_4: (+1)
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x.... 0x....      BL       psa_verify_hash_abort_internal
   3678              }
   3679          
   3680              return status;
   \                     ??psa_verify_hash_complete_3: (+1)
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0xBD70             POP      {R4-R6,PC}
   3681          }
   3682          

   \                                 In section .text, align 2, keep-with-next
   3683          psa_status_t psa_verify_hash_abort(
   3684              psa_verify_hash_interruptible_operation_t *operation)
   3685          {
   \                     psa_verify_hash_abort: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3686              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x0596      MVNS     R5,#+150
   3687          
   3688              status = psa_verify_hash_abort_internal(operation);
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       psa_verify_hash_abort_internal
   3689          
   3690              /* We clear the number of ops done here, so that it is not cleared when
   3691               * the operation fails or succeeds, only on manual abort. */
   3692              operation->num_ops = 0;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x60E1             STR      R1,[R4, #+12]
   3693          
   3694              /* Likewise, failure state. */
   3695              operation->error_occurred = 0;
   \       0x12   0x68A1             LDR      R1,[R4, #+8]
   \       0x14   0x0849             LSRS     R1,R1,#+1
   \       0x16   0x0049             LSLS     R1,R1,#+1
   \       0x18   0x60A1             STR      R1,[R4, #+8]
   3696          
   3697              return status;
   \       0x1A   0xBD32             POP      {R1,R4,R5,PC}
   3698          }
   3699          
   3700          /****************************************************************/
   3701          /* Asymmetric interruptible cryptography internal               */
   3702          /* implementations                                              */
   3703          /****************************************************************/
   3704          

   \                                 In section .text, align 2, keep-with-next
   3705          void mbedtls_psa_interruptible_set_max_ops(uint32_t max_ops)
   3706          {
   3707          
   3708          #if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   3709              defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
   3710              defined(MBEDTLS_ECP_RESTARTABLE)
   3711          
   3712              /* Internal implementation uses zero to indicate infinite number max ops,
   3713               * therefore avoid this value, and set to minimum possible. */
   3714              if (max_ops == 0) {
   3715                  max_ops = 1;
   3716              }
   3717          
   3718              mbedtls_ecp_set_max_ops(max_ops);
   3719          #else
   3720              (void) max_ops;
   3721          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   3722                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
   3723                  * defined( MBEDTLS_ECP_RESTARTABLE ) */
   3724          }
   \                     mbedtls_psa_interruptible_set_max_ops: (+1)
   \        0x0   0x4770             BX       LR
   3725          

   \                                 In section .text, align 2, keep-with-next
   3726          uint32_t mbedtls_psa_sign_hash_get_num_ops(
   3727              const mbedtls_psa_sign_hash_interruptible_operation_t *operation)
   3728          {
   \                     mbedtls_psa_sign_hash_get_num_ops: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   3729          #if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   3730              defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
   3731              defined(MBEDTLS_ECP_RESTARTABLE)
   3732          
   3733              return operation->num_ops;
   3734          #else
   3735              (void) operation;
   3736              return 0;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x4770             BX       LR
   3737          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   3738                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
   3739                  * defined( MBEDTLS_ECP_RESTARTABLE ) */
   3740          }
   3741          

   \                                 In section .text, align 2, keep-with-next
   3742          uint32_t mbedtls_psa_verify_hash_get_num_ops(
   3743              const mbedtls_psa_verify_hash_interruptible_operation_t *operation)
   3744          {
   \                     mbedtls_psa_verify_hash_get_num_ops: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   3745              #if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   3746              defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
   3747              defined(MBEDTLS_ECP_RESTARTABLE)
   3748          
   3749              return operation->num_ops;
   3750          #else
   3751              (void) operation;
   3752              return 0;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x4770             BX       LR
   3753          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   3754                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
   3755                  * defined( MBEDTLS_ECP_RESTARTABLE ) */
   3756          }
   3757          

   \                                 In section .text, align 2, keep-with-next
   3758          psa_status_t mbedtls_psa_sign_hash_start(
   3759              mbedtls_psa_sign_hash_interruptible_operation_t *operation,
   3760              const psa_key_attributes_t *attributes, const uint8_t *key_buffer,
   3761              size_t key_buffer_size, psa_algorithm_t alg,
   3762              const uint8_t *hash, size_t hash_length)
   3763          {
   \                     mbedtls_psa_sign_hash_start: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x9D04             LDR      R5,[SP, #+16]
   3764              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x0696      MVNS     R6,#+150
   3765              size_t required_hash_length = 0;
   \        0xA   0x2700             MOVS     R7,#+0
   3766          
   3767              if (!PSA_KEY_TYPE_IS_ECC(attributes->core.type)) {
   \        0xC   0xF8B1 0xC000      LDRH     R12,[R1, #+0]
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable27
   \       0x14   0xEA10 0x0C0C      ANDS     R12,R0,R12
   \       0x18   0xF5BC 0x4F82      CMP      R12,#+16640
   \       0x1C   0xD002             BEQ.N    ??mbedtls_psa_sign_hash_start_0
   3768                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x1E   0xF07F 0x0085      MVNS     R0,#+133
   \       0x22   0xE009             B.N      ??mbedtls_psa_sign_hash_start_1
   3769              }
   3770          
   3771              if (!PSA_ALG_IS_ECDSA(alg)) {
   \                     ??mbedtls_psa_sign_hash_start_0: (+1)
   \       0x24   0x0A68             LSRS     R0,R5,#+9
   \       0x26   0x0240             LSLS     R0,R0,#+9
   \       0x28   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x2C   0xD002             BEQ.N    ??mbedtls_psa_sign_hash_start_2
   3772                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x2E   0xF07F 0x0085      MVNS     R0,#+133
   \       0x32   0xE001             B.N      ??mbedtls_psa_sign_hash_start_1
   3773              }
   3774          
   3775          #if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   3776              defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
   3777              defined(MBEDTLS_ECP_RESTARTABLE)
   3778          
   3779              mbedtls_ecdsa_restart_init(&operation->restart_ctx);
   3780          
   3781              /* Ensure num_ops is zero'ed in case of context re-use. */
   3782              operation->num_ops = 0;
   3783          
   3784              status = mbedtls_psa_ecp_load_representation(attributes->core.type,
   3785                                                           attributes->core.bits,
   3786                                                           key_buffer,
   3787                                                           key_buffer_size,
   3788                                                           &operation->ctx);
   3789          
   3790              if (status != PSA_SUCCESS) {
   3791                  return status;
   3792              }
   3793          
   3794              operation->coordinate_bytes = PSA_BITS_TO_BYTES(
   3795                  operation->ctx->grp.nbits);
   3796          
   3797              psa_algorithm_t hash_alg = PSA_ALG_SIGN_GET_HASH(alg);
   3798              operation->md_alg = mbedtls_md_type_from_psa_alg(hash_alg);
   3799              operation->alg = alg;
   3800          
   3801              /* We only need to store the same length of hash as the private key size
   3802               * here, it would be truncated by the internal implementation anyway. */
   3803              required_hash_length = (hash_length < operation->coordinate_bytes ?
   3804                                      hash_length : operation->coordinate_bytes);
   3805          
   3806              if (required_hash_length > sizeof(operation->hash)) {
   3807                  /* Shouldn't happen, but better safe than sorry. */
   3808                  return PSA_ERROR_CORRUPTION_DETECTED;
   3809              }
   3810          
   3811              memcpy(operation->hash, hash, required_hash_length);
   3812              operation->hash_length = required_hash_length;
   3813          
   3814              return PSA_SUCCESS;
   3815          
   3816          #else
   3817              (void) operation;
   3818              (void) key_buffer;
   3819              (void) key_buffer_size;
   3820              (void) alg;
   3821              (void) hash;
   3822              (void) hash_length;
   3823              (void) status;
   3824              (void) required_hash_length;
   3825          
   3826              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_psa_sign_hash_start_2: (+1)
   \       0x34   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??mbedtls_psa_sign_hash_start_1: (+1)
   \       0x38   0xBCF0             POP      {R4-R7}
   \       0x3A   0x4770             BX       LR
   3827          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   3828                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
   3829                  * defined( MBEDTLS_ECP_RESTARTABLE ) */
   3830          }
   3831          

   \                                 In section .text, align 2, keep-with-next
   3832          psa_status_t mbedtls_psa_sign_hash_complete(
   3833              mbedtls_psa_sign_hash_interruptible_operation_t *operation,
   3834              uint8_t *signature, size_t signature_size,
   3835              size_t *signature_length)
   3836          {
   \                     mbedtls_psa_sign_hash_complete: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0004             MOVS     R4,R0
   3837          #if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   3838              defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
   3839              defined(MBEDTLS_ECP_RESTARTABLE)
   3840          
   3841              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   3842              mbedtls_mpi r;
   3843              mbedtls_mpi s;
   3844          
   3845              mbedtls_mpi_init(&r);
   3846              mbedtls_mpi_init(&s);
   3847          
   3848              /* Ensure max_ops is set to the current value (or default). */
   3849              mbedtls_psa_interruptible_set_max_ops(psa_interruptible_get_max_ops());
   3850          
   3851              if (signature_size < 2 * operation->coordinate_bytes) {
   3852                  status = PSA_ERROR_BUFFER_TOO_SMALL;
   3853                  goto exit;
   3854              }
   3855          
   3856              if (PSA_ALG_ECDSA_IS_DETERMINISTIC(operation->alg)) {
   3857          
   3858          #if defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)
   3859                  status = mbedtls_to_psa_error(
   3860                      mbedtls_ecdsa_sign_det_restartable(&operation->ctx->grp,
   3861                                                         &r,
   3862                                                         &s,
   3863                                                         &operation->ctx->d,
   3864                                                         operation->hash,
   3865                                                         operation->hash_length,
   3866                                                         operation->md_alg,
   3867                                                         mbedtls_psa_get_random,
   3868                                                         MBEDTLS_PSA_RANDOM_STATE,
   3869                                                         &operation->restart_ctx));
   3870          #else /* defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) */
   3871                  status = PSA_ERROR_NOT_SUPPORTED;
   3872                  goto exit;
   3873          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) */
   3874              } else {
   3875                  status = mbedtls_to_psa_error(
   3876                      mbedtls_ecdsa_sign_restartable(&operation->ctx->grp,
   3877                                                     &r,
   3878                                                     &s,
   3879                                                     &operation->ctx->d,
   3880                                                     operation->hash,
   3881                                                     operation->hash_length,
   3882                                                     mbedtls_psa_get_random,
   3883                                                     MBEDTLS_PSA_RANDOM_STATE,
   3884                                                     mbedtls_psa_get_random,
   3885                                                     MBEDTLS_PSA_RANDOM_STATE,
   3886                                                     &operation->restart_ctx));
   3887              }
   3888          
   3889              /* Hide the fact that the restart context only holds a delta of number of
   3890               * ops done during the last operation, not an absolute value. */
   3891              operation->num_ops += operation->restart_ctx.ecp.ops_done;
   3892          
   3893              if (status == PSA_SUCCESS) {
   3894                  status =  mbedtls_to_psa_error(
   3895                      mbedtls_mpi_write_binary(&r,
   3896                                               signature,
   3897                                               operation->coordinate_bytes)
   3898                      );
   3899          
   3900                  if (status != PSA_SUCCESS) {
   3901                      goto exit;
   3902                  }
   3903          
   3904                  status =  mbedtls_to_psa_error(
   3905                      mbedtls_mpi_write_binary(&s,
   3906                                               signature +
   3907                                               operation->coordinate_bytes,
   3908                                               operation->coordinate_bytes)
   3909                      );
   3910          
   3911                  if (status != PSA_SUCCESS) {
   3912                      goto exit;
   3913                  }
   3914          
   3915                  *signature_length = operation->coordinate_bytes * 2;
   3916          
   3917                  status = PSA_SUCCESS;
   3918              }
   3919          
   3920          exit:
   3921          
   3922              mbedtls_mpi_free(&r);
   3923              mbedtls_mpi_free(&s);
   3924              return status;
   3925          
   3926           #else
   3927          
   3928              (void) operation;
   3929              (void) signature;
   3930              (void) signature_size;
   3931              (void) signature_length;
   3932          
   3933              return PSA_ERROR_NOT_SUPPORTED;
   \        0x4   0xF07F 0x0085      MVNS     R0,#+133
   \        0x8   0xBC10             POP      {R4}
   \        0xA   0x4770             BX       LR
   3934          
   3935          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   3936                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
   3937                  * defined( MBEDTLS_ECP_RESTARTABLE ) */
   3938          }
   3939          

   \                                 In section .text, align 2, keep-with-next
   3940          psa_status_t mbedtls_psa_sign_hash_abort(
   3941              mbedtls_psa_sign_hash_interruptible_operation_t *operation)
   3942          {
   \                     mbedtls_psa_sign_hash_abort: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   3943          
   3944          #if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   3945              defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
   3946              defined(MBEDTLS_ECP_RESTARTABLE)
   3947          
   3948              if (operation->ctx) {
   3949                  mbedtls_ecdsa_free(operation->ctx);
   3950                  mbedtls_free(operation->ctx);
   3951                  operation->ctx = NULL;
   3952              }
   3953          
   3954              mbedtls_ecdsa_restart_free(&operation->restart_ctx);
   3955          
   3956              operation->num_ops = 0;
   3957          
   3958              return PSA_SUCCESS;
   3959          
   3960          #else
   3961          
   3962              (void) operation;
   3963          
   3964              return PSA_ERROR_NOT_SUPPORTED;
   \        0x2   0xF07F 0x0085      MVNS     R0,#+133
   \        0x6   0x4770             BX       LR
   3965          
   3966          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   3967                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
   3968                  * defined( MBEDTLS_ECP_RESTARTABLE ) */
   3969          }
   3970          

   \                                 In section .text, align 2, keep-with-next
   3971          psa_status_t mbedtls_psa_verify_hash_start(
   3972              mbedtls_psa_verify_hash_interruptible_operation_t *operation,
   3973              const psa_key_attributes_t *attributes,
   3974              const uint8_t *key_buffer, size_t key_buffer_size,
   3975              psa_algorithm_t alg,
   3976              const uint8_t *hash, size_t hash_length,
   3977              const uint8_t *signature, size_t signature_length)
   3978          {
   \                     mbedtls_psa_verify_hash_start: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x9D05             LDR      R5,[SP, #+20]
   3979              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x0696      MVNS     R6,#+150
   3980              size_t coordinate_bytes = 0;
   \        0xA   0x2700             MOVS     R7,#+0
   3981              size_t required_hash_length = 0;
   \        0xC   0xF05F 0x0C00      MOVS     R12,#+0
   3982          
   3983              if (!PSA_KEY_TYPE_IS_ECC(attributes->core.type)) {
   \       0x10   0xF8B1 0xE000      LDRH     LR,[R1, #+0]
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable27
   \       0x18   0xEA10 0x0E0E      ANDS     LR,R0,LR
   \       0x1C   0xF5BE 0x4F82      CMP      LR,#+16640
   \       0x20   0xD002             BEQ.N    ??mbedtls_psa_verify_hash_start_0
   3984                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x22   0xF07F 0x0085      MVNS     R0,#+133
   \       0x26   0xE009             B.N      ??mbedtls_psa_verify_hash_start_1
   3985              }
   3986          
   3987              if (!PSA_ALG_IS_ECDSA(alg)) {
   \                     ??mbedtls_psa_verify_hash_start_0: (+1)
   \       0x28   0x0A68             LSRS     R0,R5,#+9
   \       0x2A   0x0240             LSLS     R0,R0,#+9
   \       0x2C   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x30   0xD002             BEQ.N    ??mbedtls_psa_verify_hash_start_2
   3988                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x32   0xF07F 0x0085      MVNS     R0,#+133
   \       0x36   0xE001             B.N      ??mbedtls_psa_verify_hash_start_1
   3989              }
   3990          
   3991          #if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   3992              defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
   3993              defined(MBEDTLS_ECP_RESTARTABLE)
   3994          
   3995              mbedtls_ecdsa_restart_init(&operation->restart_ctx);
   3996              mbedtls_mpi_init(&operation->r);
   3997              mbedtls_mpi_init(&operation->s);
   3998          
   3999              /* Ensure num_ops is zero'ed in case of context re-use. */
   4000              operation->num_ops = 0;
   4001          
   4002              status = mbedtls_psa_ecp_load_representation(attributes->core.type,
   4003                                                           attributes->core.bits,
   4004                                                           key_buffer,
   4005                                                           key_buffer_size,
   4006                                                           &operation->ctx);
   4007          
   4008              if (status != PSA_SUCCESS) {
   4009                  return status;
   4010              }
   4011          
   4012              coordinate_bytes = PSA_BITS_TO_BYTES(operation->ctx->grp.nbits);
   4013          
   4014              if (signature_length != 2 * coordinate_bytes) {
   4015                  return PSA_ERROR_INVALID_SIGNATURE;
   4016              }
   4017          
   4018              status = mbedtls_to_psa_error(
   4019                  mbedtls_mpi_read_binary(&operation->r,
   4020                                          signature,
   4021                                          coordinate_bytes));
   4022          
   4023              if (status != PSA_SUCCESS) {
   4024                  return status;
   4025              }
   4026          
   4027              status = mbedtls_to_psa_error(
   4028                  mbedtls_mpi_read_binary(&operation->s,
   4029                                          signature +
   4030                                          coordinate_bytes,
   4031                                          coordinate_bytes));
   4032          
   4033              if (status != PSA_SUCCESS) {
   4034                  return status;
   4035              }
   4036          
   4037              status = mbedtls_psa_ecp_load_public_part(operation->ctx);
   4038          
   4039              if (status != PSA_SUCCESS) {
   4040                  return status;
   4041              }
   4042          
   4043              /* We only need to store the same length of hash as the private key size
   4044               * here, it would be truncated by the internal implementation anyway. */
   4045              required_hash_length = (hash_length < coordinate_bytes ? hash_length :
   4046                                      coordinate_bytes);
   4047          
   4048              if (required_hash_length > sizeof(operation->hash)) {
   4049                  /* Shouldn't happen, but better safe than sorry. */
   4050                  return PSA_ERROR_CORRUPTION_DETECTED;
   4051              }
   4052          
   4053              memcpy(operation->hash, hash, required_hash_length);
   4054              operation->hash_length = required_hash_length;
   4055          
   4056              return PSA_SUCCESS;
   4057          #else
   4058              (void) operation;
   4059              (void) key_buffer;
   4060              (void) key_buffer_size;
   4061              (void) alg;
   4062              (void) hash;
   4063              (void) hash_length;
   4064              (void) signature;
   4065              (void) signature_length;
   4066              (void) status;
   4067              (void) coordinate_bytes;
   4068              (void) required_hash_length;
   4069          
   4070              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_psa_verify_hash_start_2: (+1)
   \       0x38   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??mbedtls_psa_verify_hash_start_1: (+1)
   \       0x3C   0xBDF0             POP      {R4-R7,PC}
   4071          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   4072                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
   4073                  * defined( MBEDTLS_ECP_RESTARTABLE ) */
   4074          }
   4075          

   \                                 In section .text, align 2, keep-with-next
   4076          psa_status_t mbedtls_psa_verify_hash_complete(
   4077              mbedtls_psa_verify_hash_interruptible_operation_t *operation)
   4078          {
   \                     mbedtls_psa_verify_hash_complete: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   4079          
   4080          #if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   4081              defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
   4082              defined(MBEDTLS_ECP_RESTARTABLE)
   4083          
   4084              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   4085          
   4086              /* Ensure max_ops is set to the current value (or default). */
   4087              mbedtls_psa_interruptible_set_max_ops(psa_interruptible_get_max_ops());
   4088          
   4089              status = mbedtls_to_psa_error(
   4090                  mbedtls_ecdsa_verify_restartable(&operation->ctx->grp,
   4091                                                   operation->hash,
   4092                                                   operation->hash_length,
   4093                                                   &operation->ctx->Q,
   4094                                                   &operation->r,
   4095                                                   &operation->s,
   4096                                                   &operation->restart_ctx));
   4097          
   4098              /* Hide the fact that the restart context only holds a delta of number of
   4099               * ops done during the last operation, not an absolute value. */
   4100              operation->num_ops += operation->restart_ctx.ecp.ops_done;
   4101          
   4102              return status;
   4103          #else
   4104              (void) operation;
   4105          
   4106              return PSA_ERROR_NOT_SUPPORTED;
   \        0x2   0xF07F 0x0085      MVNS     R0,#+133
   \        0x6   0x4770             BX       LR
   4107          
   4108          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   4109                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
   4110                  * defined( MBEDTLS_ECP_RESTARTABLE ) */
   4111          }
   4112          

   \                                 In section .text, align 2, keep-with-next
   4113          psa_status_t mbedtls_psa_verify_hash_abort(
   4114              mbedtls_psa_verify_hash_interruptible_operation_t *operation)
   4115          {
   \                     mbedtls_psa_verify_hash_abort: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   4116          
   4117          #if (defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) || \
   4118              defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)) && \
   4119              defined(MBEDTLS_ECP_RESTARTABLE)
   4120          
   4121              if (operation->ctx) {
   4122                  mbedtls_ecdsa_free(operation->ctx);
   4123                  mbedtls_free(operation->ctx);
   4124                  operation->ctx = NULL;
   4125              }
   4126          
   4127              mbedtls_ecdsa_restart_free(&operation->restart_ctx);
   4128          
   4129              operation->num_ops = 0;
   4130          
   4131              mbedtls_mpi_free(&operation->r);
   4132              mbedtls_mpi_free(&operation->s);
   4133          
   4134              return PSA_SUCCESS;
   4135          
   4136          #else
   4137              (void) operation;
   4138          
   4139              return PSA_ERROR_NOT_SUPPORTED;
   \        0x2   0xF07F 0x0085      MVNS     R0,#+133
   \        0x6   0x4770             BX       LR
   4140          
   4141          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_ECDSA) ||
   4142                  * defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA) &&
   4143                  * defined( MBEDTLS_ECP_RESTARTABLE ) */
   4144          }
   4145          
   4146          /****************************************************************/
   4147          /* Symmetric cryptography */
   4148          /****************************************************************/
   4149          

   \                                 In section .text, align 2, keep-with-next
   4150          static psa_status_t psa_cipher_setup(psa_cipher_operation_t *operation,
   4151                                               mbedtls_svc_key_id_t key,
   4152                                               psa_algorithm_t alg,
   4153                                               mbedtls_operation_t cipher_operation)
   4154          {
   \                     psa_cipher_setup: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   4155              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0A96      MVNS     R10,#+150
   \       0x12   0x46D3             MOV      R11,R10
   4156              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   4157              psa_key_slot_t *slot = NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9001             STR      R0,[SP, #+4]
   4158              psa_key_usage_t usage = (cipher_operation == MBEDTLS_ENCRYPT ?
   4159                                       PSA_KEY_USAGE_ENCRYPT :
   4160                                       PSA_KEY_USAGE_DECRYPT);
   \       0x18   0x0038             MOVS     R0,R7
   \       0x1A   0xB240             SXTB     R0,R0
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD102             BNE.N    ??psa_cipher_setup_0
   \       0x20   0xF44F 0x7880      MOV      R8,#+256
   \       0x24   0xE001             B.N      ??psa_cipher_setup_1
   \                     ??psa_cipher_setup_0: (+1)
   \       0x26   0xF44F 0x7800      MOV      R8,#+512
   4161              psa_key_attributes_t attributes;
   4162          
   4163              /* A context must be freshly initialized before it can be set up. */
   4164              if (operation->id != 0) {
   \                     ??psa_cipher_setup_1: (+1)
   \       0x2A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD002             BEQ.N    ??psa_cipher_setup_2
   4165                  status = PSA_ERROR_BAD_STATE;
   \       0x32   0xF07F 0x0488      MVNS     R4,#+136
   4166                  goto exit;
   \       0x36   0xE0A1             B.N      ??psa_cipher_setup_3
   4167              }
   4168          
   4169              if (!PSA_ALG_IS_CIPHER(alg)) {
   \                     ??psa_cipher_setup_2: (+1)
   \       0x38   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \       0x3C   0xF1B0 0x6F80      CMP      R0,#+67108864
   \       0x40   0xD002             BEQ.N    ??psa_cipher_setup_4
   4170                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x42   0xF07F 0x0486      MVNS     R4,#+134
   4171                  goto exit;
   \       0x46   0xE099             B.N      ??psa_cipher_setup_3
   4172              }
   4173          
   4174              status = psa_get_and_lock_key_slot_with_policy(key, &slot, usage, alg);
   \                     ??psa_cipher_setup_4: (+1)
   \       0x48   0x0033             MOVS     R3,R6
   \       0x4A   0x4642             MOV      R2,R8
   \       0x4C   0xA901             ADD      R1,SP,#+4
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x54   0x0004             MOVS     R4,R0
   4175              if (status != PSA_SUCCESS) {
   \       0x56   0x2C00             CMP      R4,#+0
   \       0x58   0xF040 0x8090      BNE.W    ??psa_cipher_setup_3
   4176                  goto exit;
   4177              }
   4178          
   4179              /* Initialize the operation struct members, except for id. The id member
   4180               * is used to indicate to psa_cipher_abort that there are resources to free,
   4181               * so we only set it (in the driver wrapper) after resources have been
   4182               * allocated/initialized. */
   4183              operation->iv_set = 0;
   \                     ??psa_cipher_setup_5: (+1)
   \       0x5C   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x60   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x64   0xF8C9 0x0004      STR      R0,[R9, #+4]
   4184              if (alg == PSA_ALG_ECB_NO_PADDING) {
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable32
   \       0x6C   0x4286             CMP      R6,R0
   \       0x6E   0xD106             BNE.N    ??psa_cipher_setup_6
   4185                  operation->iv_required = 0;
   \       0x70   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x74   0x0840             LSRS     R0,R0,#+1
   \       0x76   0x0040             LSLS     R0,R0,#+1
   \       0x78   0xF8C9 0x0004      STR      R0,[R9, #+4]
   \       0x7C   0xE005             B.N      ??psa_cipher_setup_7
   4186              } else {
   4187                  operation->iv_required = 1;
   \                     ??psa_cipher_setup_6: (+1)
   \       0x7E   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x82   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x86   0xF8C9 0x0004      STR      R0,[R9, #+4]
   4188              }
   4189              operation->default_iv_length = PSA_CIPHER_IV_LENGTH(slot->attr.type, alg);
   \                     ??psa_cipher_setup_7: (+1)
   \       0x8A   0x9801             LDR      R0,[SP, #+4]
   \       0x8C   0x8800             LDRH     R0,[R0, #+0]
   \       0x8E   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x92   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x96   0xD108             BNE.N    ??psa_cipher_setup_8
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0x9901             LDR      R1,[SP, #+4]
   \       0x9C   0x8809             LDRH     R1,[R1, #+0]
   \       0x9E   0xB289             UXTH     R1,R1
   \       0xA0   0x0A09             LSRS     R1,R1,#+8
   \       0xA2   0xF011 0x0107      ANDS     R1,R1,#0x7
   \       0xA6   0x4088             LSLS     R0,R0,R1
   \       0xA8   0xE000             B.N      ??psa_cipher_setup_9
   \                     ??psa_cipher_setup_8: (+1)
   \       0xAA   0x2000             MOVS     R0,#+0
   \                     ??psa_cipher_setup_9: (+1)
   \       0xAC   0x2802             CMP      R0,#+2
   \       0xAE   0xD329             BCC.N    ??psa_cipher_setup_10
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \       0xB4   0x4286             CMP      R6,R0
   \       0xB6   0xD013             BEQ.N    ??psa_cipher_setup_11
   \       0xB8   0x.... 0x....      LDR.W    R0,??DataTable32_2
   \       0xBC   0x4286             CMP      R6,R0
   \       0xBE   0xD00F             BEQ.N    ??psa_cipher_setup_11
   \       0xC0   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \       0xC4   0x4286             CMP      R6,R0
   \       0xC6   0xD00B             BEQ.N    ??psa_cipher_setup_11
   \       0xC8   0x.... 0x....      LDR.W    R0,??DataTable32_4
   \       0xCC   0x4286             CMP      R6,R0
   \       0xCE   0xD007             BEQ.N    ??psa_cipher_setup_11
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable32_5
   \       0xD4   0x4286             CMP      R6,R0
   \       0xD6   0xD003             BEQ.N    ??psa_cipher_setup_11
   \       0xD8   0x.... 0x....      LDR.W    R0,??DataTable32_6
   \       0xDC   0x4286             CMP      R6,R0
   \       0xDE   0xD111             BNE.N    ??psa_cipher_setup_10
   \                     ??psa_cipher_setup_11: (+1)
   \       0xE0   0x9801             LDR      R0,[SP, #+4]
   \       0xE2   0x8800             LDRH     R0,[R0, #+0]
   \       0xE4   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0xE8   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0xEC   0xD108             BNE.N    ??psa_cipher_setup_12
   \       0xEE   0x2001             MOVS     R0,#+1
   \       0xF0   0x9901             LDR      R1,[SP, #+4]
   \       0xF2   0x8809             LDRH     R1,[R1, #+0]
   \       0xF4   0xB289             UXTH     R1,R1
   \       0xF6   0x0A09             LSRS     R1,R1,#+8
   \       0xF8   0xF011 0x0107      ANDS     R1,R1,#0x7
   \       0xFC   0x4088             LSLS     R0,R0,R1
   \       0xFE   0xE014             B.N      ??psa_cipher_setup_13
   \                     ??psa_cipher_setup_12: (+1)
   \      0x100   0x2000             MOVS     R0,#+0
   \      0x102   0xE012             B.N      ??psa_cipher_setup_13
   \                     ??psa_cipher_setup_10: (+1)
   \      0x104   0x9801             LDR      R0,[SP, #+4]
   \      0x106   0x8801             LDRH     R1,[R0, #+0]
   \      0x108   0xF242 0x0004      MOVW     R0,#+8196
   \      0x10C   0x4281             CMP      R1,R0
   \      0x10E   0xD105             BNE.N    ??psa_cipher_setup_14
   \      0x110   0x.... 0x....      LDR.W    R0,??DataTable32_7
   \      0x114   0x4286             CMP      R6,R0
   \      0x116   0xD101             BNE.N    ??psa_cipher_setup_14
   \      0x118   0x200C             MOVS     R0,#+12
   \      0x11A   0xE006             B.N      ??psa_cipher_setup_15
   \                     ??psa_cipher_setup_14: (+1)
   \      0x11C   0x.... 0x....      LDR.W    R0,??DataTable33
   \      0x120   0x4286             CMP      R6,R0
   \      0x122   0xD101             BNE.N    ??psa_cipher_setup_16
   \      0x124   0x200D             MOVS     R0,#+13
   \      0x126   0xE000             B.N      ??psa_cipher_setup_15
   \                     ??psa_cipher_setup_16: (+1)
   \      0x128   0x2000             MOVS     R0,#+0
   \                     ??psa_cipher_setup_15: (+1)
   \                     ??psa_cipher_setup_13: (+1)
   \      0x12A   0xF889 0x0005      STRB     R0,[R9, #+5]
   4190          
   4191              attributes = (psa_key_attributes_t) {
   4192                  .core = slot->attr
   4193              };
   \      0x12E   0xA802             ADD      R0,SP,#+8
   \      0x130   0x2124             MOVS     R1,#+36
   \      0x132   0x.... 0x....      BL       __aeabi_memclr4
   \      0x136   0xA802             ADD      R0,SP,#+8
   \      0x138   0x9901             LDR      R1,[SP, #+4]
   \      0x13A   0x221C             MOVS     R2,#+28
   \      0x13C   0x.... 0x....      BL       __aeabi_memcpy4
   \      0x140   0xA80B             ADD      R0,SP,#+44
   \      0x142   0xA902             ADD      R1,SP,#+8
   \      0x144   0x2224             MOVS     R2,#+36
   \      0x146   0x.... 0x....      BL       __aeabi_memcpy4
   4194          
   4195              /* Try doing the operation through a driver before using software fallback. */
   4196              if (cipher_operation == MBEDTLS_ENCRYPT) {
   \      0x14A   0x0038             MOVS     R0,R7
   \      0x14C   0xB240             SXTB     R0,R0
   \      0x14E   0x2801             CMP      R0,#+1
   \      0x150   0xD10A             BNE.N    ??psa_cipher_setup_17
   4197                  status = psa_driver_wrapper_cipher_encrypt_setup(operation,
   4198                                                                   &attributes,
   4199                                                                   slot->key.data,
   4200                                                                   slot->key.bytes,
   4201                                                                   alg);
   \      0x152   0x9600             STR      R6,[SP, #+0]
   \      0x154   0x9801             LDR      R0,[SP, #+4]
   \      0x156   0x6A83             LDR      R3,[R0, #+40]
   \      0x158   0x9801             LDR      R0,[SP, #+4]
   \      0x15A   0x6A42             LDR      R2,[R0, #+36]
   \      0x15C   0xA90B             ADD      R1,SP,#+44
   \      0x15E   0x4648             MOV      R0,R9
   \      0x160   0x.... 0x....      BL       psa_driver_wrapper_cipher_encrypt_setup
   \      0x164   0x0004             MOVS     R4,R0
   \      0x166   0xE009             B.N      ??psa_cipher_setup_3
   4202              } else {
   4203                  status = psa_driver_wrapper_cipher_decrypt_setup(operation,
   4204                                                                   &attributes,
   4205                                                                   slot->key.data,
   4206                                                                   slot->key.bytes,
   4207                                                                   alg);
   \                     ??psa_cipher_setup_17: (+1)
   \      0x168   0x9600             STR      R6,[SP, #+0]
   \      0x16A   0x9801             LDR      R0,[SP, #+4]
   \      0x16C   0x6A83             LDR      R3,[R0, #+40]
   \      0x16E   0x9801             LDR      R0,[SP, #+4]
   \      0x170   0x6A42             LDR      R2,[R0, #+36]
   \      0x172   0xA90B             ADD      R1,SP,#+44
   \      0x174   0x4648             MOV      R0,R9
   \      0x176   0x.... 0x....      BL       psa_driver_wrapper_cipher_decrypt_setup
   \      0x17A   0x0004             MOVS     R4,R0
   4208              }
   4209          
   4210          exit:
   4211              if (status != PSA_SUCCESS) {
   \                     ??psa_cipher_setup_3: (+1)
   \      0x17C   0x2C00             CMP      R4,#+0
   \      0x17E   0xD002             BEQ.N    ??psa_cipher_setup_18
   4212                  psa_cipher_abort(operation);
   \      0x180   0x4648             MOV      R0,R9
   \      0x182   0x.... 0x....      BL       psa_cipher_abort
   4213              }
   4214          
   4215              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_cipher_setup_18: (+1)
   \      0x186   0x9801             LDR      R0,[SP, #+4]
   \      0x188   0x.... 0x....      BL       psa_unlock_key_slot
   4216          
   4217              return (status == PSA_SUCCESS) ? unlock_status : status;
   \      0x18C   0x2C00             CMP      R4,#+0
   \      0x18E   0xD000             BEQ.N    ??psa_cipher_setup_19
   \                     ??psa_cipher_setup_20: (+1)
   \      0x190   0x0020             MOVS     R0,R4
   \                     ??psa_cipher_setup_19: (+1)
   \      0x192   0xB015             ADD      SP,SP,#+84
   \      0x194   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4218          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   4219          

   \                                 In section .text, align 2, keep-with-next
   4220          psa_status_t psa_cipher_encrypt_setup(psa_cipher_operation_t *operation,
   4221                                                mbedtls_svc_key_id_t key,
   4222                                                psa_algorithm_t alg)
   4223          {
   \                     psa_cipher_encrypt_setup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   4224              return psa_cipher_setup(operation, key, alg, MBEDTLS_ENCRYPT);
   \        0x8   0x2301             MOVS     R3,#+1
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       psa_cipher_setup
   \       0x14   0xBD70             POP      {R4-R6,PC}
   4225          }
   4226          

   \                                 In section .text, align 2, keep-with-next
   4227          psa_status_t psa_cipher_decrypt_setup(psa_cipher_operation_t *operation,
   4228                                                mbedtls_svc_key_id_t key,
   4229                                                psa_algorithm_t alg)
   4230          {
   \                     psa_cipher_decrypt_setup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   4231              return psa_cipher_setup(operation, key, alg, MBEDTLS_DECRYPT);
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       psa_cipher_setup
   \       0x14   0xBD70             POP      {R4-R6,PC}
   4232          }
   4233          

   \                                 In section .text, align 2, keep-with-next
   4234          psa_status_t psa_cipher_generate_iv(psa_cipher_operation_t *operation,
   4235                                              uint8_t *iv,
   4236                                              size_t iv_size,
   4237                                              size_t *iv_length)
   4238          {
   \                     psa_cipher_generate_iv: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   4239              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0A96      MVNS     R10,#+150
   4240              uint8_t local_iv[PSA_CIPHER_IV_MAX_SIZE];
   4241              size_t default_iv_length = 0;
   \       0x12   0xF05F 0x0800      MOVS     R8,#+0
   4242          
   4243              if (operation->id == 0) {
   \       0x16   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??psa_cipher_generate_iv_0
   4244                  status = PSA_ERROR_BAD_STATE;
   \       0x1E   0xF07F 0x0488      MVNS     R4,#+136
   4245                  goto exit;
   \       0x22   0xE023             B.N      ??psa_cipher_generate_iv_1
   4246              }
   4247          
   4248              if (operation->iv_set || !operation->iv_required) {
   \                     ??psa_cipher_generate_iv_0: (+1)
   \       0x24   0xF899 0x0004      LDRB     R0,[R9, #+4]
   \       0x28   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD002             BEQ.N    ??psa_cipher_generate_iv_2
   4249                  status = PSA_ERROR_BAD_STATE;
   \       0x30   0xF07F 0x0488      MVNS     R4,#+136
   4250                  goto exit;
   \       0x34   0xE01A             B.N      ??psa_cipher_generate_iv_1
   4251              }
   4252          
   4253              default_iv_length = operation->default_iv_length;
   \                     ??psa_cipher_generate_iv_2: (+1)
   \       0x36   0xF899 0x0005      LDRB     R0,[R9, #+5]
   \       0x3A   0x4680             MOV      R8,R0
   4254              if (iv_size < default_iv_length) {
   \       0x3C   0x4546             CMP      R6,R8
   \       0x3E   0xD202             BCS.N    ??psa_cipher_generate_iv_3
   4255                  status = PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x40   0xF07F 0x0489      MVNS     R4,#+137
   4256                  goto exit;
   \       0x44   0xE012             B.N      ??psa_cipher_generate_iv_1
   4257              }
   4258          
   4259              if (default_iv_length > PSA_CIPHER_IV_MAX_SIZE) {
   \                     ??psa_cipher_generate_iv_3: (+1)
   \       0x46   0xF1B8 0x0F11      CMP      R8,#+17
   \       0x4A   0xD302             BCC.N    ??psa_cipher_generate_iv_4
   4260                  status = PSA_ERROR_GENERIC_ERROR;
   \       0x4C   0xF07F 0x0483      MVNS     R4,#+131
   4261                  goto exit;
   \       0x50   0xE00C             B.N      ??psa_cipher_generate_iv_1
   4262              }
   4263          
   4264              status = psa_generate_random(local_iv, default_iv_length);
   \                     ??psa_cipher_generate_iv_4: (+1)
   \       0x52   0x4641             MOV      R1,R8
   \       0x54   0xA801             ADD      R0,SP,#+4
   \       0x56   0x.... 0x....      BL       psa_generate_random
   \       0x5A   0x0004             MOVS     R4,R0
   4265              if (status != PSA_SUCCESS) {
   \       0x5C   0x2C00             CMP      R4,#+0
   \       0x5E   0xD105             BNE.N    ??psa_cipher_generate_iv_1
   4266                  goto exit;
   4267              }
   4268          
   4269              status = psa_driver_wrapper_cipher_set_iv(operation,
   4270                                                        local_iv, default_iv_length);
   \                     ??psa_cipher_generate_iv_5: (+1)
   \       0x60   0x4642             MOV      R2,R8
   \       0x62   0xA901             ADD      R1,SP,#+4
   \       0x64   0x4648             MOV      R0,R9
   \       0x66   0x.... 0x....      BL       psa_driver_wrapper_cipher_set_iv
   \       0x6A   0x0004             MOVS     R4,R0
   4271          
   4272          exit:
   4273              if (status == PSA_SUCCESS) {
   \                     ??psa_cipher_generate_iv_1: (+1)
   \       0x6C   0x2C00             CMP      R4,#+0
   \       0x6E   0xD112             BNE.N    ??psa_cipher_generate_iv_6
   4274                  memcpy(iv, local_iv, default_iv_length);
   \       0x70   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x74   0xF10D 0x0B04      ADD      R11,SP,#+4
   \       0x78   0x46AA             MOV      R10,R5
   \       0x7A   0x9A00             LDR      R2,[SP, #+0]
   \       0x7C   0x4659             MOV      R1,R11
   \       0x7E   0x4650             MOV      R0,R10
   \       0x80   0x.... 0x....      BL       __aeabi_memcpy
   4275                  *iv_length = default_iv_length;
   \       0x84   0xF8C7 0x8000      STR      R8,[R7, #+0]
   4276                  operation->iv_set = 1;
   \       0x88   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x8C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x90   0xF8C9 0x0004      STR      R0,[R9, #+4]
   \       0x94   0xE004             B.N      ??psa_cipher_generate_iv_7
   4277              } else {
   4278                  *iv_length = 0;
   \                     ??psa_cipher_generate_iv_6: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0x6038             STR      R0,[R7, #+0]
   4279                  psa_cipher_abort(operation);
   \       0x9A   0x4648             MOV      R0,R9
   \       0x9C   0x.... 0x....      BL       psa_cipher_abort
   4280              }
   4281          
   4282              return status;
   \                     ??psa_cipher_generate_iv_7: (+1)
   \       0xA0   0x0020             MOVS     R0,R4
   \       0xA2   0xB005             ADD      SP,SP,#+20
   \       0xA4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4283          }
   4284          

   \                                 In section .text, align 2, keep-with-next
   4285          psa_status_t psa_cipher_set_iv(psa_cipher_operation_t *operation,
   4286                                         const uint8_t *iv,
   4287                                         size_t iv_length)
   4288          {
   \                     psa_cipher_set_iv: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   4289              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0896      MVNS     R8,#+150
   4290          
   4291              if (operation->id == 0) {
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??psa_cipher_set_iv_0
   4292                  status = PSA_ERROR_BAD_STATE;
   \       0x14   0xF07F 0x0488      MVNS     R4,#+136
   4293                  goto exit;
   \       0x18   0xE012             B.N      ??psa_cipher_set_iv_1
   4294              }
   4295          
   4296              if (operation->iv_set || !operation->iv_required) {
   \                     ??psa_cipher_set_iv_0: (+1)
   \       0x1A   0x7928             LDRB     R0,[R5, #+4]
   \       0x1C   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD002             BEQ.N    ??psa_cipher_set_iv_2
   4297                  status = PSA_ERROR_BAD_STATE;
   \       0x24   0xF07F 0x0488      MVNS     R4,#+136
   4298                  goto exit;
   \       0x28   0xE00A             B.N      ??psa_cipher_set_iv_1
   4299              }
   4300          
   4301              if (iv_length > PSA_CIPHER_IV_MAX_SIZE) {
   \                     ??psa_cipher_set_iv_2: (+1)
   \       0x2A   0x2F11             CMP      R7,#+17
   \       0x2C   0xD302             BCC.N    ??psa_cipher_set_iv_3
   4302                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x2E   0xF07F 0x0486      MVNS     R4,#+134
   4303                  goto exit;
   \       0x32   0xE005             B.N      ??psa_cipher_set_iv_1
   4304              }
   4305          
   4306              status = psa_driver_wrapper_cipher_set_iv(operation,
   4307                                                        iv,
   4308                                                        iv_length);
   \                     ??psa_cipher_set_iv_3: (+1)
   \       0x34   0x003A             MOVS     R2,R7
   \       0x36   0x0031             MOVS     R1,R6
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       psa_driver_wrapper_cipher_set_iv
   \       0x3E   0x0004             MOVS     R4,R0
   4309          
   4310          exit:
   4311              if (status == PSA_SUCCESS) {
   \                     ??psa_cipher_set_iv_1: (+1)
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD104             BNE.N    ??psa_cipher_set_iv_4
   4312                  operation->iv_set = 1;
   \       0x44   0x6868             LDR      R0,[R5, #+4]
   \       0x46   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x4A   0x6068             STR      R0,[R5, #+4]
   \       0x4C   0xE002             B.N      ??psa_cipher_set_iv_5
   4313              } else {
   4314                  psa_cipher_abort(operation);
   \                     ??psa_cipher_set_iv_4: (+1)
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0x.... 0x....      BL       psa_cipher_abort
   4315              }
   4316              return status;
   \                     ??psa_cipher_set_iv_5: (+1)
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0xE8BD 0x81F0      POP      {R4-R8,PC}
   4317          }
   4318          

   \                                 In section .text, align 2, keep-with-next
   4319          psa_status_t psa_cipher_update(psa_cipher_operation_t *operation,
   4320                                         const uint8_t *input,
   4321                                         size_t input_length,
   4322                                         uint8_t *output,
   4323                                         size_t output_size,
   4324                                         size_t *output_length)
   4325          {
   \                     psa_cipher_update: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   4326              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x0996      MVNS     R9,#+150
   4327          
   4328              if (operation->id == 0) {
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??psa_cipher_update_0
   4329                  status = PSA_ERROR_BAD_STATE;
   \       0x16   0xF07F 0x0488      MVNS     R4,#+136
   4330                  goto exit;
   \       0x1A   0xE012             B.N      ??psa_cipher_update_1
   4331              }
   4332          
   4333              if (operation->iv_required && !operation->iv_set) {
   \                     ??psa_cipher_update_0: (+1)
   \       0x1C   0x7928             LDRB     R0,[R5, #+4]
   \       0x1E   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD102             BNE.N    ??psa_cipher_update_2
   4334                  status = PSA_ERROR_BAD_STATE;
   \       0x26   0xF07F 0x0488      MVNS     R4,#+136
   4335                  goto exit;
   \       0x2A   0xE00A             B.N      ??psa_cipher_update_1
   4336              }
   4337          
   4338              status = psa_driver_wrapper_cipher_update(operation,
   4339                                                        input,
   4340                                                        input_length,
   4341                                                        output,
   4342                                                        output_size,
   4343                                                        output_length);
   \                     ??psa_cipher_update_2: (+1)
   \       0x2C   0x980B             LDR      R0,[SP, #+44]
   \       0x2E   0x9001             STR      R0,[SP, #+4]
   \       0x30   0x980A             LDR      R0,[SP, #+40]
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0x4643             MOV      R3,R8
   \       0x36   0x003A             MOVS     R2,R7
   \       0x38   0x0031             MOVS     R1,R6
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0x.... 0x....      BL       psa_driver_wrapper_cipher_update
   \       0x40   0x0004             MOVS     R4,R0
   4344          
   4345          exit:
   4346              if (status != PSA_SUCCESS) {
   \                     ??psa_cipher_update_1: (+1)
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD002             BEQ.N    ??psa_cipher_update_3
   4347                  psa_cipher_abort(operation);
   \       0x46   0x0028             MOVS     R0,R5
   \       0x48   0x.... 0x....      BL       psa_cipher_abort
   4348              }
   4349          
   4350              return status;
   \                     ??psa_cipher_update_3: (+1)
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0xE8BD 0x83FE      POP      {R1-R9,PC}
   4351          }
   4352          

   \                                 In section .text, align 2, keep-with-next
   4353          psa_status_t psa_cipher_finish(psa_cipher_operation_t *operation,
   4354                                         uint8_t *output,
   4355                                         size_t output_size,
   4356                                         size_t *output_length)
   4357          {
   \                     psa_cipher_finish: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   4358              psa_status_t status = PSA_ERROR_GENERIC_ERROR;
   \        0xC   0xF07F 0x0983      MVNS     R9,#+131
   4359          
   4360              if (operation->id == 0) {
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??psa_cipher_finish_0
   4361                  status = PSA_ERROR_BAD_STATE;
   \       0x16   0xF07F 0x0488      MVNS     R4,#+136
   4362                  goto exit;
   \       0x1A   0xE00E             B.N      ??psa_cipher_finish_1
   4363              }
   4364          
   4365              if (operation->iv_required && !operation->iv_set) {
   \                     ??psa_cipher_finish_0: (+1)
   \       0x1C   0x7928             LDRB     R0,[R5, #+4]
   \       0x1E   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD102             BNE.N    ??psa_cipher_finish_2
   4366                  status = PSA_ERROR_BAD_STATE;
   \       0x26   0xF07F 0x0488      MVNS     R4,#+136
   4367                  goto exit;
   \       0x2A   0xE006             B.N      ??psa_cipher_finish_1
   4368              }
   4369          
   4370              status = psa_driver_wrapper_cipher_finish(operation,
   4371                                                        output,
   4372                                                        output_size,
   4373                                                        output_length);
   \                     ??psa_cipher_finish_2: (+1)
   \       0x2C   0x4643             MOV      R3,R8
   \       0x2E   0x003A             MOVS     R2,R7
   \       0x30   0x0031             MOVS     R1,R6
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0x.... 0x....      BL       psa_driver_wrapper_cipher_finish
   \       0x38   0x0004             MOVS     R4,R0
   4374          
   4375          exit:
   4376              if (status == PSA_SUCCESS) {
   \                     ??psa_cipher_finish_1: (+1)
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD103             BNE.N    ??psa_cipher_finish_3
   4377                  return psa_cipher_abort(operation);
   \       0x3E   0x0028             MOVS     R0,R5
   \       0x40   0x.... 0x....      BL       psa_cipher_abort
   \       0x44   0xE006             B.N      ??psa_cipher_finish_4
   4378              } else {
   4379                  *output_length = 0;
   \                     ??psa_cipher_finish_3: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xF8C8 0x0000      STR      R0,[R8, #+0]
   4380                  (void) psa_cipher_abort(operation);
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0x.... 0x....      BL       psa_cipher_abort
   4381          
   4382                  return status;
   \       0x52   0x0020             MOVS     R0,R4
   \                     ??psa_cipher_finish_4: (+1)
   \       0x54   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   4383              }
   4384          }
   4385          

   \                                 In section .text, align 2, keep-with-next
   4386          psa_status_t psa_cipher_abort(psa_cipher_operation_t *operation)
   4387          {
   \                     psa_cipher_abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4388              if (operation->id == 0) {
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD101             BNE.N    ??psa_cipher_abort_0
   4389                  /* The object has (apparently) been initialized but it is not (yet)
   4390                   * in use. It's ok to call abort on such an object, and there's
   4391                   * nothing to do. */
   4392                  return PSA_SUCCESS;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE00D             B.N      ??psa_cipher_abort_1
   4393              }
   4394          
   4395              psa_driver_wrapper_cipher_abort(operation);
   \                     ??psa_cipher_abort_0: (+1)
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       psa_driver_wrapper_cipher_abort
   4396          
   4397              operation->id = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6020             STR      R0,[R4, #+0]
   4398              operation->iv_set = 0;
   \       0x18   0x6860             LDR      R0,[R4, #+4]
   \       0x1A   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x1E   0x6060             STR      R0,[R4, #+4]
   4399              operation->iv_required = 0;
   \       0x20   0x6860             LDR      R0,[R4, #+4]
   \       0x22   0x0840             LSRS     R0,R0,#+1
   \       0x24   0x0040             LSLS     R0,R0,#+1
   \       0x26   0x6060             STR      R0,[R4, #+4]
   4400          
   4401              return PSA_SUCCESS;
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??psa_cipher_abort_1: (+1)
   \       0x2A   0xBD10             POP      {R4,PC}
   4402          }
   4403          

   \                                 In section .text, align 2, keep-with-next
   4404          psa_status_t psa_cipher_encrypt(mbedtls_svc_key_id_t key,
   4405                                          psa_algorithm_t alg,
   4406                                          const uint8_t *input,
   4407                                          size_t input_length,
   4408                                          uint8_t *output,
   4409                                          size_t output_size,
   4410                                          size_t *output_length)
   4411          {
   \                     psa_cipher_encrypt: (+1)
   \        0x0   0xE92D 0x4FFD      PUSH     {R0,R2-R11,LR}
   \        0x4   0xB09E             SUB      SP,SP,#+120
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x9E2A             LDR      R6,[SP, #+168]
   \        0xA   0x9F2B             LDR      R7,[SP, #+172]
   \        0xC   0xF8DD 0x80B0      LDR      R8,[SP, #+176]
   4412              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x10   0xF07F 0x0A96      MVNS     R10,#+150
   \       0x14   0x46D3             MOV      R11,R10
   4413              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   4414              psa_key_slot_t *slot = NULL;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x9007             STR      R0,[SP, #+28]
   4415              uint8_t local_iv[PSA_CIPHER_IV_MAX_SIZE];
   4416              size_t default_iv_length = 0;
   \       0x1A   0x2500             MOVS     R5,#+0
   4417              psa_key_attributes_t attributes;
   4418          
   4419              if (!PSA_ALG_IS_CIPHER(alg)) {
   \       0x1C   0xF019 0x40FE      ANDS     R0,R9,#0x7F000000
   \       0x20   0xF1B0 0x6F80      CMP      R0,#+67108864
   \       0x24   0xD002             BEQ.N    ??psa_cipher_encrypt_0
   4420                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x26   0xF07F 0x0486      MVNS     R4,#+134
   4421                  goto exit;
   \       0x2A   0xE096             B.N      ??psa_cipher_encrypt_1
   4422              }
   4423          
   4424              status = psa_get_and_lock_key_slot_with_policy(key, &slot,
   4425                                                             PSA_KEY_USAGE_ENCRYPT,
   4426                                                             alg);
   \                     ??psa_cipher_encrypt_0: (+1)
   \       0x2C   0x464B             MOV      R3,R9
   \       0x2E   0xF44F 0x7280      MOV      R2,#+256
   \       0x32   0xA907             ADD      R1,SP,#+28
   \       0x34   0x981E             LDR      R0,[SP, #+120]
   \       0x36   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x3A   0x0004             MOVS     R4,R0
   4427              if (status != PSA_SUCCESS) {
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xF040 0x808C      BNE.W    ??psa_cipher_encrypt_1
   4428                  goto exit;
   4429              }
   4430          
   4431              attributes = (psa_key_attributes_t) {
   4432                  .core = slot->attr
   4433              };
   \                     ??psa_cipher_encrypt_2: (+1)
   \       0x42   0xA80C             ADD      R0,SP,#+48
   \       0x44   0x2124             MOVS     R1,#+36
   \       0x46   0x.... 0x....      BL       __aeabi_memclr4
   \       0x4A   0xA80C             ADD      R0,SP,#+48
   \       0x4C   0x9907             LDR      R1,[SP, #+28]
   \       0x4E   0x221C             MOVS     R2,#+28
   \       0x50   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x54   0xA815             ADD      R0,SP,#+84
   \       0x56   0xA90C             ADD      R1,SP,#+48
   \       0x58   0x2224             MOVS     R2,#+36
   \       0x5A   0x.... 0x....      BL       __aeabi_memcpy4
   4434          
   4435              default_iv_length = PSA_CIPHER_IV_LENGTH(slot->attr.type, alg);
   \       0x5E   0x9807             LDR      R0,[SP, #+28]
   \       0x60   0x8800             LDRH     R0,[R0, #+0]
   \       0x62   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x66   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x6A   0xD108             BNE.N    ??psa_cipher_encrypt_3
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0x9907             LDR      R1,[SP, #+28]
   \       0x70   0x8809             LDRH     R1,[R1, #+0]
   \       0x72   0xB289             UXTH     R1,R1
   \       0x74   0x0A09             LSRS     R1,R1,#+8
   \       0x76   0xF011 0x0107      ANDS     R1,R1,#0x7
   \       0x7A   0x4088             LSLS     R0,R0,R1
   \       0x7C   0xE000             B.N      ??psa_cipher_encrypt_4
   \                     ??psa_cipher_encrypt_3: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \                     ??psa_cipher_encrypt_4: (+1)
   \       0x80   0x2802             CMP      R0,#+2
   \       0x82   0xD329             BCC.N    ??psa_cipher_encrypt_5
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \       0x88   0x4581             CMP      R9,R0
   \       0x8A   0xD013             BEQ.N    ??psa_cipher_encrypt_6
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable32_2
   \       0x90   0x4581             CMP      R9,R0
   \       0x92   0xD00F             BEQ.N    ??psa_cipher_encrypt_6
   \       0x94   0x.... 0x....      LDR.W    R0,??DataTable32_3
   \       0x98   0x4581             CMP      R9,R0
   \       0x9A   0xD00B             BEQ.N    ??psa_cipher_encrypt_6
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable32_4
   \       0xA0   0x4581             CMP      R9,R0
   \       0xA2   0xD007             BEQ.N    ??psa_cipher_encrypt_6
   \       0xA4   0x.... 0x....      LDR.W    R0,??DataTable32_5
   \       0xA8   0x4581             CMP      R9,R0
   \       0xAA   0xD003             BEQ.N    ??psa_cipher_encrypt_6
   \       0xAC   0x.... 0x....      LDR.W    R0,??DataTable32_6
   \       0xB0   0x4581             CMP      R9,R0
   \       0xB2   0xD111             BNE.N    ??psa_cipher_encrypt_5
   \                     ??psa_cipher_encrypt_6: (+1)
   \       0xB4   0x9807             LDR      R0,[SP, #+28]
   \       0xB6   0x8800             LDRH     R0,[R0, #+0]
   \       0xB8   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0xBC   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0xC0   0xD108             BNE.N    ??psa_cipher_encrypt_7
   \       0xC2   0x2501             MOVS     R5,#+1
   \       0xC4   0x9807             LDR      R0,[SP, #+28]
   \       0xC6   0x8800             LDRH     R0,[R0, #+0]
   \       0xC8   0xB280             UXTH     R0,R0
   \       0xCA   0x0A00             LSRS     R0,R0,#+8
   \       0xCC   0xF010 0x0007      ANDS     R0,R0,#0x7
   \       0xD0   0x4085             LSLS     R5,R5,R0
   \       0xD2   0xE014             B.N      ??psa_cipher_encrypt_8
   \                     ??psa_cipher_encrypt_7: (+1)
   \       0xD4   0x2500             MOVS     R5,#+0
   \       0xD6   0xE012             B.N      ??psa_cipher_encrypt_8
   \                     ??psa_cipher_encrypt_5: (+1)
   \       0xD8   0x9807             LDR      R0,[SP, #+28]
   \       0xDA   0x8800             LDRH     R0,[R0, #+0]
   \       0xDC   0xF242 0x0104      MOVW     R1,#+8196
   \       0xE0   0x4288             CMP      R0,R1
   \       0xE2   0xD105             BNE.N    ??psa_cipher_encrypt_9
   \       0xE4   0x.... 0x....      LDR.W    R0,??DataTable32_7
   \       0xE8   0x4581             CMP      R9,R0
   \       0xEA   0xD101             BNE.N    ??psa_cipher_encrypt_9
   \       0xEC   0x250C             MOVS     R5,#+12
   \       0xEE   0xE006             B.N      ??psa_cipher_encrypt_8
   \                     ??psa_cipher_encrypt_9: (+1)
   \       0xF0   0x.... 0x....      LDR.W    R0,??DataTable33
   \       0xF4   0x4581             CMP      R9,R0
   \       0xF6   0xD101             BNE.N    ??psa_cipher_encrypt_10
   \       0xF8   0x250D             MOVS     R5,#+13
   \       0xFA   0xE000             B.N      ??psa_cipher_encrypt_8
   \                     ??psa_cipher_encrypt_10: (+1)
   \       0xFC   0x2500             MOVS     R5,#+0
   4436              if (default_iv_length > PSA_CIPHER_IV_MAX_SIZE) {
   \                     ??psa_cipher_encrypt_8: (+1)
   \       0xFE   0x2D11             CMP      R5,#+17
   \      0x100   0xD303             BCC.N    ??psa_cipher_encrypt_11
   4437                  status = PSA_ERROR_GENERIC_ERROR;
   \      0x102   0xF07F 0x0083      MVNS     R0,#+131
   \      0x106   0x0004             MOVS     R4,R0
   4438                  goto exit;
   \      0x108   0xE027             B.N      ??psa_cipher_encrypt_1
   4439              }
   4440          
   4441              if (default_iv_length > 0) {
   \                     ??psa_cipher_encrypt_11: (+1)
   \      0x10A   0x2D00             CMP      R5,#+0
   \      0x10C   0xD00C             BEQ.N    ??psa_cipher_encrypt_12
   4442                  if (output_size < default_iv_length) {
   \      0x10E   0x42AF             CMP      R7,R5
   \      0x110   0xD203             BCS.N    ??psa_cipher_encrypt_13
   4443                      status = PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x112   0xF07F 0x0089      MVNS     R0,#+137
   \      0x116   0x0004             MOVS     R4,R0
   4444                      goto exit;
   \      0x118   0xE01F             B.N      ??psa_cipher_encrypt_1
   4445                  }
   4446          
   4447                  status = psa_generate_random(local_iv, default_iv_length);
   \                     ??psa_cipher_encrypt_13: (+1)
   \      0x11A   0x0029             MOVS     R1,R5
   \      0x11C   0xA808             ADD      R0,SP,#+32
   \      0x11E   0x.... 0x....      BL       psa_generate_random
   \      0x122   0x0004             MOVS     R4,R0
   4448                  if (status != PSA_SUCCESS) {
   \      0x124   0x2C00             CMP      R4,#+0
   \      0x126   0xD118             BNE.N    ??psa_cipher_encrypt_1
   4449                      goto exit;
   4450                  }
   4451              }
   4452          
   4453              status = psa_driver_wrapper_cipher_encrypt(
   4454                  &attributes, slot->key.data, slot->key.bytes,
   4455                  alg, local_iv, default_iv_length, input, input_length,
   4456                  psa_crypto_buffer_offset(output, default_iv_length),
   4457                  output_size - default_iv_length, output_length);
   \                     ??psa_cipher_encrypt_12: (+1)
   \      0x128   0x0029             MOVS     R1,R5
   \      0x12A   0x0030             MOVS     R0,R6
   \      0x12C   0x.... 0x....      BL       psa_crypto_buffer_offset
   \      0x130   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \      0x134   0x1B79             SUBS     R1,R7,R5
   \      0x136   0x9105             STR      R1,[SP, #+20]
   \      0x138   0x9004             STR      R0,[SP, #+16]
   \      0x13A   0x9820             LDR      R0,[SP, #+128]
   \      0x13C   0x9003             STR      R0,[SP, #+12]
   \      0x13E   0x981F             LDR      R0,[SP, #+124]
   \      0x140   0x9002             STR      R0,[SP, #+8]
   \      0x142   0x9501             STR      R5,[SP, #+4]
   \      0x144   0xA808             ADD      R0,SP,#+32
   \      0x146   0x9000             STR      R0,[SP, #+0]
   \      0x148   0x464B             MOV      R3,R9
   \      0x14A   0x9807             LDR      R0,[SP, #+28]
   \      0x14C   0x6A82             LDR      R2,[R0, #+40]
   \      0x14E   0x9807             LDR      R0,[SP, #+28]
   \      0x150   0x6A41             LDR      R1,[R0, #+36]
   \      0x152   0xA815             ADD      R0,SP,#+84
   \      0x154   0x.... 0x....      BL       psa_driver_wrapper_cipher_encrypt
   \      0x158   0x0004             MOVS     R4,R0
   4458          
   4459          exit:
   4460              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_cipher_encrypt_1: (+1)
   \      0x15A   0x9807             LDR      R0,[SP, #+28]
   \      0x15C   0x.... 0x....      BL       psa_unlock_key_slot
   \      0x160   0x9001             STR      R0,[SP, #+4]
   4461              if (status == PSA_SUCCESS) {
   \      0x162   0x2C00             CMP      R4,#+0
   \      0x164   0xD101             BNE.N    ??psa_cipher_encrypt_14
   4462                  status = unlock_status;
   \      0x166   0x9801             LDR      R0,[SP, #+4]
   \      0x168   0x0004             MOVS     R4,R0
   4463              }
   4464          
   4465              if (status == PSA_SUCCESS) {
   \                     ??psa_cipher_encrypt_14: (+1)
   \      0x16A   0x2C00             CMP      R4,#+0
   \      0x16C   0xD110             BNE.N    ??psa_cipher_encrypt_15
   4466                  if (default_iv_length > 0) {
   \      0x16E   0x2D00             CMP      R5,#+0
   \      0x170   0xD008             BEQ.N    ??psa_cipher_encrypt_16
   4467                      memcpy(output, local_iv, default_iv_length);
   \      0x172   0x9500             STR      R5,[SP, #+0]
   \      0x174   0xF10D 0x0A20      ADD      R10,SP,#+32
   \      0x178   0x46B3             MOV      R11,R6
   \      0x17A   0x9A00             LDR      R2,[SP, #+0]
   \      0x17C   0x4651             MOV      R1,R10
   \      0x17E   0x4658             MOV      R0,R11
   \      0x180   0x.... 0x....      BL       __aeabi_memcpy
   4468                  }
   4469                  *output_length += default_iv_length;
   \                     ??psa_cipher_encrypt_16: (+1)
   \      0x184   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x188   0x1828             ADDS     R0,R5,R0
   \      0x18A   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \      0x18E   0xE002             B.N      ??psa_cipher_encrypt_17
   4470              } else {
   4471                  *output_length = 0;
   \                     ??psa_cipher_encrypt_15: (+1)
   \      0x190   0x2000             MOVS     R0,#+0
   \      0x192   0xF8C8 0x0000      STR      R0,[R8, #+0]
   4472              }
   4473          
   4474              return status;
   \                     ??psa_cipher_encrypt_17: (+1)
   \      0x196   0x0020             MOVS     R0,R4
   \      0x198   0xB021             ADD      SP,SP,#+132
   \      0x19A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4475          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   4476          

   \                                 In section .text, align 2, keep-with-next
   4477          psa_status_t psa_cipher_decrypt(mbedtls_svc_key_id_t key,
   4478                                          psa_algorithm_t alg,
   4479                                          const uint8_t *input,
   4480                                          size_t input_length,
   4481                                          uint8_t *output,
   4482                                          size_t output_size,
   4483                                          size_t *output_length)
   4484          {
   \                     psa_cipher_decrypt: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB098             SUB      SP,SP,#+96
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0xF8DD 0x8090      LDR      R8,[SP, #+144]
   4485              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x0A96      MVNS     R10,#+150
   \       0x16   0x46D3             MOV      R11,R10
   4486              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   4487              psa_key_slot_t *slot = NULL;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x9005             STR      R0,[SP, #+20]
   4488              psa_key_attributes_t attributes;
   4489          
   4490              if (!PSA_ALG_IS_CIPHER(alg)) {
   \       0x1C   0xF015 0x40FE      ANDS     R0,R5,#0x7F000000
   \       0x20   0xF1B0 0x6F80      CMP      R0,#+67108864
   \       0x24   0xD002             BEQ.N    ??psa_cipher_decrypt_0
   4491                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x26   0xF07F 0x0486      MVNS     R4,#+134
   4492                  goto exit;
   \       0x2A   0xE098             B.N      ??psa_cipher_decrypt_1
   4493              }
   4494          
   4495              status = psa_get_and_lock_key_slot_with_policy(key, &slot,
   4496                                                             PSA_KEY_USAGE_DECRYPT,
   4497                                                             alg);
   \                     ??psa_cipher_decrypt_0: (+1)
   \       0x2C   0x002B             MOVS     R3,R5
   \       0x2E   0xF44F 0x7200      MOV      R2,#+512
   \       0x32   0xA905             ADD      R1,SP,#+20
   \       0x34   0x4648             MOV      R0,R9
   \       0x36   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x3A   0x0004             MOVS     R4,R0
   4498              if (status != PSA_SUCCESS) {
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xF040 0x808E      BNE.W    ??psa_cipher_decrypt_1
   4499                  goto exit;
   4500              }
   4501          
   4502              attributes = (psa_key_attributes_t) {
   4503                  .core = slot->attr
   4504              };
   \                     ??psa_cipher_decrypt_2: (+1)
   \       0x42   0xA806             ADD      R0,SP,#+24
   \       0x44   0x2124             MOVS     R1,#+36
   \       0x46   0x.... 0x....      BL       __aeabi_memclr4
   \       0x4A   0xA806             ADD      R0,SP,#+24
   \       0x4C   0x9905             LDR      R1,[SP, #+20]
   \       0x4E   0x221C             MOVS     R2,#+28
   \       0x50   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x54   0xA80F             ADD      R0,SP,#+60
   \       0x56   0xA906             ADD      R1,SP,#+24
   \       0x58   0x2224             MOVS     R2,#+36
   \       0x5A   0x.... 0x....      BL       __aeabi_memcpy4
   4505          
   4506              if (alg == PSA_ALG_CCM_STAR_NO_TAG &&
   4507                  input_length < PSA_BLOCK_CIPHER_BLOCK_LENGTH(slot->attr.type)) {
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable33
   \       0x62   0x4285             CMP      R5,R0
   \       0x64   0xD116             BNE.N    ??psa_cipher_decrypt_3
   \       0x66   0x9905             LDR      R1,[SP, #+20]
   \       0x68   0x8809             LDRH     R1,[R1, #+0]
   \       0x6A   0xF411 0x41E0      ANDS     R1,R1,#0x7000
   \       0x6E   0xF5B1 0x5F00      CMP      R1,#+8192
   \       0x72   0xD108             BNE.N    ??psa_cipher_decrypt_4
   \       0x74   0x2101             MOVS     R1,#+1
   \       0x76   0x9A05             LDR      R2,[SP, #+20]
   \       0x78   0x8812             LDRH     R2,[R2, #+0]
   \       0x7A   0xB292             UXTH     R2,R2
   \       0x7C   0x0A12             LSRS     R2,R2,#+8
   \       0x7E   0xF012 0x0207      ANDS     R2,R2,#0x7
   \       0x82   0x4091             LSLS     R1,R1,R2
   \       0x84   0xE000             B.N      ??psa_cipher_decrypt_5
   \                     ??psa_cipher_decrypt_4: (+1)
   \       0x86   0x2100             MOVS     R1,#+0
   \                     ??psa_cipher_decrypt_5: (+1)
   \       0x88   0x428F             CMP      R7,R1
   \       0x8A   0xD203             BCS.N    ??psa_cipher_decrypt_3
   4508                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x8C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x90   0x0004             MOVS     R4,R0
   4509                  goto exit;
   \       0x92   0xE064             B.N      ??psa_cipher_decrypt_1
   4510              } else if (input_length < PSA_CIPHER_IV_LENGTH(slot->attr.type, alg)) {
   \                     ??psa_cipher_decrypt_3: (+1)
   \       0x94   0x9905             LDR      R1,[SP, #+20]
   \       0x96   0x8809             LDRH     R1,[R1, #+0]
   \       0x98   0xF411 0x41E0      ANDS     R1,R1,#0x7000
   \       0x9C   0xF5B1 0x5F00      CMP      R1,#+8192
   \       0xA0   0xD108             BNE.N    ??psa_cipher_decrypt_6
   \       0xA2   0x2101             MOVS     R1,#+1
   \       0xA4   0x9A05             LDR      R2,[SP, #+20]
   \       0xA6   0x8812             LDRH     R2,[R2, #+0]
   \       0xA8   0xB292             UXTH     R2,R2
   \       0xAA   0x0A12             LSRS     R2,R2,#+8
   \       0xAC   0xF012 0x0207      ANDS     R2,R2,#0x7
   \       0xB0   0x4091             LSLS     R1,R1,R2
   \       0xB2   0xE000             B.N      ??psa_cipher_decrypt_7
   \                     ??psa_cipher_decrypt_6: (+1)
   \       0xB4   0x2100             MOVS     R1,#+0
   \                     ??psa_cipher_decrypt_7: (+1)
   \       0xB6   0x2902             CMP      R1,#+2
   \       0xB8   0xD329             BCC.N    ??psa_cipher_decrypt_8
   \       0xBA   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \       0xBE   0x428D             CMP      R5,R1
   \       0xC0   0xD013             BEQ.N    ??psa_cipher_decrypt_9
   \       0xC2   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \       0xC6   0x428D             CMP      R5,R1
   \       0xC8   0xD00F             BEQ.N    ??psa_cipher_decrypt_9
   \       0xCA   0x.... 0x....      LDR.W    R1,??DataTable32_3
   \       0xCE   0x428D             CMP      R5,R1
   \       0xD0   0xD00B             BEQ.N    ??psa_cipher_decrypt_9
   \       0xD2   0x.... 0x....      LDR.W    R1,??DataTable32_4
   \       0xD6   0x428D             CMP      R5,R1
   \       0xD8   0xD007             BEQ.N    ??psa_cipher_decrypt_9
   \       0xDA   0x.... 0x....      LDR.W    R1,??DataTable32_5
   \       0xDE   0x428D             CMP      R5,R1
   \       0xE0   0xD003             BEQ.N    ??psa_cipher_decrypt_9
   \       0xE2   0x.... 0x....      LDR.W    R1,??DataTable32_6
   \       0xE6   0x428D             CMP      R5,R1
   \       0xE8   0xD111             BNE.N    ??psa_cipher_decrypt_8
   \                     ??psa_cipher_decrypt_9: (+1)
   \       0xEA   0x9805             LDR      R0,[SP, #+20]
   \       0xEC   0x8800             LDRH     R0,[R0, #+0]
   \       0xEE   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0xF2   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0xF6   0xD108             BNE.N    ??psa_cipher_decrypt_10
   \       0xF8   0x2001             MOVS     R0,#+1
   \       0xFA   0x9905             LDR      R1,[SP, #+20]
   \       0xFC   0x8809             LDRH     R1,[R1, #+0]
   \       0xFE   0xB289             UXTH     R1,R1
   \      0x100   0x0A09             LSRS     R1,R1,#+8
   \      0x102   0xF011 0x0107      ANDS     R1,R1,#0x7
   \      0x106   0x4088             LSLS     R0,R0,R1
   \      0x108   0xE012             B.N      ??psa_cipher_decrypt_11
   \                     ??psa_cipher_decrypt_10: (+1)
   \      0x10A   0x2000             MOVS     R0,#+0
   \      0x10C   0xE010             B.N      ??psa_cipher_decrypt_11
   \                     ??psa_cipher_decrypt_8: (+1)
   \      0x10E   0x9905             LDR      R1,[SP, #+20]
   \      0x110   0x880A             LDRH     R2,[R1, #+0]
   \      0x112   0xF242 0x0104      MOVW     R1,#+8196
   \      0x116   0x428A             CMP      R2,R1
   \      0x118   0xD105             BNE.N    ??psa_cipher_decrypt_12
   \      0x11A   0x.... 0x....      LDR.W    R1,??DataTable32_7
   \      0x11E   0x428D             CMP      R5,R1
   \      0x120   0xD101             BNE.N    ??psa_cipher_decrypt_12
   \      0x122   0x200C             MOVS     R0,#+12
   \      0x124   0xE004             B.N      ??psa_cipher_decrypt_11
   \                     ??psa_cipher_decrypt_12: (+1)
   \      0x126   0x4285             CMP      R5,R0
   \      0x128   0xD101             BNE.N    ??psa_cipher_decrypt_13
   \      0x12A   0x200D             MOVS     R0,#+13
   \      0x12C   0xE000             B.N      ??psa_cipher_decrypt_11
   \                     ??psa_cipher_decrypt_13: (+1)
   \      0x12E   0x2000             MOVS     R0,#+0
   \                     ??psa_cipher_decrypt_11: (+1)
   \      0x130   0x4287             CMP      R7,R0
   \      0x132   0xD203             BCS.N    ??psa_cipher_decrypt_14
   4511                  status = PSA_ERROR_INVALID_ARGUMENT;
   \      0x134   0xF07F 0x0086      MVNS     R0,#+134
   \      0x138   0x0004             MOVS     R4,R0
   4512                  goto exit;
   \      0x13A   0xE010             B.N      ??psa_cipher_decrypt_1
   4513              }
   4514          
   4515              status = psa_driver_wrapper_cipher_decrypt(
   4516                  &attributes, slot->key.data, slot->key.bytes,
   4517                  alg, input, input_length,
   4518                  output, output_size, output_length);
   \                     ??psa_cipher_decrypt_14: (+1)
   \      0x13C   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \      0x140   0x9823             LDR      R0,[SP, #+140]
   \      0x142   0x9003             STR      R0,[SP, #+12]
   \      0x144   0x9822             LDR      R0,[SP, #+136]
   \      0x146   0x9002             STR      R0,[SP, #+8]
   \      0x148   0x9701             STR      R7,[SP, #+4]
   \      0x14A   0x9600             STR      R6,[SP, #+0]
   \      0x14C   0x002B             MOVS     R3,R5
   \      0x14E   0x9805             LDR      R0,[SP, #+20]
   \      0x150   0x6A82             LDR      R2,[R0, #+40]
   \      0x152   0x9805             LDR      R0,[SP, #+20]
   \      0x154   0x6A41             LDR      R1,[R0, #+36]
   \      0x156   0xA80F             ADD      R0,SP,#+60
   \      0x158   0x.... 0x....      BL       psa_driver_wrapper_cipher_decrypt
   \      0x15C   0x0004             MOVS     R4,R0
   4519          
   4520          exit:
   4521              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_cipher_decrypt_1: (+1)
   \      0x15E   0x9805             LDR      R0,[SP, #+20]
   \      0x160   0x.... 0x....      BL       psa_unlock_key_slot
   \      0x164   0x0001             MOVS     R1,R0
   4522              if (status == PSA_SUCCESS) {
   \      0x166   0x2C00             CMP      R4,#+0
   \      0x168   0xD100             BNE.N    ??psa_cipher_decrypt_15
   4523                  status = unlock_status;
   \      0x16A   0x000C             MOVS     R4,R1
   4524              }
   4525          
   4526              if (status != PSA_SUCCESS) {
   \                     ??psa_cipher_decrypt_15: (+1)
   \      0x16C   0x2C00             CMP      R4,#+0
   \      0x16E   0xD002             BEQ.N    ??psa_cipher_decrypt_16
   4527                  *output_length = 0;
   \      0x170   0x2000             MOVS     R0,#+0
   \      0x172   0xF8C8 0x0000      STR      R0,[R8, #+0]
   4528              }
   4529          
   4530              return status;
   \                     ??psa_cipher_decrypt_16: (+1)
   \      0x176   0x0020             MOVS     R0,R4
   \      0x178   0xB019             ADD      SP,SP,#+100
   \      0x17A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4531          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   4532          
   4533          
   4534          /****************************************************************/
   4535          /* AEAD */
   4536          /****************************************************************/
   4537          
   4538          /* Helper function to get the base algorithm from its variants. */

   \                                 In section .text, align 2, keep-with-next
   4539          static psa_algorithm_t psa_aead_get_base_algorithm(psa_algorithm_t alg)
   4540          {
   4541              return PSA_ALG_AEAD_WITH_DEFAULT_LENGTH_TAG(alg);
   \                     psa_aead_get_base_algorithm: (+1)
   \        0x0   0xF430 0x127E      BICS     R2,R0,#0x3F8000
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable37
   \        0x8   0x428A             CMP      R2,R1
   \        0xA   0xD102             BNE.N    ??psa_aead_get_base_algorithm_0
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \       0x10   0xE011             B.N      ??psa_aead_get_base_algorithm_1
   \                     ??psa_aead_get_base_algorithm_0: (+1)
   \       0x12   0xF430 0x127E      BICS     R2,R0,#0x3F8000
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable37_2
   \       0x1A   0x428A             CMP      R2,R1
   \       0x1C   0xD102             BNE.N    ??psa_aead_get_base_algorithm_2
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable37_3
   \       0x22   0xE008             B.N      ??psa_aead_get_base_algorithm_1
   \                     ??psa_aead_get_base_algorithm_2: (+1)
   \       0x24   0xF430 0x107E      BICS     R0,R0,#0x3F8000
   \       0x28   0xF1B0 0x2F05      CMP      R0,#+83887360
   \       0x2C   0xD102             BNE.N    ??psa_aead_get_base_algorithm_3
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable37_4
   \       0x32   0xE000             B.N      ??psa_aead_get_base_algorithm_1
   \                     ??psa_aead_get_base_algorithm_3: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??psa_aead_get_base_algorithm_1: (+1)
   \       0x36   0x4770             BX       LR
   4542          }
   4543          
   4544          /* Helper function to perform common nonce length checks. */

   \                                 In section .text, align 2, keep-with-next
   4545          static psa_status_t psa_aead_check_nonce_length(psa_algorithm_t alg,
   4546                                                          size_t nonce_length)
   4547          {
   \                     psa_aead_check_nonce_length: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   4548              psa_algorithm_t base_alg = psa_aead_get_base_algorithm(alg);
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       psa_aead_get_base_algorithm
   \        0xC   0x0001             MOVS     R1,R0
   4549              psa_status_t status = PSA_ERROR_INVALID_ARGUMENT;
   \        0xE   0xF07F 0x0286      MVNS     R2,#+134
   4550          
   4551              switch (base_alg) {
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \       0x16   0x4281             CMP      R1,R0
   \       0x18   0xD106             BNE.N    ??psa_aead_check_nonce_length_0
   4552          #if defined(PSA_WANT_ALG_GCM)
   4553                  case PSA_ALG_GCM:
   4554                      /* Not checking max nonce size here as GCM spec allows almost
   4555                       * arbitrarily large nonces. Please note that we do not generally
   4556                       * recommend the usage of nonces of greater length than
   4557                       * PSA_AEAD_NONCE_MAX_SIZE, as large nonces are hashed to a shorter
   4558                       * size, which can then lead to collisions if you encrypt a very
   4559                       * large number of messages.*/
   4560                      if (nonce_length != 0) {
   4561                          return PSA_SUCCESS;
   4562                      }
   4563                      break;
   4564          #endif /* PSA_WANT_ALG_GCM */
   4565          #if defined(PSA_WANT_ALG_CCM)
   4566                  case PSA_ALG_CCM:
   4567                      if (nonce_length >= 7 && nonce_length <= 13) {
   \       0x1A   0x2D07             CMP      R5,#+7
   \       0x1C   0xD303             BCC.N    ??psa_aead_check_nonce_length_1
   \       0x1E   0x2D0E             CMP      R5,#+14
   \       0x20   0xD201             BCS.N    ??psa_aead_check_nonce_length_1
   4568                          return PSA_SUCCESS;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xE004             B.N      ??psa_aead_check_nonce_length_2
   4569                      }
   4570                      break;
   \                     ??psa_aead_check_nonce_length_1: (+1)
   \       0x26   0xE002             B.N      ??psa_aead_check_nonce_length_3
   4571          #endif /* PSA_WANT_ALG_CCM */
   4572          #if defined(PSA_WANT_ALG_CHACHA20_POLY1305)
   4573                  case PSA_ALG_CHACHA20_POLY1305:
   4574                      if (nonce_length == 12) {
   4575                          return PSA_SUCCESS;
   4576                      } else if (nonce_length == 8) {
   4577                          return PSA_ERROR_NOT_SUPPORTED;
   4578                      }
   4579                      break;
   4580          #endif /* PSA_WANT_ALG_CHACHA20_POLY1305 */
   4581                  default:
   4582                      (void)nonce_length;
   4583                      status = PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_aead_check_nonce_length_0: (+1)
   \       0x28   0xF07F 0x0085      MVNS     R0,#+133
   \       0x2C   0x0002             MOVS     R2,R0
   4584                      break;
   4585              }
   4586          
   4587              return status;
   \                     ??psa_aead_check_nonce_length_3: (+1)
   \       0x2E   0x0010             MOVS     R0,R2
   \                     ??psa_aead_check_nonce_length_2: (+1)
   \       0x30   0xBD32             POP      {R1,R4,R5,PC}
   4588          }
   4589          

   \                                 In section .text, align 2, keep-with-next
   4590          static psa_status_t psa_aead_check_algorithm(psa_algorithm_t alg)
   4591          {
   \                     psa_aead_check_algorithm: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   4592              if (!PSA_ALG_IS_AEAD(alg) || PSA_ALG_IS_WILDCARD(alg)) {
   \        0x2   0xF011 0x40FE      ANDS     R0,R1,#0x7F000000
   \        0x6   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \        0xA   0xD172             BNE.N    ??psa_aead_check_algorithm_0
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable37_5
   \       0x10   0x0A0A             LSRS     R2,R1,#+8
   \       0x12   0x0212             LSLS     R2,R2,#+8
   \       0x14   0x4282             CMP      R2,R0
   \       0x16   0xD01C             BEQ.N    ??psa_aead_check_algorithm_1
   \       0x18   0x0A0B             LSRS     R3,R1,#+8
   \       0x1A   0x021B             LSLS     R3,R3,#+8
   \       0x1C   0x.... 0x....      LDR.W    R2,??DataTable37_6
   \       0x20   0x4293             CMP      R3,R2
   \       0x22   0xD016             BEQ.N    ??psa_aead_check_algorithm_1
   \       0x24   0x0A0B             LSRS     R3,R1,#+8
   \       0x26   0x021B             LSLS     R3,R3,#+8
   \       0x28   0x.... 0x....      LDR.W    R2,??DataTable37_7
   \       0x2C   0x4293             CMP      R3,R2
   \       0x2E   0xD010             BEQ.N    ??psa_aead_check_algorithm_1
   \       0x30   0x0A4A             LSRS     R2,R1,#+9
   \       0x32   0x0252             LSLS     R2,R2,#+9
   \       0x34   0xF1B2 0x2F06      CMP      R2,#+100664832
   \       0x38   0xD00B             BEQ.N    ??psa_aead_check_algorithm_1
   \       0x3A   0x0A0B             LSRS     R3,R1,#+8
   \       0x3C   0x021B             LSLS     R3,R3,#+8
   \       0x3E   0x.... 0x....      LDR.W    R2,??DataTable37_8
   \       0x42   0x4293             CMP      R3,R2
   \       0x44   0xD005             BEQ.N    ??psa_aead_check_algorithm_1
   \       0x46   0x0A4B             LSRS     R3,R1,#+9
   \       0x48   0x025B             LSLS     R3,R3,#+9
   \       0x4A   0x.... 0x....      LDR.W    R2,??DataTable38
   \       0x4E   0x4293             CMP      R3,R2
   \       0x50   0xD132             BNE.N    ??psa_aead_check_algorithm_2
   \                     ??psa_aead_check_algorithm_1: (+1)
   \       0x52   0x060A             LSLS     R2,R1,#+24
   \       0x54   0xD030             BEQ.N    ??psa_aead_check_algorithm_2
   \       0x56   0x0A0A             LSRS     R2,R1,#+8
   \       0x58   0x0212             LSLS     R2,R2,#+8
   \       0x5A   0x4282             CMP      R2,R0
   \       0x5C   0xD01C             BEQ.N    ??psa_aead_check_algorithm_3
   \       0x5E   0x0A0A             LSRS     R2,R1,#+8
   \       0x60   0x0212             LSLS     R2,R2,#+8
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable37_6
   \       0x66   0x4282             CMP      R2,R0
   \       0x68   0xD016             BEQ.N    ??psa_aead_check_algorithm_3
   \       0x6A   0x0A0A             LSRS     R2,R1,#+8
   \       0x6C   0x0212             LSLS     R2,R2,#+8
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable37_7
   \       0x72   0x4282             CMP      R2,R0
   \       0x74   0xD010             BEQ.N    ??psa_aead_check_algorithm_3
   \       0x76   0x0A48             LSRS     R0,R1,#+9
   \       0x78   0x0240             LSLS     R0,R0,#+9
   \       0x7A   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x7E   0xD00B             BEQ.N    ??psa_aead_check_algorithm_3
   \       0x80   0x0A0A             LSRS     R2,R1,#+8
   \       0x82   0x0212             LSLS     R2,R2,#+8
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable37_8
   \       0x88   0x4282             CMP      R2,R0
   \       0x8A   0xD005             BEQ.N    ??psa_aead_check_algorithm_3
   \       0x8C   0x0A4A             LSRS     R2,R1,#+9
   \       0x8E   0x0252             LSLS     R2,R2,#+9
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable38
   \       0x94   0x4282             CMP      R2,R0
   \       0x96   0xD106             BNE.N    ??psa_aead_check_algorithm_4
   \                     ??psa_aead_check_algorithm_3: (+1)
   \       0x98   0x0608             LSLS     R0,R1,#+24
   \       0x9A   0xD004             BEQ.N    ??psa_aead_check_algorithm_4
   \       0x9C   0xF001 0x02FF      AND      R2,R1,#0xFF
   \       0xA0   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0xA4   0xE000             B.N      ??psa_aead_check_algorithm_5
   \                     ??psa_aead_check_algorithm_4: (+1)
   \       0xA6   0x2200             MOVS     R2,#+0
   \                     ??psa_aead_check_algorithm_5: (+1)
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable38_1
   \       0xAC   0x4282             CMP      R2,R0
   \       0xAE   0xD101             BNE.N    ??psa_aead_check_algorithm_6
   \       0xB0   0x2001             MOVS     R0,#+1
   \       0xB2   0xE01C             B.N      ??psa_aead_check_algorithm_7
   \                     ??psa_aead_check_algorithm_6: (+1)
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0xE01A             B.N      ??psa_aead_check_algorithm_7
   \                     ??psa_aead_check_algorithm_2: (+1)
   \       0xB8   0xF011 0x40FE      ANDS     R0,R1,#0x7F000000
   \       0xBC   0xF1B0 0x7F40      CMP      R0,#+50331648
   \       0xC0   0xD104             BNE.N    ??psa_aead_check_algorithm_8
   \       0xC2   0xF3C1 0x30C0      UBFX     R0,R1,#+15,#+1
   \       0xC6   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xCA   0xE010             B.N      ??psa_aead_check_algorithm_7
   \                     ??psa_aead_check_algorithm_8: (+1)
   \       0xCC   0xF011 0x40FE      ANDS     R0,R1,#0x7F000000
   \       0xD0   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \       0xD4   0xD104             BNE.N    ??psa_aead_check_algorithm_9
   \       0xD6   0xF3C1 0x30C0      UBFX     R0,R1,#+15,#+1
   \       0xDA   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xDE   0xE006             B.N      ??psa_aead_check_algorithm_7
   \                     ??psa_aead_check_algorithm_9: (+1)
   \       0xE0   0x.... 0x....      LDR.W    R0,??DataTable38_1
   \       0xE4   0x4281             CMP      R1,R0
   \       0xE6   0xD101             BNE.N    ??psa_aead_check_algorithm_10
   \       0xE8   0x2001             MOVS     R0,#+1
   \       0xEA   0xE000             B.N      ??psa_aead_check_algorithm_7
   \                     ??psa_aead_check_algorithm_10: (+1)
   \       0xEC   0x2000             MOVS     R0,#+0
   \                     ??psa_aead_check_algorithm_7: (+1)
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD002             BEQ.N    ??psa_aead_check_algorithm_11
   4593                  return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_aead_check_algorithm_0: (+1)
   \       0xF2   0xF07F 0x0086      MVNS     R0,#+134
   \       0xF6   0xE000             B.N      ??psa_aead_check_algorithm_12
   4594              }
   4595          
   4596              return PSA_SUCCESS;
   \                     ??psa_aead_check_algorithm_11: (+1)
   \       0xF8   0x2000             MOVS     R0,#+0
   \                     ??psa_aead_check_algorithm_12: (+1)
   \       0xFA   0x4770             BX       LR
   4597          }
   4598          

   \                                 In section .text, align 2, keep-with-next
   4599          psa_status_t psa_aead_encrypt(mbedtls_svc_key_id_t key,
   4600                                        psa_algorithm_t alg,
   4601                                        const uint8_t *nonce,
   4602                                        size_t nonce_length,
   4603                                        const uint8_t *additional_data,
   4604                                        size_t additional_data_length,
   4605                                        const uint8_t *plaintext,
   4606                                        size_t plaintext_length,
   4607                                        uint8_t *ciphertext,
   4608                                        size_t ciphertext_size,
   4609                                        size_t *ciphertext_length)
   4610          {
   \                     psa_aead_encrypt: (+1)
   \        0x0   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \        0x4   0xB093             SUB      SP,SP,#+76
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x001E             MOVS     R6,R3
   \        0xA   0x9F22             LDR      R7,[SP, #+136]
   \        0xC   0x9C23             LDR      R4,[SP, #+140]
   \        0xE   0xF8DD 0x8090      LDR      R8,[SP, #+144]
   4611              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x0596      MVNS     R5,#+150
   4612              psa_key_slot_t *slot;
   4613          
   4614              *ciphertext_length = 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF8C8 0x0000      STR      R0,[R8, #+0]
   4615          
   4616              status = psa_aead_check_algorithm(alg);
   \       0x1C   0x4648             MOV      R0,R9
   \       0x1E   0x.... 0x....      BL       psa_aead_check_algorithm
   \       0x22   0x4682             MOV      R10,R0
   4617              if (status != PSA_SUCCESS) {
   \       0x24   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x28   0xD001             BEQ.N    ??psa_aead_encrypt_0
   4618                  return status;
   \       0x2A   0x4650             MOV      R0,R10
   \       0x2C   0xE046             B.N      ??psa_aead_encrypt_1
   4619              }
   4620          
   4621              status = psa_get_and_lock_key_slot_with_policy(
   4622                  key, &slot, PSA_KEY_USAGE_ENCRYPT, alg);
   \                     ??psa_aead_encrypt_0: (+1)
   \       0x2E   0x464B             MOV      R3,R9
   \       0x30   0xF44F 0x7280      MOV      R2,#+256
   \       0x34   0xA909             ADD      R1,SP,#+36
   \       0x36   0x9813             LDR      R0,[SP, #+76]
   \       0x38   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x3C   0x0005             MOVS     R5,R0
   4623              if (status != PSA_SUCCESS) {
   \       0x3E   0x2D00             CMP      R5,#+0
   \       0x40   0xD001             BEQ.N    ??psa_aead_encrypt_2
   4624                  return status;
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0xE03A             B.N      ??psa_aead_encrypt_1
   4625              }
   4626          
   4627              psa_key_attributes_t attributes = {
   4628                  .core = slot->attr
   4629              };
   \                     ??psa_aead_encrypt_2: (+1)
   \       0x46   0xA80A             ADD      R0,SP,#+40
   \       0x48   0x2124             MOVS     R1,#+36
   \       0x4A   0x.... 0x....      BL       __aeabi_memclr4
   \       0x4E   0xA80A             ADD      R0,SP,#+40
   \       0x50   0x9909             LDR      R1,[SP, #+36]
   \       0x52   0x221C             MOVS     R2,#+28
   \       0x54   0x.... 0x....      BL       __aeabi_memcpy4
   4630          
   4631              status = psa_aead_check_nonce_length(alg, nonce_length);
   \       0x58   0x0031             MOVS     R1,R6
   \       0x5A   0x4648             MOV      R0,R9
   \       0x5C   0x.... 0x....      BL       psa_aead_check_nonce_length
   \       0x60   0x4682             MOV      R10,R0
   4632              if (status != PSA_SUCCESS) {
   \       0x62   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x66   0xD125             BNE.N    ??psa_aead_encrypt_3
   4633                  goto exit;
   4634              }
   4635          
   4636              status = psa_driver_wrapper_aead_encrypt(
   4637                  &attributes, slot->key.data, slot->key.bytes,
   4638                  alg,
   4639                  nonce, nonce_length,
   4640                  additional_data, additional_data_length,
   4641                  plaintext, plaintext_length,
   4642                  ciphertext, ciphertext_size, ciphertext_length);
   \                     ??psa_aead_encrypt_4: (+1)
   \       0x68   0xF8CD 0x8020      STR      R8,[SP, #+32]
   \       0x6C   0x9407             STR      R4,[SP, #+28]
   \       0x6E   0x9706             STR      R7,[SP, #+24]
   \       0x70   0x9821             LDR      R0,[SP, #+132]
   \       0x72   0x9005             STR      R0,[SP, #+20]
   \       0x74   0x9820             LDR      R0,[SP, #+128]
   \       0x76   0x9004             STR      R0,[SP, #+16]
   \       0x78   0x981F             LDR      R0,[SP, #+124]
   \       0x7A   0x9003             STR      R0,[SP, #+12]
   \       0x7C   0x981E             LDR      R0,[SP, #+120]
   \       0x7E   0x9002             STR      R0,[SP, #+8]
   \       0x80   0x9601             STR      R6,[SP, #+4]
   \       0x82   0x9814             LDR      R0,[SP, #+80]
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x464B             MOV      R3,R9
   \       0x88   0x9809             LDR      R0,[SP, #+36]
   \       0x8A   0x6A82             LDR      R2,[R0, #+40]
   \       0x8C   0x9809             LDR      R0,[SP, #+36]
   \       0x8E   0x6A41             LDR      R1,[R0, #+36]
   \       0x90   0xA80A             ADD      R0,SP,#+40
   \       0x92   0x.... 0x....      BL       psa_driver_wrapper_aead_encrypt
   \       0x96   0x4682             MOV      R10,R0
   4643          
   4644              if (status != PSA_SUCCESS && ciphertext_size != 0) {
   \       0x98   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x9C   0xD00A             BEQ.N    ??psa_aead_encrypt_3
   \       0x9E   0x2C00             CMP      R4,#+0
   \       0xA0   0xD008             BEQ.N    ??psa_aead_encrypt_3
   4645                  memset(ciphertext, 0, ciphertext_size);
   \       0xA2   0x9400             STR      R4,[SP, #+0]
   \       0xA4   0xF05F 0x0B00      MOVS     R11,#+0
   \       0xA8   0x003D             MOVS     R5,R7
   \       0xAA   0x465A             MOV      R2,R11
   \       0xAC   0x9900             LDR      R1,[SP, #+0]
   \       0xAE   0x0028             MOVS     R0,R5
   \       0xB0   0x.... 0x....      BL       __aeabi_memset
   4646              }
   4647          
   4648          exit:
   4649              psa_unlock_key_slot(slot);
   \                     ??psa_aead_encrypt_3: (+1)
   \       0xB4   0x9809             LDR      R0,[SP, #+36]
   \       0xB6   0x.... 0x....      BL       psa_unlock_key_slot
   4650          
   4651              return status;
   \       0xBA   0x4650             MOV      R0,R10
   \                     ??psa_aead_encrypt_1: (+1)
   \       0xBC   0xB015             ADD      SP,SP,#+84
   \       0xBE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4652          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   4653          

   \                                 In section .text, align 2, keep-with-next
   4654          psa_status_t psa_aead_decrypt(mbedtls_svc_key_id_t key,
   4655                                        psa_algorithm_t alg,
   4656                                        const uint8_t *nonce,
   4657                                        size_t nonce_length,
   4658                                        const uint8_t *additional_data,
   4659                                        size_t additional_data_length,
   4660                                        const uint8_t *ciphertext,
   4661                                        size_t ciphertext_length,
   4662                                        uint8_t *plaintext,
   4663                                        size_t plaintext_size,
   4664                                        size_t *plaintext_length)
   4665          {
   \                     psa_aead_decrypt: (+1)
   \        0x0   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \        0x4   0xB093             SUB      SP,SP,#+76
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x001E             MOVS     R6,R3
   \        0xA   0x9F22             LDR      R7,[SP, #+136]
   \        0xC   0x9C23             LDR      R4,[SP, #+140]
   \        0xE   0xF8DD 0x8090      LDR      R8,[SP, #+144]
   4666              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x0596      MVNS     R5,#+150
   4667              psa_key_slot_t *slot;
   4668          
   4669              *plaintext_length = 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF8C8 0x0000      STR      R0,[R8, #+0]
   4670          
   4671              status = psa_aead_check_algorithm(alg);
   \       0x1C   0x4648             MOV      R0,R9
   \       0x1E   0x.... 0x....      BL       psa_aead_check_algorithm
   \       0x22   0x4682             MOV      R10,R0
   4672              if (status != PSA_SUCCESS) {
   \       0x24   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x28   0xD001             BEQ.N    ??psa_aead_decrypt_0
   4673                  return status;
   \       0x2A   0x4650             MOV      R0,R10
   \       0x2C   0xE046             B.N      ??psa_aead_decrypt_1
   4674              }
   4675          
   4676              status = psa_get_and_lock_key_slot_with_policy(
   4677                  key, &slot, PSA_KEY_USAGE_DECRYPT, alg);
   \                     ??psa_aead_decrypt_0: (+1)
   \       0x2E   0x464B             MOV      R3,R9
   \       0x30   0xF44F 0x7200      MOV      R2,#+512
   \       0x34   0xA909             ADD      R1,SP,#+36
   \       0x36   0x9813             LDR      R0,[SP, #+76]
   \       0x38   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x3C   0x0005             MOVS     R5,R0
   4678              if (status != PSA_SUCCESS) {
   \       0x3E   0x2D00             CMP      R5,#+0
   \       0x40   0xD001             BEQ.N    ??psa_aead_decrypt_2
   4679                  return status;
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0xE03A             B.N      ??psa_aead_decrypt_1
   4680              }
   4681          
   4682              psa_key_attributes_t attributes = {
   4683                  .core = slot->attr
   4684              };
   \                     ??psa_aead_decrypt_2: (+1)
   \       0x46   0xA80A             ADD      R0,SP,#+40
   \       0x48   0x2124             MOVS     R1,#+36
   \       0x4A   0x.... 0x....      BL       __aeabi_memclr4
   \       0x4E   0xA80A             ADD      R0,SP,#+40
   \       0x50   0x9909             LDR      R1,[SP, #+36]
   \       0x52   0x221C             MOVS     R2,#+28
   \       0x54   0x.... 0x....      BL       __aeabi_memcpy4
   4685          
   4686              status = psa_aead_check_nonce_length(alg, nonce_length);
   \       0x58   0x0031             MOVS     R1,R6
   \       0x5A   0x4648             MOV      R0,R9
   \       0x5C   0x.... 0x....      BL       psa_aead_check_nonce_length
   \       0x60   0x4682             MOV      R10,R0
   4687              if (status != PSA_SUCCESS) {
   \       0x62   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x66   0xD125             BNE.N    ??psa_aead_decrypt_3
   4688                  goto exit;
   4689              }
   4690          
   4691              status = psa_driver_wrapper_aead_decrypt(
   4692                  &attributes, slot->key.data, slot->key.bytes,
   4693                  alg,
   4694                  nonce, nonce_length,
   4695                  additional_data, additional_data_length,
   4696                  ciphertext, ciphertext_length,
   4697                  plaintext, plaintext_size, plaintext_length);
   \                     ??psa_aead_decrypt_4: (+1)
   \       0x68   0xF8CD 0x8020      STR      R8,[SP, #+32]
   \       0x6C   0x9407             STR      R4,[SP, #+28]
   \       0x6E   0x9706             STR      R7,[SP, #+24]
   \       0x70   0x9821             LDR      R0,[SP, #+132]
   \       0x72   0x9005             STR      R0,[SP, #+20]
   \       0x74   0x9820             LDR      R0,[SP, #+128]
   \       0x76   0x9004             STR      R0,[SP, #+16]
   \       0x78   0x981F             LDR      R0,[SP, #+124]
   \       0x7A   0x9003             STR      R0,[SP, #+12]
   \       0x7C   0x981E             LDR      R0,[SP, #+120]
   \       0x7E   0x9002             STR      R0,[SP, #+8]
   \       0x80   0x9601             STR      R6,[SP, #+4]
   \       0x82   0x9814             LDR      R0,[SP, #+80]
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x464B             MOV      R3,R9
   \       0x88   0x9809             LDR      R0,[SP, #+36]
   \       0x8A   0x6A82             LDR      R2,[R0, #+40]
   \       0x8C   0x9809             LDR      R0,[SP, #+36]
   \       0x8E   0x6A41             LDR      R1,[R0, #+36]
   \       0x90   0xA80A             ADD      R0,SP,#+40
   \       0x92   0x.... 0x....      BL       psa_driver_wrapper_aead_decrypt
   \       0x96   0x4682             MOV      R10,R0
   4698          
   4699              if (status != PSA_SUCCESS && plaintext_size != 0) {
   \       0x98   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x9C   0xD00A             BEQ.N    ??psa_aead_decrypt_3
   \       0x9E   0x2C00             CMP      R4,#+0
   \       0xA0   0xD008             BEQ.N    ??psa_aead_decrypt_3
   4700                  memset(plaintext, 0, plaintext_size);
   \       0xA2   0x9400             STR      R4,[SP, #+0]
   \       0xA4   0xF05F 0x0B00      MOVS     R11,#+0
   \       0xA8   0x003D             MOVS     R5,R7
   \       0xAA   0x465A             MOV      R2,R11
   \       0xAC   0x9900             LDR      R1,[SP, #+0]
   \       0xAE   0x0028             MOVS     R0,R5
   \       0xB0   0x.... 0x....      BL       __aeabi_memset
   4701              }
   4702          
   4703          exit:
   4704              psa_unlock_key_slot(slot);
   \                     ??psa_aead_decrypt_3: (+1)
   \       0xB4   0x9809             LDR      R0,[SP, #+36]
   \       0xB6   0x.... 0x....      BL       psa_unlock_key_slot
   4705          
   4706              return status;
   \       0xBA   0x4650             MOV      R0,R10
   \                     ??psa_aead_decrypt_1: (+1)
   \       0xBC   0xB015             ADD      SP,SP,#+84
   \       0xBE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4707          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   4708          

   \                                 In section .text, align 2, keep-with-next
   4709          static psa_status_t psa_validate_tag_length(psa_algorithm_t alg)
   4710          {
   \                     psa_validate_tag_length: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0001             MOVS     R1,R0
   4711              const uint8_t tag_len = PSA_ALG_AEAD_GET_TAG_LENGTH(alg);
   \        0x4   0x000A             MOVS     R2,R1
   \        0x6   0x0C12             LSRS     R2,R2,#+16
   \        0x8   0xF012 0x023F      ANDS     R2,R2,#0x3F
   4712              psa_status_t status = PSA_SUCCESS;
   \        0xC   0x2300             MOVS     R3,#+0
   4713          
   4714          
   4715              switch (PSA_ALG_AEAD_WITH_SHORTENED_TAG(alg, 0)) {
   \        0xE   0xF431 0x147E      BICS     R4,R1,#0x3F8000
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable37
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD10D             BNE.N    ??psa_validate_tag_length_0
   4716          #if defined(PSA_WANT_ALG_CCM)
   4717                  case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, 0):
   4718                      /* CCM allows the following tag lengths: 4, 6, 8, 10, 12, 14, 16.*/
   4719                      if (tag_len < 4 || tag_len > 16 || tag_len % 2) {
   \       0x1A   0x0010             MOVS     R0,R2
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x2804             CMP      R0,#+4
   \       0x20   0xDB05             BLT.N    ??psa_validate_tag_length_1
   \       0x22   0x0010             MOVS     R0,R2
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2811             CMP      R0,#+17
   \       0x28   0xDA01             BGE.N    ??psa_validate_tag_length_1
   \       0x2A   0x07D0             LSLS     R0,R2,#+31
   \       0x2C   0xD502             BPL.N    ??psa_validate_tag_length_2
   4720                          return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_validate_tag_length_1: (+1)
   \       0x2E   0xF07F 0x0086      MVNS     R0,#+134
   \       0x32   0xE004             B.N      ??psa_validate_tag_length_3
   4721                      }
   4722                      break;
   \                     ??psa_validate_tag_length_2: (+1)
   \       0x34   0xE002             B.N      ??psa_validate_tag_length_4
   4723          #endif /* PSA_WANT_ALG_CCM */
   4724          
   4725          #if defined(PSA_WANT_ALG_GCM)
   4726                  case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, 0):
   4727                      /* GCM allows the following tag lengths: 4, 8, 12, 13, 14, 15, 16. */
   4728                      if (tag_len != 4 && tag_len != 8 && (tag_len < 12 || tag_len > 16)) {
   4729                          return PSA_ERROR_INVALID_ARGUMENT;
   4730                      }
   4731                      break;
   4732          #endif /* PSA_WANT_ALG_GCM */
   4733          
   4734          #if defined(PSA_WANT_ALG_CHACHA20_POLY1305)
   4735                  case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CHACHA20_POLY1305, 0):
   4736                      /* We only support the default tag length. */
   4737                      if (tag_len != 16) {
   4738                          return PSA_ERROR_INVALID_ARGUMENT;
   4739                      }
   4740                      break;
   4741          #endif /* PSA_WANT_ALG_CHACHA20_POLY1305 */
   4742          
   4743                  default:
   4744                      (void) tag_len;
   4745                      status = PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_validate_tag_length_0: (+1)
   \       0x36   0xF07F 0x0085      MVNS     R0,#+133
   \       0x3A   0x0003             MOVS     R3,R0
   4746              }
   4747              return status;
   \                     ??psa_validate_tag_length_4: (+1)
   \       0x3C   0x0018             MOVS     R0,R3
   \                     ??psa_validate_tag_length_3: (+1)
   \       0x3E   0xBC10             POP      {R4}
   \       0x40   0x4770             BX       LR
   4748          }
   4749          
   4750          /* Set the key for a multipart authenticated operation. */

   \                                 In section .text, align 2, keep-with-next
   4751          static psa_status_t psa_aead_setup(psa_aead_operation_t *operation,
   4752                                             int is_encrypt,
   4753                                             mbedtls_svc_key_id_t key,
   4754                                             psa_algorithm_t alg)
   4755          {
   \                     psa_aead_setup: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   4756              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0A96      MVNS     R10,#+150
   \       0x12   0x46D3             MOV      R11,R10
   4757              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   4758              psa_key_slot_t *slot = NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9001             STR      R0,[SP, #+4]
   4759              psa_key_usage_t key_usage = 0;
   \       0x18   0xF05F 0x0800      MOVS     R8,#+0
   4760              psa_key_attributes_t attributes;
   4761          
   4762              status = psa_aead_check_algorithm(alg);
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0x.... 0x....      BL       psa_aead_check_algorithm
   \       0x22   0x0004             MOVS     R4,R0
   4763              if (status != PSA_SUCCESS) {
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD154             BNE.N    ??psa_aead_setup_0
   4764                  goto exit;
   4765              }
   4766          
   4767              if (operation->id != 0) {
   \                     ??psa_aead_setup_1: (+1)
   \       0x28   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD003             BEQ.N    ??psa_aead_setup_2
   4768                  status = PSA_ERROR_BAD_STATE;
   \       0x30   0xF07F 0x0088      MVNS     R0,#+136
   \       0x34   0x0004             MOVS     R4,R0
   4769                  goto exit;
   \       0x36   0xE04C             B.N      ??psa_aead_setup_0
   4770              }
   4771          
   4772              if (operation->nonce_set || operation->lengths_set ||
   4773                  operation->ad_started || operation->body_started) {
   \                     ??psa_aead_setup_2: (+1)
   \       0x38   0xF899 0x0014      LDRB     R0,[R9, #+20]
   \       0x3C   0xF010 0x0F0F      TST      R0,#0xF
   \       0x40   0xD003             BEQ.N    ??psa_aead_setup_3
   4774                  status = PSA_ERROR_BAD_STATE;
   \       0x42   0xF07F 0x0088      MVNS     R0,#+136
   \       0x46   0x0004             MOVS     R4,R0
   4775                  goto exit;
   \       0x48   0xE043             B.N      ??psa_aead_setup_0
   4776              }
   4777          
   4778              if (is_encrypt) {
   \                     ??psa_aead_setup_3: (+1)
   \       0x4A   0x2D00             CMP      R5,#+0
   \       0x4C   0xD003             BEQ.N    ??psa_aead_setup_4
   4779                  key_usage = PSA_KEY_USAGE_ENCRYPT;
   \       0x4E   0xF44F 0x7080      MOV      R0,#+256
   \       0x52   0x4680             MOV      R8,R0
   \       0x54   0xE002             B.N      ??psa_aead_setup_5
   4780              } else {
   4781                  key_usage = PSA_KEY_USAGE_DECRYPT;
   \                     ??psa_aead_setup_4: (+1)
   \       0x56   0xF44F 0x7000      MOV      R0,#+512
   \       0x5A   0x4680             MOV      R8,R0
   4782              }
   4783          
   4784              status = psa_get_and_lock_key_slot_with_policy(key, &slot, key_usage,
   4785                                                             alg);
   \                     ??psa_aead_setup_5: (+1)
   \       0x5C   0x003B             MOVS     R3,R7
   \       0x5E   0x4642             MOV      R2,R8
   \       0x60   0xA901             ADD      R1,SP,#+4
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x68   0x0004             MOVS     R4,R0
   4786              if (status != PSA_SUCCESS) {
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD131             BNE.N    ??psa_aead_setup_0
   4787                  goto exit;
   4788              }
   4789          
   4790              attributes = (psa_key_attributes_t) {
   4791                  .core = slot->attr
   4792              };
   \                     ??psa_aead_setup_6: (+1)
   \       0x6E   0xA80B             ADD      R0,SP,#+44
   \       0x70   0x2124             MOVS     R1,#+36
   \       0x72   0x.... 0x....      BL       __aeabi_memclr4
   \       0x76   0xA80B             ADD      R0,SP,#+44
   \       0x78   0x9901             LDR      R1,[SP, #+4]
   \       0x7A   0x221C             MOVS     R2,#+28
   \       0x7C   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x80   0xA802             ADD      R0,SP,#+8
   \       0x82   0xA90B             ADD      R1,SP,#+44
   \       0x84   0x2224             MOVS     R2,#+36
   \       0x86   0x.... 0x....      BL       __aeabi_memcpy4
   4793          
   4794              if ((status = psa_validate_tag_length(alg)) != PSA_SUCCESS) {
   \       0x8A   0x0038             MOVS     R0,R7
   \       0x8C   0x.... 0x....      BL       psa_validate_tag_length
   \       0x90   0x0004             MOVS     R4,R0
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD11D             BNE.N    ??psa_aead_setup_0
   4795                  goto exit;
   4796              }
   4797          
   4798              if (is_encrypt) {
   \                     ??psa_aead_setup_7: (+1)
   \       0x96   0x2D00             CMP      R5,#+0
   \       0x98   0xD00A             BEQ.N    ??psa_aead_setup_8
   4799                  status = psa_driver_wrapper_aead_encrypt_setup(operation,
   4800                                                                 &attributes,
   4801                                                                 slot->key.data,
   4802                                                                 slot->key.bytes,
   4803                                                                 alg);
   \       0x9A   0x9700             STR      R7,[SP, #+0]
   \       0x9C   0x9801             LDR      R0,[SP, #+4]
   \       0x9E   0x6A83             LDR      R3,[R0, #+40]
   \       0xA0   0x9801             LDR      R0,[SP, #+4]
   \       0xA2   0x6A42             LDR      R2,[R0, #+36]
   \       0xA4   0xA902             ADD      R1,SP,#+8
   \       0xA6   0x4648             MOV      R0,R9
   \       0xA8   0x.... 0x....      BL       psa_driver_wrapper_aead_encrypt_setup
   \       0xAC   0x0004             MOVS     R4,R0
   \       0xAE   0xE009             B.N      ??psa_aead_setup_9
   4804              } else {
   4805                  status = psa_driver_wrapper_aead_decrypt_setup(operation,
   4806                                                                 &attributes,
   4807                                                                 slot->key.data,
   4808                                                                 slot->key.bytes,
   4809                                                                 alg);
   \                     ??psa_aead_setup_8: (+1)
   \       0xB0   0x9700             STR      R7,[SP, #+0]
   \       0xB2   0x9801             LDR      R0,[SP, #+4]
   \       0xB4   0x6A83             LDR      R3,[R0, #+40]
   \       0xB6   0x9801             LDR      R0,[SP, #+4]
   \       0xB8   0x6A42             LDR      R2,[R0, #+36]
   \       0xBA   0xA902             ADD      R1,SP,#+8
   \       0xBC   0x4648             MOV      R0,R9
   \       0xBE   0x.... 0x....      BL       psa_driver_wrapper_aead_decrypt_setup
   \       0xC2   0x0004             MOVS     R4,R0
   4810              }
   4811              if (status != PSA_SUCCESS) {
   \                     ??psa_aead_setup_9: (+1)
   \       0xC4   0x2C00             CMP      R4,#+0
   \       0xC6   0xD104             BNE.N    ??psa_aead_setup_0
   4812                  goto exit;
   4813              }
   4814          
   4815              operation->key_type = psa_get_key_type(&attributes);
   \                     ??psa_aead_setup_10: (+1)
   \       0xC8   0xA802             ADD      R0,SP,#+8
   \       0xCA   0x.... 0x....      BL       psa_get_key_type
   \       0xCE   0xF8A9 0x0008      STRH     R0,[R9, #+8]
   4816          
   4817          exit:
   4818              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_aead_setup_0: (+1)
   \       0xD2   0x9801             LDR      R0,[SP, #+4]
   \       0xD4   0x.... 0x....      BL       psa_unlock_key_slot
   \       0xD8   0x4683             MOV      R11,R0
   4819          
   4820              if (status == PSA_SUCCESS) {
   \       0xDA   0x2C00             CMP      R4,#+0
   \       0xDC   0xD10C             BNE.N    ??psa_aead_setup_11
   4821                  status = unlock_status;
   \       0xDE   0x465C             MOV      R4,R11
   4822                  operation->alg = psa_aead_get_base_algorithm(alg);
   \       0xE0   0x0038             MOVS     R0,R7
   \       0xE2   0x.... 0x....      BL       psa_aead_get_base_algorithm
   \       0xE6   0xF8C9 0x0004      STR      R0,[R9, #+4]
   4823                  operation->is_encrypt = is_encrypt;
   \       0xEA   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \       0xEE   0xF365 0x1004      BFI      R0,R5,#+4,#+1
   \       0xF2   0xF8C9 0x0014      STR      R0,[R9, #+20]
   \       0xF6   0xE002             B.N      ??psa_aead_setup_12
   4824              } else {
   4825                  psa_aead_abort(operation);
   \                     ??psa_aead_setup_11: (+1)
   \       0xF8   0x4648             MOV      R0,R9
   \       0xFA   0x.... 0x....      BL       psa_aead_abort
   4826              }
   4827          
   4828              return status;
   \                     ??psa_aead_setup_12: (+1)
   \       0xFE   0x0020             MOVS     R0,R4
   \      0x100   0xB015             ADD      SP,SP,#+84
   \      0x102   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4829          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   4830          
   4831          /* Set the key for a multipart authenticated encryption operation. */

   \                                 In section .text, align 2, keep-with-next
   4832          psa_status_t psa_aead_encrypt_setup(psa_aead_operation_t *operation,
   4833                                              mbedtls_svc_key_id_t key,
   4834                                              psa_algorithm_t alg)
   4835          {
   \                     psa_aead_encrypt_setup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   4836              return psa_aead_setup(operation, 1, key, alg);
   \        0x8   0x002B             MOVS     R3,R5
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       psa_aead_setup
   \       0x14   0xBD70             POP      {R4-R6,PC}
   4837          }
   4838          
   4839          /* Set the key for a multipart authenticated decryption operation. */

   \                                 In section .text, align 2, keep-with-next
   4840          psa_status_t psa_aead_decrypt_setup(psa_aead_operation_t *operation,
   4841                                              mbedtls_svc_key_id_t key,
   4842                                              psa_algorithm_t alg)
   4843          {
   \                     psa_aead_decrypt_setup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   4844              return psa_aead_setup(operation, 0, key, alg);
   \        0x8   0x002B             MOVS     R3,R5
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       psa_aead_setup
   \       0x14   0xBD70             POP      {R4-R6,PC}
   4845          }
   4846          
   4847          /* Generate a random nonce / IV for multipart AEAD operation */

   \                                 In section .text, align 2, keep-with-next
   4848          psa_status_t psa_aead_generate_nonce(psa_aead_operation_t *operation,
   4849                                               uint8_t *nonce,
   4850                                               size_t nonce_size,
   4851                                               size_t *nonce_length)
   4852          {
   \                     psa_aead_generate_nonce: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   4853              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   4854              uint8_t local_nonce[PSA_AEAD_NONCE_MAX_SIZE];
   4855              size_t required_nonce_size = 0;
   \       0x12   0xF05F 0x0A00      MOVS     R10,#+0
   4856          
   4857              *nonce_length = 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x6038             STR      R0,[R7, #+0]
   4858          
   4859              if (operation->id == 0) {
   \       0x1A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD102             BNE.N    ??psa_aead_generate_nonce_0
   4860                  status = PSA_ERROR_BAD_STATE;
   \       0x22   0xF07F 0x0488      MVNS     R4,#+136
   4861                  goto exit;
   \       0x26   0xE05F             B.N      ??psa_aead_generate_nonce_1
   4862              }
   4863          
   4864              if (operation->nonce_set || !operation->is_encrypt) {
   \                     ??psa_aead_generate_nonce_0: (+1)
   \       0x28   0xF899 0x0014      LDRB     R0,[R9, #+20]
   \       0x2C   0xF010 0x0011      ANDS     R0,R0,#0x11
   \       0x30   0x2810             CMP      R0,#+16
   \       0x32   0xD002             BEQ.N    ??psa_aead_generate_nonce_2
   4865                  status = PSA_ERROR_BAD_STATE;
   \       0x34   0xF07F 0x0488      MVNS     R4,#+136
   4866                  goto exit;
   \       0x38   0xE056             B.N      ??psa_aead_generate_nonce_1
   4867              }
   4868          
   4869              /* For CCM, this size may not be correct according to the PSA
   4870               * specification. The PSA Crypto 1.0.1 specification states:
   4871               *
   4872               * CCM encodes the plaintext length pLen in L octets, with L the smallest
   4873               * integer >= 2 where pLen < 2^(8L). The nonce length is then 15 - L bytes.
   4874               *
   4875               * However this restriction that L has to be the smallest integer is not
   4876               * applied in practice, and it is not implementable here since the
   4877               * plaintext length may or may not be known at this time. */
   4878              required_nonce_size = PSA_AEAD_NONCE_LENGTH(operation->key_type,
   4879                                                          operation->alg);
   \                     ??psa_aead_generate_nonce_2: (+1)
   \       0x3A   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \       0x3E   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x42   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x46   0xD108             BNE.N    ??psa_aead_generate_nonce_3
   \       0x48   0x2101             MOVS     R1,#+1
   \       0x4A   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \       0x4E   0xB280             UXTH     R0,R0
   \       0x50   0x0A00             LSRS     R0,R0,#+8
   \       0x52   0xF010 0x0007      ANDS     R0,R0,#0x7
   \       0x56   0x4081             LSLS     R1,R1,R0
   \       0x58   0xE000             B.N      ??psa_aead_generate_nonce_4
   \                     ??psa_aead_generate_nonce_3: (+1)
   \       0x5A   0x2100             MOVS     R1,#+0
   \                     ??psa_aead_generate_nonce_4: (+1)
   \       0x5C   0x2910             CMP      R1,#+16
   \       0x5E   0xD11C             BNE.N    ??psa_aead_generate_nonce_5
   \       0x60   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x64   0xF080 0x60AA      EOR      R0,R0,#0x5500000
   \       0x68   0xF490 0x7080      EORS     R0,R0,#0x100
   \       0x6C   0xF430 0x107E      BICS     R0,R0,#0x3F8000
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD102             BNE.N    ??psa_aead_generate_nonce_6
   \       0x74   0xF05F 0x0A0D      MOVS     R10,#+13
   \       0x78   0xE024             B.N      ??psa_aead_generate_nonce_7
   \                     ??psa_aead_generate_nonce_6: (+1)
   \       0x7A   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x7E   0xF080 0x60AA      EOR      R0,R0,#0x5500000
   \       0x82   0xF490 0x7000      EORS     R0,R0,#0x200
   \       0x86   0xF430 0x107E      BICS     R0,R0,#0x3F8000
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD102             BNE.N    ??psa_aead_generate_nonce_8
   \       0x8E   0xF05F 0x0A0C      MOVS     R10,#+12
   \       0x92   0xE017             B.N      ??psa_aead_generate_nonce_7
   \                     ??psa_aead_generate_nonce_8: (+1)
   \       0x94   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x98   0xE014             B.N      ??psa_aead_generate_nonce_7
   \                     ??psa_aead_generate_nonce_5: (+1)
   \       0x9A   0xF8B9 0x1008      LDRH     R1,[R9, #+8]
   \       0x9E   0xF242 0x0004      MOVW     R0,#+8196
   \       0xA2   0x4281             CMP      R1,R0
   \       0xA4   0xD10C             BNE.N    ??psa_aead_generate_nonce_9
   \       0xA6   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0xAA   0xF080 0x60A2      EOR      R0,R0,#0x5100000
   \       0xAE   0xF490 0x60A0      EORS     R0,R0,#0x500
   \       0xB2   0xF430 0x107E      BICS     R0,R0,#0x3F8000
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD102             BNE.N    ??psa_aead_generate_nonce_9
   \       0xBA   0xF05F 0x0A0C      MOVS     R10,#+12
   \       0xBE   0xE001             B.N      ??psa_aead_generate_nonce_7
   \                     ??psa_aead_generate_nonce_9: (+1)
   \       0xC0   0xF05F 0x0A00      MOVS     R10,#+0
   4880              if (nonce_size < required_nonce_size) {
   \                     ??psa_aead_generate_nonce_7: (+1)
   \       0xC4   0x4556             CMP      R6,R10
   \       0xC6   0xD202             BCS.N    ??psa_aead_generate_nonce_10
   4881                  status = PSA_ERROR_BUFFER_TOO_SMALL;
   \       0xC8   0xF07F 0x0489      MVNS     R4,#+137
   4882                  goto exit;
   \       0xCC   0xE00C             B.N      ??psa_aead_generate_nonce_1
   4883              }
   4884          
   4885              status = psa_generate_random(local_nonce, required_nonce_size);
   \                     ??psa_aead_generate_nonce_10: (+1)
   \       0xCE   0x4651             MOV      R1,R10
   \       0xD0   0xA801             ADD      R0,SP,#+4
   \       0xD2   0x.... 0x....      BL       psa_generate_random
   \       0xD6   0x0004             MOVS     R4,R0
   4886              if (status != PSA_SUCCESS) {
   \       0xD8   0x2C00             CMP      R4,#+0
   \       0xDA   0xD105             BNE.N    ??psa_aead_generate_nonce_1
   4887                  goto exit;
   4888              }
   4889          
   4890              status = psa_aead_set_nonce(operation, local_nonce, required_nonce_size);
   \                     ??psa_aead_generate_nonce_11: (+1)
   \       0xDC   0x4652             MOV      R2,R10
   \       0xDE   0xA901             ADD      R1,SP,#+4
   \       0xE0   0x4648             MOV      R0,R9
   \       0xE2   0x.... 0x....      BL       psa_aead_set_nonce
   \       0xE6   0x0004             MOVS     R4,R0
   4891          
   4892          exit:
   4893              if (status == PSA_SUCCESS) {
   \                     ??psa_aead_generate_nonce_1: (+1)
   \       0xE8   0x2C00             CMP      R4,#+0
   \       0xEA   0xD10C             BNE.N    ??psa_aead_generate_nonce_12
   4894                  memcpy(nonce, local_nonce, required_nonce_size);
   \       0xEC   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \       0xF0   0xF10D 0x0B04      ADD      R11,SP,#+4
   \       0xF4   0x46A8             MOV      R8,R5
   \       0xF6   0x9A00             LDR      R2,[SP, #+0]
   \       0xF8   0x4659             MOV      R1,R11
   \       0xFA   0x4640             MOV      R0,R8
   \       0xFC   0x.... 0x....      BL       __aeabi_memcpy
   4895                  *nonce_length = required_nonce_size;
   \      0x100   0xF8C7 0xA000      STR      R10,[R7, #+0]
   \      0x104   0xE002             B.N      ??psa_aead_generate_nonce_13
   4896              } else {
   4897                  psa_aead_abort(operation);
   \                     ??psa_aead_generate_nonce_12: (+1)
   \      0x106   0x4648             MOV      R0,R9
   \      0x108   0x.... 0x....      BL       psa_aead_abort
   4898              }
   4899          
   4900              return status;
   \                     ??psa_aead_generate_nonce_13: (+1)
   \      0x10C   0x0020             MOVS     R0,R4
   \      0x10E   0xB005             ADD      SP,SP,#+20
   \      0x110   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4901          }
   4902          
   4903          /* Set the nonce for a multipart authenticated encryption or decryption
   4904             operation.*/

   \                                 In section .text, align 2, keep-with-next
   4905          psa_status_t psa_aead_set_nonce(psa_aead_operation_t *operation,
   4906                                          const uint8_t *nonce,
   4907                                          size_t nonce_length)
   4908          {
   \                     psa_aead_set_nonce: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   4909              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0996      MVNS     R9,#+150
   4910          
   4911              if (operation->id == 0) {
   \        0xE   0x6830             LDR      R0,[R6, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??psa_aead_set_nonce_0
   4912                  status = PSA_ERROR_BAD_STATE;
   \       0x14   0xF07F 0x0488      MVNS     R4,#+136
   4913                  goto exit;
   \       0x18   0xE015             B.N      ??psa_aead_set_nonce_1
   4914              }
   4915          
   4916              if (operation->nonce_set) {
   \                     ??psa_aead_set_nonce_0: (+1)
   \       0x1A   0x7D30             LDRB     R0,[R6, #+20]
   \       0x1C   0x07C0             LSLS     R0,R0,#+31
   \       0x1E   0xD502             BPL.N    ??psa_aead_set_nonce_2
   4917                  status = PSA_ERROR_BAD_STATE;
   \       0x20   0xF07F 0x0488      MVNS     R4,#+136
   4918                  goto exit;
   \       0x24   0xE00F             B.N      ??psa_aead_set_nonce_1
   4919              }
   4920          
   4921              status = psa_aead_check_nonce_length(operation->alg, nonce_length);
   \                     ??psa_aead_set_nonce_2: (+1)
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x6870             LDR      R0,[R6, #+4]
   \       0x2A   0x.... 0x....      BL       psa_aead_check_nonce_length
   \       0x2E   0x0005             MOVS     R5,R0
   4922              if (status != PSA_SUCCESS) {
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xD002             BEQ.N    ??psa_aead_set_nonce_3
   4923                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x34   0xF07F 0x0486      MVNS     R4,#+134
   4924                  goto exit;
   \       0x38   0xE005             B.N      ??psa_aead_set_nonce_1
   4925              }
   4926          
   4927              status = psa_driver_wrapper_aead_set_nonce(operation, nonce,
   4928                                                         nonce_length);
   \                     ??psa_aead_set_nonce_3: (+1)
   \       0x3A   0x4642             MOV      R2,R8
   \       0x3C   0x0039             MOVS     R1,R7
   \       0x3E   0x0030             MOVS     R0,R6
   \       0x40   0x.... 0x....      BL       psa_driver_wrapper_aead_set_nonce
   \       0x44   0x0004             MOVS     R4,R0
   4929          
   4930          exit:
   4931              if (status == PSA_SUCCESS) {
   \                     ??psa_aead_set_nonce_1: (+1)
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD104             BNE.N    ??psa_aead_set_nonce_4
   4932                  operation->nonce_set = 1;
   \       0x4A   0x6970             LDR      R0,[R6, #+20]
   \       0x4C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x50   0x6170             STR      R0,[R6, #+20]
   \       0x52   0xE002             B.N      ??psa_aead_set_nonce_5
   4933              } else {
   4934                  psa_aead_abort(operation);
   \                     ??psa_aead_set_nonce_4: (+1)
   \       0x54   0x0030             MOVS     R0,R6
   \       0x56   0x.... 0x....      BL       psa_aead_abort
   4935              }
   4936          
   4937              return status;
   \                     ??psa_aead_set_nonce_5: (+1)
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   4938          }
   4939          
   4940          /* Declare the lengths of the message and additional data for multipart AEAD. */

   \                                 In section .text, align 2, keep-with-next
   4941          psa_status_t psa_aead_set_lengths(psa_aead_operation_t *operation,
   4942                                            size_t ad_length,
   4943                                            size_t plaintext_length)
   4944          {
   \                     psa_aead_set_lengths: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   4945              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0896      MVNS     R8,#+150
   4946          
   4947              if (operation->id == 0) {
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??psa_aead_set_lengths_0
   4948                  status = PSA_ERROR_BAD_STATE;
   \       0x14   0xF07F 0x0488      MVNS     R4,#+136
   4949                  goto exit;
   \       0x18   0xE019             B.N      ??psa_aead_set_lengths_1
   4950              }
   4951          
   4952              if (operation->lengths_set || operation->ad_started ||
   4953                  operation->body_started) {
   \                     ??psa_aead_set_lengths_0: (+1)
   \       0x1A   0x7D28             LDRB     R0,[R5, #+20]
   \       0x1C   0xF010 0x0F0E      TST      R0,#0xE
   \       0x20   0xD002             BEQ.N    ??psa_aead_set_lengths_2
   4954                  status = PSA_ERROR_BAD_STATE;
   \       0x22   0xF07F 0x0488      MVNS     R4,#+136
   4955                  goto exit;
   \       0x26   0xE012             B.N      ??psa_aead_set_lengths_1
   4956              }
   4957          
   4958              switch (operation->alg) {
   \                     ??psa_aead_set_lengths_2: (+1)
   \       0x28   0x6869             LDR      R1,[R5, #+4]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \       0x2E   0x4281             CMP      R1,R0
   \       0x30   0xD107             BNE.N    ??psa_aead_set_lengths_3
   4959          #if defined(PSA_WANT_ALG_GCM)
   4960                  case PSA_ALG_GCM:
   4961                      /* Lengths can only be too large for GCM if size_t is bigger than 32
   4962                       * bits. Without the guard this code will generate warnings on 32bit
   4963                       * builds. */
   4964          #if SIZE_MAX > UINT32_MAX
   4965                      if (((uint64_t) ad_length) >> 61 != 0 ||
   4966                          ((uint64_t) plaintext_length) > 0xFFFFFFFE0ull) {
   4967                          status = PSA_ERROR_INVALID_ARGUMENT;
   4968                          goto exit;
   4969                      }
   4970          #endif
   4971                      break;
   4972          #endif /* PSA_WANT_ALG_GCM */
   4973          #if defined(PSA_WANT_ALG_CCM)
   4974                  case PSA_ALG_CCM:
   4975                      if (ad_length > 0xFF00) {
   \       0x32   0xF64F 0x7001      MOVW     R0,#+65281
   \       0x36   0x4286             CMP      R6,R0
   \       0x38   0xD302             BCC.N    ??psa_aead_set_lengths_4
   4976                          status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x3A   0xF07F 0x0486      MVNS     R4,#+134
   4977                          goto exit;
   \       0x3E   0xE006             B.N      ??psa_aead_set_lengths_1
   4978                      }
   4979                      break;
   \                     ??psa_aead_set_lengths_4: (+1)
   \       0x40   0xE7FF             B.N      ??psa_aead_set_lengths_5
   4980          #endif /* PSA_WANT_ALG_CCM */
   4981          #if defined(PSA_WANT_ALG_CHACHA20_POLY1305)
   4982                  case PSA_ALG_CHACHA20_POLY1305:
   4983                      /* No length restrictions for ChaChaPoly. */
   4984                      break;
   4985          #endif /* PSA_WANT_ALG_CHACHA20_POLY1305 */
   4986                  default:
   4987                      break;
   4988              }
   4989          
   4990              status = psa_driver_wrapper_aead_set_lengths(operation, ad_length,
   4991                                                           plaintext_length);
   \                     ??psa_aead_set_lengths_3: (+1)
   \                     ??psa_aead_set_lengths_5: (+1)
   \       0x42   0x003A             MOVS     R2,R7
   \       0x44   0x0031             MOVS     R1,R6
   \       0x46   0x0028             MOVS     R0,R5
   \       0x48   0x.... 0x....      BL       psa_driver_wrapper_aead_set_lengths
   \       0x4C   0x0004             MOVS     R4,R0
   4992          
   4993          exit:
   4994              if (status == PSA_SUCCESS) {
   \                     ??psa_aead_set_lengths_1: (+1)
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xD106             BNE.N    ??psa_aead_set_lengths_6
   4995                  operation->ad_remaining = ad_length;
   \       0x52   0x60EE             STR      R6,[R5, #+12]
   4996                  operation->body_remaining = plaintext_length;
   \       0x54   0x612F             STR      R7,[R5, #+16]
   4997                  operation->lengths_set = 1;
   \       0x56   0x6968             LDR      R0,[R5, #+20]
   \       0x58   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x5C   0x6168             STR      R0,[R5, #+20]
   \       0x5E   0xE002             B.N      ??psa_aead_set_lengths_7
   4998              } else {
   4999                  psa_aead_abort(operation);
   \                     ??psa_aead_set_lengths_6: (+1)
   \       0x60   0x0028             MOVS     R0,R5
   \       0x62   0x.... 0x....      BL       psa_aead_abort
   5000              }
   5001          
   5002              return status;
   \                     ??psa_aead_set_lengths_7: (+1)
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0xE8BD 0x81F0      POP      {R4-R8,PC}
   5003          }
   5004          
   5005          /* Pass additional data to an active multipart AEAD operation. */

   \                                 In section .text, align 2, keep-with-next
   5006          psa_status_t psa_aead_update_ad(psa_aead_operation_t *operation,
   5007                                          const uint8_t *input,
   5008                                          size_t input_length)
   5009          {
   \                     psa_aead_update_ad: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   5010              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0896      MVNS     R8,#+150
   5011          
   5012              if (operation->id == 0) {
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??psa_aead_update_ad_0
   5013                  status = PSA_ERROR_BAD_STATE;
   \       0x14   0xF07F 0x0488      MVNS     R4,#+136
   5014                  goto exit;
   \       0x18   0xE024             B.N      ??psa_aead_update_ad_1
   5015              }
   5016          
   5017              if (!operation->nonce_set || operation->body_started) {
   \                     ??psa_aead_update_ad_0: (+1)
   \       0x1A   0x7D28             LDRB     R0,[R5, #+20]
   \       0x1C   0xF010 0x0009      ANDS     R0,R0,#0x9
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD002             BEQ.N    ??psa_aead_update_ad_2
   5018                  status = PSA_ERROR_BAD_STATE;
   \       0x24   0xF07F 0x0488      MVNS     R4,#+136
   5019                  goto exit;
   \       0x28   0xE01C             B.N      ??psa_aead_update_ad_1
   5020              }
   5021          
   5022              if (operation->lengths_set) {
   \                     ??psa_aead_update_ad_2: (+1)
   \       0x2A   0x6968             LDR      R0,[R5, #+20]
   \       0x2C   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD009             BEQ.N    ??psa_aead_update_ad_3
   5023                  if (operation->ad_remaining < input_length) {
   \       0x34   0x68E8             LDR      R0,[R5, #+12]
   \       0x36   0x42B8             CMP      R0,R7
   \       0x38   0xD202             BCS.N    ??psa_aead_update_ad_4
   5024                      status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x3A   0xF07F 0x0486      MVNS     R4,#+134
   5025                      goto exit;
   \       0x3E   0xE011             B.N      ??psa_aead_update_ad_1
   5026                  }
   5027          
   5028                  operation->ad_remaining -= input_length;
   \                     ??psa_aead_update_ad_4: (+1)
   \       0x40   0x68E8             LDR      R0,[R5, #+12]
   \       0x42   0x1BC0             SUBS     R0,R0,R7
   \       0x44   0x60E8             STR      R0,[R5, #+12]
   \       0x46   0xE007             B.N      ??psa_aead_update_ad_5
   5029              }
   5030          #if defined(PSA_WANT_ALG_CCM)
   5031              else if (operation->alg == PSA_ALG_CCM) {
   \                     ??psa_aead_update_ad_3: (+1)
   \       0x48   0x6869             LDR      R1,[R5, #+4]
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \       0x4E   0x4281             CMP      R1,R0
   \       0x50   0xD102             BNE.N    ??psa_aead_update_ad_5
   5032                  status = PSA_ERROR_BAD_STATE;
   \       0x52   0xF07F 0x0488      MVNS     R4,#+136
   5033                  goto exit;
   \       0x56   0xE005             B.N      ??psa_aead_update_ad_1
   5034              }
   5035          #endif /* PSA_WANT_ALG_CCM */
   5036          
   5037              status = psa_driver_wrapper_aead_update_ad(operation, input,
   5038                                                         input_length);
   \                     ??psa_aead_update_ad_5: (+1)
   \       0x58   0x003A             MOVS     R2,R7
   \       0x5A   0x0031             MOVS     R1,R6
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0x.... 0x....      BL       psa_driver_wrapper_aead_update_ad
   \       0x62   0x0004             MOVS     R4,R0
   5039          
   5040          exit:
   5041              if (status == PSA_SUCCESS) {
   \                     ??psa_aead_update_ad_1: (+1)
   \       0x64   0x2C00             CMP      R4,#+0
   \       0x66   0xD104             BNE.N    ??psa_aead_update_ad_6
   5042                  operation->ad_started = 1;
   \       0x68   0x6968             LDR      R0,[R5, #+20]
   \       0x6A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x6E   0x6168             STR      R0,[R5, #+20]
   \       0x70   0xE002             B.N      ??psa_aead_update_ad_7
   5043              } else {
   5044                  psa_aead_abort(operation);
   \                     ??psa_aead_update_ad_6: (+1)
   \       0x72   0x0028             MOVS     R0,R5
   \       0x74   0x.... 0x....      BL       psa_aead_abort
   5045              }
   5046          
   5047              return status;
   \                     ??psa_aead_update_ad_7: (+1)
   \       0x78   0x0020             MOVS     R0,R4
   \       0x7A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   5048          }
   5049          
   5050          /* Encrypt or decrypt a message fragment in an active multipart AEAD
   5051             operation.*/

   \                                 In section .text, align 2, keep-with-next
   5052          psa_status_t psa_aead_update(psa_aead_operation_t *operation,
   5053                                       const uint8_t *input,
   5054                                       size_t input_length,
   5055                                       uint8_t *output,
   5056                                       size_t output_size,
   5057                                       size_t *output_length)
   5058          {
   \                     psa_aead_update: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x802C      LDR      R8,[SP, #+44]
   5059              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x10   0xF07F 0x0996      MVNS     R9,#+150
   5060          
   5061              *output_length = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF8C8 0x0000      STR      R0,[R8, #+0]
   5062          
   5063              if (operation->id == 0) {
   \       0x1A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD102             BNE.N    ??psa_aead_update_0
   5064                  status = PSA_ERROR_BAD_STATE;
   \       0x22   0xF07F 0x0488      MVNS     R4,#+136
   5065                  goto exit;
   \       0x26   0xE034             B.N      ??psa_aead_update_1
   5066              }
   5067          
   5068              if (!operation->nonce_set) {
   \                     ??psa_aead_update_0: (+1)
   \       0x28   0xF89A 0x0014      LDRB     R0,[R10, #+20]
   \       0x2C   0x07C0             LSLS     R0,R0,#+31
   \       0x2E   0xD402             BMI.N    ??psa_aead_update_2
   5069                  status = PSA_ERROR_BAD_STATE;
   \       0x30   0xF07F 0x0488      MVNS     R4,#+136
   5070                  goto exit;
   \       0x34   0xE02D             B.N      ??psa_aead_update_1
   5071              }
   5072          
   5073              if (operation->lengths_set) {
   \                     ??psa_aead_update_2: (+1)
   \       0x36   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \       0x3A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD013             BEQ.N    ??psa_aead_update_3
   5074                  /* Additional data length was supplied, but not all the additional
   5075                     data was supplied.*/
   5076                  if (operation->ad_remaining != 0) {
   \       0x42   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD002             BEQ.N    ??psa_aead_update_4
   5077                      status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x4A   0xF07F 0x0486      MVNS     R4,#+134
   5078                      goto exit;
   \       0x4E   0xE020             B.N      ??psa_aead_update_1
   5079                  }
   5080          
   5081                  /* Too much data provided. */
   5082                  if (operation->body_remaining < input_length) {
   \                     ??psa_aead_update_4: (+1)
   \       0x50   0xF8DA 0x0010      LDR      R0,[R10, #+16]
   \       0x54   0x42B0             CMP      R0,R6
   \       0x56   0xD202             BCS.N    ??psa_aead_update_5
   5083                      status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x58   0xF07F 0x0486      MVNS     R4,#+134
   5084                      goto exit;
   \       0x5C   0xE019             B.N      ??psa_aead_update_1
   5085                  }
   5086          
   5087                  operation->body_remaining -= input_length;
   \                     ??psa_aead_update_5: (+1)
   \       0x5E   0xF8DA 0x0010      LDR      R0,[R10, #+16]
   \       0x62   0x1B80             SUBS     R0,R0,R6
   \       0x64   0xF8CA 0x0010      STR      R0,[R10, #+16]
   \       0x68   0xE008             B.N      ??psa_aead_update_6
   5088              }
   5089          #if defined(PSA_WANT_ALG_CCM)
   5090              else if (operation->alg == PSA_ALG_CCM) {
   \                     ??psa_aead_update_3: (+1)
   \       0x6A   0xF8DA 0x1004      LDR      R1,[R10, #+4]
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \       0x72   0x4281             CMP      R1,R0
   \       0x74   0xD102             BNE.N    ??psa_aead_update_6
   5091                  status = PSA_ERROR_BAD_STATE;
   \       0x76   0xF07F 0x0488      MVNS     R4,#+136
   5092                  goto exit;
   \       0x7A   0xE00A             B.N      ??psa_aead_update_1
   5093              }
   5094          #endif /* PSA_WANT_ALG_CCM */
   5095          
   5096              status = psa_driver_wrapper_aead_update(operation, input, input_length,
   5097                                                      output, output_size,
   5098                                                      output_length);
   \                     ??psa_aead_update_6: (+1)
   \       0x7C   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x80   0x980A             LDR      R0,[SP, #+40]
   \       0x82   0x9000             STR      R0,[SP, #+0]
   \       0x84   0x003B             MOVS     R3,R7
   \       0x86   0x0032             MOVS     R2,R6
   \       0x88   0x0029             MOVS     R1,R5
   \       0x8A   0x4650             MOV      R0,R10
   \       0x8C   0x.... 0x....      BL       psa_driver_wrapper_aead_update
   \       0x90   0x0004             MOVS     R4,R0
   5099          
   5100          exit:
   5101              if (status == PSA_SUCCESS) {
   \                     ??psa_aead_update_1: (+1)
   \       0x92   0x2C00             CMP      R4,#+0
   \       0x94   0xD106             BNE.N    ??psa_aead_update_7
   5102                  operation->body_started = 1;
   \       0x96   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \       0x9A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x9E   0xF8CA 0x0014      STR      R0,[R10, #+20]
   \       0xA2   0xE002             B.N      ??psa_aead_update_8
   5103              } else {
   5104                  psa_aead_abort(operation);
   \                     ??psa_aead_update_7: (+1)
   \       0xA4   0x4650             MOV      R0,R10
   \       0xA6   0x.... 0x....      BL       psa_aead_abort
   5105              }
   5106          
   5107              return status;
   \                     ??psa_aead_update_8: (+1)
   \       0xAA   0x0020             MOVS     R0,R4
   \       0xAC   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   5108          }
   5109          

   \                                 In section .text, align 2, keep-with-next
   5110          static psa_status_t psa_aead_final_checks(const psa_aead_operation_t *operation)
   5111          {
   \                     psa_aead_final_checks: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   5112              if (operation->id == 0 || !operation->nonce_set) {
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD002             BEQ.N    ??psa_aead_final_checks_0
   \        0x8   0x7D08             LDRB     R0,[R1, #+20]
   \        0xA   0x07C0             LSLS     R0,R0,#+31
   \        0xC   0xD402             BMI.N    ??psa_aead_final_checks_1
   5113                  return PSA_ERROR_BAD_STATE;
   \                     ??psa_aead_final_checks_0: (+1)
   \        0xE   0xF07F 0x0088      MVNS     R0,#+136
   \       0x12   0xE00E             B.N      ??psa_aead_final_checks_2
   5114              }
   5115          
   5116              if (operation->lengths_set && (operation->ad_remaining != 0 ||
   5117                                             operation->body_remaining != 0)) {
   \                     ??psa_aead_final_checks_1: (+1)
   \       0x14   0x6948             LDR      R0,[R1, #+20]
   \       0x16   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD008             BEQ.N    ??psa_aead_final_checks_3
   \       0x1E   0x68C8             LDR      R0,[R1, #+12]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD102             BNE.N    ??psa_aead_final_checks_4
   \       0x24   0x6908             LDR      R0,[R1, #+16]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ.N    ??psa_aead_final_checks_3
   5118                  return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_aead_final_checks_4: (+1)
   \       0x2A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x2E   0xE000             B.N      ??psa_aead_final_checks_2
   5119              }
   5120          
   5121              return PSA_SUCCESS;
   \                     ??psa_aead_final_checks_3: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??psa_aead_final_checks_2: (+1)
   \       0x32   0x4770             BX       LR
   5122          }
   5123          
   5124          /* Finish encrypting a message in a multipart AEAD operation. */

   \                                 In section .text, align 2, keep-with-next
   5125          psa_status_t psa_aead_finish(psa_aead_operation_t *operation,
   5126                                       uint8_t *ciphertext,
   5127                                       size_t ciphertext_size,
   5128                                       size_t *ciphertext_length,
   5129                                       uint8_t *tag,
   5130                                       size_t tag_size,
   5131                                       size_t *tag_length)
   5132          {
   \                     psa_aead_finish: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \       0x10   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   \       0x14   0xF8DD 0xA038      LDR      R10,[SP, #+56]
   5133              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x18   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   5134          
   5135              *ciphertext_length = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6038             STR      R0,[R7, #+0]
   5136              *tag_length = tag_size;
   \       0x22   0xF8CA 0x9000      STR      R9,[R10, #+0]
   5137          
   5138              status = psa_aead_final_checks(operation);
   \       0x26   0x4658             MOV      R0,R11
   \       0x28   0x.... 0x....      BL       psa_aead_final_checks
   \       0x2C   0x0004             MOVS     R4,R0
   5139              if (status != PSA_SUCCESS) {
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD116             BNE.N    ??psa_aead_finish_0
   5140                  goto exit;
   5141              }
   5142          
   5143              if (!operation->is_encrypt) {
   \                     ??psa_aead_finish_1: (+1)
   \       0x32   0xF8DB 0x0014      LDR      R0,[R11, #+20]
   \       0x36   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD103             BNE.N    ??psa_aead_finish_2
   5144                  status = PSA_ERROR_BAD_STATE;
   \       0x3E   0xF07F 0x0088      MVNS     R0,#+136
   \       0x42   0x0004             MOVS     R4,R0
   5145                  goto exit;
   \       0x44   0xE00C             B.N      ??psa_aead_finish_0
   5146              }
   5147          
   5148              status = psa_driver_wrapper_aead_finish(operation, ciphertext,
   5149                                                      ciphertext_size,
   5150                                                      ciphertext_length,
   5151                                                      tag, tag_size, tag_length);
   \                     ??psa_aead_finish_2: (+1)
   \       0x46   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \       0x4A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x4E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x52   0x003B             MOVS     R3,R7
   \       0x54   0x0032             MOVS     R2,R6
   \       0x56   0x0029             MOVS     R1,R5
   \       0x58   0x4658             MOV      R0,R11
   \       0x5A   0x.... 0x....      BL       psa_driver_wrapper_aead_finish
   \       0x5E   0x0004             MOVS     R4,R0
   5152          
   5153          exit:
   5154          
   5155          
   5156              /* In case the operation fails and the user fails to check for failure or
   5157               * the zero tag size, make sure the tag is set to something implausible.
   5158               * Even if the operation succeeds, make sure we clear the rest of the
   5159               * buffer to prevent potential leakage of anything previously placed in
   5160               * the same buffer.*/
   5161              psa_wipe_tag_output_buffer(tag, status, tag_size, *tag_length);
   \                     ??psa_aead_finish_0: (+1)
   \       0x60   0xF8DA 0x3000      LDR      R3,[R10, #+0]
   \       0x64   0x464A             MOV      R2,R9
   \       0x66   0x0021             MOVS     R1,R4
   \       0x68   0x4640             MOV      R0,R8
   \       0x6A   0x.... 0x....      BL       psa_wipe_tag_output_buffer
   5162          
   5163              psa_aead_abort(operation);
   \       0x6E   0x4658             MOV      R0,R11
   \       0x70   0x.... 0x....      BL       psa_aead_abort
   5164          
   5165              return status;
   \       0x74   0x0020             MOVS     R0,R4
   \       0x76   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   5166          }
   5167          
   5168          /* Finish authenticating and decrypting a message in a multipart AEAD
   5169             operation.*/

   \                                 In section .text, align 2, keep-with-next
   5170          psa_status_t psa_aead_verify(psa_aead_operation_t *operation,
   5171                                       uint8_t *plaintext,
   5172                                       size_t plaintext_size,
   5173                                       size_t *plaintext_length,
   5174                                       const uint8_t *tag,
   5175                                       size_t tag_length)
   5176          {
   \                     psa_aead_verify: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   5177              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x0996      MVNS     R9,#+150
   5178          
   5179              *plaintext_length = 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xF8C8 0x0000      STR      R0,[R8, #+0]
   5180          
   5181              status = psa_aead_final_checks(operation);
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x.... 0x....      BL       psa_aead_final_checks
   \       0x1C   0x0004             MOVS     R4,R0
   5182              if (status != PSA_SUCCESS) {
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD113             BNE.N    ??psa_aead_verify_0
   5183                  goto exit;
   5184              }
   5185          
   5186              if (operation->is_encrypt) {
   \                     ??psa_aead_verify_1: (+1)
   \       0x22   0x6968             LDR      R0,[R5, #+20]
   \       0x24   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD003             BEQ.N    ??psa_aead_verify_2
   5187                  status = PSA_ERROR_BAD_STATE;
   \       0x2C   0xF07F 0x0088      MVNS     R0,#+136
   \       0x30   0x0004             MOVS     R4,R0
   5188                  goto exit;
   \       0x32   0xE00A             B.N      ??psa_aead_verify_0
   5189              }
   5190          
   5191              status = psa_driver_wrapper_aead_verify(operation, plaintext,
   5192                                                      plaintext_size,
   5193                                                      plaintext_length,
   5194                                                      tag, tag_length);
   \                     ??psa_aead_verify_2: (+1)
   \       0x34   0x980B             LDR      R0,[SP, #+44]
   \       0x36   0x9001             STR      R0,[SP, #+4]
   \       0x38   0x980A             LDR      R0,[SP, #+40]
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0x4643             MOV      R3,R8
   \       0x3E   0x003A             MOVS     R2,R7
   \       0x40   0x0031             MOVS     R1,R6
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0x.... 0x....      BL       psa_driver_wrapper_aead_verify
   \       0x48   0x0004             MOVS     R4,R0
   5195          
   5196          exit:
   5197              psa_aead_abort(operation);
   \                     ??psa_aead_verify_0: (+1)
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0x.... 0x....      BL       psa_aead_abort
   5198          
   5199              return status;
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0xE8BD 0x83FE      POP      {R1-R9,PC}
   5200          }
   5201          
   5202          /* Abort an AEAD operation. */

   \                                 In section .text, align 2, keep-with-next
   5203          psa_status_t psa_aead_abort(psa_aead_operation_t *operation)
   5204          {
   \                     psa_aead_abort: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   5205              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x0596      MVNS     R5,#+150
   5206          
   5207              if (operation->id == 0) {
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??psa_aead_abort_0
   5208                  /* The object has (apparently) been initialized but it is not (yet)
   5209                   * in use. It's ok to call abort on such an object, and there's
   5210                   * nothing to do. */
   5211                  return PSA_SUCCESS;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE00C             B.N      ??psa_aead_abort_1
   5212              }
   5213          
   5214              status = psa_driver_wrapper_aead_abort(operation);
   \                     ??psa_aead_abort_0: (+1)
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       psa_driver_wrapper_aead_abort
   \       0x1A   0x4681             MOV      R9,R0
   5215          
   5216              memset(operation, 0, sizeof(*operation));
   \       0x1C   0x26D8             MOVS     R6,#+216
   \       0x1E   0x2700             MOVS     R7,#+0
   \       0x20   0x46A0             MOV      R8,R4
   \       0x22   0x003A             MOVS     R2,R7
   \       0x24   0x0031             MOVS     R1,R6
   \       0x26   0x4640             MOV      R0,R8
   \       0x28   0x.... 0x....      BL       __aeabi_memset
   5217          
   5218              return status;
   \       0x2C   0x4648             MOV      R0,R9
   \                     ??psa_aead_abort_1: (+1)
   \       0x2E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   5219          }
   5220          
   5221          /****************************************************************/
   5222          /* Generators */
   5223          /****************************************************************/
   5224          
   5225          #if defined(BUILTIN_ALG_ANY_HKDF) || \
   5226              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF) || \
   5227              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS) || \
   5228              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS) || \
   5229              defined(PSA_HAVE_SOFT_PBKDF2)
   5230          #define AT_LEAST_ONE_BUILTIN_KDF
   5231          #endif /* At least one builtin KDF */
   5232          
   5233          #if defined(BUILTIN_ALG_ANY_HKDF) || \
   5234              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF) || \
   5235              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)

   \                                 In section .text, align 2, keep-with-next
   5236          static psa_status_t psa_key_derivation_start_hmac(
   5237              psa_mac_operation_t *operation,
   5238              psa_algorithm_t hash_alg,
   5239              const uint8_t *hmac_key,
   5240              size_t hmac_key_length)
   5241          {
   \                     psa_key_derivation_start_hmac: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   5242              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   5243              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \       0x12   0xA801             ADD      R0,SP,#+4
   \       0x14   0x2124             MOVS     R1,#+36
   \       0x16   0x.... 0x....      BL       __aeabi_memclr4
   5244              psa_set_key_type(&attributes, PSA_KEY_TYPE_HMAC);
   \       0x1A   0xF44F 0x5188      MOV      R1,#+4352
   \       0x1E   0xA801             ADD      R0,SP,#+4
   \       0x20   0x.... 0x....      BL       psa_set_key_type
   5245              psa_set_key_bits(&attributes, PSA_BYTES_TO_BITS(hmac_key_length));
   \       0x24   0x00F9             LSLS     R1,R7,#+3
   \       0x26   0xA801             ADD      R0,SP,#+4
   \       0x28   0x.... 0x....      BL       psa_set_key_bits
   5246              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_HASH);
   \       0x2C   0xF44F 0x5180      MOV      R1,#+4096
   \       0x30   0xA801             ADD      R0,SP,#+4
   \       0x32   0x.... 0x....      BL       psa_set_key_usage_flags
   5247          
   5248              operation->is_sign = 1;
   \       0x36   0x6860             LDR      R0,[R4, #+4]
   \       0x38   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x3C   0x6060             STR      R0,[R4, #+4]
   5249              operation->mac_size = PSA_HASH_LENGTH(hash_alg);
   \       0x3E   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0x42   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable44
   \       0x4A   0x4281             CMP      R1,R0
   \       0x4C   0xD101             BNE.N    ??psa_key_derivation_start_hmac_0
   \       0x4E   0x2010             MOVS     R0,#+16
   \       0x50   0xE078             B.N      ??psa_key_derivation_start_hmac_1
   \                     ??psa_key_derivation_start_hmac_0: (+1)
   \       0x52   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0x56   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable44_1
   \       0x5E   0x4281             CMP      R1,R0
   \       0x60   0xD101             BNE.N    ??psa_key_derivation_start_hmac_2
   \       0x62   0x2014             MOVS     R0,#+20
   \       0x64   0xE06E             B.N      ??psa_key_derivation_start_hmac_3
   \                     ??psa_key_derivation_start_hmac_2: (+1)
   \       0x66   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0x6A   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable44_2
   \       0x72   0x4281             CMP      R1,R0
   \       0x74   0xD101             BNE.N    ??psa_key_derivation_start_hmac_4
   \       0x76   0x2014             MOVS     R0,#+20
   \       0x78   0xE064             B.N      ??psa_key_derivation_start_hmac_3
   \                     ??psa_key_derivation_start_hmac_4: (+1)
   \       0x7A   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0x7E   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable44_3
   \       0x86   0x4281             CMP      R1,R0
   \       0x88   0xD101             BNE.N    ??psa_key_derivation_start_hmac_5
   \       0x8A   0x201C             MOVS     R0,#+28
   \       0x8C   0xE05A             B.N      ??psa_key_derivation_start_hmac_6
   \                     ??psa_key_derivation_start_hmac_5: (+1)
   \       0x8E   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0x92   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x96   0x.... 0x....      LDR.W    R0,??DataTable44_4
   \       0x9A   0x4281             CMP      R1,R0
   \       0x9C   0xD101             BNE.N    ??psa_key_derivation_start_hmac_7
   \       0x9E   0x2020             MOVS     R0,#+32
   \       0xA0   0xE050             B.N      ??psa_key_derivation_start_hmac_6
   \                     ??psa_key_derivation_start_hmac_7: (+1)
   \       0xA2   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0xA6   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable44_5
   \       0xAE   0x4281             CMP      R1,R0
   \       0xB0   0xD101             BNE.N    ??psa_key_derivation_start_hmac_8
   \       0xB2   0x2030             MOVS     R0,#+48
   \       0xB4   0xE046             B.N      ??psa_key_derivation_start_hmac_9
   \                     ??psa_key_derivation_start_hmac_8: (+1)
   \       0xB6   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0xBA   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xBE   0x.... 0x....      LDR.W    R0,??DataTable44_6
   \       0xC2   0x4281             CMP      R1,R0
   \       0xC4   0xD101             BNE.N    ??psa_key_derivation_start_hmac_10
   \       0xC6   0x2040             MOVS     R0,#+64
   \       0xC8   0xE03C             B.N      ??psa_key_derivation_start_hmac_9
   \                     ??psa_key_derivation_start_hmac_10: (+1)
   \       0xCA   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0xCE   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xD2   0x.... 0x....      LDR.W    R0,??DataTable44_7
   \       0xD6   0x4281             CMP      R1,R0
   \       0xD8   0xD101             BNE.N    ??psa_key_derivation_start_hmac_11
   \       0xDA   0x201C             MOVS     R0,#+28
   \       0xDC   0xE032             B.N      ??psa_key_derivation_start_hmac_12
   \                     ??psa_key_derivation_start_hmac_11: (+1)
   \       0xDE   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0xE2   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xE6   0x.... 0x....      LDR.W    R0,??DataTable44_8
   \       0xEA   0x4281             CMP      R1,R0
   \       0xEC   0xD101             BNE.N    ??psa_key_derivation_start_hmac_13
   \       0xEE   0x2020             MOVS     R0,#+32
   \       0xF0   0xE028             B.N      ??psa_key_derivation_start_hmac_12
   \                     ??psa_key_derivation_start_hmac_13: (+1)
   \       0xF2   0xF005 0x01FF      AND      R1,R5,#0xFF
   \       0xF6   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xFA   0x.... 0x....      LDR.W    R0,??DataTable44_9
   \       0xFE   0x4281             CMP      R1,R0
   \      0x100   0xD101             BNE.N    ??psa_key_derivation_start_hmac_14
   \      0x102   0x201C             MOVS     R0,#+28
   \      0x104   0xE01E             B.N      ??psa_key_derivation_start_hmac_15
   \                     ??psa_key_derivation_start_hmac_14: (+1)
   \      0x106   0xF005 0x00FF      AND      R0,R5,#0xFF
   \      0x10A   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x10E   0x.... 0x....      LDR.W    R1,??DataTable44_10
   \      0x112   0x4288             CMP      R0,R1
   \      0x114   0xD101             BNE.N    ??psa_key_derivation_start_hmac_16
   \      0x116   0x2020             MOVS     R0,#+32
   \      0x118   0xE014             B.N      ??psa_key_derivation_start_hmac_15
   \                     ??psa_key_derivation_start_hmac_16: (+1)
   \      0x11A   0xF005 0x01FF      AND      R1,R5,#0xFF
   \      0x11E   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x122   0x.... 0x....      LDR.W    R0,??DataTable44_11
   \      0x126   0x4281             CMP      R1,R0
   \      0x128   0xD101             BNE.N    ??psa_key_derivation_start_hmac_17
   \      0x12A   0x2030             MOVS     R0,#+48
   \      0x12C   0xE00A             B.N      ??psa_key_derivation_start_hmac_18
   \                     ??psa_key_derivation_start_hmac_17: (+1)
   \      0x12E   0xF005 0x01FF      AND      R1,R5,#0xFF
   \      0x132   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x136   0x.... 0x....      LDR.W    R0,??DataTable44_12
   \      0x13A   0x4281             CMP      R1,R0
   \      0x13C   0xD101             BNE.N    ??psa_key_derivation_start_hmac_19
   \      0x13E   0x2040             MOVS     R0,#+64
   \      0x140   0xE000             B.N      ??psa_key_derivation_start_hmac_18
   \                     ??psa_key_derivation_start_hmac_19: (+1)
   \      0x142   0x2000             MOVS     R0,#+0
   \                     ??psa_key_derivation_start_hmac_18: (+1)
   \                     ??psa_key_derivation_start_hmac_15: (+1)
   \                     ??psa_key_derivation_start_hmac_12: (+1)
   \                     ??psa_key_derivation_start_hmac_9: (+1)
   \                     ??psa_key_derivation_start_hmac_6: (+1)
   \                     ??psa_key_derivation_start_hmac_3: (+1)
   \                     ??psa_key_derivation_start_hmac_1: (+1)
   \      0x144   0x7120             STRB     R0,[R4, #+4]
   5250          
   5251              status = psa_driver_wrapper_mac_sign_setup(operation,
   5252                                                         &attributes,
   5253                                                         hmac_key, hmac_key_length,
   5254                                                         PSA_ALG_HMAC(hash_alg));
   \      0x146   0xF005 0x00FF      AND      R0,R5,#0xFF
   \      0x14A   0xF050 0x7060      ORRS     R0,R0,#0x3800000
   \      0x14E   0x9000             STR      R0,[SP, #+0]
   \      0x150   0x003B             MOVS     R3,R7
   \      0x152   0x0032             MOVS     R2,R6
   \      0x154   0xA901             ADD      R1,SP,#+4
   \      0x156   0x0020             MOVS     R0,R4
   \      0x158   0x.... 0x....      BL       psa_driver_wrapper_mac_sign_setup
   \      0x15C   0x4681             MOV      R9,R0
   5255          
   5256              psa_reset_key_attributes(&attributes);
   \      0x15E   0xA801             ADD      R0,SP,#+4
   \      0x160   0x.... 0x....      BL       psa_reset_key_attributes
   5257              return status;
   \      0x164   0x4648             MOV      R0,R9
   \      0x166   0xB00B             ADD      SP,SP,#+44
   \      0x168   0xE8BD 0x83F0      POP      {R4-R9,PC}
   5258          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   5259          #endif /* KDF algorithms reliant on HMAC */
   5260          
   5261          #define HKDF_STATE_INIT 0 /* no input yet */
   5262          #define HKDF_STATE_STARTED 1 /* got salt */
   5263          #define HKDF_STATE_KEYED 2 /* got key */
   5264          #define HKDF_STATE_OUTPUT 3 /* output started */
   5265          

   \                                 In section .text, align 2, keep-with-next
   5266          static psa_algorithm_t psa_key_derivation_get_kdf_alg(
   5267              const psa_key_derivation_operation_t *operation)
   5268          {
   5269              if (PSA_ALG_IS_KEY_AGREEMENT(operation->alg)) {
   \                     psa_key_derivation_get_kdf_alg: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF011 0x41FE      ANDS     R1,R1,#0x7F000000
   \        0x6   0xF1B1 0x6F10      CMP      R1,#+150994944
   \        0xA   0xD105             BNE.N    ??psa_key_derivation_get_kdf_alg_0
   5270                  return PSA_ALG_KEY_AGREEMENT_GET_KDF(operation->alg);
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0xF36F 0x4018      BFC      R0,#+16,#+9
   \       0x12   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \       0x16   0xE000             B.N      ??psa_key_derivation_get_kdf_alg_1
   5271              } else {
   5272                  return operation->alg;
   \                     ??psa_key_derivation_get_kdf_alg_0: (+1)
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \                     ??psa_key_derivation_get_kdf_alg_1: (+1)
   \       0x1A   0x4770             BX       LR
   5273              }
   5274          }
   5275          

   \                                 In section .text, align 2, keep-with-next
   5276          psa_status_t psa_key_derivation_abort(psa_key_derivation_operation_t *operation)
   5277          {
   \                     psa_key_derivation_abort: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   5278              psa_status_t status = PSA_SUCCESS;
   \        0x4   0x2600             MOVS     R6,#+0
   5279              psa_algorithm_t kdf_alg = psa_key_derivation_get_kdf_alg(operation);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       psa_key_derivation_get_kdf_alg
   \        0xC   0x0004             MOVS     R4,R0
   5280              if (kdf_alg == 0) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD026             BEQ.N    ??psa_key_derivation_abort_0
   5281                  /* The object has (apparently) been initialized but it is not
   5282                   * in use. It's ok to call abort on such an object, and there's
   5283                   * nothing to do. */
   5284              } else
   5285          #if defined(BUILTIN_ALG_ANY_HKDF)
   5286              if (PSA_ALG_IS_ANY_HKDF(kdf_alg)) {
   5287                  mbedtls_free(operation->ctx.hkdf.info);
   5288                  status = psa_mac_abort(&operation->ctx.hkdf.hmac);
   5289              } else
   5290          #endif /* BUILTIN_ALG_ANY_HKDF */
   5291          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF) || \
   5292              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)
   5293              if (PSA_ALG_IS_TLS12_PRF(kdf_alg) ||
   5294                  /* TLS-1.2 PSK-to-MS KDF uses the same core as TLS-1.2 PRF */
   5295                  PSA_ALG_IS_TLS12_PSK_TO_MS(kdf_alg)) {
   \       0x12   0x0A21             LSRS     R1,R4,#+8
   \       0x14   0x0209             LSLS     R1,R1,#+8
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable44_13
   \       0x1A   0x4281             CMP      R1,R0
   \       0x1C   0xD005             BEQ.N    ??psa_key_derivation_abort_1
   \       0x1E   0x0A21             LSRS     R1,R4,#+8
   \       0x20   0x0209             LSLS     R1,R1,#+8
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable44_14
   \       0x26   0x4281             CMP      R1,R0
   \       0x28   0xD117             BNE.N    ??psa_key_derivation_abort_2
   5296                  if (operation->ctx.tls12_prf.secret != NULL) {
   \                     ??psa_key_derivation_abort_1: (+1)
   \       0x2A   0x6928             LDR      R0,[R5, #+16]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD003             BEQ.N    ??psa_key_derivation_abort_3
   5297                      mbedtls_zeroize_and_free(operation->ctx.tls12_prf.secret,
   5298                                               operation->ctx.tls12_prf.secret_length);
   \       0x30   0x6969             LDR      R1,[R5, #+20]
   \       0x32   0x6928             LDR      R0,[R5, #+16]
   \       0x34   0x.... 0x....      BL       mbedtls_zeroize_and_free
   5299                  }
   5300          
   5301                  if (operation->ctx.tls12_prf.seed != NULL) {
   \                     ??psa_key_derivation_abort_3: (+1)
   \       0x38   0x69A8             LDR      R0,[R5, #+24]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD003             BEQ.N    ??psa_key_derivation_abort_4
   5302                      mbedtls_zeroize_and_free(operation->ctx.tls12_prf.seed,
   5303                                               operation->ctx.tls12_prf.seed_length);
   \       0x3E   0x69E9             LDR      R1,[R5, #+28]
   \       0x40   0x69A8             LDR      R0,[R5, #+24]
   \       0x42   0x.... 0x....      BL       mbedtls_zeroize_and_free
   5304                  }
   5305          
   5306                  if (operation->ctx.tls12_prf.label != NULL) {
   \                     ??psa_key_derivation_abort_4: (+1)
   \       0x46   0x6A28             LDR      R0,[R5, #+32]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD003             BEQ.N    ??psa_key_derivation_abort_5
   5307                      mbedtls_zeroize_and_free(operation->ctx.tls12_prf.label,
   5308                                               operation->ctx.tls12_prf.label_length);
   \       0x4C   0x6A69             LDR      R1,[R5, #+36]
   \       0x4E   0x6A28             LDR      R0,[R5, #+32]
   \       0x50   0x.... 0x....      BL       mbedtls_zeroize_and_free
   5309                  }
   5310          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)
   5311                  if (operation->ctx.tls12_prf.other_secret != NULL) {
   5312                      mbedtls_zeroize_and_free(operation->ctx.tls12_prf.other_secret,
   5313                                               operation->ctx.tls12_prf.other_secret_length);
   5314                  }
   5315          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS */
   5316                  status = PSA_SUCCESS;
   \                     ??psa_key_derivation_abort_5: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x0006             MOVS     R6,R0
   \       0x58   0xE002             B.N      ??psa_key_derivation_abort_0
   5317          
   5318                  /* We leave the fields Ai and output_block to be erased safely by the
   5319                   * mbedtls_platform_zeroize() in the end of this function. */
   5320              } else
   5321          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF) ||
   5322                  * defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS) */
   5323          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS)
   5324              if (kdf_alg == PSA_ALG_TLS12_ECJPAKE_TO_PMS) {
   5325                  mbedtls_platform_zeroize(operation->ctx.tls12_ecjpake_to_pms.data,
   5326                                           sizeof(operation->ctx.tls12_ecjpake_to_pms.data));
   5327              } else
   5328          #endif /* defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS) */
   5329          #if defined(PSA_HAVE_SOFT_PBKDF2)
   5330              if (PSA_ALG_IS_PBKDF2(kdf_alg)) {
   5331                  if (operation->ctx.pbkdf2.salt != NULL) {
   5332                      mbedtls_zeroize_and_free(operation->ctx.pbkdf2.salt,
   5333                                               operation->ctx.pbkdf2.salt_length);
   5334                  }
   5335          
   5336                  status = PSA_SUCCESS;
   5337              } else
   5338          #endif /* defined(PSA_HAVE_SOFT_PBKDF2) */
   5339              {
   5340                  status = PSA_ERROR_BAD_STATE;
   \                     ??psa_key_derivation_abort_2: (+1)
   \       0x5A   0xF07F 0x0088      MVNS     R0,#+136
   \       0x5E   0x0006             MOVS     R6,R0
   5341              }
   5342              mbedtls_platform_zeroize(operation, sizeof(*operation));
   \                     ??psa_key_derivation_abort_0: (+1)
   \       0x60   0x2168             MOVS     R1,#+104
   \       0x62   0x0028             MOVS     R0,R5
   \       0x64   0x.... 0x....      BL       mbedtls_platform_zeroize
   5343              return status;
   \       0x68   0x0030             MOVS     R0,R6
   \       0x6A   0xBD70             POP      {R4-R6,PC}
   5344          }
   5345          

   \                                 In section .text, align 2, keep-with-next
   5346          psa_status_t psa_key_derivation_get_capacity(const psa_key_derivation_operation_t *operation,
   5347                                                       size_t *capacity)
   5348          {
   \                     psa_key_derivation_get_capacity: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   5349              if (operation->alg == 0) {
   \        0x2   0x6810             LDR      R0,[R2, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD102             BNE.N    ??psa_key_derivation_get_capacity_0
   5350                  /* This is a blank key derivation operation. */
   5351                  return PSA_ERROR_BAD_STATE;
   \        0x8   0xF07F 0x0088      MVNS     R0,#+136
   \        0xC   0xE002             B.N      ??psa_key_derivation_get_capacity_1
   5352              }
   5353          
   5354              *capacity = operation->capacity;
   \                     ??psa_key_derivation_get_capacity_0: (+1)
   \        0xE   0x6890             LDR      R0,[R2, #+8]
   \       0x10   0x6008             STR      R0,[R1, #+0]
   5355              return PSA_SUCCESS;
   \       0x12   0x2000             MOVS     R0,#+0
   \                     ??psa_key_derivation_get_capacity_1: (+1)
   \       0x14   0x4770             BX       LR
   5356          }
   5357          

   \                                 In section .text, align 2, keep-with-next
   5358          psa_status_t psa_key_derivation_set_capacity(psa_key_derivation_operation_t *operation,
   5359                                                       size_t capacity)
   5360          {
   \                     psa_key_derivation_set_capacity: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   5361              if (operation->alg == 0) {
   \        0x2   0x6810             LDR      R0,[R2, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD102             BNE.N    ??psa_key_derivation_set_capacity_0
   5362                  return PSA_ERROR_BAD_STATE;
   \        0x8   0xF07F 0x0088      MVNS     R0,#+136
   \        0xC   0xE007             B.N      ??psa_key_derivation_set_capacity_1
   5363              }
   5364              if (capacity > operation->capacity) {
   \                     ??psa_key_derivation_set_capacity_0: (+1)
   \        0xE   0x6890             LDR      R0,[R2, #+8]
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD202             BCS.N    ??psa_key_derivation_set_capacity_2
   5365                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x14   0xF07F 0x0086      MVNS     R0,#+134
   \       0x18   0xE001             B.N      ??psa_key_derivation_set_capacity_1
   5366              }
   5367              operation->capacity = capacity;
   \                     ??psa_key_derivation_set_capacity_2: (+1)
   \       0x1A   0x6091             STR      R1,[R2, #+8]
   5368              return PSA_SUCCESS;
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??psa_key_derivation_set_capacity_1: (+1)
   \       0x1E   0x4770             BX       LR
   5369          }
   5370          
   5371          #if defined(BUILTIN_ALG_ANY_HKDF)
   5372          /* Read some bytes from an HKDF-based operation. */
   5373          static psa_status_t psa_key_derivation_hkdf_read(psa_hkdf_key_derivation_t *hkdf,
   5374                                                           psa_algorithm_t kdf_alg,
   5375                                                           uint8_t *output,
   5376                                                           size_t output_length)
   5377          {
   5378              psa_algorithm_t hash_alg = PSA_ALG_HKDF_GET_HASH(kdf_alg);
   5379              uint8_t hash_length = PSA_HASH_LENGTH(hash_alg);
   5380              size_t hmac_output_length;
   5381              psa_status_t status;
   5382          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT)
   5383              const uint8_t last_block = PSA_ALG_IS_HKDF_EXTRACT(kdf_alg) ? 0 : 0xff;
   5384          #else
   5385              const uint8_t last_block = 0xff;
   5386          #endif /* MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT */
   5387          
   5388              if (hkdf->state < HKDF_STATE_KEYED ||
   5389                  (!hkdf->info_set
   5390          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT)
   5391                   && !PSA_ALG_IS_HKDF_EXTRACT(kdf_alg)
   5392          #endif /* MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT */
   5393                  )) {
   5394                  return PSA_ERROR_BAD_STATE;
   5395              }
   5396              hkdf->state = HKDF_STATE_OUTPUT;
   5397          
   5398              while (output_length != 0) {
   5399                  /* Copy what remains of the current block */
   5400                  uint8_t n = hash_length - hkdf->offset_in_block;
   5401                  if (n > output_length) {
   5402                      n = (uint8_t) output_length;
   5403                  }
   5404                  memcpy(output, hkdf->output_block + hkdf->offset_in_block, n);
   5405                  output += n;
   5406                  output_length -= n;
   5407                  hkdf->offset_in_block += n;
   5408                  if (output_length == 0) {
   5409                      break;
   5410                  }
   5411                  /* We can't be wanting more output after the last block, otherwise
   5412                   * the capacity check in psa_key_derivation_output_bytes() would have
   5413                   * prevented this call. It could happen only if the operation
   5414                   * object was corrupted or if this function is called directly
   5415                   * inside the library. */
   5416                  if (hkdf->block_number == last_block) {
   5417                      return PSA_ERROR_BAD_STATE;
   5418                  }
   5419          
   5420                  /* We need a new block */
   5421                  ++hkdf->block_number;
   5422                  hkdf->offset_in_block = 0;
   5423          
   5424                  status = psa_key_derivation_start_hmac(&hkdf->hmac,
   5425                                                         hash_alg,
   5426                                                         hkdf->prk,
   5427                                                         hash_length);
   5428                  if (status != PSA_SUCCESS) {
   5429                      return status;
   5430                  }
   5431          
   5432                  if (hkdf->block_number != 1) {
   5433                      status = psa_mac_update(&hkdf->hmac,
   5434                                              hkdf->output_block,
   5435                                              hash_length);
   5436                      if (status != PSA_SUCCESS) {
   5437                          return status;
   5438                      }
   5439                  }
   5440                  status = psa_mac_update(&hkdf->hmac,
   5441                                          hkdf->info,
   5442                                          hkdf->info_length);
   5443                  if (status != PSA_SUCCESS) {
   5444                      return status;
   5445                  }
   5446                  status = psa_mac_update(&hkdf->hmac,
   5447                                          &hkdf->block_number, 1);
   5448                  if (status != PSA_SUCCESS) {
   5449                      return status;
   5450                  }
   5451                  status = psa_mac_sign_finish(&hkdf->hmac,
   5452                                               hkdf->output_block,
   5453                                               sizeof(hkdf->output_block),
   5454                                               &hmac_output_length);
   5455                  if (status != PSA_SUCCESS) {
   5456                      return status;
   5457                  }
   5458              }
   5459          
   5460              return PSA_SUCCESS;
   5461          }
   5462          #endif /* BUILTIN_ALG_ANY_HKDF */
   5463          
   5464          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF) || \
   5465              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)

   \                                 In section .text, align 2, keep-with-next
   5466          static psa_status_t psa_key_derivation_tls12_prf_generate_next_block(
   5467              psa_tls12_prf_key_derivation_t *tls12_prf,
   5468              psa_algorithm_t alg)
   5469          {
   \                     psa_key_derivation_tls12_prf_generate_next_block: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB0DA             SUB      SP,SP,#+360
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x000D             MOVS     R5,R1
   5470              psa_algorithm_t hash_alg = PSA_ALG_HKDF_GET_HASH(alg);
   \        0xA   0xF005 0x06FF      AND      R6,R5,#0xFF
   \        0xE   0xF056 0x7600      ORRS     R6,R6,#0x2000000
   5471              uint8_t hash_length = PSA_HASH_LENGTH(hash_alg);
   \       0x12   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x16   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable44
   \       0x1E   0x4281             CMP      R1,R0
   \       0x20   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_0
   \       0x22   0x2710             MOVS     R7,#+16
   \       0x24   0xE078             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_1
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_0: (+1)
   \       0x26   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x2A   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable44_1
   \       0x32   0x4281             CMP      R1,R0
   \       0x34   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_2
   \       0x36   0x2714             MOVS     R7,#+20
   \       0x38   0xE06E             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_3
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_2: (+1)
   \       0x3A   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x3E   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable44_2
   \       0x46   0x4281             CMP      R1,R0
   \       0x48   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_4
   \       0x4A   0x2714             MOVS     R7,#+20
   \       0x4C   0xE064             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_3
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_4: (+1)
   \       0x4E   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x52   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable44_3
   \       0x5A   0x4281             CMP      R1,R0
   \       0x5C   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_5
   \       0x5E   0x271C             MOVS     R7,#+28
   \       0x60   0xE05A             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_6
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_5: (+1)
   \       0x62   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x66   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable44_4
   \       0x6E   0x4281             CMP      R1,R0
   \       0x70   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_7
   \       0x72   0x2720             MOVS     R7,#+32
   \       0x74   0xE050             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_6
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_7: (+1)
   \       0x76   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x7A   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable44_5
   \       0x82   0x4281             CMP      R1,R0
   \       0x84   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_8
   \       0x86   0x2730             MOVS     R7,#+48
   \       0x88   0xE046             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_9
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_8: (+1)
   \       0x8A   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x8E   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable44_6
   \       0x96   0x4281             CMP      R1,R0
   \       0x98   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_10
   \       0x9A   0x2740             MOVS     R7,#+64
   \       0x9C   0xE03C             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_9
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_10: (+1)
   \       0x9E   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xA2   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable44_7
   \       0xAA   0x4281             CMP      R1,R0
   \       0xAC   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_11
   \       0xAE   0x271C             MOVS     R7,#+28
   \       0xB0   0xE032             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_12
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_11: (+1)
   \       0xB2   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xB6   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xBA   0x.... 0x....      LDR.W    R0,??DataTable44_8
   \       0xBE   0x4281             CMP      R1,R0
   \       0xC0   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_13
   \       0xC2   0x2720             MOVS     R7,#+32
   \       0xC4   0xE028             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_12
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_13: (+1)
   \       0xC6   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xCA   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xCE   0x.... 0x....      LDR.W    R0,??DataTable44_9
   \       0xD2   0x4281             CMP      R1,R0
   \       0xD4   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_14
   \       0xD6   0x271C             MOVS     R7,#+28
   \       0xD8   0xE01E             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_15
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_14: (+1)
   \       0xDA   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xDE   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xE2   0x.... 0x....      LDR.W    R0,??DataTable44_10
   \       0xE6   0x4281             CMP      R1,R0
   \       0xE8   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_16
   \       0xEA   0x2720             MOVS     R7,#+32
   \       0xEC   0xE014             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_15
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_16: (+1)
   \       0xEE   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xF2   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xF6   0x.... 0x....      LDR.W    R0,??DataTable44_11
   \       0xFA   0x4281             CMP      R1,R0
   \       0xFC   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_17
   \       0xFE   0x2730             MOVS     R7,#+48
   \      0x100   0xE00A             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_18
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_17: (+1)
   \      0x102   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x106   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x10A   0x.... 0x....      LDR.W    R0,??DataTable44_12
   \      0x10E   0x4281             CMP      R1,R0
   \      0x110   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_19
   \      0x112   0x2740             MOVS     R7,#+64
   \      0x114   0xE000             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_18
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_19: (+1)
   \      0x116   0x2700             MOVS     R7,#+0
   5472              psa_mac_operation_t hmac = PSA_MAC_OPERATION_INIT;
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_18: (+1)
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_15: (+1)
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_12: (+1)
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_9: (+1)
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_6: (+1)
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_3: (+1)
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_1: (+1)
   \      0x118   0xA801             ADD      R0,SP,#+4
   \      0x11A   0xF44F 0x71B2      MOV      R1,#+356
   \      0x11E   0x.... 0x....      BL       __aeabi_memclr4
   5473              size_t hmac_output_length;
   5474              psa_status_t status, cleanup_status;
   5475          
   5476              /* We can't be wanting more output after block 0xff, otherwise
   5477               * the capacity check in psa_key_derivation_output_bytes() would have
   5478               * prevented this call. It could happen only if the operation
   5479               * object was corrupted or if this function is called directly
   5480               * inside the library. */
   5481              if (tls12_prf->block_number == 0xff) {
   \      0x122   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \      0x126   0x28FF             CMP      R0,#+255
   \      0x128   0xD102             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_20
   5482                  return PSA_ERROR_CORRUPTION_DETECTED;
   \      0x12A   0xF07F 0x0096      MVNS     R0,#+150
   \      0x12E   0xE084             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_21
   5483              }
   5484          
   5485              /* We need a new block */
   5486              ++tls12_prf->block_number;
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_20: (+1)
   \      0x130   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \      0x134   0x1C40             ADDS     R0,R0,#+1
   \      0x136   0xF888 0x0001      STRB     R0,[R8, #+1]
   5487              tls12_prf->left_in_block = hash_length;
   \      0x13A   0xF888 0x7000      STRB     R7,[R8, #+0]
   5488          
   5489              /* Recall the definition of the TLS-1.2-PRF from RFC 5246:
   5490               *
   5491               * PRF(secret, label, seed) = P_<hash>(secret, label + seed)
   5492               *
   5493               * P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
   5494               *                        HMAC_hash(secret, A(2) + seed) +
   5495               *                        HMAC_hash(secret, A(3) + seed) + ...
   5496               *
   5497               * A(0) = seed
   5498               * A(i) = HMAC_hash(secret, A(i-1))
   5499               *
   5500               * The `psa_tls12_prf_key_derivation` structure saves the block
   5501               * `HMAC_hash(secret, A(i) + seed)` from which the output
   5502               * is currently extracted as `output_block` and where i is
   5503               * `block_number`.
   5504               */
   5505          
   5506              status = psa_key_derivation_start_hmac(&hmac,
   5507                                                     hash_alg,
   5508                                                     tls12_prf->secret,
   5509                                                     tls12_prf->secret_length);
   \      0x13E   0xF8D8 0x3008      LDR      R3,[R8, #+8]
   \      0x142   0xF8D8 0x2004      LDR      R2,[R8, #+4]
   \      0x146   0x0031             MOVS     R1,R6
   \      0x148   0xA801             ADD      R0,SP,#+4
   \      0x14A   0x.... 0x....      BL       psa_key_derivation_start_hmac
   \      0x14E   0x0004             MOVS     R4,R0
   5510              if (status != PSA_SUCCESS) {
   \      0x150   0x2C00             CMP      R4,#+0
   \      0x152   0xD168             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_22
   5511                  goto cleanup;
   5512              }
   5513          
   5514              /* Calculate A(i) where i = tls12_prf->block_number. */
   5515              if (tls12_prf->block_number == 1) {
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_23: (+1)
   \      0x154   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \      0x158   0x2801             CMP      R0,#+1
   \      0x15A   0xD114             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_24
   5516                  /* A(1) = HMAC_hash(secret, A(0)), where A(0) = seed. (The RFC overloads
   5517                   * the variable seed and in this instance means it in the context of the
   5518                   * P_hash function, where seed = label + seed.) */
   5519                  status = psa_mac_update(&hmac,
   5520                                          tls12_prf->label,
   5521                                          tls12_prf->label_length);
   \      0x15C   0xF8D8 0x2018      LDR      R2,[R8, #+24]
   \      0x160   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \      0x164   0xA801             ADD      R0,SP,#+4
   \      0x166   0x.... 0x....      BL       psa_mac_update
   \      0x16A   0x0004             MOVS     R4,R0
   5522                  if (status != PSA_SUCCESS) {
   \      0x16C   0x2C00             CMP      R4,#+0
   \      0x16E   0xD15A             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_22
   5523                      goto cleanup;
   5524                  }
   5525                  status = psa_mac_update(&hmac,
   5526                                          tls12_prf->seed,
   5527                                          tls12_prf->seed_length);
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_25: (+1)
   \      0x170   0xF8D8 0x2010      LDR      R2,[R8, #+16]
   \      0x174   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \      0x178   0xA801             ADD      R0,SP,#+4
   \      0x17A   0x.... 0x....      BL       psa_mac_update
   \      0x17E   0x0004             MOVS     R4,R0
   5528                  if (status != PSA_SUCCESS) {
   \      0x180   0x2C00             CMP      R4,#+0
   \      0x182   0xD00A             BEQ.N    ??psa_key_derivation_tls12_prf_generate_next_bl_26
   5529                      goto cleanup;
   \      0x184   0xE04F             B.N      ??psa_key_derivation_tls12_prf_generate_next_bl_22
   5530                  }
   5531              } else {
   5532                  /* A(i) = HMAC_hash(secret, A(i-1)) */
   5533                  status = psa_mac_update(&hmac, tls12_prf->Ai, hash_length);
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_24: (+1)
   \      0x186   0x003A             MOVS     R2,R7
   \      0x188   0xB2D2             UXTB     R2,R2
   \      0x18A   0xF118 0x011C      ADDS     R1,R8,#+28
   \      0x18E   0xA801             ADD      R0,SP,#+4
   \      0x190   0x.... 0x....      BL       psa_mac_update
   \      0x194   0x0004             MOVS     R4,R0
   5534                  if (status != PSA_SUCCESS) {
   \      0x196   0x2C00             CMP      R4,#+0
   \      0x198   0xD145             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_22
   5535                      goto cleanup;
   5536                  }
   5537              }
   5538          
   5539              status = psa_mac_sign_finish(&hmac,
   5540                                           tls12_prf->Ai, hash_length,
   5541                                           &hmac_output_length);
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_26: (+1)
   \      0x19A   0x466B             MOV      R3,SP
   \      0x19C   0x003A             MOVS     R2,R7
   \      0x19E   0xB2D2             UXTB     R2,R2
   \      0x1A0   0xF118 0x011C      ADDS     R1,R8,#+28
   \      0x1A4   0xA801             ADD      R0,SP,#+4
   \      0x1A6   0x.... 0x....      BL       psa_mac_sign_finish
   \      0x1AA   0x0004             MOVS     R4,R0
   5542              if (hmac_output_length != hash_length) {
   \      0x1AC   0x9900             LDR      R1,[SP, #+0]
   \      0x1AE   0x0038             MOVS     R0,R7
   \      0x1B0   0xB2C0             UXTB     R0,R0
   \      0x1B2   0x4281             CMP      R1,R0
   \      0x1B4   0xD002             BEQ.N    ??psa_key_derivation_tls12_prf_generate_next_bl_27
   5543                  status = PSA_ERROR_CORRUPTION_DETECTED;
   \      0x1B6   0xF07F 0x0096      MVNS     R0,#+150
   \      0x1BA   0x0004             MOVS     R4,R0
   5544              }
   5545              if (status != PSA_SUCCESS) {
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_27: (+1)
   \      0x1BC   0x2C00             CMP      R4,#+0
   \      0x1BE   0xD132             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_22
   5546                  goto cleanup;
   5547              }
   5548          
   5549              /* Calculate HMAC_hash(secret, A(i) + label + seed). */
   5550              status = psa_key_derivation_start_hmac(&hmac,
   5551                                                     hash_alg,
   5552                                                     tls12_prf->secret,
   5553                                                     tls12_prf->secret_length);
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_28: (+1)
   \      0x1C0   0xF8D8 0x3008      LDR      R3,[R8, #+8]
   \      0x1C4   0xF8D8 0x2004      LDR      R2,[R8, #+4]
   \      0x1C8   0x0031             MOVS     R1,R6
   \      0x1CA   0xA801             ADD      R0,SP,#+4
   \      0x1CC   0x.... 0x....      BL       psa_key_derivation_start_hmac
   \      0x1D0   0x0004             MOVS     R4,R0
   5554              if (status != PSA_SUCCESS) {
   \      0x1D2   0x2C00             CMP      R4,#+0
   \      0x1D4   0xD127             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_22
   5555                  goto cleanup;
   5556              }
   5557              status = psa_mac_update(&hmac, tls12_prf->Ai, hash_length);
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_29: (+1)
   \      0x1D6   0x003A             MOVS     R2,R7
   \      0x1D8   0xB2D2             UXTB     R2,R2
   \      0x1DA   0xF118 0x011C      ADDS     R1,R8,#+28
   \      0x1DE   0xA801             ADD      R0,SP,#+4
   \      0x1E0   0x.... 0x....      BL       psa_mac_update
   \      0x1E4   0x0004             MOVS     R4,R0
   5558              if (status != PSA_SUCCESS) {
   \      0x1E6   0x2C00             CMP      R4,#+0
   \      0x1E8   0xD11D             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_22
   5559                  goto cleanup;
   5560              }
   5561              status = psa_mac_update(&hmac, tls12_prf->label, tls12_prf->label_length);
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_30: (+1)
   \      0x1EA   0xF8D8 0x2018      LDR      R2,[R8, #+24]
   \      0x1EE   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \      0x1F2   0xA801             ADD      R0,SP,#+4
   \      0x1F4   0x.... 0x....      BL       psa_mac_update
   \      0x1F8   0x0004             MOVS     R4,R0
   5562              if (status != PSA_SUCCESS) {
   \      0x1FA   0x2C00             CMP      R4,#+0
   \      0x1FC   0xD113             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_22
   5563                  goto cleanup;
   5564              }
   5565              status = psa_mac_update(&hmac, tls12_prf->seed, tls12_prf->seed_length);
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_31: (+1)
   \      0x1FE   0xF8D8 0x2010      LDR      R2,[R8, #+16]
   \      0x202   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \      0x206   0xA801             ADD      R0,SP,#+4
   \      0x208   0x.... 0x....      BL       psa_mac_update
   \      0x20C   0x0004             MOVS     R4,R0
   5566              if (status != PSA_SUCCESS) {
   \      0x20E   0x2C00             CMP      R4,#+0
   \      0x210   0xD109             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_22
   5567                  goto cleanup;
   5568              }
   5569              status = psa_mac_sign_finish(&hmac,
   5570                                           tls12_prf->output_block, hash_length,
   5571                                           &hmac_output_length);
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_32: (+1)
   \      0x212   0x466B             MOV      R3,SP
   \      0x214   0x003A             MOVS     R2,R7
   \      0x216   0xB2D2             UXTB     R2,R2
   \      0x218   0xF118 0x013C      ADDS     R1,R8,#+60
   \      0x21C   0xA801             ADD      R0,SP,#+4
   \      0x21E   0x.... 0x....      BL       psa_mac_sign_finish
   \      0x222   0x0004             MOVS     R4,R0
   5572              if (status != PSA_SUCCESS) {
   \      0x224   0x2C00             CMP      R4,#+0
   5573                  goto cleanup;
   5574              }
   5575          
   5576          
   5577          cleanup:
   5578              cleanup_status = psa_mac_abort(&hmac);
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_22: (+1)
   \      0x226   0xA801             ADD      R0,SP,#+4
   \      0x228   0x.... 0x....      BL       psa_mac_abort
   \      0x22C   0x0001             MOVS     R1,R0
   5579              if (status == PSA_SUCCESS && cleanup_status != PSA_SUCCESS) {
   \      0x22E   0x2C00             CMP      R4,#+0
   \      0x230   0xD102             BNE.N    ??psa_key_derivation_tls12_prf_generate_next_bl_33
   \      0x232   0x2900             CMP      R1,#+0
   \      0x234   0xD000             BEQ.N    ??psa_key_derivation_tls12_prf_generate_next_bl_33
   5580                  status = cleanup_status;
   \      0x236   0x000C             MOVS     R4,R1
   5581              }
   5582          
   5583              return status;
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_33: (+1)
   \      0x238   0x0020             MOVS     R0,R4
   \                     ??psa_key_derivation_tls12_prf_generate_next_bl_21: (+1)
   \      0x23A   0xB05A             ADD      SP,SP,#+360
   \      0x23C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   5584          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0
   \        0x6                      DS8 2
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 344
   5585          

   \                                 In section .text, align 2, keep-with-next
   5586          static psa_status_t psa_key_derivation_tls12_prf_read(
   5587              psa_tls12_prf_key_derivation_t *tls12_prf,
   5588              psa_algorithm_t alg,
   5589              uint8_t *output,
   5590              size_t output_length)
   5591          {
   \                     psa_key_derivation_tls12_prf_read: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB083             SUB      SP,SP,#+12
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001C             MOVS     R4,R3
   5592              psa_algorithm_t hash_alg = PSA_ALG_TLS12_PRF_GET_HASH(alg);
   \        0xC   0x9E04             LDR      R6,[SP, #+16]
   \        0xE   0xF006 0x06FF      AND      R6,R6,#0xFF
   \       0x12   0xF056 0x7600      ORRS     R6,R6,#0x2000000
   5593              uint8_t hash_length = PSA_HASH_LENGTH(hash_alg);
   \       0x16   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x1A   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable44
   \       0x22   0x4281             CMP      R1,R0
   \       0x24   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_0
   \       0x26   0x2710             MOVS     R7,#+16
   \       0x28   0xE078             B.N      ??psa_key_derivation_tls12_prf_read_1
   \                     ??psa_key_derivation_tls12_prf_read_0: (+1)
   \       0x2A   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x2E   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable44_1
   \       0x36   0x4281             CMP      R1,R0
   \       0x38   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_2
   \       0x3A   0x2714             MOVS     R7,#+20
   \       0x3C   0xE06E             B.N      ??psa_key_derivation_tls12_prf_read_3
   \                     ??psa_key_derivation_tls12_prf_read_2: (+1)
   \       0x3E   0xF006 0x00FF      AND      R0,R6,#0xFF
   \       0x42   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \       0x46   0x.... 0x....      LDR.W    R1,??DataTable44_2
   \       0x4A   0x4288             CMP      R0,R1
   \       0x4C   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_4
   \       0x4E   0x2714             MOVS     R7,#+20
   \       0x50   0xE064             B.N      ??psa_key_derivation_tls12_prf_read_3
   \                     ??psa_key_derivation_tls12_prf_read_4: (+1)
   \       0x52   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x56   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable44_3
   \       0x5E   0x4281             CMP      R1,R0
   \       0x60   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_5
   \       0x62   0x271C             MOVS     R7,#+28
   \       0x64   0xE05A             B.N      ??psa_key_derivation_tls12_prf_read_6
   \                     ??psa_key_derivation_tls12_prf_read_5: (+1)
   \       0x66   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x6A   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable44_4
   \       0x72   0x4281             CMP      R1,R0
   \       0x74   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_7
   \       0x76   0x2720             MOVS     R7,#+32
   \       0x78   0xE050             B.N      ??psa_key_derivation_tls12_prf_read_6
   \                     ??psa_key_derivation_tls12_prf_read_7: (+1)
   \       0x7A   0xF006 0x00FF      AND      R0,R6,#0xFF
   \       0x7E   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \       0x82   0x.... 0x....      LDR.W    R1,??DataTable44_5
   \       0x86   0x4288             CMP      R0,R1
   \       0x88   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_8
   \       0x8A   0x2730             MOVS     R7,#+48
   \       0x8C   0xE046             B.N      ??psa_key_derivation_tls12_prf_read_9
   \                     ??psa_key_derivation_tls12_prf_read_8: (+1)
   \       0x8E   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0x92   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x96   0x.... 0x....      LDR.W    R0,??DataTable44_6
   \       0x9A   0x4281             CMP      R1,R0
   \       0x9C   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_10
   \       0x9E   0x2740             MOVS     R7,#+64
   \       0xA0   0xE03C             B.N      ??psa_key_derivation_tls12_prf_read_9
   \                     ??psa_key_derivation_tls12_prf_read_10: (+1)
   \       0xA2   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xA6   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable44_7
   \       0xAE   0x4281             CMP      R1,R0
   \       0xB0   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_11
   \       0xB2   0x271C             MOVS     R7,#+28
   \       0xB4   0xE032             B.N      ??psa_key_derivation_tls12_prf_read_12
   \                     ??psa_key_derivation_tls12_prf_read_11: (+1)
   \       0xB6   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xBA   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xBE   0x.... 0x....      LDR.W    R0,??DataTable44_8
   \       0xC2   0x4281             CMP      R1,R0
   \       0xC4   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_13
   \       0xC6   0x2720             MOVS     R7,#+32
   \       0xC8   0xE028             B.N      ??psa_key_derivation_tls12_prf_read_12
   \                     ??psa_key_derivation_tls12_prf_read_13: (+1)
   \       0xCA   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xCE   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xD2   0x.... 0x....      LDR.W    R0,??DataTable44_9
   \       0xD6   0x4281             CMP      R1,R0
   \       0xD8   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_14
   \       0xDA   0x271C             MOVS     R7,#+28
   \       0xDC   0xE01E             B.N      ??psa_key_derivation_tls12_prf_read_15
   \                     ??psa_key_derivation_tls12_prf_read_14: (+1)
   \       0xDE   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xE2   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xE6   0x.... 0x....      LDR.W    R0,??DataTable44_10
   \       0xEA   0x4281             CMP      R1,R0
   \       0xEC   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_16
   \       0xEE   0x2720             MOVS     R7,#+32
   \       0xF0   0xE014             B.N      ??psa_key_derivation_tls12_prf_read_15
   \                     ??psa_key_derivation_tls12_prf_read_16: (+1)
   \       0xF2   0xF006 0x01FF      AND      R1,R6,#0xFF
   \       0xF6   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xFA   0x.... 0x....      LDR.W    R0,??DataTable44_11
   \       0xFE   0x4281             CMP      R1,R0
   \      0x100   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_17
   \      0x102   0x2730             MOVS     R7,#+48
   \      0x104   0xE00A             B.N      ??psa_key_derivation_tls12_prf_read_18
   \                     ??psa_key_derivation_tls12_prf_read_17: (+1)
   \      0x106   0xF006 0x00FF      AND      R0,R6,#0xFF
   \      0x10A   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x10E   0x.... 0x....      LDR.W    R1,??DataTable44_12
   \      0x112   0x4288             CMP      R0,R1
   \      0x114   0xD101             BNE.N    ??psa_key_derivation_tls12_prf_read_19
   \      0x116   0x2740             MOVS     R7,#+64
   \      0x118   0xE000             B.N      ??psa_key_derivation_tls12_prf_read_18
   \                     ??psa_key_derivation_tls12_prf_read_19: (+1)
   \      0x11A   0x2700             MOVS     R7,#+0
   5594              psa_status_t status;
   5595              uint8_t offset, length;
   5596          
   5597              switch (tls12_prf->state) {
   \                     ??psa_key_derivation_tls12_prf_read_18: (+1)
   \                     ??psa_key_derivation_tls12_prf_read_15: (+1)
   \                     ??psa_key_derivation_tls12_prf_read_12: (+1)
   \                     ??psa_key_derivation_tls12_prf_read_9: (+1)
   \                     ??psa_key_derivation_tls12_prf_read_6: (+1)
   \                     ??psa_key_derivation_tls12_prf_read_3: (+1)
   \                     ??psa_key_derivation_tls12_prf_read_1: (+1)
   \      0x11C   0xF899 0x0002      LDRB     R0,[R9, #+2]
   \      0x120   0x2804             CMP      R0,#+4
   \      0x122   0xD002             BEQ.N    ??psa_key_derivation_tls12_prf_read_20
   \      0x124   0x2805             CMP      R0,#+5
   \      0x126   0xD004             BEQ.N    ??psa_key_derivation_tls12_prf_read_21
   \      0x128   0xE004             B.N      ??psa_key_derivation_tls12_prf_read_22
   5598                  case PSA_TLS12_PRF_STATE_LABEL_SET:
   5599                      tls12_prf->state = PSA_TLS12_PRF_STATE_OUTPUT;
   \                     ??psa_key_derivation_tls12_prf_read_20: (+1)
   \      0x12A   0x2005             MOVS     R0,#+5
   \      0x12C   0xF889 0x0002      STRB     R0,[R9, #+2]
   5600                      break;
   \      0x130   0xE003             B.N      ??psa_key_derivation_tls12_prf_read_23
   5601                  case PSA_TLS12_PRF_STATE_OUTPUT:
   5602                      break;
   \                     ??psa_key_derivation_tls12_prf_read_21: (+1)
   \      0x132   0xE002             B.N      ??psa_key_derivation_tls12_prf_read_23
   5603                  default:
   5604                      return PSA_ERROR_BAD_STATE;
   \                     ??psa_key_derivation_tls12_prf_read_22: (+1)
   \      0x134   0xF07F 0x0088      MVNS     R0,#+136
   \      0x138   0xE03B             B.N      ??psa_key_derivation_tls12_prf_read_24
   5605              }
   5606          
   5607              while (output_length != 0) {
   \                     ??psa_key_derivation_tls12_prf_read_23: (+1)
   \      0x13A   0x2C00             CMP      R4,#+0
   \      0x13C   0xD038             BEQ.N    ??psa_key_derivation_tls12_prf_read_25
   5608                  /* Check if we have fully processed the current block. */
   5609                  if (tls12_prf->left_in_block == 0) {
   \      0x13E   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \      0x142   0x2800             CMP      R0,#+0
   \      0x144   0xD10A             BNE.N    ??psa_key_derivation_tls12_prf_read_26
   5610                      status = psa_key_derivation_tls12_prf_generate_next_block(tls12_prf,
   5611                                                                                alg);
   \      0x146   0x9904             LDR      R1,[SP, #+16]
   \      0x148   0x4648             MOV      R0,R9
   \      0x14A   0x.... 0x....      BL       psa_key_derivation_tls12_prf_generate_next_block
   \      0x14E   0x9001             STR      R0,[SP, #+4]
   5612                      if (status != PSA_SUCCESS) {
   \      0x150   0x9801             LDR      R0,[SP, #+4]
   \      0x152   0x2800             CMP      R0,#+0
   \      0x154   0xD001             BEQ.N    ??psa_key_derivation_tls12_prf_read_27
   5613                          return status;
   \      0x156   0x9801             LDR      R0,[SP, #+4]
   \      0x158   0xE02B             B.N      ??psa_key_derivation_tls12_prf_read_24
   5614                      }
   5615          
   5616                      continue;
   \                     ??psa_key_derivation_tls12_prf_read_27: (+1)
   \      0x15A   0xE7EE             B.N      ??psa_key_derivation_tls12_prf_read_23
   5617                  }
   5618          
   5619                  if (tls12_prf->left_in_block > output_length) {
   \                     ??psa_key_derivation_tls12_prf_read_26: (+1)
   \      0x15C   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \      0x160   0x4284             CMP      R4,R0
   \      0x162   0xD202             BCS.N    ??psa_key_derivation_tls12_prf_read_28
   5620                      length = (uint8_t) output_length;
   \      0x164   0x0020             MOVS     R0,R4
   \      0x166   0x4680             MOV      R8,R0
   \      0x168   0xE002             B.N      ??psa_key_derivation_tls12_prf_read_29
   5621                  } else {
   5622                      length = tls12_prf->left_in_block;
   \                     ??psa_key_derivation_tls12_prf_read_28: (+1)
   \      0x16A   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \      0x16E   0x4680             MOV      R8,R0
   5623                  }
   5624          
   5625                  offset = hash_length - tls12_prf->left_in_block;
   \                     ??psa_key_derivation_tls12_prf_read_29: (+1)
   \      0x170   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \      0x174   0x1A38             SUBS     R0,R7,R0
   \      0x176   0xF88D 0x0000      STRB     R0,[SP, #+0]
   5626                  memcpy(output, tls12_prf->output_block + offset, length);
   \      0x17A   0x46C2             MOV      R10,R8
   \      0x17C   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x180   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x184   0x4448             ADD      R0,R9,R0
   \      0x186   0x303C             ADDS     R0,R0,#+60
   \      0x188   0x9002             STR      R0,[SP, #+8]
   \      0x18A   0x46AB             MOV      R11,R5
   \      0x18C   0x4652             MOV      R2,R10
   \      0x18E   0x9902             LDR      R1,[SP, #+8]
   \      0x190   0x4658             MOV      R0,R11
   \      0x192   0x.... 0x....      BL       __aeabi_memcpy
   5627                  output += length;
   \      0x196   0x4640             MOV      R0,R8
   \      0x198   0xB2C0             UXTB     R0,R0
   \      0x19A   0x4405             ADD      R5,R5,R0
   5628                  output_length -= length;
   \      0x19C   0x4640             MOV      R0,R8
   \      0x19E   0xB2C0             UXTB     R0,R0
   \      0x1A0   0x1A24             SUBS     R4,R4,R0
   5629                  tls12_prf->left_in_block -= length;
   \      0x1A2   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \      0x1A6   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x1AA   0xF889 0x0000      STRB     R0,[R9, #+0]
   \      0x1AE   0xE7C4             B.N      ??psa_key_derivation_tls12_prf_read_23
   5630              }
   5631          
   5632              return PSA_SUCCESS;
   \                     ??psa_key_derivation_tls12_prf_read_25: (+1)
   \      0x1B0   0x2000             MOVS     R0,#+0
   \                     ??psa_key_derivation_tls12_prf_read_24: (+1)
   \      0x1B2   0xB005             ADD      SP,SP,#+20
   \      0x1B4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   5633          }
   5634          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF ||
   5635                  * MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS */
   5636          
   5637          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS)
   5638          static psa_status_t psa_key_derivation_tls12_ecjpake_to_pms_read(
   5639              psa_tls12_ecjpake_to_pms_t *ecjpake,
   5640              uint8_t *output,
   5641              size_t output_length)
   5642          {
   5643              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   5644              size_t output_size = 0;
   5645          
   5646              if (output_length != 32) {
   5647                  return PSA_ERROR_INVALID_ARGUMENT;
   5648              }
   5649          
   5650              status = psa_hash_compute(PSA_ALG_SHA_256, ecjpake->data,
   5651                                        PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE, output, output_length,
   5652                                        &output_size);
   5653              if (status != PSA_SUCCESS) {
   5654                  return status;
   5655              }
   5656          
   5657              if (output_size != output_length) {
   5658                  return PSA_ERROR_GENERIC_ERROR;
   5659              }
   5660          
   5661              return PSA_SUCCESS;
   5662          }
   5663          #endif
   5664          
   5665          #if defined(PSA_HAVE_SOFT_PBKDF2)
   5666          static psa_status_t psa_key_derivation_pbkdf2_generate_block(
   5667              psa_pbkdf2_key_derivation_t *pbkdf2,
   5668              psa_algorithm_t prf_alg,
   5669              uint8_t prf_output_length,
   5670              psa_key_attributes_t *attributes)
   5671          {
   5672              psa_status_t status;
   5673              psa_mac_operation_t mac_operation = PSA_MAC_OPERATION_INIT;
   5674              size_t mac_output_length;
   5675              uint8_t U_i[PSA_MAC_MAX_SIZE];
   5676              uint8_t *U_accumulator = pbkdf2->output_block;
   5677              uint64_t i;
   5678              uint8_t block_counter[4];
   5679          
   5680              mac_operation.is_sign = 1;
   5681              mac_operation.mac_size = prf_output_length;
   5682              MBEDTLS_PUT_UINT32_BE(pbkdf2->block_number, block_counter, 0);
   5683          
   5684              status = psa_driver_wrapper_mac_sign_setup(&mac_operation,
   5685                                                         attributes,
   5686                                                         pbkdf2->password,
   5687                                                         pbkdf2->password_length,
   5688                                                         prf_alg);
   5689              if (status != PSA_SUCCESS) {
   5690                  goto cleanup;
   5691              }
   5692              status = psa_mac_update(&mac_operation, pbkdf2->salt, pbkdf2->salt_length);
   5693              if (status != PSA_SUCCESS) {
   5694                  goto cleanup;
   5695              }
   5696              status = psa_mac_update(&mac_operation, block_counter, sizeof(block_counter));
   5697              if (status != PSA_SUCCESS) {
   5698                  goto cleanup;
   5699              }
   5700              status = psa_mac_sign_finish(&mac_operation, U_i, sizeof(U_i),
   5701                                           &mac_output_length);
   5702              if (status != PSA_SUCCESS) {
   5703                  goto cleanup;
   5704              }
   5705          
   5706              if (mac_output_length != prf_output_length) {
   5707                  status = PSA_ERROR_CORRUPTION_DETECTED;
   5708                  goto cleanup;
   5709              }
   5710          
   5711              memcpy(U_accumulator, U_i, prf_output_length);
   5712          
   5713              for (i = 1; i < pbkdf2->input_cost; i++) {
   5714                  /* We are passing prf_output_length as mac_size because the driver
   5715                   * function directly sets mac_output_length as mac_size upon success.
   5716                   * See https://github.com/Mbed-TLS/mbedtls/issues/7801 */
   5717                  status = psa_driver_wrapper_mac_compute(attributes,
   5718                                                          pbkdf2->password,
   5719                                                          pbkdf2->password_length,
   5720                                                          prf_alg, U_i, prf_output_length,
   5721                                                          U_i, prf_output_length,
   5722                                                          &mac_output_length);
   5723                  if (status != PSA_SUCCESS) {
   5724                      goto cleanup;
   5725                  }
   5726          
   5727                  mbedtls_xor(U_accumulator, U_accumulator, U_i, prf_output_length);
   5728              }
   5729          
   5730          cleanup:
   5731              /* Zeroise buffers to clear sensitive data from memory. */
   5732              mbedtls_platform_zeroize(U_i, PSA_MAC_MAX_SIZE);
   5733              return status;
   5734          }
   5735          
   5736          static psa_status_t psa_key_derivation_pbkdf2_read(
   5737              psa_pbkdf2_key_derivation_t *pbkdf2,
   5738              psa_algorithm_t kdf_alg,
   5739              uint8_t *output,
   5740              size_t output_length)
   5741          {
   5742              psa_status_t status;
   5743              psa_algorithm_t prf_alg;
   5744              uint8_t prf_output_length;
   5745              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   5746              psa_set_key_bits(&attributes, PSA_BYTES_TO_BITS(pbkdf2->password_length));
   5747              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_MESSAGE);
   5748          
   5749              if (PSA_ALG_IS_PBKDF2_HMAC(kdf_alg)) {
   5750                  prf_alg = PSA_ALG_HMAC(PSA_ALG_PBKDF2_HMAC_GET_HASH(kdf_alg));
   5751                  prf_output_length = PSA_HASH_LENGTH(prf_alg);
   5752                  psa_set_key_type(&attributes, PSA_KEY_TYPE_HMAC);
   5753              } else if (kdf_alg == PSA_ALG_PBKDF2_AES_CMAC_PRF_128) {
   5754                  prf_alg = PSA_ALG_CMAC;
   5755                  prf_output_length = PSA_MAC_LENGTH(PSA_KEY_TYPE_AES, 128U, PSA_ALG_CMAC);
   5756                  psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
   5757              } else {
   5758                  return PSA_ERROR_INVALID_ARGUMENT;
   5759              }
   5760          
   5761              switch (pbkdf2->state) {
   5762                  case PSA_PBKDF2_STATE_PASSWORD_SET:
   5763                      /* Initially we need a new block so bytes_used is equal to block size*/
   5764                      pbkdf2->bytes_used = prf_output_length;
   5765                      pbkdf2->state = PSA_PBKDF2_STATE_OUTPUT;
   5766                      break;
   5767                  case PSA_PBKDF2_STATE_OUTPUT:
   5768                      break;
   5769                  default:
   5770                      return PSA_ERROR_BAD_STATE;
   5771              }
   5772          
   5773              while (output_length != 0) {
   5774                  uint8_t n = prf_output_length - pbkdf2->bytes_used;
   5775                  if (n > output_length) {
   5776                      n = (uint8_t) output_length;
   5777                  }
   5778                  memcpy(output, pbkdf2->output_block + pbkdf2->bytes_used, n);
   5779                  output += n;
   5780                  output_length -= n;
   5781                  pbkdf2->bytes_used += n;
   5782          
   5783                  if (output_length == 0) {
   5784                      break;
   5785                  }
   5786          
   5787                  /* We need a new block */
   5788                  pbkdf2->bytes_used = 0;
   5789                  pbkdf2->block_number++;
   5790          
   5791                  status = psa_key_derivation_pbkdf2_generate_block(pbkdf2, prf_alg,
   5792                                                                    prf_output_length,
   5793                                                                    &attributes);
   5794                  if (status != PSA_SUCCESS) {
   5795                      return status;
   5796                  }
   5797              }
   5798          
   5799              return PSA_SUCCESS;
   5800          }
   5801          #endif /* PSA_HAVE_SOFT_PBKDF2 */
   5802          

   \                                 In section .text, align 2, keep-with-next
   5803          psa_status_t psa_key_derivation_output_bytes(
   5804              psa_key_derivation_operation_t *operation,
   5805              uint8_t *output,
   5806              size_t output_length)
   5807          {
   \                     psa_key_derivation_output_bytes: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   5808              psa_status_t status;
   5809              psa_algorithm_t kdf_alg = psa_key_derivation_get_kdf_alg(operation);
   \        0xA   0x4640             MOV      R0,R8
   \        0xC   0x.... 0x....      BL       psa_key_derivation_get_kdf_alg
   \       0x10   0x0007             MOVS     R7,R0
   5810          
   5811              if (operation->alg == 0) {
   \       0x12   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD102             BNE.N    ??psa_key_derivation_output_bytes_0
   5812                  /* This is a blank operation. */
   5813                  return PSA_ERROR_BAD_STATE;
   \       0x1A   0xF07F 0x0088      MVNS     R0,#+136
   \       0x1E   0xE042             B.N      ??psa_key_derivation_output_bytes_1
   5814              }
   5815          
   5816              if (output_length > operation->capacity) {
   \                     ??psa_key_derivation_output_bytes_0: (+1)
   \       0x20   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x24   0x42A0             CMP      R0,R4
   \       0x26   0xD205             BCS.N    ??psa_key_derivation_output_bytes_2
   5817                  operation->capacity = 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF8C8 0x0008      STR      R0,[R8, #+8]
   5818                  /* Go through the error path to wipe all confidential data now
   5819                   * that the operation object is useless. */
   5820                  status = PSA_ERROR_INSUFFICIENT_DATA;
   \       0x2E   0xF07F 0x058E      MVNS     R5,#+142
   5821                  goto exit;
   \       0x32   0xE025             B.N      ??psa_key_derivation_output_bytes_3
   5822              }
   5823              if (output_length == 0 && operation->capacity == 0) {
   \                     ??psa_key_derivation_output_bytes_2: (+1)
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD106             BNE.N    ??psa_key_derivation_output_bytes_4
   \       0x38   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD102             BNE.N    ??psa_key_derivation_output_bytes_4
   5824                  /* Edge case: this is a finished operation, and 0 bytes
   5825                   * were requested. The right error in this case could
   5826                   * be either INSUFFICIENT_CAPACITY or BAD_STATE. Return
   5827                   * INSUFFICIENT_CAPACITY, which is right for a finished
   5828                   * operation, for consistency with the case when
   5829                   * output_length > 0. */
   5830                  return PSA_ERROR_INSUFFICIENT_DATA;
   \       0x40   0xF07F 0x008E      MVNS     R0,#+142
   \       0x44   0xE02F             B.N      ??psa_key_derivation_output_bytes_1
   5831              }
   5832              operation->capacity -= output_length;
   \                     ??psa_key_derivation_output_bytes_4: (+1)
   \       0x46   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x4A   0x1B00             SUBS     R0,R0,R4
   \       0x4C   0xF8C8 0x0008      STR      R0,[R8, #+8]
   5833          
   5834          #if defined(BUILTIN_ALG_ANY_HKDF)
   5835              if (PSA_ALG_IS_ANY_HKDF(kdf_alg)) {
   5836                  status = psa_key_derivation_hkdf_read(&operation->ctx.hkdf, kdf_alg,
   5837                                                        output, output_length);
   5838              } else
   5839          #endif /* BUILTIN_ALG_ANY_HKDF */
   5840          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF) || \
   5841              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)
   5842              if (PSA_ALG_IS_TLS12_PRF(kdf_alg) ||
   5843                  PSA_ALG_IS_TLS12_PSK_TO_MS(kdf_alg)) {
   \       0x50   0x0A39             LSRS     R1,R7,#+8
   \       0x52   0x0209             LSLS     R1,R1,#+8
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable44_13
   \       0x58   0x4281             CMP      R1,R0
   \       0x5A   0xD005             BEQ.N    ??psa_key_derivation_output_bytes_5
   \       0x5C   0x0A39             LSRS     R1,R7,#+8
   \       0x5E   0x0209             LSLS     R1,R1,#+8
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable44_14
   \       0x64   0x4281             CMP      R1,R0
   \       0x66   0xD108             BNE.N    ??psa_key_derivation_output_bytes_6
   5844                  status = psa_key_derivation_tls12_prf_read(&operation->ctx.tls12_prf,
   5845                                                             kdf_alg, output,
   5846                                                             output_length);
   \                     ??psa_key_derivation_output_bytes_5: (+1)
   \       0x68   0x0023             MOVS     R3,R4
   \       0x6A   0x0032             MOVS     R2,R6
   \       0x6C   0x0039             MOVS     R1,R7
   \       0x6E   0xF118 0x000C      ADDS     R0,R8,#+12
   \       0x72   0x.... 0x....      BL       psa_key_derivation_tls12_prf_read
   \       0x76   0x0005             MOVS     R5,R0
   \       0x78   0xE002             B.N      ??psa_key_derivation_output_bytes_3
   5847              } else
   5848          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF ||
   5849                  * MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS */
   5850          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS)
   5851              if (kdf_alg == PSA_ALG_TLS12_ECJPAKE_TO_PMS) {
   5852                  status = psa_key_derivation_tls12_ecjpake_to_pms_read(
   5853                      &operation->ctx.tls12_ecjpake_to_pms, output, output_length);
   5854              } else
   5855          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS */
   5856          #if defined(PSA_HAVE_SOFT_PBKDF2)
   5857              if (PSA_ALG_IS_PBKDF2(kdf_alg)) {
   5858                  status = psa_key_derivation_pbkdf2_read(&operation->ctx.pbkdf2, kdf_alg,
   5859                                                          output, output_length);
   5860              } else
   5861          #endif /* PSA_HAVE_SOFT_PBKDF2 */
   5862          
   5863              {
   5864                  (void) kdf_alg;
   5865                  return PSA_ERROR_BAD_STATE;
   \                     ??psa_key_derivation_output_bytes_6: (+1)
   \       0x7A   0xF07F 0x0088      MVNS     R0,#+136
   \       0x7E   0xE012             B.N      ??psa_key_derivation_output_bytes_1
   5866              }
   5867          
   5868          exit:
   5869              if (status != PSA_SUCCESS) {
   \                     ??psa_key_derivation_output_bytes_3: (+1)
   \       0x80   0x2D00             CMP      R5,#+0
   \       0x82   0xD00F             BEQ.N    ??psa_key_derivation_output_bytes_7
   5870                  /* Preserve the algorithm upon errors, but clear all sensitive state.
   5871                   * This allows us to differentiate between exhausted operations and
   5872                   * blank operations, so we can return PSA_ERROR_BAD_STATE on blank
   5873                   * operations. */
   5874                  psa_algorithm_t alg = operation->alg;
   \       0x84   0xF8D8 0x9000      LDR      R9,[R8, #+0]
   5875                  psa_key_derivation_abort(operation);
   \       0x88   0x4640             MOV      R0,R8
   \       0x8A   0x.... 0x....      BL       psa_key_derivation_abort
   5876                  operation->alg = alg;
   \       0x8E   0xF8C8 0x9000      STR      R9,[R8, #+0]
   5877                  memset(output, '!', output_length);
   \       0x92   0x9400             STR      R4,[SP, #+0]
   \       0x94   0xF05F 0x0B21      MOVS     R11,#+33
   \       0x98   0x46B2             MOV      R10,R6
   \       0x9A   0x465A             MOV      R2,R11
   \       0x9C   0x9900             LDR      R1,[SP, #+0]
   \       0x9E   0x4650             MOV      R0,R10
   \       0xA0   0x.... 0x....      BL       __aeabi_memset
   5878              }
   5879              return status;
   \                     ??psa_key_derivation_output_bytes_7: (+1)
   \       0xA4   0x0028             MOVS     R0,R5
   \                     ??psa_key_derivation_output_bytes_1: (+1)
   \       0xA6   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   5880          }
   5881          
   5882          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES)
   5883          static void psa_des_set_key_parity(uint8_t *data, size_t data_size)
   5884          {
   5885              if (data_size >= 8) {
   5886                  mbedtls_des_key_set_parity(data);
   5887              }
   5888              if (data_size >= 16) {
   5889                  mbedtls_des_key_set_parity(data + 8);
   5890              }
   5891              if (data_size >= 24) {
   5892                  mbedtls_des_key_set_parity(data + 16);
   5893              }
   5894          }
   5895          #endif /* MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES */
   5896          
   5897          /*
   5898           * ECC keys on a Weierstrass elliptic curve require the generation
   5899           * of a private key which is an integer
   5900           * in the range [1, N - 1], where N is the boundary of the private key domain:
   5901           * N is the prime p for Diffie-Hellman, or the order of the
   5902           * curves base point for ECC.
   5903           *
   5904           * Let m be the bit size of N, such that 2^m > N >= 2^(m-1).
   5905           * This function generates the private key using the following process:
   5906           *
   5907           * 1. Draw a byte string of length ceiling(m/8) bytes.
   5908           * 2. If m is not a multiple of 8, set the most significant
   5909           *    (8 * ceiling(m/8) - m) bits of the first byte in the string to zero.
   5910           * 3. Convert the string to integer k by decoding it as a big-endian byte string.
   5911           * 4. If k > N - 2, discard the result and return to step 1.
   5912           * 5. Output k + 1 as the private key.
   5913           *
   5914           * This method allows compliance to NIST standards, specifically the methods titled
   5915           * Key-Pair Generation by Testing Candidates in the following publications:
   5916           * - NIST Special Publication 800-56A: Recommendation for Pair-Wise Key-Establishment
   5917           *   Schemes Using Discrete Logarithm Cryptography [SP800-56A] 5.6.1.1.4 for
   5918           *   Diffie-Hellman keys.
   5919           *
   5920           * - [SP800-56A] 5.6.1.2.2 or FIPS Publication 186-4: Digital Signature
   5921           *   Standard (DSS) [FIPS186-4] B.4.2 for elliptic curve keys.
   5922           *
   5923           * Note: Function allocates memory for *data buffer, so given *data should be
   5924           *       always NULL.
   5925           */
   5926          #if defined(PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_DERIVE)
   5927          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_DERIVE)
   5928          static psa_status_t psa_generate_derived_ecc_key_weierstrass_helper(
   5929              psa_key_slot_t *slot,
   5930              size_t bits,
   5931              psa_key_derivation_operation_t *operation,
   5932              uint8_t **data
   5933              )
   5934          {
   5935              unsigned key_out_of_range = 1;
   5936              mbedtls_mpi k;
   5937              mbedtls_mpi diff_N_2;
   5938              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   5939              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   5940              size_t m;
   5941              size_t m_bytes;
   5942          
   5943              mbedtls_mpi_init(&k);
   5944              mbedtls_mpi_init(&diff_N_2);
   5945          
   5946              psa_ecc_family_t curve = PSA_KEY_TYPE_ECC_GET_FAMILY(
   5947                  slot->attr.type);
   5948              mbedtls_ecp_group_id grp_id =
   5949                  mbedtls_ecc_group_of_psa(curve, bits, 0);
   5950          
   5951              if (grp_id == MBEDTLS_ECP_DP_NONE) {
   5952                  ret = MBEDTLS_ERR_ASN1_INVALID_DATA;
   5953                  goto cleanup;
   5954              }
   5955          
   5956              mbedtls_ecp_group ecp_group;
   5957              mbedtls_ecp_group_init(&ecp_group);
   5958          
   5959              MBEDTLS_MPI_CHK(mbedtls_ecp_group_load(&ecp_group, grp_id));
   5960          
   5961              /* N is the boundary of the private key domain (ecp_group.N). */
   5962              /* Let m be the bit size of N. */
   5963              m = ecp_group.nbits;
   5964          
   5965              m_bytes = PSA_BITS_TO_BYTES(m);
   5966          
   5967              /* Calculate N - 2 - it will be needed later. */
   5968              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int(&diff_N_2, &ecp_group.N, 2));
   5969          
   5970              /* Note: This function is always called with *data == NULL and it
   5971               * allocates memory for the data buffer. */
   5972              *data = mbedtls_calloc(1, m_bytes);
   5973              if (*data == NULL) {
   5974                  ret = MBEDTLS_ERR_ASN1_ALLOC_FAILED;
   5975                  goto cleanup;
   5976              }
   5977          
   5978              while (key_out_of_range) {
   5979                  /* 1. Draw a byte string of length ceiling(m/8) bytes. */
   5980                  if ((status = psa_key_derivation_output_bytes(operation, *data, m_bytes)) != 0) {
   5981                      goto cleanup;
   5982                  }
   5983          
   5984                  /* 2. If m is not a multiple of 8 */
   5985                  if (m % 8 != 0) {
   5986                      /* Set the most significant
   5987                       * (8 * ceiling(m/8) - m) bits of the first byte in
   5988                       * the string to zero.
   5989                       */
   5990                      uint8_t clear_bit_mask = (1 << (m % 8)) - 1;
   5991                      (*data)[0] &= clear_bit_mask;
   5992                  }
   5993          
   5994                  /* 3. Convert the string to integer k by decoding it as a
   5995                   *    big-endian byte string.
   5996                   */
   5997                  MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&k, *data, m_bytes));
   5998          
   5999                  /* 4. If k > N - 2, discard the result and return to step 1.
   6000                   *    Result of comparison is returned. When it indicates error
   6001                   *    then this function is called again.
   6002                   */
   6003                  MBEDTLS_MPI_CHK(mbedtls_mpi_lt_mpi_ct(&diff_N_2, &k, &key_out_of_range));
   6004              }
   6005          
   6006              /* 5. Output k + 1 as the private key. */
   6007              MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&k, &k, 1));
   6008              MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&k, *data, m_bytes));
   6009          cleanup:
   6010              if (ret != 0) {
   6011                  status = mbedtls_to_psa_error(ret);
   6012              }
   6013              if (status != PSA_SUCCESS) {
   6014                  mbedtls_free(*data);
   6015                  *data = NULL;
   6016              }
   6017              mbedtls_mpi_free(&k);
   6018              mbedtls_mpi_free(&diff_N_2);
   6019              return status;
   6020          }
   6021          
   6022          /* ECC keys on a Montgomery elliptic curve draws a byte string whose length
   6023           * is determined by the curve, and sets the mandatory bits accordingly. That is:
   6024           *
   6025           * - Curve25519 (PSA_ECC_FAMILY_MONTGOMERY, 255 bits):
   6026           *   draw a 32-byte string and process it as specified in
   6027           *   Elliptic Curves for Security [RFC7748] 5.
   6028           *
   6029           * - Curve448 (PSA_ECC_FAMILY_MONTGOMERY, 448 bits):
   6030           *   draw a 56-byte string and process it as specified in [RFC7748] 5.
   6031           *
   6032           * Note: Function allocates memory for *data buffer, so given *data should be
   6033           *       always NULL.
   6034           */
   6035          
   6036          static psa_status_t psa_generate_derived_ecc_key_montgomery_helper(
   6037              size_t bits,
   6038              psa_key_derivation_operation_t *operation,
   6039              uint8_t **data
   6040              )
   6041          {
   6042              size_t output_length;
   6043              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   6044          
   6045              switch (bits) {
   6046                  case 255:
   6047                      output_length = 32;
   6048                      break;
   6049                  case 448:
   6050                      output_length = 56;
   6051                      break;
   6052                  default:
   6053                      return PSA_ERROR_INVALID_ARGUMENT;
   6054                      break;
   6055              }
   6056          
   6057              *data = mbedtls_calloc(1, output_length);
   6058          
   6059              if (*data == NULL) {
   6060                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   6061              }
   6062          
   6063              status = psa_key_derivation_output_bytes(operation, *data, output_length);
   6064          
   6065              if (status != PSA_SUCCESS) {
   6066                  return status;
   6067              }
   6068          
   6069              switch (bits) {
   6070                  case 255:
   6071                      (*data)[0] &= 248;
   6072                      (*data)[31] &= 127;
   6073                      (*data)[31] |= 64;
   6074                      break;
   6075                  case 448:
   6076                      (*data)[0] &= 252;
   6077                      (*data)[55] |= 128;
   6078                      break;
   6079                  default:
   6080                      return PSA_ERROR_CORRUPTION_DETECTED;
   6081                      break;
   6082              }
   6083          
   6084              return status;
   6085          }
   6086          #else /* MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_DERIVE */

   \                                 In section .text, align 2, keep-with-next
   6087          static psa_status_t psa_generate_derived_ecc_key_weierstrass_helper(
   6088              psa_key_slot_t *slot, size_t bits,
   6089              psa_key_derivation_operation_t *operation, uint8_t **data)
   6090          {
   \                     psa_generate_derived_ecc_key_weierstrass_helper: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0004             MOVS     R4,R0
   6091              (void) slot;
   6092              (void) bits;
   6093              (void) operation;
   6094              (void) data;
   6095              return PSA_ERROR_NOT_SUPPORTED;
   \        0x4   0xF07F 0x0085      MVNS     R0,#+133
   \        0x8   0xBC10             POP      {R4}
   \        0xA   0x4770             BX       LR
   6096          }
   6097          

   \                                 In section .text, align 2, keep-with-next
   6098          static psa_status_t psa_generate_derived_ecc_key_montgomery_helper(
   6099              size_t bits, psa_key_derivation_operation_t *operation, uint8_t **data)
   6100          {
   \                     psa_generate_derived_ecc_key_montgomery_helper: (+1)
   \        0x0   0x0003             MOVS     R3,R0
   6101              (void) bits;
   6102              (void) operation;
   6103              (void) data;
   6104              return PSA_ERROR_NOT_SUPPORTED;
   \        0x2   0xF07F 0x0085      MVNS     R0,#+133
   \        0x6   0x4770             BX       LR
   6105          }
   6106          #endif /* MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_DERIVE */
   6107          #endif /* PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_DERIVE */
   6108          

   \                                 In section .text, align 2, keep-with-next
   6109          static psa_status_t psa_generate_derived_key_internal(
   6110              psa_key_slot_t *slot,
   6111              size_t bits,
   6112              psa_key_derivation_operation_t *operation)
   6113          {
   \                     psa_generate_derived_key_internal: (+1)
   \        0x0   0xE92D 0x43F3      PUSH     {R0,R1,R4-R9,LR}
   \        0x4   0xB097             SUB      SP,SP,#+92
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x0015             MOVS     R5,R2
   6114              uint8_t *data = NULL;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9003             STR      R0,[SP, #+12]
   6115              size_t bytes = PSA_BITS_TO_BYTES(bits);
   \        0xE   0x9E18             LDR      R6,[SP, #+96]
   \       0x10   0x1DF6             ADDS     R6,R6,#+7
   \       0x12   0x08F6             LSRS     R6,R6,#+3
   6116              size_t storage_size = bytes;
   \       0x14   0x9604             STR      R6,[SP, #+16]
   6117              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x0896      MVNS     R8,#+150
   6118              psa_key_attributes_t attributes;
   6119          
   6120              if (PSA_KEY_TYPE_IS_PUBLIC_KEY(slot->attr.type)) {
   \       0x1A   0x8838             LDRH     R0,[R7, #+0]
   \       0x1C   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x20   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x24   0xD102             BNE.N    ??psa_generate_derived_key_internal_0
   6121                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x26   0xF07F 0x0086      MVNS     R0,#+134
   \       0x2A   0xE085             B.N      ??psa_generate_derived_key_internal_1
   6122              }
   6123          
   6124          #if defined(PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_DERIVE) || \
   6125              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_DERIVE)
   6126              if (PSA_KEY_TYPE_IS_ECC(slot->attr.type)) {
   \                     ??psa_generate_derived_key_internal_0: (+1)
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable49
   \       0x30   0x8839             LDRH     R1,[R7, #+0]
   \       0x32   0x4001             ANDS     R1,R0,R1
   \       0x34   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x38   0xD11F             BNE.N    ??psa_generate_derived_key_internal_2
   6127                  psa_ecc_family_t curve = PSA_KEY_TYPE_ECC_GET_FAMILY(slot->attr.type);
   \       0x3A   0x8839             LDRH     R1,[R7, #+0]
   \       0x3C   0x4008             ANDS     R0,R0,R1
   \       0x3E   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0x42   0xD102             BNE.N    ??psa_generate_derived_key_internal_3
   \       0x44   0xF8B7 0x9000      LDRH     R9,[R7, #+0]
   \       0x48   0xE001             B.N      ??psa_generate_derived_key_internal_4
   \                     ??psa_generate_derived_key_internal_3: (+1)
   \       0x4A   0xF05F 0x0900      MOVS     R9,#+0
   6128                  if (PSA_ECC_FAMILY_IS_WEIERSTRASS(curve)) {
   \                     ??psa_generate_derived_key_internal_4: (+1)
   \       0x4E   0xF019 0x0FC0      TST      R9,#0xC0
   \       0x52   0xD109             BNE.N    ??psa_generate_derived_key_internal_5
   6129                      /* Weierstrass elliptic curve */
   6130                      status = psa_generate_derived_ecc_key_weierstrass_helper(slot, bits, operation, &data);
   \       0x54   0xAB03             ADD      R3,SP,#+12
   \       0x56   0x002A             MOVS     R2,R5
   \       0x58   0x9918             LDR      R1,[SP, #+96]
   \       0x5A   0x0038             MOVS     R0,R7
   \       0x5C   0x.... 0x....      BL       psa_generate_derived_ecc_key_weierstrass_helper
   \       0x60   0x0004             MOVS     R4,R0
   6131                      if (status != PSA_SUCCESS) {
   \       0x62   0x2C00             CMP      R4,#+0
   \       0x64   0xD02C             BEQ.N    ??psa_generate_derived_key_internal_6
   6132                          goto exit;
   \       0x66   0xE063             B.N      ??psa_generate_derived_key_internal_7
   6133                      }
   6134                  } else {
   6135                      /* Montgomery elliptic curve */
   6136                      status = psa_generate_derived_ecc_key_montgomery_helper(bits, operation, &data);
   \                     ??psa_generate_derived_key_internal_5: (+1)
   \       0x68   0xAA03             ADD      R2,SP,#+12
   \       0x6A   0x0029             MOVS     R1,R5
   \       0x6C   0x9818             LDR      R0,[SP, #+96]
   \       0x6E   0x.... 0x....      BL       psa_generate_derived_ecc_key_montgomery_helper
   \       0x72   0x0004             MOVS     R4,R0
   6137                      if (status != PSA_SUCCESS) {
   \       0x74   0x2C00             CMP      R4,#+0
   \       0x76   0xD023             BEQ.N    ??psa_generate_derived_key_internal_6
   6138                          goto exit;
   \       0x78   0xE05A             B.N      ??psa_generate_derived_key_internal_7
   6139                      }
   6140                  }
   6141              } else
   6142          #endif /* defined(PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_DERIVE) ||
   6143                    defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_DERIVE) */
   6144              if (key_type_is_raw_bytes(slot->attr.type)) {
   \                     ??psa_generate_derived_key_internal_2: (+1)
   \       0x7A   0x8838             LDRH     R0,[R7, #+0]
   \       0x7C   0x.... 0x....      BL       key_type_is_raw_bytes
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD01A             BEQ.N    ??psa_generate_derived_key_internal_8
   6145                  if (bits % 8 != 0) {
   \       0x84   0x9818             LDR      R0,[SP, #+96]
   \       0x86   0xF010 0x0F07      TST      R0,#0x7
   \       0x8A   0xD002             BEQ.N    ??psa_generate_derived_key_internal_9
   6146                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x8C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x90   0xE052             B.N      ??psa_generate_derived_key_internal_1
   6147                  }
   6148                  data = mbedtls_calloc(1, bytes);
   \                     ??psa_generate_derived_key_internal_9: (+1)
   \       0x92   0x0031             MOVS     R1,R6
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0x.... 0x....      BL       sl_calloc
   \       0x9A   0x9003             STR      R0,[SP, #+12]
   6149                  if (data == NULL) {
   \       0x9C   0x9803             LDR      R0,[SP, #+12]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD102             BNE.N    ??psa_generate_derived_key_internal_10
   6150                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0xA2   0xF07F 0x008C      MVNS     R0,#+140
   \       0xA6   0xE047             B.N      ??psa_generate_derived_key_internal_1
   6151                  }
   6152          
   6153                  status = psa_key_derivation_output_bytes(operation, data, bytes);
   \                     ??psa_generate_derived_key_internal_10: (+1)
   \       0xA8   0x0032             MOVS     R2,R6
   \       0xAA   0x9903             LDR      R1,[SP, #+12]
   \       0xAC   0x0028             MOVS     R0,R5
   \       0xAE   0x.... 0x....      BL       psa_key_derivation_output_bytes
   \       0xB2   0x0004             MOVS     R4,R0
   6154                  if (status != PSA_SUCCESS) {
   \       0xB4   0x2C00             CMP      R4,#+0
   \       0xB6   0xD003             BEQ.N    ??psa_generate_derived_key_internal_6
   6155                      goto exit;
   \       0xB8   0xE03A             B.N      ??psa_generate_derived_key_internal_7
   6156                  }
   6157          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES)
   6158                  if (slot->attr.type == PSA_KEY_TYPE_DES) {
   6159                      psa_des_set_key_parity(data, bytes);
   6160                  }
   6161          #endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES) */
   6162              } else {
   6163                  return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_generate_derived_key_internal_8: (+1)
   \       0xBA   0xF07F 0x0085      MVNS     R0,#+133
   \       0xBE   0xE03B             B.N      ??psa_generate_derived_key_internal_1
   6164              }
   6165          
   6166              slot->attr.bits = (psa_key_bits_t) bits;
   \                     ??psa_generate_derived_key_internal_6: (+1)
   \       0xC0   0x9818             LDR      R0,[SP, #+96]
   \       0xC2   0x8078             STRH     R0,[R7, #+2]
   6167              attributes = (psa_key_attributes_t) {
   6168                  .core = slot->attr
   6169              };
   \       0xC4   0xA80E             ADD      R0,SP,#+56
   \       0xC6   0x2124             MOVS     R1,#+36
   \       0xC8   0x.... 0x....      BL       __aeabi_memclr4
   \       0xCC   0xA80E             ADD      R0,SP,#+56
   \       0xCE   0x0039             MOVS     R1,R7
   \       0xD0   0x221C             MOVS     R2,#+28
   \       0xD2   0x.... 0x....      BL       __aeabi_memcpy4
   \       0xD6   0xA805             ADD      R0,SP,#+20
   \       0xD8   0xA90E             ADD      R1,SP,#+56
   \       0xDA   0x2224             MOVS     R2,#+36
   \       0xDC   0x.... 0x....      BL       __aeabi_memcpy4
   6170          
   6171              if (psa_key_lifetime_is_external(attributes.core.lifetime)) {
   \       0xE0   0x9806             LDR      R0,[SP, #+24]
   \       0xE2   0x.... 0x....      BL       psa_key_lifetime_is_external
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD006             BEQ.N    ??psa_generate_derived_key_internal_11
   6172                  status = psa_driver_wrapper_get_key_buffer_size(&attributes,
   6173                                                                  &storage_size);
   \       0xEA   0xA904             ADD      R1,SP,#+16
   \       0xEC   0xA805             ADD      R0,SP,#+20
   \       0xEE   0x.... 0x....      BL       psa_driver_wrapper_get_key_buffer_size
   \       0xF2   0x0004             MOVS     R4,R0
   6174                  if (status != PSA_SUCCESS) {
   \       0xF4   0x2C00             CMP      R4,#+0
   \       0xF6   0xD11B             BNE.N    ??psa_generate_derived_key_internal_7
   6175                      goto exit;
   6176                  }
   6177              }
   6178              status = psa_allocate_buffer_to_slot(slot, storage_size);
   \                     ??psa_generate_derived_key_internal_11: (+1)
   \       0xF8   0x9904             LDR      R1,[SP, #+16]
   \       0xFA   0x0038             MOVS     R0,R7
   \       0xFC   0x.... 0x....      BL       psa_allocate_buffer_to_slot
   \      0x100   0x0004             MOVS     R4,R0
   6179              if (status != PSA_SUCCESS) {
   \      0x102   0x2C00             CMP      R4,#+0
   \      0x104   0xD114             BNE.N    ??psa_generate_derived_key_internal_7
   6180                  goto exit;
   6181              }
   6182          
   6183              status = psa_driver_wrapper_import_key(&attributes,
   6184                                                     data, bytes,
   6185                                                     slot->key.data,
   6186                                                     slot->key.bytes,
   6187                                                     &slot->key.bytes, &bits);
   \                     ??psa_generate_derived_key_internal_12: (+1)
   \      0x106   0xA818             ADD      R0,SP,#+96
   \      0x108   0x9002             STR      R0,[SP, #+8]
   \      0x10A   0xF117 0x0028      ADDS     R0,R7,#+40
   \      0x10E   0x9001             STR      R0,[SP, #+4]
   \      0x110   0x6AB8             LDR      R0,[R7, #+40]
   \      0x112   0x9000             STR      R0,[SP, #+0]
   \      0x114   0x6A7B             LDR      R3,[R7, #+36]
   \      0x116   0x0032             MOVS     R2,R6
   \      0x118   0x9903             LDR      R1,[SP, #+12]
   \      0x11A   0xA805             ADD      R0,SP,#+20
   \      0x11C   0x.... 0x....      BL       psa_driver_wrapper_import_key
   \      0x120   0x0004             MOVS     R4,R0
   6188              if (bits != slot->attr.bits) {
   \      0x122   0x9918             LDR      R1,[SP, #+96]
   \      0x124   0x8878             LDRH     R0,[R7, #+2]
   \      0x126   0x4281             CMP      R1,R0
   \      0x128   0xD002             BEQ.N    ??psa_generate_derived_key_internal_7
   6189                  status = PSA_ERROR_INVALID_ARGUMENT;
   \      0x12A   0xF07F 0x0086      MVNS     R0,#+134
   \      0x12E   0x0004             MOVS     R4,R0
   6190              }
   6191          
   6192          exit:
   6193              mbedtls_free(data);
   \                     ??psa_generate_derived_key_internal_7: (+1)
   \      0x130   0x9803             LDR      R0,[SP, #+12]
   \      0x132   0x.... 0x....      BL       sl_free
   6194              return status;
   \      0x136   0x0020             MOVS     R0,R4
   \                     ??psa_generate_derived_key_internal_1: (+1)
   \      0x138   0xB019             ADD      SP,SP,#+100
   \      0x13A   0xE8BD 0x83F0      POP      {R4-R9,PC}
   6195          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   6196          

   \                                 In section .text, align 2, keep-with-next
   6197          psa_status_t psa_key_derivation_output_key(const psa_key_attributes_t *attributes,
   6198                                                     psa_key_derivation_operation_t *operation,
   6199                                                     mbedtls_svc_key_id_t *key)
   6200          {
   \                     psa_key_derivation_output_key: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   6201              psa_status_t status;
   6202              psa_key_slot_t *slot = NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
   6203              psa_se_drv_table_entry_t *driver = NULL;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9001             STR      R0,[SP, #+4]
   6204          
   6205              *key = MBEDTLS_SVC_KEY_ID_INIT;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x6030             STR      R0,[R6, #+0]
   6206          
   6207              /* Reject any attempt to create a zero-length key so that we don't
   6208               * risk tripping up later, e.g. on a malloc(0) that returns NULL. */
   6209              if (psa_get_key_bits(attributes) > PSA_MAX_KEY_BITS) {
   \       0x14   0x0038             MOVS     R0,R7
   \       0x16   0x.... 0x....      BL       psa_get_key_bits
   \       0x1A   0xF64F 0x71F9      MOVW     R1,#+65529
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD302             BCC.N    ??psa_key_derivation_output_key_0
   6210                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x22   0xF07F 0x0085      MVNS     R0,#+133
   \       0x26   0xE042             B.N      ??psa_key_derivation_output_key_1
   6211              }
   6212              if (psa_get_key_bits(attributes) == 0 ||
   6213                  psa_get_key_bits(attributes) % 8 != 0) {
   \                     ??psa_key_derivation_output_key_0: (+1)
   \       0x28   0x0038             MOVS     R0,R7
   \       0x2A   0x.... 0x....      BL       psa_get_key_bits
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD005             BEQ.N    ??psa_key_derivation_output_key_2
   \       0x32   0x0038             MOVS     R0,R7
   \       0x34   0x.... 0x....      BL       psa_get_key_bits
   \       0x38   0xF010 0x0F07      TST      R0,#0x7
   \       0x3C   0xD002             BEQ.N    ??psa_key_derivation_output_key_3
   6214                  return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_key_derivation_output_key_2: (+1)
   \       0x3E   0xF07F 0x0086      MVNS     R0,#+134
   \       0x42   0xE034             B.N      ??psa_key_derivation_output_key_1
   6215              }
   6216              if (!key_type_is_raw_bytes(psa_get_key_type(attributes))) {
   \                     ??psa_key_derivation_output_key_3: (+1)
   \       0x44   0x0038             MOVS     R0,R7
   \       0x46   0x.... 0x....      BL       psa_get_key_type
   \       0x4A   0xB280             UXTH     R0,R0
   \       0x4C   0x.... 0x....      BL       key_type_is_raw_bytes
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD102             BNE.N    ??psa_key_derivation_output_key_4
   6217                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x54   0xF07F 0x0086      MVNS     R0,#+134
   \       0x58   0xE029             B.N      ??psa_key_derivation_output_key_1
   6218              }
   6219          
   6220              if (operation->alg == PSA_ALG_NONE) {
   \                     ??psa_key_derivation_output_key_4: (+1)
   \       0x5A   0x6828             LDR      R0,[R5, #+0]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD102             BNE.N    ??psa_key_derivation_output_key_5
   6221                  return PSA_ERROR_BAD_STATE;
   \       0x60   0xF07F 0x0088      MVNS     R0,#+136
   \       0x64   0xE023             B.N      ??psa_key_derivation_output_key_1
   6222              }
   6223          
   6224              if (!operation->can_output_key) {
   \                     ??psa_key_derivation_output_key_5: (+1)
   \       0x66   0x7928             LDRB     R0,[R5, #+4]
   \       0x68   0x07C0             LSLS     R0,R0,#+31
   \       0x6A   0xD402             BMI.N    ??psa_key_derivation_output_key_6
   6225                  return PSA_ERROR_NOT_PERMITTED;
   \       0x6C   0xF07F 0x0084      MVNS     R0,#+132
   \       0x70   0xE01D             B.N      ??psa_key_derivation_output_key_1
   6226              }
   6227          
   6228              status = psa_start_key_creation(PSA_KEY_CREATION_DERIVE, attributes,
   6229                                              &slot, &driver);
   \                     ??psa_key_derivation_output_key_6: (+1)
   \       0x72   0xAB01             ADD      R3,SP,#+4
   \       0x74   0x466A             MOV      R2,SP
   \       0x76   0x0039             MOVS     R1,R7
   \       0x78   0x2002             MOVS     R0,#+2
   \       0x7A   0x.... 0x....      BL       psa_start_key_creation
   \       0x7E   0x0004             MOVS     R4,R0
   6230          #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
   6231              if (driver != NULL) {
   6232                  /* Deriving a key in a secure element is not implemented yet. */
   6233                  status = PSA_ERROR_NOT_SUPPORTED;
   6234              }
   6235          #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
   6236              if (status == PSA_SUCCESS) {
   \       0x80   0x2C00             CMP      R4,#+0
   \       0x82   0xD105             BNE.N    ??psa_key_derivation_output_key_7
   6237                  status = psa_generate_derived_key_internal(slot,
   6238                                                             attributes->core.bits,
   6239                                                             operation);
   \       0x84   0x002A             MOVS     R2,R5
   \       0x86   0x8879             LDRH     R1,[R7, #+2]
   \       0x88   0x9800             LDR      R0,[SP, #+0]
   \       0x8A   0x.... 0x....      BL       psa_generate_derived_key_internal
   \       0x8E   0x0004             MOVS     R4,R0
   6240              }
   6241              if (status == PSA_SUCCESS) {
   \                     ??psa_key_derivation_output_key_7: (+1)
   \       0x90   0x2C00             CMP      R4,#+0
   \       0x92   0xD105             BNE.N    ??psa_key_derivation_output_key_8
   6242                  status = psa_finish_key_creation(slot, driver, key);
   \       0x94   0x0032             MOVS     R2,R6
   \       0x96   0x9901             LDR      R1,[SP, #+4]
   \       0x98   0x9800             LDR      R0,[SP, #+0]
   \       0x9A   0x.... 0x....      BL       psa_finish_key_creation
   \       0x9E   0x0004             MOVS     R4,R0
   6243              }
   6244              if (status != PSA_SUCCESS) {
   \                     ??psa_key_derivation_output_key_8: (+1)
   \       0xA0   0x2C00             CMP      R4,#+0
   \       0xA2   0xD003             BEQ.N    ??psa_key_derivation_output_key_9
   6245                  psa_fail_key_creation(slot, driver);
   \       0xA4   0x9901             LDR      R1,[SP, #+4]
   \       0xA6   0x9800             LDR      R0,[SP, #+0]
   \       0xA8   0x.... 0x....      BL       psa_fail_key_creation
   6246              }
   6247          
   6248              return status;
   \                     ??psa_key_derivation_output_key_9: (+1)
   \       0xAC   0x0020             MOVS     R0,R4
   \                     ??psa_key_derivation_output_key_1: (+1)
   \       0xAE   0xBDFE             POP      {R1-R7,PC}
   6249          }
   6250          
   6251          
   6252          
   6253          /****************************************************************/
   6254          /* Key derivation */
   6255          /****************************************************************/
   6256          
   6257          #if defined(AT_LEAST_ONE_BUILTIN_KDF)

   \                                 In section .text, align 2, keep-with-next
   6258          static int is_kdf_alg_supported(psa_algorithm_t kdf_alg)
   6259          {
   \                     is_kdf_alg_supported: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   6260          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF)
   6261              if (PSA_ALG_IS_HKDF(kdf_alg)) {
   6262                  return 1;
   6263              }
   6264          #endif
   6265          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT)
   6266              if (PSA_ALG_IS_HKDF_EXTRACT(kdf_alg)) {
   6267                  return 1;
   6268              }
   6269          #endif
   6270          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND)
   6271              if (PSA_ALG_IS_HKDF_EXPAND(kdf_alg)) {
   6272                  return 1;
   6273              }
   6274          #endif
   6275          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF)
   6276              if (PSA_ALG_IS_TLS12_PRF(kdf_alg)) {
   \        0x2   0x0A0A             LSRS     R2,R1,#+8
   \        0x4   0x0212             LSLS     R2,R2,#+8
   \        0x6   0x....             LDR.N    R0,??DataTable44_13
   \        0x8   0x4282             CMP      R2,R0
   \        0xA   0xD101             BNE.N    ??is_kdf_alg_supported_0
   6277                  return 1;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE000             B.N      ??is_kdf_alg_supported_1
   6278              }
   6279          #endif
   6280          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)
   6281              if (PSA_ALG_IS_TLS12_PSK_TO_MS(kdf_alg)) {
   6282                  return 1;
   6283              }
   6284          #endif
   6285          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS)
   6286              if (kdf_alg == PSA_ALG_TLS12_ECJPAKE_TO_PMS) {
   6287                  return 1;
   6288              }
   6289          #endif
   6290          #if defined(MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_HMAC)
   6291              if (PSA_ALG_IS_PBKDF2_HMAC(kdf_alg)) {
   6292                  return 1;
   6293              }
   6294          #endif
   6295          #if defined(MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_AES_CMAC_PRF_128)
   6296              if (kdf_alg == PSA_ALG_PBKDF2_AES_CMAC_PRF_128) {
   6297                  return 1;
   6298              }
   6299          #endif
   6300              return 0;
   \                     ??is_kdf_alg_supported_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??is_kdf_alg_supported_1: (+1)
   \       0x12   0x4770             BX       LR
   6301          }
   6302          

   \                                 In section .text, align 2, keep-with-next
   6303          static psa_status_t psa_hash_try_support(psa_algorithm_t alg)
   6304          {
   \                     psa_hash_try_support: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB0B8             SUB      SP,SP,#+224
   \        0x4   0x0004             MOVS     R4,R0
   6305              psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x21E0             MOVS     R1,#+224
   \        0xA   0x.... 0x....      BL       __aeabi_memclr4
   6306              psa_status_t status = psa_hash_setup(&operation, alg);
   \        0xE   0x0021             MOVS     R1,R4
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x.... 0x....      BL       psa_hash_setup
   \       0x16   0x0005             MOVS     R5,R0
   6307              psa_hash_abort(&operation);
   \       0x18   0x4668             MOV      R0,SP
   \       0x1A   0x.... 0x....      BL       psa_hash_abort
   6308              return status;
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xB039             ADD      SP,SP,#+228
   \       0x22   0xBD30             POP      {R4,R5,PC}
   6309          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0
   \              0x0000'0000
   \        0x8                      DS8 216
   6310          

   \                                 In section .text, align 2, keep-with-next
   6311          static psa_status_t psa_key_derivation_setup_kdf(
   6312              psa_key_derivation_operation_t *operation,
   6313              psa_algorithm_t kdf_alg)
   6314          {
   \                     psa_key_derivation_setup_kdf: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   6315              /* Make sure that operation->ctx is properly zero-initialised. (Macro
   6316               * initialisers for this union leave some bytes unspecified.) */
   6317              memset(&operation->ctx, 0, sizeof(operation->ctx));
   \        0x8   0xF05F 0x085C      MOVS     R8,#+92
   \        0xC   0x2400             MOVS     R4,#+0
   \        0xE   0xF115 0x070C      ADDS     R7,R5,#+12
   \       0x12   0x0022             MOVS     R2,R4
   \       0x14   0x4641             MOV      R1,R8
   \       0x16   0x0038             MOVS     R0,R7
   \       0x18   0x.... 0x....      BL       __aeabi_memset
   6318          
   6319              /* Make sure that kdf_alg is a supported key derivation algorithm. */
   6320              if (!is_kdf_alg_supported(kdf_alg)) {
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0x.... 0x....      BL       is_kdf_alg_supported
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD102             BNE.N    ??psa_key_derivation_setup_kdf_0
   6321                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x26   0xF07F 0x0085      MVNS     R0,#+133
   \       0x2A   0xE0A9             B.N      ??psa_key_derivation_setup_kdf_1
   6322              }
   6323          
   6324              /* All currently supported key derivation algorithms (apart from
   6325               * ecjpake to pms and pbkdf2_aes_cmac_128) are based on a hash algorithm. */
   6326              psa_algorithm_t hash_alg = PSA_ALG_HKDF_GET_HASH(kdf_alg);
   \                     ??psa_key_derivation_setup_kdf_0: (+1)
   \       0x2C   0xF006 0x07FF      AND      R7,R6,#0xFF
   \       0x30   0xF057 0x7700      ORRS     R7,R7,#0x2000000
   6327              size_t hash_size = PSA_HASH_LENGTH(hash_alg);
   \       0x34   0xF007 0x00FF      AND      R0,R7,#0xFF
   \       0x38   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \       0x3C   0x....             LDR.N    R1,??DataTable44
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_2
   \       0x42   0x2410             MOVS     R4,#+16
   \       0x44   0xE06C             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_2: (+1)
   \       0x46   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0x4A   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x4E   0x....             LDR.N    R0,??DataTable44_1
   \       0x50   0x4281             CMP      R1,R0
   \       0x52   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_4
   \       0x54   0x2414             MOVS     R4,#+20
   \       0x56   0xE063             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_4: (+1)
   \       0x58   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0x5C   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x60   0x....             LDR.N    R0,??DataTable44_2
   \       0x62   0x4281             CMP      R1,R0
   \       0x64   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_5
   \       0x66   0x2414             MOVS     R4,#+20
   \       0x68   0xE05A             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_5: (+1)
   \       0x6A   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0x6E   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x72   0x....             LDR.N    R0,??DataTable44_3
   \       0x74   0x4281             CMP      R1,R0
   \       0x76   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_6
   \       0x78   0x241C             MOVS     R4,#+28
   \       0x7A   0xE051             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_6: (+1)
   \       0x7C   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0x80   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x84   0x....             LDR.N    R0,??DataTable44_4
   \       0x86   0x4281             CMP      R1,R0
   \       0x88   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_7
   \       0x8A   0x2420             MOVS     R4,#+32
   \       0x8C   0xE048             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_7: (+1)
   \       0x8E   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0x92   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x96   0x....             LDR.N    R0,??DataTable44_5
   \       0x98   0x4281             CMP      R1,R0
   \       0x9A   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_8
   \       0x9C   0x2430             MOVS     R4,#+48
   \       0x9E   0xE03F             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_8: (+1)
   \       0xA0   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xA4   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xA8   0x....             LDR.N    R0,??DataTable44_6
   \       0xAA   0x4281             CMP      R1,R0
   \       0xAC   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_9
   \       0xAE   0x2440             MOVS     R4,#+64
   \       0xB0   0xE036             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_9: (+1)
   \       0xB2   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xB6   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xBA   0x....             LDR.N    R0,??DataTable44_7
   \       0xBC   0x4281             CMP      R1,R0
   \       0xBE   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_10
   \       0xC0   0x241C             MOVS     R4,#+28
   \       0xC2   0xE02D             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_10: (+1)
   \       0xC4   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xC8   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xCC   0x....             LDR.N    R0,??DataTable44_8
   \       0xCE   0x4281             CMP      R1,R0
   \       0xD0   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_11
   \       0xD2   0x2420             MOVS     R4,#+32
   \       0xD4   0xE024             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_11: (+1)
   \       0xD6   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xDA   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xDE   0x....             LDR.N    R0,??DataTable44_9
   \       0xE0   0x4281             CMP      R1,R0
   \       0xE2   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_12
   \       0xE4   0x241C             MOVS     R4,#+28
   \       0xE6   0xE01B             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_12: (+1)
   \       0xE8   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xEC   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xF0   0x....             LDR.N    R0,??DataTable44_10
   \       0xF2   0x4281             CMP      R1,R0
   \       0xF4   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_13
   \       0xF6   0x2420             MOVS     R4,#+32
   \       0xF8   0xE012             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_13: (+1)
   \       0xFA   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xFE   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x102   0x....             LDR.N    R0,??DataTable44_11
   \      0x104   0x4281             CMP      R1,R0
   \      0x106   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_14
   \      0x108   0x2430             MOVS     R4,#+48
   \      0x10A   0xE009             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_14: (+1)
   \      0x10C   0xF007 0x01FF      AND      R1,R7,#0xFF
   \      0x110   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x114   0x....             LDR.N    R0,??DataTable44_12
   \      0x116   0x4281             CMP      R1,R0
   \      0x118   0xD101             BNE.N    ??psa_key_derivation_setup_kdf_15
   \      0x11A   0x2440             MOVS     R4,#+64
   \      0x11C   0xE000             B.N      ??psa_key_derivation_setup_kdf_3
   \                     ??psa_key_derivation_setup_kdf_15: (+1)
   \      0x11E   0x2400             MOVS     R4,#+0
   6328              if (kdf_alg == PSA_ALG_TLS12_ECJPAKE_TO_PMS) {
   \                     ??psa_key_derivation_setup_kdf_3: (+1)
   \      0x120   0x.... 0x....      LDR.W    R0,??DataTable53
   \      0x124   0x4286             CMP      R6,R0
   \      0x126   0xD102             BNE.N    ??psa_key_derivation_setup_kdf_16
   6329                  hash_size = PSA_HASH_LENGTH(PSA_ALG_SHA_256);
   \      0x128   0x2020             MOVS     R0,#+32
   \      0x12A   0x0004             MOVS     R4,R0
   \      0x12C   0xE010             B.N      ??psa_key_derivation_setup_kdf_17
   6330              } else if (kdf_alg == PSA_ALG_PBKDF2_AES_CMAC_PRF_128) {
   \                     ??psa_key_derivation_setup_kdf_16: (+1)
   \      0x12E   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \      0x132   0x4286             CMP      R6,R0
   \      0x134   0xD102             BNE.N    ??psa_key_derivation_setup_kdf_18
   6331                  hash_size = PSA_MAC_LENGTH(PSA_KEY_TYPE_AES, 128U, PSA_ALG_CMAC);
   \      0x136   0x2010             MOVS     R0,#+16
   \      0x138   0x0004             MOVS     R4,R0
   \      0x13A   0xE009             B.N      ??psa_key_derivation_setup_kdf_17
   6332              } else {
   6333                  if (hash_size == 0) {
   \                     ??psa_key_derivation_setup_kdf_18: (+1)
   \      0x13C   0x2C00             CMP      R4,#+0
   \      0x13E   0xD102             BNE.N    ??psa_key_derivation_setup_kdf_19
   6334                      return PSA_ERROR_NOT_SUPPORTED;
   \      0x140   0xF07F 0x0085      MVNS     R0,#+133
   \      0x144   0xE01C             B.N      ??psa_key_derivation_setup_kdf_1
   6335                  }
   6336          
   6337                  /* Make sure that hash_alg is a supported hash algorithm. Otherwise
   6338                   * we might fail later, which is somewhat unfriendly and potentially
   6339                   * risk-prone. */
   6340                  psa_status_t status = psa_hash_try_support(hash_alg);
   \                     ??psa_key_derivation_setup_kdf_19: (+1)
   \      0x146   0x0038             MOVS     R0,R7
   \      0x148   0x.... 0x....      BL       psa_hash_try_support
   6341                  if (status != PSA_SUCCESS) {
   \      0x14C   0x2800             CMP      R0,#+0
   \      0x14E   0xD117             BNE.N    ??psa_key_derivation_setup_kdf_1
   6342                      return status;
   6343                  }
   6344              }
   6345          
   6346              if ((PSA_ALG_IS_TLS12_PRF(kdf_alg) ||
   6347                   PSA_ALG_IS_TLS12_PSK_TO_MS(kdf_alg)) &&
   6348                  !(hash_alg == PSA_ALG_SHA_256 || hash_alg == PSA_ALG_SHA_384)) {
   \                     ??psa_key_derivation_setup_kdf_17: (+1)
   \      0x150   0x0A31             LSRS     R1,R6,#+8
   \      0x152   0x0209             LSLS     R1,R1,#+8
   \      0x154   0x....             LDR.N    R0,??DataTable44_13
   \      0x156   0x4281             CMP      R1,R0
   \      0x158   0xD004             BEQ.N    ??psa_key_derivation_setup_kdf_20
   \      0x15A   0x0A31             LSRS     R1,R6,#+8
   \      0x15C   0x0209             LSLS     R1,R1,#+8
   \      0x15E   0x....             LDR.N    R0,??DataTable44_14
   \      0x160   0x4281             CMP      R1,R0
   \      0x162   0xD108             BNE.N    ??psa_key_derivation_setup_kdf_21
   \                     ??psa_key_derivation_setup_kdf_20: (+1)
   \      0x164   0x....             LDR.N    R0,??DataTable44_4
   \      0x166   0x4287             CMP      R7,R0
   \      0x168   0xD005             BEQ.N    ??psa_key_derivation_setup_kdf_21
   \      0x16A   0x....             LDR.N    R0,??DataTable44_5
   \      0x16C   0x4287             CMP      R7,R0
   \      0x16E   0xD002             BEQ.N    ??psa_key_derivation_setup_kdf_21
   6349                  return PSA_ERROR_NOT_SUPPORTED;
   \      0x170   0xF07F 0x0085      MVNS     R0,#+133
   \      0x174   0xE004             B.N      ??psa_key_derivation_setup_kdf_1
   6350              }
   6351          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT) || \
   6352              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS)
   6353              if (PSA_ALG_IS_HKDF_EXTRACT(kdf_alg) ||
   6354                  (kdf_alg == PSA_ALG_TLS12_ECJPAKE_TO_PMS)) {
   6355                  operation->capacity = hash_size;
   6356              } else
   6357          #endif /* MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT ||
   6358                    MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS */
   6359              operation->capacity = 255 * hash_size;
   \                     ??psa_key_derivation_setup_kdf_21: (+1)
   \      0x176   0x20FF             MOVS     R0,#+255
   \      0x178   0xFB00 0xF004      MUL      R0,R0,R4
   \      0x17C   0x60A8             STR      R0,[R5, #+8]
   6360              return PSA_SUCCESS;
   \      0x17E   0x2000             MOVS     R0,#+0
   \                     ??psa_key_derivation_setup_kdf_1: (+1)
   \      0x180   0xE8BD 0x81F0      POP      {R4-R8,PC}
   6361          }
   6362          

   \                                 In section .text, align 2, keep-with-next
   6363          static psa_status_t psa_key_agreement_try_support(psa_algorithm_t alg)
   6364          {
   \                     psa_key_agreement_try_support: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   6365          #if defined(PSA_WANT_ALG_ECDH)
   6366              if (alg == PSA_ALG_ECDH) {
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable53_2
   \        0x6   0x4281             CMP      R1,R0
   \        0x8   0xD101             BNE.N    ??psa_key_agreement_try_support_0
   6367                  return PSA_SUCCESS;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE001             B.N      ??psa_key_agreement_try_support_1
   6368              }
   6369          #endif
   6370          #if defined(PSA_WANT_ALG_FFDH)
   6371              if (alg == PSA_ALG_FFDH) {
   6372                  return PSA_SUCCESS;
   6373              }
   6374          #endif
   6375              (void) alg;
   6376              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_key_agreement_try_support_0: (+1)
   \        0xE   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_key_agreement_try_support_1: (+1)
   \       0x12   0x4770             BX       LR
   6377          }
   6378          

   \                                 In section .text, align 2, keep-with-next
   6379          static int psa_key_derivation_allows_free_form_secret_input(
   6380              psa_algorithm_t kdf_alg)
   6381          {
   \                     psa_key_derivation_allows_free_form_secret_input: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   6382          #if defined(PSA_WANT_ALG_TLS12_ECJPAKE_TO_PMS)
   6383              if (kdf_alg == PSA_ALG_TLS12_ECJPAKE_TO_PMS) {
   6384                  return 0;
   6385              }
   6386          #endif
   6387              (void) kdf_alg;
   6388              return 1;
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x4770             BX       LR
   6389          }
   6390          #endif /* AT_LEAST_ONE_BUILTIN_KDF */
   6391          

   \                                 In section .text, align 2, keep-with-next
   6392          psa_status_t psa_key_derivation_setup(psa_key_derivation_operation_t *operation,
   6393                                                psa_algorithm_t alg)
   6394          {
   \                     psa_key_derivation_setup: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   6395              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x0796      MVNS     R7,#+150
   6396          
   6397              if (operation->alg != 0) {
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD002             BEQ.N    ??psa_key_derivation_setup_0
   6398                  return PSA_ERROR_BAD_STATE;
   \       0x12   0xF07F 0x0088      MVNS     R0,#+136
   \       0x16   0xE043             B.N      ??psa_key_derivation_setup_1
   6399              }
   6400          
   6401              if (PSA_ALG_IS_RAW_KEY_AGREEMENT(alg)) {
   \                     ??psa_key_derivation_setup_0: (+1)
   \       0x18   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \       0x1C   0xF1B0 0x6F10      CMP      R0,#+150994944
   \       0x20   0xD10A             BNE.N    ??psa_key_derivation_setup_2
   \       0x22   0x0030             MOVS     R0,R6
   \       0x24   0xF36F 0x4018      BFC      R0,#+16,#+9
   \       0x28   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \       0x2C   0xF1B0 0x6F00      CMP      R0,#+134217728
   \       0x30   0xD102             BNE.N    ??psa_key_derivation_setup_2
   6402                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x32   0xF07F 0x0086      MVNS     R0,#+134
   \       0x36   0xE033             B.N      ??psa_key_derivation_setup_1
   6403              } else if (PSA_ALG_IS_KEY_AGREEMENT(alg)) {
   \                     ??psa_key_derivation_setup_2: (+1)
   \       0x38   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \       0x3C   0xF1B0 0x6F10      CMP      R0,#+150994944
   \       0x40   0xD11F             BNE.N    ??psa_key_derivation_setup_3
   6404          #if defined(AT_LEAST_ONE_BUILTIN_KDF)
   6405                  psa_algorithm_t kdf_alg = PSA_ALG_KEY_AGREEMENT_GET_KDF(alg);
   \       0x42   0x46B1             MOV      R9,R6
   \       0x44   0xF36F 0x4918      BFC      R9,#+16,#+9
   \       0x48   0xF059 0x6900      ORRS     R9,R9,#0x8000000
   6406                  psa_algorithm_t ka_alg = PSA_ALG_KEY_AGREEMENT_GET_BASE(alg);
   \       0x4C   0xEA5F 0x4816      LSRS     R8,R6,#+16
   \       0x50   0xEA5F 0x4808      LSLS     R8,R8,#+16
   \       0x54   0xF058 0x6810      ORRS     R8,R8,#0x9000000
   6407                  status = psa_key_agreement_try_support(ka_alg);
   \       0x58   0x4640             MOV      R0,R8
   \       0x5A   0x.... 0x....      BL       psa_key_agreement_try_support
   \       0x5E   0x0004             MOVS     R4,R0
   6408                  if (status != PSA_SUCCESS) {
   \       0x60   0x2C00             CMP      R4,#+0
   \       0x62   0xD001             BEQ.N    ??psa_key_derivation_setup_4
   6409                      return status;
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0xE01B             B.N      ??psa_key_derivation_setup_1
   6410                  }
   6411                  if (!psa_key_derivation_allows_free_form_secret_input(kdf_alg)) {
   \                     ??psa_key_derivation_setup_4: (+1)
   \       0x68   0x4648             MOV      R0,R9
   \       0x6A   0x.... 0x....      BL       psa_key_derivation_allows_free_form_secret_input
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD102             BNE.N    ??psa_key_derivation_setup_5
   6412                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x72   0xF07F 0x0086      MVNS     R0,#+134
   \       0x76   0xE013             B.N      ??psa_key_derivation_setup_1
   6413                  }
   6414                  status = psa_key_derivation_setup_kdf(operation, kdf_alg);
   \                     ??psa_key_derivation_setup_5: (+1)
   \       0x78   0x4649             MOV      R1,R9
   \       0x7A   0x0028             MOVS     R0,R5
   \       0x7C   0x.... 0x....      BL       psa_key_derivation_setup_kdf
   \       0x80   0xE00B             B.N      ??psa_key_derivation_setup_6
   6415          #else
   6416                  status = PSA_ERROR_NOT_SUPPORTED;
   6417          #endif /* AT_LEAST_ONE_BUILTIN_KDF */
   6418              } else if (PSA_ALG_IS_KEY_DERIVATION(alg)) {
   \                     ??psa_key_derivation_setup_3: (+1)
   \       0x82   0xF016 0x40FE      ANDS     R0,R6,#0x7F000000
   \       0x86   0xF1B0 0x6F00      CMP      R0,#+134217728
   \       0x8A   0xD104             BNE.N    ??psa_key_derivation_setup_7
   6419          #if defined(AT_LEAST_ONE_BUILTIN_KDF)
   6420                  status = psa_key_derivation_setup_kdf(operation, alg);
   \       0x8C   0x0031             MOVS     R1,R6
   \       0x8E   0x0028             MOVS     R0,R5
   \       0x90   0x.... 0x....      BL       psa_key_derivation_setup_kdf
   \       0x94   0xE001             B.N      ??psa_key_derivation_setup_6
   6421          #else
   6422                  status = PSA_ERROR_NOT_SUPPORTED;
   6423          #endif /* AT_LEAST_ONE_BUILTIN_KDF */
   6424              } else {
   6425                  status = PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_key_derivation_setup_7: (+1)
   \       0x96   0xF07F 0x0086      MVNS     R0,#+134
   6426              }
   6427          
   6428              if (status == PSA_SUCCESS) {
   \                     ??psa_key_derivation_setup_6: (+1)
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD100             BNE.N    ??psa_key_derivation_setup_8
   6429                  operation->alg = alg;
   \       0x9E   0x602E             STR      R6,[R5, #+0]
   6430              }
   6431              return status;
   \                     ??psa_key_derivation_setup_8: (+1)
   \                     ??psa_key_derivation_setup_1: (+1)
   \       0xA0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   6432          }
   6433          
   6434          #if defined(BUILTIN_ALG_ANY_HKDF)
   6435          static psa_status_t psa_hkdf_input(psa_hkdf_key_derivation_t *hkdf,
   6436                                             psa_algorithm_t kdf_alg,
   6437                                             psa_key_derivation_step_t step,
   6438                                             const uint8_t *data,
   6439                                             size_t data_length)
   6440          {
   6441              psa_algorithm_t hash_alg = PSA_ALG_HKDF_GET_HASH(kdf_alg);
   6442              psa_status_t status;
   6443              switch (step) {
   6444                  case PSA_KEY_DERIVATION_INPUT_SALT:
   6445          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND)
   6446                      if (PSA_ALG_IS_HKDF_EXPAND(kdf_alg)) {
   6447                          return PSA_ERROR_INVALID_ARGUMENT;
   6448                      }
   6449          #endif /* MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND */
   6450                      if (hkdf->state != HKDF_STATE_INIT) {
   6451                          return PSA_ERROR_BAD_STATE;
   6452                      } else {
   6453                          status = psa_key_derivation_start_hmac(&hkdf->hmac,
   6454                                                                 hash_alg,
   6455                                                                 data, data_length);
   6456                          if (status != PSA_SUCCESS) {
   6457                              return status;
   6458                          }
   6459                          hkdf->state = HKDF_STATE_STARTED;
   6460                          return PSA_SUCCESS;
   6461                      }
   6462                  case PSA_KEY_DERIVATION_INPUT_SECRET:
   6463          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND)
   6464                      if (PSA_ALG_IS_HKDF_EXPAND(kdf_alg)) {
   6465                          /* We shouldn't be in different state as HKDF_EXPAND only allows
   6466                           * two inputs: SECRET (this case) and INFO which does not modify
   6467                           * the state. It could happen only if the hkdf
   6468                           * object was corrupted. */
   6469                          if (hkdf->state != HKDF_STATE_INIT) {
   6470                              return PSA_ERROR_BAD_STATE;
   6471                          }
   6472          
   6473                          /* Allow only input that fits expected prk size */
   6474                          if (data_length != PSA_HASH_LENGTH(hash_alg)) {
   6475                              return PSA_ERROR_INVALID_ARGUMENT;
   6476                          }
   6477          
   6478                          memcpy(hkdf->prk, data, data_length);
   6479                      } else
   6480          #endif /* MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND */
   6481                      {
   6482                          /* HKDF: If no salt was provided, use an empty salt.
   6483                           * HKDF-EXTRACT: salt is mandatory. */
   6484                          if (hkdf->state == HKDF_STATE_INIT) {
   6485          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT)
   6486                              if (PSA_ALG_IS_HKDF_EXTRACT(kdf_alg)) {
   6487                                  return PSA_ERROR_BAD_STATE;
   6488                              }
   6489          #endif /* MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT */
   6490                              status = psa_key_derivation_start_hmac(&hkdf->hmac,
   6491                                                                     hash_alg,
   6492                                                                     NULL, 0);
   6493                              if (status != PSA_SUCCESS) {
   6494                                  return status;
   6495                              }
   6496                              hkdf->state = HKDF_STATE_STARTED;
   6497                          }
   6498                          if (hkdf->state != HKDF_STATE_STARTED) {
   6499                              return PSA_ERROR_BAD_STATE;
   6500                          }
   6501                          status = psa_mac_update(&hkdf->hmac,
   6502                                                  data, data_length);
   6503                          if (status != PSA_SUCCESS) {
   6504                              return status;
   6505                          }
   6506                          status = psa_mac_sign_finish(&hkdf->hmac,
   6507                                                       hkdf->prk,
   6508                                                       sizeof(hkdf->prk),
   6509                                                       &data_length);
   6510                          if (status != PSA_SUCCESS) {
   6511                              return status;
   6512                          }
   6513                      }
   6514          
   6515                      hkdf->state = HKDF_STATE_KEYED;
   6516                      hkdf->block_number = 0;
   6517          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT)
   6518                      if (PSA_ALG_IS_HKDF_EXTRACT(kdf_alg)) {
   6519                          /* The only block of output is the PRK. */
   6520                          memcpy(hkdf->output_block, hkdf->prk, PSA_HASH_LENGTH(hash_alg));
   6521                          hkdf->offset_in_block = 0;
   6522                      } else
   6523          #endif /* MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT */
   6524                      {
   6525                          /* Block 0 is empty, and the next block will be
   6526                           * generated by psa_key_derivation_hkdf_read(). */
   6527                          hkdf->offset_in_block = PSA_HASH_LENGTH(hash_alg);
   6528                      }
   6529          
   6530                      return PSA_SUCCESS;
   6531                  case PSA_KEY_DERIVATION_INPUT_INFO:
   6532          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT)
   6533                      if (PSA_ALG_IS_HKDF_EXTRACT(kdf_alg)) {
   6534                          return PSA_ERROR_INVALID_ARGUMENT;
   6535                      }
   6536          #endif /* MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT */
   6537          #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND)
   6538                      if (PSA_ALG_IS_HKDF_EXPAND(kdf_alg) &&
   6539                          hkdf->state == HKDF_STATE_INIT) {
   6540                          return PSA_ERROR_BAD_STATE;
   6541                      }
   6542          #endif /* MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT */
   6543                      if (hkdf->state == HKDF_STATE_OUTPUT) {
   6544                          return PSA_ERROR_BAD_STATE;
   6545                      }
   6546                      if (hkdf->info_set) {
   6547                          return PSA_ERROR_BAD_STATE;
   6548                      }
   6549                      hkdf->info_length = data_length;
   6550                      if (data_length != 0) {
   6551                          hkdf->info = mbedtls_calloc(1, data_length);
   6552                          if (hkdf->info == NULL) {
   6553                              return PSA_ERROR_INSUFFICIENT_MEMORY;
   6554                          }
   6555                          memcpy(hkdf->info, data, data_length);
   6556                      }
   6557                      hkdf->info_set = 1;
   6558                      return PSA_SUCCESS;
   6559                  default:
   6560                      return PSA_ERROR_INVALID_ARGUMENT;
   6561              }
   6562          }
   6563          #endif /* BUILTIN_ALG_ANY_HKDF */
   6564          
   6565          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF) || \
   6566              defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)

   \                                 In section .text, align 2, keep-with-next
   6567          static psa_status_t psa_tls12_prf_set_seed(psa_tls12_prf_key_derivation_t *prf,
   6568                                                     const uint8_t *data,
   6569                                                     size_t data_length)
   6570          {
   \                     psa_tls12_prf_set_seed: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   6571              if (prf->state != PSA_TLS12_PRF_STATE_INIT) {
   \        0xA   0x78A8             LDRB     R0,[R5, #+2]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD002             BEQ.N    ??psa_tls12_prf_set_seed_0
   6572                  return PSA_ERROR_BAD_STATE;
   \       0x10   0xF07F 0x0088      MVNS     R0,#+136
   \       0x14   0xE019             B.N      ??psa_tls12_prf_set_seed_1
   6573              }
   6574          
   6575              if (data_length != 0) {
   \                     ??psa_tls12_prf_set_seed_0: (+1)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD014             BEQ.N    ??psa_tls12_prf_set_seed_2
   6576                  prf->seed = mbedtls_calloc(1, data_length);
   \       0x1A   0x0021             MOVS     R1,R4
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x.... 0x....      BL       sl_calloc
   \       0x22   0x60E8             STR      R0,[R5, #+12]
   6577                  if (prf->seed == NULL) {
   \       0x24   0x68E8             LDR      R0,[R5, #+12]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE.N    ??psa_tls12_prf_set_seed_3
   6578                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x2A   0xF07F 0x008C      MVNS     R0,#+140
   \       0x2E   0xE00C             B.N      ??psa_tls12_prf_set_seed_1
   6579                  }
   6580          
   6581                  memcpy(prf->seed, data, data_length);
   \                     ??psa_tls12_prf_set_seed_3: (+1)
   \       0x30   0x46A1             MOV      R9,R4
   \       0x32   0x0037             MOVS     R7,R6
   \       0x34   0xF8D5 0x800C      LDR      R8,[R5, #+12]
   \       0x38   0x464A             MOV      R2,R9
   \       0x3A   0x0039             MOVS     R1,R7
   \       0x3C   0x4640             MOV      R0,R8
   \       0x3E   0x.... 0x....      BL       __aeabi_memcpy
   6582                  prf->seed_length = data_length;
   \       0x42   0x612C             STR      R4,[R5, #+16]
   6583              }
   6584          
   6585              prf->state = PSA_TLS12_PRF_STATE_SEED_SET;
   \                     ??psa_tls12_prf_set_seed_2: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x70A8             STRB     R0,[R5, #+2]
   6586          
   6587              return PSA_SUCCESS;
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??psa_tls12_prf_set_seed_1: (+1)
   \       0x4A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   6588          }
   6589          

   \                                 In section .text, align 2, keep-with-next
   6590          static psa_status_t psa_tls12_prf_set_key(psa_tls12_prf_key_derivation_t *prf,
   6591                                                    const uint8_t *data,
   6592                                                    size_t data_length)
   6593          {
   \                     psa_tls12_prf_set_key: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   6594              if (prf->state != PSA_TLS12_PRF_STATE_SEED_SET &&
   6595                  prf->state != PSA_TLS12_PRF_STATE_OTHER_KEY_SET) {
   \        0xA   0x78A8             LDRB     R0,[R5, #+2]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD005             BEQ.N    ??psa_tls12_prf_set_key_0
   \       0x10   0x78A8             LDRB     R0,[R5, #+2]
   \       0x12   0x2802             CMP      R0,#+2
   \       0x14   0xD002             BEQ.N    ??psa_tls12_prf_set_key_0
   6596                  return PSA_ERROR_BAD_STATE;
   \       0x16   0xF07F 0x0088      MVNS     R0,#+136
   \       0x1A   0xE019             B.N      ??psa_tls12_prf_set_key_1
   6597              }
   6598          
   6599              if (data_length != 0) {
   \                     ??psa_tls12_prf_set_key_0: (+1)
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD014             BEQ.N    ??psa_tls12_prf_set_key_2
   6600                  prf->secret = mbedtls_calloc(1, data_length);
   \       0x20   0x0021             MOVS     R1,R4
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x.... 0x....      BL       sl_calloc
   \       0x28   0x6068             STR      R0,[R5, #+4]
   6601                  if (prf->secret == NULL) {
   \       0x2A   0x6868             LDR      R0,[R5, #+4]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD102             BNE.N    ??psa_tls12_prf_set_key_3
   6602                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x30   0xF07F 0x008C      MVNS     R0,#+140
   \       0x34   0xE00C             B.N      ??psa_tls12_prf_set_key_1
   6603                  }
   6604          
   6605                  memcpy(prf->secret, data, data_length);
   \                     ??psa_tls12_prf_set_key_3: (+1)
   \       0x36   0x46A1             MOV      R9,R4
   \       0x38   0x0037             MOVS     R7,R6
   \       0x3A   0xF8D5 0x8004      LDR      R8,[R5, #+4]
   \       0x3E   0x464A             MOV      R2,R9
   \       0x40   0x0039             MOVS     R1,R7
   \       0x42   0x4640             MOV      R0,R8
   \       0x44   0x.... 0x....      BL       __aeabi_memcpy
   6606                  prf->secret_length = data_length;
   \       0x48   0x60AC             STR      R4,[R5, #+8]
   6607              }
   6608          
   6609              prf->state = PSA_TLS12_PRF_STATE_KEY_SET;
   \                     ??psa_tls12_prf_set_key_2: (+1)
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0x70A8             STRB     R0,[R5, #+2]
   6610          
   6611              return PSA_SUCCESS;
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??psa_tls12_prf_set_key_1: (+1)
   \       0x50   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   6612          }
   6613          

   \                                 In section .text, align 2, keep-with-next
   6614          static psa_status_t psa_tls12_prf_set_label(psa_tls12_prf_key_derivation_t *prf,
   6615                                                      const uint8_t *data,
   6616                                                      size_t data_length)
   6617          {
   \                     psa_tls12_prf_set_label: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   6618              if (prf->state != PSA_TLS12_PRF_STATE_KEY_SET) {
   \        0xA   0x78A8             LDRB     R0,[R5, #+2]
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD002             BEQ.N    ??psa_tls12_prf_set_label_0
   6619                  return PSA_ERROR_BAD_STATE;
   \       0x10   0xF07F 0x0088      MVNS     R0,#+136
   \       0x14   0xE019             B.N      ??psa_tls12_prf_set_label_1
   6620              }
   6621          
   6622              if (data_length != 0) {
   \                     ??psa_tls12_prf_set_label_0: (+1)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD014             BEQ.N    ??psa_tls12_prf_set_label_2
   6623                  prf->label = mbedtls_calloc(1, data_length);
   \       0x1A   0x0021             MOVS     R1,R4
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x.... 0x....      BL       sl_calloc
   \       0x22   0x6168             STR      R0,[R5, #+20]
   6624                  if (prf->label == NULL) {
   \       0x24   0x6968             LDR      R0,[R5, #+20]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE.N    ??psa_tls12_prf_set_label_3
   6625                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x2A   0xF07F 0x008C      MVNS     R0,#+140
   \       0x2E   0xE00C             B.N      ??psa_tls12_prf_set_label_1
   6626                  }
   6627          
   6628                  memcpy(prf->label, data, data_length);
   \                     ??psa_tls12_prf_set_label_3: (+1)
   \       0x30   0x46A1             MOV      R9,R4
   \       0x32   0x0037             MOVS     R7,R6
   \       0x34   0xF8D5 0x8014      LDR      R8,[R5, #+20]
   \       0x38   0x464A             MOV      R2,R9
   \       0x3A   0x0039             MOVS     R1,R7
   \       0x3C   0x4640             MOV      R0,R8
   \       0x3E   0x.... 0x....      BL       __aeabi_memcpy
   6629                  prf->label_length = data_length;
   \       0x42   0x61AC             STR      R4,[R5, #+24]
   6630              }
   6631          
   6632              prf->state = PSA_TLS12_PRF_STATE_LABEL_SET;
   \                     ??psa_tls12_prf_set_label_2: (+1)
   \       0x44   0x2004             MOVS     R0,#+4
   \       0x46   0x70A8             STRB     R0,[R5, #+2]
   6633          
   6634              return PSA_SUCCESS;
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??psa_tls12_prf_set_label_1: (+1)
   \       0x4A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   6635          }
   6636          

   \                                 In section .text, align 2, keep-with-next
   6637          static psa_status_t psa_tls12_prf_input(psa_tls12_prf_key_derivation_t *prf,
   6638                                                  psa_key_derivation_step_t step,
   6639                                                  const uint8_t *data,
   6640                                                  size_t data_length)
   6641          {
   \                     psa_tls12_prf_input: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   6642              switch (step) {
   \        0xA   0x0029             MOVS     R1,R5
   \        0xC   0xB289             UXTH     R1,R1
   \        0xE   0xF240 0x1001      MOVW     R0,#+257
   \       0x12   0x1A09             SUBS     R1,R1,R0
   \       0x14   0xD00B             BEQ.N    ??psa_tls12_prf_input_0
   \       0x16   0xF44F 0x7080      MOV      R0,#+256
   \       0x1A   0x1A09             SUBS     R1,R1,R0
   \       0x1C   0xD00D             BEQ.N    ??psa_tls12_prf_input_1
   \       0x1E   0x1EC9             SUBS     R1,R1,#+3
   \       0x20   0xD111             BNE.N    ??psa_tls12_prf_input_2
   6643                  case PSA_KEY_DERIVATION_INPUT_SEED:
   6644                      return psa_tls12_prf_set_seed(prf, data, data_length);
   \                     ??psa_tls12_prf_input_3: (+1)
   \       0x22   0x003A             MOVS     R2,R7
   \       0x24   0x0031             MOVS     R1,R6
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       psa_tls12_prf_set_seed
   \       0x2C   0xE00D             B.N      ??psa_tls12_prf_input_4
   6645                  case PSA_KEY_DERIVATION_INPUT_SECRET:
   6646                      return psa_tls12_prf_set_key(prf, data, data_length);
   \                     ??psa_tls12_prf_input_0: (+1)
   \       0x2E   0x003A             MOVS     R2,R7
   \       0x30   0x0031             MOVS     R1,R6
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       psa_tls12_prf_set_key
   \       0x38   0xE007             B.N      ??psa_tls12_prf_input_4
   6647                  case PSA_KEY_DERIVATION_INPUT_LABEL:
   6648                      return psa_tls12_prf_set_label(prf, data, data_length);
   \                     ??psa_tls12_prf_input_1: (+1)
   \       0x3A   0x003A             MOVS     R2,R7
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       psa_tls12_prf_set_label
   \       0x44   0xE001             B.N      ??psa_tls12_prf_input_4
   6649                  default:
   6650                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_tls12_prf_input_2: (+1)
   \       0x46   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_tls12_prf_input_4: (+1)
   \       0x4A   0xBDF2             POP      {R1,R4-R7,PC}
   6651              }
   6652          }
   6653          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF) ||
   6654                  * MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS */
   6655          
   6656          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)
   6657          static psa_status_t psa_tls12_prf_psk_to_ms_set_key(
   6658              psa_tls12_prf_key_derivation_t *prf,
   6659              const uint8_t *data,
   6660              size_t data_length)
   6661          {
   6662              psa_status_t status;
   6663              const size_t pms_len = (prf->state == PSA_TLS12_PRF_STATE_OTHER_KEY_SET ?
   6664                                      4 + data_length + prf->other_secret_length :
   6665                                      4 + 2 * data_length);
   6666          
   6667              if (data_length > PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE) {
   6668                  return PSA_ERROR_INVALID_ARGUMENT;
   6669              }
   6670          
   6671              uint8_t *pms = mbedtls_calloc(1, pms_len);
   6672              if (pms == NULL) {
   6673                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   6674              }
   6675              uint8_t *cur = pms;
   6676          
   6677              /* pure-PSK:
   6678               * Quoting RFC 4279, Section 2:
   6679               *
   6680               * The premaster secret is formed as follows: if the PSK is N octets
   6681               * long, concatenate a uint16 with the value N, N zero octets, a second
   6682               * uint16 with the value N, and the PSK itself.
   6683               *
   6684               * mixed-PSK:
   6685               * In a DHE-PSK, RSA-PSK, ECDHE-PSK the premaster secret is formed as
   6686               * follows: concatenate a uint16 with the length of the other secret,
   6687               * the other secret itself, uint16 with the length of PSK, and the
   6688               * PSK itself.
   6689               * For details please check:
   6690               * - RFC 4279, Section 4 for the definition of RSA-PSK,
   6691               * - RFC 4279, Section 3 for the definition of DHE-PSK,
   6692               * - RFC 5489 for the definition of ECDHE-PSK.
   6693               */
   6694          
   6695              if (prf->state == PSA_TLS12_PRF_STATE_OTHER_KEY_SET) {
   6696                  *cur++ = MBEDTLS_BYTE_1(prf->other_secret_length);
   6697                  *cur++ = MBEDTLS_BYTE_0(prf->other_secret_length);
   6698                  if (prf->other_secret_length != 0) {
   6699                      memcpy(cur, prf->other_secret, prf->other_secret_length);
   6700                      mbedtls_platform_zeroize(prf->other_secret, prf->other_secret_length);
   6701                      cur += prf->other_secret_length;
   6702                  }
   6703              } else {
   6704                  *cur++ = MBEDTLS_BYTE_1(data_length);
   6705                  *cur++ = MBEDTLS_BYTE_0(data_length);
   6706                  memset(cur, 0, data_length);
   6707                  cur += data_length;
   6708              }
   6709          
   6710              *cur++ = MBEDTLS_BYTE_1(data_length);
   6711              *cur++ = MBEDTLS_BYTE_0(data_length);
   6712              memcpy(cur, data, data_length);
   6713              cur += data_length;
   6714          
   6715              status = psa_tls12_prf_set_key(prf, pms, cur - pms);
   6716          
   6717              mbedtls_zeroize_and_free(pms, pms_len);
   6718              return status;
   6719          }
   6720          
   6721          static psa_status_t psa_tls12_prf_psk_to_ms_set_other_key(
   6722              psa_tls12_prf_key_derivation_t *prf,
   6723              const uint8_t *data,
   6724              size_t data_length)
   6725          {
   6726              if (prf->state != PSA_TLS12_PRF_STATE_SEED_SET) {
   6727                  return PSA_ERROR_BAD_STATE;
   6728              }
   6729          
   6730              if (data_length != 0) {
   6731                  prf->other_secret = mbedtls_calloc(1, data_length);
   6732                  if (prf->other_secret == NULL) {
   6733                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   6734                  }
   6735          
   6736                  memcpy(prf->other_secret, data, data_length);
   6737                  prf->other_secret_length = data_length;
   6738              } else {
   6739                  prf->other_secret_length = 0;
   6740              }
   6741          
   6742              prf->state = PSA_TLS12_PRF_STATE_OTHER_KEY_SET;
   6743          
   6744              return PSA_SUCCESS;
   6745          }
   6746          
   6747          static psa_status_t psa_tls12_prf_psk_to_ms_input(
   6748              psa_tls12_prf_key_derivation_t *prf,
   6749              psa_key_derivation_step_t step,
   6750              const uint8_t *data,
   6751              size_t data_length)
   6752          {
   6753              switch (step) {
   6754                  case PSA_KEY_DERIVATION_INPUT_SECRET:
   6755                      return psa_tls12_prf_psk_to_ms_set_key(prf,
   6756                                                             data, data_length);
   6757                      break;
   6758                  case PSA_KEY_DERIVATION_INPUT_OTHER_SECRET:
   6759                      return psa_tls12_prf_psk_to_ms_set_other_key(prf,
   6760                                                                   data,
   6761                                                                   data_length);
   6762                      break;
   6763                  default:
   6764                      return psa_tls12_prf_input(prf, step, data, data_length);
   6765                      break;
   6766          
   6767              }
   6768          }
   6769          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS */
   6770          
   6771          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS)
   6772          static psa_status_t psa_tls12_ecjpake_to_pms_input(
   6773              psa_tls12_ecjpake_to_pms_t *ecjpake,
   6774              psa_key_derivation_step_t step,
   6775              const uint8_t *data,
   6776              size_t data_length)
   6777          {
   6778              if (data_length != PSA_TLS12_ECJPAKE_TO_PMS_INPUT_SIZE ||
   6779                  step != PSA_KEY_DERIVATION_INPUT_SECRET) {
   6780                  return PSA_ERROR_INVALID_ARGUMENT;
   6781              }
   6782          
   6783              /* Check if the passed point is in an uncompressed form */
   6784              if (data[0] != 0x04) {
   6785                  return PSA_ERROR_INVALID_ARGUMENT;
   6786              }
   6787          
   6788              /* Only K.X has to be extracted - bytes 1 to 32 inclusive. */
   6789              memcpy(ecjpake->data, data + 1, PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE);
   6790          
   6791              return PSA_SUCCESS;
   6792          }
   6793          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS */
   6794          
   6795          #if defined(PSA_HAVE_SOFT_PBKDF2)
   6796          static psa_status_t psa_pbkdf2_set_input_cost(
   6797              psa_pbkdf2_key_derivation_t *pbkdf2,
   6798              psa_key_derivation_step_t step,
   6799              uint64_t data)
   6800          {
   6801              if (step != PSA_KEY_DERIVATION_INPUT_COST) {
   6802                  return PSA_ERROR_INVALID_ARGUMENT;
   6803              }
   6804          
   6805              if (pbkdf2->state != PSA_PBKDF2_STATE_INIT) {
   6806                  return PSA_ERROR_BAD_STATE;
   6807              }
   6808          
   6809              if (data > PSA_VENDOR_PBKDF2_MAX_ITERATIONS) {
   6810                  return PSA_ERROR_NOT_SUPPORTED;
   6811              }
   6812          
   6813              if (data == 0) {
   6814                  return PSA_ERROR_INVALID_ARGUMENT;
   6815              }
   6816          
   6817              pbkdf2->input_cost = data;
   6818              pbkdf2->state = PSA_PBKDF2_STATE_INPUT_COST_SET;
   6819          
   6820              return PSA_SUCCESS;
   6821          }
   6822          
   6823          static psa_status_t psa_pbkdf2_set_salt(psa_pbkdf2_key_derivation_t *pbkdf2,
   6824                                                  const uint8_t *data,
   6825                                                  size_t data_length)
   6826          {
   6827              if (pbkdf2->state == PSA_PBKDF2_STATE_INPUT_COST_SET) {
   6828                  pbkdf2->state = PSA_PBKDF2_STATE_SALT_SET;
   6829              } else if (pbkdf2->state == PSA_PBKDF2_STATE_SALT_SET) {
   6830                  /* Appending to existing salt. No state change. */
   6831              } else {
   6832                  return PSA_ERROR_BAD_STATE;
   6833              }
   6834          
   6835              if (data_length == 0) {
   6836                  /* Appending an empty string, nothing to do. */
   6837              } else {
   6838                  uint8_t *next_salt;
   6839          
   6840                  next_salt = mbedtls_calloc(1, data_length + pbkdf2->salt_length);
   6841                  if (next_salt == NULL) {
   6842                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   6843                  }
   6844          
   6845                  if (pbkdf2->salt_length != 0) {
   6846                      memcpy(next_salt, pbkdf2->salt, pbkdf2->salt_length);
   6847                  }
   6848                  memcpy(next_salt + pbkdf2->salt_length, data, data_length);
   6849                  pbkdf2->salt_length += data_length;
   6850                  mbedtls_free(pbkdf2->salt);
   6851                  pbkdf2->salt = next_salt;
   6852              }
   6853              return PSA_SUCCESS;
   6854          }
   6855          
   6856          #if defined(MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_HMAC)
   6857          static psa_status_t psa_pbkdf2_hmac_set_password(psa_algorithm_t hash_alg,
   6858                                                           const uint8_t *input,
   6859                                                           size_t input_len,
   6860                                                           uint8_t *output,
   6861                                                           size_t *output_len)
   6862          {
   6863              psa_status_t status = PSA_SUCCESS;
   6864              if (input_len > PSA_HASH_BLOCK_LENGTH(hash_alg)) {
   6865                  status = psa_hash_compute(hash_alg, input, input_len, output,
   6866                                            PSA_HMAC_MAX_HASH_BLOCK_SIZE, output_len);
   6867              } else {
   6868                  memcpy(output, input, input_len);
   6869                  *output_len = PSA_HASH_BLOCK_LENGTH(hash_alg);
   6870              }
   6871              return status;
   6872          }
   6873          #endif /* MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_HMAC */
   6874          
   6875          #if defined(MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_AES_CMAC_PRF_128)
   6876          static psa_status_t psa_pbkdf2_cmac_set_password(const uint8_t *input,
   6877                                                           size_t input_len,
   6878                                                           uint8_t *output,
   6879                                                           size_t *output_len)
   6880          {
   6881              psa_status_t status = PSA_SUCCESS;
   6882              if (input_len != PSA_MAC_LENGTH(PSA_KEY_TYPE_AES, 128U, PSA_ALG_CMAC)) {
   6883                  psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   6884                  uint8_t zeros[16] = { 0 };
   6885                  psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
   6886                  psa_set_key_bits(&attributes, PSA_BYTES_TO_BITS(sizeof(zeros)));
   6887                  psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_MESSAGE);
   6888                  /* Passing PSA_MAC_LENGTH(PSA_KEY_TYPE_AES, 128U, PSA_ALG_CMAC) as
   6889                   * mac_size as the driver function sets mac_output_length = mac_size
   6890                   * on success. See https://github.com/Mbed-TLS/mbedtls/issues/7801 */
   6891                  status = psa_driver_wrapper_mac_compute(&attributes,
   6892                                                          zeros, sizeof(zeros),
   6893                                                          PSA_ALG_CMAC, input, input_len,
   6894                                                          output,
   6895                                                          PSA_MAC_LENGTH(PSA_KEY_TYPE_AES,
   6896                                                                         128U,
   6897                                                                         PSA_ALG_CMAC),
   6898                                                          output_len);
   6899              } else {
   6900                  memcpy(output, input, input_len);
   6901                  *output_len = PSA_MAC_LENGTH(PSA_KEY_TYPE_AES, 128U, PSA_ALG_CMAC);
   6902              }
   6903              return status;
   6904          }
   6905          #endif /* MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_AES_CMAC_PRF_128 */
   6906          
   6907          static psa_status_t psa_pbkdf2_set_password(psa_pbkdf2_key_derivation_t *pbkdf2,
   6908                                                      psa_algorithm_t kdf_alg,
   6909                                                      const uint8_t *data,
   6910                                                      size_t data_length)
   6911          {
   6912              psa_status_t status = PSA_SUCCESS;
   6913              if (pbkdf2->state != PSA_PBKDF2_STATE_SALT_SET) {
   6914                  return PSA_ERROR_BAD_STATE;
   6915              }
   6916          
   6917          #if defined(MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_HMAC)
   6918              if (PSA_ALG_IS_PBKDF2_HMAC(kdf_alg)) {
   6919                  psa_algorithm_t hash_alg = PSA_ALG_PBKDF2_HMAC_GET_HASH(kdf_alg);
   6920                  status = psa_pbkdf2_hmac_set_password(hash_alg, data, data_length,
   6921                                                        pbkdf2->password,
   6922                                                        &pbkdf2->password_length);
   6923              } else
   6924          #endif /* MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_HMAC */
   6925          #if defined(MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_AES_CMAC_PRF_128)
   6926              if (kdf_alg == PSA_ALG_PBKDF2_AES_CMAC_PRF_128) {
   6927                  status = psa_pbkdf2_cmac_set_password(data, data_length,
   6928                                                        pbkdf2->password,
   6929                                                        &pbkdf2->password_length);
   6930              } else
   6931          #endif /* MBEDTLS_PSA_BUILTIN_ALG_PBKDF2_AES_CMAC_PRF_128 */
   6932              {
   6933                  return PSA_ERROR_INVALID_ARGUMENT;
   6934              }
   6935          
   6936              pbkdf2->state = PSA_PBKDF2_STATE_PASSWORD_SET;
   6937          
   6938              return status;
   6939          }
   6940          
   6941          static psa_status_t psa_pbkdf2_input(psa_pbkdf2_key_derivation_t *pbkdf2,
   6942                                               psa_algorithm_t kdf_alg,
   6943                                               psa_key_derivation_step_t step,
   6944                                               const uint8_t *data,
   6945                                               size_t data_length)
   6946          {
   6947              switch (step) {
   6948                  case PSA_KEY_DERIVATION_INPUT_SALT:
   6949                      return psa_pbkdf2_set_salt(pbkdf2, data, data_length);
   6950                  case PSA_KEY_DERIVATION_INPUT_PASSWORD:
   6951                      return psa_pbkdf2_set_password(pbkdf2, kdf_alg, data, data_length);
   6952                  default:
   6953                      return PSA_ERROR_INVALID_ARGUMENT;
   6954              }
   6955          }
   6956          #endif /* PSA_HAVE_SOFT_PBKDF2 */
   6957          
   6958          /** Check whether the given key type is acceptable for the given
   6959           * input step of a key derivation.
   6960           *
   6961           * Secret inputs must have the type #PSA_KEY_TYPE_DERIVE.
   6962           * Non-secret inputs must have the type #PSA_KEY_TYPE_RAW_DATA.
   6963           * Both secret and non-secret inputs can alternatively have the type
   6964           * #PSA_KEY_TYPE_NONE, which is never the type of a key object, meaning
   6965           * that the input was passed as a buffer rather than via a key object.
   6966           */

   \                                 In section .text, align 2, keep-with-next
   6967          static int psa_key_derivation_check_input_type(
   6968              psa_key_derivation_step_t step,
   6969              psa_key_type_t key_type)
   6970          {
   \                     psa_key_derivation_check_input_type: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   6971              switch (step) {
   \        0x2   0x0013             MOVS     R3,R2
   \        0x4   0xB29B             UXTH     R3,R3
   \        0x6   0xF240 0x1001      MOVW     R0,#+257
   \        0xA   0x1A1B             SUBS     R3,R3,R0
   \        0xC   0xD007             BEQ.N    ??psa_key_derivation_check_input_type_0
   \        0xE   0x1E5B             SUBS     R3,R3,#+1
   \       0x10   0xD030             BEQ.N    ??psa_key_derivation_check_input_type_1
   \       0x12   0x1E5B             SUBS     R3,R3,#+1
   \       0x14   0xD011             BEQ.N    ??psa_key_derivation_check_input_type_2
   \       0x16   0x3BFE             SUBS     R3,R3,#+254
   \       0x18   0x2B03             CMP      R3,#+3
   \       0x1A   0xD91C             BLS.N    ??psa_key_derivation_check_input_type_3
   \       0x1C   0xE03F             B.N      ??psa_key_derivation_check_input_type_4
   6972                  case PSA_KEY_DERIVATION_INPUT_SECRET:
   6973                      if (key_type == PSA_KEY_TYPE_DERIVE) {
   \                     ??psa_key_derivation_check_input_type_0: (+1)
   \       0x1E   0x0008             MOVS     R0,R1
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0xF5B0 0x5F90      CMP      R0,#+4608
   \       0x26   0xD101             BNE.N    ??psa_key_derivation_check_input_type_5
   6974                          return PSA_SUCCESS;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE03A             B.N      ??psa_key_derivation_check_input_type_6
   6975                      }
   6976                      if (key_type == PSA_KEY_TYPE_NONE) {
   \                     ??psa_key_derivation_check_input_type_5: (+1)
   \       0x2C   0x0008             MOVS     R0,R1
   \       0x2E   0xB280             UXTH     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD101             BNE.N    ??psa_key_derivation_check_input_type_7
   6977                          return PSA_SUCCESS;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xE034             B.N      ??psa_key_derivation_check_input_type_6
   6978                      }
   6979                      break;
   \                     ??psa_key_derivation_check_input_type_7: (+1)
   \       0x38   0xE031             B.N      ??psa_key_derivation_check_input_type_4
   6980                  case PSA_KEY_DERIVATION_INPUT_OTHER_SECRET:
   6981                      if (key_type == PSA_KEY_TYPE_DERIVE) {
   \                     ??psa_key_derivation_check_input_type_2: (+1)
   \       0x3A   0x0008             MOVS     R0,R1
   \       0x3C   0xB280             UXTH     R0,R0
   \       0x3E   0xF5B0 0x5F90      CMP      R0,#+4608
   \       0x42   0xD101             BNE.N    ??psa_key_derivation_check_input_type_8
   6982                          return PSA_SUCCESS;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xE02C             B.N      ??psa_key_derivation_check_input_type_6
   6983                      }
   6984                      if (key_type == PSA_KEY_TYPE_NONE) {
   \                     ??psa_key_derivation_check_input_type_8: (+1)
   \       0x48   0x0008             MOVS     R0,R1
   \       0x4A   0xB280             UXTH     R0,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD101             BNE.N    ??psa_key_derivation_check_input_type_9
   6985                          return PSA_SUCCESS;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE026             B.N      ??psa_key_derivation_check_input_type_6
   6986                      }
   6987                      break;
   \                     ??psa_key_derivation_check_input_type_9: (+1)
   \       0x54   0xE023             B.N      ??psa_key_derivation_check_input_type_4
   6988                  case PSA_KEY_DERIVATION_INPUT_LABEL:
   6989                  case PSA_KEY_DERIVATION_INPUT_SALT:
   6990                  case PSA_KEY_DERIVATION_INPUT_INFO:
   6991                  case PSA_KEY_DERIVATION_INPUT_SEED:
   6992                      if (key_type == PSA_KEY_TYPE_RAW_DATA) {
   \                     ??psa_key_derivation_check_input_type_3: (+1)
   \       0x56   0x000B             MOVS     R3,R1
   \       0x58   0xF241 0x0001      MOVW     R0,#+4097
   \       0x5C   0xB29B             UXTH     R3,R3
   \       0x5E   0x4283             CMP      R3,R0
   \       0x60   0xD101             BNE.N    ??psa_key_derivation_check_input_type_10
   6993                          return PSA_SUCCESS;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xE01D             B.N      ??psa_key_derivation_check_input_type_6
   6994                      }
   6995                      if (key_type == PSA_KEY_TYPE_NONE) {
   \                     ??psa_key_derivation_check_input_type_10: (+1)
   \       0x66   0x0008             MOVS     R0,R1
   \       0x68   0xB280             UXTH     R0,R0
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD101             BNE.N    ??psa_key_derivation_check_input_type_11
   6996                          return PSA_SUCCESS;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xE017             B.N      ??psa_key_derivation_check_input_type_6
   6997                      }
   6998                      break;
   \                     ??psa_key_derivation_check_input_type_11: (+1)
   \       0x72   0xE014             B.N      ??psa_key_derivation_check_input_type_4
   6999                  case PSA_KEY_DERIVATION_INPUT_PASSWORD:
   7000                      if (key_type == PSA_KEY_TYPE_PASSWORD) {
   \                     ??psa_key_derivation_check_input_type_1: (+1)
   \       0x74   0x000B             MOVS     R3,R1
   \       0x76   0xF241 0x2003      MOVW     R0,#+4611
   \       0x7A   0xB29B             UXTH     R3,R3
   \       0x7C   0x4283             CMP      R3,R0
   \       0x7E   0xD101             BNE.N    ??psa_key_derivation_check_input_type_12
   7001                          return PSA_SUCCESS;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xE00E             B.N      ??psa_key_derivation_check_input_type_6
   7002                      }
   7003                      if (key_type == PSA_KEY_TYPE_DERIVE) {
   \                     ??psa_key_derivation_check_input_type_12: (+1)
   \       0x84   0x0008             MOVS     R0,R1
   \       0x86   0xB280             UXTH     R0,R0
   \       0x88   0xF5B0 0x5F90      CMP      R0,#+4608
   \       0x8C   0xD101             BNE.N    ??psa_key_derivation_check_input_type_13
   7004                          return PSA_SUCCESS;
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xE007             B.N      ??psa_key_derivation_check_input_type_6
   7005                      }
   7006                      if (key_type == PSA_KEY_TYPE_NONE) {
   \                     ??psa_key_derivation_check_input_type_13: (+1)
   \       0x92   0x0008             MOVS     R0,R1
   \       0x94   0xB280             UXTH     R0,R0
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD101             BNE.N    ??psa_key_derivation_check_input_type_14
   7007                          return PSA_SUCCESS;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xE001             B.N      ??psa_key_derivation_check_input_type_6
   7008                      }
   7009                      break;
   7010              }
   7011              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_key_derivation_check_input_type_14: (+1)
   \                     ??psa_key_derivation_check_input_type_4: (+1)
   \       0x9E   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??psa_key_derivation_check_input_type_6: (+1)
   \       0xA2   0x4770             BX       LR
   7012          }
   7013          

   \                                 In section .text, align 2, keep-with-next
   7014          static psa_status_t psa_key_derivation_input_internal(
   7015              psa_key_derivation_operation_t *operation,
   7016              psa_key_derivation_step_t step,
   7017              psa_key_type_t key_type,
   7018              const uint8_t *data,
   7019              size_t data_length)
   7020          {
   \                     psa_key_derivation_input_internal: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   7021              psa_status_t status;
   7022              psa_algorithm_t kdf_alg = psa_key_derivation_get_kdf_alg(operation);
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       psa_key_derivation_get_kdf_alg
   \       0x16   0x4682             MOV      R10,R0
   7023          
   7024              status = psa_key_derivation_check_input_type(step, key_type);
   \       0x18   0x0039             MOVS     R1,R7
   \       0x1A   0xB289             UXTH     R1,R1
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x.... 0x....      BL       psa_key_derivation_check_input_type
   \       0x24   0x0004             MOVS     R4,R0
   7025              if (status != PSA_SUCCESS) {
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD113             BNE.N    ??psa_key_derivation_input_internal_0
   7026                  goto exit;
   7027              }
   7028          
   7029          #if defined(BUILTIN_ALG_ANY_HKDF)
   7030              if (PSA_ALG_IS_ANY_HKDF(kdf_alg)) {
   7031                  status = psa_hkdf_input(&operation->ctx.hkdf, kdf_alg,
   7032                                          step, data, data_length);
   7033              } else
   7034          #endif /* BUILTIN_ALG_ANY_HKDF */
   7035          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF)
   7036              if (PSA_ALG_IS_TLS12_PRF(kdf_alg)) {
   \                     ??psa_key_derivation_input_internal_1: (+1)
   \       0x2A   0xEA5F 0x211A      LSRS     R1,R10,#+8
   \       0x2E   0x0209             LSLS     R1,R1,#+8
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable53_3
   \       0x34   0x4281             CMP      R1,R0
   \       0x36   0xD109             BNE.N    ??psa_key_derivation_input_internal_2
   7037                  status = psa_tls12_prf_input(&operation->ctx.tls12_prf,
   7038                                               step, data, data_length);
   \       0x38   0x464B             MOV      R3,R9
   \       0x3A   0x4642             MOV      R2,R8
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0xB289             UXTH     R1,R1
   \       0x40   0xF115 0x000C      ADDS     R0,R5,#+12
   \       0x44   0x.... 0x....      BL       psa_tls12_prf_input
   \       0x48   0x0004             MOVS     R4,R0
   \       0x4A   0xE002             B.N      ??psa_key_derivation_input_internal_0
   7039              } else
   7040          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF */
   7041          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)
   7042              if (PSA_ALG_IS_TLS12_PSK_TO_MS(kdf_alg)) {
   7043                  status = psa_tls12_prf_psk_to_ms_input(&operation->ctx.tls12_prf,
   7044                                                         step, data, data_length);
   7045              } else
   7046          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS */
   7047          #if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS)
   7048              if (kdf_alg == PSA_ALG_TLS12_ECJPAKE_TO_PMS) {
   7049                  status = psa_tls12_ecjpake_to_pms_input(
   7050                      &operation->ctx.tls12_ecjpake_to_pms, step, data, data_length);
   7051              } else
   7052          #endif /* MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS */
   7053          #if defined(PSA_HAVE_SOFT_PBKDF2)
   7054              if (PSA_ALG_IS_PBKDF2(kdf_alg)) {
   7055                  status = psa_pbkdf2_input(&operation->ctx.pbkdf2, kdf_alg,
   7056                                            step, data, data_length);
   7057              } else
   7058          #endif /* PSA_HAVE_SOFT_PBKDF2 */
   7059              {
   7060                  /* This can't happen unless the operation object was not initialized */
   7061                  (void) data;
   7062                  (void) data_length;
   7063                  (void) kdf_alg;
   7064                  return PSA_ERROR_BAD_STATE;
   \                     ??psa_key_derivation_input_internal_2: (+1)
   \       0x4C   0xF07F 0x0088      MVNS     R0,#+136
   \       0x50   0xE005             B.N      ??psa_key_derivation_input_internal_3
   7065              }
   7066          
   7067          exit:
   7068              if (status != PSA_SUCCESS) {
   \                     ??psa_key_derivation_input_internal_0: (+1)
   \       0x52   0x2C00             CMP      R4,#+0
   \       0x54   0xD002             BEQ.N    ??psa_key_derivation_input_internal_4
   7069                  psa_key_derivation_abort(operation);
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0x.... 0x....      BL       psa_key_derivation_abort
   7070              }
   7071              return status;
   \                     ??psa_key_derivation_input_internal_4: (+1)
   \       0x5C   0x0020             MOVS     R0,R4
   \                     ??psa_key_derivation_input_internal_3: (+1)
   \       0x5E   0xE8BD 0x87F0      POP      {R4-R10,PC}
   7072          }
   7073          

   \                                 In section .text, align 2, keep-with-next
   7074          static psa_status_t psa_key_derivation_input_integer_internal(
   7075              psa_key_derivation_operation_t *operation,
   7076              psa_key_derivation_step_t step,
   7077              uint64_t value)
   7078          {
   \                     psa_key_derivation_input_integer_internal: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
   7079              psa_status_t status;
   7080              psa_algorithm_t kdf_alg = psa_key_derivation_get_kdf_alg(operation);
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0x.... 0x....      BL       psa_key_derivation_get_kdf_alg
   \       0x12   0x4681             MOV      R9,R0
   7081          
   7082          #if defined(PSA_HAVE_SOFT_PBKDF2)
   7083              if (PSA_ALG_IS_PBKDF2(kdf_alg)) {
   7084                  status = psa_pbkdf2_set_input_cost(
   7085                      &operation->ctx.pbkdf2, step, value);
   7086              } else
   7087          #endif /* PSA_HAVE_SOFT_PBKDF2 */
   7088              {
   7089                  (void) step;
   7090                  (void) value;
   7091                  (void) kdf_alg;
   7092                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x14   0xF07F 0x0686      MVNS     R6,#+134
   7093              }
   7094          
   7095              if (status != PSA_SUCCESS) {
   \       0x18   0x2E00             CMP      R6,#+0
   \       0x1A   0xD002             BEQ.N    ??psa_key_derivation_input_integer_internal_0
   7096                  psa_key_derivation_abort(operation);
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0x.... 0x....      BL       psa_key_derivation_abort
   7097              }
   7098              return status;
   \                     ??psa_key_derivation_input_integer_internal_0: (+1)
   \       0x22   0x0030             MOVS     R0,R6
   \       0x24   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   7099          }
   7100          

   \                                 In section .text, align 2, keep-with-next
   7101          psa_status_t psa_key_derivation_input_bytes(
   7102              psa_key_derivation_operation_t *operation,
   7103              psa_key_derivation_step_t step,
   7104              const uint8_t *data,
   7105              size_t data_length)
   7106          {
   \                     psa_key_derivation_input_bytes: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001E             MOVS     R6,R3
   7107              return psa_key_derivation_input_internal(operation, step,
   7108                                                       PSA_KEY_TYPE_NONE,
   7109                                                       data, data_length);
   \        0xA   0x9600             STR      R6,[SP, #+0]
   \        0xC   0x002B             MOVS     R3,R5
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x0021             MOVS     R1,R4
   \       0x12   0xB289             UXTH     R1,R1
   \       0x14   0x0038             MOVS     R0,R7
   \       0x16   0x.... 0x....      BL       psa_key_derivation_input_internal
   \       0x1A   0xBDF2             POP      {R1,R4-R7,PC}
   7110          }
   7111          

   \                                 In section .text, align 2, keep-with-next
   7112          psa_status_t psa_key_derivation_input_integer(
   7113              psa_key_derivation_operation_t *operation,
   7114              psa_key_derivation_step_t step,
   7115              uint64_t value)
   7116          {
   \                     psa_key_derivation_input_integer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   \        0x8   0x001D             MOVS     R5,R3
   7117              return psa_key_derivation_input_integer_internal(operation, step, value);
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x002B             MOVS     R3,R5
   \        0xE   0x0031             MOVS     R1,R6
   \       0x10   0xB289             UXTH     R1,R1
   \       0x12   0x0038             MOVS     R0,R7
   \       0x14   0x.... 0x....      BL       psa_key_derivation_input_integer_internal
   \       0x18   0xBDF2             POP      {R1,R4-R7,PC}
   7118          }
   7119          

   \                                 In section .text, align 2, keep-with-next
   7120          psa_status_t psa_key_derivation_input_key(
   7121              psa_key_derivation_operation_t *operation,
   7122              psa_key_derivation_step_t step,
   7123              mbedtls_svc_key_id_t key)
   7124          {
   \                     psa_key_derivation_input_key: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   7125              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0996      MVNS     R9,#+150
   \        0xE   0x464D             MOV      R5,R9
   7126              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   7127              psa_key_slot_t *slot;
   7128          
   7129              status = psa_get_and_lock_transparent_key_slot_with_policy(
   7130                  key, &slot, PSA_KEY_USAGE_DERIVE, operation->alg);
   \       0x10   0x6833             LDR      R3,[R6, #+0]
   \       0x12   0xF44F 0x4280      MOV      R2,#+16384
   \       0x16   0xA901             ADD      R1,SP,#+4
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0x.... 0x....      BL       psa_get_and_lock_transparent_key_slot_with_policy
   \       0x1E   0x0004             MOVS     R4,R0
   7131              if (status != PSA_SUCCESS) {
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD004             BEQ.N    ??psa_key_derivation_input_key_0
   7132                  psa_key_derivation_abort(operation);
   \       0x24   0x0030             MOVS     R0,R6
   \       0x26   0x.... 0x....      BL       psa_key_derivation_abort
   7133                  return status;
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0xE023             B.N      ??psa_key_derivation_input_key_1
   7134              }
   7135          
   7136              /* Passing a key object as a SECRET or PASSWORD input unlocks the
   7137               * permission to output to a key object. */
   7138              if (step == PSA_KEY_DERIVATION_INPUT_SECRET ||
   7139                  step == PSA_KEY_DERIVATION_INPUT_PASSWORD) {
   \                     ??psa_key_derivation_input_key_0: (+1)
   \       0x2E   0x0039             MOVS     R1,R7
   \       0x30   0xF240 0x1001      MOVW     R0,#+257
   \       0x34   0xB289             UXTH     R1,R1
   \       0x36   0x4281             CMP      R1,R0
   \       0x38   0xD004             BEQ.N    ??psa_key_derivation_input_key_2
   \       0x3A   0x0038             MOVS     R0,R7
   \       0x3C   0xB280             UXTH     R0,R0
   \       0x3E   0xF5B0 0x7F81      CMP      R0,#+258
   \       0x42   0xD103             BNE.N    ??psa_key_derivation_input_key_3
   7140                  operation->can_output_key = 1;
   \                     ??psa_key_derivation_input_key_2: (+1)
   \       0x44   0x6870             LDR      R0,[R6, #+4]
   \       0x46   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x4A   0x6070             STR      R0,[R6, #+4]
   7141              }
   7142          
   7143              status = psa_key_derivation_input_internal(operation,
   7144                                                         step, slot->attr.type,
   7145                                                         slot->key.data,
   7146                                                         slot->key.bytes);
   \                     ??psa_key_derivation_input_key_3: (+1)
   \       0x4C   0x9801             LDR      R0,[SP, #+4]
   \       0x4E   0x6A80             LDR      R0,[R0, #+40]
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x9801             LDR      R0,[SP, #+4]
   \       0x54   0x6A43             LDR      R3,[R0, #+36]
   \       0x56   0x9801             LDR      R0,[SP, #+4]
   \       0x58   0x8802             LDRH     R2,[R0, #+0]
   \       0x5A   0x0039             MOVS     R1,R7
   \       0x5C   0xB289             UXTH     R1,R1
   \       0x5E   0x0030             MOVS     R0,R6
   \       0x60   0x.... 0x....      BL       psa_key_derivation_input_internal
   \       0x64   0x0005             MOVS     R5,R0
   7147          
   7148              unlock_status = psa_unlock_key_slot(slot);
   \       0x66   0x9801             LDR      R0,[SP, #+4]
   \       0x68   0x.... 0x....      BL       psa_unlock_key_slot
   7149          
   7150              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0x6C   0x2D00             CMP      R5,#+0
   \       0x6E   0xD101             BNE.N    ??psa_key_derivation_input_key_4
   \       0x70   0x0005             MOVS     R5,R0
   \       0x72   0xE7FF             B.N      ??psa_key_derivation_input_key_5
   \                     ??psa_key_derivation_input_key_4: (+1)
   \                     ??psa_key_derivation_input_key_5: (+1)
   \       0x74   0x0028             MOVS     R0,R5
   \                     ??psa_key_derivation_input_key_1: (+1)
   \       0x76   0xE8BD 0x83FE      POP      {R1-R9,PC}
   7151          }
   7152          
   7153          #if defined(MBEDTLS_PSA_CRYPTO_DRIVERS)
   7154          
   7155          #include "sli_psa_driver_features.h"
   7156          
   7157          psa_status_t sli_se_driver_single_shot_hkdf(
   7158              psa_algorithm_t alg,
   7159              const psa_key_attributes_t *key_in_attributes,
   7160              const uint8_t *key_in_buffer,
   7161              size_t key_in_buffer_size,
   7162              const uint8_t* info,
   7163              size_t info_length,
   7164              const uint8_t* salt,
   7165              size_t salt_length,
   7166              const psa_key_attributes_t *key_out_attributes,
   7167              uint8_t *key_out_buffer,
   7168              size_t key_out_buffer_size);
   7169          
   7170          psa_status_t sli_se_driver_single_shot_pbkdf2(
   7171            psa_algorithm_t alg,
   7172            const psa_key_attributes_t *key_in_attributes,
   7173            const uint8_t *key_in_buffer,
   7174            size_t key_in_buffer_size,
   7175            const uint8_t* salt,
   7176            size_t salt_length,
   7177            const psa_key_attributes_t *key_out_attributes,
   7178            uint32_t iterations,
   7179            uint8_t *key_out_buffer,
   7180            size_t key_out_buffer_size);
   7181          
   7182          #if defined(SLI_MBEDTLS_DEVICE_VSE) && defined(SLI_PSA_DRIVER_FEATURE_OPAQUE_KEYS)
   7183          psa_status_t sli_cryptoacc_driver_single_shot_pbkdf2(
   7184            psa_algorithm_t alg,
   7185            const psa_key_attributes_t *key_in_attributes,
   7186            const uint8_t *key_in_buffer,
   7187            size_t key_in_buffer_size,
   7188            const uint8_t* salt,
   7189            size_t salt_length,
   7190            const psa_key_attributes_t *key_out_attributes,
   7191            uint32_t iterations,
   7192            uint8_t *key_out_buffer,
   7193            size_t key_out_buffer_size);
   7194          #endif
   7195          #endif /* MBEDTLS_PSA_CRYPTO_DRIVERS */
   7196          

   \                                 In section .text, align 2, keep-with-next
   7197          psa_status_t sl_psa_key_derivation_single_shot(
   7198              psa_algorithm_t alg,
   7199              mbedtls_svc_key_id_t key_in,
   7200              const uint8_t *info,
   7201              size_t info_length,
   7202              const uint8_t *salt,
   7203              size_t salt_length,
   7204              size_t iterations,
   7205              const psa_key_attributes_t *key_out_attributes,
   7206              mbedtls_svc_key_id_t *key_out )
   7207          {
   \                     sl_psa_key_derivation_single_shot: (+1)
   \        0x0   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x469A             MOV      R10,R3
   \        0xC   0x9E1B             LDR      R6,[SP, #+108]
   \        0xE   0x9F1C             LDR      R7,[SP, #+112]
   7208              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x10   0xF07F 0x0896      MVNS     R8,#+150
   \       0x14   0x4644             MOV      R4,R8
   7209              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   7210              psa_key_slot_t *input_key_slot = NULL;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x9002             STR      R0,[SP, #+8]
   7211              psa_key_slot_t *output_key_slot = NULL;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   7212              psa_se_drv_table_entry_t *driver = NULL;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x9001             STR      R0,[SP, #+4]
   7213              *key_out = MBEDTLS_SVC_KEY_ID_INIT;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x6038             STR      R0,[R7, #+0]
   7214              size_t storage_size = 0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x9003             STR      R0,[SP, #+12]
   7215          
   7216              /* Reject any attempt to create a zero-length key so that we don't
   7217               * risk tripping up later, e.g. on a malloc(0) that returns NULL. */
   7218              if( psa_get_key_bits( key_out_attributes ) == 0 )
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0x.... 0x....      BL       psa_get_key_bits
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD102             BNE.N    ??sl_psa_key_derivation_single_shot_0
   7219                  return( PSA_ERROR_INVALID_ARGUMENT );
   \       0x34   0xF07F 0x0086      MVNS     R0,#+134
   \       0x38   0xE061             B.N      ??sl_psa_key_derivation_single_shot_1
   7220          
   7221              status = psa_get_and_lock_key_slot_with_policy(
   7222                           key_in, &input_key_slot, PSA_KEY_USAGE_DERIVE, alg );
   \                     ??sl_psa_key_derivation_single_shot_0: (+1)
   \       0x3A   0x464B             MOV      R3,R9
   \       0x3C   0xF44F 0x4280      MOV      R2,#+16384
   \       0x40   0xA902             ADD      R1,SP,#+8
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x48   0x4683             MOV      R11,R0
   7223              if( status != PSA_SUCCESS )
   \       0x4A   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x4E   0xD001             BEQ.N    ??sl_psa_key_derivation_single_shot_2
   7224                  return( status );
   \       0x50   0x4658             MOV      R0,R11
   \       0x52   0xE054             B.N      ??sl_psa_key_derivation_single_shot_1
   7225          
   7226              status = psa_start_key_creation( PSA_KEY_CREATION_DERIVE, key_out_attributes,
   7227                                               &output_key_slot, &driver );
   \                     ??sl_psa_key_derivation_single_shot_2: (+1)
   \       0x54   0xAB01             ADD      R3,SP,#+4
   \       0x56   0x466A             MOV      R2,SP
   \       0x58   0x0031             MOVS     R1,R6
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0x.... 0x....      BL       psa_start_key_creation
   \       0x60   0x0004             MOVS     R4,R0
   7228              if( status != PSA_SUCCESS )
   \       0x62   0x2C00             CMP      R4,#+0
   \       0x64   0xD137             BNE.N    ??sl_psa_key_derivation_single_shot_3
   7229                  goto exit;
   7230          
   7231              status = psa_driver_wrapper_get_key_buffer_size( key_out_attributes, &storage_size );
   \                     ??sl_psa_key_derivation_single_shot_4: (+1)
   \       0x66   0xA903             ADD      R1,SP,#+12
   \       0x68   0x0030             MOVS     R0,R6
   \       0x6A   0x.... 0x....      BL       psa_driver_wrapper_get_key_buffer_size
   \       0x6E   0x0004             MOVS     R4,R0
   7232              if( status != PSA_SUCCESS )
   \       0x70   0x2C00             CMP      R4,#+0
   \       0x72   0xD130             BNE.N    ??sl_psa_key_derivation_single_shot_3
   7233                  goto exit;
   7234          
   7235              /* In the case of a transparent key or an opaque key stored in local
   7236               * storage (thus not in the case of generating a key in a secure element
   7237               * or cryptoprocessor with storage), we have to allocate a buffer to
   7238               * hold the generated key material. */
   7239              if( output_key_slot->key.data == NULL )
   \                     ??sl_psa_key_derivation_single_shot_5: (+1)
   \       0x74   0x9800             LDR      R0,[SP, #+0]
   \       0x76   0x6A40             LDR      R0,[R0, #+36]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD106             BNE.N    ??sl_psa_key_derivation_single_shot_6
   7240              {
   7241                  status = psa_allocate_buffer_to_slot( output_key_slot, storage_size );
   \       0x7C   0x9903             LDR      R1,[SP, #+12]
   \       0x7E   0x9800             LDR      R0,[SP, #+0]
   \       0x80   0x.... 0x....      BL       psa_allocate_buffer_to_slot
   \       0x84   0x0004             MOVS     R4,R0
   7242                  if( status != PSA_SUCCESS )
   \       0x86   0x2C00             CMP      R4,#+0
   \       0x88   0xD125             BNE.N    ??sl_psa_key_derivation_single_shot_3
   7243                      goto exit;
   7244              }
   7245          
   7246              {
   7247                  psa_key_attributes_t key_in_attributes = {
   7248                    .core = input_key_slot->attr
   7249                  };
   \                     ??sl_psa_key_derivation_single_shot_6: (+1)
   \       0x8A   0xA804             ADD      R0,SP,#+16
   \       0x8C   0x2124             MOVS     R1,#+36
   \       0x8E   0x.... 0x....      BL       __aeabi_memclr4
   \       0x92   0xA804             ADD      R0,SP,#+16
   \       0x94   0x9902             LDR      R1,[SP, #+8]
   \       0x96   0x221C             MOVS     R2,#+28
   \       0x98   0x.... 0x....      BL       __aeabi_memcpy4
   7250          
   7251                  /* Call the appropriate driver. Since this function is used exclusively with
   7252                   * the SE as an accelerator, we can skip the wrapper layer and call the
   7253                   * driver functions directly. */
   7254                  if (PSA_ALG_IS_HKDF(alg))
   \       0x9C   0xEA5F 0x2119      LSRS     R1,R9,#+8
   \       0xA0   0x0209             LSLS     R1,R1,#+8
   \       0xA2   0x.... 0x....      LDR.W    R0,??DataTable53_4
   \       0xA6   0x4281             CMP      R1,R0
   \       0xA8   0xD103             BNE.N    ??sl_psa_key_derivation_single_shot_7
   7255          #if defined(SLI_PSA_DRIVER_FEATURE_HKDF)
   7256                  {
   7257                      status = sli_se_driver_single_shot_hkdf(
   7258                          alg, &key_in_attributes, input_key_slot->key.data,
   7259                          input_key_slot->key.bytes, info, info_length, salt, salt_length,
   7260                          key_out_attributes, output_key_slot->key.data,
   7261                          output_key_slot->key.bytes);
   7262                  }
   7263          #else /* SLI_PSA_DRIVER_FEATURE_HKDF */
   7264                  {
   7265                      (void)info;
   7266                      (void)info_length;
   7267                      (void)salt;
   7268                      (void)salt_length;
   7269                      (void)key_in_attributes;
   7270          
   7271                      status = PSA_ERROR_NOT_SUPPORTED;
   \       0xAA   0xF07F 0x0085      MVNS     R0,#+133
   \       0xAE   0x0004             MOVS     R4,R0
   \       0xB0   0xE011             B.N      ??sl_psa_key_derivation_single_shot_3
   7272                  }
   7273          #endif /* SLI_PSA_DRIVER_FEATURE_HKDF */
   7274                  else if ( (PSA_ALG_IS_PBKDF2_HMAC(alg) || (alg == PSA_ALG_PBKDF2_AES_CMAC_PRF_128)) )
   \                     ??sl_psa_key_derivation_single_shot_7: (+1)
   \       0xB2   0xEA5F 0x2119      LSRS     R1,R9,#+8
   \       0xB6   0x0209             LSLS     R1,R1,#+8
   \       0xB8   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \       0xBC   0x4281             CMP      R1,R0
   \       0xBE   0xD003             BEQ.N    ??sl_psa_key_derivation_single_shot_8
   \       0xC0   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \       0xC4   0x4581             CMP      R9,R0
   \       0xC6   0xD103             BNE.N    ??sl_psa_key_derivation_single_shot_9
   7275          #if defined(SLI_PSA_DRIVER_FEATURE_PBKDF2)
   7276          #if defined(SLI_MBEDTLS_DEVICE_VSE) && defined(SLI_PSA_DRIVER_FEATURE_OPAQUE_KEYS)
   7277                  {
   7278                      if (alg == PSA_ALG_PBKDF2_AES_CMAC_PRF_128)
   7279                      {
   7280                          status = sli_cryptoacc_driver_single_shot_pbkdf2(
   7281                              alg, &key_in_attributes, input_key_slot->key.data,
   7282                              input_key_slot->key.bytes, salt, salt_length,
   7283                              key_out_attributes, iterations, output_key_slot->key.data,
   7284                              output_key_slot->key.bytes);
   7285                      }
   7286                      else
   7287                      {
   7288                          (void)salt;
   7289                          (void)salt_length;
   7290                          (void)iterations;
   7291                          (void)key_in_attributes;
   7292          
   7293                          status = PSA_ERROR_NOT_SUPPORTED;
   7294                      }
   7295                  }
   7296          #else /* SLI_MBEDTLS_DEVICE_VSE && SLI_PSA_DRIVER_FEATURE_OPAQUE_KEYS */
   7297                  {
   7298                      status = sli_se_driver_single_shot_pbkdf2(
   7299                          alg, &key_in_attributes, input_key_slot->key.data,
   7300                          input_key_slot->key.bytes, salt, salt_length,
   7301                          key_out_attributes, iterations, output_key_slot->key.data,
   7302                          output_key_slot->key.bytes);
   7303                  }
   7304          #endif /* SLI_MBEDTLS_DEVICE_VSE && SLI_PSA_DRIVER_FEATURE_OPAQUE_KEYS */
   7305          #else /* SLI_PSA_DRIVER_FEATURE_PBKDF2 */
   7306                  {
   7307                      (void)salt;
   7308                      (void)salt_length;
   7309                      (void)iterations;
   7310                      (void)key_in_attributes;
   7311          
   7312                      status = PSA_ERROR_NOT_SUPPORTED;
   \                     ??sl_psa_key_derivation_single_shot_8: (+1)
   \       0xC8   0xF07F 0x0085      MVNS     R0,#+133
   \       0xCC   0x0004             MOVS     R4,R0
   \       0xCE   0xE002             B.N      ??sl_psa_key_derivation_single_shot_3
   7313                  }
   7314          #endif /* SLI_PSA_DRIVER_FEATURE_PBKDF2 */
   7315                  else
   7316                  {
   7317                      status = PSA_ERROR_NOT_SUPPORTED;
   \                     ??sl_psa_key_derivation_single_shot_9: (+1)
   \       0xD0   0xF07F 0x0085      MVNS     R0,#+133
   \       0xD4   0x0004             MOVS     R4,R0
   7318                  }
   7319              }
   7320          
   7321          exit:
   7322          
   7323              /* Finish (or fail) key creation. */
   7324              if( status == PSA_SUCCESS )
   \                     ??sl_psa_key_derivation_single_shot_3: (+1)
   \       0xD6   0x2C00             CMP      R4,#+0
   \       0xD8   0xD105             BNE.N    ??sl_psa_key_derivation_single_shot_10
   7325                  status = psa_finish_key_creation( output_key_slot, driver, key_out );
   \       0xDA   0x003A             MOVS     R2,R7
   \       0xDC   0x9901             LDR      R1,[SP, #+4]
   \       0xDE   0x9800             LDR      R0,[SP, #+0]
   \       0xE0   0x.... 0x....      BL       psa_finish_key_creation
   \       0xE4   0x0004             MOVS     R4,R0
   7326              if( status != PSA_SUCCESS )
   \                     ??sl_psa_key_derivation_single_shot_10: (+1)
   \       0xE6   0x2C00             CMP      R4,#+0
   \       0xE8   0xD003             BEQ.N    ??sl_psa_key_derivation_single_shot_11
   7327                  psa_fail_key_creation( output_key_slot, driver );
   \       0xEA   0x9901             LDR      R1,[SP, #+4]
   \       0xEC   0x9800             LDR      R0,[SP, #+0]
   \       0xEE   0x.... 0x....      BL       psa_fail_key_creation
   7328          
   7329              /* Release input key slot. */
   7330              unlock_status = psa_unlock_key_slot( input_key_slot );
   \                     ??sl_psa_key_derivation_single_shot_11: (+1)
   \       0xF2   0x9802             LDR      R0,[SP, #+8]
   \       0xF4   0x.... 0x....      BL       psa_unlock_key_slot
   7331          
   7332              return( ( status == PSA_SUCCESS ) ? unlock_status : status );
   \       0xF8   0x2C00             CMP      R4,#+0
   \       0xFA   0xD000             BEQ.N    ??sl_psa_key_derivation_single_shot_12
   \                     ??sl_psa_key_derivation_single_shot_13: (+1)
   \       0xFC   0x0020             MOVS     R0,R4
   \                     ??sl_psa_key_derivation_single_shot_12: (+1)
   \                     ??sl_psa_key_derivation_single_shot_1: (+1)
   \       0xFE   0xB00F             ADD      SP,SP,#+60
   \      0x100   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   7333          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   7334          
   7335          
   7336          
   7337          /****************************************************************/
   7338          /* Key agreement */
   7339          /****************************************************************/
   7340          

   \                                 In section .text, align 2, keep-with-next
   7341          psa_status_t psa_key_agreement_raw_builtin(const psa_key_attributes_t *attributes,
   7342                                                     const uint8_t *key_buffer,
   7343                                                     size_t key_buffer_size,
   7344                                                     psa_algorithm_t alg,
   7345                                                     const uint8_t *peer_key,
   7346                                                     size_t peer_key_length,
   7347                                                     uint8_t *shared_secret,
   7348                                                     size_t shared_secret_size,
   7349                                                     size_t *shared_secret_length)
   7350          {
   \                     psa_key_agreement_raw_builtin: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   7351              switch (alg) {
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable53_2
   \       0x10   0x4287             CMP      R7,R0
   \       0x12   0xD110             BNE.N    ??psa_key_agreement_raw_builtin_0
   7352          #if defined(MBEDTLS_PSA_BUILTIN_ALG_ECDH)
   7353                  case PSA_ALG_ECDH:
   7354                      return mbedtls_psa_key_agreement_ecdh(attributes, key_buffer,
   7355                                                            key_buffer_size, alg,
   7356                                                            peer_key, peer_key_length,
   7357                                                            shared_secret,
   7358                                                            shared_secret_size,
   7359                                                            shared_secret_length);
   \       0x14   0x980E             LDR      R0,[SP, #+56]
   \       0x16   0x9004             STR      R0,[SP, #+16]
   \       0x18   0x980D             LDR      R0,[SP, #+52]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   \       0x1C   0x980C             LDR      R0,[SP, #+48]
   \       0x1E   0x9002             STR      R0,[SP, #+8]
   \       0x20   0x980B             LDR      R0,[SP, #+44]
   \       0x22   0x9001             STR      R0,[SP, #+4]
   \       0x24   0x980A             LDR      R0,[SP, #+40]
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0x003B             MOVS     R3,R7
   \       0x2A   0x0032             MOVS     R2,R6
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       mbedtls_psa_key_agreement_ecdh
   \       0x34   0xE001             B.N      ??psa_key_agreement_raw_builtin_1
   7360          #endif /* MBEDTLS_PSA_BUILTIN_ALG_ECDH */
   7361          
   7362          #if defined(MBEDTLS_PSA_BUILTIN_ALG_FFDH)
   7363                  case PSA_ALG_FFDH:
   7364                      return mbedtls_psa_ffdh_key_agreement(attributes,
   7365                                                            peer_key,
   7366                                                            peer_key_length,
   7367                                                            key_buffer,
   7368                                                            key_buffer_size,
   7369                                                            shared_secret,
   7370                                                            shared_secret_size,
   7371                                                            shared_secret_length);
   7372          #endif /* MBEDTLS_PSA_BUILTIN_ALG_FFDH */
   7373          
   7374                  default:
   7375                      (void) attributes;
   7376                      (void) key_buffer;
   7377                      (void) key_buffer_size;
   7378                      (void) peer_key;
   7379                      (void) peer_key_length;
   7380                      (void) shared_secret;
   7381                      (void) shared_secret_size;
   7382                      (void) shared_secret_length;
   7383                      return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_key_agreement_raw_builtin_0: (+1)
   \       0x36   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??psa_key_agreement_raw_builtin_1: (+1)
   \       0x3A   0xB005             ADD      SP,SP,#+20
   \       0x3C   0xBDF0             POP      {R4-R7,PC}
   7384              }
   7385          }
   7386          
   7387          /** Internal function for raw key agreement
   7388           *  Calls the driver wrapper which will hand off key agreement task
   7389           *  to the driver's implementation if a driver is present.
   7390           *  Fallback specified in the driver wrapper is built-in raw key agreement
   7391           *  (psa_key_agreement_raw_builtin).
   7392           */

   \                                 In section .text, align 2, keep-with-next
   7393          static psa_status_t psa_key_agreement_raw_internal(psa_algorithm_t alg,
   7394                                                             psa_key_slot_t *private_key,
   7395                                                             const uint8_t *peer_key,
   7396                                                             size_t peer_key_length,
   7397                                                             uint8_t *shared_secret,
   7398                                                             size_t shared_secret_size,
   7399                                                             size_t *shared_secret_length)
   7400          {
   \                     psa_key_agreement_raw_internal: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB08E             SUB      SP,SP,#+56
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   7401              if (!PSA_ALG_IS_RAW_KEY_AGREEMENT(alg)) {
   \        0xC   0xF014 0x40FE      ANDS     R0,R4,#0x7F000000
   \       0x10   0xF1B0 0x6F10      CMP      R0,#+150994944
   \       0x14   0xD107             BNE.N    ??psa_key_agreement_raw_internal_0
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0xF36F 0x4018      BFC      R0,#+16,#+9
   \       0x1C   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \       0x20   0xF1B0 0x6F00      CMP      R0,#+134217728
   \       0x24   0xD002             BEQ.N    ??psa_key_agreement_raw_internal_1
   7402                  return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_key_agreement_raw_internal_0: (+1)
   \       0x26   0xF07F 0x0085      MVNS     R0,#+133
   \       0x2A   0xE016             B.N      ??psa_key_agreement_raw_internal_2
   7403              }
   7404          
   7405              psa_key_attributes_t attributes = {
   7406                  .core = private_key->attr
   7407              };
   \                     ??psa_key_agreement_raw_internal_1: (+1)
   \       0x2C   0xA805             ADD      R0,SP,#+20
   \       0x2E   0x2124             MOVS     R1,#+36
   \       0x30   0x.... 0x....      BL       __aeabi_memclr4
   \       0x34   0xA805             ADD      R0,SP,#+20
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0x221C             MOVS     R2,#+28
   \       0x3A   0x.... 0x....      BL       __aeabi_memcpy4
   7408          
   7409              return psa_driver_wrapper_key_agreement(&attributes,
   7410                                                      private_key->key.data,
   7411                                                      private_key->key.bytes, alg,
   7412                                                      peer_key, peer_key_length,
   7413                                                      shared_secret,
   7414                                                      shared_secret_size,
   7415                                                      shared_secret_length);
   \       0x3E   0x9816             LDR      R0,[SP, #+88]
   \       0x40   0x9004             STR      R0,[SP, #+16]
   \       0x42   0x9815             LDR      R0,[SP, #+84]
   \       0x44   0x9003             STR      R0,[SP, #+12]
   \       0x46   0x9814             LDR      R0,[SP, #+80]
   \       0x48   0x9002             STR      R0,[SP, #+8]
   \       0x4A   0x9701             STR      R7,[SP, #+4]
   \       0x4C   0x9600             STR      R6,[SP, #+0]
   \       0x4E   0x0023             MOVS     R3,R4
   \       0x50   0x6AAA             LDR      R2,[R5, #+40]
   \       0x52   0x6A69             LDR      R1,[R5, #+36]
   \       0x54   0xA805             ADD      R0,SP,#+20
   \       0x56   0x.... 0x....      BL       psa_driver_wrapper_key_agreement
   \                     ??psa_key_agreement_raw_internal_2: (+1)
   \       0x5A   0xB00F             ADD      SP,SP,#+60
   \       0x5C   0xBDF0             POP      {R4-R7,PC}
   7416          }

   \                                 In section .rodata, align 4
   \        0x0                      DS8 28
   \       0x1C                      DS8 8
   7417          
   7418          /* Note that if this function fails, you must call psa_key_derivation_abort()
   7419           * to potentially free embedded data structures and wipe confidential data.
   7420           */

   \                                 In section .text, align 2, keep-with-next
   7421          static psa_status_t psa_key_agreement_internal(psa_key_derivation_operation_t *operation,
   7422                                                         psa_key_derivation_step_t step,
   7423                                                         psa_key_slot_t *private_key,
   7424                                                         const uint8_t *peer_key,
   7425                                                         size_t peer_key_length)
   7426          {
   \                     psa_key_agreement_internal: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0xF8DD 0x9050      LDR      R9,[SP, #+80]
   7427              psa_status_t status;
   7428              uint8_t shared_secret[PSA_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE];
   7429              size_t shared_secret_length = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9003             STR      R0,[SP, #+12]
   7430              psa_algorithm_t ka_alg = PSA_ALG_KEY_AGREEMENT_GET_BASE(operation->alg);
   \       0x16   0xF8D5 0xA000      LDR      R10,[R5, #+0]
   \       0x1A   0xEA5F 0x4A1A      LSRS     R10,R10,#+16
   \       0x1E   0xEA5F 0x4A0A      LSLS     R10,R10,#+16
   \       0x22   0xF05A 0x6A10      ORRS     R10,R10,#0x9000000
   7431          
   7432              /* Step 1: run the secret agreement algorithm to generate the shared
   7433               * secret. */
   7434              status = psa_key_agreement_raw_internal(ka_alg,
   7435                                                      private_key,
   7436                                                      peer_key, peer_key_length,
   7437                                                      shared_secret,
   7438                                                      sizeof(shared_secret),
   7439                                                      &shared_secret_length);
   \       0x26   0xA803             ADD      R0,SP,#+12
   \       0x28   0x9002             STR      R0,[SP, #+8]
   \       0x2A   0x2020             MOVS     R0,#+32
   \       0x2C   0x9001             STR      R0,[SP, #+4]
   \       0x2E   0xA804             ADD      R0,SP,#+16
   \       0x30   0x9000             STR      R0,[SP, #+0]
   \       0x32   0x464B             MOV      R3,R9
   \       0x34   0x4642             MOV      R2,R8
   \       0x36   0x0039             MOVS     R1,R7
   \       0x38   0x4650             MOV      R0,R10
   \       0x3A   0x.... 0x....      BL       psa_key_agreement_raw_internal
   \       0x3E   0x0004             MOVS     R4,R0
   7440              if (status != PSA_SUCCESS) {
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD10A             BNE.N    ??psa_key_agreement_internal_0
   7441                  goto exit;
   7442              }
   7443          
   7444              /* Step 2: set up the key derivation to generate key material from
   7445               * the shared secret. A shared secret is permitted wherever a key
   7446               * of type DERIVE is permitted. */
   7447              status = psa_key_derivation_input_internal(operation, step,
   7448                                                         PSA_KEY_TYPE_DERIVE,
   7449                                                         shared_secret,
   7450                                                         shared_secret_length);
   \                     ??psa_key_agreement_internal_1: (+1)
   \       0x44   0x9803             LDR      R0,[SP, #+12]
   \       0x46   0x9000             STR      R0,[SP, #+0]
   \       0x48   0xAB04             ADD      R3,SP,#+16
   \       0x4A   0xF44F 0x5290      MOV      R2,#+4608
   \       0x4E   0x0031             MOVS     R1,R6
   \       0x50   0xB289             UXTH     R1,R1
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0x.... 0x....      BL       psa_key_derivation_input_internal
   \       0x58   0x0004             MOVS     R4,R0
   7451          exit:
   7452              mbedtls_platform_zeroize(shared_secret, shared_secret_length);
   \                     ??psa_key_agreement_internal_0: (+1)
   \       0x5A   0x9903             LDR      R1,[SP, #+12]
   \       0x5C   0xA804             ADD      R0,SP,#+16
   \       0x5E   0x.... 0x....      BL       mbedtls_platform_zeroize
   7453              return status;
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0xB00C             ADD      SP,SP,#+48
   \       0x66   0xE8BD 0x87F0      POP      {R4-R10,PC}
   7454          }
   7455          

   \                                 In section .text, align 2, keep-with-next
   7456          psa_status_t psa_key_derivation_key_agreement(psa_key_derivation_operation_t *operation,
   7457                                                        psa_key_derivation_step_t step,
   7458                                                        mbedtls_svc_key_id_t private_key,
   7459                                                        const uint8_t *peer_key,
   7460                                                        size_t peer_key_length)
   7461          {
   \                     psa_key_derivation_key_agreement: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   7462              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x0996      MVNS     R9,#+150
   \       0x10   0x464C             MOV      R4,R9
   7463              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   7464              psa_key_slot_t *slot;
   7465          
   7466              if (!PSA_ALG_IS_KEY_AGREEMENT(operation->alg)) {
   \       0x12   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x16   0xF010 0x40FE      ANDS     R0,R0,#0x7F000000
   \       0x1A   0xF1B0 0x6F10      CMP      R0,#+150994944
   \       0x1E   0xD002             BEQ.N    ??psa_key_derivation_key_agreement_0
   7467                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x20   0xF07F 0x0086      MVNS     R0,#+134
   \       0x24   0xE030             B.N      ??psa_key_derivation_key_agreement_1
   7468              }
   7469              status = psa_get_and_lock_key_slot_with_policy(
   7470                  private_key, &slot, PSA_KEY_USAGE_DERIVE, operation->alg);
   \                     ??psa_key_derivation_key_agreement_0: (+1)
   \       0x26   0xF8DA 0x3000      LDR      R3,[R10, #+0]
   \       0x2A   0xF44F 0x4280      MOV      R2,#+16384
   \       0x2E   0xA901             ADD      R1,SP,#+4
   \       0x30   0x0038             MOVS     R0,R7
   \       0x32   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x36   0x0005             MOVS     R5,R0
   7471              if (status != PSA_SUCCESS) {
   \       0x38   0x2D00             CMP      R5,#+0
   \       0x3A   0xD001             BEQ.N    ??psa_key_derivation_key_agreement_2
   7472                  return status;
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0xE023             B.N      ??psa_key_derivation_key_agreement_1
   7473              }
   7474              status = psa_key_agreement_internal(operation, step,
   7475                                                  slot,
   7476                                                  peer_key, peer_key_length);
   \                     ??psa_key_derivation_key_agreement_2: (+1)
   \       0x40   0x980A             LDR      R0,[SP, #+40]
   \       0x42   0x9000             STR      R0,[SP, #+0]
   \       0x44   0x4643             MOV      R3,R8
   \       0x46   0x9A01             LDR      R2,[SP, #+4]
   \       0x48   0x0031             MOVS     R1,R6
   \       0x4A   0xB289             UXTH     R1,R1
   \       0x4C   0x4650             MOV      R0,R10
   \       0x4E   0x.... 0x....      BL       psa_key_agreement_internal
   \       0x52   0x0004             MOVS     R4,R0
   7477              if (status != PSA_SUCCESS) {
   \       0x54   0x2C00             CMP      R4,#+0
   \       0x56   0xD003             BEQ.N    ??psa_key_derivation_key_agreement_3
   7478                  psa_key_derivation_abort(operation);
   \       0x58   0x4650             MOV      R0,R10
   \       0x5A   0x.... 0x....      BL       psa_key_derivation_abort
   \       0x5E   0xE00B             B.N      ??psa_key_derivation_key_agreement_4
   7479              } else {
   7480                  /* If a private key has been added as SECRET, we allow the derived
   7481                   * key material to be used as a key in PSA Crypto. */
   7482                  if (step == PSA_KEY_DERIVATION_INPUT_SECRET) {
   \                     ??psa_key_derivation_key_agreement_3: (+1)
   \       0x60   0x0031             MOVS     R1,R6
   \       0x62   0xF240 0x1001      MOVW     R0,#+257
   \       0x66   0xB289             UXTH     R1,R1
   \       0x68   0x4281             CMP      R1,R0
   \       0x6A   0xD105             BNE.N    ??psa_key_derivation_key_agreement_4
   7483                      operation->can_output_key = 1;
   \       0x6C   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x70   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x74   0xF8CA 0x0004      STR      R0,[R10, #+4]
   7484                  }
   7485              }
   7486          
   7487              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_key_derivation_key_agreement_4: (+1)
   \       0x78   0x9801             LDR      R0,[SP, #+4]
   \       0x7A   0x.... 0x....      BL       psa_unlock_key_slot
   7488          
   7489              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0x7E   0x2C00             CMP      R4,#+0
   \       0x80   0xD101             BNE.N    ??psa_key_derivation_key_agreement_5
   \       0x82   0x0004             MOVS     R4,R0
   \       0x84   0xE7FF             B.N      ??psa_key_derivation_key_agreement_6
   \                     ??psa_key_derivation_key_agreement_5: (+1)
   \                     ??psa_key_derivation_key_agreement_6: (+1)
   \       0x86   0x0020             MOVS     R0,R4
   \                     ??psa_key_derivation_key_agreement_1: (+1)
   \       0x88   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   7490          }
   7491          

   \                                 In section .text, align 2, keep-with-next
   7492          psa_status_t psa_raw_key_agreement(psa_algorithm_t alg,
   7493                                             mbedtls_svc_key_id_t private_key,
   7494                                             const uint8_t *peer_key,
   7495                                             size_t peer_key_length,
   7496                                             uint8_t *output,
   7497                                             size_t output_size,
   7498                                             size_t *output_length)
   7499          {
   \                     psa_raw_key_agreement: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8040      LDR      R8,[SP, #+64]
   \       0x10   0xF8DD 0x9044      LDR      R9,[SP, #+68]
   \       0x14   0xF8DD 0xA048      LDR      R10,[SP, #+72]
   7500              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x18   0xF07F 0x0096      MVNS     R0,#+150
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   7501              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x1E   0x9004             STR      R0,[SP, #+16]
   7502              psa_key_slot_t *slot = NULL;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x9003             STR      R0,[SP, #+12]
   7503              size_t expected_length;
   7504          
   7505              if (!PSA_ALG_IS_KEY_AGREEMENT(alg)) {
   \       0x24   0xF01B 0x40FE      ANDS     R0,R11,#0x7F000000
   \       0x28   0xF1B0 0x6F10      CMP      R0,#+150994944
   \       0x2C   0xD002             BEQ.N    ??psa_raw_key_agreement_0
   7506                  status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x2E   0xF07F 0x0486      MVNS     R4,#+134
   7507                  goto exit;
   \       0x32   0xE030             B.N      ??psa_raw_key_agreement_1
   7508              }
   7509              status = psa_get_and_lock_key_slot_with_policy(
   7510                  private_key, &slot, PSA_KEY_USAGE_DERIVE, alg);
   \                     ??psa_raw_key_agreement_0: (+1)
   \       0x34   0x465B             MOV      R3,R11
   \       0x36   0xF44F 0x4280      MOV      R2,#+16384
   \       0x3A   0xA903             ADD      R1,SP,#+12
   \       0x3C   0x9806             LDR      R0,[SP, #+24]
   \       0x3E   0x.... 0x....      BL       psa_get_and_lock_key_slot_with_policy
   \       0x42   0x0004             MOVS     R4,R0
   7511              if (status != PSA_SUCCESS) {
   \       0x44   0x2C00             CMP      R4,#+0
   \       0x46   0xD126             BNE.N    ??psa_raw_key_agreement_1
   7512                  goto exit;
   7513              }
   7514          
   7515              /* PSA_RAW_KEY_AGREEMENT_OUTPUT_SIZE() is in general an upper bound
   7516               * for the output size. The PSA specification only guarantees that this
   7517               * function works if output_size >= PSA_RAW_KEY_AGREEMENT_OUTPUT_SIZE(...),
   7518               * but it might be nice to allow smaller buffers if the output fits.
   7519               * At the time of writing this comment, with only ECDH implemented,
   7520               * PSA_RAW_KEY_AGREEMENT_OUTPUT_SIZE() is exact so the point is moot.
   7521               * If FFDH is implemented, PSA_RAW_KEY_AGREEMENT_OUTPUT_SIZE() can easily
   7522               * be exact for it as well. */
   7523              expected_length =
   7524                  PSA_RAW_KEY_AGREEMENT_OUTPUT_SIZE(slot->attr.type, slot->attr.bits);
   \                     ??psa_raw_key_agreement_2: (+1)
   \       0x48   0x9803             LDR      R0,[SP, #+12]
   \       0x4A   0x8800             LDRH     R0,[R0, #+0]
   \       0x4C   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0x50   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0x54   0xD006             BEQ.N    ??psa_raw_key_agreement_3
   \       0x56   0x9803             LDR      R0,[SP, #+12]
   \       0x58   0x8800             LDRH     R0,[R0, #+0]
   \       0x5A   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0x5E   0xF5B0 0x4FE4      CMP      R0,#+29184
   \       0x62   0xD104             BNE.N    ??psa_raw_key_agreement_4
   \                     ??psa_raw_key_agreement_3: (+1)
   \       0x64   0x9803             LDR      R0,[SP, #+12]
   \       0x66   0x8845             LDRH     R5,[R0, #+2]
   \       0x68   0x1DED             ADDS     R5,R5,#+7
   \       0x6A   0x08ED             LSRS     R5,R5,#+3
   \       0x6C   0xE000             B.N      ??psa_raw_key_agreement_5
   \                     ??psa_raw_key_agreement_4: (+1)
   \       0x6E   0x2500             MOVS     R5,#+0
   7525              if (output_size < expected_length) {
   \                     ??psa_raw_key_agreement_5: (+1)
   \       0x70   0x45A9             CMP      R9,R5
   \       0x72   0xD203             BCS.N    ??psa_raw_key_agreement_6
   7526                  status = PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x74   0xF07F 0x0089      MVNS     R0,#+137
   \       0x78   0x0004             MOVS     R4,R0
   7527                  goto exit;
   \       0x7A   0xE00C             B.N      ??psa_raw_key_agreement_1
   7528              }
   7529          
   7530              status = psa_key_agreement_raw_internal(alg, slot,
   7531                                                      peer_key, peer_key_length,
   7532                                                      output, output_size,
   7533                                                      output_length);
   \                     ??psa_raw_key_agreement_6: (+1)
   \       0x7C   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \       0x80   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x84   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x88   0x003B             MOVS     R3,R7
   \       0x8A   0x0032             MOVS     R2,R6
   \       0x8C   0x9903             LDR      R1,[SP, #+12]
   \       0x8E   0x4658             MOV      R0,R11
   \       0x90   0x.... 0x....      BL       psa_key_agreement_raw_internal
   \       0x94   0x0004             MOVS     R4,R0
   7534          
   7535          exit:
   7536              if (status != PSA_SUCCESS) {
   \                     ??psa_raw_key_agreement_1: (+1)
   \       0x96   0x2C00             CMP      R4,#+0
   \       0x98   0xD005             BEQ.N    ??psa_raw_key_agreement_7
   7537                  /* If an error happens and is not handled properly, the output
   7538                   * may be used as a key to protect sensitive data. Arrange for such
   7539                   * a key to be random, which is likely to result in decryption or
   7540                   * verification errors. This is better than filling the buffer with
   7541                   * some constant data such as zeros, which would result in the data
   7542                   * being protected with a reproducible, easily knowable key.
   7543                   */
   7544                  psa_generate_random(output, output_size);
   \       0x9A   0x4649             MOV      R1,R9
   \       0x9C   0x4640             MOV      R0,R8
   \       0x9E   0x.... 0x....      BL       psa_generate_random
   7545                  *output_length = output_size;
   \       0xA2   0xF8CA 0x9000      STR      R9,[R10, #+0]
   7546              }
   7547          
   7548              unlock_status = psa_unlock_key_slot(slot);
   \                     ??psa_raw_key_agreement_7: (+1)
   \       0xA6   0x9803             LDR      R0,[SP, #+12]
   \       0xA8   0x.... 0x....      BL       psa_unlock_key_slot
   7549          
   7550              return (status == PSA_SUCCESS) ? unlock_status : status;
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD000             BEQ.N    ??psa_raw_key_agreement_8
   \                     ??psa_raw_key_agreement_9: (+1)
   \       0xB0   0x0020             MOVS     R0,R4
   \                     ??psa_raw_key_agreement_8: (+1)
   \       0xB2   0xB007             ADD      SP,SP,#+28
   \       0xB4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   7551          }
   7552          
   7553          
   7554          
   7555          /****************************************************************/
   7556          /* Random generation */
   7557          /****************************************************************/
   7558          
   7559          #if defined(MBEDTLS_PSA_INJECT_ENTROPY)
   7560          #include "entropy_poll.h"
   7561          #endif
   7562          
   7563          /** Initialize the PSA random generator.
   7564           */

   \                                 In section .text, align 2, keep-with-next
   7565          static void mbedtls_psa_random_init(mbedtls_psa_random_context_t *rng)
   7566          {
   \                     mbedtls_psa_random_init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   7567          #if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
   7568              memset(rng, 0, sizeof(*rng));
   \        0x4   0x2408             MOVS     R4,#+8
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memset
   7569          #else /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
   7570          
   7571              /* Set default configuration if
   7572               * mbedtls_psa_crypto_configure_entropy_sources() hasn't been called. */
   7573              if (rng->entropy_init == NULL) {
   7574                  rng->entropy_init = mbedtls_entropy_init;
   7575              }
   7576              if (rng->entropy_free == NULL) {
   7577                  rng->entropy_free = mbedtls_entropy_free;
   7578              }
   7579          
   7580              rng->entropy_init(&rng->entropy);
   7581          #if defined(MBEDTLS_PSA_INJECT_ENTROPY) && \
   7582              defined(MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES)
   7583              /* The PSA entropy injection feature depends on using NV seed as an entropy
   7584               * source. Add NV seed as an entropy source for PSA entropy injection. */
   7585              mbedtls_entropy_add_source(&rng->entropy,
   7586                                         mbedtls_nv_seed_poll, NULL,
   7587                                         MBEDTLS_ENTROPY_BLOCK_SIZE,
   7588                                         MBEDTLS_ENTROPY_SOURCE_STRONG);
   7589          #endif
   7590          
   7591              mbedtls_psa_drbg_init(MBEDTLS_PSA_RANDOM_STATE);
   7592          #endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
   7593          }
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}
   7594          
   7595          /** Deinitialize the PSA random generator.
   7596           */

   \                                 In section .text, align 2, keep-with-next
   7597          static void mbedtls_psa_random_free(mbedtls_psa_random_context_t *rng)
   7598          {
   \                     mbedtls_psa_random_free: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   7599          #if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
   7600              memset(rng, 0, sizeof(*rng));
   \        0x4   0x2408             MOVS     R4,#+8
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memset
   7601          #else /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
   7602              mbedtls_psa_drbg_free(MBEDTLS_PSA_RANDOM_STATE);
   7603              rng->entropy_free(&rng->entropy);
   7604          #endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
   7605          }
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}
   7606          
   7607          /** Seed the PSA random generator.
   7608           */

   \                                 In section .text, align 2, keep-with-next
   7609          static psa_status_t mbedtls_psa_random_seed(mbedtls_psa_random_context_t *rng)
   7610          {
   \                     mbedtls_psa_random_seed: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   7611          #if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
   7612              /* Do nothing: the external RNG seeds itself. */
   7613              (void) rng;
   7614              return PSA_SUCCESS;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x4770             BX       LR
   7615          #else /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
   7616              const unsigned char drbg_seed[] = "PSA";
   7617              int ret = mbedtls_psa_drbg_seed(&rng->entropy,
   7618                                              drbg_seed, sizeof(drbg_seed) - 1);
   7619              return mbedtls_to_psa_error(ret);
   7620          #endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
   7621          }
   7622          

   \                                 In section .text, align 2, keep-with-next
   7623          psa_status_t psa_generate_random(uint8_t *output,
   7624                                           size_t output_size)
   7625          {
   \                     psa_generate_random: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   7626              GUARD_MODULE_INITIALIZED;
   \        0x6   0x.... 0x....      LDR.W    R6,??DataTable53_6
   \        0xA   0x7830             LDRB     R0,[R6, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD102             BNE.N    ??psa_generate_random_0
   \       0x10   0xF07F 0x0088      MVNS     R0,#+136
   \       0x14   0xE013             B.N      ??psa_generate_random_1
   7627          
   7628          #if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
   7629          
   7630              size_t output_length = 0;
   \                     ??psa_generate_random_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x9000             STR      R0,[SP, #+0]
   7631              psa_status_t status = mbedtls_psa_external_get_random(&global_data.rng,
   7632                                                                    output, output_size,
   7633                                                                    &output_length);
   \       0x1A   0x466B             MOV      R3,SP
   \       0x1C   0x002A             MOVS     R2,R5
   \       0x1E   0x0021             MOVS     R1,R4
   \       0x20   0x1D30             ADDS     R0,R6,#+4
   \       0x22   0x.... 0x....      BL       mbedtls_psa_external_get_random
   \       0x26   0x0001             MOVS     R1,R0
   7634              if (status != PSA_SUCCESS) {
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD001             BEQ.N    ??psa_generate_random_2
   7635                  return status;
   \       0x2C   0x0008             MOVS     R0,R1
   \       0x2E   0xE006             B.N      ??psa_generate_random_1
   7636              }
   7637              /* Breaking up a request into smaller chunks is currently not supported
   7638               * for the external RNG interface. */
   7639              if (output_length != output_size) {
   \                     ??psa_generate_random_2: (+1)
   \       0x30   0x9800             LDR      R0,[SP, #+0]
   \       0x32   0x42A8             CMP      R0,R5
   \       0x34   0xD002             BEQ.N    ??psa_generate_random_3
   7640                  return PSA_ERROR_INSUFFICIENT_ENTROPY;
   \       0x36   0xF07F 0x0093      MVNS     R0,#+147
   \       0x3A   0xE000             B.N      ??psa_generate_random_1
   7641              }
   7642              return PSA_SUCCESS;
   \                     ??psa_generate_random_3: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??psa_generate_random_1: (+1)
   \       0x3E   0xBD76             POP      {R1,R2,R4-R6,PC}
   7643          
   7644          #else /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
   7645          
   7646              while (output_size > 0) {
   7647                  size_t request_size =
   7648                      (output_size > MBEDTLS_PSA_RANDOM_MAX_REQUEST ?
   7649                       MBEDTLS_PSA_RANDOM_MAX_REQUEST :
   7650                       output_size);
   7651                  int ret = mbedtls_psa_get_random(MBEDTLS_PSA_RANDOM_STATE,
   7652                                                   output, request_size);
   7653                  if (ret != 0) {
   7654                      return mbedtls_to_psa_error(ret);
   7655                  }
   7656                  output_size -= request_size;
   7657                  output += request_size;
   7658              }
   7659              return PSA_SUCCESS;
   7660          #endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
   7661          }
   7662          
   7663          /* Wrapper function allowing the classic API to use the PSA RNG.
   7664           *
   7665           * `mbedtls_psa_get_random(MBEDTLS_PSA_RANDOM_STATE, ...)` calls
   7666           * `psa_generate_random(...)`. The state parameter is ignored since the
   7667           * PSA API doesn't support passing an explicit state.
   7668           *
   7669           * In the non-external case, psa_generate_random() calls an
   7670           * `mbedtls_xxx_drbg_random` function which has exactly the same signature
   7671           * and semantics as mbedtls_psa_get_random(). As an optimization,
   7672           * instead of doing this back-and-forth between the PSA API and the
   7673           * classic API, psa_crypto_random_impl.h defines `mbedtls_psa_get_random`
   7674           * as a constant function pointer to `mbedtls_xxx_drbg_random`.
   7675           */
   7676          #if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)

   \                                 In section .text, align 2, keep-with-next
   7677          int mbedtls_psa_get_random(void *p_rng,
   7678                                     unsigned char *output,
   7679                                     size_t output_size)
   7680          {
   \                     mbedtls_psa_get_random: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   7681              /* This function takes a pointer to the RNG state because that's what
   7682               * classic mbedtls functions using an RNG expect. The PSA RNG manages
   7683               * its own state internally and doesn't let the caller access that state.
   7684               * So we just ignore the state parameter, and in practice we'll pass
   7685               * NULL. */
   7686              (void) p_rng;
   7687              psa_status_t status = psa_generate_random(output, output_size);
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       psa_generate_random
   \       0x10   0x0001             MOVS     R1,R0
   7688              if (status == PSA_SUCCESS) {
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD101             BNE.N    ??mbedtls_psa_get_random_0
   7689                  return 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE001             B.N      ??mbedtls_psa_get_random_1
   7690              } else {
   7691                  return MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
   \                     ??mbedtls_psa_get_random_0: (+1)
   \       0x1A   0xF07F 0x003B      MVNS     R0,#+59
   \                     ??mbedtls_psa_get_random_1: (+1)
   \       0x1E   0xBD70             POP      {R4-R6,PC}
   7692              }
   7693          }
   7694          #endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
   7695          
   7696          #if defined(MBEDTLS_PSA_INJECT_ENTROPY)
   7697          psa_status_t mbedtls_psa_inject_entropy(const uint8_t *seed,
   7698                                                  size_t seed_size)
   7699          {
   7700              if (global_data.initialized) {
   7701                  return PSA_ERROR_NOT_PERMITTED;
   7702              }
   7703          
   7704              if (((seed_size < MBEDTLS_ENTROPY_MIN_PLATFORM) ||
   7705                   (seed_size < MBEDTLS_ENTROPY_BLOCK_SIZE)) ||
   7706                  (seed_size > MBEDTLS_ENTROPY_MAX_SEED_SIZE)) {
   7707                  return PSA_ERROR_INVALID_ARGUMENT;
   7708              }
   7709          
   7710              return mbedtls_psa_storage_inject_entropy(seed, seed_size);
   7711          }
   7712          #endif /* MBEDTLS_PSA_INJECT_ENTROPY */
   7713          
   7714          /** Validate the key type and size for key generation
   7715           *
   7716           * \param  type  The key type
   7717           * \param  bits  The number of bits of the key
   7718           *
   7719           * \retval #PSA_SUCCESS
   7720           *         The key type and size are valid.
   7721           * \retval #PSA_ERROR_INVALID_ARGUMENT
   7722           *         The size in bits of the key is not valid.
   7723           * \retval #PSA_ERROR_NOT_SUPPORTED
   7724           *         The type and/or the size in bits of the key or the combination of
   7725           *         the two is not supported.
   7726           */

   \                                 In section .text, align 2, keep-with-next
   7727          static psa_status_t psa_validate_key_type_and_size_for_key_generation(
   7728              psa_key_type_t type, size_t bits)
   7729          {
   \                     psa_validate_key_type_and_size_for_key_generation: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   7730              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x0596      MVNS     R5,#+150
   7731          
   7732              if (key_type_is_raw_bytes(type)) {
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x.... 0x....      BL       key_type_is_raw_bytes
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD009             BEQ.N    ??psa_validate_key_type_and_size_for_key_genera_0
   7733                  status = psa_validate_unstructured_key_bit_size(type, bits);
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0xB280             UXTH     R0,R0
   \       0x1C   0x.... 0x....      BL       psa_validate_unstructured_key_bit_size
   \       0x20   0x0001             MOVS     R1,R0
   7734                  if (status != PSA_SUCCESS) {
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD014             BEQ.N    ??psa_validate_key_type_and_size_for_key_genera_1
   7735                      return status;
   \       0x26   0x0008             MOVS     R0,R1
   \       0x28   0xE013             B.N      ??psa_validate_key_type_and_size_for_key_genera_2
   7736                  }
   7737              } else
   7738          #if defined(PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_GENERATE)
   7739              if (PSA_KEY_TYPE_IS_RSA(type) && PSA_KEY_TYPE_IS_KEY_PAIR(type)) {
   7740                  if (bits > PSA_VENDOR_RSA_MAX_KEY_BITS) {
   7741                      return PSA_ERROR_NOT_SUPPORTED;
   7742                  }
   7743                  if (bits < PSA_VENDOR_RSA_GENERATE_MIN_KEY_BITS) {
   7744                      return PSA_ERROR_NOT_SUPPORTED;
   7745                  }
   7746          
   7747                  /* Accept only byte-aligned keys, for the same reasons as
   7748                   * in psa_import_rsa_key(). */
   7749                  if (bits % 8 != 0) {
   7750                      return PSA_ERROR_NOT_SUPPORTED;
   7751                  }
   7752              } else
   7753          #endif /* defined(PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_GENERATE) */
   7754          
   7755          #if defined(PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_GENERATE)
   7756              if (PSA_KEY_TYPE_IS_ECC(type) && PSA_KEY_TYPE_IS_KEY_PAIR(type)) {
   \                     ??psa_validate_key_type_and_size_for_key_genera_0: (+1)
   \       0x2A   0x0031             MOVS     R1,R6
   \       0x2C   0xB289             UXTH     R1,R1
   \       0x2E   0x....             LDR.N    R0,??DataTable49
   \       0x30   0x4001             ANDS     R1,R0,R1
   \       0x32   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x36   0xD108             BNE.N    ??psa_validate_key_type_and_size_for_key_genera_3
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0xB280             UXTH     R0,R0
   \       0x3C   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x40   0xF5B0 0x4FE0      CMP      R0,#+28672
   \       0x44   0xD101             BNE.N    ??psa_validate_key_type_and_size_for_key_genera_3
   7757                  /* To avoid empty block, return successfully here. */
   7758                  return PSA_SUCCESS;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xE003             B.N      ??psa_validate_key_type_and_size_for_key_genera_2
   7759              } else
   7760          #endif /* defined(PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_GENERATE) */
   7761          
   7762          #if defined(PSA_WANT_KEY_TYPE_DH_KEY_PAIR_GENERATE)
   7763              if (PSA_KEY_TYPE_IS_DH(type) && PSA_KEY_TYPE_IS_KEY_PAIR(type)) {
   7764                  if (psa_is_dh_key_size_valid(bits) == 0) {
   7765                      return PSA_ERROR_NOT_SUPPORTED;
   7766                  }
   7767              } else
   7768          #endif /* defined(PSA_WANT_KEY_TYPE_DH_KEY_PAIR_GENERATE) */
   7769              {
   7770                  return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_validate_key_type_and_size_for_key_genera_3: (+1)
   \       0x4A   0xF07F 0x0085      MVNS     R0,#+133
   \       0x4E   0xE000             B.N      ??psa_validate_key_type_and_size_for_key_genera_2
   7771              }
   7772          
   7773              return PSA_SUCCESS;
   \                     ??psa_validate_key_type_and_size_for_key_genera_1: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \                     ??psa_validate_key_type_and_size_for_key_genera_2: (+1)
   \       0x52   0xBD70             POP      {R4-R6,PC}
   7774          }
   7775          

   \                                 In section .text, align 2, keep-with-next
   7776          psa_status_t psa_generate_key_internal(
   7777              const psa_key_attributes_t *attributes,
   7778              uint8_t *key_buffer, size_t key_buffer_size, size_t *key_buffer_length)
   7779          {
   \                     psa_generate_key_internal: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   7780              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x0796      MVNS     R7,#+150
   7781              psa_key_type_t type = attributes->core.type;
   \       0x10   0xF8B9 0x8000      LDRH     R8,[R9, #+0]
   7782          
   7783              if ((attributes->domain_parameters == NULL) &&
   7784                  (attributes->domain_parameters_size != 0)) {
   \       0x14   0xF8D9 0x001C      LDR      R0,[R9, #+28]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD106             BNE.N    ??psa_generate_key_internal_0
   \       0x1C   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD002             BEQ.N    ??psa_generate_key_internal_0
   7785                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x24   0xF07F 0x0086      MVNS     R0,#+134
   \       0x28   0xE027             B.N      ??psa_generate_key_internal_1
   7786              }
   7787          
   7788              if (key_type_is_raw_bytes(type)) {
   \                     ??psa_generate_key_internal_0: (+1)
   \       0x2A   0x4640             MOV      R0,R8
   \       0x2C   0xB280             UXTH     R0,R0
   \       0x2E   0x.... 0x....      BL       key_type_is_raw_bytes
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD008             BEQ.N    ??psa_generate_key_internal_2
   7789                  status = psa_generate_random(key_buffer, key_buffer_size);
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       psa_generate_random
   \       0x3E   0x0001             MOVS     R1,R0
   7790                  if (status != PSA_SUCCESS) {
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD019             BEQ.N    ??psa_generate_key_internal_3
   7791                      return status;
   \       0x44   0x0008             MOVS     R0,R1
   \       0x46   0xE018             B.N      ??psa_generate_key_internal_1
   7792                  }
   7793          
   7794          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES)
   7795                  if (type == PSA_KEY_TYPE_DES) {
   7796                      psa_des_set_key_parity(key_buffer, key_buffer_size);
   7797                  }
   7798          #endif /* MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES */
   7799              } else
   7800          
   7801          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_GENERATE)
   7802              if (type == PSA_KEY_TYPE_RSA_KEY_PAIR) {
   7803                  return mbedtls_psa_rsa_generate_key(attributes,
   7804                                                      key_buffer,
   7805                                                      key_buffer_size,
   7806                                                      key_buffer_length);
   7807              } else
   7808          #endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_GENERATE) */
   7809          
   7810          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_GENERATE)
   7811              if (PSA_KEY_TYPE_IS_ECC(type) && PSA_KEY_TYPE_IS_KEY_PAIR(type)) {
   \                     ??psa_generate_key_internal_2: (+1)
   \       0x48   0x4641             MOV      R1,R8
   \       0x4A   0xB289             UXTH     R1,R1
   \       0x4C   0x....             LDR.N    R0,??DataTable53_7
   \       0x4E   0x4001             ANDS     R1,R0,R1
   \       0x50   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x54   0xD10D             BNE.N    ??psa_generate_key_internal_4
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0xB280             UXTH     R0,R0
   \       0x5A   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x5E   0xF5B0 0x4FE0      CMP      R0,#+28672
   \       0x62   0xD106             BNE.N    ??psa_generate_key_internal_4
   7812                  return mbedtls_psa_ecp_generate_key(attributes,
   7813                                                      key_buffer,
   7814                                                      key_buffer_size,
   7815                                                      key_buffer_length);
   \       0x64   0x0033             MOVS     R3,R6
   \       0x66   0x002A             MOVS     R2,R5
   \       0x68   0x0021             MOVS     R1,R4
   \       0x6A   0x4648             MOV      R0,R9
   \       0x6C   0x.... 0x....      BL       mbedtls_psa_ecp_generate_key
   \       0x70   0xE003             B.N      ??psa_generate_key_internal_1
   7816              } else
   7817          #endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_GENERATE) */
   7818          
   7819          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_GENERATE)
   7820              if (PSA_KEY_TYPE_IS_DH(type) && PSA_KEY_TYPE_IS_KEY_PAIR(type)) {
   7821                  return mbedtls_psa_ffdh_generate_key(attributes,
   7822                                                       key_buffer,
   7823                                                       key_buffer_size,
   7824                                                       key_buffer_length);
   7825              } else
   7826          #endif /* defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_GENERATE) */
   7827              {
   7828                  (void) key_buffer_length;
   7829                  return PSA_ERROR_NOT_SUPPORTED;
   \                     ??psa_generate_key_internal_4: (+1)
   \       0x72   0xF07F 0x0085      MVNS     R0,#+133
   \       0x76   0xE000             B.N      ??psa_generate_key_internal_1
   7830              }
   7831          
   7832              return PSA_SUCCESS;
   \                     ??psa_generate_key_internal_3: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??psa_generate_key_internal_1: (+1)
   \       0x7A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   7833          }
   7834          

   \                                 In section .text, align 2, keep-with-next
   7835          psa_status_t psa_generate_key(const psa_key_attributes_t *attributes,
   7836                                        mbedtls_svc_key_id_t *key)
   7837          {
   \                     psa_generate_key: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000D             MOVS     R5,R1
   7838              psa_status_t status;
   7839              psa_key_slot_t *slot = NULL;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9001             STR      R0,[SP, #+4]
   7840              psa_se_drv_table_entry_t *driver = NULL;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9002             STR      R0,[SP, #+8]
   7841              size_t key_buffer_size;
   7842          
   7843              *key = MBEDTLS_SVC_KEY_ID_INIT;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x6028             STR      R0,[R5, #+0]
   7844          
   7845              /* Reject any attempt to create a zero-length key so that we don't
   7846               * risk tripping up later, e.g. on a malloc(0) that returns NULL. */
   7847              if (psa_get_key_bits(attributes) == 0) {
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0x.... 0x....      BL       psa_get_key_bits
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD102             BNE.N    ??psa_generate_key_0
   7848                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x1C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x20   0xE0B7             B.N      ??psa_generate_key_1
   7849              }
   7850          
   7851              /* Reject any attempt to create a public key. */
   7852              if (PSA_KEY_TYPE_IS_PUBLIC_KEY(attributes->core.type)) {
   \                     ??psa_generate_key_0: (+1)
   \       0x22   0x8830             LDRH     R0,[R6, #+0]
   \       0x24   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x28   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x2C   0xD102             BNE.N    ??psa_generate_key_2
   7853                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x2E   0xF07F 0x0086      MVNS     R0,#+134
   \       0x32   0xE0AE             B.N      ??psa_generate_key_1
   7854              }
   7855          
   7856              status = psa_start_key_creation(PSA_KEY_CREATION_GENERATE, attributes,
   7857                                              &slot, &driver);
   \                     ??psa_generate_key_2: (+1)
   \       0x34   0xAB02             ADD      R3,SP,#+8
   \       0x36   0xAA01             ADD      R2,SP,#+4
   \       0x38   0x0031             MOVS     R1,R6
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x.... 0x....      BL       psa_start_key_creation
   \       0x40   0x0004             MOVS     R4,R0
   7858              if (status != PSA_SUCCESS) {
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xF040 0x8096      BNE.W    ??psa_generate_key_3
   7859                  goto exit;
   7860              }
   7861          
   7862              /* In the case of a transparent key or an opaque key stored in local
   7863               * storage ( thus not in the case of generating a key in a secure element
   7864               * with storage ( MBEDTLS_PSA_CRYPTO_SE_C ) ),we have to allocate a
   7865               * buffer to hold the generated key material. */
   7866              if (slot->key.data == NULL) {
   \                     ??psa_generate_key_4: (+1)
   \       0x48   0x9801             LDR      R0,[SP, #+4]
   \       0x4A   0x6A40             LDR      R0,[R0, #+36]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xF040 0x8081      BNE.W    ??psa_generate_key_5
   7867                  if (PSA_KEY_LIFETIME_GET_LOCATION(attributes->core.lifetime) ==
   7868                      PSA_KEY_LOCATION_LOCAL_STORAGE) {
   \       0x52   0x6870             LDR      R0,[R6, #+4]
   \       0x54   0x0A00             LSRS     R0,R0,#+8
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD16E             BNE.N    ??psa_generate_key_6
   7869                      status = psa_validate_key_type_and_size_for_key_generation(
   7870                          attributes->core.type, attributes->core.bits);
   \       0x5A   0x8871             LDRH     R1,[R6, #+2]
   \       0x5C   0x8830             LDRH     R0,[R6, #+0]
   \       0x5E   0x.... 0x....      BL       psa_validate_key_type_and_size_for_key_generation
   \       0x62   0x0004             MOVS     R4,R0
   7871                      if (status != PSA_SUCCESS) {
   \       0x64   0x2C00             CMP      R4,#+0
   \       0x66   0xF040 0x8085      BNE.W    ??psa_generate_key_3
   7872                          goto exit;
   7873                      }
   7874          
   7875                      key_buffer_size = PSA_EXPORT_KEY_OUTPUT_SIZE(
   7876                          attributes->core.type,
   7877                          attributes->core.bits);
   \                     ??psa_generate_key_7: (+1)
   \       0x6A   0x8830             LDRH     R0,[R6, #+0]
   \       0x6C   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x70   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x74   0xD005             BEQ.N    ??psa_generate_key_8
   \       0x76   0x8830             LDRH     R0,[R6, #+0]
   \       0x78   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x7C   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x80   0xD104             BNE.N    ??psa_generate_key_9
   \                     ??psa_generate_key_8: (+1)
   \       0x82   0x8870             LDRH     R0,[R6, #+2]
   \       0x84   0x1DC0             ADDS     R0,R0,#+7
   \       0x86   0x08C0             LSRS     R0,R0,#+3
   \       0x88   0x9000             STR      R0,[SP, #+0]
   \       0x8A   0xE05C             B.N      ??psa_generate_key_10
   \                     ??psa_generate_key_9: (+1)
   \       0x8C   0x8831             LDRH     R1,[R6, #+0]
   \       0x8E   0x....             LDR.N    R0,??DataTable53_7
   \       0x90   0x4001             ANDS     R1,R0,R1
   \       0x92   0xF5B1 0x4F84      CMP      R1,#+16896
   \       0x96   0xD104             BNE.N    ??psa_generate_key_11
   \       0x98   0x8870             LDRH     R0,[R6, #+2]
   \       0x9A   0x1DC0             ADDS     R0,R0,#+7
   \       0x9C   0x08C0             LSRS     R0,R0,#+3
   \       0x9E   0x9000             STR      R0,[SP, #+0]
   \       0xA0   0xE051             B.N      ??psa_generate_key_10
   \                     ??psa_generate_key_11: (+1)
   \       0xA2   0x8831             LDRH     R1,[R6, #+0]
   \       0xA4   0xF247 0x0001      MOVW     R0,#+28673
   \       0xA8   0x4281             CMP      R1,R0
   \       0xAA   0xD108             BNE.N    ??psa_generate_key_12
   \       0xAC   0x8871             LDRH     R1,[R6, #+2]
   \       0xAE   0x0849             LSRS     R1,R1,#+1
   \       0xB0   0x1C49             ADDS     R1,R1,#+1
   \       0xB2   0x08C9             LSRS     R1,R1,#+3
   \       0xB4   0x2009             MOVS     R0,#+9
   \       0xB6   0x4341             MULS     R1,R0,R1
   \       0xB8   0x313B             ADDS     R1,R1,#+59
   \       0xBA   0x9100             STR      R1,[SP, #+0]
   \       0xBC   0xE043             B.N      ??psa_generate_key_10
   \                     ??psa_generate_key_12: (+1)
   \       0xBE   0x8830             LDRH     R0,[R6, #+0]
   \       0xC0   0xF244 0x0101      MOVW     R1,#+16385
   \       0xC4   0x4288             CMP      R0,R1
   \       0xC6   0xD104             BNE.N    ??psa_generate_key_13
   \       0xC8   0x8870             LDRH     R0,[R6, #+2]
   \       0xCA   0x08C0             LSRS     R0,R0,#+3
   \       0xCC   0x3010             ADDS     R0,R0,#+16
   \       0xCE   0x9000             STR      R0,[SP, #+0]
   \       0xD0   0xE039             B.N      ??psa_generate_key_10
   \                     ??psa_generate_key_13: (+1)
   \       0xD2   0x8830             LDRH     R0,[R6, #+0]
   \       0xD4   0xF247 0x0102      MOVW     R1,#+28674
   \       0xD8   0x4288             CMP      R0,R1
   \       0xDA   0xD106             BNE.N    ??psa_generate_key_14
   \       0xDC   0x8871             LDRH     R1,[R6, #+2]
   \       0xDE   0x08C9             LSRS     R1,R1,#+3
   \       0xE0   0x2003             MOVS     R0,#+3
   \       0xE2   0x4341             MULS     R1,R0,R1
   \       0xE4   0x315A             ADDS     R1,R1,#+90
   \       0xE6   0x9100             STR      R1,[SP, #+0]
   \       0xE8   0xE02D             B.N      ??psa_generate_key_10
   \                     ??psa_generate_key_14: (+1)
   \       0xEA   0x8830             LDRH     R0,[R6, #+0]
   \       0xEC   0xF244 0x0102      MOVW     R1,#+16386
   \       0xF0   0x4288             CMP      R0,R1
   \       0xF2   0xD106             BNE.N    ??psa_generate_key_15
   \       0xF4   0x8871             LDRH     R1,[R6, #+2]
   \       0xF6   0x08C9             LSRS     R1,R1,#+3
   \       0xF8   0x2003             MOVS     R0,#+3
   \       0xFA   0x4341             MULS     R1,R0,R1
   \       0xFC   0x314A             ADDS     R1,R1,#+74
   \       0xFE   0x9100             STR      R1,[SP, #+0]
   \      0x100   0xE021             B.N      ??psa_generate_key_10
   \                     ??psa_generate_key_15: (+1)
   \      0x102   0x8830             LDRH     R0,[R6, #+0]
   \      0x104   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \      0x108   0xF5B0 0x4FE2      CMP      R0,#+28928
   \      0x10C   0xD104             BNE.N    ??psa_generate_key_16
   \      0x10E   0x8870             LDRH     R0,[R6, #+2]
   \      0x110   0x1DC0             ADDS     R0,R0,#+7
   \      0x112   0x08C0             LSRS     R0,R0,#+3
   \      0x114   0x9000             STR      R0,[SP, #+0]
   \      0x116   0xE016             B.N      ??psa_generate_key_10
   \                     ??psa_generate_key_16: (+1)
   \      0x118   0x8830             LDRH     R0,[R6, #+0]
   \      0x11A   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \      0x11E   0xF5B0 0x4F82      CMP      R0,#+16640
   \      0x122   0xD106             BNE.N    ??psa_generate_key_17
   \      0x124   0x8870             LDRH     R0,[R6, #+2]
   \      0x126   0x1DC0             ADDS     R0,R0,#+7
   \      0x128   0x08C0             LSRS     R0,R0,#+3
   \      0x12A   0x0040             LSLS     R0,R0,#+1
   \      0x12C   0x1C40             ADDS     R0,R0,#+1
   \      0x12E   0x9000             STR      R0,[SP, #+0]
   \      0x130   0xE009             B.N      ??psa_generate_key_10
   \                     ??psa_generate_key_17: (+1)
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x9000             STR      R0,[SP, #+0]
   \      0x136   0xE006             B.N      ??psa_generate_key_10
   7878                  } else {
   7879                      status = psa_driver_wrapper_get_key_buffer_size(
   7880                          attributes, &key_buffer_size);
   \                     ??psa_generate_key_6: (+1)
   \      0x138   0x4669             MOV      R1,SP
   \      0x13A   0x0030             MOVS     R0,R6
   \      0x13C   0x.... 0x....      BL       psa_driver_wrapper_get_key_buffer_size
   \      0x140   0x0004             MOVS     R4,R0
   7881                      if (status != PSA_SUCCESS) {
   \      0x142   0x2C00             CMP      R4,#+0
   \      0x144   0xD116             BNE.N    ??psa_generate_key_3
   7882                          goto exit;
   7883                      }
   7884                  }
   7885          
   7886                  status = psa_allocate_buffer_to_slot(slot, key_buffer_size);
   \                     ??psa_generate_key_10: (+1)
   \      0x146   0x9900             LDR      R1,[SP, #+0]
   \      0x148   0x9801             LDR      R0,[SP, #+4]
   \      0x14A   0x.... 0x....      BL       psa_allocate_buffer_to_slot
   \      0x14E   0x0004             MOVS     R4,R0
   7887                  if (status != PSA_SUCCESS) {
   \      0x150   0x2C00             CMP      R4,#+0
   \      0x152   0xD10F             BNE.N    ??psa_generate_key_3
   7888                      goto exit;
   7889                  }
   7890              }
   7891          
   7892              status = psa_driver_wrapper_generate_key(attributes,
   7893                                                       slot->key.data, slot->key.bytes, &slot->key.bytes);
   \                     ??psa_generate_key_5: (+1)
   \      0x154   0x9801             LDR      R0,[SP, #+4]
   \      0x156   0xF110 0x0328      ADDS     R3,R0,#+40
   \      0x15A   0x9801             LDR      R0,[SP, #+4]
   \      0x15C   0x6A82             LDR      R2,[R0, #+40]
   \      0x15E   0x9801             LDR      R0,[SP, #+4]
   \      0x160   0x6A41             LDR      R1,[R0, #+36]
   \      0x162   0x0030             MOVS     R0,R6
   \      0x164   0x.... 0x....      BL       psa_driver_wrapper_generate_key
   \      0x168   0x0004             MOVS     R4,R0
   7894          
   7895              if (status != PSA_SUCCESS) {
   \      0x16A   0x2C00             CMP      R4,#+0
   \      0x16C   0xD002             BEQ.N    ??psa_generate_key_3
   7896                  psa_remove_key_data_from_memory(slot);
   \      0x16E   0x9801             LDR      R0,[SP, #+4]
   \      0x170   0x.... 0x....      BL       psa_remove_key_data_from_memory
   7897              }
   7898          
   7899          exit:
   7900              if (status == PSA_SUCCESS) {
   \                     ??psa_generate_key_3: (+1)
   \      0x174   0x2C00             CMP      R4,#+0
   \      0x176   0xD105             BNE.N    ??psa_generate_key_18
   7901                  status = psa_finish_key_creation(slot, driver, key);
   \      0x178   0x002A             MOVS     R2,R5
   \      0x17A   0x9902             LDR      R1,[SP, #+8]
   \      0x17C   0x9801             LDR      R0,[SP, #+4]
   \      0x17E   0x.... 0x....      BL       psa_finish_key_creation
   \      0x182   0x0004             MOVS     R4,R0
   7902              }
   7903              if (status != PSA_SUCCESS) {
   \                     ??psa_generate_key_18: (+1)
   \      0x184   0x2C00             CMP      R4,#+0
   \      0x186   0xD003             BEQ.N    ??psa_generate_key_19
   7904                  psa_fail_key_creation(slot, driver);
   \      0x188   0x9902             LDR      R1,[SP, #+8]
   \      0x18A   0x9801             LDR      R0,[SP, #+4]
   \      0x18C   0x.... 0x....      BL       psa_fail_key_creation
   7905              }
   7906          
   7907              return status;
   \                     ??psa_generate_key_19: (+1)
   \      0x190   0x0020             MOVS     R0,R4
   \                     ??psa_generate_key_1: (+1)
   \      0x192   0xB004             ADD      SP,SP,#+16
   \      0x194   0xBD70             POP      {R4-R6,PC}
   7908          }
   7909          
   7910          /****************************************************************/
   7911          /* Module setup */
   7912          /****************************************************************/
   7913          
   7914          #if !defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
   7915          psa_status_t mbedtls_psa_crypto_configure_entropy_sources(
   7916              void (* entropy_init)(mbedtls_entropy_context *ctx),
   7917              void (* entropy_free)(mbedtls_entropy_context *ctx))
   7918          {
   7919              if (global_data.rng_state != RNG_NOT_INITIALIZED) {
   7920                  return PSA_ERROR_BAD_STATE;
   7921              }
   7922              global_data.rng.entropy_init = entropy_init;
   7923              global_data.rng.entropy_free = entropy_free;
   7924              return PSA_SUCCESS;
   7925          }
   7926          #endif /* !defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) */
   7927          

   \                                 In section .text, align 2, keep-with-next
   7928          void mbedtls_psa_crypto_free(void)
   7929          {
   \                     mbedtls_psa_crypto_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   7930              psa_wipe_all_key_slots();
   \        0x2   0x.... 0x....      BL       psa_wipe_all_key_slots
   7931              if (global_data.rng_state != RNG_NOT_INITIALIZED) {
   \        0x6   0x....             LDR.N    R4,??DataTable53_6
   \        0x8   0x7860             LDRB     R0,[R4, #+1]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD002             BEQ.N    ??mbedtls_psa_crypto_free_0
   7932                  mbedtls_psa_random_free(&global_data.rng);
   \        0xE   0x1D20             ADDS     R0,R4,#+4
   \       0x10   0x.... 0x....      BL       mbedtls_psa_random_free
   7933              }
   7934              /* Wipe all remaining data, including configuration.
   7935               * In particular, this sets all state indicator to the value
   7936               * indicating "uninitialized". */
   7937              mbedtls_platform_zeroize(&global_data, sizeof(global_data));
   \                     ??mbedtls_psa_crypto_free_0: (+1)
   \       0x14   0x210C             MOVS     R1,#+12
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_platform_zeroize
   7938          
   7939              /* Terminate drivers */
   7940              psa_driver_wrapper_free();
   \       0x1C   0x.... 0x....      BL       psa_driver_wrapper_free
   7941          }
   \       0x20   0xBD10             POP      {R4,PC}
   7942          
   7943          #if defined(PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS)
   7944          /** Recover a transaction that was interrupted by a power failure.
   7945           *
   7946           * This function is called during initialization, before psa_crypto_init()
   7947           * returns. If this function returns a failure status, the initialization
   7948           * fails.
   7949           */
   7950          static psa_status_t psa_crypto_recover_transaction(
   7951              const psa_crypto_transaction_t *transaction)
   7952          {
   7953              switch (transaction->unknown.type) {
   7954                  case PSA_CRYPTO_TRANSACTION_CREATE_KEY:
   7955                  case PSA_CRYPTO_TRANSACTION_DESTROY_KEY:
   7956                  /* TODO - fall through to the failure case until this
   7957                   * is implemented.
   7958                   * https://github.com/ARMmbed/mbed-crypto/issues/218
   7959                   */
   7960                  default:
   7961                      /* We found an unsupported transaction in the storage.
   7962                       * We don't know what state the storage is in. Give up. */
   7963                      return PSA_ERROR_DATA_INVALID;
   7964              }
   7965          }
   7966          #endif /* PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS */
   7967          

   \                                 In section .text, align 2, keep-with-next
   7968          psa_status_t psa_crypto_init(void)
   7969          {
   \                     psa_crypto_init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   7970              psa_status_t status;
   7971          
   7972              /* Double initialization is explicitly allowed. */
   7973              if (global_data.initialized != 0) {
   \        0x2   0x....             LDR.N    R5,??DataTable53_6
   \        0x4   0x7828             LDRB     R0,[R5, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??psa_crypto_init_0
   7974                  return PSA_SUCCESS;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE020             B.N      ??psa_crypto_init_1
   7975              }
   7976          
   7977              /* Init drivers */
   7978              status = psa_driver_wrapper_init();
   \                     ??psa_crypto_init_0: (+1)
   \        0xE   0x.... 0x....      BL       psa_driver_wrapper_init
   \       0x12   0x0004             MOVS     R4,R0
   7979              if (status != PSA_SUCCESS) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD116             BNE.N    ??psa_crypto_init_2
   7980                  goto exit;
   7981              }
   7982              global_data.drivers_initialized = 1;
   \                     ??psa_crypto_init_3: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x70A8             STRB     R0,[R5, #+2]
   7983          
   7984              /* Initialize and seed the random generator. */
   7985              mbedtls_psa_random_init(&global_data.rng);
   \       0x1C   0x1D2E             ADDS     R6,R5,#+4
   \       0x1E   0x0030             MOVS     R0,R6
   \       0x20   0x.... 0x....      BL       mbedtls_psa_random_init
   7986              global_data.rng_state = RNG_INITIALIZED;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x7068             STRB     R0,[R5, #+1]
   7987              status = mbedtls_psa_random_seed(&global_data.rng);
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0x.... 0x....      BL       mbedtls_psa_random_seed
   \       0x2E   0x0004             MOVS     R4,R0
   7988              if (status != PSA_SUCCESS) {
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD108             BNE.N    ??psa_crypto_init_2
   7989                  goto exit;
   7990              }
   7991              global_data.rng_state = RNG_SEEDED;
   \                     ??psa_crypto_init_4: (+1)
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0x7068             STRB     R0,[R5, #+1]
   7992          
   7993              status = psa_initialize_key_slots();
   \       0x38   0x.... 0x....      BL       psa_initialize_key_slots
   \       0x3C   0x0004             MOVS     R4,R0
   7994              if (status != PSA_SUCCESS) {
   \       0x3E   0x2C00             CMP      R4,#+0
   \       0x40   0xD101             BNE.N    ??psa_crypto_init_2
   7995                  goto exit;
   7996              }
   7997          
   7998          #if defined(PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS)
   7999              status = psa_crypto_load_transaction();
   8000              if (status == PSA_SUCCESS) {
   8001                  status = psa_crypto_recover_transaction(&psa_crypto_transaction);
   8002                  if (status != PSA_SUCCESS) {
   8003                      goto exit;
   8004                  }
   8005                  status = psa_crypto_stop_transaction();
   8006              } else if (status == PSA_ERROR_DOES_NOT_EXIST) {
   8007                  /* There's no transaction to complete. It's all good. */
   8008                  status = PSA_SUCCESS;
   8009              }
   8010          #endif /* PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS */
   8011          
   8012              /* All done. */
   8013              global_data.initialized = 1;
   \                     ??psa_crypto_init_5: (+1)
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0x7028             STRB     R0,[R5, #+0]
   8014          
   8015          exit:
   8016              if (status != PSA_SUCCESS) {
   \                     ??psa_crypto_init_2: (+1)
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD001             BEQ.N    ??psa_crypto_init_6
   8017                  mbedtls_psa_crypto_free();
   \       0x4A   0x.... 0x....      BL       mbedtls_psa_crypto_free
   8018              }
   8019              return status;
   \                     ??psa_crypto_init_6: (+1)
   \       0x4E   0x0020             MOVS     R0,R4
   \                     ??psa_crypto_init_1: (+1)
   \       0x50   0xBD70             POP      {R4-R6,PC}
   8020          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0xFFFF'9C80        DC32     0xffff9c80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x7FC0'0000        DC32     0x7fc00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x0600'0300        DC32     0x6000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x0600'1300        DC32     0x6001300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x0600'0200        DC32     0x6000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x0600'0900        DC32     0x6000900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x0600'0400        DC32     0x6000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x0200'00FF        DC32     0x20000ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x0200'0003        DC32     0x2000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x0200'0004        DC32     0x2000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x0200'0005        DC32     0x2000005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0200'0008        DC32     0x2000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x0200'0009        DC32     0x2000009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x0200'000A        DC32     0x200000a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x0200'000B        DC32     0x200000b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x0200'000C        DC32     0x200000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x0200'000D        DC32     0x200000d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x0200'0010        DC32     0x2000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x0200'0011        DC32     0x2000011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x0200'0012        DC32     0x2000012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x0200'0013        DC32     0x2000013

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     mbedtls_psa_slots_mutex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x....'....        DC32     mbedtls_mutex_lock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     mbedtls_mutex_unlock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0xFFFF'00FC        DC32     0xffff00fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x7FC0'0000        DC32     0x7fc00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x0200'0003        DC32     0x2000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x0200'0004        DC32     0x2000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x0200'0005        DC32     0x2000005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \        0x0   0x0200'0008        DC32     0x2000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \        0x0   0x0200'0009        DC32     0x2000009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \        0x0   0x0200'000A        DC32     0x200000a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \        0x0   0x0200'000B        DC32     0x200000b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \        0x0   0x0200'000C        DC32     0x200000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \        0x0   0x0200'000D        DC32     0x200000d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x0200'0010        DC32     0x2000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x0200'0011        DC32     0x2000011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x0200'0012        DC32     0x2000012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0x0200'0013        DC32     0x2000013

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x0600'0300        DC32     0x6000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x0600'1300        DC32     0x6001300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \        0x0   0x0600'0200        DC32     0x6000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \        0x0   0x0600'0900        DC32     0x6000900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \        0x0   0x0600'0400        DC32     0x6000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \        0x0   0x0600'0800        DC32     0x6000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \        0x0   0x0700'0300        DC32     0x7000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x....'....        DC32     psa_interruptible_max_ops

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \        0x0   0x0440'4400        DC32     0x4404400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \        0x0   0x04C0'1000        DC32     0x4c01000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \        0x0   0x04C0'1100        DC32     0x4c01100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \        0x0   0x04C0'1200        DC32     0x4c01200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \        0x0   0x0440'FF00        DC32     0x440ff00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \        0x0   0x0440'4000        DC32     0x4404000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_6:
   \        0x0   0x0440'4100        DC32     0x4404100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_7:
   \        0x0   0x0480'0100        DC32     0x4800100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \        0x0   0x04C0'1300        DC32     0x4c01300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0x0540'0100        DC32     0x5400100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \        0x0   0x0550'0100        DC32     0x5500100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \        0x0   0x0540'0200        DC32     0x5400200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_3:
   \        0x0   0x0550'0200        DC32     0x5500200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_4:
   \        0x0   0x0510'0500        DC32     0x5100500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_5:
   \        0x0   0x0600'0300        DC32     0x6000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_6:
   \        0x0   0x0600'1300        DC32     0x6001300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_7:
   \        0x0   0x0600'0200        DC32     0x6000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_8:
   \        0x0   0x0600'0900        DC32     0x6000900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \        0x0   0x0600'0400        DC32     0x6000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \        0x0   0x0200'00FF        DC32     0x20000ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44:
   \        0x0   0x0200'0003        DC32     0x2000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_1:
   \        0x0   0x0200'0004        DC32     0x2000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_2:
   \        0x0   0x0200'0005        DC32     0x2000005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_3:
   \        0x0   0x0200'0008        DC32     0x2000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_4:
   \        0x0   0x0200'0009        DC32     0x2000009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_5:
   \        0x0   0x0200'000A        DC32     0x200000a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_6:
   \        0x0   0x0200'000B        DC32     0x200000b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_7:
   \        0x0   0x0200'000C        DC32     0x200000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_8:
   \        0x0   0x0200'000D        DC32     0x200000d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_9:
   \        0x0   0x0200'0010        DC32     0x2000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_10:
   \        0x0   0x0200'0011        DC32     0x2000011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_11:
   \        0x0   0x0200'0012        DC32     0x2000012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_12:
   \        0x0   0x0200'0013        DC32     0x2000013

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_13:
   \        0x0   0x0800'0200        DC32     0x8000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_14:
   \        0x0   0x0800'0300        DC32     0x8000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \        0x0   0x0800'0609        DC32     0x8000609

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_1:
   \        0x0   0x0880'0200        DC32     0x8800200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_2:
   \        0x0   0x0902'0000        DC32     0x9020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_3:
   \        0x0   0x0800'0200        DC32     0x8000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_4:
   \        0x0   0x0800'0100        DC32     0x8000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_5:
   \        0x0   0x0880'0100        DC32     0x8800100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_6:
   \        0x0   0x....'....        DC32     global_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_7:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00
   8021          
   8022          #if defined(PSA_WANT_ALG_SOME_PAKE)
   8023          psa_status_t psa_crypto_driver_pake_get_password_len(
   8024              const psa_crypto_driver_pake_inputs_t *inputs,
   8025              size_t *password_len)
   8026          {
   8027              if (inputs->password_len == 0) {
   8028                  return PSA_ERROR_BAD_STATE;
   8029              }
   8030          
   8031              *password_len = inputs->password_len;
   8032          
   8033              return PSA_SUCCESS;
   8034          }
   8035          
   8036          psa_status_t psa_crypto_driver_pake_get_password(
   8037              const psa_crypto_driver_pake_inputs_t *inputs,
   8038              uint8_t *buffer, size_t buffer_size, size_t *buffer_length)
   8039          {
   8040              if (inputs->password_len == 0) {
   8041                  return PSA_ERROR_BAD_STATE;
   8042              }
   8043          
   8044              if (buffer_size < inputs->password_len) {
   8045                  return PSA_ERROR_BUFFER_TOO_SMALL;
   8046              }
   8047          
   8048              memcpy(buffer, inputs->password, inputs->password_len);
   8049              *buffer_length = inputs->password_len;
   8050          
   8051              return PSA_SUCCESS;
   8052          }
   8053          
   8054          psa_status_t psa_crypto_driver_pake_get_user_len(
   8055              const psa_crypto_driver_pake_inputs_t *inputs,
   8056              size_t *user_len)
   8057          {
   8058              if (inputs->user_len == 0) {
   8059                  return PSA_ERROR_BAD_STATE;
   8060              }
   8061          
   8062              *user_len = inputs->user_len;
   8063          
   8064              return PSA_SUCCESS;
   8065          }
   8066          
   8067          psa_status_t psa_crypto_driver_pake_get_user(
   8068              const psa_crypto_driver_pake_inputs_t *inputs,
   8069              uint8_t *user_id, size_t user_id_size, size_t *user_id_len)
   8070          {
   8071              if (inputs->user_len == 0) {
   8072                  return PSA_ERROR_BAD_STATE;
   8073              }
   8074          
   8075              if (user_id_size < inputs->user_len) {
   8076                  return PSA_ERROR_BUFFER_TOO_SMALL;
   8077              }
   8078          
   8079              memcpy(user_id, inputs->user, inputs->user_len);
   8080              *user_id_len = inputs->user_len;
   8081          
   8082              return PSA_SUCCESS;
   8083          }
   8084          
   8085          psa_status_t psa_crypto_driver_pake_get_peer_len(
   8086              const psa_crypto_driver_pake_inputs_t *inputs,
   8087              size_t *peer_len)
   8088          {
   8089              if (inputs->peer_len == 0) {
   8090                  return PSA_ERROR_BAD_STATE;
   8091              }
   8092          
   8093              *peer_len = inputs->peer_len;
   8094          
   8095              return PSA_SUCCESS;
   8096          }
   8097          
   8098          psa_status_t psa_crypto_driver_pake_get_peer(
   8099              const psa_crypto_driver_pake_inputs_t *inputs,
   8100              uint8_t *peer_id, size_t peer_id_size, size_t *peer_id_length)
   8101          {
   8102              if (inputs->peer_len == 0) {
   8103                  return PSA_ERROR_BAD_STATE;
   8104              }
   8105          
   8106              if (peer_id_size < inputs->peer_len) {
   8107                  return PSA_ERROR_BUFFER_TOO_SMALL;
   8108              }
   8109          
   8110              memcpy(peer_id, inputs->peer, inputs->peer_len);
   8111              *peer_id_length = inputs->peer_len;
   8112          
   8113              return PSA_SUCCESS;
   8114          }
   8115          
   8116          psa_status_t psa_crypto_driver_pake_get_cipher_suite(
   8117              const psa_crypto_driver_pake_inputs_t *inputs,
   8118              psa_pake_cipher_suite_t *cipher_suite)
   8119          {
   8120              if (inputs->cipher_suite.algorithm == PSA_ALG_NONE) {
   8121                  return PSA_ERROR_BAD_STATE;
   8122              }
   8123          
   8124              *cipher_suite = inputs->cipher_suite;
   8125          
   8126              return PSA_SUCCESS;
   8127          }
   8128          
   8129          psa_status_t psa_pake_setup(
   8130              psa_pake_operation_t *operation,
   8131              const psa_pake_cipher_suite_t *cipher_suite)
   8132          {
   8133              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8134          
   8135              if (operation->stage != PSA_PAKE_OPERATION_STAGE_SETUP) {
   8136                  status = PSA_ERROR_BAD_STATE;
   8137                  goto exit;
   8138              }
   8139          
   8140              if (PSA_ALG_IS_PAKE(cipher_suite->algorithm) == 0 ||
   8141                  PSA_ALG_IS_HASH(cipher_suite->hash) == 0) {
   8142                  status = PSA_ERROR_INVALID_ARGUMENT;
   8143                  goto exit;
   8144              }
   8145          
   8146              memset(&operation->data.inputs, 0, sizeof(operation->data.inputs));
   8147          
   8148              operation->alg = cipher_suite->algorithm;
   8149              operation->primitive = PSA_PAKE_PRIMITIVE(cipher_suite->type,
   8150                                                        cipher_suite->family, cipher_suite->bits);
   8151              operation->data.inputs.cipher_suite = *cipher_suite;
   8152          
   8153          #if defined(PSA_WANT_ALG_JPAKE)
   8154              if (operation->alg == PSA_ALG_JPAKE) {
   8155                  psa_jpake_computation_stage_t *computation_stage =
   8156                      &operation->computation_stage.jpake;
   8157          
   8158                  memset(computation_stage, 0, sizeof(*computation_stage));
   8159                  computation_stage->step = PSA_PAKE_STEP_KEY_SHARE;
   8160              } else
   8161          #endif /* PSA_WANT_ALG_JPAKE */
   8162              {
   8163                  status = PSA_ERROR_NOT_SUPPORTED;
   8164                  goto exit;
   8165              }
   8166          
   8167              operation->stage = PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS;
   8168          
   8169              return PSA_SUCCESS;
   8170          exit:
   8171              psa_pake_abort(operation);
   8172              return status;
   8173          }
   8174          
   8175          psa_status_t psa_pake_set_password_key(
   8176              psa_pake_operation_t *operation,
   8177              mbedtls_svc_key_id_t password)
   8178          {
   8179              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8180              psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
   8181              psa_key_slot_t *slot = NULL;
   8182              psa_key_attributes_t attributes;
   8183              psa_key_type_t type;
   8184          
   8185              if (operation->stage != PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS) {
   8186                  status = PSA_ERROR_BAD_STATE;
   8187                  goto exit;
   8188              }
   8189          
   8190              status = psa_get_and_lock_key_slot_with_policy(password, &slot,
   8191                                                             PSA_KEY_USAGE_DERIVE,
   8192                                                             operation->alg);
   8193              if (status != PSA_SUCCESS) {
   8194                  goto exit;
   8195              }
   8196          
   8197              attributes = (psa_key_attributes_t) {
   8198                  .core = slot->attr
   8199              };
   8200          
   8201              type = psa_get_key_type(&attributes);
   8202          
   8203              if (type != PSA_KEY_TYPE_PASSWORD &&
   8204                  type != PSA_KEY_TYPE_PASSWORD_HASH) {
   8205                  status = PSA_ERROR_INVALID_ARGUMENT;
   8206                  goto exit;
   8207              }
   8208          
   8209              operation->data.inputs.password = mbedtls_calloc(1, slot->key.bytes);
   8210              if (operation->data.inputs.password == NULL) {
   8211                  status = PSA_ERROR_INSUFFICIENT_MEMORY;
   8212                  goto exit;
   8213              }
   8214          
   8215              memcpy(operation->data.inputs.password, slot->key.data, slot->key.bytes);
   8216              operation->data.inputs.password_len = slot->key.bytes;
   8217              operation->data.inputs.attributes = attributes;
   8218          exit:
   8219              if (status != PSA_SUCCESS) {
   8220                  psa_pake_abort(operation);
   8221              }
   8222              unlock_status = psa_unlock_key_slot(slot);
   8223              return (status == PSA_SUCCESS) ? unlock_status : status;
   8224          }
   8225          
   8226          psa_status_t psa_pake_set_user(
   8227              psa_pake_operation_t *operation,
   8228              const uint8_t *user_id,
   8229              size_t user_id_len)
   8230          {
   8231              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8232          
   8233              if (operation->stage != PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS) {
   8234                  status = PSA_ERROR_BAD_STATE;
   8235                  goto exit;
   8236              }
   8237          
   8238              if (user_id_len == 0) {
   8239                  status = PSA_ERROR_INVALID_ARGUMENT;
   8240                  goto exit;
   8241              }
   8242          
   8243              if (operation->data.inputs.user_len != 0) {
   8244                  status = PSA_ERROR_BAD_STATE;
   8245                  goto exit;
   8246              }
   8247          
   8248              operation->data.inputs.user = mbedtls_calloc(1, user_id_len);
   8249              if (operation->data.inputs.user == NULL) {
   8250                  status = PSA_ERROR_INSUFFICIENT_MEMORY;
   8251                  goto exit;
   8252              }
   8253          
   8254              memcpy(operation->data.inputs.user, user_id, user_id_len);
   8255              operation->data.inputs.user_len = user_id_len;
   8256          
   8257              return PSA_SUCCESS;
   8258          exit:
   8259              psa_pake_abort(operation);
   8260              return status;
   8261          }
   8262          
   8263          psa_status_t psa_pake_set_peer(
   8264              psa_pake_operation_t *operation,
   8265              const uint8_t *peer_id,
   8266              size_t peer_id_len)
   8267          {
   8268              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8269          
   8270              if (operation->stage != PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS) {
   8271                  status = PSA_ERROR_BAD_STATE;
   8272                  goto exit;
   8273              }
   8274          
   8275              if (peer_id_len == 0) {
   8276                  status = PSA_ERROR_INVALID_ARGUMENT;
   8277                  goto exit;
   8278              }
   8279          
   8280              if (operation->data.inputs.peer_len != 0) {
   8281                  status = PSA_ERROR_BAD_STATE;
   8282                  goto exit;
   8283              }
   8284          
   8285              operation->data.inputs.peer = mbedtls_calloc(1, peer_id_len);
   8286              if (operation->data.inputs.peer == NULL) {
   8287                  status = PSA_ERROR_INSUFFICIENT_MEMORY;
   8288                  goto exit;
   8289              }
   8290          
   8291              memcpy(operation->data.inputs.peer, peer_id, peer_id_len);
   8292              operation->data.inputs.peer_len = peer_id_len;
   8293          
   8294              return PSA_SUCCESS;
   8295          exit:
   8296              psa_pake_abort(operation);
   8297              return status;
   8298          }
   8299          
   8300          psa_status_t psa_pake_set_role(
   8301              psa_pake_operation_t *operation,
   8302              psa_pake_role_t role)
   8303          {
   8304              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8305          
   8306              if (operation->stage != PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS) {
   8307                  status = PSA_ERROR_BAD_STATE;
   8308                  goto exit;
   8309              }
   8310          
   8311              switch (operation->alg) {
   8312          #if defined(PSA_WANT_ALG_JPAKE)
   8313                  case PSA_ALG_JPAKE:
   8314                      if (role == PSA_PAKE_ROLE_NONE) {
   8315                          return PSA_SUCCESS;
   8316                      }
   8317                      status = PSA_ERROR_INVALID_ARGUMENT;
   8318                      break;
   8319          #endif
   8320                  default:
   8321                      (void) role;
   8322                      status = PSA_ERROR_NOT_SUPPORTED;
   8323                      goto exit;
   8324              }
   8325          exit:
   8326              psa_pake_abort(operation);
   8327              return status;
   8328          }
   8329          
   8330          /* Auxiliary function to convert core computation stage to single driver step. */
   8331          #if defined(PSA_WANT_ALG_JPAKE)
   8332          static psa_crypto_driver_pake_step_t convert_jpake_computation_stage_to_driver_step(
   8333              psa_jpake_computation_stage_t *stage)
   8334          {
   8335              psa_crypto_driver_pake_step_t key_share_step;
   8336              if (stage->round == PSA_JPAKE_FIRST) {
   8337                  int is_x1;
   8338          
   8339                  if (stage->io_mode == PSA_JPAKE_OUTPUT) {
   8340                      is_x1 = (stage->outputs < 1);
   8341                  } else {
   8342                      is_x1 = (stage->inputs < 1);
   8343                  }
   8344          
   8345                  key_share_step = is_x1 ?
   8346                                   PSA_JPAKE_X1_STEP_KEY_SHARE :
   8347                                   PSA_JPAKE_X2_STEP_KEY_SHARE;
   8348              } else if (stage->round == PSA_JPAKE_SECOND) {
   8349                  key_share_step = (stage->io_mode == PSA_JPAKE_OUTPUT) ?
   8350                                   PSA_JPAKE_X2S_STEP_KEY_SHARE :
   8351                                   PSA_JPAKE_X4S_STEP_KEY_SHARE;
   8352              } else {
   8353                  return PSA_JPAKE_STEP_INVALID;
   8354              }
   8355              return (psa_crypto_driver_pake_step_t) (key_share_step + stage->step - PSA_PAKE_STEP_KEY_SHARE);
   8356          }
   8357          #endif /* PSA_WANT_ALG_JPAKE */
   8358          
   8359          static psa_status_t psa_pake_complete_inputs(
   8360              psa_pake_operation_t *operation)
   8361          {
   8362              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8363              /* Create copy of the inputs on stack as inputs share memory
   8364                 with the driver context which will be setup by the driver. */
   8365              psa_crypto_driver_pake_inputs_t inputs = operation->data.inputs;
   8366          
   8367              if (inputs.password_len == 0) {
   8368                  return PSA_ERROR_BAD_STATE;
   8369              }
   8370          
   8371              if (operation->alg == PSA_ALG_JPAKE) {
   8372                  if (inputs.user_len == 0 || inputs.peer_len == 0) {
   8373                      return PSA_ERROR_BAD_STATE;
   8374                  }
   8375              }
   8376          
   8377              /* Clear driver context */
   8378              mbedtls_platform_zeroize(&operation->data, sizeof(operation->data));
   8379          
   8380              status = psa_driver_wrapper_pake_setup(operation, &inputs);
   8381          
   8382              /* Driver is responsible for creating its own copy of the password. */
   8383              mbedtls_zeroize_and_free(inputs.password, inputs.password_len);
   8384          
   8385              /* User and peer are translated to role. */
   8386              mbedtls_free(inputs.user);
   8387              mbedtls_free(inputs.peer);
   8388          
   8389              if (status == PSA_SUCCESS) {
   8390          #if defined(PSA_WANT_ALG_JPAKE)
   8391                  if (operation->alg == PSA_ALG_JPAKE) {
   8392                      operation->stage = PSA_PAKE_OPERATION_STAGE_COMPUTATION;
   8393                  } else
   8394          #endif /* PSA_WANT_ALG_JPAKE */
   8395                  {
   8396                      status = PSA_ERROR_NOT_SUPPORTED;
   8397                  }
   8398              }
   8399              return status;
   8400          }
   8401          
   8402          #if defined(PSA_WANT_ALG_JPAKE)
   8403          static psa_status_t psa_jpake_prologue(
   8404              psa_pake_operation_t *operation,
   8405              psa_pake_step_t step,
   8406              psa_jpake_io_mode_t io_mode)
   8407          {
   8408              if (step != PSA_PAKE_STEP_KEY_SHARE &&
   8409                  step != PSA_PAKE_STEP_ZK_PUBLIC &&
   8410                  step != PSA_PAKE_STEP_ZK_PROOF) {
   8411                  return PSA_ERROR_INVALID_ARGUMENT;
   8412              }
   8413          
   8414              psa_jpake_computation_stage_t *computation_stage =
   8415                  &operation->computation_stage.jpake;
   8416          
   8417              if (computation_stage->round != PSA_JPAKE_FIRST &&
   8418                  computation_stage->round != PSA_JPAKE_SECOND) {
   8419                  return PSA_ERROR_BAD_STATE;
   8420              }
   8421          
   8422              /* Check that the step we are given is the one we were expecting */
   8423              if (step != computation_stage->step) {
   8424                  return PSA_ERROR_BAD_STATE;
   8425              }
   8426          
   8427              if (step == PSA_PAKE_STEP_KEY_SHARE &&
   8428                  computation_stage->inputs == 0 &&
   8429                  computation_stage->outputs == 0) {
   8430                  /* Start of the round, so function decides whether we are inputting
   8431                   * or outputting */
   8432                  computation_stage->io_mode = io_mode;
   8433              } else if (computation_stage->io_mode != io_mode) {
   8434                  /* Middle of the round so the mode we are in must match the function
   8435                   * called by the user */
   8436                  return PSA_ERROR_BAD_STATE;
   8437              }
   8438          
   8439              return PSA_SUCCESS;
   8440          }
   8441          
   8442          static psa_status_t psa_jpake_epilogue(
   8443              psa_pake_operation_t *operation,
   8444              psa_jpake_io_mode_t io_mode)
   8445          {
   8446              psa_jpake_computation_stage_t *stage =
   8447                  &operation->computation_stage.jpake;
   8448          
   8449              if (stage->step == PSA_PAKE_STEP_ZK_PROOF) {
   8450                  /* End of an input/output */
   8451                  if (io_mode == PSA_JPAKE_INPUT) {
   8452                      stage->inputs++;
   8453                      if (stage->inputs == PSA_JPAKE_EXPECTED_INPUTS(stage->round)) {
   8454                          stage->io_mode = PSA_JPAKE_OUTPUT;
   8455                      }
   8456                  }
   8457                  if (io_mode == PSA_JPAKE_OUTPUT) {
   8458                      stage->outputs++;
   8459                      if (stage->outputs == PSA_JPAKE_EXPECTED_OUTPUTS(stage->round)) {
   8460                          stage->io_mode = PSA_JPAKE_INPUT;
   8461                      }
   8462                  }
   8463                  if (stage->inputs == PSA_JPAKE_EXPECTED_INPUTS(stage->round) &&
   8464                      stage->outputs == PSA_JPAKE_EXPECTED_OUTPUTS(stage->round)) {
   8465                      /* End of a round, move to the next round */
   8466                      stage->inputs = 0;
   8467                      stage->outputs = 0;
   8468                      stage->round++;
   8469                  }
   8470                  stage->step = PSA_PAKE_STEP_KEY_SHARE;
   8471              } else {
   8472                  stage->step++;
   8473              }
   8474              return PSA_SUCCESS;
   8475          }
   8476          
   8477          #endif /* PSA_WANT_ALG_JPAKE */
   8478          
   8479          psa_status_t psa_pake_output(
   8480              psa_pake_operation_t *operation,
   8481              psa_pake_step_t step,
   8482              uint8_t *output,
   8483              size_t output_size,
   8484              size_t *output_length)
   8485          {
   8486              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8487              psa_crypto_driver_pake_step_t driver_step = PSA_JPAKE_STEP_INVALID;
   8488              *output_length = 0;
   8489          
   8490              if (operation->stage == PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS) {
   8491                  status = psa_pake_complete_inputs(operation);
   8492                  if (status != PSA_SUCCESS) {
   8493                      goto exit;
   8494                  }
   8495              }
   8496          
   8497              if (operation->stage != PSA_PAKE_OPERATION_STAGE_COMPUTATION) {
   8498                  status = PSA_ERROR_BAD_STATE;
   8499                  goto exit;
   8500              }
   8501          
   8502              if (output_size == 0) {
   8503                  status = PSA_ERROR_INVALID_ARGUMENT;
   8504                  goto exit;
   8505              }
   8506          
   8507              switch (operation->alg) {
   8508          #if defined(PSA_WANT_ALG_JPAKE)
   8509                  case PSA_ALG_JPAKE:
   8510                      status = psa_jpake_prologue(operation, step, PSA_JPAKE_OUTPUT);
   8511                      if (status != PSA_SUCCESS) {
   8512                          goto exit;
   8513                      }
   8514                      driver_step = convert_jpake_computation_stage_to_driver_step(
   8515                          &operation->computation_stage.jpake);
   8516                      break;
   8517          #endif /* PSA_WANT_ALG_JPAKE */
   8518                  default:
   8519                      (void) step;
   8520                      status = PSA_ERROR_NOT_SUPPORTED;
   8521                      goto exit;
   8522              }
   8523          
   8524              status = psa_driver_wrapper_pake_output(operation, driver_step,
   8525                                                      output, output_size, output_length);
   8526          
   8527              if (status != PSA_SUCCESS) {
   8528                  goto exit;
   8529              }
   8530          
   8531              switch (operation->alg) {
   8532          #if defined(PSA_WANT_ALG_JPAKE)
   8533                  case PSA_ALG_JPAKE:
   8534                      status = psa_jpake_epilogue(operation, PSA_JPAKE_OUTPUT);
   8535                      if (status != PSA_SUCCESS) {
   8536                          goto exit;
   8537                      }
   8538                      break;
   8539          #endif /* PSA_WANT_ALG_JPAKE */
   8540                  default:
   8541                      status = PSA_ERROR_NOT_SUPPORTED;
   8542                      goto exit;
   8543              }
   8544          
   8545              return PSA_SUCCESS;
   8546          exit:
   8547              psa_pake_abort(operation);
   8548              return status;
   8549          }
   8550          
   8551          psa_status_t psa_pake_input(
   8552              psa_pake_operation_t *operation,
   8553              psa_pake_step_t step,
   8554              const uint8_t *input,
   8555              size_t input_length)
   8556          {
   8557              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8558              psa_crypto_driver_pake_step_t driver_step = PSA_JPAKE_STEP_INVALID;
   8559              const size_t max_input_length = (size_t) PSA_PAKE_INPUT_SIZE(operation->alg,
   8560                                                                           operation->primitive,
   8561                                                                           step);
   8562          
   8563              if (operation->stage == PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS) {
   8564                  status = psa_pake_complete_inputs(operation);
   8565                  if (status != PSA_SUCCESS) {
   8566                      goto exit;
   8567                  }
   8568              }
   8569          
   8570              if (operation->stage != PSA_PAKE_OPERATION_STAGE_COMPUTATION) {
   8571                  status =  PSA_ERROR_BAD_STATE;
   8572                  goto exit;
   8573              }
   8574          
   8575              if (input_length == 0 || input_length > max_input_length) {
   8576                  status = PSA_ERROR_INVALID_ARGUMENT;
   8577                  goto exit;
   8578              }
   8579          
   8580              switch (operation->alg) {
   8581          #if defined(PSA_WANT_ALG_JPAKE)
   8582                  case PSA_ALG_JPAKE:
   8583                      status = psa_jpake_prologue(operation, step, PSA_JPAKE_INPUT);
   8584                      if (status != PSA_SUCCESS) {
   8585                          goto exit;
   8586                      }
   8587                      driver_step = convert_jpake_computation_stage_to_driver_step(
   8588                          &operation->computation_stage.jpake);
   8589                      break;
   8590          #endif /* PSA_WANT_ALG_JPAKE */
   8591                  default:
   8592                      (void) step;
   8593                      status = PSA_ERROR_NOT_SUPPORTED;
   8594                      goto exit;
   8595              }
   8596          
   8597              status = psa_driver_wrapper_pake_input(operation, driver_step,
   8598                                                     input, input_length);
   8599          
   8600              if (status != PSA_SUCCESS) {
   8601                  goto exit;
   8602              }
   8603          
   8604              switch (operation->alg) {
   8605          #if defined(PSA_WANT_ALG_JPAKE)
   8606                  case PSA_ALG_JPAKE:
   8607                      status = psa_jpake_epilogue(operation, PSA_JPAKE_INPUT);
   8608                      if (status != PSA_SUCCESS) {
   8609                          goto exit;
   8610                      }
   8611                      break;
   8612          #endif /* PSA_WANT_ALG_JPAKE */
   8613                  default:
   8614                      status = PSA_ERROR_NOT_SUPPORTED;
   8615                      goto exit;
   8616              }
   8617          
   8618              return PSA_SUCCESS;
   8619          exit:
   8620              psa_pake_abort(operation);
   8621              return status;
   8622          }
   8623          
   8624          psa_status_t psa_pake_get_implicit_key(
   8625              psa_pake_operation_t *operation,
   8626              psa_key_derivation_operation_t *output)
   8627          {
   8628              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8629              psa_status_t abort_status = PSA_ERROR_CORRUPTION_DETECTED;
   8630              uint8_t shared_key[MBEDTLS_PSA_JPAKE_BUFFER_SIZE];
   8631              size_t shared_key_len = 0;
   8632          
   8633              if (operation->stage != PSA_PAKE_OPERATION_STAGE_COMPUTATION) {
   8634                  status = PSA_ERROR_BAD_STATE;
   8635                  goto exit;
   8636              }
   8637          
   8638          #if defined(PSA_WANT_ALG_JPAKE)
   8639              if (operation->alg == PSA_ALG_JPAKE) {
   8640                  psa_jpake_computation_stage_t *computation_stage =
   8641                      &operation->computation_stage.jpake;
   8642                  if (computation_stage->round != PSA_JPAKE_FINISHED) {
   8643                      status = PSA_ERROR_BAD_STATE;
   8644                      goto exit;
   8645                  }
   8646              } else
   8647          #endif /* PSA_WANT_ALG_JPAKE */
   8648              {
   8649                  status = PSA_ERROR_NOT_SUPPORTED;
   8650                  goto exit;
   8651              }
   8652          
   8653              status = psa_driver_wrapper_pake_get_implicit_key(operation,
   8654                                                                shared_key,
   8655                                                                sizeof(shared_key),
   8656                                                                &shared_key_len);
   8657          
   8658              if (status != PSA_SUCCESS) {
   8659                  goto exit;
   8660              }
   8661          
   8662              status = psa_key_derivation_input_bytes(output,
   8663                                                      PSA_KEY_DERIVATION_INPUT_SECRET,
   8664                                                      shared_key,
   8665                                                      shared_key_len);
   8666          
   8667              mbedtls_platform_zeroize(shared_key, sizeof(shared_key));
   8668          exit:
   8669              abort_status = psa_pake_abort(operation);
   8670              return status == PSA_SUCCESS ? abort_status : status;
   8671          }
   8672          
   8673          #if defined(SLI_MBEDTLS_PSA_EC_JPAKE_TLS_WORKAROUND)
   8674          
   8675          psa_status_t psa_pake_derive_secret(
   8676              psa_pake_operation_t *operation,
   8677              uint8_t *key_buf,
   8678              size_t key_length)
   8679          {
   8680              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8681              psa_status_t abort_status = PSA_ERROR_CORRUPTION_DETECTED;
   8682              size_t key_output_length = 0;
   8683              int ret = 0;
   8684          
   8685              if (operation->stage != PSA_PAKE_OPERATION_STAGE_COMPUTATION) {
   8686                  status = PSA_ERROR_BAD_STATE;
   8687                  goto exit;
   8688              }
   8689          
   8690              if (operation->alg == PSA_ALG_JPAKE) {
   8691                  psa_jpake_computation_stage_t *computation_stage =
   8692                      &operation->computation_stage.jpake;
   8693                  if (computation_stage->round != PSA_JPAKE_FINISHED) {
   8694                      status = PSA_ERROR_BAD_STATE;
   8695                      goto exit;
   8696                  }
   8697              } else {
   8698                  status = PSA_ERROR_NOT_SUPPORTED;
   8699                  goto exit;
   8700              }
   8701          
   8702              ret = mbedtls_ecjpake_derive_secret(
   8703                  &(&operation->data.ctx.mbedtls_ctx)->ctx.jpake,
   8704                  key_buf,
   8705                  key_length,
   8706                  &key_output_length,
   8707                  mbedtls_psa_get_random,
   8708                  MBEDTLS_PSA_RANDOM_STATE);
   8709          
   8710              if (key_output_length != key_length ||
   8711                  ret != 0) {
   8712                  status = PSA_ERROR_HARDWARE_FAILURE;
   8713                  goto exit;
   8714              }
   8715          
   8716              status = PSA_SUCCESS;
   8717          
   8718          exit:
   8719              abort_status = psa_pake_abort(operation);
   8720              return status == PSA_SUCCESS ? abort_status : status;
   8721          }
   8722          
   8723          #endif // SLI_MBEDTLS_PSA_EC_JPAKE_TLS_WORKAROUND
   8724          
   8725          psa_status_t psa_pake_abort(
   8726              psa_pake_operation_t *operation)
   8727          {
   8728              psa_status_t status = PSA_SUCCESS;
   8729          
   8730              if (operation->stage == PSA_PAKE_OPERATION_STAGE_COMPUTATION) {
   8731                  status = psa_driver_wrapper_pake_abort(operation);
   8732              }
   8733          
   8734              if (operation->stage == PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS) {
   8735                  if (operation->data.inputs.password != NULL) {
   8736                      mbedtls_zeroize_and_free(operation->data.inputs.password,
   8737                                               operation->data.inputs.password_len);
   8738                  }
   8739                  if (operation->data.inputs.user != NULL) {
   8740                      mbedtls_free(operation->data.inputs.user);
   8741                  }
   8742                  if (operation->data.inputs.peer != NULL) {
   8743                      mbedtls_free(operation->data.inputs.peer);
   8744                  }
   8745              }
   8746              memset(operation, 0, sizeof(psa_pake_operation_t));
   8747          
   8748              return status;
   8749          }
   8750          #endif /* PSA_WANT_ALG_SOME_PAKE */
   8751          
   8752          #endif /* MBEDTLS_PSA_CRYPTO_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   is_kdf_alg_supported
       0   key_type_is_raw_bytes
       0   mbedtls_ecc_group_of_psa
       0   mbedtls_ecc_group_to_psa
       8   mbedtls_psa_crypto_free
         8   -> mbedtls_platform_zeroize
         8   -> mbedtls_psa_random_free
         8   -> psa_driver_wrapper_free
         8   -> psa_wipe_all_key_slots
      16   mbedtls_psa_get_random
        16   -> psa_generate_random
       0   mbedtls_psa_interruptible_set_max_ops
      24   mbedtls_psa_random_free
        24   -> __aeabi_memset
      24   mbedtls_psa_random_init
        24   -> __aeabi_memset
       0   mbedtls_psa_random_seed
       0   mbedtls_psa_sign_hash_abort
       4   mbedtls_psa_sign_hash_complete
       0   mbedtls_psa_sign_hash_get_num_ops
      16   mbedtls_psa_sign_hash_start
       0   mbedtls_psa_verify_hash_abort
       0   mbedtls_psa_verify_hash_complete
       0   mbedtls_psa_verify_hash_get_num_ops
      20   mbedtls_psa_verify_hash_start
       0   mbedtls_svc_key_id_is_null
       0   mbedtls_to_psa_error
      32   psa_aead_abort
        32   -> __aeabi_memset
        32   -> psa_driver_wrapper_aead_abort
       0   psa_aead_check_algorithm
      16   psa_aead_check_nonce_length
        16   -> psa_aead_get_base_algorithm
     120   psa_aead_decrypt
       120   -> __aeabi_memclr4
       120   -> __aeabi_memcpy4
       120   -> __aeabi_memset
       120   -> psa_aead_check_algorithm
       120   -> psa_aead_check_nonce_length
       120   -> psa_driver_wrapper_aead_decrypt
       120   -> psa_get_and_lock_key_slot_with_policy
       120   -> psa_unlock_key_slot
      16   psa_aead_decrypt_setup
        16   -> psa_aead_setup
     120   psa_aead_encrypt
       120   -> __aeabi_memclr4
       120   -> __aeabi_memcpy4
       120   -> __aeabi_memset
       120   -> psa_aead_check_algorithm
       120   -> psa_aead_check_nonce_length
       120   -> psa_driver_wrapper_aead_encrypt
       120   -> psa_get_and_lock_key_slot_with_policy
       120   -> psa_unlock_key_slot
      16   psa_aead_encrypt_setup
        16   -> psa_aead_setup
       0   psa_aead_final_checks
      48   psa_aead_finish
        48   -> psa_aead_abort
        48   -> psa_aead_final_checks
        48   -> psa_driver_wrapper_aead_finish
        48   -> psa_wipe_tag_output_buffer
      56   psa_aead_generate_nonce
        56   -> __aeabi_memcpy
        56   -> psa_aead_abort
        56   -> psa_aead_set_nonce
        56   -> psa_generate_random
       0   psa_aead_get_base_algorithm
      24   psa_aead_set_lengths
        24   -> psa_aead_abort
        24   -> psa_driver_wrapper_aead_set_lengths
      32   psa_aead_set_nonce
        32   -> psa_aead_abort
        32   -> psa_aead_check_nonce_length
        32   -> psa_driver_wrapper_aead_set_nonce
     120   psa_aead_setup
       120   -> __aeabi_memclr4
       120   -> __aeabi_memcpy4
       120   -> psa_aead_abort
       120   -> psa_aead_check_algorithm
       120   -> psa_aead_get_base_algorithm
       120   -> psa_driver_wrapper_aead_decrypt_setup
       120   -> psa_driver_wrapper_aead_encrypt_setup
       120   -> psa_get_and_lock_key_slot_with_policy
       120   -> psa_get_key_type
       120   -> psa_unlock_key_slot
       120   -> psa_validate_tag_length
      40   psa_aead_update
        40   -> psa_aead_abort
        40   -> psa_driver_wrapper_aead_update
      24   psa_aead_update_ad
        24   -> psa_aead_abort
        24   -> psa_driver_wrapper_aead_update_ad
      40   psa_aead_verify
        40   -> psa_aead_abort
        40   -> psa_aead_final_checks
        40   -> psa_driver_wrapper_aead_verify
      16   psa_allocate_buffer_to_slot
        16   -> sl_calloc
     144   psa_asymmetric_decrypt
       144   -> __aeabi_memclr4
       144   -> __aeabi_memcpy4
       144   -> psa_driver_wrapper_asymmetric_decrypt
       144   -> psa_get_and_lock_transparent_key_slot_with_policy
       144   -> psa_unlock_key_slot
     144   psa_asymmetric_encrypt
       144   -> __aeabi_memclr4
       144   -> __aeabi_memcpy4
       144   -> psa_driver_wrapper_asymmetric_encrypt
       144   -> psa_get_and_lock_transparent_key_slot_with_policy
       144   -> psa_unlock_key_slot
       8   psa_cipher_abort
         8   -> psa_driver_wrapper_cipher_abort
     136   psa_cipher_decrypt
       136   -> __aeabi_memclr4
       136   -> __aeabi_memcpy4
       136   -> psa_driver_wrapper_cipher_decrypt
       136   -> psa_get_and_lock_key_slot_with_policy
       136   -> psa_unlock_key_slot
      16   psa_cipher_decrypt_setup
        16   -> psa_cipher_setup
     168   psa_cipher_encrypt
       168   -> __aeabi_memclr4
       168   -> __aeabi_memcpy
       168   -> __aeabi_memcpy4
       168   -> psa_crypto_buffer_offset
       168   -> psa_driver_wrapper_cipher_encrypt
       168   -> psa_generate_random
       168   -> psa_get_and_lock_key_slot_with_policy
       168   -> psa_unlock_key_slot
      16   psa_cipher_encrypt_setup
        16   -> psa_cipher_setup
      32   psa_cipher_finish
        32   -> psa_cipher_abort
        32   -> psa_driver_wrapper_cipher_finish
      56   psa_cipher_generate_iv
        56   -> __aeabi_memcpy
        56   -> psa_cipher_abort
        56   -> psa_driver_wrapper_cipher_set_iv
        56   -> psa_generate_random
      24   psa_cipher_set_iv
        24   -> psa_cipher_abort
        24   -> psa_driver_wrapper_cipher_set_iv
     120   psa_cipher_setup
       120   -> __aeabi_memclr4
       120   -> __aeabi_memcpy4
       120   -> psa_cipher_abort
       120   -> psa_driver_wrapper_cipher_decrypt_setup
       120   -> psa_driver_wrapper_cipher_encrypt_setup
       120   -> psa_get_and_lock_key_slot_with_policy
       120   -> psa_unlock_key_slot
      40   psa_cipher_update
        40   -> psa_cipher_abort
        40   -> psa_driver_wrapper_cipher_update
      96   psa_copy_key
        96   -> __aeabi_memcpy4
        96   -> psa_allocate_buffer_to_slot
        96   -> psa_copy_key_material_into_slot
        96   -> psa_driver_wrapper_copy_key
        96   -> psa_driver_wrapper_get_key_buffer_size
        96   -> psa_fail_key_creation
        96   -> psa_finish_key_creation
        96   -> psa_get_and_lock_key_slot_with_policy
        96   -> psa_key_lifetime_is_external
        96   -> psa_restrict_key_policy
        96   -> psa_start_key_creation
        96   -> psa_unlock_key_slot
        96   -> psa_validate_optional_attributes
        96   -> sli_psa_key_is_unconditionally_copyable
      32   psa_copy_key_material_into_slot
        32   -> __aeabi_memcpy
        32   -> psa_allocate_buffer_to_slot
       0   psa_crypto_buffer_offset
      16   psa_crypto_init
        16   -> mbedtls_psa_crypto_free
        16   -> mbedtls_psa_random_init
        16   -> mbedtls_psa_random_seed
        16   -> psa_driver_wrapper_init
        16   -> psa_initialize_key_slots
      24   psa_destroy_key
        24   -- Indirect call
        24   -> mbedtls_svc_key_id_is_null
        24   -> psa_finish_key_destruction
        24   -> psa_get_and_lock_key_slot
        24   -> psa_slot_has_no_readers
       8   psa_driver_wrapper_aead_abort
         8   -> mbedtls_psa_aead_abort
         8   -> sli_se_opaque_aead_abort
         8   -> sli_se_transparent_aead_abort
      96   psa_driver_wrapper_aead_decrypt
        96   -> mbedtls_psa_aead_decrypt
        96   -> sli_se_opaque_aead_decrypt
        96   -> sli_se_transparent_aead_decrypt
      40   psa_driver_wrapper_aead_decrypt_setup
        40   -> mbedtls_psa_aead_decrypt_setup
        40   -> sli_se_opaque_aead_decrypt_setup
        40   -> sli_se_transparent_aead_decrypt_setup
      96   psa_driver_wrapper_aead_encrypt
        96   -> mbedtls_psa_aead_encrypt
        96   -> sli_se_opaque_aead_encrypt
        96   -> sli_se_transparent_aead_encrypt
      40   psa_driver_wrapper_aead_encrypt_setup
        40   -> mbedtls_psa_aead_encrypt_setup
        40   -> sli_se_opaque_aead_encrypt_setup
        40   -> sli_se_transparent_aead_encrypt_setup
      48   psa_driver_wrapper_aead_finish
        48   -> mbedtls_psa_aead_finish
        48   -> sli_se_opaque_aead_finish
        48   -> sli_se_transparent_aead_finish
      16   psa_driver_wrapper_aead_set_lengths
        16   -> mbedtls_psa_aead_set_lengths
        16   -> sli_se_opaque_aead_set_lengths
        16   -> sli_se_transparent_aead_set_lengths
      16   psa_driver_wrapper_aead_set_nonce
        16   -> mbedtls_psa_aead_set_nonce
        16   -> sli_se_opaque_aead_set_nonce
        16   -> sli_se_transparent_aead_set_nonce
      40   psa_driver_wrapper_aead_update
        40   -> mbedtls_psa_aead_update
        40   -> sli_se_opaque_aead_update
        40   -> sli_se_transparent_aead_update
      16   psa_driver_wrapper_aead_update_ad
        16   -> mbedtls_psa_aead_update_ad
        16   -> sli_se_opaque_aead_update_ad
        16   -> sli_se_transparent_aead_update_ad
      72   psa_driver_wrapper_aead_verify
        72   -> mbedtls_ct_memcmp
        72   -> mbedtls_platform_zeroize
        72   -> mbedtls_psa_aead_finish
        72   -> sli_se_opaque_aead_verify
        72   -> sli_se_transparent_aead_verify
      56   psa_driver_wrapper_asymmetric_decrypt
        56   -> mbedtls_psa_asymmetric_decrypt
      56   psa_driver_wrapper_asymmetric_encrypt
        56   -> mbedtls_psa_asymmetric_encrypt
      16   psa_driver_wrapper_cipher_abort
        16   -> mbedtls_psa_cipher_abort
        16   -> sli_se_opaque_cipher_abort
        16   -> sli_se_transparent_cipher_abort
      72   psa_driver_wrapper_cipher_decrypt
        72   -> mbedtls_psa_cipher_decrypt
        72   -> sli_se_opaque_cipher_decrypt
        72   -> sli_se_transparent_cipher_decrypt
      40   psa_driver_wrapper_cipher_decrypt_setup
        40   -> mbedtls_psa_cipher_decrypt_setup
        40   -> sli_se_opaque_cipher_decrypt_setup
        40   -> sli_se_transparent_cipher_decrypt_setup
      88   psa_driver_wrapper_cipher_encrypt
        88   -> mbedtls_psa_cipher_encrypt
        88   -> sli_se_opaque_cipher_encrypt
        88   -> sli_se_transparent_cipher_encrypt
      40   psa_driver_wrapper_cipher_encrypt_setup
        40   -> mbedtls_psa_cipher_encrypt_setup
        40   -> sli_se_opaque_cipher_encrypt_setup
        40   -> sli_se_transparent_cipher_encrypt_setup
      24   psa_driver_wrapper_cipher_finish
        24   -> mbedtls_psa_cipher_finish
        24   -> sli_se_opaque_cipher_finish
        24   -> sli_se_transparent_cipher_finish
      16   psa_driver_wrapper_cipher_set_iv
        16   -> mbedtls_psa_cipher_set_iv
        16   -> sli_se_opaque_cipher_set_iv
        16   -> sli_se_transparent_cipher_set_iv
      40   psa_driver_wrapper_cipher_update
        40   -> mbedtls_psa_cipher_update
        40   -> sli_se_opaque_cipher_update
        40   -> sli_se_transparent_cipher_update
      40   psa_driver_wrapper_copy_key
        40   -> sli_se_opaque_copy_key
      48   psa_driver_wrapper_export_key
        48   -> psa_export_key_internal
        48   -> psa_get_key_lifetime
        48   -> sli_se_opaque_export_key
       0   psa_driver_wrapper_free
      32   psa_driver_wrapper_generate_key
        32   -> psa_generate_key_internal
        32   -> sli_se_opaque_generate_key
        32   -> sli_se_transparent_generate_key
      32   psa_driver_wrapper_get_key_buffer_size_from_key_data
        32   -> psa_driver_wrapper_get_key_buffer_size
       8   psa_driver_wrapper_hash_abort
         8   -> mbedtls_psa_hash_abort
         8   -> sli_se_transparent_hash_abort
      16   psa_driver_wrapper_hash_clone
        16   -> mbedtls_psa_hash_clone
        16   -> sli_se_transparent_hash_clone
      48   psa_driver_wrapper_hash_compute
        48   -> mbedtls_psa_hash_compute
        48   -> sli_se_transparent_hash_compute
      24   psa_driver_wrapper_hash_finish
        24   -> mbedtls_psa_hash_finish
        24   -> sli_se_transparent_hash_finish
      24   psa_driver_wrapper_hash_setup
        24   -> mbedtls_psa_hash_setup
        24   -> sli_se_transparent_hash_setup
      16   psa_driver_wrapper_hash_update
        16   -> mbedtls_psa_hash_update
        16   -> sli_se_transparent_hash_update
      56   psa_driver_wrapper_import_key
        56   -> psa_get_key_lifetime
        56   -> psa_import_key_into_slot
        56   -> sli_se_opaque_import_key
        56   -> sli_se_transparent_import_key
      16   psa_driver_wrapper_init
        16   -> sli_se_opaque_driver_init
        16   -> sli_se_transparent_driver_init
      72   psa_driver_wrapper_key_agreement
        72   -> psa_key_agreement_raw_builtin
        72   -> sli_se_opaque_key_agreement
        72   -> sli_se_transparent_key_agreement
       8   psa_driver_wrapper_mac_abort
         8   -> mbedtls_psa_mac_abort
         8   -> sli_se_opaque_mac_abort
         8   -> sli_se_transparent_mac_abort
      80   psa_driver_wrapper_mac_compute
        80   -> mbedtls_psa_mac_compute
        80   -> sli_se_opaque_mac_compute
        80   -> sli_se_transparent_mac_compute
      24   psa_driver_wrapper_mac_sign_finish
        24   -> mbedtls_psa_mac_sign_finish
        24   -> sli_se_opaque_mac_sign_finish
        24   -> sli_se_transparent_mac_sign_finish
      40   psa_driver_wrapper_mac_sign_setup
        40   -> mbedtls_psa_mac_sign_setup
        40   -> sli_se_opaque_mac_sign_setup
        40   -> sli_se_transparent_mac_sign_setup
      16   psa_driver_wrapper_mac_update
        16   -> mbedtls_psa_mac_update
        16   -> sli_se_opaque_mac_update
        16   -> sli_se_transparent_mac_update
      16   psa_driver_wrapper_mac_verify_finish
        16   -> mbedtls_psa_mac_verify_finish
        16   -> sli_se_opaque_mac_verify_finish
        16   -> sli_se_transparent_mac_verify_finish
      40   psa_driver_wrapper_mac_verify_setup
        40   -> mbedtls_psa_mac_verify_setup
        40   -> sli_se_opaque_mac_verify_setup
        40   -> sli_se_transparent_mac_verify_setup
      72   psa_driver_wrapper_sign_hash
        72   -> psa_sign_hash_builtin
        72   -> sli_se_opaque_sign_hash
        72   -> sli_se_transparent_sign_hash
       8   psa_driver_wrapper_sign_hash_abort
         8   -> mbedtls_psa_sign_hash_abort
      24   psa_driver_wrapper_sign_hash_complete
        24   -> mbedtls_psa_sign_hash_complete
       8   psa_driver_wrapper_sign_hash_get_num_ops
         8   -> mbedtls_psa_sign_hash_get_num_ops
      40   psa_driver_wrapper_sign_hash_start
        40   -> mbedtls_psa_sign_hash_start
      72   psa_driver_wrapper_sign_message
        72   -> psa_sign_message_builtin
        72   -> sli_se_opaque_sign_message
        72   -> sli_se_transparent_sign_message
      64   psa_driver_wrapper_verify_hash
        64   -> psa_verify_hash_builtin
        64   -> sli_se_opaque_verify_hash
        64   -> sli_se_transparent_verify_hash
       8   psa_driver_wrapper_verify_hash_abort
         8   -> mbedtls_psa_verify_hash_abort
       8   psa_driver_wrapper_verify_hash_complete
         8   -> mbedtls_psa_verify_hash_complete
       8   psa_driver_wrapper_verify_hash_get_num_ops
         8   -> mbedtls_psa_verify_hash_get_num_ops
      48   psa_driver_wrapper_verify_hash_start
        48   -> mbedtls_psa_verify_hash_start
      64   psa_driver_wrapper_verify_message
        64   -> psa_verify_message_builtin
        64   -> sli_se_opaque_verify_message
        64   -> sli_se_transparent_verify_message
      80   psa_export_key
        80   -> __aeabi_memclr4
        80   -> __aeabi_memcpy4
        80   -> psa_driver_wrapper_export_key
        80   -> psa_get_and_lock_key_slot_with_policy
        80   -> psa_unlock_key_slot
      48   psa_export_key_buffer_internal
        48   -> __aeabi_memcpy
        48   -> __aeabi_memset
      32   psa_export_key_internal
        32   -> key_type_is_raw_bytes
        32   -> psa_export_key_buffer_internal
     120   psa_export_public_key
       120   -> __aeabi_memclr4
       120   -> __aeabi_memcpy4
       120   -> psa_driver_wrapper_export_public_key
       120   -> psa_get_and_lock_key_slot_with_policy
       120   -> psa_unlock_key_slot
      40   psa_export_public_key_internal
        40   -> mbedtls_psa_ecp_export_public_key
        40   -> psa_export_key_buffer_internal
       0   psa_extend_key_usage_flags
      16   psa_fail_key_creation
        16   -- Indirect call
        16   -> psa_slot_change_state
        16   -> psa_wipe_key_slot
      24   psa_finish_key_creation
        24   -- Indirect call
        24   -> psa_save_persistent_key
        24   -> psa_slot_change_state
      24   psa_finish_key_destruction
        24   -> psa_destroy_persistent_key
        24   -> psa_wipe_key_slot
       0   psa_generate_derived_ecc_key_montgomery_helper
       4   psa_generate_derived_ecc_key_weierstrass_helper
     128   psa_generate_derived_key_internal
       128   -> __aeabi_memclr4
       128   -> __aeabi_memcpy4
       128   -> key_type_is_raw_bytes
       128   -> psa_allocate_buffer_to_slot
       128   -> psa_driver_wrapper_get_key_buffer_size
       128   -> psa_driver_wrapper_import_key
       128   -> psa_generate_derived_ecc_key_montgomery_helper
       128   -> psa_generate_derived_ecc_key_weierstrass_helper
       128   -> psa_key_derivation_output_bytes
       128   -> psa_key_lifetime_is_external
       128   -> sl_calloc
       128   -> sl_free
      32   psa_generate_key
        32   -> psa_allocate_buffer_to_slot
        32   -> psa_driver_wrapper_generate_key
        32   -> psa_driver_wrapper_get_key_buffer_size
        32   -> psa_fail_key_creation
        32   -> psa_finish_key_creation
        32   -> psa_get_key_bits
        32   -> psa_remove_key_data_from_memory
        32   -> psa_start_key_creation
        32   -> psa_validate_key_type_and_size_for_key_generation
      32   psa_generate_key_internal
        32   -> key_type_is_raw_bytes
        32   -> mbedtls_psa_ecp_generate_key
        32   -> psa_generate_random
      24   psa_generate_random
        24   -> mbedtls_psa_external_get_random
      32   psa_get_and_lock_key_slot_with_policy
        32   -> psa_get_and_lock_key_slot
        32   -> psa_key_policy_permits
        32   -> psa_unlock_key_slot
      24   psa_get_and_lock_transparent_key_slot_with_policy
        24   -> psa_get_and_lock_key_slot_with_policy
        24   -> psa_key_lifetime_is_external
        24   -> psa_unlock_key_slot
      32   psa_get_key_attributes
        32   -> __aeabi_memcpy4
        32   -> psa_get_and_lock_key_slot_with_policy
        32   -> psa_reset_key_attributes
        32   -> psa_unlock_key_slot
       0   psa_get_key_bits
       0   psa_get_key_id
       0   psa_get_key_lifetime
       0   psa_get_key_type
       8   psa_hash_abort
         8   -> psa_driver_wrapper_hash_abort
      16   psa_hash_clone
        16   -> psa_driver_wrapper_hash_clone
        16   -> psa_hash_abort
      72   psa_hash_compare
        72   -> mbedtls_ct_memcmp
        72   -> mbedtls_platform_zeroize
        72   -> psa_driver_wrapper_hash_compute
      32   psa_hash_compute
        32   -> psa_driver_wrapper_hash_compute
      24   psa_hash_finish
        24   -> psa_driver_wrapper_hash_finish
        24   -> psa_hash_abort
      32   psa_hash_setup
        32   -> __aeabi_memset
        32   -> psa_driver_wrapper_hash_setup
        32   -> psa_hash_abort
     240   psa_hash_try_support
       240   -> __aeabi_memclr4
       240   -> psa_hash_abort
       240   -> psa_hash_setup
      24   psa_hash_update
        24   -> psa_driver_wrapper_hash_update
        24   -> psa_hash_abort
      56   psa_hash_verify
        56   -> mbedtls_ct_memcmp
        56   -> mbedtls_platform_zeroize
        56   -> psa_hash_abort
        56   -> psa_hash_finish
      56   psa_import_key
        56   -> psa_allocate_buffer_to_slot
        56   -> psa_driver_wrapper_get_key_buffer_size_from_key_data
        56   -> psa_driver_wrapper_import_key
        56   -> psa_fail_key_creation
        56   -> psa_finish_key_creation
        56   -> psa_key_lifetime_is_external
        56   -> psa_start_key_creation
        56   -> psa_validate_optional_attributes
      56   psa_import_key_into_slot
        56   -> __aeabi_memcpy
        56   -> key_type_is_raw_bytes
        56   -> mbedtls_psa_ecp_import_key
        56   -> psa_validate_unstructured_key_bit_size
       0   psa_interruptible_get_max_ops
       0   psa_interruptible_set_max_ops
      80   psa_key_agreement_internal
        80   -> mbedtls_platform_zeroize
        80   -> psa_key_agreement_raw_internal
        80   -> psa_key_derivation_input_internal
      40   psa_key_agreement_raw_builtin
        40   -> mbedtls_psa_key_agreement_ecdh
      80   psa_key_agreement_raw_internal
        80   -> __aeabi_memclr4
        80   -> __aeabi_memcpy4
        80   -> psa_driver_wrapper_key_agreement
       0   psa_key_agreement_try_support
      16   psa_key_algorithm_permits
        16   -> psa_mac_key_can_do
      16   psa_key_derivation_abort
        16   -> mbedtls_platform_zeroize
        16   -> mbedtls_zeroize_and_free
        16   -> psa_key_derivation_get_kdf_alg
       0   psa_key_derivation_allows_free_form_secret_input
       0   psa_key_derivation_check_input_type
       0   psa_key_derivation_get_capacity
       0   psa_key_derivation_get_kdf_alg
      24   psa_key_derivation_input_bytes
        24   -> psa_key_derivation_input_internal
      24   psa_key_derivation_input_integer
        24   -> psa_key_derivation_input_integer_internal
      32   psa_key_derivation_input_integer_internal
        32   -> psa_key_derivation_abort
        32   -> psa_key_derivation_get_kdf_alg
      32   psa_key_derivation_input_internal
        32   -> psa_key_derivation_abort
        32   -> psa_key_derivation_check_input_type
        32   -> psa_key_derivation_get_kdf_alg
        32   -> psa_tls12_prf_input
      40   psa_key_derivation_input_key
        40   -> psa_get_and_lock_transparent_key_slot_with_policy
        40   -> psa_key_derivation_abort
        40   -> psa_key_derivation_input_internal
        40   -> psa_unlock_key_slot
      40   psa_key_derivation_key_agreement
        40   -> psa_get_and_lock_key_slot_with_policy
        40   -> psa_key_agreement_internal
        40   -> psa_key_derivation_abort
        40   -> psa_unlock_key_slot
      40   psa_key_derivation_output_bytes
        40   -> __aeabi_memset
        40   -> psa_key_derivation_abort
        40   -> psa_key_derivation_get_kdf_alg
        40   -> psa_key_derivation_tls12_prf_read
      32   psa_key_derivation_output_key
        32   -> key_type_is_raw_bytes
        32   -> psa_fail_key_creation
        32   -> psa_finish_key_creation
        32   -> psa_generate_derived_key_internal
        32   -> psa_get_key_bits
        32   -> psa_get_key_type
        32   -> psa_start_key_creation
       0   psa_key_derivation_set_capacity
      32   psa_key_derivation_setup
        32   -> psa_key_agreement_try_support
        32   -> psa_key_derivation_allows_free_form_secret_input
        32   -> psa_key_derivation_setup_kdf
      24   psa_key_derivation_setup_kdf
        24   -> __aeabi_memset
        24   -> is_kdf_alg_supported
        24   -> psa_hash_try_support
      72   psa_key_derivation_start_hmac
        72   -> __aeabi_memclr4
        72   -> psa_driver_wrapper_mac_sign_setup
        72   -> psa_reset_key_attributes
        72   -> psa_set_key_bits
        72   -> psa_set_key_type
        72   -> psa_set_key_usage_flags
     384   psa_key_derivation_tls12_prf_generate_next_block
       384   -> __aeabi_memclr4
       384   -> psa_key_derivation_start_hmac
       384   -> psa_mac_abort
       384   -> psa_mac_sign_finish
       384   -> psa_mac_update
      56   psa_key_derivation_tls12_prf_read
        56   -> __aeabi_memcpy
        56   -> psa_key_derivation_tls12_prf_generate_next_block
       0   psa_key_lifetime_is_external
      16   psa_key_policy_algorithm_intersection
        16   -> psa_mac_key_can_do
      16   psa_key_policy_permits
        16   -> psa_key_algorithm_permits
       8   psa_mac_abort
         8   -> psa_driver_wrapper_mac_abort
      40   psa_mac_compute
        40   -> psa_mac_compute_internal
     144   psa_mac_compute_internal
       144   -> __aeabi_memclr4
       144   -> __aeabi_memcpy4
       144   -> psa_driver_wrapper_mac_compute
       144   -> psa_get_and_lock_key_slot_with_policy
       144   -> psa_mac_finalize_alg_and_key_validation
       144   -> psa_unlock_key_slot
       144   -> psa_wipe_tag_output_buffer
      32   psa_mac_finalize_alg_and_key_validation
        32   -> psa_get_key_bits
        32   -> psa_get_key_type
        32   -> psa_mac_key_can_do
       0   psa_mac_key_can_do
     112   psa_mac_setup
       112   -> __aeabi_memclr4
       112   -> __aeabi_memcpy4
       112   -> psa_driver_wrapper_mac_sign_setup
       112   -> psa_driver_wrapper_mac_verify_setup
       112   -> psa_get_and_lock_key_slot_with_policy
       112   -> psa_mac_abort
       112   -> psa_mac_finalize_alg_and_key_validation
       112   -> psa_unlock_key_slot
      32   psa_mac_sign_finish
        32   -> psa_driver_wrapper_mac_sign_finish
        32   -> psa_mac_abort
        32   -> psa_wipe_tag_output_buffer
      16   psa_mac_sign_setup
        16   -> psa_mac_setup
      24   psa_mac_update
        24   -> psa_driver_wrapper_mac_update
        24   -> psa_mac_abort
      88   psa_mac_verify
        88   -> mbedtls_ct_memcmp
        88   -> mbedtls_platform_zeroize
        88   -> psa_mac_compute_internal
      32   psa_mac_verify_finish
        32   -> psa_driver_wrapper_mac_verify_finish
        32   -> psa_mac_abort
      16   psa_mac_verify_setup
        16   -> psa_mac_setup
      64   psa_raw_key_agreement
        64   -> psa_generate_random
        64   -> psa_get_and_lock_key_slot_with_policy
        64   -> psa_key_agreement_raw_internal
        64   -> psa_unlock_key_slot
       8   psa_remove_key_data_from_memory
         8   -> mbedtls_zeroize_and_free
      24   psa_restrict_key_policy
        24   -> psa_key_policy_algorithm_intersection
       0   psa_set_key_bits
      16   psa_set_key_type
        16   -> psa_set_key_domain_parameters
      16   psa_set_key_usage_flags
        16   -> psa_extend_key_usage_flags
      40   psa_sign_hash
        40   -> psa_sign_internal
      16   psa_sign_hash_abort
        16   -> psa_sign_hash_abort_internal
      16   psa_sign_hash_abort_internal
        16   -> psa_driver_wrapper_sign_hash_abort
      40   psa_sign_hash_builtin
        40   -> mbedtls_psa_ecdsa_sign_hash
      32   psa_sign_hash_complete
        32   -> psa_driver_wrapper_sign_hash_complete
        32   -> psa_driver_wrapper_sign_hash_get_num_ops
        32   -> psa_sign_hash_abort_internal
        32   -> psa_wipe_tag_output_buffer
       0   psa_sign_hash_get_num_ops
     120   psa_sign_hash_start
       120   -> __aeabi_memclr4
       120   -> __aeabi_memcpy4
       120   -> psa_driver_wrapper_sign_hash_start
       120   -> psa_get_and_lock_key_slot_with_policy
       120   -> psa_sign_hash_abort_internal
       120   -> psa_sign_verify_check_alg
       120   -> psa_unlock_key_slot
     144   psa_sign_internal
       144   -> __aeabi_memclr4
       144   -> __aeabi_memcpy4
       144   -> psa_driver_wrapper_sign_hash
       144   -> psa_driver_wrapper_sign_message
       144   -> psa_get_and_lock_key_slot_with_policy
       144   -> psa_sign_verify_check_alg
       144   -> psa_unlock_key_slot
       144   -> psa_wipe_tag_output_buffer
      40   psa_sign_message
        40   -> psa_sign_internal
      96   psa_sign_message_builtin
        96   -> psa_driver_wrapper_hash_compute
        96   -> psa_driver_wrapper_sign_hash
       4   psa_sign_verify_check_alg
      40   psa_start_key_creation
        40   -- Indirect call
        40   -> __aeabi_memcpy4
        40   -> psa_get_empty_key_slot
        40   -> psa_slot_change_state
        40   -> psa_validate_key_attributes
      24   psa_tls12_prf_input
        24   -> psa_tls12_prf_set_key
        24   -> psa_tls12_prf_set_label
        24   -> psa_tls12_prf_set_seed
      32   psa_tls12_prf_set_key
        32   -> __aeabi_memcpy
        32   -> sl_calloc
      32   psa_tls12_prf_set_label
        32   -> __aeabi_memcpy
        32   -> sl_calloc
      32   psa_tls12_prf_set_seed
        32   -> __aeabi_memcpy
        32   -> sl_calloc
      32   psa_validate_key_attributes
        32   -> psa_get_key_bits
        32   -> psa_get_key_id
        32   -> psa_get_key_lifetime
        32   -> psa_is_valid_key_id
        32   -> psa_validate_key_location
        32   -> psa_validate_key_persistence
        32   -> psa_validate_key_policy
       0   psa_validate_key_policy
      16   psa_validate_key_type_and_size_for_key_generation
        16   -> key_type_is_raw_bytes
        16   -> psa_validate_unstructured_key_bit_size
       0   psa_validate_optional_attributes
       4   psa_validate_tag_length
       0   psa_validate_unstructured_key_bit_size
      32   psa_verify_hash
        32   -> psa_verify_internal
      16   psa_verify_hash_abort
        16   -> psa_verify_hash_abort_internal
      16   psa_verify_hash_abort_internal
        16   -> psa_driver_wrapper_verify_hash_abort
      40   psa_verify_hash_builtin
        40   -> mbedtls_psa_ecdsa_verify_hash
      16   psa_verify_hash_complete
        16   -> psa_driver_wrapper_verify_hash_complete
        16   -> psa_driver_wrapper_verify_hash_get_num_ops
        16   -> psa_verify_hash_abort_internal
       0   psa_verify_hash_get_num_ops
      96   psa_verify_hash_start
        96   -> __aeabi_memclr4
        96   -> __aeabi_memcpy4
        96   -> psa_driver_wrapper_verify_hash_start
        96   -> psa_get_and_lock_key_slot_with_policy
        96   -> psa_sign_verify_check_alg
        96   -> psa_unlock_key_slot
        96   -> psa_verify_hash_abort_internal
     104   psa_verify_internal
       104   -> __aeabi_memclr4
       104   -> __aeabi_memcpy4
       104   -> psa_driver_wrapper_verify_hash
       104   -> psa_driver_wrapper_verify_message
       104   -> psa_get_and_lock_key_slot_with_policy
       104   -> psa_sign_verify_check_alg
       104   -> psa_unlock_key_slot
      32   psa_verify_message
        32   -> psa_verify_internal
      88   psa_verify_message_builtin
        88   -> psa_driver_wrapper_hash_compute
        88   -> psa_driver_wrapper_verify_hash
      24   psa_wipe_key_slot
        24   -> __aeabi_memset
        24   -> psa_remove_key_data_from_memory
      40   psa_wipe_tag_output_buffer
        40   -> __aeabi_memset
      96   sl_psa_key_derivation_single_shot
        96   -> __aeabi_memclr4
        96   -> __aeabi_memcpy4
        96   -> psa_allocate_buffer_to_slot
        96   -> psa_driver_wrapper_get_key_buffer_size
        96   -> psa_fail_key_creation
        96   -> psa_finish_key_creation
        96   -> psa_get_and_lock_key_slot_with_policy
        96   -> psa_get_key_bits
        96   -> psa_start_key_creation
        96   -> psa_unlock_key_slot


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable27
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable32_7
       4  ??DataTable33
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable37_6
       4  ??DataTable37_7
       4  ??DataTable37_8
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable4
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable44_10
       4  ??DataTable44_11
       4  ??DataTable44_12
       4  ??DataTable44_13
       4  ??DataTable44_14
       4  ??DataTable44_2
       4  ??DataTable44_3
       4  ??DataTable44_4
       4  ??DataTable44_5
       4  ??DataTable44_6
       4  ??DataTable44_7
       4  ??DataTable44_8
       4  ??DataTable44_9
       4  ??DataTable49
       4  ??DataTable5
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable53_2
       4  ??DataTable53_3
       4  ??DataTable53_4
       4  ??DataTable53_5
       4  ??DataTable53_6
       4  ??DataTable53_7
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      36  ?_0
      36  ?_1
      36  ?_10
      36  ?_11
      36  ?_12
      36  ?_13
      36  ?_14
      36  ?_15
      36  ?_16
     356  ?_17
      36  ?_18
     224  ?_19
      36  ?_2
      36  ?_20
      36  ?_21
      36  ?_3
      36  ?_4
      36  ?_5
      36  ?_6
      36  ?_7
      36  ?_8
      36  ?_9
      12  global_data
      20  is_kdf_alg_supported
      36  key_type_is_raw_bytes
      44  mbedtls_ecc_group_of_psa
      28  mbedtls_ecc_group_to_psa
      34  mbedtls_psa_crypto_free
      32  mbedtls_psa_get_random
       2  mbedtls_psa_interruptible_set_max_ops
      22  mbedtls_psa_random_free
      22  mbedtls_psa_random_init
       6  mbedtls_psa_random_seed
       8  mbedtls_psa_sign_hash_abort
      12  mbedtls_psa_sign_hash_complete
       6  mbedtls_psa_sign_hash_get_num_ops
      60  mbedtls_psa_sign_hash_start
       8  mbedtls_psa_verify_hash_abort
       8  mbedtls_psa_verify_hash_complete
       6  mbedtls_psa_verify_hash_get_num_ops
      62  mbedtls_psa_verify_hash_start
      14  mbedtls_svc_key_id_is_null
     624  mbedtls_to_psa_error
      50  psa_aead_abort
     252  psa_aead_check_algorithm
      50  psa_aead_check_nonce_length
     194  psa_aead_decrypt
      22  psa_aead_decrypt_setup
     194  psa_aead_encrypt
      22  psa_aead_encrypt_setup
      52  psa_aead_final_checks
     122  psa_aead_finish
     276  psa_aead_generate_nonce
      56  psa_aead_get_base_algorithm
     108  psa_aead_set_lengths
      96  psa_aead_set_nonce
     262  psa_aead_setup
     176  psa_aead_update
     126  psa_aead_update_ad
      86  psa_aead_verify
      46  psa_allocate_buffer_to_slot
     194  psa_asymmetric_decrypt
     208  psa_asymmetric_encrypt
      44  psa_cipher_abort
     382  psa_cipher_decrypt
      22  psa_cipher_decrypt_setup
     414  psa_cipher_encrypt
      22  psa_cipher_encrypt_setup
      88  psa_cipher_finish
     168  psa_cipher_generate_iv
      90  psa_cipher_set_iv
     408  psa_cipher_setup
      82  psa_cipher_update
     398  psa_copy_key
      52  psa_copy_key_material_into_slot
      12  psa_crypto_buffer_offset
      82  psa_crypto_init
     110  psa_destroy_key
      56  psa_driver_wrapper_aead_abort
     196  psa_driver_wrapper_aead_decrypt
     134  psa_driver_wrapper_aead_decrypt_setup
     196  psa_driver_wrapper_aead_encrypt
     134  psa_driver_wrapper_aead_encrypt_setup
     134  psa_driver_wrapper_aead_finish
      72  psa_driver_wrapper_aead_set_lengths
      72  psa_driver_wrapper_aead_set_nonce
     116  psa_driver_wrapper_aead_update
      72  psa_driver_wrapper_aead_update_ad
     172  psa_driver_wrapper_aead_verify
      78  psa_driver_wrapper_asymmetric_decrypt
      78  psa_driver_wrapper_asymmetric_encrypt
      60  psa_driver_wrapper_cipher_abort
     154  psa_driver_wrapper_cipher_decrypt
     142  psa_driver_wrapper_cipher_decrypt_setup
     172  psa_driver_wrapper_cipher_encrypt
     158  psa_driver_wrapper_cipher_encrypt_setup
      80  psa_driver_wrapper_cipher_finish
      72  psa_driver_wrapper_cipher_set_iv
     116  psa_driver_wrapper_cipher_update
      60  psa_driver_wrapper_copy_key
      94  psa_driver_wrapper_export_key
       2  psa_driver_wrapper_free
     106  psa_driver_wrapper_generate_key
      54  psa_driver_wrapper_get_key_buffer_size_from_key_data
      38  psa_driver_wrapper_hash_abort
      52  psa_driver_wrapper_hash_clone
      96  psa_driver_wrapper_hash_compute
      56  psa_driver_wrapper_hash_finish
      70  psa_driver_wrapper_hash_setup
      50  psa_driver_wrapper_hash_update
     130  psa_driver_wrapper_import_key
      38  psa_driver_wrapper_init
     154  psa_driver_wrapper_key_agreement
      56  psa_driver_wrapper_mac_abort
     158  psa_driver_wrapper_mac_compute
      80  psa_driver_wrapper_mac_sign_finish
     158  psa_driver_wrapper_mac_sign_setup
      72  psa_driver_wrapper_mac_update
      72  psa_driver_wrapper_mac_verify_finish
     158  psa_driver_wrapper_mac_verify_setup
     154  psa_driver_wrapper_sign_hash
      24  psa_driver_wrapper_sign_hash_abort
      36  psa_driver_wrapper_sign_hash_complete
      32  psa_driver_wrapper_sign_hash_get_num_ops
      60  psa_driver_wrapper_sign_hash_start
     148  psa_driver_wrapper_sign_message
     148  psa_driver_wrapper_verify_hash
      24  psa_driver_wrapper_verify_hash_abort
      24  psa_driver_wrapper_verify_hash_complete
      32  psa_driver_wrapper_verify_hash_get_num_ops
      70  psa_driver_wrapper_verify_hash_start
     142  psa_driver_wrapper_verify_message
     120  psa_export_key
      74  psa_export_key_buffer_internal
     102  psa_export_key_internal
     144  psa_export_public_key
     186  psa_export_public_key_internal
      30  psa_extend_key_usage_flags
      44  psa_fail_key_creation
     130  psa_finish_key_creation
      90  psa_finish_key_destruction
       8  psa_generate_derived_ecc_key_montgomery_helper
      12  psa_generate_derived_ecc_key_weierstrass_helper
     318  psa_generate_derived_key_internal
     406  psa_generate_key
     126  psa_generate_key_internal
      64  psa_generate_random
     130  psa_get_and_lock_key_slot_with_policy
      68  psa_get_and_lock_transparent_key_slot_with_policy
      90  psa_get_key_attributes
       4  psa_get_key_bits
       4  psa_get_key_id
       4  psa_get_key_lifetime
       4  psa_get_key_type
      26  psa_hash_abort
      48  psa_hash_clone
     110  psa_hash_compare
      62  psa_hash_compute
      54  psa_hash_finish
      86  psa_hash_setup
      36  psa_hash_try_support
      64  psa_hash_update
      86  psa_hash_verify
     260  psa_import_key
     204  psa_import_key_into_slot
       8  psa_interruptible_get_max_ops
       4  psa_interruptible_max_ops
       8  psa_interruptible_set_max_ops
     106  psa_key_agreement_internal
      62  psa_key_agreement_raw_builtin
      94  psa_key_agreement_raw_internal
      20  psa_key_agreement_try_support
   1'096  psa_key_algorithm_permits
     108  psa_key_derivation_abort
       6  psa_key_derivation_allows_free_form_secret_input
     164  psa_key_derivation_check_input_type
      22  psa_key_derivation_get_capacity
      28  psa_key_derivation_get_kdf_alg
      28  psa_key_derivation_input_bytes
      26  psa_key_derivation_input_integer
      40  psa_key_derivation_input_integer_internal
      98  psa_key_derivation_input_internal
     122  psa_key_derivation_input_key
     140  psa_key_derivation_key_agreement
     170  psa_key_derivation_output_bytes
     176  psa_key_derivation_output_key
      32  psa_key_derivation_set_capacity
     164  psa_key_derivation_setup
     388  psa_key_derivation_setup_kdf
     364  psa_key_derivation_start_hmac
     576  psa_key_derivation_tls12_prf_generate_next_block
     440  psa_key_derivation_tls12_prf_read
      16  psa_key_lifetime_is_external
   1'254  psa_key_policy_algorithm_intersection
     274  psa_key_policy_permits
      38  psa_mac_abort
      44  psa_mac_compute
     210  psa_mac_compute_internal
     774  psa_mac_finalize_alg_and_key_validation
      98  psa_mac_key_can_do
     200  psa_mac_setup
     138  psa_mac_sign_finish
      22  psa_mac_sign_setup
      54  psa_mac_update
     110  psa_mac_verify
      94  psa_mac_verify_finish
      22  psa_mac_verify_setup
     184  psa_raw_key_agreement
      30  psa_remove_key_data_from_memory
      96  psa_restrict_key_policy
      20  psa_set_key_bits
      32  psa_set_key_type
      16  psa_set_key_usage_flags
      42  psa_sign_hash
      28  psa_sign_hash_abort
      30  psa_sign_hash_abort_internal
     136  psa_sign_hash_builtin
     116  psa_sign_hash_complete
       4  psa_sign_hash_get_num_ops
     232  psa_sign_hash_start
     252  psa_sign_internal
      42  psa_sign_message
     250  psa_sign_message_builtin
     338  psa_sign_verify_check_alg
     160  psa_start_key_creation
      76  psa_tls12_prf_input
      84  psa_tls12_prf_set_key
      78  psa_tls12_prf_set_label
      78  psa_tls12_prf_set_seed
     160  psa_validate_key_attributes
      22  psa_validate_key_policy
      84  psa_validate_key_type_and_size_for_key_generation
      58  psa_validate_optional_attributes
      66  psa_validate_tag_length
      90  psa_validate_unstructured_key_bit_size
      34  psa_verify_hash
      28  psa_verify_hash_abort
      30  psa_verify_hash_abort_internal
     136  psa_verify_hash_builtin
      70  psa_verify_hash_complete
       4  psa_verify_hash_get_num_ops
     232  psa_verify_hash_start
     190  psa_verify_internal
      34  psa_verify_message
     246  psa_verify_message_builtin
      66  psa_wipe_key_slot
      50  psa_wipe_tag_output_buffer
     260  sl_psa_key_derivation_single_shot

 
     12 bytes in section .bss
      4 bytes in section .data
  1'300 bytes in section .rodata
 26'720 bytes in section .text
 
 26'720 bytes of CODE  memory
  1'300 bytes of CONST memory
     16 bytes of DATA  memory

Errors: none
Warnings: none
