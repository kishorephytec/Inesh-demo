###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:42
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ctr_drbg.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ctr_drbg.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ctr_drbg.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ctr_drbg.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\ctr_drbg.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ctr_drbg.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ctr_drbg.c
      1          /*
      2           *  CTR_DRBG implementation based on AES-256 (NIST SP 800-90)
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          /*
     20           *  The NIST SP 800-90 DRBGs are described in the following publication.
     21           *
     22           *  https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-90r.pdf
     23           */
     24          
     25          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint32_t mbedtls_get_unaligned_uint32(void const *)
   \                     mbedtls_get_unaligned_uint32: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2404             MOVS     R4,#+4
   \        0x6   0x003D             MOVS     R5,R7
   \        0x8   0x466E             MOV      R6,SP
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint32(void *, uint32_t)
   \                     mbedtls_put_unaligned_uint32: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2404             MOVS     R4,#+4
   \        0x6   0x466D             MOV      R5,SP
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_bswap32(uint32_t)
   \                     mbedtls_bswap32: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x0208             LSLS     R0,R1,#+8
   \        0x4   0xF410 0x007F      ANDS     R0,R0,#0xFF0000
   \        0x8   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \        0xC   0x000A             MOVS     R2,R1
   \        0xE   0x0A12             LSRS     R2,R2,#+8
   \       0x10   0xF412 0x427F      ANDS     R2,R2,#0xFF00
   \       0x14   0x4310             ORRS     R0,R2,R0
   \       0x16   0xEA50 0x6011      ORRS     R0,R0,R1, LSR #+24
   \       0x1A   0x4770             BX       LR

   \                                 In section .rodata, align 2
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256

   \                                 In section .text, align 2
   \   __vfp void mbedtls_xor(unsigned char *, unsigned char const *, unsigned char const *, size_t)
   \                     mbedtls_xor: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??mbedtls_xor_0: (+1)
   \       0x10   0xF118 0x0004      ADDS     R0,R8,#+4
   \       0x14   0x4287             CMP      R7,R0
   \       0x16   0xD313             BCC.N    ??mbedtls_xor_1
   \       0x18   0xEB05 0x0008      ADD      R0,R5,R8
   \       0x1C   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x20   0x4681             MOV      R9,R0
   \       0x22   0xEB06 0x0008      ADD      R0,R6,R8
   \       0x26   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x2A   0x4682             MOV      R10,R0
   \       0x2C   0xEA9A 0x0A09      EORS     R10,R10,R9
   \       0x30   0x4651             MOV      R1,R10
   \       0x32   0xEB04 0x0008      ADD      R0,R4,R8
   \       0x36   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
   \       0x3A   0xF118 0x0804      ADDS     R8,R8,#+4
   \       0x3E   0xE7E7             B.N      ??mbedtls_xor_0
   \                     ??mbedtls_xor_1: (+1)
   \       0x40   0x45B8             CMP      R8,R7
   \       0x42   0xD209             BCS.N    ??mbedtls_xor_2
   \       0x44   0xF815 0x1008      LDRB     R1,[R5, R8]
   \       0x48   0xF816 0x0008      LDRB     R0,[R6, R8]
   \       0x4C   0x4041             EORS     R1,R0,R1
   \       0x4E   0xF804 0x1008      STRB     R1,[R4, R8]
   \       0x52   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x56   0xE7F3             B.N      ??mbedtls_xor_1
   \                     ??mbedtls_xor_2: (+1)
   \       0x58   0xE8BD 0x87F0      POP      {R4-R10,PC}
     26          
     27          #if defined(MBEDTLS_CTR_DRBG_C)
     28          
     29          #include "mbedtls/ctr_drbg.h"
     30          #include "mbedtls/platform_util.h"
     31          #include "mbedtls/error.h"
     32          
     33          #include <string.h>
     34          
     35          #if defined(MBEDTLS_FS_IO)
     36          #include <stdio.h>
     37          #endif
     38          
     39          #include "mbedtls/platform.h"
     40          
     41          /*
     42           * CTR_DRBG context initialization
     43           */

   \                                 In section .text, align 2, keep-with-next
     44          void mbedtls_ctr_drbg_init(mbedtls_ctr_drbg_context *ctx)
     45          {
   \                     mbedtls_ctr_drbg_init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
     46              memset(ctx, 0, sizeof(mbedtls_ctr_drbg_context));
   \        0x4   0x2560             MOVS     R5,#+96
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0x0027             MOVS     R7,R4
   \        0xA   0x0032             MOVS     R2,R6
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0038             MOVS     R0,R7
   \       0x10   0x.... 0x....      BL       __aeabi_memset
     47              mbedtls_aes_init(&ctx->aes_ctx);
   \       0x14   0xF114 0x0020      ADDS     R0,R4,#+32
   \       0x18   0x.... 0x....      BL       mbedtls_aes_init
     48              /* Indicate that the entropy nonce length is not set explicitly.
     49               * See mbedtls_ctr_drbg_set_nonce_len(). */
     50              ctx->reseed_counter = -1;
   \       0x1C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x20   0x6120             STR      R0,[R4, #+16]
     51          
     52              ctx->reseed_interval = MBEDTLS_CTR_DRBG_RESEED_INTERVAL;
   \       0x22   0xF242 0x7010      MOVW     R0,#+10000
   \       0x26   0x61E0             STR      R0,[R4, #+28]
     53          }
   \       0x28   0xBDF1             POP      {R0,R4-R7,PC}
     54          
     55          /*
     56           *  This function resets CTR_DRBG context to the state immediately
     57           *  after initial call of mbedtls_ctr_drbg_init().
     58           */

   \                                 In section .text, align 2, keep-with-next
     59          void mbedtls_ctr_drbg_free(mbedtls_ctr_drbg_context *ctx)
     60          {
   \                     mbedtls_ctr_drbg_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     61              if (ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD016             BEQ.N    ??mbedtls_ctr_drbg_free_0
     62                  return;
     63              }
     64          
     65          #if defined(MBEDTLS_THREADING_C)
     66              /* The mutex is initialized iff f_entropy is set. */
     67              if (ctx->f_entropy != NULL) {
   \                     ??mbedtls_ctr_drbg_free_1: (+1)
   \        0x8   0x6C60             LDR      R0,[R4, #+68]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD005             BEQ.N    ??mbedtls_ctr_drbg_free_2
     68                  mbedtls_mutex_free(&ctx->mutex);
   \        0xE   0xF114 0x004C      ADDS     R0,R4,#+76
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable4
   \       0x16   0x6809             LDR      R1,[R1, #+0]
   \       0x18   0x4788             BLX      R1
     69              }
     70          #endif
     71              mbedtls_aes_free(&ctx->aes_ctx);
   \                     ??mbedtls_ctr_drbg_free_2: (+1)
   \       0x1A   0xF114 0x0020      ADDS     R0,R4,#+32
   \       0x1E   0x.... 0x....      BL       mbedtls_aes_free
     72              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_ctr_drbg_context));
   \       0x22   0x2160             MOVS     R1,#+96
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_platform_zeroize
     73              ctx->reseed_interval = MBEDTLS_CTR_DRBG_RESEED_INTERVAL;
   \       0x2A   0xF242 0x7010      MOVW     R0,#+10000
   \       0x2E   0x61E0             STR      R0,[R4, #+28]
     74              ctx->reseed_counter = -1;
   \       0x30   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x34   0x6120             STR      R0,[R4, #+16]
     75          }
   \                     ??mbedtls_ctr_drbg_free_0: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
     76          

   \                                 In section .text, align 2, keep-with-next
     77          void mbedtls_ctr_drbg_set_prediction_resistance(mbedtls_ctr_drbg_context *ctx,
     78                                                          int resistance)
     79          {
     80              ctx->prediction_resistance = resistance;
   \                     mbedtls_ctr_drbg_set_prediction_resistance: (+1)
   \        0x0   0x6141             STR      R1,[R0, #+20]
     81          }
   \        0x2   0x4770             BX       LR
     82          

   \                                 In section .text, align 2, keep-with-next
     83          void mbedtls_ctr_drbg_set_entropy_len(mbedtls_ctr_drbg_context *ctx,
     84                                                size_t len)
     85          {
     86              ctx->entropy_len = len;
   \                     mbedtls_ctr_drbg_set_entropy_len: (+1)
   \        0x0   0x6181             STR      R1,[R0, #+24]
     87          }
   \        0x2   0x4770             BX       LR
     88          

   \                                 In section .text, align 2, keep-with-next
     89          int mbedtls_ctr_drbg_set_nonce_len(mbedtls_ctr_drbg_context *ctx,
     90                                             size_t len)
     91          {
   \                     mbedtls_ctr_drbg_set_nonce_len: (+1)
   \        0x0   0x0002             MOVS     R2,R0
     92              /* If mbedtls_ctr_drbg_seed() has already been called, it's
     93               * too late. Return the error code that's closest to making sense. */
     94              if (ctx->f_entropy != NULL) {
   \        0x2   0x6C50             LDR      R0,[R2, #+68]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD002             BEQ.N    ??mbedtls_ctr_drbg_set_nonce_len_0
     95                  return MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED;
   \        0x8   0xF07F 0x0033      MVNS     R0,#+51
   \        0xC   0xE00E             B.N      ??mbedtls_ctr_drbg_set_nonce_len_1
     96              }
     97          
     98              if (len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT) {
   \                     ??mbedtls_ctr_drbg_set_nonce_len_0: (+1)
   \        0xE   0xF240 0x1081      MOVW     R0,#+385
   \       0x12   0x4281             CMP      R1,R0
   \       0x14   0xD302             BCC.N    ??mbedtls_ctr_drbg_set_nonce_len_2
     99                  return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
   \       0x16   0xF07F 0x0037      MVNS     R0,#+55
   \       0x1A   0xE007             B.N      ??mbedtls_ctr_drbg_set_nonce_len_1
    100              }
    101          
    102              /* This shouldn't be an issue because
    103               * MBEDTLS_CTR_DRBG_MAX_SEED_INPUT < INT_MAX in any sensible
    104               * configuration, but make sure anyway. */
    105              if (len > INT_MAX) {
   \                     ??mbedtls_ctr_drbg_set_nonce_len_2: (+1)
   \       0x1C   0xF1B1 0x4F00      CMP      R1,#+2147483648
   \       0x20   0xD302             BCC.N    ??mbedtls_ctr_drbg_set_nonce_len_3
    106                  return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
   \       0x22   0xF07F 0x0037      MVNS     R0,#+55
   \       0x26   0xE001             B.N      ??mbedtls_ctr_drbg_set_nonce_len_1
    107              }
    108          
    109              /* For backward compatibility with Mbed TLS <= 2.19, store the
    110               * entropy nonce length in a field that already exists, but isn't
    111               * used until after the initial seeding. */
    112              /* Due to the capping of len above, the value fits in an int. */
    113              ctx->reseed_counter = (int) len;
   \                     ??mbedtls_ctr_drbg_set_nonce_len_3: (+1)
   \       0x28   0x6111             STR      R1,[R2, #+16]
    114              return 0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ctr_drbg_set_nonce_len_1: (+1)
   \       0x2C   0x4770             BX       LR
    115          }
    116          

   \                                 In section .text, align 2, keep-with-next
    117          void mbedtls_ctr_drbg_set_reseed_interval(mbedtls_ctr_drbg_context *ctx,
    118                                                    int interval)
    119          {
    120              ctx->reseed_interval = interval;
   \                     mbedtls_ctr_drbg_set_reseed_interval: (+1)
   \        0x0   0x61C1             STR      R1,[R0, #+28]
    121          }
   \        0x2   0x4770             BX       LR
    122          

   \                                 In section .text, align 2, keep-with-next
    123          static int block_cipher_df(unsigned char *output,
    124                                     const unsigned char *data, size_t data_len)
    125          {
   \                     block_cipher_df: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xF5AD 0x7D0D      SUB      SP,SP,#+564
   \        0x8   0x0015             MOVS     R5,R2
    126              unsigned char buf[MBEDTLS_CTR_DRBG_MAX_SEED_INPUT +
    127                                MBEDTLS_CTR_DRBG_BLOCKSIZE + 16];
    128              unsigned char tmp[MBEDTLS_CTR_DRBG_SEEDLEN];
    129              unsigned char key[MBEDTLS_CTR_DRBG_KEYSIZE];
    130              unsigned char chain[MBEDTLS_CTR_DRBG_BLOCKSIZE];
    131              unsigned char *p, *iv;
    132              mbedtls_aes_context aes_ctx;
    133              int ret = 0;
   \        0xA   0xF05F 0x0900      MOVS     R9,#+0
    134          
    135              int i, j;
    136              size_t buf_len, use_len;
    137          
    138              if (data_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT) {
   \        0xE   0xF240 0x1081      MOVW     R0,#+385
   \       0x12   0x4285             CMP      R5,R0
   \       0x14   0xD302             BCC.N    ??block_cipher_df_0
    139                  return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
   \       0x16   0xF07F 0x0037      MVNS     R0,#+55
   \       0x1A   0xE0C5             B.N      ??block_cipher_df_1
    140              }
    141          
    142              memset(buf, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT +
    143                     MBEDTLS_CTR_DRBG_BLOCKSIZE + 16);
   \                     ??block_cipher_df_0: (+1)
   \       0x1C   0xF44F 0x77D0      MOV      R7,#+416
   \       0x20   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x24   0xAE25             ADD      R6,SP,#+148
   \       0x26   0x4652             MOV      R2,R10
   \       0x28   0x0039             MOVS     R1,R7
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0x.... 0x....      BL       __aeabi_memset
    144              mbedtls_aes_init(&aes_ctx);
   \       0x30   0xA808             ADD      R0,SP,#+32
   \       0x32   0x.... 0x....      BL       mbedtls_aes_init
    145          
    146              /*
    147               * Construct IV (16 bytes) and S in buffer
    148               * IV = Counter (in 32-bits) padded to 16 with zeroes
    149               * S = Length input string (in 32-bits) || Length of output (in 32-bits) ||
    150               *     data || 0x80
    151               *     (Total is padded to a multiple of 16-bytes with zeroes)
    152               */
    153              p = buf + MBEDTLS_CTR_DRBG_BLOCKSIZE;
   \       0x36   0xAE29             ADD      R6,SP,#+164
    154              MBEDTLS_PUT_UINT32_BE(data_len, p, 0);
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \       0x3C   0x7800             LDRB     R0,[R0, #+0]
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD104             BNE.N    ??block_cipher_df_2
   \       0x42   0x0029             MOVS     R1,R5
   \       0x44   0x0030             MOVS     R0,R6
   \       0x46   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
   \       0x4A   0xE006             B.N      ??block_cipher_df_3
   \                     ??block_cipher_df_2: (+1)
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0x.... 0x....      BL       mbedtls_bswap32
   \       0x52   0x0001             MOVS     R1,R0
   \       0x54   0x0030             MOVS     R0,R6
   \       0x56   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
    155              p += 4 + 3;
   \                     ??block_cipher_df_3: (+1)
   \       0x5A   0x1DF1             ADDS     R1,R6,#+7
    156              *p++ = MBEDTLS_CTR_DRBG_SEEDLEN;
   \       0x5C   0x2030             MOVS     R0,#+48
   \       0x5E   0x7008             STRB     R0,[R1, #+0]
   \       0x60   0x1C4E             ADDS     R6,R1,#+1
    157              memcpy(p, data, data_len);
   \       0x62   0x46AA             MOV      R10,R5
   \       0x64   0x988E             LDR      R0,[SP, #+568]
   \       0x66   0x9000             STR      R0,[SP, #+0]
   \       0x68   0x0037             MOVS     R7,R6
   \       0x6A   0x4652             MOV      R2,R10
   \       0x6C   0x9900             LDR      R1,[SP, #+0]
   \       0x6E   0x0038             MOVS     R0,R7
   \       0x70   0x.... 0x....      BL       __aeabi_memcpy
    158              p[data_len] = 0x80;
   \       0x74   0x2080             MOVS     R0,#+128
   \       0x76   0x5570             STRB     R0,[R6, R5]
    159          
    160              buf_len = MBEDTLS_CTR_DRBG_BLOCKSIZE + 8 + data_len + 1;
   \       0x78   0xF115 0x0019      ADDS     R0,R5,#+25
   \       0x7C   0x9003             STR      R0,[SP, #+12]
    161          
    162              for (i = 0; i < MBEDTLS_CTR_DRBG_KEYSIZE; i++) {
   \       0x7E   0x2700             MOVS     R7,#+0
   \                     ??block_cipher_df_4: (+1)
   \       0x80   0x2F20             CMP      R7,#+32
   \       0x82   0xDA03             BGE.N    ??block_cipher_df_5
    163                  key[i] = i;
   \       0x84   0xA811             ADD      R0,SP,#+68
   \       0x86   0x55C7             STRB     R7,[R0, R7]
    164              }
   \       0x88   0x1C7F             ADDS     R7,R7,#+1
   \       0x8A   0xE7F9             B.N      ??block_cipher_df_4
    165          
    166              if ((ret = mbedtls_aes_setkey_enc(&aes_ctx, key,
    167                                                MBEDTLS_CTR_DRBG_KEYBITS)) != 0) {
   \                     ??block_cipher_df_5: (+1)
   \       0x8C   0xF44F 0x7280      MOV      R2,#+256
   \       0x90   0xA911             ADD      R1,SP,#+68
   \       0x92   0xA808             ADD      R0,SP,#+32
   \       0x94   0x.... 0x....      BL       mbedtls_aes_setkey_enc
   \       0x98   0x9000             STR      R0,[SP, #+0]
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD168             BNE.N    ??block_cipher_df_6
    168                  goto exit;
    169              }
    170          
    171              /*
    172               * Reduce data to MBEDTLS_CTR_DRBG_SEEDLEN bytes of data
    173               */
    174              for (j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE) {
   \                     ??block_cipher_df_7: (+1)
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x4680             MOV      R8,R0
   \                     ??block_cipher_df_8: (+1)
   \       0xA2   0xF1B8 0x0F30      CMP      R8,#+48
   \       0xA6   0xDA3A             BGE.N    ??block_cipher_df_9
    175                  p = buf;
   \       0xA8   0xA825             ADD      R0,SP,#+148
   \       0xAA   0x0006             MOVS     R6,R0
    176                  memset(chain, 0, MBEDTLS_CTR_DRBG_BLOCKSIZE);
   \       0xAC   0xF05F 0x0B10      MOVS     R11,#+16
   \       0xB0   0xF05F 0x0900      MOVS     R9,#+0
   \       0xB4   0xF10D 0x0A10      ADD      R10,SP,#+16
   \       0xB8   0x464A             MOV      R2,R9
   \       0xBA   0x4659             MOV      R1,R11
   \       0xBC   0x4650             MOV      R0,R10
   \       0xBE   0x.... 0x....      BL       __aeabi_memset
    177                  use_len = buf_len;
   \       0xC2   0x9803             LDR      R0,[SP, #+12]
   \       0xC4   0x0004             MOVS     R4,R0
    178          
    179                  while (use_len > 0) {
   \                     ??block_cipher_df_10: (+1)
   \       0xC6   0x2C00             CMP      R4,#+0
   \       0xC8   0xD016             BEQ.N    ??block_cipher_df_11
    180                      mbedtls_xor(chain, chain, p, MBEDTLS_CTR_DRBG_BLOCKSIZE);
   \       0xCA   0x2310             MOVS     R3,#+16
   \       0xCC   0x0032             MOVS     R2,R6
   \       0xCE   0xA904             ADD      R1,SP,#+16
   \       0xD0   0xA804             ADD      R0,SP,#+16
   \       0xD2   0x.... 0x....      BL       mbedtls_xor
    181                      p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
   \       0xD6   0x3610             ADDS     R6,R6,#+16
    182                      use_len -= (use_len >= MBEDTLS_CTR_DRBG_BLOCKSIZE) ?
    183                                 MBEDTLS_CTR_DRBG_BLOCKSIZE : use_len;
   \       0xD8   0x2C10             CMP      R4,#+16
   \       0xDA   0xD301             BCC.N    ??block_cipher_df_12
   \       0xDC   0x2010             MOVS     R0,#+16
   \       0xDE   0xE000             B.N      ??block_cipher_df_13
   \                     ??block_cipher_df_12: (+1)
   \       0xE0   0x0020             MOVS     R0,R4
   \                     ??block_cipher_df_13: (+1)
   \       0xE2   0x1A24             SUBS     R4,R4,R0
    184          
    185                      if ((ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT,
    186                                                       chain, chain)) != 0) {
   \       0xE4   0xAB04             ADD      R3,SP,#+16
   \       0xE6   0xAA04             ADD      R2,SP,#+16
   \       0xE8   0x2101             MOVS     R1,#+1
   \       0xEA   0xA808             ADD      R0,SP,#+32
   \       0xEC   0x.... 0x....      BL       mbedtls_aes_crypt_ecb
   \       0xF0   0x9000             STR      R0,[SP, #+0]
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xD0E7             BEQ.N    ??block_cipher_df_10
    187                          goto exit;
   \       0xF6   0xE03B             B.N      ??block_cipher_df_6
    188                      }
    189                  }
    190          
    191                  memcpy(tmp + j, chain, MBEDTLS_CTR_DRBG_BLOCKSIZE);
   \                     ??block_cipher_df_11: (+1)
   \       0xF8   0xF05F 0x0B10      MOVS     R11,#+16
   \       0xFC   0xF10D 0x0910      ADD      R9,SP,#+16
   \      0x100   0xA819             ADD      R0,SP,#+100
   \      0x102   0xEB00 0x0A08      ADD      R10,R0,R8
   \      0x106   0x465A             MOV      R2,R11
   \      0x108   0x4649             MOV      R1,R9
   \      0x10A   0x4650             MOV      R0,R10
   \      0x10C   0x.... 0x....      BL       __aeabi_memcpy
    192          
    193                  /*
    194                   * Update IV
    195                   */
    196                  buf[3]++;
   \      0x110   0xA925             ADD      R1,SP,#+148
   \      0x112   0x78C8             LDRB     R0,[R1, #+3]
   \      0x114   0x1C40             ADDS     R0,R0,#+1
   \      0x116   0x70C8             STRB     R0,[R1, #+3]
    197              }
   \      0x118   0xF118 0x0810      ADDS     R8,R8,#+16
   \      0x11C   0xE7C1             B.N      ??block_cipher_df_8
    198          
    199              /*
    200               * Do final encryption with reduced data
    201               */
    202              if ((ret = mbedtls_aes_setkey_enc(&aes_ctx, tmp,
    203                                                MBEDTLS_CTR_DRBG_KEYBITS)) != 0) {
   \                     ??block_cipher_df_9: (+1)
   \      0x11E   0xF44F 0x7280      MOV      R2,#+256
   \      0x122   0xA919             ADD      R1,SP,#+100
   \      0x124   0xA808             ADD      R0,SP,#+32
   \      0x126   0x.... 0x....      BL       mbedtls_aes_setkey_enc
   \      0x12A   0x9000             STR      R0,[SP, #+0]
   \      0x12C   0x2800             CMP      R0,#+0
   \      0x12E   0xD11F             BNE.N    ??block_cipher_df_6
    204                  goto exit;
    205              }
    206              iv = tmp + MBEDTLS_CTR_DRBG_KEYSIZE;
   \                     ??block_cipher_df_14: (+1)
   \      0x130   0xA821             ADD      R0,SP,#+132
   \      0x132   0x9001             STR      R0,[SP, #+4]
    207              p = output;
   \      0x134   0x988D             LDR      R0,[SP, #+564]
   \      0x136   0x0006             MOVS     R6,R0
    208          
    209              for (j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE) {
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0x4680             MOV      R8,R0
   \                     ??block_cipher_df_15: (+1)
   \      0x13C   0xF1B8 0x0F30      CMP      R8,#+48
   \      0x140   0xDA16             BGE.N    ??block_cipher_df_6
    210                  if ((ret = mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT,
    211                                                   iv, iv)) != 0) {
   \      0x142   0x9B01             LDR      R3,[SP, #+4]
   \      0x144   0x9A01             LDR      R2,[SP, #+4]
   \      0x146   0x2101             MOVS     R1,#+1
   \      0x148   0xA808             ADD      R0,SP,#+32
   \      0x14A   0x.... 0x....      BL       mbedtls_aes_crypt_ecb
   \      0x14E   0x9000             STR      R0,[SP, #+0]
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD10D             BNE.N    ??block_cipher_df_6
    212                      goto exit;
    213                  }
    214                  memcpy(p, iv, MBEDTLS_CTR_DRBG_BLOCKSIZE);
   \                     ??block_cipher_df_16: (+1)
   \      0x154   0xF05F 0x0910      MOVS     R9,#+16
   \      0x158   0x9801             LDR      R0,[SP, #+4]
   \      0x15A   0x9002             STR      R0,[SP, #+8]
   \      0x15C   0x46B2             MOV      R10,R6
   \      0x15E   0x464A             MOV      R2,R9
   \      0x160   0x9902             LDR      R1,[SP, #+8]
   \      0x162   0x4650             MOV      R0,R10
   \      0x164   0x.... 0x....      BL       __aeabi_memcpy
    215                  p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
   \      0x168   0x3610             ADDS     R6,R6,#+16
    216              }
   \      0x16A   0xF118 0x0810      ADDS     R8,R8,#+16
   \      0x16E   0xE7E5             B.N      ??block_cipher_df_15
    217          exit:
    218              mbedtls_aes_free(&aes_ctx);
   \                     ??block_cipher_df_6: (+1)
   \      0x170   0xA808             ADD      R0,SP,#+32
   \      0x172   0x.... 0x....      BL       mbedtls_aes_free
    219              /*
    220               * tidy up the stack
    221               */
    222              mbedtls_platform_zeroize(buf, sizeof(buf));
   \      0x176   0xF44F 0x71D0      MOV      R1,#+416
   \      0x17A   0xA825             ADD      R0,SP,#+148
   \      0x17C   0x.... 0x....      BL       mbedtls_platform_zeroize
    223              mbedtls_platform_zeroize(tmp, sizeof(tmp));
   \      0x180   0x2130             MOVS     R1,#+48
   \      0x182   0xA819             ADD      R0,SP,#+100
   \      0x184   0x.... 0x....      BL       mbedtls_platform_zeroize
    224              mbedtls_platform_zeroize(key, sizeof(key));
   \      0x188   0x2120             MOVS     R1,#+32
   \      0x18A   0xA811             ADD      R0,SP,#+68
   \      0x18C   0x.... 0x....      BL       mbedtls_platform_zeroize
    225              mbedtls_platform_zeroize(chain, sizeof(chain));
   \      0x190   0x2110             MOVS     R1,#+16
   \      0x192   0xA804             ADD      R0,SP,#+16
   \      0x194   0x.... 0x....      BL       mbedtls_platform_zeroize
    226              if (0 != ret) {
   \      0x198   0x9800             LDR      R0,[SP, #+0]
   \      0x19A   0x2800             CMP      R0,#+0
   \      0x19C   0xD003             BEQ.N    ??block_cipher_df_17
    227                  /*
    228                   * wipe partial seed from memory
    229                   */
    230                  mbedtls_platform_zeroize(output, MBEDTLS_CTR_DRBG_SEEDLEN);
   \      0x19E   0x2130             MOVS     R1,#+48
   \      0x1A0   0x988D             LDR      R0,[SP, #+564]
   \      0x1A2   0x.... 0x....      BL       mbedtls_platform_zeroize
    231              }
    232          
    233              return ret;
   \                     ??block_cipher_df_17: (+1)
   \      0x1A6   0x9800             LDR      R0,[SP, #+0]
   \                     ??block_cipher_df_1: (+1)
   \      0x1A8   0xF50D 0x7D0F      ADD      SP,SP,#+572
   \      0x1AC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    234          }
    235          
    236          /* CTR_DRBG_Update (SP 800-90A &sect;10.2.1.2)
    237           * ctr_drbg_update_internal(ctx, provided_data)
    238           * implements
    239           * CTR_DRBG_Update(provided_data, Key, V)
    240           * with inputs and outputs
    241           *   ctx->aes_ctx = Key
    242           *   ctx->counter = V
    243           */

   \                                 In section .text, align 2, keep-with-next
    244          static int ctr_drbg_update_internal(mbedtls_ctr_drbg_context *ctx,
    245                                              const unsigned char data[MBEDTLS_CTR_DRBG_SEEDLEN])
    246          {
   \                     ctr_drbg_update_internal: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000D             MOVS     R5,R1
    247              unsigned char tmp[MBEDTLS_CTR_DRBG_SEEDLEN];
    248              unsigned char *p = tmp;
   \        0xA   0xAE01             ADD      R6,SP,#+4
    249              int i, j;
    250              int ret = 0;
   \        0xC   0x2700             MOVS     R7,#+0
    251          
    252              memset(tmp, 0, MBEDTLS_CTR_DRBG_SEEDLEN);
   \        0xE   0xF05F 0x0B30      MOVS     R11,#+48
   \       0x12   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x16   0xF10D 0x0804      ADD      R8,SP,#+4
   \       0x1A   0x4652             MOV      R2,R10
   \       0x1C   0x4659             MOV      R1,R11
   \       0x1E   0x4640             MOV      R0,R8
   \       0x20   0x.... 0x....      BL       __aeabi_memset
    253          
    254              for (j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE) {
   \       0x24   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??ctr_drbg_update_internal_0: (+1)
   \       0x28   0xF1B8 0x0F30      CMP      R8,#+48
   \       0x2C   0xDA22             BGE.N    ??ctr_drbg_update_internal_1
    255                  /*
    256                   * Increase counter
    257                   */
    258                  for (i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i > 0; i--) {
   \       0x2E   0x2010             MOVS     R0,#+16
   \       0x30   0x0004             MOVS     R4,R0
   \                     ??ctr_drbg_update_internal_2: (+1)
   \       0x32   0x2C01             CMP      R4,#+1
   \       0x34   0xDB10             BLT.N    ??ctr_drbg_update_internal_3
    259                      if (++ctx->counter[i - 1] != 0) {
   \       0x36   0xEB09 0x0004      ADD      R0,R9,R4
   \       0x3A   0xF810 0x1C01      LDRB     R1,[R0, #-1]
   \       0x3E   0x1C49             ADDS     R1,R1,#+1
   \       0x40   0xEB09 0x0004      ADD      R0,R9,R4
   \       0x44   0xF800 0x1C01      STRB     R1,[R0, #-1]
   \       0x48   0xEB09 0x0004      ADD      R0,R9,R4
   \       0x4C   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD101             BNE.N    ??ctr_drbg_update_internal_3
    260                          break;
    261                      }
    262                  }
   \                     ??ctr_drbg_update_internal_4: (+1)
   \       0x54   0x1E64             SUBS     R4,R4,#+1
   \       0x56   0xE7EC             B.N      ??ctr_drbg_update_internal_2
    263          
    264                  /*
    265                   * Crypt counter block
    266                   */
    267                  if ((ret = mbedtls_aes_crypt_ecb(&ctx->aes_ctx, MBEDTLS_AES_ENCRYPT,
    268                                                   ctx->counter, p)) != 0) {
   \                     ??ctr_drbg_update_internal_3: (+1)
   \       0x58   0x0033             MOVS     R3,R6
   \       0x5A   0x464A             MOV      R2,R9
   \       0x5C   0x2101             MOVS     R1,#+1
   \       0x5E   0xF119 0x0020      ADDS     R0,R9,#+32
   \       0x62   0x.... 0x....      BL       mbedtls_aes_crypt_ecb
   \       0x66   0x0007             MOVS     R7,R0
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD122             BNE.N    ??ctr_drbg_update_internal_5
    269                      goto exit;
    270                  }
    271          
    272                  p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
   \                     ??ctr_drbg_update_internal_6: (+1)
   \       0x6C   0x3610             ADDS     R6,R6,#+16
    273              }
   \       0x6E   0xF118 0x0810      ADDS     R8,R8,#+16
   \       0x72   0xE7D9             B.N      ??ctr_drbg_update_internal_0
    274          
    275              for (i = 0; i < MBEDTLS_CTR_DRBG_SEEDLEN; i++) {
   \                     ??ctr_drbg_update_internal_1: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x0004             MOVS     R4,R0
   \                     ??ctr_drbg_update_internal_7: (+1)
   \       0x78   0x2C30             CMP      R4,#+48
   \       0x7A   0xDA06             BGE.N    ??ctr_drbg_update_internal_8
    276                  tmp[i] ^= data[i];
   \       0x7C   0xAA01             ADD      R2,SP,#+4
   \       0x7E   0x5D11             LDRB     R1,[R2, R4]
   \       0x80   0x5D28             LDRB     R0,[R5, R4]
   \       0x82   0x4041             EORS     R1,R0,R1
   \       0x84   0x5511             STRB     R1,[R2, R4]
    277              }
   \       0x86   0x1C64             ADDS     R4,R4,#+1
   \       0x88   0xE7F6             B.N      ??ctr_drbg_update_internal_7
    278          
    279              /*
    280               * Update key and counter
    281               */
    282              if ((ret = mbedtls_aes_setkey_enc(&ctx->aes_ctx, tmp,
    283                                                MBEDTLS_CTR_DRBG_KEYBITS)) != 0) {
   \                     ??ctr_drbg_update_internal_8: (+1)
   \       0x8A   0xF44F 0x7280      MOV      R2,#+256
   \       0x8E   0xA901             ADD      R1,SP,#+4
   \       0x90   0xF119 0x0020      ADDS     R0,R9,#+32
   \       0x94   0x.... 0x....      BL       mbedtls_aes_setkey_enc
   \       0x98   0x0007             MOVS     R7,R0
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD109             BNE.N    ??ctr_drbg_update_internal_5
    284                  goto exit;
    285              }
    286              memcpy(ctx->counter, tmp + MBEDTLS_CTR_DRBG_KEYSIZE,
    287                     MBEDTLS_CTR_DRBG_BLOCKSIZE);
   \                     ??ctr_drbg_update_internal_9: (+1)
   \       0x9E   0x2010             MOVS     R0,#+16
   \       0xA0   0x9000             STR      R0,[SP, #+0]
   \       0xA2   0xF10D 0x0B24      ADD      R11,SP,#+36
   \       0xA6   0x46CA             MOV      R10,R9
   \       0xA8   0x9A00             LDR      R2,[SP, #+0]
   \       0xAA   0x4659             MOV      R1,R11
   \       0xAC   0x4650             MOV      R0,R10
   \       0xAE   0x.... 0x....      BL       __aeabi_memcpy
    288          
    289          exit:
    290              mbedtls_platform_zeroize(tmp, sizeof(tmp));
   \                     ??ctr_drbg_update_internal_5: (+1)
   \       0xB2   0x2130             MOVS     R1,#+48
   \       0xB4   0xA801             ADD      R0,SP,#+4
   \       0xB6   0x.... 0x....      BL       mbedtls_platform_zeroize
    291              return ret;
   \       0xBA   0x0038             MOVS     R0,R7
   \       0xBC   0xB00D             ADD      SP,SP,#+52
   \       0xBE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    292          }
    293          
    294          /* CTR_DRBG_Instantiate with derivation function (SP 800-90A &sect;10.2.1.3.2)
    295           * mbedtls_ctr_drbg_update(ctx, additional, add_len)
    296           * implements
    297           * CTR_DRBG_Instantiate(entropy_input, nonce, personalization_string,
    298           *                      security_strength) -> initial_working_state
    299           * with inputs
    300           *   ctx->counter = all-bits-0
    301           *   ctx->aes_ctx = context from all-bits-0 key
    302           *   additional[:add_len] = entropy_input || nonce || personalization_string
    303           * and with outputs
    304           *   ctx = initial_working_state
    305           */

   \                                 In section .text, align 2, keep-with-next
    306          int mbedtls_ctr_drbg_update(mbedtls_ctr_drbg_context *ctx,
    307                                      const unsigned char *additional,
    308                                      size_t add_len)
    309          {
   \                     mbedtls_ctr_drbg_update: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0014             MOVS     R4,R2
    310              unsigned char add_input[MBEDTLS_CTR_DRBG_SEEDLEN];
    311              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x086D      MVNS     R8,#+109
    312          
    313              if (add_len == 0) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD101             BNE.N    ??mbedtls_ctr_drbg_update_0
    314                  return 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE012             B.N      ??mbedtls_ctr_drbg_update_1
    315              }
    316          
    317              if ((ret = block_cipher_df(add_input, additional, add_len)) != 0) {
   \                     ??mbedtls_ctr_drbg_update_0: (+1)
   \       0x18   0x0022             MOVS     R2,R4
   \       0x1A   0x0031             MOVS     R1,R6
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x.... 0x....      BL       block_cipher_df
   \       0x22   0x0007             MOVS     R7,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD105             BNE.N    ??mbedtls_ctr_drbg_update_2
    318                  goto exit;
    319              }
    320              if ((ret = ctr_drbg_update_internal(ctx, add_input)) != 0) {
   \                     ??mbedtls_ctr_drbg_update_3: (+1)
   \       0x28   0x4669             MOV      R1,SP
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x.... 0x....      BL       ctr_drbg_update_internal
   \       0x30   0x0007             MOVS     R7,R0
   \       0x32   0x2800             CMP      R0,#+0
    321                  goto exit;
    322              }
    323          
    324          exit:
    325              mbedtls_platform_zeroize(add_input, sizeof(add_input));
   \                     ??mbedtls_ctr_drbg_update_2: (+1)
   \       0x34   0x2130             MOVS     R1,#+48
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x.... 0x....      BL       mbedtls_platform_zeroize
    326              return ret;
   \       0x3C   0x0038             MOVS     R0,R7
   \                     ??mbedtls_ctr_drbg_update_1: (+1)
   \       0x3E   0xB00C             ADD      SP,SP,#+48
   \       0x40   0xE8BD 0x81F0      POP      {R4-R8,PC}
    327          }
    328          
    329          /* CTR_DRBG_Reseed with derivation function (SP 800-90A &sect;10.2.1.4.2)
    330           * mbedtls_ctr_drbg_reseed(ctx, additional, len, nonce_len)
    331           * implements
    332           * CTR_DRBG_Reseed(working_state, entropy_input, additional_input)
    333           *                -> new_working_state
    334           * with inputs
    335           *   ctx contains working_state
    336           *   additional[:len] = additional_input
    337           * and entropy_input comes from calling ctx->f_entropy
    338           *                              for (ctx->entropy_len + nonce_len) bytes
    339           * and with output
    340           *   ctx contains new_working_state
    341           */

   \                                 In section .text, align 2, keep-with-next
    342          static int mbedtls_ctr_drbg_reseed_internal(mbedtls_ctr_drbg_context *ctx,
    343                                                      const unsigned char *additional,
    344                                                      size_t len,
    345                                                      size_t nonce_len)
    346          {
   \                     mbedtls_ctr_drbg_reseed_internal: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB0E1             SUB      SP,SP,#+388
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
    347              unsigned char seed[MBEDTLS_CTR_DRBG_MAX_SEED_INPUT];
    348              size_t seedlen = 0;
   \        0xE   0xF05F 0x0800      MOVS     R8,#+0
    349              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x006D      MVNS     R0,#+109
   \       0x16   0x9000             STR      R0,[SP, #+0]
    350          
    351              if (ctx->entropy_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT) {
   \       0x18   0x69B9             LDR      R1,[R7, #+24]
   \       0x1A   0xF240 0x1081      MOVW     R0,#+385
   \       0x1E   0x4281             CMP      R1,R0
   \       0x20   0xD302             BCC.N    ??mbedtls_ctr_drbg_reseed_internal_0
    352                  return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
   \       0x22   0xF07F 0x0037      MVNS     R0,#+55
   \       0x26   0xE05F             B.N      ??mbedtls_ctr_drbg_reseed_internal_1
    353              }
    354              if (nonce_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx->entropy_len) {
   \                     ??mbedtls_ctr_drbg_reseed_internal_0: (+1)
   \       0x28   0x69B8             LDR      R0,[R7, #+24]
   \       0x2A   0xF5D0 0x70C0      RSBS     R0,R0,#+384
   \       0x2E   0x42B0             CMP      R0,R6
   \       0x30   0xD202             BCS.N    ??mbedtls_ctr_drbg_reseed_internal_2
    355                  return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
   \       0x32   0xF07F 0x0037      MVNS     R0,#+55
   \       0x36   0xE057             B.N      ??mbedtls_ctr_drbg_reseed_internal_1
    356              }
    357              if (len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx->entropy_len - nonce_len) {
   \                     ??mbedtls_ctr_drbg_reseed_internal_2: (+1)
   \       0x38   0x69B8             LDR      R0,[R7, #+24]
   \       0x3A   0xF5D0 0x70C0      RSBS     R0,R0,#+384
   \       0x3E   0x1B80             SUBS     R0,R0,R6
   \       0x40   0x42A8             CMP      R0,R5
   \       0x42   0xD202             BCS.N    ??mbedtls_ctr_drbg_reseed_internal_3
    358                  return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
   \       0x44   0xF07F 0x0037      MVNS     R0,#+55
   \       0x48   0xE04E             B.N      ??mbedtls_ctr_drbg_reseed_internal_1
    359              }
    360          
    361              memset(seed, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT);
   \                     ??mbedtls_ctr_drbg_reseed_internal_3: (+1)
   \       0x4A   0xF44F 0x7BC0      MOV      R11,#+384
   \       0x4E   0xF05F 0x0900      MOVS     R9,#+0
   \       0x52   0xF10D 0x0A04      ADD      R10,SP,#+4
   \       0x56   0x464A             MOV      R2,R9
   \       0x58   0x4659             MOV      R1,R11
   \       0x5A   0x4650             MOV      R0,R10
   \       0x5C   0x.... 0x....      BL       __aeabi_memset
    362          
    363              /* Gather entropy_len bytes of entropy to seed state. */
    364              if (0 != ctx->f_entropy(ctx->p_entropy, seed, ctx->entropy_len)) {
   \       0x60   0x69BA             LDR      R2,[R7, #+24]
   \       0x62   0xA901             ADD      R1,SP,#+4
   \       0x64   0x6CB8             LDR      R0,[R7, #+72]
   \       0x66   0x6C7B             LDR      R3,[R7, #+68]
   \       0x68   0x4798             BLX      R3
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD002             BEQ.N    ??mbedtls_ctr_drbg_reseed_internal_4
    365                  return MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED;
   \       0x6E   0xF07F 0x0033      MVNS     R0,#+51
   \       0x72   0xE039             B.N      ??mbedtls_ctr_drbg_reseed_internal_1
    366              }
    367              seedlen += ctx->entropy_len;
   \                     ??mbedtls_ctr_drbg_reseed_internal_4: (+1)
   \       0x74   0x69B8             LDR      R0,[R7, #+24]
   \       0x76   0xEB10 0x0808      ADDS     R8,R0,R8
    368          
    369              /* Gather entropy for a nonce if requested. */
    370              if (nonce_len != 0) {
   \       0x7A   0x2E00             CMP      R6,#+0
   \       0x7C   0xD00D             BEQ.N    ??mbedtls_ctr_drbg_reseed_internal_5
    371                  if (0 != ctx->f_entropy(ctx->p_entropy, seed + seedlen, nonce_len)) {
   \       0x7E   0x0032             MOVS     R2,R6
   \       0x80   0xA801             ADD      R0,SP,#+4
   \       0x82   0xEB00 0x0108      ADD      R1,R0,R8
   \       0x86   0x6CB8             LDR      R0,[R7, #+72]
   \       0x88   0x6C7B             LDR      R3,[R7, #+68]
   \       0x8A   0x4798             BLX      R3
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD002             BEQ.N    ??mbedtls_ctr_drbg_reseed_internal_6
    372                      return MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED;
   \       0x90   0xF07F 0x0033      MVNS     R0,#+51
   \       0x94   0xE028             B.N      ??mbedtls_ctr_drbg_reseed_internal_1
    373                  }
    374                  seedlen += nonce_len;
   \                     ??mbedtls_ctr_drbg_reseed_internal_6: (+1)
   \       0x96   0xEB16 0x0808      ADDS     R8,R6,R8
    375              }
    376          
    377              /* Add additional data if provided. */
    378              if (additional != NULL && len != 0) {
   \                     ??mbedtls_ctr_drbg_reseed_internal_5: (+1)
   \       0x9A   0x2C00             CMP      R4,#+0
   \       0x9C   0xD00D             BEQ.N    ??mbedtls_ctr_drbg_reseed_internal_7
   \       0x9E   0x2D00             CMP      R5,#+0
   \       0xA0   0xD00B             BEQ.N    ??mbedtls_ctr_drbg_reseed_internal_7
    379                  memcpy(seed + seedlen, additional, len);
   \       0xA2   0x46AB             MOV      R11,R5
   \       0xA4   0x46A1             MOV      R9,R4
   \       0xA6   0xA801             ADD      R0,SP,#+4
   \       0xA8   0xEB00 0x0A08      ADD      R10,R0,R8
   \       0xAC   0x465A             MOV      R2,R11
   \       0xAE   0x4649             MOV      R1,R9
   \       0xB0   0x4650             MOV      R0,R10
   \       0xB2   0x.... 0x....      BL       __aeabi_memcpy
    380                  seedlen += len;
   \       0xB6   0xEB15 0x0808      ADDS     R8,R5,R8
    381              }
    382          
    383              /* Reduce to 384 bits. */
    384              if ((ret = block_cipher_df(seed, seed, seedlen)) != 0) {
   \                     ??mbedtls_ctr_drbg_reseed_internal_7: (+1)
   \       0xBA   0x4642             MOV      R2,R8
   \       0xBC   0xA901             ADD      R1,SP,#+4
   \       0xBE   0xA801             ADD      R0,SP,#+4
   \       0xC0   0x.... 0x....      BL       block_cipher_df
   \       0xC4   0x4681             MOV      R9,R0
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD108             BNE.N    ??mbedtls_ctr_drbg_reseed_internal_8
    385                  goto exit;
    386              }
    387          
    388              /* Update state. */
    389              if ((ret = ctr_drbg_update_internal(ctx, seed)) != 0) {
   \                     ??mbedtls_ctr_drbg_reseed_internal_9: (+1)
   \       0xCA   0xA901             ADD      R1,SP,#+4
   \       0xCC   0x0038             MOVS     R0,R7
   \       0xCE   0x.... 0x....      BL       ctr_drbg_update_internal
   \       0xD2   0x4681             MOV      R9,R0
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD101             BNE.N    ??mbedtls_ctr_drbg_reseed_internal_8
    390                  goto exit;
    391              }
    392              ctx->reseed_counter = 1;
   \                     ??mbedtls_ctr_drbg_reseed_internal_10: (+1)
   \       0xD8   0x2001             MOVS     R0,#+1
   \       0xDA   0x6138             STR      R0,[R7, #+16]
    393          
    394          exit:
    395              mbedtls_platform_zeroize(seed, sizeof(seed));
   \                     ??mbedtls_ctr_drbg_reseed_internal_8: (+1)
   \       0xDC   0xF44F 0x71C0      MOV      R1,#+384
   \       0xE0   0xA801             ADD      R0,SP,#+4
   \       0xE2   0x.... 0x....      BL       mbedtls_platform_zeroize
    396              return ret;
   \       0xE6   0x4648             MOV      R0,R9
   \                     ??mbedtls_ctr_drbg_reseed_internal_1: (+1)
   \       0xE8   0xB061             ADD      SP,SP,#+388
   \       0xEA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    397          }
    398          

   \                                 In section .text, align 2, keep-with-next
    399          int mbedtls_ctr_drbg_reseed(mbedtls_ctr_drbg_context *ctx,
    400                                      const unsigned char *additional, size_t len)
    401          {
   \                     mbedtls_ctr_drbg_reseed: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
    402              return mbedtls_ctr_drbg_reseed_internal(ctx, additional, len, 0);
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       mbedtls_ctr_drbg_reseed_internal
   \       0x14   0xBD70             POP      {R4-R6,PC}
    403          }
    404          
    405          /* Return a "good" nonce length for CTR_DRBG. The chosen nonce length
    406           * is sufficient to achieve the maximum security strength given the key
    407           * size and entropy length. If there is enough entropy in the initial
    408           * call to the entropy function to serve as both the entropy input and
    409           * the nonce, don't make a second call to get a nonce. */

   \                                 In section .text, align 2, keep-with-next
    410          static size_t good_nonce_len(size_t entropy_len)
    411          {
   \                     good_nonce_len: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    412              if (entropy_len >= MBEDTLS_CTR_DRBG_KEYSIZE * 3 / 2) {
   \        0x2   0x2930             CMP      R1,#+48
   \        0x4   0xD301             BCC.N    ??good_nonce_len_0
    413                  return 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE002             B.N      ??good_nonce_len_1
    414              } else {
    415                  return (entropy_len + 1) / 2;
   \                     ??good_nonce_len_0: (+1)
   \        0xA   0x1C49             ADDS     R1,R1,#+1
   \        0xC   0x0849             LSRS     R1,R1,#+1
   \        0xE   0x0008             MOVS     R0,R1
   \                     ??good_nonce_len_1: (+1)
   \       0x10   0x4770             BX       LR
    416              }
    417          }
    418          
    419          /* CTR_DRBG_Instantiate with derivation function (SP 800-90A &sect;10.2.1.3.2)
    420           * mbedtls_ctr_drbg_seed(ctx, f_entropy, p_entropy, custom, len)
    421           * implements
    422           * CTR_DRBG_Instantiate(entropy_input, nonce, personalization_string,
    423           *                      security_strength) -> initial_working_state
    424           * with inputs
    425           *   custom[:len] = nonce || personalization_string
    426           * where entropy_input comes from f_entropy for ctx->entropy_len bytes
    427           * and with outputs
    428           *   ctx = initial_working_state
    429           */

   \                                 In section .text, align 2, keep-with-next
    430          int mbedtls_ctr_drbg_seed(mbedtls_ctr_drbg_context *ctx,
    431                                    int (*f_entropy)(void *, unsigned char *, size_t),
    432                                    void *p_entropy,
    433                                    const unsigned char *custom,
    434                                    size_t len)
    435          {
   \                     mbedtls_ctr_drbg_seed: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
   \        0xE   0x9F12             LDR      R7,[SP, #+72]
    436              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x10   0xF07F 0x006D      MVNS     R0,#+109
   \       0x14   0x9000             STR      R0,[SP, #+0]
    437              unsigned char key[MBEDTLS_CTR_DRBG_KEYSIZE];
    438              size_t nonce_len;
    439          
    440              memset(key, 0, MBEDTLS_CTR_DRBG_KEYSIZE);
   \       0x16   0xF05F 0x0920      MOVS     R9,#+32
   \       0x1A   0xF05F 0x0800      MOVS     R8,#+0
   \       0x1E   0xF10D 0x0B04      ADD      R11,SP,#+4
   \       0x22   0x4642             MOV      R2,R8
   \       0x24   0x4649             MOV      R1,R9
   \       0x26   0x4658             MOV      R0,R11
   \       0x28   0x.... 0x....      BL       __aeabi_memset
    441          
    442              /* The mutex is initialized iff f_entropy is set. */
    443          #if defined(MBEDTLS_THREADING_C)
    444              mbedtls_mutex_init(&ctx->mutex);
   \       0x2C   0xF11A 0x004C      ADDS     R0,R10,#+76
   \       0x30   0x....             LDR.N    R1,??DataTable4_2
   \       0x32   0x6809             LDR      R1,[R1, #+0]
   \       0x34   0x4788             BLX      R1
    445          #endif
    446          
    447              ctx->f_entropy = f_entropy;
   \       0x36   0xF8CA 0x4044      STR      R4,[R10, #+68]
    448              ctx->p_entropy = p_entropy;
   \       0x3A   0xF8CA 0x5048      STR      R5,[R10, #+72]
    449          
    450              if (ctx->entropy_len == 0) {
   \       0x3E   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD102             BNE.N    ??mbedtls_ctr_drbg_seed_0
    451                  ctx->entropy_len = MBEDTLS_CTR_DRBG_ENTROPY_LEN;
   \       0x46   0x2020             MOVS     R0,#+32
   \       0x48   0xF8CA 0x0018      STR      R0,[R10, #+24]
    452              }
    453              /* ctx->reseed_counter contains the desired amount of entropy to
    454               * grab for a nonce (see mbedtls_ctr_drbg_set_nonce_len()).
    455               * If it's -1, indicating that the entropy nonce length was not set
    456               * explicitly, use a sufficiently large nonce for security. */
    457              nonce_len = (ctx->reseed_counter >= 0 ?
    458                           (size_t) ctx->reseed_counter :
    459                           good_nonce_len(ctx->entropy_len));
   \                     ??mbedtls_ctr_drbg_seed_0: (+1)
   \       0x4C   0xF8DA 0x0010      LDR      R0,[R10, #+16]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD402             BMI.N    ??mbedtls_ctr_drbg_seed_1
   \       0x54   0xF8DA 0x8010      LDR      R8,[R10, #+16]
   \       0x58   0xE004             B.N      ??mbedtls_ctr_drbg_seed_2
   \                     ??mbedtls_ctr_drbg_seed_1: (+1)
   \       0x5A   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \       0x5E   0x.... 0x....      BL       good_nonce_len
   \       0x62   0x4680             MOV      R8,R0
    460          
    461              /* Initialize with an empty key. */
    462              if ((ret = mbedtls_aes_setkey_enc(&ctx->aes_ctx, key,
    463                                                MBEDTLS_CTR_DRBG_KEYBITS)) != 0) {
   \                     ??mbedtls_ctr_drbg_seed_2: (+1)
   \       0x64   0xF44F 0x7280      MOV      R2,#+256
   \       0x68   0xA901             ADD      R1,SP,#+4
   \       0x6A   0xF11A 0x0020      ADDS     R0,R10,#+32
   \       0x6E   0x.... 0x....      BL       mbedtls_aes_setkey_enc
   \       0x72   0x4681             MOV      R9,R0
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD001             BEQ.N    ??mbedtls_ctr_drbg_seed_3
    464                  return ret;
   \       0x78   0x4648             MOV      R0,R9
   \       0x7A   0xE00B             B.N      ??mbedtls_ctr_drbg_seed_4
    465              }
    466          
    467              /* Do the initial seeding. */
    468              if ((ret = mbedtls_ctr_drbg_reseed_internal(ctx, custom, len,
    469                                                          nonce_len)) != 0) {
   \                     ??mbedtls_ctr_drbg_seed_3: (+1)
   \       0x7C   0x4643             MOV      R3,R8
   \       0x7E   0x003A             MOVS     R2,R7
   \       0x80   0x0031             MOVS     R1,R6
   \       0x82   0x4650             MOV      R0,R10
   \       0x84   0x.... 0x....      BL       mbedtls_ctr_drbg_reseed_internal
   \       0x88   0x0001             MOVS     R1,R0
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD001             BEQ.N    ??mbedtls_ctr_drbg_seed_5
    470                  return ret;
   \       0x8E   0x0008             MOVS     R0,R1
   \       0x90   0xE000             B.N      ??mbedtls_ctr_drbg_seed_4
    471              }
    472              return 0;
   \                     ??mbedtls_ctr_drbg_seed_5: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ctr_drbg_seed_4: (+1)
   \       0x94   0xB009             ADD      SP,SP,#+36
   \       0x96   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    473          }
    474          
    475          /* CTR_DRBG_Generate with derivation function (SP 800-90A &sect;10.2.1.5.2)
    476           * mbedtls_ctr_drbg_random_with_add(ctx, output, output_len, additional, add_len)
    477           * implements
    478           * CTR_DRBG_Reseed(working_state, entropy_input, additional[:add_len])
    479           *                -> working_state_after_reseed
    480           *                if required, then
    481           * CTR_DRBG_Generate(working_state_after_reseed,
    482           *                   requested_number_of_bits, additional_input)
    483           *                -> status, returned_bits, new_working_state
    484           * with inputs
    485           *   ctx contains working_state
    486           *   requested_number_of_bits = 8 * output_len
    487           *   additional[:add_len] = additional_input
    488           * and entropy_input comes from calling ctx->f_entropy
    489           * and with outputs
    490           *   status = SUCCESS (this function does the reseed internally)
    491           *   returned_bits = output[:output_len]
    492           *   ctx contains new_working_state
    493           */

   \                                 In section .text, align 2, keep-with-next
    494          int mbedtls_ctr_drbg_random_with_add(void *p_rng,
    495                                               unsigned char *output, size_t output_len,
    496                                               const unsigned char *additional, size_t add_len)
    497          {
   \                     mbedtls_ctr_drbg_random_with_add: (+1)
   \        0x0   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0014             MOVS     R4,R2
    498              int ret = 0;
   \        0x8   0x2700             MOVS     R7,#+0
    499              mbedtls_ctr_drbg_context *ctx = (mbedtls_ctr_drbg_context *) p_rng;
   \        0xA   0xF8DD 0x9048      LDR      R9,[SP, #+72]
    500              unsigned char add_input[MBEDTLS_CTR_DRBG_SEEDLEN];
    501              unsigned char *p = output;
   \        0xE   0xF8DD 0x804C      LDR      R8,[SP, #+76]
    502              unsigned char tmp[MBEDTLS_CTR_DRBG_BLOCKSIZE];
    503              int i;
    504              size_t use_len;
    505          
    506              if (output_len > MBEDTLS_CTR_DRBG_MAX_REQUEST) {
   \       0x12   0xF240 0x4001      MOVW     R0,#+1025
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD302             BCC.N    ??mbedtls_ctr_drbg_random_with_add_0
    507                  return MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG;
   \       0x1A   0xF07F 0x0035      MVNS     R0,#+53
   \       0x1E   0xE081             B.N      ??mbedtls_ctr_drbg_random_with_add_1
    508              }
    509          
    510              if (add_len > MBEDTLS_CTR_DRBG_MAX_INPUT) {
   \                     ??mbedtls_ctr_drbg_random_with_add_0: (+1)
   \       0x20   0x991E             LDR      R1,[SP, #+120]
   \       0x22   0xF240 0x1001      MOVW     R0,#+257
   \       0x26   0x4281             CMP      R1,R0
   \       0x28   0xD302             BCC.N    ??mbedtls_ctr_drbg_random_with_add_2
    511                  return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
   \       0x2A   0xF07F 0x0037      MVNS     R0,#+55
   \       0x2E   0xE079             B.N      ??mbedtls_ctr_drbg_random_with_add_1
    512              }
    513          
    514              memset(add_input, 0, MBEDTLS_CTR_DRBG_SEEDLEN);
   \                     ??mbedtls_ctr_drbg_random_with_add_2: (+1)
   \       0x30   0x2030             MOVS     R0,#+48
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0xF05F 0x0B00      MOVS     R11,#+0
   \       0x38   0xF10D 0x0A14      ADD      R10,SP,#+20
   \       0x3C   0x465A             MOV      R2,R11
   \       0x3E   0x9900             LDR      R1,[SP, #+0]
   \       0x40   0x4650             MOV      R0,R10
   \       0x42   0x.... 0x....      BL       __aeabi_memset
    515          
    516              if (ctx->reseed_counter > ctx->reseed_interval ||
    517                  ctx->prediction_resistance) {
   \       0x46   0xF8D9 0x101C      LDR      R1,[R9, #+28]
   \       0x4A   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x4E   0x4281             CMP      R1,R0
   \       0x50   0xDB03             BLT.N    ??mbedtls_ctr_drbg_random_with_add_3
   \       0x52   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD00B             BEQ.N    ??mbedtls_ctr_drbg_random_with_add_4
    518                  if ((ret = mbedtls_ctr_drbg_reseed(ctx, additional, add_len)) != 0) {
   \                     ??mbedtls_ctr_drbg_random_with_add_3: (+1)
   \       0x5A   0x9A1E             LDR      R2,[SP, #+120]
   \       0x5C   0x9914             LDR      R1,[SP, #+80]
   \       0x5E   0x4648             MOV      R0,R9
   \       0x60   0x.... 0x....      BL       mbedtls_ctr_drbg_reseed
   \       0x64   0x0007             MOVS     R7,R0
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD001             BEQ.N    ??mbedtls_ctr_drbg_random_with_add_5
    519                      return ret;
   \       0x6A   0x0038             MOVS     R0,R7
   \       0x6C   0xE05A             B.N      ??mbedtls_ctr_drbg_random_with_add_1
    520                  }
    521                  add_len = 0;
   \                     ??mbedtls_ctr_drbg_random_with_add_5: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x901E             STR      R0,[SP, #+120]
    522              }
    523          
    524              if (add_len > 0) {
   \                     ??mbedtls_ctr_drbg_random_with_add_4: (+1)
   \       0x72   0x981E             LDR      R0,[SP, #+120]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD00E             BEQ.N    ??mbedtls_ctr_drbg_random_with_add_6
    525                  if ((ret = block_cipher_df(add_input, additional, add_len)) != 0) {
   \       0x78   0x9A1E             LDR      R2,[SP, #+120]
   \       0x7A   0x9914             LDR      R1,[SP, #+80]
   \       0x7C   0xA805             ADD      R0,SP,#+20
   \       0x7E   0x.... 0x....      BL       block_cipher_df
   \       0x82   0x0007             MOVS     R7,R0
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD144             BNE.N    ??mbedtls_ctr_drbg_random_with_add_7
    526                      goto exit;
    527                  }
    528                  if ((ret = ctr_drbg_update_internal(ctx, add_input)) != 0) {
   \                     ??mbedtls_ctr_drbg_random_with_add_8: (+1)
   \       0x88   0xA905             ADD      R1,SP,#+20
   \       0x8A   0x4648             MOV      R0,R9
   \       0x8C   0x.... 0x....      BL       ctr_drbg_update_internal
   \       0x90   0x0007             MOVS     R7,R0
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD13D             BNE.N    ??mbedtls_ctr_drbg_random_with_add_7
    529                      goto exit;
    530                  }
    531              }
    532          
    533              while (output_len > 0) {
   \                     ??mbedtls_ctr_drbg_random_with_add_6: (+1)
   \       0x96   0x2C00             CMP      R4,#+0
   \       0x98   0xD02F             BEQ.N    ??mbedtls_ctr_drbg_random_with_add_9
    534                  /*
    535                   * Increase counter
    536                   */
    537                  for (i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i > 0; i--) {
   \       0x9A   0x2010             MOVS     R0,#+16
   \       0x9C   0x0005             MOVS     R5,R0
   \                     ??mbedtls_ctr_drbg_random_with_add_10: (+1)
   \       0x9E   0x2D01             CMP      R5,#+1
   \       0xA0   0xDB10             BLT.N    ??mbedtls_ctr_drbg_random_with_add_11
    538                      if (++ctx->counter[i - 1] != 0) {
   \       0xA2   0xEB09 0x0005      ADD      R0,R9,R5
   \       0xA6   0xF810 0x1C01      LDRB     R1,[R0, #-1]
   \       0xAA   0x1C49             ADDS     R1,R1,#+1
   \       0xAC   0xEB09 0x0005      ADD      R0,R9,R5
   \       0xB0   0xF800 0x1C01      STRB     R1,[R0, #-1]
   \       0xB4   0xEB09 0x0005      ADD      R0,R9,R5
   \       0xB8   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD101             BNE.N    ??mbedtls_ctr_drbg_random_with_add_11
    539                          break;
    540                      }
    541                  }
   \                     ??mbedtls_ctr_drbg_random_with_add_12: (+1)
   \       0xC0   0x1E6D             SUBS     R5,R5,#+1
   \       0xC2   0xE7EC             B.N      ??mbedtls_ctr_drbg_random_with_add_10
    542          
    543                  /*
    544                   * Crypt counter block
    545                   */
    546                  if ((ret = mbedtls_aes_crypt_ecb(&ctx->aes_ctx, MBEDTLS_AES_ENCRYPT,
    547                                                   ctx->counter, tmp)) != 0) {
   \                     ??mbedtls_ctr_drbg_random_with_add_11: (+1)
   \       0xC4   0xAB01             ADD      R3,SP,#+4
   \       0xC6   0x464A             MOV      R2,R9
   \       0xC8   0x2101             MOVS     R1,#+1
   \       0xCA   0xF119 0x0020      ADDS     R0,R9,#+32
   \       0xCE   0x.... 0x....      BL       mbedtls_aes_crypt_ecb
   \       0xD2   0x0007             MOVS     R7,R0
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD11C             BNE.N    ??mbedtls_ctr_drbg_random_with_add_7
    548                      goto exit;
    549                  }
    550          
    551                  use_len = (output_len > MBEDTLS_CTR_DRBG_BLOCKSIZE)
    552                      ? MBEDTLS_CTR_DRBG_BLOCKSIZE : output_len;
   \                     ??mbedtls_ctr_drbg_random_with_add_13: (+1)
   \       0xD8   0x2C11             CMP      R4,#+17
   \       0xDA   0xD301             BCC.N    ??mbedtls_ctr_drbg_random_with_add_14
   \       0xDC   0x2610             MOVS     R6,#+16
   \       0xDE   0xE000             B.N      ??mbedtls_ctr_drbg_random_with_add_15
   \                     ??mbedtls_ctr_drbg_random_with_add_14: (+1)
   \       0xE0   0x0026             MOVS     R6,R4
    553                  /*
    554                   * Copy random block to destination
    555                   */
    556                  memcpy(p, tmp, use_len);
   \                     ??mbedtls_ctr_drbg_random_with_add_15: (+1)
   \       0xE2   0x9600             STR      R6,[SP, #+0]
   \       0xE4   0xF10D 0x0B04      ADD      R11,SP,#+4
   \       0xE8   0x46C2             MOV      R10,R8
   \       0xEA   0x9A00             LDR      R2,[SP, #+0]
   \       0xEC   0x4659             MOV      R1,R11
   \       0xEE   0x4650             MOV      R0,R10
   \       0xF0   0x.... 0x....      BL       __aeabi_memcpy
    557                  p += use_len;
   \       0xF4   0x44B0             ADD      R8,R8,R6
    558                  output_len -= use_len;
   \       0xF6   0x1BA4             SUBS     R4,R4,R6
   \       0xF8   0xE7CD             B.N      ??mbedtls_ctr_drbg_random_with_add_6
    559              }
    560          
    561              if ((ret = ctr_drbg_update_internal(ctx, add_input)) != 0) {
   \                     ??mbedtls_ctr_drbg_random_with_add_9: (+1)
   \       0xFA   0xA905             ADD      R1,SP,#+20
   \       0xFC   0x4648             MOV      R0,R9
   \       0xFE   0x.... 0x....      BL       ctr_drbg_update_internal
   \      0x102   0x0007             MOVS     R7,R0
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD104             BNE.N    ??mbedtls_ctr_drbg_random_with_add_7
    562                  goto exit;
    563              }
    564          
    565              ctx->reseed_counter++;
   \                     ??mbedtls_ctr_drbg_random_with_add_16: (+1)
   \      0x108   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \      0x10C   0x1C40             ADDS     R0,R0,#+1
   \      0x10E   0xF8C9 0x0010      STR      R0,[R9, #+16]
    566          
    567          exit:
    568              mbedtls_platform_zeroize(add_input, sizeof(add_input));
   \                     ??mbedtls_ctr_drbg_random_with_add_7: (+1)
   \      0x112   0x2130             MOVS     R1,#+48
   \      0x114   0xA805             ADD      R0,SP,#+20
   \      0x116   0x.... 0x....      BL       mbedtls_platform_zeroize
    569              mbedtls_platform_zeroize(tmp, sizeof(tmp));
   \      0x11A   0x2110             MOVS     R1,#+16
   \      0x11C   0xA801             ADD      R0,SP,#+4
   \      0x11E   0x.... 0x....      BL       mbedtls_platform_zeroize
    570              return ret;
   \      0x122   0x0038             MOVS     R0,R7
   \                     ??mbedtls_ctr_drbg_random_with_add_1: (+1)
   \      0x124   0xB015             ADD      SP,SP,#+84
   \      0x126   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    571          }
    572          

   \                                 In section .text, align 2, keep-with-next
    573          int mbedtls_ctr_drbg_random(void *p_rng, unsigned char *output,
    574                                      size_t output_len)
    575          {
   \                     mbedtls_ctr_drbg_random: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    576              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x096D      MVNS     R9,#+109
    577              mbedtls_ctr_drbg_context *ctx = (mbedtls_ctr_drbg_context *) p_rng;
   \        0xE   0x0027             MOVS     R7,R4
    578          
    579          #if defined(MBEDTLS_THREADING_C)
    580              if ((ret = mbedtls_mutex_lock(&ctx->mutex)) != 0) {
   \       0x10   0xF117 0x004C      ADDS     R0,R7,#+76
   \       0x14   0x....             LDR.N    R1,??DataTable4_3
   \       0x16   0x6809             LDR      R1,[R1, #+0]
   \       0x18   0x4788             BLX      R1
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD001             BEQ.N    ??mbedtls_ctr_drbg_random_0
    581                  return ret;
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0xE013             B.N      ??mbedtls_ctr_drbg_random_1
    582              }
    583          #endif
    584          
    585              ret = mbedtls_ctr_drbg_random_with_add(ctx, output, output_len, NULL, 0);
   \                     ??mbedtls_ctr_drbg_random_0: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x0032             MOVS     R2,R6
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0x.... 0x....      BL       mbedtls_ctr_drbg_random_with_add
   \       0x34   0x4681             MOV      R9,R0
    586          
    587          #if defined(MBEDTLS_THREADING_C)
    588              if (mbedtls_mutex_unlock(&ctx->mutex) != 0) {
   \       0x36   0xF117 0x004C      ADDS     R0,R7,#+76
   \       0x3A   0x....             LDR.N    R1,??DataTable4_4
   \       0x3C   0x6809             LDR      R1,[R1, #+0]
   \       0x3E   0x4788             BLX      R1
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD002             BEQ.N    ??mbedtls_ctr_drbg_random_2
    589                  return MBEDTLS_ERR_THREADING_MUTEX_ERROR;
   \       0x44   0xF07F 0x001D      MVNS     R0,#+29
   \       0x48   0xE000             B.N      ??mbedtls_ctr_drbg_random_1
    590              }
    591          #endif
    592          
    593              return ret;
   \                     ??mbedtls_ctr_drbg_random_2: (+1)
   \       0x4A   0x4648             MOV      R0,R9
   \                     ??mbedtls_ctr_drbg_random_1: (+1)
   \       0x4C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    594          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     mbedtls_mutex_free

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     mbedtls_byte_order_detector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     mbedtls_mutex_init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     mbedtls_mutex_lock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x....'....        DC32     mbedtls_mutex_unlock
    595          
    596          #if defined(MBEDTLS_FS_IO)
    597          int mbedtls_ctr_drbg_write_seed_file(mbedtls_ctr_drbg_context *ctx,
    598                                               const char *path)
    599          {
    600              int ret = MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR;
    601              FILE *f;
    602              unsigned char buf[MBEDTLS_CTR_DRBG_MAX_INPUT];
    603          
    604              if ((f = fopen(path, "wb")) == NULL) {
    605                  return MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR;
    606              }
    607          
    608              /* Ensure no stdio buffering of secrets, as such buffers cannot be wiped. */
    609              mbedtls_setbuf(f, NULL);
    610          
    611              if ((ret = mbedtls_ctr_drbg_random(ctx, buf,
    612                                                 MBEDTLS_CTR_DRBG_MAX_INPUT)) != 0) {
    613                  goto exit;
    614              }
    615          
    616              if (fwrite(buf, 1, MBEDTLS_CTR_DRBG_MAX_INPUT, f) !=
    617                  MBEDTLS_CTR_DRBG_MAX_INPUT) {
    618                  ret = MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR;
    619              } else {
    620                  ret = 0;
    621              }
    622          
    623          exit:
    624              mbedtls_platform_zeroize(buf, sizeof(buf));
    625          
    626              fclose(f);
    627              return ret;
    628          }
    629          
    630          int mbedtls_ctr_drbg_update_seed_file(mbedtls_ctr_drbg_context *ctx,
    631                                                const char *path)
    632          {
    633              int ret = 0;
    634              FILE *f = NULL;
    635              size_t n;
    636              unsigned char buf[MBEDTLS_CTR_DRBG_MAX_INPUT];
    637              unsigned char c;
    638          
    639              if ((f = fopen(path, "rb")) == NULL) {
    640                  return MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR;
    641              }
    642          
    643              /* Ensure no stdio buffering of secrets, as such buffers cannot be wiped. */
    644              mbedtls_setbuf(f, NULL);
    645          
    646              n = fread(buf, 1, sizeof(buf), f);
    647              if (fread(&c, 1, 1, f) != 0) {
    648                  ret = MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
    649                  goto exit;
    650              }
    651              if (n == 0 || ferror(f)) {
    652                  ret = MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR;
    653                  goto exit;
    654              }
    655              fclose(f);
    656              f = NULL;
    657          
    658              ret = mbedtls_ctr_drbg_update(ctx, buf, n);
    659          
    660          exit:
    661              mbedtls_platform_zeroize(buf, sizeof(buf));
    662              if (f != NULL) {
    663                  fclose(f);
    664              }
    665              if (ret != 0) {
    666                  return ret;
    667              }
    668              return mbedtls_ctr_drbg_write_seed_file(ctx, path);
    669          }
    670          #endif /* MBEDTLS_FS_IO */
    671          
    672          #if defined(MBEDTLS_SELF_TEST)
    673          
    674          /* The CTR_DRBG NIST test vectors used here are available at
    675           * https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/drbg/drbgtestvectors.zip
    676           *
    677           * The parameters used to derive the test data are:
    678           *
    679           * [AES-128 use df]
    680           * [PredictionResistance = True/False]
    681           * [EntropyInputLen = 128]
    682           * [NonceLen = 64]
    683           * [PersonalizationStringLen = 128]
    684           * [AdditionalInputLen = 0]
    685           * [ReturnedBitsLen = 512]
    686           *
    687           * [AES-256 use df]
    688           * [PredictionResistance = True/False]
    689           * [EntropyInputLen = 256]
    690           * [NonceLen = 128]
    691           * [PersonalizationStringLen = 256]
    692           * [AdditionalInputLen = 0]
    693           * [ReturnedBitsLen = 512]
    694           *
    695           */
    696          
    697          #if defined(MBEDTLS_CTR_DRBG_USE_128_BIT_KEY)
    698          static const unsigned char entropy_source_pr[] =
    699          { 0x04, 0xd9, 0x49, 0xa6, 0xdc, 0xe8, 0x6e, 0xbb,
    700            0xf1, 0x08, 0x77, 0x2b, 0x9e, 0x08, 0xca, 0x92,
    701            0x65, 0x16, 0xda, 0x99, 0xa2, 0x59, 0xf3, 0xe8,
    702            0x38, 0x7e, 0x3f, 0x6b, 0x51, 0x70, 0x7b, 0x20,
    703            0xec, 0x53, 0xd0, 0x66, 0xc3, 0x0f, 0xe3, 0xb0,
    704            0xe0, 0x86, 0xa6, 0xaa, 0x5f, 0x72, 0x2f, 0xad,
    705            0xf7, 0xef, 0x06, 0xb8, 0xd6, 0x9c, 0x9d, 0xe8 };
    706          
    707          static const unsigned char entropy_source_nopr[] =
    708          { 0x07, 0x0d, 0x59, 0x63, 0x98, 0x73, 0xa5, 0x45,
    709            0x27, 0x38, 0x22, 0x7b, 0x76, 0x85, 0xd1, 0xa9,
    710            0x74, 0x18, 0x1f, 0x3c, 0x22, 0xf6, 0x49, 0x20,
    711            0x4a, 0x47, 0xc2, 0xf3, 0x85, 0x16, 0xb4, 0x6f,
    712            0x00, 0x2e, 0x71, 0xda, 0xed, 0x16, 0x9b, 0x5c };
    713          
    714          static const unsigned char pers_pr[] =
    715          { 0xbf, 0xa4, 0x9a, 0x8f, 0x7b, 0xd8, 0xb1, 0x7a,
    716            0x9d, 0xfa, 0x45, 0xed, 0x21, 0x52, 0xb3, 0xad };
    717          
    718          static const unsigned char pers_nopr[] =
    719          { 0x4e, 0x61, 0x79, 0xd4, 0xc2, 0x72, 0xa1, 0x4c,
    720            0xf1, 0x3d, 0xf6, 0x5e, 0xa3, 0xa6, 0xe5, 0x0f };
    721          
    722          static const unsigned char result_pr[] =
    723          { 0xc9, 0x0a, 0xaf, 0x85, 0x89, 0x71, 0x44, 0x66,
    724            0x4f, 0x25, 0x0b, 0x2b, 0xde, 0xd8, 0xfa, 0xff,
    725            0x52, 0x5a, 0x1b, 0x32, 0x5e, 0x41, 0x7a, 0x10,
    726            0x1f, 0xef, 0x1e, 0x62, 0x23, 0xe9, 0x20, 0x30,
    727            0xc9, 0x0d, 0xad, 0x69, 0xb4, 0x9c, 0x5b, 0xf4,
    728            0x87, 0x42, 0xd5, 0xae, 0x5e, 0x5e, 0x43, 0xcc,
    729            0xd9, 0xfd, 0x0b, 0x93, 0x4a, 0xe3, 0xd4, 0x06,
    730            0x37, 0x36, 0x0f, 0x3f, 0x72, 0x82, 0x0c, 0xcf };
    731          
    732          static const unsigned char result_nopr[] =
    733          { 0x31, 0xc9, 0x91, 0x09, 0xf8, 0xc5, 0x10, 0x13,
    734            0x3c, 0xd3, 0x96, 0xf9, 0xbc, 0x2c, 0x12, 0xc0,
    735            0x7c, 0xc1, 0x61, 0x5f, 0xa3, 0x09, 0x99, 0xaf,
    736            0xd7, 0xf2, 0x36, 0xfd, 0x40, 0x1a, 0x8b, 0xf2,
    737            0x33, 0x38, 0xee, 0x1d, 0x03, 0x5f, 0x83, 0xb7,
    738            0xa2, 0x53, 0xdc, 0xee, 0x18, 0xfc, 0xa7, 0xf2,
    739            0xee, 0x96, 0xc6, 0xc2, 0xcd, 0x0c, 0xff, 0x02,
    740            0x76, 0x70, 0x69, 0xaa, 0x69, 0xd1, 0x3b, 0xe8 };
    741          #else /* MBEDTLS_CTR_DRBG_USE_128_BIT_KEY */
    742          
    743          static const unsigned char entropy_source_pr[] =
    744          { 0xca, 0x58, 0xfd, 0xf2, 0xb9, 0x77, 0xcb, 0x49,
    745            0xd4, 0xe0, 0x5b, 0xe2, 0x39, 0x50, 0xd9, 0x8a,
    746            0x6a, 0xb3, 0xc5, 0x2f, 0xdf, 0x74, 0xd5, 0x85,
    747            0x8f, 0xd1, 0xba, 0x64, 0x54, 0x7b, 0xdb, 0x1e,
    748            0xc5, 0xea, 0x24, 0xc0, 0xfa, 0x0c, 0x90, 0x15,
    749            0x09, 0x20, 0x92, 0x42, 0x32, 0x36, 0x45, 0x45,
    750            0x7d, 0x20, 0x76, 0x6b, 0xcf, 0xa2, 0x15, 0xc8,
    751            0x2f, 0x9f, 0xbc, 0x88, 0x3f, 0x80, 0xd1, 0x2c,
    752            0xb7, 0x16, 0xd1, 0x80, 0x9e, 0xe1, 0xc9, 0xb3,
    753            0x88, 0x1b, 0x21, 0x45, 0xef, 0xa1, 0x7f, 0xce,
    754            0xc8, 0x92, 0x35, 0x55, 0x2a, 0xd9, 0x1d, 0x8e,
    755            0x12, 0x38, 0xac, 0x01, 0x4e, 0x38, 0x18, 0x76,
    756            0x9c, 0xf2, 0xb6, 0xd4, 0x13, 0xb6, 0x2c, 0x77,
    757            0xc0, 0xe7, 0xe6, 0x0c, 0x47, 0x44, 0x95, 0xbe };
    758          
    759          static const unsigned char entropy_source_nopr[] =
    760          { 0x4c, 0xfb, 0x21, 0x86, 0x73, 0x34, 0x6d, 0x9d,
    761            0x50, 0xc9, 0x22, 0xe4, 0x9b, 0x0d, 0xfc, 0xd0,
    762            0x90, 0xad, 0xf0, 0x4f, 0x5c, 0x3b, 0xa4, 0x73,
    763            0x27, 0xdf, 0xcd, 0x6f, 0xa6, 0x3a, 0x78, 0x5c,
    764            0x01, 0x69, 0x62, 0xa7, 0xfd, 0x27, 0x87, 0xa2,
    765            0x4b, 0xf6, 0xbe, 0x47, 0xef, 0x37, 0x83, 0xf1,
    766            0xb7, 0xec, 0x46, 0x07, 0x23, 0x63, 0x83, 0x4a,
    767            0x1b, 0x01, 0x33, 0xf2, 0xc2, 0x38, 0x91, 0xdb,
    768            0x4f, 0x11, 0xa6, 0x86, 0x51, 0xf2, 0x3e, 0x3a,
    769            0x8b, 0x1f, 0xdc, 0x03, 0xb1, 0x92, 0xc7, 0xe7 };
    770          
    771          static const unsigned char pers_pr[] =
    772          { 0x5a, 0x70, 0x95, 0xe9, 0x81, 0x40, 0x52, 0x33,
    773            0x91, 0x53, 0x7e, 0x75, 0xd6, 0x19, 0x9d, 0x1e,
    774            0xad, 0x0d, 0xc6, 0xa7, 0xde, 0x6c, 0x1f, 0xe0,
    775            0xea, 0x18, 0x33, 0xa8, 0x7e, 0x06, 0x20, 0xe9 };
    776          
    777          static const unsigned char pers_nopr[] =
    778          { 0x88, 0xee, 0xb8, 0xe0, 0xe8, 0x3b, 0xf3, 0x29,
    779            0x4b, 0xda, 0xcd, 0x60, 0x99, 0xeb, 0xe4, 0xbf,
    780            0x55, 0xec, 0xd9, 0x11, 0x3f, 0x71, 0xe5, 0xeb,
    781            0xcb, 0x45, 0x75, 0xf3, 0xd6, 0xa6, 0x8a, 0x6b };
    782          
    783          static const unsigned char result_pr[] =
    784          { 0xce, 0x2f, 0xdb, 0xb6, 0xd9, 0xb7, 0x39, 0x85,
    785            0x04, 0xc5, 0xc0, 0x42, 0xc2, 0x31, 0xc6, 0x1d,
    786            0x9b, 0x5a, 0x59, 0xf8, 0x7e, 0x0d, 0xcc, 0x62,
    787            0x7b, 0x65, 0x11, 0x55, 0x10, 0xeb, 0x9e, 0x3d,
    788            0xa4, 0xfb, 0x1c, 0x6a, 0x18, 0xc0, 0x74, 0xdb,
    789            0xdd, 0xe7, 0x02, 0x23, 0x63, 0x21, 0xd0, 0x39,
    790            0xf9, 0xa7, 0xc4, 0x52, 0x84, 0x3b, 0x49, 0x40,
    791            0x72, 0x2b, 0xb0, 0x6c, 0x9c, 0xdb, 0xc3, 0x43 };
    792          
    793          static const unsigned char result_nopr[] =
    794          { 0xa5, 0x51, 0x80, 0xa1, 0x90, 0xbe, 0xf3, 0xad,
    795            0xaf, 0x28, 0xf6, 0xb7, 0x95, 0xe9, 0xf1, 0xf3,
    796            0xd6, 0xdf, 0xa1, 0xb2, 0x7d, 0xd0, 0x46, 0x7b,
    797            0x0c, 0x75, 0xf5, 0xfa, 0x93, 0x1e, 0x97, 0x14,
    798            0x75, 0xb2, 0x7c, 0xae, 0x03, 0xa2, 0x96, 0x54,
    799            0xe2, 0xf4, 0x09, 0x66, 0xea, 0x33, 0x64, 0x30,
    800            0x40, 0xd1, 0x40, 0x0f, 0xe6, 0x77, 0x87, 0x3a,
    801            0xf8, 0x09, 0x7c, 0x1f, 0xe9, 0xf0, 0x02, 0x98 };
    802          #endif /* MBEDTLS_CTR_DRBG_USE_128_BIT_KEY */
    803          
    804          static size_t test_offset;
    805          static int ctr_drbg_self_test_entropy(void *data, unsigned char *buf,
    806                                                size_t len)
    807          {
    808              const unsigned char *p = data;
    809              memcpy(buf, p + test_offset, len);
    810              test_offset += len;
    811              return 0;
    812          }
    813          
    814          #define CHK(c)    if ((c) != 0)                          \
    815              {                                       \
    816                  if (verbose != 0)                  \
    817                  mbedtls_printf("failed\n");  \
    818                  return 1;                        \
    819              }
    820          
    821          #define SELF_TEST_OUTPUT_DISCARD_LENGTH 64
    822          
    823          /*
    824           * Checkup routine
    825           */
    826          int mbedtls_ctr_drbg_self_test(int verbose)
    827          {
    828              mbedtls_ctr_drbg_context ctx;
    829              unsigned char buf[sizeof(result_pr)];
    830          
    831              mbedtls_ctr_drbg_init(&ctx);
    832          
    833              /*
    834               * Based on a NIST CTR_DRBG test vector (PR = True)
    835               */
    836              if (verbose != 0) {
    837                  mbedtls_printf("  CTR_DRBG (PR = TRUE) : ");
    838              }
    839          
    840              test_offset = 0;
    841              mbedtls_ctr_drbg_set_entropy_len(&ctx, MBEDTLS_CTR_DRBG_KEYSIZE);
    842              mbedtls_ctr_drbg_set_nonce_len(&ctx, MBEDTLS_CTR_DRBG_KEYSIZE / 2);
    843              CHK(mbedtls_ctr_drbg_seed(&ctx,
    844                                        ctr_drbg_self_test_entropy,
    845                                        (void *) entropy_source_pr,
    846                                        pers_pr, MBEDTLS_CTR_DRBG_KEYSIZE));
    847              mbedtls_ctr_drbg_set_prediction_resistance(&ctx, MBEDTLS_CTR_DRBG_PR_ON);
    848              CHK(mbedtls_ctr_drbg_random(&ctx, buf, SELF_TEST_OUTPUT_DISCARD_LENGTH));
    849              CHK(mbedtls_ctr_drbg_random(&ctx, buf, sizeof(result_pr)));
    850              CHK(memcmp(buf, result_pr, sizeof(result_pr)));
    851          
    852              mbedtls_ctr_drbg_free(&ctx);
    853          
    854              if (verbose != 0) {
    855                  mbedtls_printf("passed\n");
    856              }
    857          
    858              /*
    859               * Based on a NIST CTR_DRBG test vector (PR = FALSE)
    860               */
    861              if (verbose != 0) {
    862                  mbedtls_printf("  CTR_DRBG (PR = FALSE): ");
    863              }
    864          
    865              mbedtls_ctr_drbg_init(&ctx);
    866          
    867              test_offset = 0;
    868              mbedtls_ctr_drbg_set_entropy_len(&ctx, MBEDTLS_CTR_DRBG_KEYSIZE);
    869              mbedtls_ctr_drbg_set_nonce_len(&ctx, MBEDTLS_CTR_DRBG_KEYSIZE / 2);
    870              CHK(mbedtls_ctr_drbg_seed(&ctx,
    871                                        ctr_drbg_self_test_entropy,
    872                                        (void *) entropy_source_nopr,
    873                                        pers_nopr, MBEDTLS_CTR_DRBG_KEYSIZE));
    874              CHK(mbedtls_ctr_drbg_reseed(&ctx, NULL, 0));
    875              CHK(mbedtls_ctr_drbg_random(&ctx, buf, SELF_TEST_OUTPUT_DISCARD_LENGTH));
    876              CHK(mbedtls_ctr_drbg_random(&ctx, buf, sizeof(result_nopr)));
    877              CHK(memcmp(buf, result_nopr, sizeof(result_nopr)));
    878          
    879              mbedtls_ctr_drbg_free(&ctx);
    880          
    881              if (verbose != 0) {
    882                  mbedtls_printf("passed\n");
    883              }
    884          
    885              if (verbose != 0) {
    886                  mbedtls_printf("\n");
    887              }
    888          
    889              return 0;
    890          }
    891          #endif /* MBEDTLS_SELF_TEST */
    892          
    893          #endif /* MBEDTLS_CTR_DRBG_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     608   block_cipher_df
       608   -> __aeabi_memcpy
       608   -> __aeabi_memset
       608   -> mbedtls_aes_crypt_ecb
       608   -> mbedtls_aes_free
       608   -> mbedtls_aes_init
       608   -> mbedtls_aes_setkey_enc
       608   -> mbedtls_bswap32
       608   -> mbedtls_platform_zeroize
       608   -> mbedtls_put_unaligned_uint32
       608   -> mbedtls_xor
      88   ctr_drbg_update_internal
        88   -> __aeabi_memcpy
        88   -> __aeabi_memset
        88   -> mbedtls_aes_crypt_ecb
        88   -> mbedtls_aes_setkey_enc
        88   -> mbedtls_platform_zeroize
       0   good_nonce_len
       0   mbedtls_bswap32
       8   mbedtls_ctr_drbg_free
         8   -- Indirect call
         8   -> mbedtls_aes_free
         8   -> mbedtls_platform_zeroize
      24   mbedtls_ctr_drbg_init
        24   -> __aeabi_memset
        24   -> mbedtls_aes_init
      32   mbedtls_ctr_drbg_random
        32   -- Indirect call
        32   -> mbedtls_ctr_drbg_random_with_add
     120   mbedtls_ctr_drbg_random_with_add
       120   -> __aeabi_memcpy
       120   -> __aeabi_memset
       120   -> block_cipher_df
       120   -> ctr_drbg_update_internal
       120   -> mbedtls_aes_crypt_ecb
       120   -> mbedtls_ctr_drbg_reseed
       120   -> mbedtls_platform_zeroize
      16   mbedtls_ctr_drbg_reseed
        16   -> mbedtls_ctr_drbg_reseed_internal
     424   mbedtls_ctr_drbg_reseed_internal
       424   -- Indirect call
       424   -> __aeabi_memcpy
       424   -> __aeabi_memset
       424   -> block_cipher_df
       424   -> ctr_drbg_update_internal
       424   -> mbedtls_platform_zeroize
      72   mbedtls_ctr_drbg_seed
        72   -- Indirect call
        72   -> __aeabi_memset
        72   -> good_nonce_len
        72   -> mbedtls_aes_setkey_enc
        72   -> mbedtls_ctr_drbg_reseed_internal
       0   mbedtls_ctr_drbg_set_entropy_len
       0   mbedtls_ctr_drbg_set_nonce_len
       0   mbedtls_ctr_drbg_set_prediction_resistance
       0   mbedtls_ctr_drbg_set_reseed_interval
      72   mbedtls_ctr_drbg_update
        72   -> block_cipher_df
        72   -> ctr_drbg_update_internal
        72   -> mbedtls_platform_zeroize
      24   mbedtls_get_unaligned_uint32
        24   -> __aeabi_memcpy
      24   mbedtls_put_unaligned_uint32
        24   -> __aeabi_memcpy
      32   mbedtls_xor
        32   -> mbedtls_get_unaligned_uint32
        32   -> mbedtls_put_unaligned_uint32


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
     432  block_cipher_df
     194  ctr_drbg_update_internal
      18  good_nonce_len
      28  mbedtls_bswap32
       2  mbedtls_byte_order_detector
      56  mbedtls_ctr_drbg_free
      42  mbedtls_ctr_drbg_init
      80  mbedtls_ctr_drbg_random
     298  mbedtls_ctr_drbg_random_with_add
      22  mbedtls_ctr_drbg_reseed
     238  mbedtls_ctr_drbg_reseed_internal
     154  mbedtls_ctr_drbg_seed
       4  mbedtls_ctr_drbg_set_entropy_len
      46  mbedtls_ctr_drbg_set_nonce_len
       4  mbedtls_ctr_drbg_set_prediction_resistance
       4  mbedtls_ctr_drbg_set_reseed_interval
      68  mbedtls_ctr_drbg_update
      24  mbedtls_get_unaligned_uint32
      22  mbedtls_put_unaligned_uint32
      92  mbedtls_xor

 
     2 bytes in section .rodata
 1'846 bytes in section .text
 
 1'708 bytes of CODE  memory (+ 138 bytes shared)
     2 bytes of CONST memory

Errors: none
Warnings: none
