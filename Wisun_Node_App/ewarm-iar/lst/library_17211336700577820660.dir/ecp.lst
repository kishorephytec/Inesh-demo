###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:46
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ecp.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ecp.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ecp.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ecp.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\ecp.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ecp.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ecp.c
      1          /*
      2           *  Elliptic curves over GF(p): generic functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           * References:
     22           *
     23           * SEC1 https://www.secg.org/sec1-v2.pdf
     24           * GECC = Guide to Elliptic Curve Cryptography - Hankerson, Menezes, Vanstone
     25           * FIPS 186-3 http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf
     26           * RFC 4492 for the related TLS structures and constants
     27           * - https://www.rfc-editor.org/rfc/rfc4492
     28           * RFC 7748 for the Curve448 and Curve25519 curve definitions
     29           * - https://www.rfc-editor.org/rfc/rfc7748
     30           *
     31           * [Curve25519] https://cr.yp.to/ecdh/curve25519-20060209.pdf
     32           *
     33           * [2] CORON, Jean-S'ebastien. Resistance against differential power analysis
     34           *     for elliptic curve cryptosystems. In : Cryptographic Hardware and
     35           *     Embedded Systems. Springer Berlin Heidelberg, 1999. p. 292-302.
     36           *     <http://link.springer.com/chapter/10.1007/3-540-48059-5_25>
     37           *
     38           * [3] HEDABOU, Mustapha, PINEL, Pierre, et B'EN'ETEAU, Lucien. A comb method to
     39           *     render ECC resistant against Side Channel Attacks. IACR Cryptology
     40           *     ePrint Archive, 2004, vol. 2004, p. 342.
     41           *     <http://eprint.iacr.org/2004/342.pdf>
     42           */
     43          
     44          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint16_t mbedtls_get_unaligned_uint16(void const *)
   \                     mbedtls_get_unaligned_uint16: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2402             MOVS     R4,#+2
   \        0x6   0x003D             MOVS     R5,R7
   \        0x8   0x466E             MOV      R6,SP
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x18   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2402             MOVS     R4,#+2
   \        0x6   0x466D             MOV      R5,SP
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t mbedtls_bswap16(uint16_t)
   \                     mbedtls_bswap16: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x0A00             LSRS     R0,R0,#+8
   \        0x8   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x4770             BX       LR

   \                                 In section .rodata, align 2
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     45          
     46          /**
     47           * \brief Function level alternative implementation.
     48           *
     49           * The MBEDTLS_ECP_INTERNAL_ALT macro enables alternative implementations to
     50           * replace certain functions in this module. The alternative implementations are
     51           * typically hardware accelerators and need to activate the hardware before the
     52           * computation starts and deactivate it after it finishes. The
     53           * mbedtls_internal_ecp_init() and mbedtls_internal_ecp_free() functions serve
     54           * this purpose.
     55           *
     56           * To preserve the correct functionality the following conditions must hold:
     57           *
     58           * - The alternative implementation must be activated by
     59           *   mbedtls_internal_ecp_init() before any of the replaceable functions is
     60           *   called.
     61           * - mbedtls_internal_ecp_free() must \b only be called when the alternative
     62           *   implementation is activated.
     63           * - mbedtls_internal_ecp_init() must \b not be called when the alternative
     64           *   implementation is activated.
     65           * - Public functions must not return while the alternative implementation is
     66           *   activated.
     67           * - Replaceable functions are guarded by \c MBEDTLS_ECP_XXX_ALT macros and
     68           *   before calling them an \code if( mbedtls_internal_ecp_grp_capable( grp ) )
     69           *   \endcode ensures that the alternative implementation supports the current
     70           *   group.
     71           */
     72          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
     73          #endif
     74          
     75          #if defined(MBEDTLS_ECP_LIGHT)
     76          
     77          #include "mbedtls/ecp.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ecp_group_a_is_minus_3(mbedtls_ecp_group const *)
   \                     mbedtls_ecp_group_a_is_minus_3: (+1)
   \        0x0   0x68C0             LDR      R0,[R0, #+12]
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??mbedtls_ecp_group_a_is_minus_3_0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE000             B.N      ??mbedtls_ecp_group_a_is_minus_3_1
   \                     ??mbedtls_ecp_group_a_is_minus_3_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecp_group_a_is_minus_3_1: (+1)
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x4770             BX       LR
     78          #include "mbedtls/threading.h"
     79          #include "mbedtls/platform_util.h"
     80          #include "mbedtls/error.h"
     81          
     82          #include "bn_mul.h"
     83          #include "ecp_invasive.h"
     84          
     85          #include <string.h>
     86          
     87          #if !defined(MBEDTLS_ECP_ALT)
     88          
     89          #include "mbedtls/platform.h"
     90          
     91          #include "ecp_internal_alt.h"
     92          
     93          #if defined(MBEDTLS_SELF_TEST)
     94          /*
     95           * Counts of point addition and doubling, and field multiplications.
     96           * Used to test resistance of point multiplication to simple timing attacks.
     97           */
     98          #if defined(MBEDTLS_ECP_C)
     99          static unsigned long add_count, dbl_count;
    100          #endif /* MBEDTLS_ECP_C */
    101          static unsigned long mul_count;
    102          #endif
    103          
    104          #if defined(MBEDTLS_ECP_RESTARTABLE)
    105          /*
    106           * Maximum number of "basic operations" to be done in a row.
    107           *
    108           * Default value 0 means that ECC operations will not yield.
    109           * Note that regardless of the value of ecp_max_ops, always at
    110           * least one step is performed before yielding.
    111           *
    112           * Setting ecp_max_ops=1 can be suitable for testing purposes
    113           * as it will interrupt computation at all possible points.
    114           */
    115          static unsigned ecp_max_ops = 0;
    116          
    117          /*
    118           * Set ecp_max_ops
    119           */
    120          void mbedtls_ecp_set_max_ops(unsigned max_ops)
    121          {
    122              ecp_max_ops = max_ops;
    123          }
    124          
    125          /*
    126           * Check if restart is enabled
    127           */
    128          int mbedtls_ecp_restart_is_enabled(void)
    129          {
    130              return ecp_max_ops != 0;
    131          }
    132          
    133          /*
    134           * Restart sub-context for ecp_mul_comb()
    135           */
    136          struct mbedtls_ecp_restart_mul {
    137              mbedtls_ecp_point R;    /* current intermediate result                  */
    138              size_t i;               /* current index in various loops, 0 outside    */
    139              mbedtls_ecp_point *T;   /* table for precomputed points                 */
    140              unsigned char T_size;   /* number of points in table T                  */
    141              enum {                  /* what were we doing last time we returned?    */
    142                  ecp_rsm_init = 0,       /* nothing so far, dummy initial state      */
    143                  ecp_rsm_pre_dbl,        /* precompute 2^n multiples                 */
    144                  ecp_rsm_pre_norm_dbl,   /* normalize precomputed 2^n multiples      */
    145                  ecp_rsm_pre_add,        /* precompute remaining points by adding    */
    146                  ecp_rsm_pre_norm_add,   /* normalize all precomputed points         */
    147                  ecp_rsm_comb_core,      /* ecp_mul_comb_core()                      */
    148                  ecp_rsm_final_norm,     /* do the final normalization               */
    149              } state;
    150          };
    151          
    152          /*
    153           * Init restart_mul sub-context
    154           */
    155          static void ecp_restart_rsm_init(mbedtls_ecp_restart_mul_ctx *ctx)
    156          {
    157              mbedtls_ecp_point_init(&ctx->R);
    158              ctx->i = 0;
    159              ctx->T = NULL;
    160              ctx->T_size = 0;
    161              ctx->state = ecp_rsm_init;
    162          }
    163          
    164          /*
    165           * Free the components of a restart_mul sub-context
    166           */
    167          static void ecp_restart_rsm_free(mbedtls_ecp_restart_mul_ctx *ctx)
    168          {
    169              unsigned char i;
    170          
    171              if (ctx == NULL) {
    172                  return;
    173              }
    174          
    175              mbedtls_ecp_point_free(&ctx->R);
    176          
    177              if (ctx->T != NULL) {
    178                  for (i = 0; i < ctx->T_size; i++) {
    179                      mbedtls_ecp_point_free(ctx->T + i);
    180                  }
    181                  mbedtls_free(ctx->T);
    182              }
    183          
    184              ecp_restart_rsm_init(ctx);
    185          }
    186          
    187          /*
    188           * Restart context for ecp_muladd()
    189           */
    190          struct mbedtls_ecp_restart_muladd {
    191              mbedtls_ecp_point mP;       /* mP value                             */
    192              mbedtls_ecp_point R;        /* R intermediate result                */
    193              enum {                      /* what should we do next?              */
    194                  ecp_rsma_mul1 = 0,      /* first multiplication                 */
    195                  ecp_rsma_mul2,          /* second multiplication                */
    196                  ecp_rsma_add,           /* addition                             */
    197                  ecp_rsma_norm,          /* normalization                        */
    198              } state;
    199          };
    200          
    201          /*
    202           * Init restart_muladd sub-context
    203           */
    204          static void ecp_restart_ma_init(mbedtls_ecp_restart_muladd_ctx *ctx)
    205          {
    206              mbedtls_ecp_point_init(&ctx->mP);
    207              mbedtls_ecp_point_init(&ctx->R);
    208              ctx->state = ecp_rsma_mul1;
    209          }
    210          
    211          /*
    212           * Free the components of a restart_muladd sub-context
    213           */
    214          static void ecp_restart_ma_free(mbedtls_ecp_restart_muladd_ctx *ctx)
    215          {
    216              if (ctx == NULL) {
    217                  return;
    218              }
    219          
    220              mbedtls_ecp_point_free(&ctx->mP);
    221              mbedtls_ecp_point_free(&ctx->R);
    222          
    223              ecp_restart_ma_init(ctx);
    224          }
    225          
    226          /*
    227           * Initialize a restart context
    228           */
    229          void mbedtls_ecp_restart_init(mbedtls_ecp_restart_ctx *ctx)
    230          {
    231              ctx->ops_done = 0;
    232              ctx->depth = 0;
    233              ctx->rsm = NULL;
    234              ctx->ma = NULL;
    235          }
    236          
    237          /*
    238           * Free the components of a restart context
    239           */
    240          void mbedtls_ecp_restart_free(mbedtls_ecp_restart_ctx *ctx)
    241          {
    242              if (ctx == NULL) {
    243                  return;
    244              }
    245          
    246              ecp_restart_rsm_free(ctx->rsm);
    247              mbedtls_free(ctx->rsm);
    248          
    249              ecp_restart_ma_free(ctx->ma);
    250              mbedtls_free(ctx->ma);
    251          
    252              mbedtls_ecp_restart_init(ctx);
    253          }
    254          
    255          /*
    256           * Check if we can do the next step
    257           */
    258          int mbedtls_ecp_check_budget(const mbedtls_ecp_group *grp,
    259                                       mbedtls_ecp_restart_ctx *rs_ctx,
    260                                       unsigned ops)
    261          {
    262              if (rs_ctx != NULL && ecp_max_ops != 0) {
    263                  /* scale depending on curve size: the chosen reference is 256-bit,
    264                   * and multiplication is quadratic. Round to the closest integer. */
    265                  if (grp->pbits >= 512) {
    266                      ops *= 4;
    267                  } else if (grp->pbits >= 384) {
    268                      ops *= 2;
    269                  }
    270          
    271                  /* Avoid infinite loops: always allow first step.
    272                   * Because of that, however, it's not generally true
    273                   * that ops_done <= ecp_max_ops, so the check
    274                   * ops_done > ecp_max_ops below is mandatory. */
    275                  if ((rs_ctx->ops_done != 0) &&
    276                      (rs_ctx->ops_done > ecp_max_ops ||
    277                       ops > ecp_max_ops - rs_ctx->ops_done)) {
    278                      return MBEDTLS_ERR_ECP_IN_PROGRESS;
    279                  }
    280          
    281                  /* update running count */
    282                  rs_ctx->ops_done += ops;
    283              }
    284          
    285              return 0;
    286          }
    287          
    288          /* Call this when entering a function that needs its own sub-context */
    289          #define ECP_RS_ENTER(SUB)   do {                                      \
    290                  /* reset ops count for this call if top-level */                    \
    291                  if (rs_ctx != NULL && rs_ctx->depth++ == 0)                        \
    292                  rs_ctx->ops_done = 0;                                           \
    293                                                                                  \
    294                  /* set up our own sub-context if needed */                          \
    295                  if (mbedtls_ecp_restart_is_enabled() &&                             \
    296                      rs_ctx != NULL && rs_ctx->SUB == NULL)                         \
    297                  {                                                                   \
    298                      rs_ctx->SUB = mbedtls_calloc(1, sizeof(*rs_ctx->SUB));      \
    299                      if (rs_ctx->SUB == NULL)                                       \
    300                      return MBEDTLS_ERR_ECP_ALLOC_FAILED;                     \
    301                                                                                \
    302                      ecp_restart_## SUB ##_init(rs_ctx->SUB);                      \
    303                  }                                                                   \
    304          } while (0)
    305          
    306          /* Call this when leaving a function that needs its own sub-context */
    307          #define ECP_RS_LEAVE(SUB)   do {                                      \
    308                  /* clear our sub-context when not in progress (done or error) */    \
    309                  if (rs_ctx != NULL && rs_ctx->SUB != NULL &&                        \
    310                      ret != MBEDTLS_ERR_ECP_IN_PROGRESS)                            \
    311                  {                                                                   \
    312                      ecp_restart_## SUB ##_free(rs_ctx->SUB);                      \
    313                      mbedtls_free(rs_ctx->SUB);                                    \
    314                      rs_ctx->SUB = NULL;                                             \
    315                  }                                                                   \
    316                                                                                  \
    317                  if (rs_ctx != NULL)                                                \
    318                  rs_ctx->depth--;                                                \
    319          } while (0)
    320          
    321          #else /* MBEDTLS_ECP_RESTARTABLE */
    322          
    323          #define ECP_RS_ENTER(sub)     (void) rs_ctx;
    324          #define ECP_RS_LEAVE(sub)     (void) rs_ctx;
    325          
    326          #endif /* MBEDTLS_ECP_RESTARTABLE */
    327          
    328          #if defined(MBEDTLS_ECP_C)

   \                                 In section .text, align 2, keep-with-next
    329          static void mpi_init_many(mbedtls_mpi *arr, size_t size)
    330          {
   \                     mpi_init_many: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    331              while (size--) {
   \                     ??mpi_init_many_0: (+1)
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x1E44             SUBS     R4,R0,#+1
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD004             BEQ.N    ??mpi_init_many_1
    332                  mbedtls_mpi_init(arr++);
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x14   0x3508             ADDS     R5,R5,#+8
   \       0x16   0xE7F6             B.N      ??mpi_init_many_0
    333              }
    334          }
   \                     ??mpi_init_many_1: (+1)
   \       0x18   0xBD31             POP      {R0,R4,R5,PC}
    335          

   \                                 In section .text, align 2, keep-with-next
    336          static void mpi_free_many(mbedtls_mpi *arr, size_t size)
    337          {
   \                     mpi_free_many: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    338              while (size--) {
   \                     ??mpi_free_many_0: (+1)
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x1E44             SUBS     R4,R0,#+1
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD004             BEQ.N    ??mpi_free_many_1
    339                  mbedtls_mpi_free(arr++);
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_free
   \       0x14   0x3508             ADDS     R5,R5,#+8
   \       0x16   0xE7F6             B.N      ??mpi_free_many_0
    340              }
    341          }
   \                     ??mpi_free_many_1: (+1)
   \       0x18   0xBD31             POP      {R0,R4,R5,PC}
    342          #endif /* MBEDTLS_ECP_C */
    343          
    344          /*
    345           * List of supported curves:
    346           *  - internal ID
    347           *  - TLS NamedCurve ID (RFC 4492 sec. 5.1.1, RFC 7071 sec. 2, RFC 8446 sec. 4.2.7)
    348           *  - size in bits
    349           *  - readable name
    350           *
    351           * Curves are listed in order: largest curves first, and for a given size,
    352           * fastest curves first.
    353           *
    354           * Reminder: update profiles in x509_crt.c and ssl_tls.c when adding a new curve!
    355           */

   \                                 In section .rodata, align 4
    356          static const mbedtls_ecp_curve_info ecp_supported_curves[] =
   \                     ecp_supported_curves:
   \        0x0   0x03               DC8 3
   \        0x1                      DS8 1
   \        0x2   0x0017 0x0100      DC16 23, 256
   \        0x6                      DS8 2
   \        0x8   0x....'....        DC32 ?_0
   \        0xC   0x00               DC8 0
   \        0xD                      DS8 1
   \        0xE   0x0000 0x0000      DC16 0, 0
   \       0x12                      DS8 2
   \       0x14   0x0000'0000        DC32 0x0
    357          {
    358          #if defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED)
    359              { MBEDTLS_ECP_DP_SECP521R1,    25,     521,    "secp521r1"         },
    360          #endif
    361          #if defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)
    362              { MBEDTLS_ECP_DP_BP512R1,      28,     512,    "brainpoolP512r1"   },
    363          #endif
    364          #if defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED)
    365              { MBEDTLS_ECP_DP_SECP384R1,    24,     384,    "secp384r1"         },
    366          #endif
    367          #if defined(MBEDTLS_ECP_DP_BP384R1_ENABLED)
    368              { MBEDTLS_ECP_DP_BP384R1,      27,     384,    "brainpoolP384r1"   },
    369          #endif
    370          #if defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED)
    371              { MBEDTLS_ECP_DP_SECP256R1,    23,     256,    "secp256r1"         },
    372          #endif
    373          #if defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
    374              { MBEDTLS_ECP_DP_SECP256K1,    22,     256,    "secp256k1"         },
    375          #endif
    376          #if defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)
    377              { MBEDTLS_ECP_DP_BP256R1,      26,     256,    "brainpoolP256r1"   },
    378          #endif
    379          #if defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED)
    380              { MBEDTLS_ECP_DP_SECP224R1,    21,     224,    "secp224r1"         },
    381          #endif
    382          #if defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED)
    383              { MBEDTLS_ECP_DP_SECP224K1,    20,     224,    "secp224k1"         },
    384          #endif
    385          #if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
    386              { MBEDTLS_ECP_DP_SECP192R1,    19,     192,    "secp192r1"         },
    387          #endif
    388          #if defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED)
    389              { MBEDTLS_ECP_DP_SECP192K1,    18,     192,    "secp192k1"         },
    390          #endif
    391          #if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
    392              { MBEDTLS_ECP_DP_CURVE25519,   29,     256,    "x25519"            },
    393          #endif
    394          #if defined(MBEDTLS_ECP_DP_CURVE448_ENABLED)
    395              { MBEDTLS_ECP_DP_CURVE448,     30,     448,    "x448"              },
    396          #endif
    397              { MBEDTLS_ECP_DP_NONE,          0,     0,      NULL                },
    398          };
    399          
    400          #define ECP_NB_CURVES   sizeof(ecp_supported_curves) /    \
    401              sizeof(ecp_supported_curves[0])
    402          

   \                                 In section .bss, align 2
    403          static mbedtls_ecp_group_id ecp_supported_grp_id[ECP_NB_CURVES];
   \                     ecp_supported_grp_id:
   \        0x0                      DS8 2
    404          
    405          /*
    406           * List of supported curves and associated info
    407           */

   \                                 In section .text, align 2, keep-with-next
    408          const mbedtls_ecp_curve_info *mbedtls_ecp_curve_list(void)
    409          {
    410              return ecp_supported_curves;
   \                     mbedtls_ecp_curve_list: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable11
   \        0x4   0x4770             BX       LR
    411          }
    412          
    413          /*
    414           * List of supported curves, group ID only
    415           */

   \                                 In section .text, align 2, keep-with-next
    416          const mbedtls_ecp_group_id *mbedtls_ecp_grp_id_list(void)
    417          {
   \                     mbedtls_ecp_grp_id_list: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    418              static int init_done = 0;
    419          
    420              if (!init_done) {
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable11_1
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD112             BNE.N    ??mbedtls_ecp_grp_id_list_0
    421                  size_t i = 0;
   \        0xC   0x2500             MOVS     R5,#+0
    422                  const mbedtls_ecp_curve_info *curve_info;
    423          
    424                  for (curve_info = mbedtls_ecp_curve_list();
   \        0xE   0x.... 0x....      BL       mbedtls_ecp_curve_list
    425                       curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
   \                     ??mbedtls_ecp_grp_id_list_1: (+1)
   \       0x12   0x7801             LDRB     R1,[R0, #+0]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD006             BEQ.N    ??mbedtls_ecp_grp_id_list_2
    426                       curve_info++) {
    427                      ecp_supported_grp_id[i++] = curve_info->grp_id;
   \       0x18   0x7802             LDRB     R2,[R0, #+0]
   \       0x1A   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \       0x1E   0x554A             STRB     R2,[R1, R5]
   \       0x20   0x1C6D             ADDS     R5,R5,#+1
    428                  }
   \       0x22   0x300C             ADDS     R0,R0,#+12
   \       0x24   0xE7F5             B.N      ??mbedtls_ecp_grp_id_list_1
    429                  ecp_supported_grp_id[i] = MBEDTLS_ECP_DP_NONE;
   \                     ??mbedtls_ecp_grp_id_list_2: (+1)
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \       0x2C   0x554A             STRB     R2,[R1, R5]
    430          
    431                  init_done = 1;
   \       0x2E   0x2101             MOVS     R1,#+1
   \       0x30   0x6021             STR      R1,[R4, #+0]
    432              }
    433          
    434              return ecp_supported_grp_id;
   \                     ??mbedtls_ecp_grp_id_list_0: (+1)
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
    435          }

   \                                 In section .bss, align 4
   \                     `mbedtls_ecp_grp_id_list::init_done`:
   \        0x0                      DS8 4
    436          
    437          /*
    438           * Get the curve info for the internal identifier
    439           */

   \                                 In section .text, align 2, keep-with-next
    440          const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_grp_id(mbedtls_ecp_group_id grp_id)
    441          {
   \                     mbedtls_ecp_curve_info_from_grp_id: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    442              const mbedtls_ecp_curve_info *curve_info;
    443          
    444              for (curve_info = mbedtls_ecp_curve_list();
   \        0x4   0x.... 0x....      BL       mbedtls_ecp_curve_list
   \        0x8   0x0001             MOVS     R1,R0
    445                   curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
   \                     ??mbedtls_ecp_curve_info_from_grp_id_0: (+1)
   \        0xA   0x7808             LDRB     R0,[R1, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD008             BEQ.N    ??mbedtls_ecp_curve_info_from_grp_id_1
    446                   curve_info++) {
    447                  if (curve_info->grp_id == grp_id) {
   \       0x10   0x780A             LDRB     R2,[R1, #+0]
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x4282             CMP      R2,R0
   \       0x18   0xD101             BNE.N    ??mbedtls_ecp_curve_info_from_grp_id_2
    448                      return curve_info;
   \       0x1A   0x0008             MOVS     R0,R1
   \       0x1C   0xE002             B.N      ??mbedtls_ecp_curve_info_from_grp_id_3
    449                  }
    450              }
   \                     ??mbedtls_ecp_curve_info_from_grp_id_2: (+1)
   \       0x1E   0x310C             ADDS     R1,R1,#+12
   \       0x20   0xE7F3             B.N      ??mbedtls_ecp_curve_info_from_grp_id_0
    451          
    452              return NULL;
   \                     ??mbedtls_ecp_curve_info_from_grp_id_1: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecp_curve_info_from_grp_id_3: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
    453          }
    454          
    455          /*
    456           * Get the curve info from the TLS identifier
    457           */

   \                                 In section .text, align 2, keep-with-next
    458          const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_tls_id(uint16_t tls_id)
    459          {
   \                     mbedtls_ecp_curve_info_from_tls_id: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    460              const mbedtls_ecp_curve_info *curve_info;
    461          
    462              for (curve_info = mbedtls_ecp_curve_list();
   \        0x4   0x.... 0x....      BL       mbedtls_ecp_curve_list
   \        0x8   0x0001             MOVS     R1,R0
    463                   curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
   \                     ??mbedtls_ecp_curve_info_from_tls_id_0: (+1)
   \        0xA   0x7808             LDRB     R0,[R1, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD008             BEQ.N    ??mbedtls_ecp_curve_info_from_tls_id_1
    464                   curve_info++) {
    465                  if (curve_info->tls_id == tls_id) {
   \       0x10   0x884A             LDRH     R2,[R1, #+2]
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x4282             CMP      R2,R0
   \       0x18   0xD101             BNE.N    ??mbedtls_ecp_curve_info_from_tls_id_2
    466                      return curve_info;
   \       0x1A   0x0008             MOVS     R0,R1
   \       0x1C   0xE002             B.N      ??mbedtls_ecp_curve_info_from_tls_id_3
    467                  }
    468              }
   \                     ??mbedtls_ecp_curve_info_from_tls_id_2: (+1)
   \       0x1E   0x310C             ADDS     R1,R1,#+12
   \       0x20   0xE7F3             B.N      ??mbedtls_ecp_curve_info_from_tls_id_0
    469          
    470              return NULL;
   \                     ??mbedtls_ecp_curve_info_from_tls_id_1: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecp_curve_info_from_tls_id_3: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
    471          }
    472          
    473          /*
    474           * Get the curve info from the name
    475           */

   \                                 In section .text, align 2, keep-with-next
    476          const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_name(const char *name)
    477          {
   \                     mbedtls_ecp_curve_info_from_name: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    478              const mbedtls_ecp_curve_info *curve_info;
    479          
    480              if (name == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??mbedtls_ecp_curve_info_from_name_0
    481                  return NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE010             B.N      ??mbedtls_ecp_curve_info_from_name_1
    482              }
    483          
    484              for (curve_info = mbedtls_ecp_curve_list();
   \                     ??mbedtls_ecp_curve_info_from_name_0: (+1)
   \        0xC   0x.... 0x....      BL       mbedtls_ecp_curve_list
   \       0x10   0x0005             MOVS     R5,R0
    485                   curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
   \                     ??mbedtls_ecp_curve_info_from_name_2: (+1)
   \       0x12   0x7828             LDRB     R0,[R5, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD009             BEQ.N    ??mbedtls_ecp_curve_info_from_name_3
    486                   curve_info++) {
    487                  if (strcmp(curve_info->name, name) == 0) {
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0x68A8             LDR      R0,[R5, #+8]
   \       0x1C   0x.... 0x....      BL       strcmp
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??mbedtls_ecp_curve_info_from_name_4
    488                      return curve_info;
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0xE002             B.N      ??mbedtls_ecp_curve_info_from_name_1
    489                  }
    490              }
   \                     ??mbedtls_ecp_curve_info_from_name_4: (+1)
   \       0x28   0x350C             ADDS     R5,R5,#+12
   \       0x2A   0xE7F2             B.N      ??mbedtls_ecp_curve_info_from_name_2
    491          
    492              return NULL;
   \                     ??mbedtls_ecp_curve_info_from_name_3: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecp_curve_info_from_name_1: (+1)
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
    493          }
    494          
    495          /*
    496           * Get the type of a curve
    497           */

   \                                 In section .text, align 2, keep-with-next
    498          mbedtls_ecp_curve_type mbedtls_ecp_get_type(const mbedtls_ecp_group *grp)
    499          {
   \                     mbedtls_ecp_get_type: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    500              if (grp->G.X.p == NULL) {
   \        0x2   0x69C8             LDR      R0,[R1, #+28]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD101             BNE.N    ??mbedtls_ecp_get_type_0
    501                  return MBEDTLS_ECP_TYPE_NONE;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE005             B.N      ??mbedtls_ecp_get_type_1
    502              }
    503          
    504              if (grp->G.Y.p == NULL) {
   \                     ??mbedtls_ecp_get_type_0: (+1)
   \        0xC   0x6A48             LDR      R0,[R1, #+36]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??mbedtls_ecp_get_type_2
    505                  return MBEDTLS_ECP_TYPE_MONTGOMERY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE000             B.N      ??mbedtls_ecp_get_type_1
    506              } else {
    507                  return MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS;
   \                     ??mbedtls_ecp_get_type_2: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \                     ??mbedtls_ecp_get_type_1: (+1)
   \       0x18   0x4770             BX       LR
    508              }
    509          }
    510          
    511          /*
    512           * Initialize (the components of) a point
    513           */

   \                                 In section .text, align 2, keep-with-next
    514          void mbedtls_ecp_point_init(mbedtls_ecp_point *pt)
    515          {
   \                     mbedtls_ecp_point_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    516              mbedtls_mpi_init(&pt->X);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_init
    517              mbedtls_mpi_init(&pt->Y);
   \        0xA   0xF114 0x0008      ADDS     R0,R4,#+8
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_init
    518              mbedtls_mpi_init(&pt->Z);
   \       0x12   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_init
    519          }
   \       0x1A   0xBD10             POP      {R4,PC}
    520          
    521          /*
    522           * Initialize (the components of) a group
    523           */

   \                                 In section .text, align 2, keep-with-next
    524          void mbedtls_ecp_group_init(mbedtls_ecp_group *grp)
    525          {
   \                     mbedtls_ecp_group_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    526              grp->id = MBEDTLS_ECP_DP_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x7020             STRB     R0,[R4, #+0]
    527              mbedtls_mpi_init(&grp->P);
   \        0x8   0x1D20             ADDS     R0,R4,#+4
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_init
    528              mbedtls_mpi_init(&grp->A);
   \        0xE   0xF114 0x000C      ADDS     R0,R4,#+12
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_init
    529              mbedtls_mpi_init(&grp->B);
   \       0x16   0xF114 0x0014      ADDS     R0,R4,#+20
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_init
    530              mbedtls_ecp_point_init(&grp->G);
   \       0x1E   0xF114 0x001C      ADDS     R0,R4,#+28
   \       0x22   0x.... 0x....      BL       mbedtls_ecp_point_init
    531              mbedtls_mpi_init(&grp->N);
   \       0x26   0xF114 0x0034      ADDS     R0,R4,#+52
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_init
    532              grp->pbits = 0;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x63E0             STR      R0,[R4, #+60]
    533              grp->nbits = 0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6420             STR      R0,[R4, #+64]
    534              grp->h = 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6460             STR      R0,[R4, #+68]
    535              grp->modp = NULL;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x64A0             STR      R0,[R4, #+72]
    536              grp->t_pre = NULL;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x64E0             STR      R0,[R4, #+76]
    537              grp->t_post = NULL;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x6520             STR      R0,[R4, #+80]
    538              grp->t_data = NULL;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x6560             STR      R0,[R4, #+84]
    539              grp->T = NULL;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x65A0             STR      R0,[R4, #+88]
    540              grp->T_size = 0;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x65E0             STR      R0,[R4, #+92]
    541          }
   \       0x52   0xBD10             POP      {R4,PC}
    542          
    543          /*
    544           * Initialize (the components of) a key pair
    545           */

   \                                 In section .text, align 2, keep-with-next
    546          void mbedtls_ecp_keypair_init(mbedtls_ecp_keypair *key)
    547          {
   \                     mbedtls_ecp_keypair_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    548              mbedtls_ecp_group_init(&key->grp);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       mbedtls_ecp_group_init
    549              mbedtls_mpi_init(&key->d);
   \        0xA   0xF114 0x0060      ADDS     R0,R4,#+96
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_init
    550              mbedtls_ecp_point_init(&key->Q);
   \       0x12   0xF114 0x0068      ADDS     R0,R4,#+104
   \       0x16   0x.... 0x....      BL       mbedtls_ecp_point_init
    551          }
   \       0x1A   0xBD10             POP      {R4,PC}
    552          
    553          /*
    554           * Unallocate (the components of) a point
    555           */

   \                                 In section .text, align 2, keep-with-next
    556          void mbedtls_ecp_point_free(mbedtls_ecp_point *pt)
    557          {
   \                     mbedtls_ecp_point_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    558              if (pt == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD00A             BEQ.N    ??mbedtls_ecp_point_free_0
    559                  return;
    560              }
    561          
    562              mbedtls_mpi_free(&(pt->X));
   \                     ??mbedtls_ecp_point_free_1: (+1)
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_free
    563              mbedtls_mpi_free(&(pt->Y));
   \        0xE   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_free
    564              mbedtls_mpi_free(&(pt->Z));
   \       0x16   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_free
    565          }
   \                     ??mbedtls_ecp_point_free_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}
    566          
    567          /*
    568           * Check that the comb table (grp->T) is static initialized.
    569           */

   \                                 In section .text, align 2, keep-with-next
    570          static int ecp_group_is_static_comb_table(const mbedtls_ecp_group *grp)
    571          {
   \                     ecp_group_is_static_comb_table: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    572          #if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1
    573              return grp->T != NULL && grp->T_size == 0;
    574          #else
    575              (void) grp;
    576              return 0;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x4770             BX       LR
    577          #endif
    578          }
    579          
    580          /*
    581           * Unallocate (the components of) a group
    582           */

   \                                 In section .text, align 2, keep-with-next
    583          void mbedtls_ecp_group_free(mbedtls_ecp_group *grp)
    584          {
   \                     mbedtls_ecp_group_free: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    585              size_t i;
    586          
    587              if (grp == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD032             BEQ.N    ??mbedtls_ecp_group_free_0
    588                  return;
    589              }
    590          
    591              if (grp->h != 1) {
   \                     ??mbedtls_ecp_group_free_1: (+1)
   \        0x8   0x6C60             LDR      R0,[R4, #+68]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD012             BEQ.N    ??mbedtls_ecp_group_free_2
    592                  mbedtls_mpi_free(&grp->A);
   \        0xE   0xF114 0x000C      ADDS     R0,R4,#+12
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_free
    593                  mbedtls_mpi_free(&grp->B);
   \       0x16   0xF114 0x0014      ADDS     R0,R4,#+20
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_free
    594                  mbedtls_ecp_point_free(&grp->G);
   \       0x1E   0xF114 0x001C      ADDS     R0,R4,#+28
   \       0x22   0x.... 0x....      BL       mbedtls_ecp_point_free
    595          
    596          #if !defined(MBEDTLS_ECP_WITH_MPI_UINT)
    597                  mbedtls_mpi_free(&grp->N);
   \       0x26   0xF114 0x0034      ADDS     R0,R4,#+52
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_free
    598                  mbedtls_mpi_free(&grp->P);
   \       0x2E   0x1D20             ADDS     R0,R4,#+4
   \       0x30   0x.... 0x....      BL       mbedtls_mpi_free
    599          #endif
    600              }
    601          
    602              if (!ecp_group_is_static_comb_table(grp) && grp->T != NULL) {
   \                     ??mbedtls_ecp_group_free_2: (+1)
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       ecp_group_is_static_comb_table
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD113             BNE.N    ??mbedtls_ecp_group_free_3
   \       0x3E   0x6DA0             LDR      R0,[R4, #+88]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD010             BEQ.N    ??mbedtls_ecp_group_free_3
    603                  for (i = 0; i < grp->T_size; i++) {
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x0005             MOVS     R5,R0
   \                     ??mbedtls_ecp_group_free_4: (+1)
   \       0x48   0x6DE0             LDR      R0,[R4, #+92]
   \       0x4A   0x4285             CMP      R5,R0
   \       0x4C   0xD208             BCS.N    ??mbedtls_ecp_group_free_5
    604                      mbedtls_ecp_point_free(&grp->T[i]);
   \       0x4E   0x6DA1             LDR      R1,[R4, #+88]
   \       0x50   0x2018             MOVS     R0,#+24
   \       0x52   0xFB00 0xF005      MUL      R0,R0,R5
   \       0x56   0x4408             ADD      R0,R1,R0
   \       0x58   0x.... 0x....      BL       mbedtls_ecp_point_free
    605                  }
   \       0x5C   0x1C6D             ADDS     R5,R5,#+1
   \       0x5E   0xE7F3             B.N      ??mbedtls_ecp_group_free_4
    606                  mbedtls_free(grp->T);
   \                     ??mbedtls_ecp_group_free_5: (+1)
   \       0x60   0x6DA0             LDR      R0,[R4, #+88]
   \       0x62   0x.... 0x....      BL       sl_free
    607              }
    608          
    609              mbedtls_platform_zeroize(grp, sizeof(mbedtls_ecp_group));
   \                     ??mbedtls_ecp_group_free_3: (+1)
   \       0x66   0x2160             MOVS     R1,#+96
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       mbedtls_platform_zeroize
    610          }
   \                     ??mbedtls_ecp_group_free_0: (+1)
   \       0x6E   0xBD31             POP      {R0,R4,R5,PC}
    611          
    612          /*
    613           * Unallocate (the components of) a key pair
    614           */

   \                                 In section .text, align 2, keep-with-next
    615          void mbedtls_ecp_keypair_free(mbedtls_ecp_keypair *key)
    616          {
   \                     mbedtls_ecp_keypair_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    617              if (key == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD00A             BEQ.N    ??mbedtls_ecp_keypair_free_0
    618                  return;
    619              }
    620          
    621              mbedtls_ecp_group_free(&key->grp);
   \                     ??mbedtls_ecp_keypair_free_1: (+1)
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       mbedtls_ecp_group_free
    622              mbedtls_mpi_free(&key->d);
   \        0xE   0xF114 0x0060      ADDS     R0,R4,#+96
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_free
    623              mbedtls_ecp_point_free(&key->Q);
   \       0x16   0xF114 0x0068      ADDS     R0,R4,#+104
   \       0x1A   0x.... 0x....      BL       mbedtls_ecp_point_free
    624          }
   \                     ??mbedtls_ecp_keypair_free_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}
    625          
    626          /*
    627           * Copy the contents of a point
    628           */

   \                                 In section .text, align 2, keep-with-next
    629          int mbedtls_ecp_copy(mbedtls_ecp_point *P, const mbedtls_ecp_point *Q)
    630          {
   \                     mbedtls_ecp_copy: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
    631              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x056D      MVNS     R5,#+109
    632              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->X, &Q->X));
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x12   0x0006             MOVS     R6,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD111             BNE.N    ??mbedtls_ecp_copy_0
    633              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->Y, &Q->Y));
   \                     ??mbedtls_ecp_copy_1: (+1)
   \       0x18   0xF114 0x0108      ADDS     R1,R4,#+8
   \       0x1C   0xF117 0x0008      ADDS     R0,R7,#+8
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x24   0x0006             MOVS     R6,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD108             BNE.N    ??mbedtls_ecp_copy_0
    634              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->Z, &Q->Z));
   \                     ??mbedtls_ecp_copy_2: (+1)
   \       0x2A   0xF114 0x0110      ADDS     R1,R4,#+16
   \       0x2E   0xF117 0x0010      ADDS     R0,R7,#+16
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x36   0x0006             MOVS     R6,R0
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD1FF             BNE.N    ??mbedtls_ecp_copy_0
    635          
    636          cleanup:
    637              return ret;
   \                     ??mbedtls_ecp_copy_3: (+1)
   \                     ??mbedtls_ecp_copy_0: (+1)
   \       0x3C   0x0030             MOVS     R0,R6
   \       0x3E   0xBDF2             POP      {R1,R4-R7,PC}
    638          }
    639          
    640          /*
    641           * Copy the contents of a group object
    642           */

   \                                 In section .text, align 2, keep-with-next
    643          int mbedtls_ecp_group_copy(mbedtls_ecp_group *dst, const mbedtls_ecp_group *src)
    644          {
   \                     mbedtls_ecp_group_copy: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    645              return mbedtls_ecp_group_load(dst, src->id);
   \        0x6   0x7821             LDRB     R1,[R4, #+0]
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_ecp_group_load
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
    646          }
    647          
    648          /*
    649           * Set point to zero
    650           */

   \                                 In section .text, align 2, keep-with-next
    651          int mbedtls_ecp_set_zero(mbedtls_ecp_point *pt)
    652          {
   \                     mbedtls_ecp_set_zero: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
    653              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x046D      MVNS     R4,#+109
    654              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->X, 1));
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x10   0x0005             MOVS     R5,R0
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD10F             BNE.N    ??mbedtls_ecp_set_zero_0
    655              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Y, 1));
   \                     ??mbedtls_ecp_set_zero_1: (+1)
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0xF116 0x0008      ADDS     R0,R6,#+8
   \       0x1C   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x20   0x0005             MOVS     R5,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD107             BNE.N    ??mbedtls_ecp_set_zero_0
    656              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 0));
   \                     ??mbedtls_ecp_set_zero_2: (+1)
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0xF116 0x0010      ADDS     R0,R6,#+16
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x30   0x0005             MOVS     R5,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD1FF             BNE.N    ??mbedtls_ecp_set_zero_0
    657          
    658          cleanup:
    659              return ret;
   \                     ??mbedtls_ecp_set_zero_3: (+1)
   \                     ??mbedtls_ecp_set_zero_0: (+1)
   \       0x36   0x0028             MOVS     R0,R5
   \       0x38   0xBD70             POP      {R4-R6,PC}
    660          }
    661          
    662          /*
    663           * Tell if a point is zero
    664           */

   \                                 In section .text, align 2, keep-with-next
    665          int mbedtls_ecp_is_zero(mbedtls_ecp_point *pt)
    666          {
   \                     mbedtls_ecp_is_zero: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    667              return mbedtls_mpi_cmp_int(&pt->Z, 0) == 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0xF114 0x0010      ADDS     R0,R4,#+16
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??mbedtls_ecp_is_zero_0
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xE000             B.N      ??mbedtls_ecp_is_zero_1
   \                     ??mbedtls_ecp_is_zero_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecp_is_zero_1: (+1)
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0xBD10             POP      {R4,PC}
    668          }
    669          
    670          /*
    671           * Compare two points lazily
    672           */

   \                                 In section .text, align 2, keep-with-next
    673          int mbedtls_ecp_point_cmp(const mbedtls_ecp_point *P,
    674                                    const mbedtls_ecp_point *Q)
    675          {
   \                     mbedtls_ecp_point_cmp: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    676              if (mbedtls_mpi_cmp_mpi(&P->X, &Q->X) == 0 &&
    677                  mbedtls_mpi_cmp_mpi(&P->Y, &Q->Y) == 0 &&
    678                  mbedtls_mpi_cmp_mpi(&P->Z, &Q->Z) == 0) {
   \        0x6   0x0021             MOVS     R1,R4
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD111             BNE.N    ??mbedtls_ecp_point_cmp_0
   \       0x12   0xF114 0x0108      ADDS     R1,R4,#+8
   \       0x16   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD109             BNE.N    ??mbedtls_ecp_point_cmp_0
   \       0x22   0xF114 0x0110      ADDS     R1,R4,#+16
   \       0x26   0xF115 0x0010      ADDS     R0,R5,#+16
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD101             BNE.N    ??mbedtls_ecp_point_cmp_0
    679                  return 0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE001             B.N      ??mbedtls_ecp_point_cmp_1
    680              }
    681          
    682              return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_point_cmp_0: (+1)
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \                     ??mbedtls_ecp_point_cmp_1: (+1)
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
    683          }
    684          
    685          /*
    686           * Import a non-zero point from ASCII strings
    687           */

   \                                 In section .text, align 2, keep-with-next
    688          int mbedtls_ecp_point_read_string(mbedtls_ecp_point *P, int radix,
    689                                            const char *x, const char *y)
    690          {
   \                     mbedtls_ecp_point_read_string: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
    691              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x096D      MVNS     R9,#+109
    692              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&P->X, radix, x));
   \       0x10   0x002A             MOVS     R2,R5
   \       0x12   0x0021             MOVS     R1,R4
   \       0x14   0x4640             MOV      R0,R8
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_read_string
   \       0x1A   0x0007             MOVS     R7,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD110             BNE.N    ??mbedtls_ecp_point_read_string_0
    693              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&P->Y, radix, y));
   \                     ??mbedtls_ecp_point_read_string_1: (+1)
   \       0x20   0x0032             MOVS     R2,R6
   \       0x22   0x0021             MOVS     R1,R4
   \       0x24   0xF118 0x0008      ADDS     R0,R8,#+8
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_read_string
   \       0x2C   0x0007             MOVS     R7,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??mbedtls_ecp_point_read_string_0
    694              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&P->Z, 1));
   \                     ??mbedtls_ecp_point_read_string_2: (+1)
   \       0x32   0x2101             MOVS     R1,#+1
   \       0x34   0xF118 0x0010      ADDS     R0,R8,#+16
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x3C   0x0007             MOVS     R7,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD1FF             BNE.N    ??mbedtls_ecp_point_read_string_0
    695          
    696          cleanup:
    697              return ret;
   \                     ??mbedtls_ecp_point_read_string_3: (+1)
   \                     ??mbedtls_ecp_point_read_string_0: (+1)
   \       0x42   0x0038             MOVS     R0,R7
   \       0x44   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    698          }
    699          
    700          /*
    701           * Export a point into unsigned binary data (SEC1 2.3.3 and RFC7748)
    702           */

   \                                 In section .text, align 2, keep-with-next
    703          int mbedtls_ecp_point_write_binary(const mbedtls_ecp_group *grp,
    704                                             const mbedtls_ecp_point *P,
    705                                             int format, size_t *olen,
    706                                             unsigned char *buf, size_t buflen)
    707          {
   \                     mbedtls_ecp_point_write_binary: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \       0x10   0x9D0B             LDR      R5,[SP, #+44]
    708              int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \       0x12   0x.... 0x....      LDR.W    R9,??DataTable11_4
    709              size_t plen;
    710              if (format != MBEDTLS_ECP_PF_UNCOMPRESSED &&
    711                  format != MBEDTLS_ECP_PF_COMPRESSED) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD004             BEQ.N    ??mbedtls_ecp_point_write_binary_0
   \       0x1A   0x2C01             CMP      R4,#+1
   \       0x1C   0xD002             BEQ.N    ??mbedtls_ecp_point_write_binary_0
    712                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x22   0xE05D             B.N      ??mbedtls_ecp_point_write_binary_1
    713              }
    714          
    715              plen = mbedtls_mpi_size(&grp->P);
   \                     ??mbedtls_ecp_point_write_binary_0: (+1)
   \       0x24   0xF11B 0x0004      ADDS     R0,R11,#+4
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_size
   \       0x2C   0x4682             MOV      R10,R0
    716          
    717          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
    718              (void) format; /* Montgomery curves always use the same point format */
    719              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
    720                  *olen = plen;
    721                  if (buflen < *olen) {
    722                      return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
    723                  }
    724          
    725                  MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary_le(&P->X, buf, plen));
    726              }
    727          #endif
    728          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    729              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x2E   0x4658             MOV      R0,R11
   \       0x30   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD152             BNE.N    ??mbedtls_ecp_point_write_binary_2
    730                  /*
    731                   * Common case: P == 0
    732                   */
    733                  if (mbedtls_mpi_cmp_int(&P->Z, 0) == 0) {
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0xF116 0x0010      ADDS     R0,R6,#+16
   \       0x3E   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD10B             BNE.N    ??mbedtls_ecp_point_write_binary_3
    734                      if (buflen < 1) {
   \       0x46   0x2D00             CMP      R5,#+0
   \       0x48   0xD102             BNE.N    ??mbedtls_ecp_point_write_binary_4
    735                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \       0x4E   0xE047             B.N      ??mbedtls_ecp_point_write_binary_1
    736                      }
    737          
    738                      buf[0] = 0x00;
   \                     ??mbedtls_ecp_point_write_binary_4: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xF888 0x0000      STRB     R0,[R8, #+0]
    739                      *olen = 1;
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x6038             STR      R0,[R7, #+0]
    740          
    741                      return 0;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE040             B.N      ??mbedtls_ecp_point_write_binary_1
    742                  }
    743          
    744                  if (format == MBEDTLS_ECP_PF_UNCOMPRESSED) {
   \                     ??mbedtls_ecp_point_write_binary_3: (+1)
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xD121             BNE.N    ??mbedtls_ecp_point_write_binary_5
    745                      *olen = 2 * plen + 1;
   \       0x62   0xEA5F 0x004A      LSLS     R0,R10,#+1
   \       0x66   0x1C40             ADDS     R0,R0,#+1
   \       0x68   0x6038             STR      R0,[R7, #+0]
    746          
    747                      if (buflen < *olen) {
   \       0x6A   0x6838             LDR      R0,[R7, #+0]
   \       0x6C   0x4285             CMP      R5,R0
   \       0x6E   0xD202             BCS.N    ??mbedtls_ecp_point_write_binary_6
    748                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \       0x74   0xE034             B.N      ??mbedtls_ecp_point_write_binary_1
    749                      }
    750          
    751                      buf[0] = 0x04;
   \                     ??mbedtls_ecp_point_write_binary_6: (+1)
   \       0x76   0x2004             MOVS     R0,#+4
   \       0x78   0xF888 0x0000      STRB     R0,[R8, #+0]
    752                      MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->X, buf + 1, plen));
   \       0x7C   0x4652             MOV      R2,R10
   \       0x7E   0xF118 0x0101      ADDS     R1,R8,#+1
   \       0x82   0x0030             MOVS     R0,R6
   \       0x84   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x88   0x4681             MOV      R9,R0
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD127             BNE.N    ??mbedtls_ecp_point_write_binary_2
    753                      MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->Y, buf + 1 + plen, plen));
   \                     ??mbedtls_ecp_point_write_binary_7: (+1)
   \       0x8E   0x4652             MOV      R2,R10
   \       0x90   0xEB08 0x000A      ADD      R0,R8,R10
   \       0x94   0x1C41             ADDS     R1,R0,#+1
   \       0x96   0xF116 0x0008      ADDS     R0,R6,#+8
   \       0x9A   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x9E   0x4681             MOV      R9,R0
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD11C             BNE.N    ??mbedtls_ecp_point_write_binary_2
   \                     ??mbedtls_ecp_point_write_binary_8: (+1)
   \       0xA4   0xE01B             B.N      ??mbedtls_ecp_point_write_binary_2
    754                  } else if (format == MBEDTLS_ECP_PF_COMPRESSED) {
   \                     ??mbedtls_ecp_point_write_binary_5: (+1)
   \       0xA6   0x2C01             CMP      R4,#+1
   \       0xA8   0xD119             BNE.N    ??mbedtls_ecp_point_write_binary_2
    755                      *olen = plen + 1;
   \       0xAA   0xF11A 0x0001      ADDS     R0,R10,#+1
   \       0xAE   0x6038             STR      R0,[R7, #+0]
    756          
    757                      if (buflen < *olen) {
   \       0xB0   0x6838             LDR      R0,[R7, #+0]
   \       0xB2   0x4285             CMP      R5,R0
   \       0xB4   0xD202             BCS.N    ??mbedtls_ecp_point_write_binary_9
    758                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   \       0xB6   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \       0xBA   0xE011             B.N      ??mbedtls_ecp_point_write_binary_1
    759                      }
    760          
    761                      buf[0] = 0x02 + mbedtls_mpi_get_bit(&P->Y, 0);
   \                     ??mbedtls_ecp_point_write_binary_9: (+1)
   \       0xBC   0x2100             MOVS     R1,#+0
   \       0xBE   0xF116 0x0008      ADDS     R0,R6,#+8
   \       0xC2   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \       0xC6   0x1C80             ADDS     R0,R0,#+2
   \       0xC8   0xF888 0x0000      STRB     R0,[R8, #+0]
    762                      MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->X, buf + 1, plen));
   \       0xCC   0x4652             MOV      R2,R10
   \       0xCE   0xF118 0x0101      ADDS     R1,R8,#+1
   \       0xD2   0x0030             MOVS     R0,R6
   \       0xD4   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0xD8   0x4681             MOV      R9,R0
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD1FF             BNE.N    ??mbedtls_ecp_point_write_binary_2
    763                  }
    764              }
    765          #endif
    766          
    767          cleanup:
    768              return ret;
   \                     ??mbedtls_ecp_point_write_binary_10: (+1)
   \                     ??mbedtls_ecp_point_write_binary_2: (+1)
   \       0xDE   0x4648             MOV      R0,R9
   \                     ??mbedtls_ecp_point_write_binary_1: (+1)
   \       0xE0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    769          }
    770          
    771          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED) \
    772              && defined(MBEDTLS_ECP_ENABLE_COMPRESSED_CURVE_PARSING)
    773          static int mbedtls_ecp_sw_derive_y(const mbedtls_ecp_group *grp,
    774                                             const mbedtls_mpi *X,
    775                                             mbedtls_mpi *Y,
    776                                             int parity_bit);
    777          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
    778          
    779          /*
    780           * Import a point from unsigned binary data (SEC1 2.3.4 and RFC7748)
    781           */

   \                                 In section .text, align 2, keep-with-next
    782          int mbedtls_ecp_point_read_binary(const mbedtls_ecp_group *grp,
    783                                            mbedtls_ecp_point *pt,
    784                                            const unsigned char *buf, size_t ilen)
    785          {
   \                     mbedtls_ecp_point_read_binary: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001C             MOVS     R4,R3
    786              int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \        0xC   0x.... 0x....      LDR.W    R7,??DataTable11_4
    787              size_t plen;
    788              if (ilen < 1) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD102             BNE.N    ??mbedtls_ecp_point_read_binary_0
    789                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x18   0xE044             B.N      ??mbedtls_ecp_point_read_binary_1
    790              }
    791          
    792              plen = mbedtls_mpi_size(&grp->P);
   \                     ??mbedtls_ecp_point_read_binary_0: (+1)
   \       0x1A   0xF119 0x0004      ADDS     R0,R9,#+4
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_size
   \       0x22   0x4680             MOV      R8,R0
    793          
    794          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
    795              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
    796                  if (plen != ilen) {
    797                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    798                  }
    799          
    800                  MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary_le(&pt->X, buf, plen));
    801                  mbedtls_mpi_free(&pt->Y);
    802          
    803                  if (grp->id == MBEDTLS_ECP_DP_CURVE25519) {
    804                      /* Set most significant bit to 0 as prescribed in RFC7748 §5 */
    805                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&pt->X, plen * 8 - 1, 0));
    806                  }
    807          
    808                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 1));
    809              }
    810          #endif
    811          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    812              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x24   0x4648             MOV      R0,R9
   \       0x26   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD139             BNE.N    ??mbedtls_ecp_point_read_binary_2
    813                  if (buf[0] == 0x00) {
   \       0x2E   0x7830             LDRB     R0,[R6, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD108             BNE.N    ??mbedtls_ecp_point_read_binary_3
    814                      if (ilen == 1) {
   \       0x34   0x2C01             CMP      R4,#+1
   \       0x36   0xD103             BNE.N    ??mbedtls_ecp_point_read_binary_4
    815                          return mbedtls_ecp_set_zero(pt);
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       mbedtls_ecp_set_zero
   \       0x3E   0xE031             B.N      ??mbedtls_ecp_point_read_binary_1
    816                      } else {
    817                          return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_point_read_binary_4: (+1)
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x44   0xE02E             B.N      ??mbedtls_ecp_point_read_binary_1
    818                      }
    819                  }
    820          
    821                  if (ilen < 1 + plen) {
   \                     ??mbedtls_ecp_point_read_binary_3: (+1)
   \       0x46   0xF118 0x0001      ADDS     R0,R8,#+1
   \       0x4A   0x4284             CMP      R4,R0
   \       0x4C   0xD202             BCS.N    ??mbedtls_ecp_point_read_binary_5
    822                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x52   0xE027             B.N      ??mbedtls_ecp_point_read_binary_1
    823                  }
    824          
    825                  MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&pt->X, buf + 1, plen));
   \                     ??mbedtls_ecp_point_read_binary_5: (+1)
   \       0x54   0x4642             MOV      R2,R8
   \       0x56   0x1C71             ADDS     R1,R6,#+1
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0x.... 0x....      BL       mbedtls_mpi_read_binary
   \       0x5E   0x0007             MOVS     R7,R0
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD11E             BNE.N    ??mbedtls_ecp_point_read_binary_2
    826                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 1));
   \                     ??mbedtls_ecp_point_read_binary_6: (+1)
   \       0x64   0x2101             MOVS     R1,#+1
   \       0x66   0xF115 0x0010      ADDS     R0,R5,#+16
   \       0x6A   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x6E   0x0007             MOVS     R7,R0
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD116             BNE.N    ??mbedtls_ecp_point_read_binary_2
    827          
    828                  if (buf[0] == 0x04) {
   \                     ??mbedtls_ecp_point_read_binary_7: (+1)
   \       0x74   0x7830             LDRB     R0,[R6, #+0]
   \       0x76   0x2804             CMP      R0,#+4
   \       0x78   0xD110             BNE.N    ??mbedtls_ecp_point_read_binary_8
    829                      /* format == MBEDTLS_ECP_PF_UNCOMPRESSED */
    830                      if (ilen != 1 + plen * 2) {
   \       0x7A   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \       0x7E   0x1C40             ADDS     R0,R0,#+1
   \       0x80   0x4284             CMP      R4,R0
   \       0x82   0xD002             BEQ.N    ??mbedtls_ecp_point_read_binary_9
    831                          return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x88   0xE00C             B.N      ??mbedtls_ecp_point_read_binary_1
    832                      }
    833                      return mbedtls_mpi_read_binary(&pt->Y, buf + 1 + plen, plen);
   \                     ??mbedtls_ecp_point_read_binary_9: (+1)
   \       0x8A   0x4642             MOV      R2,R8
   \       0x8C   0xEB06 0x0008      ADD      R0,R6,R8
   \       0x90   0x1C41             ADDS     R1,R0,#+1
   \       0x92   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x96   0x.... 0x....      BL       mbedtls_mpi_read_binary
   \       0x9A   0xE003             B.N      ??mbedtls_ecp_point_read_binary_1
    834          #if defined(MBEDTLS_ECP_ENABLE_COMPRESSED_CURVE_PARSING)
    835                  } else if (buf[0] == 0x02 || buf[0] == 0x03) {
    836                      /* format == MBEDTLS_ECP_PF_COMPRESSED */
    837                      if (ilen != 1 + plen) {
    838                          return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    839                      }
    840                      return mbedtls_ecp_sw_derive_y(grp, &pt->X, &pt->Y,
    841                                                     (buf[0] & 1));
    842          #endif
    843                  } else {
    844                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_point_read_binary_8: (+1)
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0xA0   0xE000             B.N      ??mbedtls_ecp_point_read_binary_1
    845                  }
    846              }
    847          #endif
    848          
    849          cleanup:
    850              return ret;
   \                     ??mbedtls_ecp_point_read_binary_2: (+1)
   \       0xA2   0x0038             MOVS     R0,R7
   \                     ??mbedtls_ecp_point_read_binary_1: (+1)
   \       0xA4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    851          }
    852          
    853          /*
    854           * Import a point from a TLS ECPoint record (RFC 4492)
    855           *      struct {
    856           *          opaque point <1..2^8-1>;
    857           *      } ECPoint;
    858           */

   \                                 In section .text, align 2, keep-with-next
    859          int mbedtls_ecp_tls_read_point(const mbedtls_ecp_group *grp,
    860                                         mbedtls_ecp_point *pt,
    861                                         const unsigned char **buf, size_t buf_len)
    862          {
   \                     mbedtls_ecp_tls_read_point: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    863              unsigned char data_len;
    864              const unsigned char *buf_start;
    865              /*
    866               * We must have at least two bytes (1 for length, at least one for data)
    867               */
    868              if (buf_len < 2) {
   \        0xC   0x2F02             CMP      R7,#+2
   \        0xE   0xD202             BCS.N    ??mbedtls_ecp_tls_read_point_0
    869                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x14   0xE01E             B.N      ??mbedtls_ecp_tls_read_point_1
    870              }
    871          
    872              data_len = *(*buf)++;
   \                     ??mbedtls_ecp_tls_read_point_0: (+1)
   \       0x16   0x6831             LDR      R1,[R6, #+0]
   \       0x18   0x1C48             ADDS     R0,R1,#+1
   \       0x1A   0x6030             STR      R0,[R6, #+0]
   \       0x1C   0xF891 0x9000      LDRB     R9,[R1, #+0]
    873              if (data_len < 1 || data_len > buf_len - 1) {
   \       0x20   0x4648             MOV      R0,R9
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD004             BEQ.N    ??mbedtls_ecp_tls_read_point_2
   \       0x28   0x1E79             SUBS     R1,R7,#+1
   \       0x2A   0x4648             MOV      R0,R9
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x4281             CMP      R1,R0
   \       0x30   0xD202             BCS.N    ??mbedtls_ecp_tls_read_point_3
    874                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_tls_read_point_2: (+1)
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x36   0xE00D             B.N      ??mbedtls_ecp_tls_read_point_1
    875              }
    876          
    877              /*
    878               * Save buffer start for read_binary and update buf
    879               */
    880              buf_start = *buf;
   \                     ??mbedtls_ecp_tls_read_point_3: (+1)
   \       0x38   0xF8D6 0x8000      LDR      R8,[R6, #+0]
    881              *buf += data_len;
   \       0x3C   0x6831             LDR      R1,[R6, #+0]
   \       0x3E   0x4648             MOV      R0,R9
   \       0x40   0xB2C0             UXTB     R0,R0
   \       0x42   0x4408             ADD      R0,R1,R0
   \       0x44   0x6030             STR      R0,[R6, #+0]
    882          
    883              return mbedtls_ecp_point_read_binary(grp, pt, buf_start, data_len);
   \       0x46   0x464B             MOV      R3,R9
   \       0x48   0xB2DB             UXTB     R3,R3
   \       0x4A   0x4642             MOV      R2,R8
   \       0x4C   0x0029             MOVS     R1,R5
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       mbedtls_ecp_point_read_binary
   \                     ??mbedtls_ecp_tls_read_point_1: (+1)
   \       0x54   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    884          }
    885          
    886          /*
    887           * Export a point as a TLS ECPoint record (RFC 4492)
    888           *      struct {
    889           *          opaque point <1..2^8-1>;
    890           *      } ECPoint;
    891           */

   \                                 In section .text, align 2, keep-with-next
    892          int mbedtls_ecp_tls_write_point(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt,
    893                                          int format, size_t *olen,
    894                                          unsigned char *buf, size_t blen)
    895          {
   \                     mbedtls_ecp_tls_write_point: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \       0x10   0x9D0B             LDR      R5,[SP, #+44]
    896              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x096D      MVNS     R9,#+109
    897              if (format != MBEDTLS_ECP_PF_UNCOMPRESSED &&
    898                  format != MBEDTLS_ECP_PF_COMPRESSED) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD004             BEQ.N    ??mbedtls_ecp_tls_write_point_0
   \       0x1A   0x2C01             CMP      R4,#+1
   \       0x1C   0xD002             BEQ.N    ??mbedtls_ecp_tls_write_point_0
    899                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x22   0xE01B             B.N      ??mbedtls_ecp_tls_write_point_1
    900              }
    901          
    902              /*
    903               * buffer length must be at least one, for our length byte
    904               */
    905              if (blen < 1) {
   \                     ??mbedtls_ecp_tls_write_point_0: (+1)
   \       0x24   0x2D00             CMP      R5,#+0
   \       0x26   0xD102             BNE.N    ??mbedtls_ecp_tls_write_point_2
    906                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x2C   0xE016             B.N      ??mbedtls_ecp_tls_write_point_1
    907              }
    908          
    909              if ((ret = mbedtls_ecp_point_write_binary(grp, pt, format,
    910                                                        olen, buf + 1, blen - 1)) != 0) {
   \                     ??mbedtls_ecp_tls_write_point_2: (+1)
   \       0x2E   0x1E68             SUBS     R0,R5,#+1
   \       0x30   0x9001             STR      R0,[SP, #+4]
   \       0x32   0xF118 0x0001      ADDS     R0,R8,#+1
   \       0x36   0x9000             STR      R0,[SP, #+0]
   \       0x38   0x003B             MOVS     R3,R7
   \       0x3A   0x0022             MOVS     R2,R4
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0x4650             MOV      R0,R10
   \       0x40   0x.... 0x....      BL       mbedtls_ecp_point_write_binary
   \       0x44   0x0001             MOVS     R1,R0
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD001             BEQ.N    ??mbedtls_ecp_tls_write_point_3
    911                  return ret;
   \       0x4A   0x0008             MOVS     R0,R1
   \       0x4C   0xE006             B.N      ??mbedtls_ecp_tls_write_point_1
    912              }
    913          
    914              /*
    915               * write length to the first byte and update total length
    916               */
    917              buf[0] = (unsigned char) *olen;
   \                     ??mbedtls_ecp_tls_write_point_3: (+1)
   \       0x4E   0x6838             LDR      R0,[R7, #+0]
   \       0x50   0xF888 0x0000      STRB     R0,[R8, #+0]
    918              ++*olen;
   \       0x54   0x6838             LDR      R0,[R7, #+0]
   \       0x56   0x1C40             ADDS     R0,R0,#+1
   \       0x58   0x6038             STR      R0,[R7, #+0]
    919          
    920              return 0;
   \       0x5A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecp_tls_write_point_1: (+1)
   \       0x5C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    921          }
    922          
    923          /*
    924           * Set a group from an ECParameters record (RFC 4492)
    925           */

   \                                 In section .text, align 2, keep-with-next
    926          int mbedtls_ecp_tls_read_group(mbedtls_ecp_group *grp,
    927                                         const unsigned char **buf, size_t len)
    928          {
   \                     mbedtls_ecp_tls_read_group: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
    929              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x066D      MVNS     R6,#+109
    930              mbedtls_ecp_group_id grp_id;
    931              if ((ret = mbedtls_ecp_tls_read_group_id(&grp_id, buf, len)) != 0) {
   \        0xE   0x002A             MOVS     R2,R5
   \       0x10   0x0021             MOVS     R1,R4
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x.... 0x....      BL       mbedtls_ecp_tls_read_group_id
   \       0x18   0x0007             MOVS     R7,R0
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??mbedtls_ecp_tls_read_group_0
    932                  return ret;
   \       0x1E   0x0038             MOVS     R0,R7
   \       0x20   0xE004             B.N      ??mbedtls_ecp_tls_read_group_1
    933              }
    934          
    935              return mbedtls_ecp_group_load(grp, grp_id);
   \                     ??mbedtls_ecp_tls_read_group_0: (+1)
   \       0x22   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x26   0x4640             MOV      R0,R8
   \       0x28   0x.... 0x....      BL       mbedtls_ecp_group_load
   \                     ??mbedtls_ecp_tls_read_group_1: (+1)
   \       0x2C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    936          }
    937          
    938          /*
    939           * Read a group id from an ECParameters record (RFC 4492) and convert it to
    940           * mbedtls_ecp_group_id.
    941           */

   \                                 In section .text, align 2, keep-with-next
    942          int mbedtls_ecp_tls_read_group_id(mbedtls_ecp_group_id *grp,
    943                                            const unsigned char **buf, size_t len)
    944          {
   \                     mbedtls_ecp_tls_read_group_id: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    945              uint16_t tls_id;
    946              const mbedtls_ecp_curve_info *curve_info;
    947              /*
    948               * We expect at least three bytes (see below)
    949               */
    950              if (len < 3) {
   \        0x8   0x2E03             CMP      R6,#+3
   \        0xA   0xD202             BCS.N    ??mbedtls_ecp_tls_read_group_id_0
    951                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x10   0xE029             B.N      ??mbedtls_ecp_tls_read_group_id_1
    952              }
    953          
    954              /*
    955               * First byte is curve_type; only named_curve is handled
    956               */
    957              if (*(*buf)++ != MBEDTLS_ECP_TLS_NAMED_CURVE) {
   \                     ??mbedtls_ecp_tls_read_group_id_0: (+1)
   \       0x12   0x6829             LDR      R1,[R5, #+0]
   \       0x14   0x1C48             ADDS     R0,R1,#+1
   \       0x16   0x6028             STR      R0,[R5, #+0]
   \       0x18   0x7808             LDRB     R0,[R1, #+0]
   \       0x1A   0x2803             CMP      R0,#+3
   \       0x1C   0xD002             BEQ.N    ??mbedtls_ecp_tls_read_group_id_2
    958                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x22   0xE020             B.N      ??mbedtls_ecp_tls_read_group_id_1
    959              }
    960          
    961              /*
    962               * Next two bytes are the namedcurve value
    963               */
    964              tls_id = MBEDTLS_GET_UINT16_BE(*buf, 0);
   \                     ??mbedtls_ecp_tls_read_group_id_2: (+1)
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x28   0x7800             LDRB     R0,[R0, #+0]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD104             BNE.N    ??mbedtls_ecp_tls_read_group_id_3
   \       0x2E   0x6828             LDR      R0,[R5, #+0]
   \       0x30   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x34   0x0007             MOVS     R7,R0
   \       0x36   0xE006             B.N      ??mbedtls_ecp_tls_read_group_id_4
   \                     ??mbedtls_ecp_tls_read_group_id_3: (+1)
   \       0x38   0x6828             LDR      R0,[R5, #+0]
   \       0x3A   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x3E   0xB280             UXTH     R0,R0
   \       0x40   0x.... 0x....      BL       mbedtls_bswap16
   \       0x44   0x0007             MOVS     R7,R0
    965              *buf += 2;
   \                     ??mbedtls_ecp_tls_read_group_id_4: (+1)
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x1C80             ADDS     R0,R0,#+2
   \       0x4A   0x6028             STR      R0,[R5, #+0]
    966          
    967              if ((curve_info = mbedtls_ecp_curve_info_from_tls_id(tls_id)) == NULL) {
   \       0x4C   0x0038             MOVS     R0,R7
   \       0x4E   0xB280             UXTH     R0,R0
   \       0x50   0x.... 0x....      BL       mbedtls_ecp_curve_info_from_tls_id
   \       0x54   0x0001             MOVS     R1,R0
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD102             BNE.N    ??mbedtls_ecp_tls_read_group_id_5
    968                  return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \       0x5E   0xE002             B.N      ??mbedtls_ecp_tls_read_group_id_1
    969              }
    970          
    971              *grp = curve_info->grp_id;
   \                     ??mbedtls_ecp_tls_read_group_id_5: (+1)
   \       0x60   0x7808             LDRB     R0,[R1, #+0]
   \       0x62   0x7020             STRB     R0,[R4, #+0]
    972          
    973              return 0;
   \       0x64   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecp_tls_read_group_id_1: (+1)
   \       0x66   0xBDF2             POP      {R1,R4-R7,PC}
    974          }
    975          
    976          /*
    977           * Write the ECParameters record corresponding to a group (RFC 4492)
    978           */

   \                                 In section .text, align 2, keep-with-next
    979          int mbedtls_ecp_tls_write_group(const mbedtls_ecp_group *grp, size_t *olen,
    980                                          unsigned char *buf, size_t blen)
    981          {
   \                     mbedtls_ecp_tls_write_group: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001E             MOVS     R6,R3
    982              const mbedtls_ecp_curve_info *curve_info;
    983              if ((curve_info = mbedtls_ecp_curve_info_from_grp_id(grp->id)) == NULL) {
   \        0xC   0x7820             LDRB     R0,[R4, #+0]
   \        0xE   0x.... 0x....      BL       mbedtls_ecp_curve_info_from_grp_id
   \       0x12   0x0007             MOVS     R7,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD102             BNE.N    ??mbedtls_ecp_tls_write_group_0
    984                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x1C   0xE01F             B.N      ??mbedtls_ecp_tls_write_group_1
    985              }
    986          
    987              /*
    988               * We are going to write 3 bytes (see below)
    989               */
    990              *olen = 3;
   \                     ??mbedtls_ecp_tls_write_group_0: (+1)
   \       0x1E   0x2003             MOVS     R0,#+3
   \       0x20   0x6028             STR      R0,[R5, #+0]
    991              if (blen < *olen) {
   \       0x22   0x6828             LDR      R0,[R5, #+0]
   \       0x24   0x4286             CMP      R6,R0
   \       0x26   0xD202             BCS.N    ??mbedtls_ecp_tls_write_group_2
    992                  return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \       0x2C   0xE017             B.N      ??mbedtls_ecp_tls_write_group_1
    993              }
    994          
    995              /*
    996               * First byte is curve_type, always named_curve
    997               */
    998              *buf++ = MBEDTLS_ECP_TLS_NAMED_CURVE;
   \                     ??mbedtls_ecp_tls_write_group_2: (+1)
   \       0x2E   0x2003             MOVS     R0,#+3
   \       0x30   0xF888 0x0000      STRB     R0,[R8, #+0]
   \       0x34   0xF118 0x0801      ADDS     R8,R8,#+1
    999          
   1000              /*
   1001               * Next two bytes are the namedcurve value
   1002               */
   1003              MBEDTLS_PUT_UINT16_BE(curve_info->tls_id, buf, 0);
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x3C   0x7800             LDRB     R0,[R0, #+0]
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD104             BNE.N    ??mbedtls_ecp_tls_write_group_3
   \       0x42   0x8879             LDRH     R1,[R7, #+2]
   \       0x44   0x4640             MOV      R0,R8
   \       0x46   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x4A   0xE007             B.N      ??mbedtls_ecp_tls_write_group_4
   \                     ??mbedtls_ecp_tls_write_group_3: (+1)
   \       0x4C   0x8878             LDRH     R0,[R7, #+2]
   \       0x4E   0x.... 0x....      BL       mbedtls_bswap16
   \       0x52   0x0001             MOVS     R1,R0
   \       0x54   0xB289             UXTH     R1,R1
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   1004          
   1005              return 0;
   \                     ??mbedtls_ecp_tls_write_group_4: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecp_tls_write_group_1: (+1)
   \       0x5E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1006          }
   1007          
   1008          /*
   1009           * Wrapper around fast quasi-modp functions, with fall-back to mbedtls_mpi_mod_mpi.
   1010           * See the documentation of struct mbedtls_ecp_group.
   1011           *
   1012           * This function is in the critial loop for mbedtls_ecp_mul, so pay attention to perf.
   1013           */

   \                                 In section .text, align 2, keep-with-next
   1014          static int ecp_modp(mbedtls_mpi *N, const mbedtls_ecp_group *grp)
   1015          {
   \                     ecp_modp: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1016              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x066D      MVNS     R6,#+109
   1017          
   1018              if (grp->modp == NULL) {
   \        0xA   0x6CA8             LDR      R0,[R5, #+72]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD105             BNE.N    ??ecp_modp_0
   1019                  return mbedtls_mpi_mod_mpi(N, N, &grp->P);
   \       0x10   0x1D2A             ADDS     R2,R5,#+4
   \       0x12   0x0021             MOVS     R1,R4
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_mod_mpi
   \       0x1A   0xE03C             B.N      ??ecp_modp_1
   1020              }
   1021          
   1022              /* N->s < 0 is a much faster test, which fails only if N is 0 */
   1023              if ((N->s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0) ||
   1024                  mbedtls_mpi_bitlen(N) > 2 * grp->pbits) {
   \                     ??ecp_modp_0: (+1)
   \       0x1C   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD505             BPL.N    ??ecp_modp_2
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD106             BNE.N    ??ecp_modp_3
   \                     ??ecp_modp_2: (+1)
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0x36   0x6BE9             LDR      R1,[R5, #+60]
   \       0x38   0x0049             LSLS     R1,R1,#+1
   \       0x3A   0x4281             CMP      R1,R0
   \       0x3C   0xD202             BCS.N    ??ecp_modp_4
   1025                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??ecp_modp_3: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x42   0xE028             B.N      ??ecp_modp_1
   1026              }
   1027          
   1028              MBEDTLS_MPI_CHK(grp->modp(N));
   \                     ??ecp_modp_4: (+1)
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x6CA9             LDR      R1,[R5, #+72]
   \       0x48   0x4788             BLX      R1
   \       0x4A   0x0007             MOVS     R7,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD121             BNE.N    ??ecp_modp_5
   1029          
   1030              /* N->s < 0 is a much faster test, which fails only if N is 0 */
   1031              while (N->s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0) {
   \                     ??ecp_modp_6: (+1)
   \                     ??ecp_modp_7: (+1)
   \       0x50   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD50E             BPL.N    ??ecp_modp_8
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD008             BEQ.N    ??ecp_modp_8
   1032                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(N, N, &grp->P));
   \       0x64   0x1D2A             ADDS     R2,R5,#+4
   \       0x66   0x0021             MOVS     R1,R4
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x6E   0x0007             MOVS     R7,R0
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD10F             BNE.N    ??ecp_modp_5
   \                     ??ecp_modp_9: (+1)
   \       0x74   0xE7EC             B.N      ??ecp_modp_7
   1033              }
   1034          
   1035              while (mbedtls_mpi_cmp_mpi(N, &grp->P) >= 0) {
   \                     ??ecp_modp_8: (+1)
   \       0x76   0x1D29             ADDS     R1,R5,#+4
   \       0x78   0x0020             MOVS     R0,R4
   \       0x7A   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD408             BMI.N    ??ecp_modp_5
   1036                  /* we known P, N and the result are positive */
   1037                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(N, N, &grp->P));
   \       0x82   0x1D2A             ADDS     R2,R5,#+4
   \       0x84   0x0021             MOVS     R1,R4
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x8C   0x0007             MOVS     R7,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD100             BNE.N    ??ecp_modp_5
   \                     ??ecp_modp_10: (+1)
   \       0x92   0xE7F0             B.N      ??ecp_modp_8
   1038              }
   1039          
   1040          cleanup:
   1041              return ret;
   \                     ??ecp_modp_5: (+1)
   \       0x94   0x0038             MOVS     R0,R7
   \                     ??ecp_modp_1: (+1)
   \       0x96   0xBDF2             POP      {R1,R4-R7,PC}
   1042          }
   1043          
   1044          /*
   1045           * Fast mod-p functions expect their argument to be in the 0..p^2 range.
   1046           *
   1047           * In order to guarantee that, we need to ensure that operands of
   1048           * mbedtls_mpi_mul_mpi are in the 0..p range. So, after each operation we will
   1049           * bring the result back to this range.
   1050           *
   1051           * The following macros are shortcuts for doing that.
   1052           */
   1053          
   1054          /*
   1055           * Reduce a mbedtls_mpi mod p in-place, general case, to use after mbedtls_mpi_mul_mpi
   1056           */
   1057          #if defined(MBEDTLS_SELF_TEST)
   1058          #define INC_MUL_COUNT   mul_count++;
   1059          #else
   1060          #define INC_MUL_COUNT
   1061          #endif
   1062          
   1063          #define MOD_MUL(N)                                                    \
   1064              do                                                                  \
   1065              {                                                                   \
   1066                  MBEDTLS_MPI_CHK(ecp_modp(&(N), grp));                       \
   1067                  INC_MUL_COUNT                                                   \
   1068              } while (0)
   1069          

   \                                 In section .text, align 2, keep-with-next
   1070          static inline int mbedtls_mpi_mul_mod(const mbedtls_ecp_group *grp,
   1071                                                mbedtls_mpi *X,
   1072                                                const mbedtls_mpi *A,
   1073                                                const mbedtls_mpi *B)
   1074          {
   \                     mbedtls_mpi_mul_mod: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1075              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
   1076              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(X, A, B));
   \       0x10   0x0032             MOVS     R2,R6
   \       0x12   0x0029             MOVS     R1,R5
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_mul_mpi
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD106             BNE.N    ??mbedtls_mpi_mul_mod_0
   1077              MOD_MUL(*X);
   \                     ??mbedtls_mpi_mul_mod_1: (+1)
   \       0x20   0x4649             MOV      R1,R9
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       ecp_modp
   \       0x28   0x4680             MOV      R8,R0
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD1FF             BNE.N    ??mbedtls_mpi_mul_mod_0
   1078          cleanup:
   1079              return ret;
   \                     ??mbedtls_mpi_mul_mod_2: (+1)
   \                     ??mbedtls_mpi_mul_mod_0: (+1)
   \       0x2E   0x4640             MOV      R0,R8
   \       0x30   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1080          }
   1081          
   1082          /*
   1083           * Reduce a mbedtls_mpi mod p in-place, to use after mbedtls_mpi_sub_mpi
   1084           * N->s < 0 is a very fast test, which fails only if N is 0
   1085           */
   1086          #define MOD_SUB(N)                                                          \
   1087              do {                                                                      \
   1088                  while ((N)->s < 0 && mbedtls_mpi_cmp_int((N), 0) != 0)             \
   1089                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi((N), (N), &grp->P));      \
   1090              } while (0)
   1091          
   1092          #if (defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED) && \
   1093              !(defined(MBEDTLS_ECP_NO_FALLBACK) && \
   1094              defined(MBEDTLS_ECP_DOUBLE_JAC_ALT) && \
   1095              defined(MBEDTLS_ECP_ADD_MIXED_ALT))) || \
   1096              (defined(MBEDTLS_ECP_MONTGOMERY_ENABLED) && \
   1097              !(defined(MBEDTLS_ECP_NO_FALLBACK) && \
   1098              defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT)))

   \                                 In section .text, align 2, keep-with-next
   1099          static inline int mbedtls_mpi_sub_mod(const mbedtls_ecp_group *grp,
   1100                                                mbedtls_mpi *X,
   1101                                                const mbedtls_mpi *A,
   1102                                                const mbedtls_mpi *B)
   1103          {
   \                     mbedtls_mpi_sub_mod: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1104              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x096D      MVNS     R9,#+109
   1105              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(X, A, B));
   \       0x10   0x003A             MOVS     R2,R7
   \       0x12   0x0031             MOVS     R1,R6
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD112             BNE.N    ??mbedtls_mpi_sub_mod_0
   1106              MOD_SUB(X);
   \                     ??mbedtls_mpi_sub_mod_1: (+1)
   \                     ??mbedtls_mpi_sub_mod_2: (+1)
   \       0x20   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD50E             BPL.N    ??mbedtls_mpi_sub_mod_3
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD008             BEQ.N    ??mbedtls_mpi_sub_mod_3
   \       0x34   0x1D22             ADDS     R2,R4,#+4
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x3E   0x4680             MOV      R8,R0
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD100             BNE.N    ??mbedtls_mpi_sub_mod_0
   \                     ??mbedtls_mpi_sub_mod_4: (+1)
   \       0x44   0xE7EC             B.N      ??mbedtls_mpi_sub_mod_2
   1107          cleanup:
   1108              return ret;
   \                     ??mbedtls_mpi_sub_mod_3: (+1)
   \                     ??mbedtls_mpi_sub_mod_0: (+1)
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1109          }
   1110          #endif /* All functions referencing mbedtls_mpi_sub_mod() are alt-implemented without fallback */
   1111          
   1112          /*
   1113           * Reduce a mbedtls_mpi mod p in-place, to use after mbedtls_mpi_add_mpi and mbedtls_mpi_mul_int.
   1114           * We known P, N and the result are positive, so sub_abs is correct, and
   1115           * a bit faster.
   1116           */
   1117          #define MOD_ADD(N)                                                   \
   1118              while (mbedtls_mpi_cmp_mpi((N), &grp->P) >= 0)                  \
   1119              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs((N), (N), &grp->P))
   1120          

   \                                 In section .text, align 2, keep-with-next
   1121          static inline int mbedtls_mpi_add_mod(const mbedtls_ecp_group *grp,
   1122                                                mbedtls_mpi *X,
   1123                                                const mbedtls_mpi *A,
   1124                                                const mbedtls_mpi *B)
   1125          {
   \                     mbedtls_mpi_add_mod: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1126              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
   1127              MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(X, A, B));
   \       0x10   0x0032             MOVS     R2,R6
   \       0x12   0x0029             MOVS     R1,R5
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD110             BNE.N    ??mbedtls_mpi_add_mod_0
   1128              MOD_ADD(X);
   \                     ??mbedtls_mpi_add_mod_1: (+1)
   \                     ??mbedtls_mpi_add_mod_2: (+1)
   \       0x20   0xF119 0x0104      ADDS     R1,R9,#+4
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD409             BMI.N    ??mbedtls_mpi_add_mod_0
   \       0x2E   0xF119 0x0204      ADDS     R2,R9,#+4
   \       0x32   0x0021             MOVS     R1,R4
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x3A   0x4680             MOV      R8,R0
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD100             BNE.N    ??mbedtls_mpi_add_mod_0
   \                     ??mbedtls_mpi_add_mod_3: (+1)
   \       0x40   0xE7EE             B.N      ??mbedtls_mpi_add_mod_2
   1129          cleanup:
   1130              return ret;
   \                     ??mbedtls_mpi_add_mod_0: (+1)
   \       0x42   0x4640             MOV      R0,R8
   \       0x44   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1131          }
   1132          
   1133          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   1134          
   1135          #if !(defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_DOUBLE_JAC_ALT))

   \                                 In section .text, align 2, keep-with-next
   1136          static inline int mbedtls_mpi_mul_int_mod(const mbedtls_ecp_group *grp,
   1137                                                    mbedtls_mpi *X,
   1138                                                    const mbedtls_mpi *A,
   1139                                                    mbedtls_mpi_uint c)
   1140          {
   \                     mbedtls_mpi_mul_int_mod: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1141              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
   1142          
   1143              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(X, A, c));
   \       0x10   0x0032             MOVS     R2,R6
   \       0x12   0x0029             MOVS     R1,R5
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_mul_int
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD110             BNE.N    ??mbedtls_mpi_mul_int_mod_0
   1144              MOD_ADD(X);
   \                     ??mbedtls_mpi_mul_int_mod_1: (+1)
   \                     ??mbedtls_mpi_mul_int_mod_2: (+1)
   \       0x20   0xF119 0x0104      ADDS     R1,R9,#+4
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD409             BMI.N    ??mbedtls_mpi_mul_int_mod_0
   \       0x2E   0xF119 0x0204      ADDS     R2,R9,#+4
   \       0x32   0x0021             MOVS     R1,R4
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x3A   0x4680             MOV      R8,R0
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD100             BNE.N    ??mbedtls_mpi_mul_int_mod_0
   \                     ??mbedtls_mpi_mul_int_mod_3: (+1)
   \       0x40   0xE7EE             B.N      ??mbedtls_mpi_mul_int_mod_2
   1145          cleanup:
   1146              return ret;
   \                     ??mbedtls_mpi_mul_int_mod_0: (+1)
   \       0x42   0x4640             MOV      R0,R8
   \       0x44   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1147          }
   1148          #endif /* !(MBEDTLS_ECP_NO_FALLBACK && MBEDTLS_ECP_DOUBLE_JAC_ALT) */
   1149          

   \                                 In section .text, align 2, keep-with-next
   1150          static inline int mbedtls_mpi_sub_int_mod(const mbedtls_ecp_group *grp,
   1151                                                    mbedtls_mpi *X,
   1152                                                    const mbedtls_mpi *A,
   1153                                                    mbedtls_mpi_uint c)
   1154          {
   \                     mbedtls_mpi_sub_int_mod: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1155              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x096D      MVNS     R9,#+109
   1156          
   1157              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int(X, A, c));
   \       0x10   0x003A             MOVS     R2,R7
   \       0x12   0x0031             MOVS     R1,R6
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_sub_int
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD112             BNE.N    ??mbedtls_mpi_sub_int_mod_0
   1158              MOD_SUB(X);
   \                     ??mbedtls_mpi_sub_int_mod_1: (+1)
   \                     ??mbedtls_mpi_sub_int_mod_2: (+1)
   \       0x20   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD50E             BPL.N    ??mbedtls_mpi_sub_int_mod_3
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD008             BEQ.N    ??mbedtls_mpi_sub_int_mod_3
   \       0x34   0x1D22             ADDS     R2,R4,#+4
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x3E   0x4680             MOV      R8,R0
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD100             BNE.N    ??mbedtls_mpi_sub_int_mod_0
   \                     ??mbedtls_mpi_sub_int_mod_4: (+1)
   \       0x44   0xE7EC             B.N      ??mbedtls_mpi_sub_int_mod_2
   1159          cleanup:
   1160              return ret;
   \                     ??mbedtls_mpi_sub_int_mod_3: (+1)
   \                     ??mbedtls_mpi_sub_int_mod_0: (+1)
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1161          }
   1162          
   1163          #define MPI_ECP_SUB_INT(X, A, c)             \
   1164              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int_mod(grp, X, A, c))
   1165          
   1166          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   1167          
   1168          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED) && \
   1169              !(defined(MBEDTLS_ECP_NO_FALLBACK) && \
   1170              defined(MBEDTLS_ECP_DOUBLE_JAC_ALT) && \
   1171              defined(MBEDTLS_ECP_ADD_MIXED_ALT))

   \                                 In section .text, align 2, keep-with-next
   1172          static inline int mbedtls_mpi_shift_l_mod(const mbedtls_ecp_group *grp,
   1173                                                    mbedtls_mpi *X,
   1174                                                    size_t count)
   1175          {
   \                     mbedtls_mpi_shift_l_mod: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1176              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x086D      MVNS     R8,#+109
   1177              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(X, count));
   \        0xE   0x0031             MOVS     R1,R6
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \       0x16   0x0007             MOVS     R7,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD10E             BNE.N    ??mbedtls_mpi_shift_l_mod_0
   1178              MOD_ADD(X);
   \                     ??mbedtls_mpi_shift_l_mod_1: (+1)
   \                     ??mbedtls_mpi_shift_l_mod_2: (+1)
   \       0x1C   0x1D21             ADDS     R1,R4,#+4
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD408             BMI.N    ??mbedtls_mpi_shift_l_mod_0
   \       0x28   0x1D22             ADDS     R2,R4,#+4
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0x0028             MOVS     R0,R5
   \       0x2E   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x32   0x0007             MOVS     R7,R0
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD100             BNE.N    ??mbedtls_mpi_shift_l_mod_0
   \                     ??mbedtls_mpi_shift_l_mod_3: (+1)
   \       0x38   0xE7F0             B.N      ??mbedtls_mpi_shift_l_mod_2
   1179          cleanup:
   1180              return ret;
   \                     ??mbedtls_mpi_shift_l_mod_0: (+1)
   \       0x3A   0x0038             MOVS     R0,R7
   \       0x3C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1181          }
   1182          #endif \
   1183              /* All functions referencing mbedtls_mpi_shift_l_mod() are alt-implemented without fallback */
   1184          
   1185          /*
   1186           * Macro wrappers around ECP modular arithmetic
   1187           *
   1188           * Currently, these wrappers are defined via the bignum module.
   1189           */
   1190          
   1191          #define MPI_ECP_ADD(X, A, B)                                                  \
   1192              MBEDTLS_MPI_CHK(mbedtls_mpi_add_mod(grp, X, A, B))
   1193          
   1194          #define MPI_ECP_SUB(X, A, B)                                                  \
   1195              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mod(grp, X, A, B))
   1196          
   1197          #define MPI_ECP_MUL(X, A, B)                                                  \
   1198              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mod(grp, X, A, B))
   1199          
   1200          #define MPI_ECP_SQR(X, A)                                                     \
   1201              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mod(grp, X, A, A))
   1202          
   1203          #define MPI_ECP_MUL_INT(X, A, c)                                              \
   1204              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int_mod(grp, X, A, c))
   1205          
   1206          #define MPI_ECP_INV(dst, src)                                                 \
   1207              MBEDTLS_MPI_CHK(mbedtls_mpi_inv_mod((dst), (src), &grp->P))
   1208          
   1209          #define MPI_ECP_MOV(X, A)                                                     \
   1210              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A))
   1211          
   1212          #define MPI_ECP_SHIFT_L(X, count)                                             \
   1213              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l_mod(grp, X, count))
   1214          
   1215          #define MPI_ECP_LSET(X, c)                                                    \
   1216              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, c))
   1217          
   1218          #define MPI_ECP_CMP_INT(X, c)                                                 \
   1219              mbedtls_mpi_cmp_int(X, c)
   1220          
   1221          #define MPI_ECP_CMP(X, Y)                                                     \
   1222              mbedtls_mpi_cmp_mpi(X, Y)
   1223          
   1224          /* Needs f_rng, p_rng to be defined. */
   1225          #define MPI_ECP_RAND(X)                                                       \
   1226              MBEDTLS_MPI_CHK(mbedtls_mpi_random((X), 2, &grp->P, f_rng, p_rng))
   1227          
   1228          /* Conditional negation
   1229           * Needs grp and a temporary MPI tmp to be defined. */
   1230          #define MPI_ECP_COND_NEG(X, cond)                                        \
   1231              do                                                                     \
   1232              {                                                                      \
   1233                  unsigned char nonzero = mbedtls_mpi_cmp_int((X), 0) != 0;        \
   1234                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&tmp, &grp->P, (X)));      \
   1235                  MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign((X), &tmp,          \
   1236                                                               nonzero & cond)); \
   1237              } while (0)
   1238          
   1239          #define MPI_ECP_NEG(X) MPI_ECP_COND_NEG((X), 1)
   1240          
   1241          #define MPI_ECP_VALID(X)                      \
   1242              ((X)->p != NULL)
   1243          
   1244          #define MPI_ECP_COND_ASSIGN(X, Y, cond)       \
   1245              MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign((X), (Y), (cond)))
   1246          
   1247          #define MPI_ECP_COND_SWAP(X, Y, cond)       \
   1248              MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_swap((X), (Y), (cond)))
   1249          
   1250          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   1251          
   1252          /*
   1253           * Computes the right-hand side of the Short Weierstrass equation
   1254           * RHS = X^3 + A X + B
   1255           */

   \                                 In section .text, align 2, keep-with-next
   1256          static int ecp_sw_rhs(const mbedtls_ecp_group *grp,
   1257                                mbedtls_mpi *rhs,
   1258                                const mbedtls_mpi *X)
   1259          {
   \                     ecp_sw_rhs: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   1260              int ret;
   1261          
   1262              /* Compute X^3 + A X + B as X (X^2 + A) + B */
   1263              MPI_ECP_SQR(rhs, X);
   \        0x8   0x002B             MOVS     R3,R5
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0038             MOVS     R0,R7
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x14   0x0006             MOVS     R6,R0
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD12B             BNE.N    ??ecp_sw_rhs_0
   1264          
   1265              /* Special case for A = -3 */
   1266              if (mbedtls_ecp_group_a_is_minus_3(grp)) {
   \                     ??ecp_sw_rhs_1: (+1)
   \       0x1A   0x0038             MOVS     R0,R7
   \       0x1C   0x.... 0x....      BL       mbedtls_ecp_group_a_is_minus_3
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD009             BEQ.N    ??ecp_sw_rhs_2
   1267                  MPI_ECP_SUB_INT(rhs, rhs, 3);
   \       0x24   0x2303             MOVS     R3,#+3
   \       0x26   0x0022             MOVS     R2,R4
   \       0x28   0x0021             MOVS     R1,R4
   \       0x2A   0x0038             MOVS     R0,R7
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_sub_int_mod
   \       0x30   0x0006             MOVS     R6,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD11D             BNE.N    ??ecp_sw_rhs_0
   \                     ??ecp_sw_rhs_3: (+1)
   \       0x36   0xE009             B.N      ??ecp_sw_rhs_4
   1268              } else {
   1269                  MPI_ECP_ADD(rhs, rhs, &grp->A);
   \                     ??ecp_sw_rhs_2: (+1)
   \       0x38   0xF117 0x030C      ADDS     R3,R7,#+12
   \       0x3C   0x0022             MOVS     R2,R4
   \       0x3E   0x0021             MOVS     R1,R4
   \       0x40   0x0038             MOVS     R0,R7
   \       0x42   0x.... 0x....      BL       mbedtls_mpi_add_mod
   \       0x46   0x0006             MOVS     R6,R0
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD112             BNE.N    ??ecp_sw_rhs_0
   1270              }
   1271          
   1272              MPI_ECP_MUL(rhs, rhs, X);
   \                     ??ecp_sw_rhs_5: (+1)
   \                     ??ecp_sw_rhs_4: (+1)
   \       0x4C   0x002B             MOVS     R3,R5
   \       0x4E   0x0022             MOVS     R2,R4
   \       0x50   0x0021             MOVS     R1,R4
   \       0x52   0x0038             MOVS     R0,R7
   \       0x54   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x58   0x0006             MOVS     R6,R0
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD109             BNE.N    ??ecp_sw_rhs_0
   1273              MPI_ECP_ADD(rhs, rhs, &grp->B);
   \                     ??ecp_sw_rhs_6: (+1)
   \       0x5E   0xF117 0x0314      ADDS     R3,R7,#+20
   \       0x62   0x0022             MOVS     R2,R4
   \       0x64   0x0021             MOVS     R1,R4
   \       0x66   0x0038             MOVS     R0,R7
   \       0x68   0x.... 0x....      BL       mbedtls_mpi_add_mod
   \       0x6C   0x0006             MOVS     R6,R0
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD1FF             BNE.N    ??ecp_sw_rhs_0
   1274          
   1275          cleanup:
   1276              return ret;
   \                     ??ecp_sw_rhs_7: (+1)
   \                     ??ecp_sw_rhs_0: (+1)
   \       0x72   0x0030             MOVS     R0,R6
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}
   1277          }
   1278          
   1279          #if defined(MBEDTLS_ECP_ENABLE_COMPRESSED_CURVE_PARSING)
   1280          /*
   1281           * Derive Y from X and a parity bit
   1282           */
   1283          static int mbedtls_ecp_sw_derive_y(const mbedtls_ecp_group *grp,
   1284                                             const mbedtls_mpi *X,
   1285                                             mbedtls_mpi *Y,
   1286                                             int parity_bit)
   1287          {
   1288              /* w = y^2 = x^3 + ax + b
   1289               * y = sqrt(w) = w^((p+1)/4) mod p   (for prime p where p = 3 mod 4)
   1290               *
   1291               * Note: this method for extracting square root does not validate that w
   1292               * was indeed a square so this function will return garbage in Y if X
   1293               * does not correspond to a point on the curve.
   1294               */
   1295          
   1296              /* Check prerequisite p = 3 mod 4 */
   1297              if (mbedtls_mpi_get_bit(&grp->P, 0) != 1 ||
   1298                  mbedtls_mpi_get_bit(&grp->P, 1) != 1) {
   1299                  return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1300              }
   1301          
   1302              int ret;
   1303              mbedtls_mpi exp;
   1304              mbedtls_mpi_init(&exp);
   1305          
   1306              /* use Y to store intermediate result, actually w above */
   1307              MBEDTLS_MPI_CHK(ecp_sw_rhs(grp, Y, X));
   1308          
   1309              /* w = y^2 */ /* Y contains y^2 intermediate result */
   1310              /* exp = ((p+1)/4) */
   1311              MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&exp, &grp->P, 1));
   1312              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&exp, 2));
   1313              /* sqrt(w) = w^((p+1)/4) mod p   (for prime p where p = 3 mod 4) */
   1314              MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(Y, Y /*y^2*/, &exp, &grp->P, NULL));
   1315          
   1316              /* check parity bit match or else invert Y */
   1317              /* This quick inversion implementation is valid because Y != 0 for all
   1318               * Short Weierstrass curves supported by mbedtls, as each supported curve
   1319               * has an order that is a large prime, so each supported curve does not
   1320               * have any point of order 2, and a point with Y == 0 would be of order 2 */
   1321              if (mbedtls_mpi_get_bit(Y, 0) != parity_bit) {
   1322                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(Y, &grp->P, Y));
   1323              }
   1324          
   1325          cleanup:
   1326          
   1327              mbedtls_mpi_free(&exp);
   1328              return ret;
   1329          }
   1330          #endif /* MBEDTLS_ECP_ENABLE_COMPRESSED_CURVE_PARSING */
   1331          
   1332          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   1333          
   1334          #if defined(MBEDTLS_ECP_C)
   1335          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   1336          /*
   1337           * For curves in short Weierstrass form, we do all the internal operations in
   1338           * Jacobian coordinates.
   1339           *
   1340           * For multiplication, we'll use a comb method with countermeasures against
   1341           * SPA, hence timing attacks.
   1342           */
   1343          
   1344          /*
   1345           * Normalize jacobian coordinates so that Z == 0 || Z == 1  (GECC 3.2.1)
   1346           * Cost: 1N := 1I + 3M + 1S
   1347           */

   \                                 In section .text, align 2, keep-with-next
   1348          static int ecp_normalize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt)
   1349          {
   \                     ecp_normalize_jac: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   1350              if (MPI_ECP_CMP_INT(&pt->Z, 0) == 0) {
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xF114 0x0010      ADDS     R0,R4,#+16
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD101             BNE.N    ??ecp_normalize_jac_0
   1351                  return 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE041             B.N      ??ecp_normalize_jac_1
   1352              }
   1353          
   1354          #if defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)
   1355              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1356                  return mbedtls_internal_ecp_normalize_jac(grp, pt);
   1357              }
   1358          #endif /* MBEDTLS_ECP_NORMALIZE_JAC_ALT */
   1359          
   1360          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)
   1361              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1362          #else
   1363              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??ecp_normalize_jac_0: (+1)
   \       0x18   0xF07F 0x076D      MVNS     R7,#+109
   1364              mbedtls_mpi T;
   1365              mbedtls_mpi_init(&T);
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_init
   1366          
   1367              MPI_ECP_INV(&T,       &pt->Z);            /* T   <-          1 / Z   */
   \       0x22   0x1D32             ADDS     R2,R6,#+4
   \       0x24   0xF114 0x0110      ADDS     R1,R4,#+16
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_inv_mod
   \       0x2E   0x0005             MOVS     R5,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD12F             BNE.N    ??ecp_normalize_jac_2
   1368              MPI_ECP_MUL(&pt->Y,   &pt->Y,     &T);    /* Y'  <- Y*T    = Y / Z   */
   \                     ??ecp_normalize_jac_3: (+1)
   \       0x34   0x466B             MOV      R3,SP
   \       0x36   0xF114 0x0208      ADDS     R2,R4,#+8
   \       0x3A   0xF114 0x0108      ADDS     R1,R4,#+8
   \       0x3E   0x0030             MOVS     R0,R6
   \       0x40   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x44   0x0005             MOVS     R5,R0
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD124             BNE.N    ??ecp_normalize_jac_2
   1369              MPI_ECP_SQR(&T,       &T);                /* T   <- T^2    = 1 / Z^2 */
   \                     ??ecp_normalize_jac_4: (+1)
   \       0x4A   0x466B             MOV      R3,SP
   \       0x4C   0x466A             MOV      R2,SP
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x0030             MOVS     R0,R6
   \       0x52   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x56   0x0005             MOVS     R5,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD11B             BNE.N    ??ecp_normalize_jac_2
   1370              MPI_ECP_MUL(&pt->X,   &pt->X,     &T);    /* X   <- X  * T = X / Z^2 */
   \                     ??ecp_normalize_jac_5: (+1)
   \       0x5C   0x466B             MOV      R3,SP
   \       0x5E   0x0022             MOVS     R2,R4
   \       0x60   0x0021             MOVS     R1,R4
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x68   0x0005             MOVS     R5,R0
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD112             BNE.N    ??ecp_normalize_jac_2
   1371              MPI_ECP_MUL(&pt->Y,   &pt->Y,     &T);    /* Y'' <- Y' * T = Y / Z^3 */
   \                     ??ecp_normalize_jac_6: (+1)
   \       0x6E   0x466B             MOV      R3,SP
   \       0x70   0xF114 0x0208      ADDS     R2,R4,#+8
   \       0x74   0xF114 0x0108      ADDS     R1,R4,#+8
   \       0x78   0x0030             MOVS     R0,R6
   \       0x7A   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x7E   0x0005             MOVS     R5,R0
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD107             BNE.N    ??ecp_normalize_jac_2
   1372          
   1373              MPI_ECP_LSET(&pt->Z, 1);
   \                     ??ecp_normalize_jac_7: (+1)
   \       0x84   0x2101             MOVS     R1,#+1
   \       0x86   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0x8A   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x8E   0x0005             MOVS     R5,R0
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD1FF             BNE.N    ??ecp_normalize_jac_2
   1374          
   1375          cleanup:
   1376          
   1377              mbedtls_mpi_free(&T);
   \                     ??ecp_normalize_jac_8: (+1)
   \                     ??ecp_normalize_jac_2: (+1)
   \       0x94   0x4668             MOV      R0,SP
   \       0x96   0x.... 0x....      BL       mbedtls_mpi_free
   1378          
   1379              return ret;
   \       0x9A   0x0028             MOVS     R0,R5
   \                     ??ecp_normalize_jac_1: (+1)
   \       0x9C   0xBDFE             POP      {R1-R7,PC}
   1380          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT) */
   1381          }
   1382          
   1383          /*
   1384           * Normalize jacobian coordinates of an array of (pointers to) points,
   1385           * using Montgomery's trick to perform only one inversion mod P.
   1386           * (See for example Cohen's "A Course in Computational Algebraic Number
   1387           * Theory", Algorithm 10.3.4.)
   1388           *
   1389           * Warning: fails (returning an error) if one of the points is zero!
   1390           * This should never happen, see choice of w in ecp_mul_comb().
   1391           *
   1392           * Cost: 1N(t) := 1I + (6t - 3)M + 1S
   1393           */

   \                                 In section .text, align 2, keep-with-next
   1394          static int ecp_normalize_jac_many(const mbedtls_ecp_group *grp,
   1395                                            mbedtls_ecp_point *T[], size_t T_size)
   1396          {
   \                     ecp_normalize_jac_many: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   1397              if (T_size < 2) {
   \        0xA   0x2F02             CMP      R7,#+2
   \        0xC   0xD204             BCS.N    ??ecp_normalize_jac_many_0
   1398                  return ecp_normalize_jac(grp, *T);
   \        0xE   0x6831             LDR      R1,[R6, #+0]
   \       0x10   0x4648             MOV      R0,R9
   \       0x12   0x.... 0x....      BL       ecp_normalize_jac
   \       0x16   0xE0C7             B.N      ??ecp_normalize_jac_many_1
   1399              }
   1400          
   1401          #if defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT)
   1402              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1403                  return mbedtls_internal_ecp_normalize_jac_many(grp, T, T_size);
   1404              }
   1405          #endif
   1406          
   1407          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT)
   1408              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1409          #else
   1410              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??ecp_normalize_jac_many_0: (+1)
   \       0x18   0xF07F 0x0A6D      MVNS     R10,#+109
   1411              size_t i;
   1412              mbedtls_mpi *c, t;
   1413          
   1414              if ((c = mbedtls_calloc(T_size, sizeof(mbedtls_mpi))) == NULL) {
   \       0x1C   0x2108             MOVS     R1,#+8
   \       0x1E   0x0038             MOVS     R0,R7
   \       0x20   0x.... 0x....      BL       sl_calloc
   \       0x24   0x0005             MOVS     R5,R0
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xD102             BNE.N    ??ecp_normalize_jac_many_2
   1415                  return MBEDTLS_ERR_ECP_ALLOC_FAILED;
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x2E   0xE0BB             B.N      ??ecp_normalize_jac_many_1
   1416              }
   1417          
   1418              mbedtls_mpi_init(&t);
   \                     ??ecp_normalize_jac_many_2: (+1)
   \       0x30   0x4668             MOV      R0,SP
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_init
   1419          
   1420              mpi_init_many(c, T_size);
   \       0x36   0x0039             MOVS     R1,R7
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       mpi_init_many
   1421              /*
   1422               * c[i] = Z_0 * ... * Z_i,   i = 0,..,n := T_size-1
   1423               */
   1424              MPI_ECP_MOV(&c[0], &T[0]->Z);
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0xF110 0x0110      ADDS     R1,R0,#+16
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x4A   0x4680             MOV      R8,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xF040 0x80A0      BNE.W    ??ecp_normalize_jac_many_3
   1425              for (i = 1; i < T_size; i++) {
   \                     ??ecp_normalize_jac_many_4: (+1)
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0x0004             MOVS     R4,R0
   \                     ??ecp_normalize_jac_many_5: (+1)
   \       0x56   0x42BC             CMP      R4,R7
   \       0x58   0xD212             BCS.N    ??ecp_normalize_jac_many_6
   1426                  MPI_ECP_MUL(&c[i], &c[i-1], &T[i]->Z);
   \       0x5A   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \       0x5E   0xF110 0x0310      ADDS     R3,R0,#+16
   \       0x62   0xEB05 0x00C4      ADD      R0,R5,R4, LSL #+3
   \       0x66   0xF1B0 0x0208      SUBS     R2,R0,#+8
   \       0x6A   0xEB05 0x01C4      ADD      R1,R5,R4, LSL #+3
   \       0x6E   0x4648             MOV      R0,R9
   \       0x70   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x74   0x4680             MOV      R8,R0
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xF040 0x808B      BNE.W    ??ecp_normalize_jac_many_3
   1427              }
   \                     ??ecp_normalize_jac_many_7: (+1)
   \       0x7C   0x1C64             ADDS     R4,R4,#+1
   \       0x7E   0xE7EA             B.N      ??ecp_normalize_jac_many_5
   1428          
   1429              /*
   1430               * c[n] = 1 / (Z_0 * ... * Z_n) mod P
   1431               */
   1432              MPI_ECP_INV(&c[T_size-1], &c[T_size-1]);
   \                     ??ecp_normalize_jac_many_6: (+1)
   \       0x80   0xF119 0x0204      ADDS     R2,R9,#+4
   \       0x84   0xEB05 0x00C7      ADD      R0,R5,R7, LSL #+3
   \       0x88   0xF1B0 0x0108      SUBS     R1,R0,#+8
   \       0x8C   0xEB05 0x00C7      ADD      R0,R5,R7, LSL #+3
   \       0x90   0x3808             SUBS     R0,R0,#+8
   \       0x92   0x.... 0x....      BL       mbedtls_mpi_inv_mod
   \       0x96   0x4680             MOV      R8,R0
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD17A             BNE.N    ??ecp_normalize_jac_many_3
   1433          
   1434              for (i = T_size - 1;; i--) {
   \                     ??ecp_normalize_jac_many_8: (+1)
   \       0x9C   0x1E78             SUBS     R0,R7,#+1
   \       0x9E   0x0004             MOVS     R4,R0
   1435                  /* At the start of iteration i (note that i decrements), we have
   1436                   * - c[j] = Z_0 * .... * Z_j        for j  < i,
   1437                   * - c[j] = 1 / (Z_0 * .... * Z_j)  for j == i,
   1438                   *
   1439                   * This is maintained via
   1440                   * - c[i-1] <- c[i] * Z_i
   1441                   *
   1442                   * We also derive 1/Z_i = c[i] * c[i-1] for i>0 and use that
   1443                   * to do the actual normalization. For i==0, we already have
   1444                   * c[0] = 1 / Z_0.
   1445                   */
   1446          
   1447                  if (i > 0) {
   \                     ??ecp_normalize_jac_many_9: (+1)
   \       0xA0   0x2C00             CMP      R4,#+0
   \       0xA2   0xD01D             BEQ.N    ??ecp_normalize_jac_many_10
   1448                      /* Compute 1/Z_i and establish invariant for the next iteration. */
   1449                      MPI_ECP_MUL(&t,      &c[i], &c[i-1]);
   \       0xA4   0xEB05 0x00C4      ADD      R0,R5,R4, LSL #+3
   \       0xA8   0xF1B0 0x0308      SUBS     R3,R0,#+8
   \       0xAC   0xEB05 0x02C4      ADD      R2,R5,R4, LSL #+3
   \       0xB0   0x4669             MOV      R1,SP
   \       0xB2   0x4648             MOV      R0,R9
   \       0xB4   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0xB8   0x4680             MOV      R8,R0
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD169             BNE.N    ??ecp_normalize_jac_many_3
   1450                      MPI_ECP_MUL(&c[i-1], &c[i], &T[i]->Z);
   \                     ??ecp_normalize_jac_many_11: (+1)
   \       0xBE   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \       0xC2   0xF110 0x0310      ADDS     R3,R0,#+16
   \       0xC6   0xEB05 0x02C4      ADD      R2,R5,R4, LSL #+3
   \       0xCA   0xEB05 0x00C4      ADD      R0,R5,R4, LSL #+3
   \       0xCE   0xF1B0 0x0108      SUBS     R1,R0,#+8
   \       0xD2   0x4648             MOV      R0,R9
   \       0xD4   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0xD8   0x4680             MOV      R8,R0
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD159             BNE.N    ??ecp_normalize_jac_many_3
   \                     ??ecp_normalize_jac_many_12: (+1)
   \       0xDE   0xE006             B.N      ??ecp_normalize_jac_many_13
   1451                  } else {
   1452                      MPI_ECP_MOV(&t, &c[0]);
   \                     ??ecp_normalize_jac_many_10: (+1)
   \       0xE0   0x0029             MOVS     R1,R5
   \       0xE2   0x4668             MOV      R0,SP
   \       0xE4   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0xE8   0x4680             MOV      R8,R0
   \       0xEA   0x2800             CMP      R0,#+0
   \       0xEC   0xD151             BNE.N    ??ecp_normalize_jac_many_3
   1453                  }
   1454          
   1455                  /* Now t holds 1 / Z_i; normalize as in ecp_normalize_jac() */
   1456                  MPI_ECP_MUL(&T[i]->Y, &T[i]->Y, &t);
   \                     ??ecp_normalize_jac_many_14: (+1)
   \                     ??ecp_normalize_jac_many_13: (+1)
   \       0xEE   0x466B             MOV      R3,SP
   \       0xF0   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \       0xF4   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0xF8   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \       0xFC   0xF110 0x0108      ADDS     R1,R0,#+8
   \      0x100   0x4648             MOV      R0,R9
   \      0x102   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x106   0x4680             MOV      R8,R0
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD142             BNE.N    ??ecp_normalize_jac_many_3
   1457                  MPI_ECP_SQR(&t,       &t);
   \                     ??ecp_normalize_jac_many_15: (+1)
   \      0x10C   0x466B             MOV      R3,SP
   \      0x10E   0x466A             MOV      R2,SP
   \      0x110   0x4669             MOV      R1,SP
   \      0x112   0x4648             MOV      R0,R9
   \      0x114   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x118   0x4680             MOV      R8,R0
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD139             BNE.N    ??ecp_normalize_jac_many_3
   1458                  MPI_ECP_MUL(&T[i]->X, &T[i]->X, &t);
   \                     ??ecp_normalize_jac_many_16: (+1)
   \      0x11E   0x466B             MOV      R3,SP
   \      0x120   0xF856 0x2024      LDR      R2,[R6, R4, LSL #+2]
   \      0x124   0xF856 0x1024      LDR      R1,[R6, R4, LSL #+2]
   \      0x128   0x4648             MOV      R0,R9
   \      0x12A   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x12E   0x4680             MOV      R8,R0
   \      0x130   0x2800             CMP      R0,#+0
   \      0x132   0xD12E             BNE.N    ??ecp_normalize_jac_many_3
   1459                  MPI_ECP_MUL(&T[i]->Y, &T[i]->Y, &t);
   \                     ??ecp_normalize_jac_many_17: (+1)
   \      0x134   0x466B             MOV      R3,SP
   \      0x136   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \      0x13A   0xF110 0x0208      ADDS     R2,R0,#+8
   \      0x13E   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \      0x142   0xF110 0x0108      ADDS     R1,R0,#+8
   \      0x146   0x4648             MOV      R0,R9
   \      0x148   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x14C   0x4680             MOV      R8,R0
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD11F             BNE.N    ??ecp_normalize_jac_many_3
   1460          
   1461                  /*
   1462                   * Post-precessing: reclaim some memory by shrinking coordinates
   1463                   * - not storing Z (always 1)
   1464                   * - shrinking other coordinates, but still keeping the same number of
   1465                   *   limbs as P, as otherwise it will too likely be regrown too fast.
   1466                   */
   1467                  MBEDTLS_MPI_CHK(mbedtls_mpi_shrink(&T[i]->X, grp->P.n));
   \                     ??ecp_normalize_jac_many_18: (+1)
   \      0x152   0xF8B9 0x100A      LDRH     R1,[R9, #+10]
   \      0x156   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \      0x15A   0x.... 0x....      BL       mbedtls_mpi_shrink
   \      0x15E   0x4680             MOV      R8,R0
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD116             BNE.N    ??ecp_normalize_jac_many_3
   1468                  MBEDTLS_MPI_CHK(mbedtls_mpi_shrink(&T[i]->Y, grp->P.n));
   \                     ??ecp_normalize_jac_many_19: (+1)
   \      0x164   0xF8B9 0x100A      LDRH     R1,[R9, #+10]
   \      0x168   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \      0x16C   0x3008             ADDS     R0,R0,#+8
   \      0x16E   0x.... 0x....      BL       mbedtls_mpi_shrink
   \      0x172   0x4680             MOV      R8,R0
   \      0x174   0x2800             CMP      R0,#+0
   \      0x176   0xD10C             BNE.N    ??ecp_normalize_jac_many_3
   1469          
   1470                  MPI_ECP_LSET(&T[i]->Z, 1);
   \                     ??ecp_normalize_jac_many_20: (+1)
   \      0x178   0x2101             MOVS     R1,#+1
   \      0x17A   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \      0x17E   0x3010             ADDS     R0,R0,#+16
   \      0x180   0x.... 0x....      BL       mbedtls_mpi_lset
   \      0x184   0x4680             MOV      R8,R0
   \      0x186   0x2800             CMP      R0,#+0
   \      0x188   0xD103             BNE.N    ??ecp_normalize_jac_many_3
   1471          
   1472                  if (i == 0) {
   \                     ??ecp_normalize_jac_many_21: (+1)
   \      0x18A   0x2C00             CMP      R4,#+0
   \      0x18C   0xD001             BEQ.N    ??ecp_normalize_jac_many_3
   1473                      break;
   1474                  }
   1475              }
   \                     ??ecp_normalize_jac_many_22: (+1)
   \      0x18E   0x1E64             SUBS     R4,R4,#+1
   \      0x190   0xE786             B.N      ??ecp_normalize_jac_many_9
   1476          
   1477          cleanup:
   1478          
   1479              mbedtls_mpi_free(&t);
   \                     ??ecp_normalize_jac_many_3: (+1)
   \      0x192   0x4668             MOV      R0,SP
   \      0x194   0x.... 0x....      BL       mbedtls_mpi_free
   1480              mpi_free_many(c, T_size);
   \      0x198   0x0039             MOVS     R1,R7
   \      0x19A   0x0028             MOVS     R0,R5
   \      0x19C   0x.... 0x....      BL       mpi_free_many
   1481              mbedtls_free(c);
   \      0x1A0   0x0028             MOVS     R0,R5
   \      0x1A2   0x.... 0x....      BL       sl_free
   1482          
   1483              return ret;
   \      0x1A6   0x4640             MOV      R0,R8
   \                     ??ecp_normalize_jac_many_1: (+1)
   \      0x1A8   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   1484          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT) */
   1485          }
   1486          
   1487          /*
   1488           * Conditional point inversion: Q -> -Q = (Q.X, -Q.Y, Q.Z) without leak.
   1489           * "inv" must be 0 (don't invert) or 1 (invert) or the result will be invalid
   1490           */

   \                                 In section .text, align 2, keep-with-next
   1491          static int ecp_safe_invert_jac(const mbedtls_ecp_group *grp,
   1492                                         mbedtls_ecp_point *Q,
   1493                                         unsigned char inv)
   1494          {
   \                     ecp_safe_invert_jac: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1495              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x096D      MVNS     R9,#+109
   1496              mbedtls_mpi tmp;
   1497              mbedtls_mpi_init(&tmp);
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_init
   1498          
   1499              MPI_ECP_COND_NEG(&Q->Y, inv);
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??ecp_safe_invert_jac_0
   \       0x22   0x2701             MOVS     R7,#+1
   \       0x24   0xE000             B.N      ??ecp_safe_invert_jac_1
   \                     ??ecp_safe_invert_jac_0: (+1)
   \       0x26   0x2700             MOVS     R7,#+0
   \                     ??ecp_safe_invert_jac_1: (+1)
   \       0x28   0xF115 0x0208      ADDS     R2,R5,#+8
   \       0x2C   0x1D21             ADDS     R1,R4,#+4
   \       0x2E   0x4668             MOV      R0,SP
   \       0x30   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x34   0x4680             MOV      R8,R0
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD10A             BNE.N    ??ecp_safe_invert_jac_2
   \                     ??ecp_safe_invert_jac_3: (+1)
   \       0x3A   0xEA16 0x0207      ANDS     R2,R6,R7
   \       0x3E   0xB2D2             UXTB     R2,R2
   \       0x40   0x4669             MOV      R1,SP
   \       0x42   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x46   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x4A   0x4680             MOV      R8,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD1FF             BNE.N    ??ecp_safe_invert_jac_2
   1500          
   1501          cleanup:
   1502              mbedtls_mpi_free(&tmp);
   \                     ??ecp_safe_invert_jac_4: (+1)
   \                     ??ecp_safe_invert_jac_2: (+1)
   \       0x50   0x4668             MOV      R0,SP
   \       0x52   0x.... 0x....      BL       mbedtls_mpi_free
   1503              return ret;
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0xE8BD 0x83FE      POP      {R1-R9,PC}
   1504          }
   1505          
   1506          /*
   1507           * Point doubling R = 2 P, Jacobian coordinates
   1508           *
   1509           * Based on http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2 .
   1510           *
   1511           * We follow the variable naming fairly closely. The formula variations that trade a MUL for a SQR
   1512           * (plus a few ADDs) aren't useful as our bignum implementation doesn't distinguish squaring.
   1513           *
   1514           * Standard optimizations are applied when curve parameter A is one of { 0, -3 }.
   1515           *
   1516           * Cost: 1D := 3M + 4S          (A ==  0)
   1517           *             4M + 4S          (A == -3)
   1518           *             3M + 6S + 1a     otherwise
   1519           */

   \                                 In section .text, align 2, keep-with-next
   1520          static int ecp_double_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   1521                                    const mbedtls_ecp_point *P,
   1522                                    mbedtls_mpi tmp[4])
   1523          {
   \                     ecp_double_jac: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1524          #if defined(MBEDTLS_SELF_TEST)
   1525              dbl_count++;
   1526          #endif
   1527          
   1528          #if defined(MBEDTLS_ECP_DOUBLE_JAC_ALT)
   1529              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1530                  return mbedtls_internal_ecp_double_jac(grp, R, P);
   1531              }
   1532          #endif /* MBEDTLS_ECP_DOUBLE_JAC_ALT */
   1533          
   1534          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_DOUBLE_JAC_ALT)
   1535              (void)tmp;
   1536              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1537          #else
   1538              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x096D      MVNS     R9,#+109
   1539          
   1540              /* Special case for A = -3 */
   1541              if (mbedtls_ecp_group_a_is_minus_3(grp)) {
   \       0x10   0x4640             MOV      R0,R8
   \       0x12   0x.... 0x....      BL       mbedtls_ecp_group_a_is_minus_3
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD03D             BEQ.N    ??ecp_double_jac_0
   1542                  /* tmp[0] <- M = 3(X + Z^2)(X - Z^2) */
   1543                  MPI_ECP_SQR(&tmp[1],  &P->Z);
   \       0x1A   0xF115 0x0310      ADDS     R3,R5,#+16
   \       0x1E   0xF115 0x0210      ADDS     R2,R5,#+16
   \       0x22   0xF116 0x0108      ADDS     R1,R6,#+8
   \       0x26   0x4640             MOV      R0,R8
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x2C   0x0007             MOVS     R7,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xF040 0x8136      BNE.W    ??ecp_double_jac_1
   1544                  MPI_ECP_ADD(&tmp[2],  &P->X,  &tmp[1]);
   \                     ??ecp_double_jac_2: (+1)
   \       0x34   0xF116 0x0308      ADDS     R3,R6,#+8
   \       0x38   0x002A             MOVS     R2,R5
   \       0x3A   0xF116 0x0110      ADDS     R1,R6,#+16
   \       0x3E   0x4640             MOV      R0,R8
   \       0x40   0x.... 0x....      BL       mbedtls_mpi_add_mod
   \       0x44   0x0007             MOVS     R7,R0
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xF040 0x812A      BNE.W    ??ecp_double_jac_1
   1545                  MPI_ECP_SUB(&tmp[3],  &P->X,  &tmp[1]);
   \                     ??ecp_double_jac_3: (+1)
   \       0x4C   0xF116 0x0308      ADDS     R3,R6,#+8
   \       0x50   0x002A             MOVS     R2,R5
   \       0x52   0xF116 0x0118      ADDS     R1,R6,#+24
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \       0x5C   0x0007             MOVS     R7,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xF040 0x811E      BNE.W    ??ecp_double_jac_1
   1546                  MPI_ECP_MUL(&tmp[1],  &tmp[2],     &tmp[3]);
   \                     ??ecp_double_jac_4: (+1)
   \       0x64   0xF116 0x0318      ADDS     R3,R6,#+24
   \       0x68   0xF116 0x0210      ADDS     R2,R6,#+16
   \       0x6C   0xF116 0x0108      ADDS     R1,R6,#+8
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x76   0x0007             MOVS     R7,R0
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xF040 0x8111      BNE.W    ??ecp_double_jac_1
   1547                  MPI_ECP_MUL_INT(&tmp[0],  &tmp[1],     3);
   \                     ??ecp_double_jac_5: (+1)
   \       0x7E   0x2303             MOVS     R3,#+3
   \       0x80   0xF116 0x0208      ADDS     R2,R6,#+8
   \       0x84   0x0031             MOVS     R1,R6
   \       0x86   0x4640             MOV      R0,R8
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_mul_int_mod
   \       0x8C   0x0007             MOVS     R7,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xF040 0x8106      BNE.W    ??ecp_double_jac_1
   \                     ??ecp_double_jac_6: (+1)
   \       0x94   0xE04E             B.N      ??ecp_double_jac_7
   1548              } else {
   1549                  /* tmp[0] <- M = 3.X^2 + A.Z^4 */
   1550                  MPI_ECP_SQR(&tmp[1],  &P->X);
   \                     ??ecp_double_jac_0: (+1)
   \       0x96   0x002B             MOVS     R3,R5
   \       0x98   0x002A             MOVS     R2,R5
   \       0x9A   0xF116 0x0108      ADDS     R1,R6,#+8
   \       0x9E   0x4640             MOV      R0,R8
   \       0xA0   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0xA4   0x0007             MOVS     R7,R0
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xF040 0x80FA      BNE.W    ??ecp_double_jac_1
   1551                  MPI_ECP_MUL_INT(&tmp[0],  &tmp[1],  3);
   \                     ??ecp_double_jac_8: (+1)
   \       0xAC   0x2303             MOVS     R3,#+3
   \       0xAE   0xF116 0x0208      ADDS     R2,R6,#+8
   \       0xB2   0x0031             MOVS     R1,R6
   \       0xB4   0x4640             MOV      R0,R8
   \       0xB6   0x.... 0x....      BL       mbedtls_mpi_mul_int_mod
   \       0xBA   0x0007             MOVS     R7,R0
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xF040 0x80EF      BNE.W    ??ecp_double_jac_1
   1552          
   1553                  /* Optimize away for "koblitz" curves with A = 0 */
   1554                  if (MPI_ECP_CMP_INT(&grp->A, 0) != 0) {
   \                     ??ecp_double_jac_9: (+1)
   \       0xC2   0x2100             MOVS     R1,#+0
   \       0xC4   0xF118 0x000C      ADDS     R0,R8,#+12
   \       0xC8   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD031             BEQ.N    ??ecp_double_jac_7
   1555                      /* M += A.Z^4 */
   1556                      MPI_ECP_SQR(&tmp[1],  &P->Z);
   \       0xD0   0xF115 0x0310      ADDS     R3,R5,#+16
   \       0xD4   0xF115 0x0210      ADDS     R2,R5,#+16
   \       0xD8   0xF116 0x0108      ADDS     R1,R6,#+8
   \       0xDC   0x4640             MOV      R0,R8
   \       0xDE   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0xE2   0x0007             MOVS     R7,R0
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xF040 0x80DB      BNE.W    ??ecp_double_jac_1
   1557                      MPI_ECP_SQR(&tmp[2],  &tmp[1]);
   \                     ??ecp_double_jac_10: (+1)
   \       0xEA   0xF116 0x0308      ADDS     R3,R6,#+8
   \       0xEE   0xF116 0x0208      ADDS     R2,R6,#+8
   \       0xF2   0xF116 0x0110      ADDS     R1,R6,#+16
   \       0xF6   0x4640             MOV      R0,R8
   \       0xF8   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0xFC   0x0007             MOVS     R7,R0
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xF040 0x80CE      BNE.W    ??ecp_double_jac_1
   1558                      MPI_ECP_MUL(&tmp[1],  &tmp[2],     &grp->A);
   \                     ??ecp_double_jac_11: (+1)
   \      0x104   0xF118 0x030C      ADDS     R3,R8,#+12
   \      0x108   0xF116 0x0210      ADDS     R2,R6,#+16
   \      0x10C   0xF116 0x0108      ADDS     R1,R6,#+8
   \      0x110   0x4640             MOV      R0,R8
   \      0x112   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x116   0x0007             MOVS     R7,R0
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xF040 0x80C1      BNE.W    ??ecp_double_jac_1
   1559                      MPI_ECP_ADD(&tmp[0],  &tmp[0],     &tmp[1]);
   \                     ??ecp_double_jac_12: (+1)
   \      0x11E   0xF116 0x0308      ADDS     R3,R6,#+8
   \      0x122   0x0032             MOVS     R2,R6
   \      0x124   0x0031             MOVS     R1,R6
   \      0x126   0x4640             MOV      R0,R8
   \      0x128   0x.... 0x....      BL       mbedtls_mpi_add_mod
   \      0x12C   0x0007             MOVS     R7,R0
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xF040 0x80B6      BNE.W    ??ecp_double_jac_1
   1560                  }
   1561              }
   1562          
   1563              /* tmp[1] <- S = 4.X.Y^2 */
   1564              MPI_ECP_SQR(&tmp[2],  &P->Y);
   \                     ??ecp_double_jac_13: (+1)
   \                     ??ecp_double_jac_7: (+1)
   \      0x134   0xF115 0x0308      ADDS     R3,R5,#+8
   \      0x138   0xF115 0x0208      ADDS     R2,R5,#+8
   \      0x13C   0xF116 0x0110      ADDS     R1,R6,#+16
   \      0x140   0x4640             MOV      R0,R8
   \      0x142   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x146   0x0007             MOVS     R7,R0
   \      0x148   0x2800             CMP      R0,#+0
   \      0x14A   0xF040 0x80A9      BNE.W    ??ecp_double_jac_1
   1565              MPI_ECP_SHIFT_L(&tmp[2],  1);
   \                     ??ecp_double_jac_14: (+1)
   \      0x14E   0x2201             MOVS     R2,#+1
   \      0x150   0xF116 0x0110      ADDS     R1,R6,#+16
   \      0x154   0x4640             MOV      R0,R8
   \      0x156   0x.... 0x....      BL       mbedtls_mpi_shift_l_mod
   \      0x15A   0x0007             MOVS     R7,R0
   \      0x15C   0x2800             CMP      R0,#+0
   \      0x15E   0xF040 0x809F      BNE.W    ??ecp_double_jac_1
   1566              MPI_ECP_MUL(&tmp[1],  &P->X, &tmp[2]);
   \                     ??ecp_double_jac_15: (+1)
   \      0x162   0xF116 0x0310      ADDS     R3,R6,#+16
   \      0x166   0x002A             MOVS     R2,R5
   \      0x168   0xF116 0x0108      ADDS     R1,R6,#+8
   \      0x16C   0x4640             MOV      R0,R8
   \      0x16E   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x172   0x0007             MOVS     R7,R0
   \      0x174   0x2800             CMP      R0,#+0
   \      0x176   0xF040 0x8093      BNE.W    ??ecp_double_jac_1
   1567              MPI_ECP_SHIFT_L(&tmp[1],  1);
   \                     ??ecp_double_jac_16: (+1)
   \      0x17A   0x2201             MOVS     R2,#+1
   \      0x17C   0xF116 0x0108      ADDS     R1,R6,#+8
   \      0x180   0x4640             MOV      R0,R8
   \      0x182   0x.... 0x....      BL       mbedtls_mpi_shift_l_mod
   \      0x186   0x0007             MOVS     R7,R0
   \      0x188   0x2800             CMP      R0,#+0
   \      0x18A   0xF040 0x8089      BNE.W    ??ecp_double_jac_1
   1568          
   1569              /* tmp[3] <- U = 8.Y^4 */
   1570              MPI_ECP_SQR(&tmp[3],  &tmp[2]);
   \                     ??ecp_double_jac_17: (+1)
   \      0x18E   0xF116 0x0310      ADDS     R3,R6,#+16
   \      0x192   0xF116 0x0210      ADDS     R2,R6,#+16
   \      0x196   0xF116 0x0118      ADDS     R1,R6,#+24
   \      0x19A   0x4640             MOV      R0,R8
   \      0x19C   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x1A0   0x0007             MOVS     R7,R0
   \      0x1A2   0x2800             CMP      R0,#+0
   \      0x1A4   0xD17C             BNE.N    ??ecp_double_jac_1
   1571              MPI_ECP_SHIFT_L(&tmp[3],  1);
   \                     ??ecp_double_jac_18: (+1)
   \      0x1A6   0x2201             MOVS     R2,#+1
   \      0x1A8   0xF116 0x0118      ADDS     R1,R6,#+24
   \      0x1AC   0x4640             MOV      R0,R8
   \      0x1AE   0x.... 0x....      BL       mbedtls_mpi_shift_l_mod
   \      0x1B2   0x0007             MOVS     R7,R0
   \      0x1B4   0x2800             CMP      R0,#+0
   \      0x1B6   0xD173             BNE.N    ??ecp_double_jac_1
   1572          
   1573              /* tmp[2] <- T = M^2 - 2.S */
   1574              MPI_ECP_SQR(&tmp[2],  &tmp[0]);
   \                     ??ecp_double_jac_19: (+1)
   \      0x1B8   0x0033             MOVS     R3,R6
   \      0x1BA   0x0032             MOVS     R2,R6
   \      0x1BC   0xF116 0x0110      ADDS     R1,R6,#+16
   \      0x1C0   0x4640             MOV      R0,R8
   \      0x1C2   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x1C6   0x0007             MOVS     R7,R0
   \      0x1C8   0x2800             CMP      R0,#+0
   \      0x1CA   0xD169             BNE.N    ??ecp_double_jac_1
   1575              MPI_ECP_SUB(&tmp[2],  &tmp[2], &tmp[1]);
   \                     ??ecp_double_jac_20: (+1)
   \      0x1CC   0xF116 0x0308      ADDS     R3,R6,#+8
   \      0x1D0   0xF116 0x0210      ADDS     R2,R6,#+16
   \      0x1D4   0xF116 0x0110      ADDS     R1,R6,#+16
   \      0x1D8   0x4640             MOV      R0,R8
   \      0x1DA   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \      0x1DE   0x0007             MOVS     R7,R0
   \      0x1E0   0x2800             CMP      R0,#+0
   \      0x1E2   0xD15D             BNE.N    ??ecp_double_jac_1
   1576              MPI_ECP_SUB(&tmp[2],  &tmp[2], &tmp[1]);
   \                     ??ecp_double_jac_21: (+1)
   \      0x1E4   0xF116 0x0308      ADDS     R3,R6,#+8
   \      0x1E8   0xF116 0x0210      ADDS     R2,R6,#+16
   \      0x1EC   0xF116 0x0110      ADDS     R1,R6,#+16
   \      0x1F0   0x4640             MOV      R0,R8
   \      0x1F2   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \      0x1F6   0x0007             MOVS     R7,R0
   \      0x1F8   0x2800             CMP      R0,#+0
   \      0x1FA   0xD151             BNE.N    ??ecp_double_jac_1
   1577          
   1578              /* tmp[1] <- S = M(S - T) - U */
   1579              MPI_ECP_SUB(&tmp[1],  &tmp[1],     &tmp[2]);
   \                     ??ecp_double_jac_22: (+1)
   \      0x1FC   0xF116 0x0310      ADDS     R3,R6,#+16
   \      0x200   0xF116 0x0208      ADDS     R2,R6,#+8
   \      0x204   0xF116 0x0108      ADDS     R1,R6,#+8
   \      0x208   0x4640             MOV      R0,R8
   \      0x20A   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \      0x20E   0x0007             MOVS     R7,R0
   \      0x210   0x2800             CMP      R0,#+0
   \      0x212   0xD145             BNE.N    ??ecp_double_jac_1
   1580              MPI_ECP_MUL(&tmp[1],  &tmp[1],     &tmp[0]);
   \                     ??ecp_double_jac_23: (+1)
   \      0x214   0x0033             MOVS     R3,R6
   \      0x216   0xF116 0x0208      ADDS     R2,R6,#+8
   \      0x21A   0xF116 0x0108      ADDS     R1,R6,#+8
   \      0x21E   0x4640             MOV      R0,R8
   \      0x220   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x224   0x0007             MOVS     R7,R0
   \      0x226   0x2800             CMP      R0,#+0
   \      0x228   0xD13A             BNE.N    ??ecp_double_jac_1
   1581              MPI_ECP_SUB(&tmp[1],  &tmp[1],     &tmp[3]);
   \                     ??ecp_double_jac_24: (+1)
   \      0x22A   0xF116 0x0318      ADDS     R3,R6,#+24
   \      0x22E   0xF116 0x0208      ADDS     R2,R6,#+8
   \      0x232   0xF116 0x0108      ADDS     R1,R6,#+8
   \      0x236   0x4640             MOV      R0,R8
   \      0x238   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \      0x23C   0x0007             MOVS     R7,R0
   \      0x23E   0x2800             CMP      R0,#+0
   \      0x240   0xD12E             BNE.N    ??ecp_double_jac_1
   1582          
   1583              /* tmp[3] <- U = 2.Y.Z */
   1584              MPI_ECP_MUL(&tmp[3],  &P->Y,  &P->Z);
   \                     ??ecp_double_jac_25: (+1)
   \      0x242   0xF115 0x0310      ADDS     R3,R5,#+16
   \      0x246   0xF115 0x0208      ADDS     R2,R5,#+8
   \      0x24A   0xF116 0x0118      ADDS     R1,R6,#+24
   \      0x24E   0x4640             MOV      R0,R8
   \      0x250   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x254   0x0007             MOVS     R7,R0
   \      0x256   0x2800             CMP      R0,#+0
   \      0x258   0xD122             BNE.N    ??ecp_double_jac_1
   1585              MPI_ECP_SHIFT_L(&tmp[3],  1);
   \                     ??ecp_double_jac_26: (+1)
   \      0x25A   0x2201             MOVS     R2,#+1
   \      0x25C   0xF116 0x0118      ADDS     R1,R6,#+24
   \      0x260   0x4640             MOV      R0,R8
   \      0x262   0x.... 0x....      BL       mbedtls_mpi_shift_l_mod
   \      0x266   0x0007             MOVS     R7,R0
   \      0x268   0x2800             CMP      R0,#+0
   \      0x26A   0xD119             BNE.N    ??ecp_double_jac_1
   1586          
   1587              /* Store results */
   1588              MPI_ECP_MOV(&R->X, &tmp[2]);
   \                     ??ecp_double_jac_27: (+1)
   \      0x26C   0xF116 0x0110      ADDS     R1,R6,#+16
   \      0x270   0x0020             MOVS     R0,R4
   \      0x272   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x276   0x0007             MOVS     R7,R0
   \      0x278   0x2800             CMP      R0,#+0
   \      0x27A   0xD111             BNE.N    ??ecp_double_jac_1
   1589              MPI_ECP_MOV(&R->Y, &tmp[1]);
   \                     ??ecp_double_jac_28: (+1)
   \      0x27C   0xF116 0x0108      ADDS     R1,R6,#+8
   \      0x280   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0x284   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x288   0x0007             MOVS     R7,R0
   \      0x28A   0x2800             CMP      R0,#+0
   \      0x28C   0xD108             BNE.N    ??ecp_double_jac_1
   1590              MPI_ECP_MOV(&R->Z, &tmp[3]);
   \                     ??ecp_double_jac_29: (+1)
   \      0x28E   0xF116 0x0118      ADDS     R1,R6,#+24
   \      0x292   0xF114 0x0010      ADDS     R0,R4,#+16
   \      0x296   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x29A   0x0007             MOVS     R7,R0
   \      0x29C   0x2800             CMP      R0,#+0
   \      0x29E   0xD1FF             BNE.N    ??ecp_double_jac_1
   1591          
   1592          cleanup:
   1593          
   1594              return ret;
   \                     ??ecp_double_jac_30: (+1)
   \                     ??ecp_double_jac_1: (+1)
   \      0x2A0   0x0038             MOVS     R0,R7
   \      0x2A2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1595          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_DOUBLE_JAC_ALT) */
   1596          }
   1597          
   1598          /*
   1599           * Addition: R = P + Q, mixed affine-Jacobian coordinates (GECC 3.22)
   1600           *
   1601           * The coordinates of Q must be normalized (= affine),
   1602           * but those of P don't need to. R is not normalized.
   1603           *
   1604           * P,Q,R may alias, but only at the level of EC points: they must be either
   1605           * equal as pointers, or disjoint (including the coordinate data buffers).
   1606           * Fine-grained aliasing at the level of coordinates is not supported.
   1607           *
   1608           * Special cases: (1) P or Q is zero, (2) R is zero, (3) P == Q.
   1609           * None of these cases can happen as intermediate step in ecp_mul_comb():
   1610           * - at each step, P, Q and R are multiples of the base point, the factor
   1611           *   being less than its order, so none of them is zero;
   1612           * - Q is an odd multiple of the base point, P an even multiple,
   1613           *   due to the choice of precomputed points in the modified comb method.
   1614           * So branches for these cases do not leak secret information.
   1615           *
   1616           * Cost: 1A := 8M + 3S
   1617           */

   \                                 In section .text, align 2, keep-with-next
   1618          static int ecp_add_mixed(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   1619                                   const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q,
   1620                                   mbedtls_mpi tmp[4])
   1621          {
   \                     ecp_add_mixed: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0C             LDR      R7,[SP, #+48]
   1622          #if defined(MBEDTLS_SELF_TEST)
   1623              add_count++;
   1624          #endif
   1625          
   1626          #if defined(MBEDTLS_ECP_ADD_MIXED_ALT)
   1627              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1628                  return mbedtls_internal_ecp_add_mixed(grp, R, P, Q);
   1629              }
   1630          #endif /* MBEDTLS_ECP_ADD_MIXED_ALT */
   1631          
   1632          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_ADD_MIXED_ALT)
   1633              (void)tmp;
   1634              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1635          #else
   1636              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x086D      MVNS     R8,#+109
   1637          
   1638              /* NOTE: Aliasing between input and output is allowed, so one has to make
   1639               *       sure that at the point X,Y,Z are written, {P,Q}->{X,Y,Z} are no
   1640               *       longer read from. */
   1641              mbedtls_mpi * const X = &R->X;
   \       0x12   0x46A1             MOV      R9,R4
   1642              mbedtls_mpi * const Y = &R->Y;
   \       0x14   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x18   0x9001             STR      R0,[SP, #+4]
   1643              mbedtls_mpi * const Z = &R->Z;
   \       0x1A   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   1644          
   1645              if (!MPI_ECP_VALID(&Q->Z)) {
   \       0x20   0x6930             LDR      R0,[R6, #+16]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD102             BNE.N    ??ecp_add_mixed_0
   1646                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0x2A   0xE108             B.N      ??ecp_add_mixed_1
   1647              }
   1648          
   1649              /*
   1650               * Trivial cases: P == 0 or Q == 0 (case 1)
   1651               */
   1652              if (MPI_ECP_CMP_INT(&P->Z, 0) == 0) {
   \                     ??ecp_add_mixed_0: (+1)
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0xF115 0x0010      ADDS     R0,R5,#+16
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD104             BNE.N    ??ecp_add_mixed_2
   1653                  return mbedtls_ecp_copy(R, Q);
   \       0x3A   0x0031             MOVS     R1,R6
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x42   0xE0FC             B.N      ??ecp_add_mixed_1
   1654              }
   1655          
   1656              if (MPI_ECP_CMP_INT(&Q->Z, 0) == 0) {
   \                     ??ecp_add_mixed_2: (+1)
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0xF116 0x0010      ADDS     R0,R6,#+16
   \       0x4A   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD104             BNE.N    ??ecp_add_mixed_3
   1657                  return mbedtls_ecp_copy(R, P);
   \       0x52   0x0029             MOVS     R1,R5
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x5A   0xE0F0             B.N      ??ecp_add_mixed_1
   1658              }
   1659          
   1660              /*
   1661               * Make sure Q coordinates are normalized
   1662               */
   1663              if (MPI_ECP_CMP_INT(&Q->Z, 1) != 0) {
   \                     ??ecp_add_mixed_3: (+1)
   \       0x5C   0x2101             MOVS     R1,#+1
   \       0x5E   0xF116 0x0010      ADDS     R0,R6,#+16
   \       0x62   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD002             BEQ.N    ??ecp_add_mixed_4
   1664                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0x6E   0xE0E6             B.N      ??ecp_add_mixed_1
   1665              }
   1666          
   1667              MPI_ECP_SQR(&tmp[0], &P->Z);
   \                     ??ecp_add_mixed_4: (+1)
   \       0x70   0xF115 0x0310      ADDS     R3,R5,#+16
   \       0x74   0xF115 0x0210      ADDS     R2,R5,#+16
   \       0x78   0x0039             MOVS     R1,R7
   \       0x7A   0x4658             MOV      R0,R11
   \       0x7C   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x80   0x4682             MOV      R10,R0
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xF040 0x80DA      BNE.W    ??ecp_add_mixed_5
   1668              MPI_ECP_MUL(&tmp[1], &tmp[0], &P->Z);
   \                     ??ecp_add_mixed_6: (+1)
   \       0x88   0xF115 0x0310      ADDS     R3,R5,#+16
   \       0x8C   0x003A             MOVS     R2,R7
   \       0x8E   0xF117 0x0108      ADDS     R1,R7,#+8
   \       0x92   0x4658             MOV      R0,R11
   \       0x94   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x98   0x4682             MOV      R10,R0
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xF040 0x80CE      BNE.W    ??ecp_add_mixed_5
   1669              MPI_ECP_MUL(&tmp[0], &tmp[0], &Q->X);
   \                     ??ecp_add_mixed_7: (+1)
   \       0xA0   0x0033             MOVS     R3,R6
   \       0xA2   0x003A             MOVS     R2,R7
   \       0xA4   0x0039             MOVS     R1,R7
   \       0xA6   0x4658             MOV      R0,R11
   \       0xA8   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0xAC   0x4682             MOV      R10,R0
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xF040 0x80C4      BNE.W    ??ecp_add_mixed_5
   1670              MPI_ECP_MUL(&tmp[1], &tmp[1], &Q->Y);
   \                     ??ecp_add_mixed_8: (+1)
   \       0xB4   0xF116 0x0308      ADDS     R3,R6,#+8
   \       0xB8   0xF117 0x0208      ADDS     R2,R7,#+8
   \       0xBC   0xF117 0x0108      ADDS     R1,R7,#+8
   \       0xC0   0x4658             MOV      R0,R11
   \       0xC2   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0xC6   0x4682             MOV      R10,R0
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xF040 0x80B7      BNE.W    ??ecp_add_mixed_5
   1671              MPI_ECP_SUB(&tmp[0], &tmp[0], &P->X);
   \                     ??ecp_add_mixed_9: (+1)
   \       0xCE   0x002B             MOVS     R3,R5
   \       0xD0   0x003A             MOVS     R2,R7
   \       0xD2   0x0039             MOVS     R1,R7
   \       0xD4   0x4658             MOV      R0,R11
   \       0xD6   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \       0xDA   0x4682             MOV      R10,R0
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xF040 0x80AD      BNE.W    ??ecp_add_mixed_5
   1672              MPI_ECP_SUB(&tmp[1], &tmp[1], &P->Y);
   \                     ??ecp_add_mixed_10: (+1)
   \       0xE2   0xF115 0x0308      ADDS     R3,R5,#+8
   \       0xE6   0xF117 0x0208      ADDS     R2,R7,#+8
   \       0xEA   0xF117 0x0108      ADDS     R1,R7,#+8
   \       0xEE   0x4658             MOV      R0,R11
   \       0xF0   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \       0xF4   0x4682             MOV      R10,R0
   \       0xF6   0x2800             CMP      R0,#+0
   \       0xF8   0xF040 0x80A0      BNE.W    ??ecp_add_mixed_5
   1673          
   1674              /* Special cases (2) and (3) */
   1675              if (MPI_ECP_CMP_INT(&tmp[0], 0) == 0) {
   \                     ??ecp_add_mixed_11: (+1)
   \       0xFC   0x2100             MOVS     R1,#+0
   \       0xFE   0x0038             MOVS     R0,R7
   \      0x100   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD113             BNE.N    ??ecp_add_mixed_12
   1676                  if (MPI_ECP_CMP_INT(&tmp[1], 0) == 0) {
   \      0x108   0x2100             MOVS     R1,#+0
   \      0x10A   0xF117 0x0008      ADDS     R0,R7,#+8
   \      0x10E   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xD107             BNE.N    ??ecp_add_mixed_13
   1677                      ret = ecp_double_jac(grp, R, P, tmp);
   \      0x116   0x003B             MOVS     R3,R7
   \      0x118   0x002A             MOVS     R2,R5
   \      0x11A   0x0021             MOVS     R1,R4
   \      0x11C   0x4658             MOV      R0,R11
   \      0x11E   0x.... 0x....      BL       ecp_double_jac
   \      0x122   0x4682             MOV      R10,R0
   1678                      goto cleanup;
   \      0x124   0xE08A             B.N      ??ecp_add_mixed_5
   1679                  } else {
   1680                      ret = mbedtls_ecp_set_zero(R);
   \                     ??ecp_add_mixed_13: (+1)
   \      0x126   0x0020             MOVS     R0,R4
   \      0x128   0x.... 0x....      BL       mbedtls_ecp_set_zero
   \      0x12C   0x4682             MOV      R10,R0
   1681                      goto cleanup;
   \      0x12E   0xE085             B.N      ??ecp_add_mixed_5
   1682                  }
   1683              }
   1684          
   1685              /* {P,Q}->Z no longer used, so OK to write to Z even if there's aliasing. */
   1686              MPI_ECP_MUL(Z,        &P->Z,    &tmp[0]);
   \                     ??ecp_add_mixed_12: (+1)
   \      0x130   0x003B             MOVS     R3,R7
   \      0x132   0xF115 0x0210      ADDS     R2,R5,#+16
   \      0x136   0x9900             LDR      R1,[SP, #+0]
   \      0x138   0x4658             MOV      R0,R11
   \      0x13A   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x13E   0x4682             MOV      R10,R0
   \      0x140   0x2800             CMP      R0,#+0
   \      0x142   0xD17B             BNE.N    ??ecp_add_mixed_5
   1687              MPI_ECP_SQR(&tmp[2],  &tmp[0]);
   \                     ??ecp_add_mixed_14: (+1)
   \      0x144   0x003B             MOVS     R3,R7
   \      0x146   0x003A             MOVS     R2,R7
   \      0x148   0xF117 0x0110      ADDS     R1,R7,#+16
   \      0x14C   0x4658             MOV      R0,R11
   \      0x14E   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x152   0x4682             MOV      R10,R0
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD171             BNE.N    ??ecp_add_mixed_5
   1688              MPI_ECP_MUL(&tmp[3],  &tmp[2],  &tmp[0]);
   \                     ??ecp_add_mixed_15: (+1)
   \      0x158   0x003B             MOVS     R3,R7
   \      0x15A   0xF117 0x0210      ADDS     R2,R7,#+16
   \      0x15E   0xF117 0x0118      ADDS     R1,R7,#+24
   \      0x162   0x4658             MOV      R0,R11
   \      0x164   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x168   0x4682             MOV      R10,R0
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD166             BNE.N    ??ecp_add_mixed_5
   1689              MPI_ECP_MUL(&tmp[2],  &tmp[2],  &P->X);
   \                     ??ecp_add_mixed_16: (+1)
   \      0x16E   0x002B             MOVS     R3,R5
   \      0x170   0xF117 0x0210      ADDS     R2,R7,#+16
   \      0x174   0xF117 0x0110      ADDS     R1,R7,#+16
   \      0x178   0x4658             MOV      R0,R11
   \      0x17A   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x17E   0x4682             MOV      R10,R0
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xD15B             BNE.N    ??ecp_add_mixed_5
   1690          
   1691              MPI_ECP_MOV(&tmp[0], &tmp[2]);
   \                     ??ecp_add_mixed_17: (+1)
   \      0x184   0xF117 0x0110      ADDS     R1,R7,#+16
   \      0x188   0x0038             MOVS     R0,R7
   \      0x18A   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x18E   0x4682             MOV      R10,R0
   \      0x190   0x2800             CMP      R0,#+0
   \      0x192   0xD153             BNE.N    ??ecp_add_mixed_5
   1692              MPI_ECP_SHIFT_L(&tmp[0], 1);
   \                     ??ecp_add_mixed_18: (+1)
   \      0x194   0x2201             MOVS     R2,#+1
   \      0x196   0x0039             MOVS     R1,R7
   \      0x198   0x4658             MOV      R0,R11
   \      0x19A   0x.... 0x....      BL       mbedtls_mpi_shift_l_mod
   \      0x19E   0x4682             MOV      R10,R0
   \      0x1A0   0x2800             CMP      R0,#+0
   \      0x1A2   0xD14B             BNE.N    ??ecp_add_mixed_5
   1693          
   1694              /* {P,Q}->X no longer used, so OK to write to X even if there's aliasing. */
   1695              MPI_ECP_SQR(X,        &tmp[1]);
   \                     ??ecp_add_mixed_19: (+1)
   \      0x1A4   0xF117 0x0308      ADDS     R3,R7,#+8
   \      0x1A8   0xF117 0x0208      ADDS     R2,R7,#+8
   \      0x1AC   0x4649             MOV      R1,R9
   \      0x1AE   0x4658             MOV      R0,R11
   \      0x1B0   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x1B4   0x4682             MOV      R10,R0
   \      0x1B6   0x2800             CMP      R0,#+0
   \      0x1B8   0xD140             BNE.N    ??ecp_add_mixed_5
   1696              MPI_ECP_SUB(X,        X,        &tmp[0]);
   \                     ??ecp_add_mixed_20: (+1)
   \      0x1BA   0x003B             MOVS     R3,R7
   \      0x1BC   0x464A             MOV      R2,R9
   \      0x1BE   0x4649             MOV      R1,R9
   \      0x1C0   0x4658             MOV      R0,R11
   \      0x1C2   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \      0x1C6   0x4682             MOV      R10,R0
   \      0x1C8   0x2800             CMP      R0,#+0
   \      0x1CA   0xD137             BNE.N    ??ecp_add_mixed_5
   1697              MPI_ECP_SUB(X,        X,        &tmp[3]);
   \                     ??ecp_add_mixed_21: (+1)
   \      0x1CC   0xF117 0x0318      ADDS     R3,R7,#+24
   \      0x1D0   0x464A             MOV      R2,R9
   \      0x1D2   0x4649             MOV      R1,R9
   \      0x1D4   0x4658             MOV      R0,R11
   \      0x1D6   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \      0x1DA   0x4682             MOV      R10,R0
   \      0x1DC   0x2800             CMP      R0,#+0
   \      0x1DE   0xD12D             BNE.N    ??ecp_add_mixed_5
   1698              MPI_ECP_SUB(&tmp[2],  &tmp[2],  X);
   \                     ??ecp_add_mixed_22: (+1)
   \      0x1E0   0x464B             MOV      R3,R9
   \      0x1E2   0xF117 0x0210      ADDS     R2,R7,#+16
   \      0x1E6   0xF117 0x0110      ADDS     R1,R7,#+16
   \      0x1EA   0x4658             MOV      R0,R11
   \      0x1EC   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \      0x1F0   0x4682             MOV      R10,R0
   \      0x1F2   0x2800             CMP      R0,#+0
   \      0x1F4   0xD122             BNE.N    ??ecp_add_mixed_5
   1699              MPI_ECP_MUL(&tmp[2],  &tmp[2],  &tmp[1]);
   \                     ??ecp_add_mixed_23: (+1)
   \      0x1F6   0xF117 0x0308      ADDS     R3,R7,#+8
   \      0x1FA   0xF117 0x0210      ADDS     R2,R7,#+16
   \      0x1FE   0xF117 0x0110      ADDS     R1,R7,#+16
   \      0x202   0x4658             MOV      R0,R11
   \      0x204   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x208   0x4682             MOV      R10,R0
   \      0x20A   0x2800             CMP      R0,#+0
   \      0x20C   0xD116             BNE.N    ??ecp_add_mixed_5
   1700              MPI_ECP_MUL(&tmp[3],  &tmp[3],  &P->Y);
   \                     ??ecp_add_mixed_24: (+1)
   \      0x20E   0xF115 0x0308      ADDS     R3,R5,#+8
   \      0x212   0xF117 0x0218      ADDS     R2,R7,#+24
   \      0x216   0xF117 0x0118      ADDS     R1,R7,#+24
   \      0x21A   0x4658             MOV      R0,R11
   \      0x21C   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \      0x220   0x4682             MOV      R10,R0
   \      0x222   0x2800             CMP      R0,#+0
   \      0x224   0xD10A             BNE.N    ??ecp_add_mixed_5
   1701              /* {P,Q}->Y no longer used, so OK to write to Y even if there's aliasing. */
   1702              MPI_ECP_SUB(Y,     &tmp[2],     &tmp[3]);
   \                     ??ecp_add_mixed_25: (+1)
   \      0x226   0xF117 0x0318      ADDS     R3,R7,#+24
   \      0x22A   0xF117 0x0210      ADDS     R2,R7,#+16
   \      0x22E   0x9901             LDR      R1,[SP, #+4]
   \      0x230   0x4658             MOV      R0,R11
   \      0x232   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \      0x236   0x4682             MOV      R10,R0
   \      0x238   0x2800             CMP      R0,#+0
   \      0x23A   0xD1FF             BNE.N    ??ecp_add_mixed_5
   1703          
   1704          cleanup:
   1705          
   1706              return ret;
   \                     ??ecp_add_mixed_26: (+1)
   \                     ??ecp_add_mixed_5: (+1)
   \      0x23C   0x4650             MOV      R0,R10
   \                     ??ecp_add_mixed_1: (+1)
   \      0x23E   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1707          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_ADD_MIXED_ALT) */
   1708          }
   1709          
   1710          /*
   1711           * Randomize jacobian coordinates:
   1712           * (X, Y, Z) -> (l^2 X, l^3 Y, l Z) for random l
   1713           * This is sort of the reverse operation of ecp_normalize_jac().
   1714           *
   1715           * This countermeasure was first suggested in [2].
   1716           */

   \                                 In section .text, align 2, keep-with-next
   1717          static int ecp_randomize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt,
   1718                                       int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1719          {
   \                     ecp_randomize_jac: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1720          #if defined(MBEDTLS_ECP_RANDOMIZE_JAC_ALT)
   1721              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1722                  return mbedtls_internal_ecp_randomize_jac(grp, pt, f_rng, p_rng);
   1723              }
   1724          #endif /* MBEDTLS_ECP_RANDOMIZE_JAC_ALT */
   1725          
   1726          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_RANDOMIZE_JAC_ALT)
   1727              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1728          #else
   1729              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x096D      MVNS     R9,#+109
   1730              mbedtls_mpi l;
   1731          
   1732              mbedtls_mpi_init(&l);
   \       0x10   0xA801             ADD      R0,SP,#+4
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_init
   1733          
   1734              /* Generate l such that 1 < l < p */
   1735              MPI_ECP_RAND(&l);
   \       0x16   0x9600             STR      R6,[SP, #+0]
   \       0x18   0x002B             MOVS     R3,R5
   \       0x1A   0xF118 0x0204      ADDS     R2,R8,#+4
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0xA801             ADD      R0,SP,#+4
   \       0x22   0x.... 0x....      BL       mbedtls_mpi_random
   \       0x26   0x0007             MOVS     R7,R0
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD132             BNE.N    ??ecp_randomize_jac_0
   1736          
   1737              /* Z' = l * Z */
   1738              MPI_ECP_MUL(&pt->Z,   &pt->Z,     &l);
   \                     ??ecp_randomize_jac_1: (+1)
   \       0x2C   0xAB01             ADD      R3,SP,#+4
   \       0x2E   0xF114 0x0210      ADDS     R2,R4,#+16
   \       0x32   0xF114 0x0110      ADDS     R1,R4,#+16
   \       0x36   0x4640             MOV      R0,R8
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x3C   0x0007             MOVS     R7,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD127             BNE.N    ??ecp_randomize_jac_0
   1739          
   1740              /* Y' = l * Y */
   1741              MPI_ECP_MUL(&pt->Y,   &pt->Y,     &l);
   \                     ??ecp_randomize_jac_2: (+1)
   \       0x42   0xAB01             ADD      R3,SP,#+4
   \       0x44   0xF114 0x0208      ADDS     R2,R4,#+8
   \       0x48   0xF114 0x0108      ADDS     R1,R4,#+8
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x52   0x0007             MOVS     R7,R0
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD11C             BNE.N    ??ecp_randomize_jac_0
   1742          
   1743              /* X' = l^2 * X */
   1744              MPI_ECP_SQR(&l,       &l);
   \                     ??ecp_randomize_jac_3: (+1)
   \       0x58   0xAB01             ADD      R3,SP,#+4
   \       0x5A   0xAA01             ADD      R2,SP,#+4
   \       0x5C   0xA901             ADD      R1,SP,#+4
   \       0x5E   0x4640             MOV      R0,R8
   \       0x60   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x64   0x0007             MOVS     R7,R0
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD113             BNE.N    ??ecp_randomize_jac_0
   1745              MPI_ECP_MUL(&pt->X,   &pt->X,     &l);
   \                     ??ecp_randomize_jac_4: (+1)
   \       0x6A   0xAB01             ADD      R3,SP,#+4
   \       0x6C   0x0022             MOVS     R2,R4
   \       0x6E   0x0021             MOVS     R1,R4
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x76   0x0007             MOVS     R7,R0
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD10A             BNE.N    ??ecp_randomize_jac_0
   1746          
   1747              /* Y'' = l^2 * Y' = l^3 * Y */
   1748              MPI_ECP_MUL(&pt->Y,   &pt->Y,     &l);
   \                     ??ecp_randomize_jac_5: (+1)
   \       0x7C   0xAB01             ADD      R3,SP,#+4
   \       0x7E   0xF114 0x0208      ADDS     R2,R4,#+8
   \       0x82   0xF114 0x0108      ADDS     R1,R4,#+8
   \       0x86   0x4640             MOV      R0,R8
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x8C   0x0007             MOVS     R7,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD1FF             BNE.N    ??ecp_randomize_jac_0
   1749          
   1750          cleanup:
   1751              mbedtls_mpi_free(&l);
   \                     ??ecp_randomize_jac_6: (+1)
   \                     ??ecp_randomize_jac_0: (+1)
   \       0x92   0xA801             ADD      R0,SP,#+4
   \       0x94   0x.... 0x....      BL       mbedtls_mpi_free
   1752          
   1753              if (ret == MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) {
   \       0x98   0xF117 0x0F0E      CMN      R7,#+14
   \       0x9C   0xD102             BNE.N    ??ecp_randomize_jac_7
   1754                  ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
   \       0x9E   0x.... 0x....      LDR.W    R0,??DataTable26
   \       0xA2   0x0007             MOVS     R7,R0
   1755              }
   1756              return ret;
   \                     ??ecp_randomize_jac_7: (+1)
   \       0xA4   0x0038             MOVS     R0,R7
   \       0xA6   0xE8BD 0x83FE      POP      {R1-R9,PC}
   1757          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_RANDOMIZE_JAC_ALT) */
   1758          }
   1759          
   1760          /*
   1761           * Check and define parameters used by the comb method (see below for details)
   1762           */
   1763          #if MBEDTLS_ECP_WINDOW_SIZE < 2 || MBEDTLS_ECP_WINDOW_SIZE > 7
   1764          #error "MBEDTLS_ECP_WINDOW_SIZE out of bounds"
   1765          #endif
   1766          
   1767          /* d = ceil( n / w ) */
   1768          #define COMB_MAX_D      (MBEDTLS_ECP_MAX_BITS + 1) / 2
   1769          
   1770          /* number of precomputed points */
   1771          #define COMB_MAX_PRE    (1 << (MBEDTLS_ECP_WINDOW_SIZE - 1))
   1772          
   1773          /*
   1774           * Compute the representation of m that will be used with our comb method.
   1775           *
   1776           * The basic comb method is described in GECC 3.44 for example. We use a
   1777           * modified version that provides resistance to SPA by avoiding zero
   1778           * digits in the representation as in [3]. We modify the method further by
   1779           * requiring that all K_i be odd, which has the small cost that our
   1780           * representation uses one more K_i, due to carries, but saves on the size of
   1781           * the precomputed table.
   1782           *
   1783           * Summary of the comb method and its modifications:
   1784           *
   1785           * - The goal is to compute m*P for some w*d-bit integer m.
   1786           *
   1787           * - The basic comb method splits m into the w-bit integers
   1788           *   x[0] .. x[d-1] where x[i] consists of the bits in m whose
   1789           *   index has residue i modulo d, and computes m * P as
   1790           *   S[x[0]] + 2 * S[x[1]] + .. + 2^(d-1) S[x[d-1]], where
   1791           *   S[i_{w-1} .. i_0] := i_{w-1} 2^{(w-1)d} P + ... + i_1 2^d P + i_0 P.
   1792           *
   1793           * - If it happens that, say, x[i+1]=0 (=> S[x[i+1]]=0), one can replace the sum by
   1794           *    .. + 2^{i-1} S[x[i-1]] - 2^i S[x[i]] + 2^{i+1} S[x[i]] + 2^{i+2} S[x[i+2]] ..,
   1795           *   thereby successively converting it into a form where all summands
   1796           *   are nonzero, at the cost of negative summands. This is the basic idea of [3].
   1797           *
   1798           * - More generally, even if x[i+1] != 0, we can first transform the sum as
   1799           *   .. - 2^i S[x[i]] + 2^{i+1} ( S[x[i]] + S[x[i+1]] ) + 2^{i+2} S[x[i+2]] ..,
   1800           *   and then replace S[x[i]] + S[x[i+1]] = S[x[i] ^ x[i+1]] + 2 S[x[i] & x[i+1]].
   1801           *   Performing and iterating this procedure for those x[i] that are even
   1802           *   (keeping track of carry), we can transform the original sum into one of the form
   1803           *   S[x'[0]] +- 2 S[x'[1]] +- .. +- 2^{d-1} S[x'[d-1]] + 2^d S[x'[d]]
   1804           *   with all x'[i] odd. It is therefore only necessary to know S at odd indices,
   1805           *   which is why we are only computing half of it in the first place in
   1806           *   ecp_precompute_comb and accessing it with index abs(i) / 2 in ecp_select_comb.
   1807           *
   1808           * - For the sake of compactness, only the seven low-order bits of x[i]
   1809           *   are used to represent its absolute value (K_i in the paper), and the msb
   1810           *   of x[i] encodes the sign (s_i in the paper): it is set if and only if
   1811           *   if s_i == -1;
   1812           *
   1813           * Calling conventions:
   1814           * - x is an array of size d + 1
   1815           * - w is the size, ie number of teeth, of the comb, and must be between
   1816           *   2 and 7 (in practice, between 2 and MBEDTLS_ECP_WINDOW_SIZE)
   1817           * - m is the MPI, expected to be odd and such that bitlength(m) <= w * d
   1818           *   (the result will be incorrect if these assumptions are not satisfied)
   1819           */

   \                                 In section .text, align 2, keep-with-next
   1820          static void ecp_comb_recode_core(unsigned char x[], size_t d,
   1821                                           unsigned char w, const mbedtls_mpi *m)
   1822          {
   \                     ecp_comb_recode_core: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1823              size_t i, j;
   1824              unsigned char c, cc, adjust;
   1825          
   1826              memset(x, 0, d+1);
   \        0xC   0x1C60             ADDS     R0,R4,#+1
   \        0xE   0x9001             STR      R0,[SP, #+4]
   \       0x10   0xF05F 0x0B00      MOVS     R11,#+0
   \       0x14   0x46CA             MOV      R10,R9
   \       0x16   0x465A             MOV      R2,R11
   \       0x18   0x9901             LDR      R1,[SP, #+4]
   \       0x1A   0x4650             MOV      R0,R10
   \       0x1C   0x.... 0x....      BL       __aeabi_memset
   1827          
   1828              /* First get the classical comb values (except for x_d = 0) */
   1829              for (i = 0; i < d; i++) {
   \       0x20   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??ecp_comb_recode_core_0: (+1)
   \       0x24   0x45A2             CMP      R10,R4
   \       0x26   0xD215             BCS.N    ??ecp_comb_recode_core_1
   1830                  for (j = 0; j < w; j++) {
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x0007             MOVS     R7,R0
   \                     ??ecp_comb_recode_core_2: (+1)
   \       0x2C   0x0028             MOVS     R0,R5
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x4287             CMP      R7,R0
   \       0x32   0xD20C             BCS.N    ??ecp_comb_recode_core_3
   1831                      x[i] |= mbedtls_mpi_get_bit(m, i + d * j) << j;
   \       0x34   0xFB07 0xA104      MLA      R1,R7,R4,R10
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \       0x3E   0xF819 0x100A      LDRB     R1,[R9, R10]
   \       0x42   0x40B8             LSLS     R0,R0,R7
   \       0x44   0x4308             ORRS     R0,R0,R1
   \       0x46   0xF809 0x000A      STRB     R0,[R9, R10]
   1832                  }
   \       0x4A   0x1C7F             ADDS     R7,R7,#+1
   \       0x4C   0xE7EE             B.N      ??ecp_comb_recode_core_2
   1833              }
   \                     ??ecp_comb_recode_core_3: (+1)
   \       0x4E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \       0x52   0xE7E7             B.N      ??ecp_comb_recode_core_0
   1834          
   1835              /* Now make sure x_1 .. x_d are odd */
   1836              c = 0;
   \                     ??ecp_comb_recode_core_1: (+1)
   \       0x54   0x2100             MOVS     R1,#+0
   1837              for (i = 1; i <= d; i++) {
   \       0x56   0x2201             MOVS     R2,#+1
   \                     ??ecp_comb_recode_core_4: (+1)
   \       0x58   0x4294             CMP      R4,R2
   \       0x5A   0xD336             BCC.N    ??ecp_comb_recode_core_5
   1838                  /* Add carry and update it */
   1839                  cc   = x[i] & c;
   \       0x5C   0xF819 0x0002      LDRB     R0,[R9, R2]
   \       0x60   0x4008             ANDS     R0,R1,R0
   \       0x62   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1840                  x[i] = x[i] ^ c;
   \       0x66   0xF819 0x0002      LDRB     R0,[R9, R2]
   \       0x6A   0x4048             EORS     R0,R1,R0
   \       0x6C   0xF809 0x0002      STRB     R0,[R9, R2]
   1841                  c = cc;
   \       0x70   0xF89D 0x3000      LDRB     R3,[SP, #+0]
   1842          
   1843                  /* Adjust if needed, avoiding branches */
   1844                  adjust = 1 - (x[i] & 0x01);
   \       0x74   0xF819 0x0002      LDRB     R0,[R9, R2]
   \       0x78   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x7C   0xF1D0 0x0001      RSBS     R0,R0,#+1
   \       0x80   0x4680             MOV      R8,R0
   1845                  c   |= x[i] & (x[i-1] * adjust);
   \       0x82   0xF819 0xC002      LDRB     R12,[R9, R2]
   \       0x86   0xEB09 0x0002      ADD      R0,R9,R2
   \       0x8A   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \       0x8E   0xFB10 0xF008      SMULBB   R0,R0,R8
   \       0x92   0xEA10 0x0C0C      ANDS     R12,R0,R12
   \       0x96   0xEA5C 0x0303      ORRS     R3,R12,R3
   \       0x9A   0x0019             MOVS     R1,R3
   1846                  x[i] = x[i] ^ (x[i-1] * adjust);
   \       0x9C   0xF819 0x3002      LDRB     R3,[R9, R2]
   \       0xA0   0xEB09 0x0002      ADD      R0,R9,R2
   \       0xA4   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \       0xA8   0xFB10 0xF008      SMULBB   R0,R0,R8
   \       0xAC   0x4043             EORS     R3,R0,R3
   \       0xAE   0xF809 0x3002      STRB     R3,[R9, R2]
   1847                  x[i-1] |= adjust << 7;
   \       0xB2   0xEB09 0x0002      ADD      R0,R9,R2
   \       0xB6   0xF810 0x3C01      LDRB     R3,[R0, #-1]
   \       0xBA   0xEA53 0x13C8      ORRS     R3,R3,R8, LSL #+7
   \       0xBE   0xEB09 0x0002      ADD      R0,R9,R2
   \       0xC2   0xF800 0x3C01      STRB     R3,[R0, #-1]
   1848              }
   \       0xC6   0x1C52             ADDS     R2,R2,#+1
   \       0xC8   0xE7C6             B.N      ??ecp_comb_recode_core_4
   1849          }
   \                     ??ecp_comb_recode_core_5: (+1)
   \       0xCA   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
   1850          
   1851          /*
   1852           * Precompute points for the adapted comb method
   1853           *
   1854           * Assumption: T must be able to hold 2^{w - 1} elements.
   1855           *
   1856           * Operation: If i = i_{w-1} ... i_1 is the binary representation of i,
   1857           *            sets T[i] = i_{w-1} 2^{(w-1)d} P + ... + i_1 2^d P + P.
   1858           *
   1859           * Cost: d(w-1) D + (2^{w-1} - 1) A + 1 N(w-1) + 1 N(2^{w-1} - 1)
   1860           *
   1861           * Note: Even comb values (those where P would be omitted from the
   1862           *       sum defining T[i] above) are not needed in our adaption
   1863           *       the comb method. See ecp_comb_recode_core().
   1864           *
   1865           * This function currently works in four steps:
   1866           * (1) [dbl]      Computation of intermediate T[i] for 2-power values of i
   1867           * (2) [norm_dbl] Normalization of coordinates of these T[i]
   1868           * (3) [add]      Computation of all T[i]
   1869           * (4) [norm_add] Normalization of all T[i]
   1870           *
   1871           * Step 1 can be interrupted but not the others; together with the final
   1872           * coordinate normalization they are the largest steps done at once, depending
   1873           * on the window size. Here are operation counts for P-256:
   1874           *
   1875           * step     (2)     (3)     (4)
   1876           * w = 5    142     165     208
   1877           * w = 4    136      77     160
   1878           * w = 3    130      33     136
   1879           * w = 2    124      11     124
   1880           *
   1881           * So if ECC operations are blocking for too long even with a low max_ops
   1882           * value, it's useful to set MBEDTLS_ECP_WINDOW_SIZE to a lower value in order
   1883           * to minimize maximum blocking time.
   1884           */

   \                                 In section .text, align 2, keep-with-next
   1885          static int ecp_precompute_comb(const mbedtls_ecp_group *grp,
   1886                                         mbedtls_ecp_point T[], const mbedtls_ecp_point *P,
   1887                                         unsigned char w, size_t d,
   1888                                         mbedtls_ecp_restart_ctx *rs_ctx)
   1889          {
   \                     ecp_precompute_comb: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x9E16             LDR      R6,[SP, #+88]
   1890              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x006D      MVNS     R0,#+109
   \       0x10   0x9000             STR      R0,[SP, #+0]
   1891              unsigned char i;
   1892              size_t j = 0;
   \       0x12   0x2700             MOVS     R7,#+0
   1893              const unsigned char T_size = 1U << (w - 1);
   \       0x14   0xF05F 0x0B01      MOVS     R11,#+1
   \       0x18   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \       0x1C   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \       0x20   0xFA1B 0xF808      LSLS     R8,R11,R8
   1894              mbedtls_ecp_point *cur, *TT[COMB_MAX_PRE - 1] = { NULL };
   \       0x24   0xA901             ADD      R1,SP,#+4
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6008             STR      R0,[R1, #+0]
   1895          
   1896              mbedtls_mpi tmp[4];
   1897          
   1898              mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   \       0x2A   0x2104             MOVS     R1,#+4
   \       0x2C   0xA803             ADD      R0,SP,#+12
   \       0x2E   0x.... 0x....      BL       mpi_init_many
   1899          
   1900          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1901              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   1902                  if (rs_ctx->rsm->state == ecp_rsm_pre_dbl) {
   1903                      goto dbl;
   1904                  }
   1905                  if (rs_ctx->rsm->state == ecp_rsm_pre_norm_dbl) {
   1906                      goto norm_dbl;
   1907                  }
   1908                  if (rs_ctx->rsm->state == ecp_rsm_pre_add) {
   1909                      goto add;
   1910                  }
   1911                  if (rs_ctx->rsm->state == ecp_rsm_pre_norm_add) {
   1912                      goto norm_add;
   1913                  }
   1914              }
   1915          #else
   1916              (void) rs_ctx;
   1917          #endif
   1918          
   1919          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1920              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   1921                  rs_ctx->rsm->state = ecp_rsm_pre_dbl;
   1922          
   1923                  /* initial state for the loop */
   1924                  rs_ctx->rsm->i = 0;
   1925              }
   1926          
   1927          dbl:
   1928          #endif
   1929              /*
   1930               * Set T[0] = P and
   1931               * T[2^{l-1}] = 2^{dl} P for l = 1 .. w-1 (this is not the final value)
   1932               */
   1933              MBEDTLS_MPI_CHK(mbedtls_ecp_copy(&T[0], P));
   \       0x32   0x990B             LDR      R1,[SP, #+44]
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x3A   0x4681             MOV      R9,R0
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xF040 0x80A4      BNE.W    ??ecp_precompute_comb_0
   1934          
   1935          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1936              if (rs_ctx != NULL && rs_ctx->rsm != NULL && rs_ctx->rsm->i != 0) {
   1937                  j = rs_ctx->rsm->i;
   1938              } else
   1939          #endif
   1940              j = 0;
   \                     ??ecp_precompute_comb_1: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x0007             MOVS     R7,R0
   1941          
   1942              for (; j < d * (w - 1); j++) {
   \                     ??ecp_precompute_comb_2: (+1)
   \       0x46   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \       0x4A   0x1E40             SUBS     R0,R0,#+1
   \       0x4C   0xFB00 0xF006      MUL      R0,R0,R6
   \       0x50   0x4287             CMP      R7,R0
   \       0x52   0xD227             BCS.N    ??ecp_precompute_comb_3
   1943                  MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_DBL);
   1944          
   1945                  i = 1U << (j / d);
   \       0x54   0xFBB7 0xF0F6      UDIV     R0,R7,R6
   \       0x58   0xFA1B 0xF000      LSLS     R0,R11,R0
   \       0x5C   0x0004             MOVS     R4,R0
   1946                  cur = T + i;
   \       0x5E   0x2118             MOVS     R1,#+24
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0xB2C0             UXTB     R0,R0
   \       0x64   0x4348             MULS     R0,R1,R0
   \       0x66   0x4428             ADD      R0,R5,R0
   \       0x68   0x9002             STR      R0,[SP, #+8]
   1947          
   1948                  if (j % d == 0) {
   \       0x6A   0xFBB7 0xF0F6      UDIV     R0,R7,R6
   \       0x6E   0xFB06 0x7010      MLS      R0,R6,R0,R7
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD10B             BNE.N    ??ecp_precompute_comb_4
   1949                      MBEDTLS_MPI_CHK(mbedtls_ecp_copy(cur, T + (i >> 1)));
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0xB2C0             UXTB     R0,R0
   \       0x7A   0x1040             ASRS     R0,R0,#+1
   \       0x7C   0xFB01 0xF100      MUL      R1,R1,R0
   \       0x80   0x4429             ADD      R1,R5,R1
   \       0x82   0x9802             LDR      R0,[SP, #+8]
   \       0x84   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x88   0x4681             MOV      R9,R0
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD17D             BNE.N    ??ecp_precompute_comb_0
   1950                  }
   1951          
   1952                  MBEDTLS_MPI_CHK(ecp_double_jac(grp, cur, cur, tmp));
   \                     ??ecp_precompute_comb_5: (+1)
   \                     ??ecp_precompute_comb_4: (+1)
   \       0x8E   0xAB03             ADD      R3,SP,#+12
   \       0x90   0x9A02             LDR      R2,[SP, #+8]
   \       0x92   0x9902             LDR      R1,[SP, #+8]
   \       0x94   0x4650             MOV      R0,R10
   \       0x96   0x.... 0x....      BL       ecp_double_jac
   \       0x9A   0x4681             MOV      R9,R0
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD174             BNE.N    ??ecp_precompute_comb_0
   1953              }
   \                     ??ecp_precompute_comb_6: (+1)
   \       0xA0   0x1C7F             ADDS     R7,R7,#+1
   \       0xA2   0xE7D0             B.N      ??ecp_precompute_comb_2
   1954          
   1955          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1956              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   1957                  rs_ctx->rsm->state = ecp_rsm_pre_norm_dbl;
   1958              }
   1959          
   1960          norm_dbl:
   1961          #endif
   1962              /*
   1963               * Normalize current elements in T to allow them to be used in
   1964               * ecp_add_mixed() below, which requires one normalized input.
   1965               *
   1966               * As T has holes, use an auxiliary array of pointers to elements in T.
   1967               *
   1968               */
   1969              j = 0;
   \                     ??ecp_precompute_comb_3: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0x0007             MOVS     R7,R0
   1970              for (i = 1; i < T_size; i <<= 1) {
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0x0004             MOVS     R4,R0
   \                     ??ecp_precompute_comb_7: (+1)
   \       0xAC   0x0021             MOVS     R1,R4
   \       0xAE   0x4640             MOV      R0,R8
   \       0xB0   0xB2C9             UXTB     R1,R1
   \       0xB2   0xB2C0             UXTB     R0,R0
   \       0xB4   0x4281             CMP      R1,R0
   \       0xB6   0xD20A             BCS.N    ??ecp_precompute_comb_8
   1971                  TT[j++] = T + i;
   \       0xB8   0x0021             MOVS     R1,R4
   \       0xBA   0xB2C9             UXTB     R1,R1
   \       0xBC   0x2018             MOVS     R0,#+24
   \       0xBE   0x4341             MULS     R1,R0,R1
   \       0xC0   0x4429             ADD      R1,R5,R1
   \       0xC2   0xA801             ADD      R0,SP,#+4
   \       0xC4   0xF840 0x1027      STR      R1,[R0, R7, LSL #+2]
   \       0xC8   0x1C7F             ADDS     R7,R7,#+1
   1972              }
   \       0xCA   0x0064             LSLS     R4,R4,#+1
   \       0xCC   0xE7EE             B.N      ??ecp_precompute_comb_7
   1973          
   1974              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV + 6 * j - 2);
   1975          
   1976              MBEDTLS_MPI_CHK(ecp_normalize_jac_many(grp, TT, j));
   \                     ??ecp_precompute_comb_8: (+1)
   \       0xCE   0x003A             MOVS     R2,R7
   \       0xD0   0xA901             ADD      R1,SP,#+4
   \       0xD2   0x4650             MOV      R0,R10
   \       0xD4   0x.... 0x....      BL       ecp_normalize_jac_many
   \       0xD8   0x4681             MOV      R9,R0
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD155             BNE.N    ??ecp_precompute_comb_0
   1977          
   1978          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1979              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   1980                  rs_ctx->rsm->state = ecp_rsm_pre_add;
   1981              }
   1982          
   1983          add:
   1984          #endif
   1985              /*
   1986               * Compute the remaining ones using the minimal number of additions
   1987               * Be careful to update T[2^l] only after using it!
   1988               */
   1989              MBEDTLS_ECP_BUDGET((T_size - 1) * MBEDTLS_ECP_OPS_ADD);
   1990          
   1991              for (i = 1; i < T_size; i <<= 1) {
   \                     ??ecp_precompute_comb_9: (+1)
   \       0xDE   0x2001             MOVS     R0,#+1
   \       0xE0   0x0004             MOVS     R4,R0
   \                     ??ecp_precompute_comb_10: (+1)
   \       0xE2   0x0021             MOVS     R1,R4
   \       0xE4   0x4640             MOV      R0,R8
   \       0xE6   0xB2C9             UXTB     R1,R1
   \       0xE8   0xB2C0             UXTB     R0,R0
   \       0xEA   0x4281             CMP      R1,R0
   \       0xEC   0xD221             BCS.N    ??ecp_precompute_comb_11
   1992                  j = i;
   \       0xEE   0x0020             MOVS     R0,R4
   \       0xF0   0xB2C0             UXTB     R0,R0
   \       0xF2   0x0007             MOVS     R7,R0
   1993                  while (j--) {
   \                     ??ecp_precompute_comb_12: (+1)
   \       0xF4   0x0038             MOVS     R0,R7
   \       0xF6   0x1E47             SUBS     R7,R0,#+1
   \       0xF8   0x2800             CMP      R0,#+0
   \       0xFA   0xD018             BEQ.N    ??ecp_precompute_comb_13
   1994                      MBEDTLS_MPI_CHK(ecp_add_mixed(grp, &T[i + j], &T[j], &T[i], tmp));
   \       0xFC   0x2018             MOVS     R0,#+24
   \       0xFE   0xA903             ADD      R1,SP,#+12
   \      0x100   0x9100             STR      R1,[SP, #+0]
   \      0x102   0x0021             MOVS     R1,R4
   \      0x104   0xB2C9             UXTB     R1,R1
   \      0x106   0x4341             MULS     R1,R0,R1
   \      0x108   0xEB05 0x0301      ADD      R3,R5,R1
   \      0x10C   0xFB00 0xF107      MUL      R1,R0,R7
   \      0x110   0xEB05 0x0201      ADD      R2,R5,R1
   \      0x114   0xFA57 0xF184      UXTAB    R1,R7,R4
   \      0x118   0xFB00 0xF001      MUL      R0,R0,R1
   \      0x11C   0xEB05 0x0100      ADD      R1,R5,R0
   \      0x120   0x4650             MOV      R0,R10
   \      0x122   0x.... 0x....      BL       ecp_add_mixed
   \      0x126   0x4681             MOV      R9,R0
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD12E             BNE.N    ??ecp_precompute_comb_0
   \                     ??ecp_precompute_comb_14: (+1)
   \      0x12C   0xE7E2             B.N      ??ecp_precompute_comb_12
   1995                  }
   1996              }
   \                     ??ecp_precompute_comb_13: (+1)
   \      0x12E   0x0064             LSLS     R4,R4,#+1
   \      0x130   0xE7D7             B.N      ??ecp_precompute_comb_10
   1997          
   1998          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1999              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   2000                  rs_ctx->rsm->state = ecp_rsm_pre_norm_add;
   2001              }
   2002          
   2003          norm_add:
   2004          #endif
   2005              /*
   2006               * Normalize final elements in T. Even though there are no holes now, we
   2007               * still need the auxiliary array for homogeneity with the previous
   2008               * call. Also, skip T[0] which is already normalised, being a copy of P.
   2009               */
   2010              for (j = 0; j + 1 < T_size; j++) {
   \                     ??ecp_precompute_comb_11: (+1)
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x0007             MOVS     R7,R0
   \                     ??ecp_precompute_comb_15: (+1)
   \      0x136   0x1C79             ADDS     R1,R7,#+1
   \      0x138   0x4640             MOV      R0,R8
   \      0x13A   0xB2C0             UXTB     R0,R0
   \      0x13C   0x4281             CMP      R1,R0
   \      0x13E   0xD209             BCS.N    ??ecp_precompute_comb_16
   2011                  TT[j] = T + j + 1;
   \      0x140   0x2018             MOVS     R0,#+24
   \      0x142   0xFB00 0xF007      MUL      R0,R0,R7
   \      0x146   0x4428             ADD      R0,R5,R0
   \      0x148   0x3018             ADDS     R0,R0,#+24
   \      0x14A   0xA901             ADD      R1,SP,#+4
   \      0x14C   0xF841 0x0027      STR      R0,[R1, R7, LSL #+2]
   2012              }
   \      0x150   0x1C7F             ADDS     R7,R7,#+1
   \      0x152   0xE7F0             B.N      ??ecp_precompute_comb_15
   2013          
   2014              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV + 6 * j - 2);
   2015          
   2016              MBEDTLS_MPI_CHK(ecp_normalize_jac_many(grp, TT, j));
   \                     ??ecp_precompute_comb_16: (+1)
   \      0x154   0x003A             MOVS     R2,R7
   \      0x156   0xA901             ADD      R1,SP,#+4
   \      0x158   0x4650             MOV      R0,R10
   \      0x15A   0x.... 0x....      BL       ecp_normalize_jac_many
   \      0x15E   0x4681             MOV      R9,R0
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD112             BNE.N    ??ecp_precompute_comb_0
   2017          
   2018              /* Free Z coordinate (=1 after normalization) to save RAM.
   2019               * This makes T[i] invalid as mbedtls_ecp_points, but this is OK
   2020               * since from this point onwards, they are only accessed indirectly
   2021               * via the getter function ecp_select_comb() which does set the
   2022               * target's Z coordinate to 1. */
   2023              for (i = 0; i < T_size; i++) {
   \                     ??ecp_precompute_comb_17: (+1)
   \      0x164   0x2000             MOVS     R0,#+0
   \      0x166   0x0004             MOVS     R4,R0
   \                     ??ecp_precompute_comb_18: (+1)
   \      0x168   0x0021             MOVS     R1,R4
   \      0x16A   0x4640             MOV      R0,R8
   \      0x16C   0xB2C9             UXTB     R1,R1
   \      0x16E   0xB2C0             UXTB     R0,R0
   \      0x170   0x4281             CMP      R1,R0
   \      0x172   0xD20A             BCS.N    ??ecp_precompute_comb_0
   2024                  mbedtls_mpi_free(&T[i].Z);
   \      0x174   0x0021             MOVS     R1,R4
   \      0x176   0xB2C9             UXTB     R1,R1
   \      0x178   0x2018             MOVS     R0,#+24
   \      0x17A   0x4341             MULS     R1,R0,R1
   \      0x17C   0xEB05 0x0001      ADD      R0,R5,R1
   \      0x180   0x3010             ADDS     R0,R0,#+16
   \      0x182   0x.... 0x....      BL       mbedtls_mpi_free
   2025              }
   \      0x186   0x1C64             ADDS     R4,R4,#+1
   \      0x188   0xE7EE             B.N      ??ecp_precompute_comb_18
   2026          
   2027          cleanup:
   2028          
   2029              mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   \                     ??ecp_precompute_comb_0: (+1)
   \      0x18A   0x2104             MOVS     R1,#+4
   \      0x18C   0xA803             ADD      R0,SP,#+12
   \      0x18E   0x.... 0x....      BL       mpi_free_many
   2030          
   2031          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2032              if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   2033                  ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2034                  if (rs_ctx->rsm->state == ecp_rsm_pre_dbl) {
   2035                      rs_ctx->rsm->i = j;
   2036                  }
   2037              }
   2038          #endif
   2039          
   2040              return ret;
   \      0x192   0x4648             MOV      R0,R9
   \      0x194   0xB00D             ADD      SP,SP,#+52
   \      0x196   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2041          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0x0
   2042          
   2043          /*
   2044           * Select precomputed point: R = sign(i) * T[ abs(i) / 2 ]
   2045           *
   2046           * See ecp_comb_recode_core() for background
   2047           */

   \                                 In section .text, align 2, keep-with-next
   2048          static int ecp_select_comb(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2049                                     const mbedtls_ecp_point T[], unsigned char T_size,
   2050                                     unsigned char i)
   2051          {
   \                     ecp_select_comb: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0x9C0A             LDR      R4,[SP, #+40]
   2052              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x086D      MVNS     R8,#+109
   2053              unsigned char ii, j;
   2054          
   2055              /* Ignore the "sign" bit and scale down */
   2056              ii =  (i & 0x7Fu) >> 1;
   \       0x12   0xF3C4 0x0045      UBFX     R0,R4,#+1,#+6
   \       0x16   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2057          
   2058              /* Read the whole table to thwart cache-based timing attacks */
   2059              for (j = 0; j < T_size; j++) {
   \       0x1A   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??ecp_select_comb_0: (+1)
   \       0x1E   0x4649             MOV      R1,R9
   \       0x20   0x0038             MOVS     R0,R7
   \       0x22   0xB2C9             UXTB     R1,R1
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x4281             CMP      R1,R0
   \       0x28   0xD233             BCS.N    ??ecp_select_comb_1
   2060                  MPI_ECP_COND_ASSIGN(&R->X, &T[j].X, j == ii);
   \       0x2A   0x4649             MOV      R1,R9
   \       0x2C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x30   0xB2C9             UXTB     R1,R1
   \       0x32   0x4281             CMP      R1,R0
   \       0x34   0xD101             BNE.N    ??ecp_select_comb_2
   \       0x36   0x2201             MOVS     R2,#+1
   \       0x38   0xE000             B.N      ??ecp_select_comb_3
   \                     ??ecp_select_comb_2: (+1)
   \       0x3A   0x2200             MOVS     R2,#+0
   \                     ??ecp_select_comb_3: (+1)
   \       0x3C   0xF05F 0x0A18      MOVS     R10,#+24
   \       0x40   0xB2D2             UXTB     R2,R2
   \       0x42   0x4648             MOV      R0,R9
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0xFB0A 0xF000      MUL      R0,R10,R0
   \       0x4A   0xEB06 0x0100      ADD      R1,R6,R0
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x54   0x4680             MOV      R8,R0
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD12D             BNE.N    ??ecp_select_comb_4
   2061                  MPI_ECP_COND_ASSIGN(&R->Y, &T[j].Y, j == ii);
   \                     ??ecp_select_comb_5: (+1)
   \       0x5A   0x4649             MOV      R1,R9
   \       0x5C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x60   0xB2C9             UXTB     R1,R1
   \       0x62   0x4281             CMP      R1,R0
   \       0x64   0xD101             BNE.N    ??ecp_select_comb_6
   \       0x66   0x2201             MOVS     R2,#+1
   \       0x68   0xE000             B.N      ??ecp_select_comb_7
   \                     ??ecp_select_comb_6: (+1)
   \       0x6A   0x2200             MOVS     R2,#+0
   \                     ??ecp_select_comb_7: (+1)
   \       0x6C   0xB2D2             UXTB     R2,R2
   \       0x6E   0x4648             MOV      R0,R9
   \       0x70   0xB2C0             UXTB     R0,R0
   \       0x72   0xFB0A 0xFA00      MUL      R10,R10,R0
   \       0x76   0xEB06 0x000A      ADD      R0,R6,R10
   \       0x7A   0xF110 0x0108      ADDS     R1,R0,#+8
   \       0x7E   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x82   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x86   0x4680             MOV      R8,R0
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD114             BNE.N    ??ecp_select_comb_4
   2062              }
   \                     ??ecp_select_comb_8: (+1)
   \       0x8C   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x90   0xE7C5             B.N      ??ecp_select_comb_0
   2063          
   2064              /* Safely invert result if i is "negative" */
   2065              MBEDTLS_MPI_CHK(ecp_safe_invert_jac(grp, R, i >> 7));
   \                     ??ecp_select_comb_1: (+1)
   \       0x92   0x0022             MOVS     R2,R4
   \       0x94   0xB2D2             UXTB     R2,R2
   \       0x96   0x09D2             LSRS     R2,R2,#+7
   \       0x98   0x0029             MOVS     R1,R5
   \       0x9A   0x4658             MOV      R0,R11
   \       0x9C   0x.... 0x....      BL       ecp_safe_invert_jac
   \       0xA0   0x4680             MOV      R8,R0
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD107             BNE.N    ??ecp_select_comb_4
   2066          
   2067              MPI_ECP_LSET(&R->Z, 1);
   \                     ??ecp_select_comb_9: (+1)
   \       0xA6   0x2101             MOVS     R1,#+1
   \       0xA8   0xF115 0x0010      ADDS     R0,R5,#+16
   \       0xAC   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xB0   0x4680             MOV      R8,R0
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD1FF             BNE.N    ??ecp_select_comb_4
   2068          
   2069          cleanup:
   2070              return ret;
   \                     ??ecp_select_comb_10: (+1)
   \                     ??ecp_select_comb_4: (+1)
   \       0xB6   0x4640             MOV      R0,R8
   \       0xB8   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   2071          }
   2072          
   2073          /*
   2074           * Core multiplication algorithm for the (modified) comb method.
   2075           * This part is actually common with the basic comb method (GECC 3.44)
   2076           *
   2077           * Cost: d A + d D + 1 R
   2078           */

   \                                 In section .text, align 2, keep-with-next
   2079          static int ecp_mul_comb_core(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2080                                       const mbedtls_ecp_point T[], unsigned char T_size,
   2081                                       const unsigned char x[], size_t d,
   2082                                       int (*f_rng)(void *, unsigned char *, size_t),
   2083                                       void *p_rng,
   2084                                       mbedtls_ecp_restart_ctx *rs_ctx)
   2085          {
   \                     ecp_mul_comb_core: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB090             SUB      SP,SP,#+64
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0xF8DD 0x8068      LDR      R8,[SP, #+104]
   \       0x12   0xF8DD 0x9070      LDR      R9,[SP, #+112]
   2086              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x006D      MVNS     R0,#+109
   \       0x1A   0x9001             STR      R0,[SP, #+4]
   2087              mbedtls_ecp_point Txi;
   2088              mbedtls_mpi tmp[4];
   2089              size_t i;
   2090          
   2091              mbedtls_ecp_point_init(&Txi);
   \       0x1C   0xA80A             ADD      R0,SP,#+40
   \       0x1E   0x.... 0x....      BL       mbedtls_ecp_point_init
   2092              mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   \       0x22   0x2104             MOVS     R1,#+4
   \       0x24   0xA802             ADD      R0,SP,#+8
   \       0x26   0x.... 0x....      BL       mpi_init_many
   2093          
   2094          #if !defined(MBEDTLS_ECP_RESTARTABLE)
   2095              (void) rs_ctx;
   2096          #endif
   2097          
   2098          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2099              if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   2100                  rs_ctx->rsm->state != ecp_rsm_comb_core) {
   2101                  rs_ctx->rsm->i = 0;
   2102                  rs_ctx->rsm->state = ecp_rsm_comb_core;
   2103              }
   2104          
   2105              /* new 'if' instead of nested for the sake of the 'else' branch */
   2106              if (rs_ctx != NULL && rs_ctx->rsm != NULL && rs_ctx->rsm->i != 0) {
   2107                  /* restore current index (R already pointing to rs_ctx->rsm->R) */
   2108                  i = rs_ctx->rsm->i;
   2109              } else
   2110          #endif
   2111              {
   2112                  /* Start with a non-zero point and randomize its coordinates */
   2113                  i = d;
   \       0x2A   0x9C1B             LDR      R4,[SP, #+108]
   2114                  MBEDTLS_MPI_CHK(ecp_select_comb(grp, R, T, T_size, x[i]));
   \       0x2C   0xF818 0x0004      LDRB     R0,[R8, R4]
   \       0x30   0x9000             STR      R0,[SP, #+0]
   \       0x32   0x003B             MOVS     R3,R7
   \       0x34   0xB2DB             UXTB     R3,R3
   \       0x36   0x0032             MOVS     R2,R6
   \       0x38   0x0029             MOVS     R1,R5
   \       0x3A   0x4658             MOV      R0,R11
   \       0x3C   0x.... 0x....      BL       ecp_select_comb
   \       0x40   0x4682             MOV      R10,R0
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD130             BNE.N    ??ecp_mul_comb_core_0
   2115                  if (f_rng != 0) {
   \                     ??ecp_mul_comb_core_1: (+1)
   \       0x46   0x4648             MOV      R0,R9
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD008             BEQ.N    ??ecp_mul_comb_core_2
   2116                      MBEDTLS_MPI_CHK(ecp_randomize_jac(grp, R, f_rng, p_rng));
   \       0x4C   0x9B1D             LDR      R3,[SP, #+116]
   \       0x4E   0x464A             MOV      R2,R9
   \       0x50   0x0029             MOVS     R1,R5
   \       0x52   0x4658             MOV      R0,R11
   \       0x54   0x.... 0x....      BL       ecp_randomize_jac
   \       0x58   0x4682             MOV      R10,R0
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD124             BNE.N    ??ecp_mul_comb_core_0
   2117                  }
   2118              }
   2119          
   2120              while (i != 0) {
   \                     ??ecp_mul_comb_core_3: (+1)
   \                     ??ecp_mul_comb_core_2: (+1)
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xD022             BEQ.N    ??ecp_mul_comb_core_0
   2121                  MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_DBL + MBEDTLS_ECP_OPS_ADD);
   2122                  --i;
   \       0x62   0x1E64             SUBS     R4,R4,#+1
   2123          
   2124                  MBEDTLS_MPI_CHK(ecp_double_jac(grp, R, R, tmp));
   \       0x64   0xAB02             ADD      R3,SP,#+8
   \       0x66   0x002A             MOVS     R2,R5
   \       0x68   0x0029             MOVS     R1,R5
   \       0x6A   0x4658             MOV      R0,R11
   \       0x6C   0x.... 0x....      BL       ecp_double_jac
   \       0x70   0x4682             MOV      R10,R0
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD118             BNE.N    ??ecp_mul_comb_core_0
   2125                  MBEDTLS_MPI_CHK(ecp_select_comb(grp, &Txi, T, T_size, x[i]));
   \                     ??ecp_mul_comb_core_4: (+1)
   \       0x76   0xF818 0x0004      LDRB     R0,[R8, R4]
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0x003B             MOVS     R3,R7
   \       0x7E   0xB2DB             UXTB     R3,R3
   \       0x80   0x0032             MOVS     R2,R6
   \       0x82   0xA90A             ADD      R1,SP,#+40
   \       0x84   0x4658             MOV      R0,R11
   \       0x86   0x.... 0x....      BL       ecp_select_comb
   \       0x8A   0x4682             MOV      R10,R0
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD10B             BNE.N    ??ecp_mul_comb_core_0
   2126                  MBEDTLS_MPI_CHK(ecp_add_mixed(grp, R, R, &Txi, tmp));
   \                     ??ecp_mul_comb_core_5: (+1)
   \       0x90   0xA802             ADD      R0,SP,#+8
   \       0x92   0x9000             STR      R0,[SP, #+0]
   \       0x94   0xAB0A             ADD      R3,SP,#+40
   \       0x96   0x002A             MOVS     R2,R5
   \       0x98   0x0029             MOVS     R1,R5
   \       0x9A   0x4658             MOV      R0,R11
   \       0x9C   0x.... 0x....      BL       ecp_add_mixed
   \       0xA0   0x4682             MOV      R10,R0
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD100             BNE.N    ??ecp_mul_comb_core_0
   \                     ??ecp_mul_comb_core_6: (+1)
   \       0xA6   0xE7DA             B.N      ??ecp_mul_comb_core_2
   2127              }
   2128          
   2129          cleanup:
   2130          
   2131              mbedtls_ecp_point_free(&Txi);
   \                     ??ecp_mul_comb_core_0: (+1)
   \       0xA8   0xA80A             ADD      R0,SP,#+40
   \       0xAA   0x.... 0x....      BL       mbedtls_ecp_point_free
   2132              mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   \       0xAE   0x2104             MOVS     R1,#+4
   \       0xB0   0xA802             ADD      R0,SP,#+8
   \       0xB2   0x.... 0x....      BL       mpi_free_many
   2133          
   2134          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2135              if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   2136                  ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2137                  rs_ctx->rsm->i = i;
   2138                  /* no need to save R, already pointing to rs_ctx->rsm->R */
   2139              }
   2140          #endif
   2141          
   2142              return ret;
   \       0xB6   0x4650             MOV      R0,R10
   \       0xB8   0xB011             ADD      SP,SP,#+68
   \       0xBA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2143          }
   2144          
   2145          /*
   2146           * Recode the scalar to get constant-time comb multiplication
   2147           *
   2148           * As the actual scalar recoding needs an odd scalar as a starting point,
   2149           * this wrapper ensures that by replacing m by N - m if necessary, and
   2150           * informs the caller that the result of multiplication will be negated.
   2151           *
   2152           * This works because we only support large prime order for Short Weierstrass
   2153           * curves, so N is always odd hence either m or N - m is.
   2154           *
   2155           * See ecp_comb_recode_core() for background.
   2156           */

   \                                 In section .text, align 2, keep-with-next
   2157          static int ecp_comb_recode_scalar(const mbedtls_ecp_group *grp,
   2158                                            const mbedtls_mpi *m,
   2159                                            unsigned char k[COMB_MAX_D + 1],
   2160                                            size_t d,
   2161                                            unsigned char w,
   2162                                            unsigned char *parity_trick)
   2163          {
   \                     ecp_comb_recode_scalar: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0x9C0E             LDR      R4,[SP, #+56]
   \       0x10   0xF8DD 0x803C      LDR      R8,[SP, #+60]
   2164              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x14   0xF07F 0x096D      MVNS     R9,#+109
   2165              mbedtls_mpi M, mm;
   2166          
   2167              mbedtls_mpi_init(&M);
   \       0x18   0x4668             MOV      R0,SP
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_init
   2168              mbedtls_mpi_init(&mm);
   \       0x1E   0xA802             ADD      R0,SP,#+8
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_init
   2169          
   2170              /* N is always odd (see above), just make extra sure */
   2171              if (mbedtls_mpi_get_bit(&grp->N, 0) != 1) {
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0xF11B 0x0034      ADDS     R0,R11,#+52
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD002             BEQ.N    ??ecp_comb_recode_scalar_0
   2172                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0x36   0xE031             B.N      ??ecp_comb_recode_scalar_1
   2173              }
   2174          
   2175              /* do we need the parity trick? */
   2176              *parity_trick = (mbedtls_mpi_get_bit(m, 0) == 0);
   \                     ??ecp_comb_recode_scalar_0: (+1)
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD101             BNE.N    ??ecp_comb_recode_scalar_2
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE000             B.N      ??ecp_comb_recode_scalar_3
   \                     ??ecp_comb_recode_scalar_2: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??ecp_comb_recode_scalar_3: (+1)
   \       0x4A   0xF888 0x0000      STRB     R0,[R8, #+0]
   2177          
   2178              /* execute parity fix in constant time */
   2179              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&M, m));
   \       0x4E   0x0029             MOVS     R1,R5
   \       0x50   0x4668             MOV      R0,SP
   \       0x52   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x56   0x4682             MOV      R10,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD118             BNE.N    ??ecp_comb_recode_scalar_4
   2180              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&mm, &grp->N, m));
   \                     ??ecp_comb_recode_scalar_5: (+1)
   \       0x5C   0x002A             MOVS     R2,R5
   \       0x5E   0xF11B 0x0134      ADDS     R1,R11,#+52
   \       0x62   0xA802             ADD      R0,SP,#+8
   \       0x64   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x68   0x4682             MOV      R10,R0
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD10F             BNE.N    ??ecp_comb_recode_scalar_4
   2181              MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign(&M, &mm, *parity_trick));
   \                     ??ecp_comb_recode_scalar_6: (+1)
   \       0x6E   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \       0x72   0xA902             ADD      R1,SP,#+8
   \       0x74   0x4668             MOV      R0,SP
   \       0x76   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x7A   0x4682             MOV      R10,R0
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD106             BNE.N    ??ecp_comb_recode_scalar_4
   2182          
   2183              /* actual scalar recoding */
   2184              ecp_comb_recode_core(k, d, w, &M);
   \                     ??ecp_comb_recode_scalar_7: (+1)
   \       0x80   0x466B             MOV      R3,SP
   \       0x82   0x0022             MOVS     R2,R4
   \       0x84   0xB2D2             UXTB     R2,R2
   \       0x86   0x0039             MOVS     R1,R7
   \       0x88   0x0030             MOVS     R0,R6
   \       0x8A   0x.... 0x....      BL       ecp_comb_recode_core
   2185          
   2186          cleanup:
   2187              mbedtls_mpi_free(&mm);
   \                     ??ecp_comb_recode_scalar_4: (+1)
   \       0x8E   0xA802             ADD      R0,SP,#+8
   \       0x90   0x.... 0x....      BL       mbedtls_mpi_free
   2188              mbedtls_mpi_free(&M);
   \       0x94   0x4668             MOV      R0,SP
   \       0x96   0x.... 0x....      BL       mbedtls_mpi_free
   2189          
   2190              return ret;
   \       0x9A   0x4650             MOV      R0,R10
   \                     ??ecp_comb_recode_scalar_1: (+1)
   \       0x9C   0xB005             ADD      SP,SP,#+20
   \       0x9E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2191          }
   2192          
   2193          /*
   2194           * Perform comb multiplication (for short Weierstrass curves)
   2195           * once the auxiliary table has been pre-computed.
   2196           *
   2197           * Scalar recoding may use a parity trick that makes us compute -m * P,
   2198           * if that is the case we'll need to recover m * P at the end.
   2199           */

   \                                 In section .text, align 2, keep-with-next
   2200          static int ecp_mul_comb_after_precomp(const mbedtls_ecp_group *grp,
   2201                                                mbedtls_ecp_point *R,
   2202                                                const mbedtls_mpi *m,
   2203                                                const mbedtls_ecp_point *T,
   2204                                                unsigned char T_size,
   2205                                                unsigned char w,
   2206                                                size_t d,
   2207                                                int (*f_rng)(void *, unsigned char *, size_t),
   2208                                                void *p_rng,
   2209                                                mbedtls_ecp_restart_ctx *rs_ctx)
   2210          {
   \                     ecp_mul_comb_after_precomp: (+1)
   \        0x0   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \        0x4   0xB0A8             SUB      SP,SP,#+160
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9C32             LDR      R4,[SP, #+200]
   \        0xE   0x9F34             LDR      R7,[SP, #+208]
   \       0x10   0xF8DD 0x80D4      LDR      R8,[SP, #+212]
   \       0x14   0xF8DD 0x90D8      LDR      R9,[SP, #+216]
   2211              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x18   0xF07F 0x006D      MVNS     R0,#+109
   \       0x1C   0x9002             STR      R0,[SP, #+8]
   2212              unsigned char parity_trick;
   2213              unsigned char k[COMB_MAX_D + 1];
   2214              mbedtls_ecp_point *RR = R;
   \       0x1E   0x9828             LDR      R0,[SP, #+160]
   \       0x20   0x9006             STR      R0,[SP, #+24]
   2215          
   2216          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2217              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   2218                  RR = &rs_ctx->rsm->R;
   2219          
   2220                  if (rs_ctx->rsm->state == ecp_rsm_final_norm) {
   2221                      goto final_norm;
   2222                  }
   2223              }
   2224          #endif
   2225          
   2226              MBEDTLS_MPI_CHK(ecp_comb_recode_scalar(grp, m, k, d, w,
   2227                                                     &parity_trick));
   \       0x22   0xA805             ADD      R0,SP,#+20
   \       0x24   0x9001             STR      R0,[SP, #+4]
   \       0x26   0xF89D 0x00CC      LDRB     R0,[SP, #+204]
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x003B             MOVS     R3,R7
   \       0x2E   0xAA07             ADD      R2,SP,#+28
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0x4658             MOV      R0,R11
   \       0x34   0x.... 0x....      BL       ecp_comb_recode_scalar
   \       0x38   0x4682             MOV      R10,R0
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD12E             BNE.N    ??ecp_mul_comb_after_precomp_0
   2228              MBEDTLS_MPI_CHK(ecp_mul_comb_core(grp, RR, T, T_size, k, d,
   2229                                                f_rng, p_rng, rs_ctx));
   \                     ??ecp_mul_comb_after_precomp_1: (+1)
   \       0x3E   0x9837             LDR      R0,[SP, #+220]
   \       0x40   0x9004             STR      R0,[SP, #+16]
   \       0x42   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x46   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x4A   0x9701             STR      R7,[SP, #+4]
   \       0x4C   0xA807             ADD      R0,SP,#+28
   \       0x4E   0x9000             STR      R0,[SP, #+0]
   \       0x50   0x0023             MOVS     R3,R4
   \       0x52   0xB2DB             UXTB     R3,R3
   \       0x54   0x0032             MOVS     R2,R6
   \       0x56   0x9906             LDR      R1,[SP, #+24]
   \       0x58   0x4658             MOV      R0,R11
   \       0x5A   0x.... 0x....      BL       ecp_mul_comb_core
   \       0x5E   0x4682             MOV      R10,R0
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD11B             BNE.N    ??ecp_mul_comb_after_precomp_0
   2230              MBEDTLS_MPI_CHK(ecp_safe_invert_jac(grp, RR, parity_trick));
   \                     ??ecp_mul_comb_after_precomp_2: (+1)
   \       0x64   0xF89D 0x2014      LDRB     R2,[SP, #+20]
   \       0x68   0x9906             LDR      R1,[SP, #+24]
   \       0x6A   0x4658             MOV      R0,R11
   \       0x6C   0x.... 0x....      BL       ecp_safe_invert_jac
   \       0x70   0x4682             MOV      R10,R0
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD112             BNE.N    ??ecp_mul_comb_after_precomp_0
   2231          
   2232          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2233              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   2234                  rs_ctx->rsm->state = ecp_rsm_final_norm;
   2235              }
   2236          
   2237          final_norm:
   2238              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV);
   2239          #endif
   2240              /*
   2241               * Knowledge of the jacobian coordinates may leak the last few bits of the
   2242               * scalar [1], and since our MPI implementation isn't constant-flow,
   2243               * inversion (used for coordinate normalization) may leak the full value
   2244               * of its input via side-channels [2].
   2245               *
   2246               * [1] https://eprint.iacr.org/2003/191
   2247               * [2] https://eprint.iacr.org/2020/055
   2248               *
   2249               * Avoid the leak by randomizing coordinates before we normalize them.
   2250               */
   2251              if (f_rng != 0) {
   \                     ??ecp_mul_comb_after_precomp_3: (+1)
   \       0x76   0x4640             MOV      R0,R8
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD008             BEQ.N    ??ecp_mul_comb_after_precomp_4
   2252                  MBEDTLS_MPI_CHK(ecp_randomize_jac(grp, RR, f_rng, p_rng));
   \       0x7C   0x464B             MOV      R3,R9
   \       0x7E   0x4642             MOV      R2,R8
   \       0x80   0x9906             LDR      R1,[SP, #+24]
   \       0x82   0x4658             MOV      R0,R11
   \       0x84   0x.... 0x....      BL       ecp_randomize_jac
   \       0x88   0x4682             MOV      R10,R0
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD106             BNE.N    ??ecp_mul_comb_after_precomp_0
   2253              }
   2254          
   2255              MBEDTLS_MPI_CHK(ecp_normalize_jac(grp, RR));
   \                     ??ecp_mul_comb_after_precomp_5: (+1)
   \                     ??ecp_mul_comb_after_precomp_4: (+1)
   \       0x8E   0x9906             LDR      R1,[SP, #+24]
   \       0x90   0x4658             MOV      R0,R11
   \       0x92   0x.... 0x....      BL       ecp_normalize_jac
   \       0x96   0x4682             MOV      R10,R0
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD1FF             BNE.N    ??ecp_mul_comb_after_precomp_0
   2256          
   2257          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2258              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   2259                  MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, RR));
   2260              }
   2261          #endif
   2262          
   2263          cleanup:
   2264              return ret;
   \                     ??ecp_mul_comb_after_precomp_6: (+1)
   \                     ??ecp_mul_comb_after_precomp_0: (+1)
   \       0x9C   0x4650             MOV      R0,R10
   \       0x9E   0xB029             ADD      SP,SP,#+164
   \       0xA0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2265          }
   2266          
   2267          /*
   2268           * Pick window size based on curve size and whether we optimize for base point
   2269           */

   \                                 In section .text, align 2, keep-with-next
   2270          static unsigned char ecp_pick_window_size(const mbedtls_ecp_group *grp,
   2271                                                    unsigned char p_eq_g)
   2272          {
   \                     ecp_pick_window_size: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2273              unsigned char w;
   2274          
   2275              /*
   2276               * Minimize the number of multiplications, that is minimize
   2277               * 10 * d * w + 18 * 2^(w-1) + 11 * d + 7 * w, with d = ceil( nbits / w )
   2278               * (see costs of the various parts, with 1S = 1M)
   2279               */
   2280              w = grp->nbits >= 384 ? 5 : 4;
   \        0x6   0x6C20             LDR      R0,[R4, #+64]
   \        0x8   0xF5B0 0x7FC0      CMP      R0,#+384
   \        0xC   0xD301             BCC.N    ??ecp_pick_window_size_0
   \        0xE   0x2605             MOVS     R6,#+5
   \       0x10   0xE000             B.N      ??ecp_pick_window_size_1
   \                     ??ecp_pick_window_size_0: (+1)
   \       0x12   0x2604             MOVS     R6,#+4
   2281          
   2282              /*
   2283               * If P == G, pre-compute a bit more, since this may be re-used later.
   2284               * Just adding one avoids upping the cost of the first mul too much,
   2285               * and the memory cost too.
   2286               */
   2287              if (p_eq_g) {
   \                     ??ecp_pick_window_size_1: (+1)
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD000             BEQ.N    ??ecp_pick_window_size_2
   2288                  w++;
   \       0x1C   0x1C76             ADDS     R6,R6,#+1
   2289              }
   2290          
   2291              /*
   2292               * If static comb table may not be used (!p_eq_g) or static comb table does
   2293               * not exists, make sure w is within bounds.
   2294               * (The last test is useful only for very small curves in the test suite.)
   2295               *
   2296               * The user reduces MBEDTLS_ECP_WINDOW_SIZE does not changes the size of
   2297               * static comb table, because the size of static comb table is fixed when
   2298               * it is generated.
   2299               */
   2300          #if (MBEDTLS_ECP_WINDOW_SIZE < 6)
   2301              if ((!p_eq_g || !ecp_group_is_static_comb_table(grp)) && w > MBEDTLS_ECP_WINDOW_SIZE) {
   \                     ??ecp_pick_window_size_2: (+1)
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD004             BEQ.N    ??ecp_pick_window_size_3
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       ecp_group_is_static_comb_table
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD105             BNE.N    ??ecp_pick_window_size_4
   \                     ??ecp_pick_window_size_3: (+1)
   \       0x30   0x0030             MOVS     R0,R6
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0x2803             CMP      R0,#+3
   \       0x36   0xDB01             BLT.N    ??ecp_pick_window_size_4
   2302                  w = MBEDTLS_ECP_WINDOW_SIZE;
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0x0006             MOVS     R6,R0
   2303              }
   2304          #endif
   2305              if (w >= grp->nbits) {
   \                     ??ecp_pick_window_size_4: (+1)
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0xB2C9             UXTB     R1,R1
   \       0x40   0x6C20             LDR      R0,[R4, #+64]
   \       0x42   0x4281             CMP      R1,R0
   \       0x44   0xD301             BCC.N    ??ecp_pick_window_size_5
   2306                  w = 2;
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0x0006             MOVS     R6,R0
   2307              }
   2308          
   2309              return w;
   \                     ??ecp_pick_window_size_5: (+1)
   \       0x4A   0x0030             MOVS     R0,R6
   \       0x4C   0xB2C0             UXTB     R0,R0
   \       0x4E   0xBD70             POP      {R4-R6,PC}
   2310          }
   2311          
   2312          /*
   2313           * Multiplication using the comb method - for curves in short Weierstrass form
   2314           *
   2315           * This function is mainly responsible for administrative work:
   2316           * - managing the restart context if enabled
   2317           * - managing the table of precomputed points (passed between the below two
   2318           *   functions): allocation, computation, ownership transfer, freeing.
   2319           *
   2320           * It delegates the actual arithmetic work to:
   2321           *      ecp_precompute_comb() and ecp_mul_comb_with_precomp()
   2322           *
   2323           * See comments on ecp_comb_recode_core() regarding the computation strategy.
   2324           */

   \                                 In section .text, align 2, keep-with-next
   2325          static int ecp_mul_comb(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2326                                  const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2327                                  int (*f_rng)(void *, unsigned char *, size_t),
   2328                                  void *p_rng,
   2329                                  mbedtls_ecp_restart_ctx *rs_ctx)
   2330          {
   \                     ecp_mul_comb: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4682             MOV      R10,R0
   2331              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x056D      MVNS     R5,#+109
   2332              unsigned char w, p_eq_g, i;
   2333              size_t d;
   2334              unsigned char T_size = 0, T_ok = 0;
   \        0xC   0x2400             MOVS     R4,#+0
   \        0xE   0x2700             MOVS     R7,#+0
   2335              mbedtls_ecp_point *T = NULL;
   \       0x10   0xF05F 0x0B00      MOVS     R11,#+0
   2336          
   2337              ECP_RS_ENTER(rsm);
   2338          
   2339              /* Is P the base point ? */
   2340          #if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1
   2341              p_eq_g = (MPI_ECP_CMP(&P->Y, &grp->G.Y) == 0 &&
   2342                        MPI_ECP_CMP(&P->X, &grp->G.X) == 0);
   2343          #else
   2344              p_eq_g = 0;
   \       0x14   0xF05F 0x0800      MOVS     R8,#+0
   2345          #endif
   2346          
   2347              /* Pick window size and deduce related sizes */
   2348              w = ecp_pick_window_size(grp, p_eq_g);
   \       0x18   0x4641             MOV      R1,R8
   \       0x1A   0xB2C9             UXTB     R1,R1
   \       0x1C   0x4650             MOV      R0,R10
   \       0x1E   0x.... 0x....      BL       ecp_pick_window_size
   \       0x22   0x4681             MOV      R9,R0
   2349              T_size = 1U << (w - 1);
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0xF1B9 0x0001      SUBS     R0,R9,#+1
   \       0x2A   0x4081             LSLS     R1,R1,R0
   \       0x2C   0xF88D 0x1018      STRB     R1,[SP, #+24]
   2350              d = (grp->nbits + w - 1) / w;
   \       0x30   0xF8DA 0x0040      LDR      R0,[R10, #+64]
   \       0x34   0xFA50 0xF089      UXTAB    R0,R0,R9
   \       0x38   0x1E40             SUBS     R0,R0,#+1
   \       0x3A   0x4649             MOV      R1,R9
   \       0x3C   0xB2C9             UXTB     R1,R1
   \       0x3E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x42   0x9007             STR      R0,[SP, #+28]
   2351          
   2352              /* Pre-computed table: do we have it already for the base point? */
   2353              if (p_eq_g && grp->T != NULL) {
   \       0x44   0x4640             MOV      R0,R8
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD008             BEQ.N    ??ecp_mul_comb_0
   \       0x4C   0xF8DA 0x0058      LDR      R0,[R10, #+88]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD004             BEQ.N    ??ecp_mul_comb_0
   2354                  /* second pointer to the same table, will be deleted on exit */
   2355                  T = grp->T;
   \       0x54   0xF8DA 0x4058      LDR      R4,[R10, #+88]
   2356                  T_ok = 1;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0x0007             MOVS     R7,R0
   \       0x5C   0xE01F             B.N      ??ecp_mul_comb_1
   2357              } else
   2358          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2359              /* Pre-computed table: do we have one in progress? complete? */
   2360              if (rs_ctx != NULL && rs_ctx->rsm != NULL && rs_ctx->rsm->T != NULL) {
   2361                  /* transfer ownership of T from rsm to local function */
   2362                  T = rs_ctx->rsm->T;
   2363                  rs_ctx->rsm->T = NULL;
   2364                  rs_ctx->rsm->T_size = 0;
   2365          
   2366                  /* This effectively jumps to the call to mul_comb_after_precomp() */
   2367                  T_ok = rs_ctx->rsm->state >= ecp_rsm_comb_core;
   2368              } else
   2369          #endif
   2370              /* Allocate table if we didn't have any */
   2371              {
   2372                  T = mbedtls_calloc(T_size, sizeof(mbedtls_ecp_point));
   \                     ??ecp_mul_comb_0: (+1)
   \       0x5E   0x2118             MOVS     R1,#+24
   \       0x60   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \       0x64   0x.... 0x....      BL       sl_calloc
   \       0x68   0x0004             MOVS     R4,R0
   2373                  if (T == NULL) {
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD103             BNE.N    ??ecp_mul_comb_2
   2374                      ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x72   0x0005             MOVS     R5,R0
   2375                      goto cleanup;
   \       0x74   0xE046             B.N      ??ecp_mul_comb_3
   2376                  }
   2377          
   2378                  for (i = 0; i < T_size; i++) {
   \                     ??ecp_mul_comb_2: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x0006             MOVS     R6,R0
   \                     ??ecp_mul_comb_4: (+1)
   \       0x7A   0x0031             MOVS     R1,R6
   \       0x7C   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \       0x80   0xB2C9             UXTB     R1,R1
   \       0x82   0x4281             CMP      R1,R0
   \       0x84   0xD209             BCS.N    ??ecp_mul_comb_5
   2379                      mbedtls_ecp_point_init(&T[i]);
   \       0x86   0x0031             MOVS     R1,R6
   \       0x88   0xB2C9             UXTB     R1,R1
   \       0x8A   0x2018             MOVS     R0,#+24
   \       0x8C   0x4341             MULS     R1,R0,R1
   \       0x8E   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x92   0x.... 0x....      BL       mbedtls_ecp_point_init
   2380                  }
   \       0x96   0x1C76             ADDS     R6,R6,#+1
   \       0x98   0xE7EF             B.N      ??ecp_mul_comb_4
   2381          
   2382                  T_ok = 0;
   \                     ??ecp_mul_comb_5: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x0007             MOVS     R7,R0
   2383              }
   2384          
   2385              /* Compute table (or finish computing it) if not done already */
   2386              if (!T_ok) {
   \                     ??ecp_mul_comb_1: (+1)
   \       0x9E   0x0038             MOVS     R0,R7
   \       0xA0   0xB2C0             UXTB     R0,R0
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD117             BNE.N    ??ecp_mul_comb_6
   2387                  MBEDTLS_MPI_CHK(ecp_precompute_comb(grp, T, P, w, d, rs_ctx));
   \       0xA6   0x9816             LDR      R0,[SP, #+88]
   \       0xA8   0x9001             STR      R0,[SP, #+4]
   \       0xAA   0x9807             LDR      R0,[SP, #+28]
   \       0xAC   0x9000             STR      R0,[SP, #+0]
   \       0xAE   0x464B             MOV      R3,R9
   \       0xB0   0xB2DB             UXTB     R3,R3
   \       0xB2   0x9A0A             LDR      R2,[SP, #+40]
   \       0xB4   0x0021             MOVS     R1,R4
   \       0xB6   0x4650             MOV      R0,R10
   \       0xB8   0x.... 0x....      BL       ecp_precompute_comb
   \       0xBC   0x0005             MOVS     R5,R0
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD120             BNE.N    ??ecp_mul_comb_3
   2388          
   2389                  if (p_eq_g) {
   \                     ??ecp_mul_comb_7: (+1)
   \       0xC2   0x4640             MOV      R0,R8
   \       0xC4   0xB2C0             UXTB     R0,R0
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD005             BEQ.N    ??ecp_mul_comb_6
   2390                      /* almost transfer ownership of T to the group, but keep a copy of
   2391                       * the pointer to use for calling the next function more easily */
   2392                      grp->T = T;
   \       0xCA   0xF8CA 0x4058      STR      R4,[R10, #+88]
   2393                      grp->T_size = T_size;
   \       0xCE   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \       0xD2   0xF8CA 0x005C      STR      R0,[R10, #+92]
   2394                  }
   2395              }
   2396          
   2397              /* Actual comb multiplication using precomputed points */
   2398              MBEDTLS_MPI_CHK(ecp_mul_comb_after_precomp(grp, R, m,
   2399                                                         T, T_size, w, d,
   2400                                                         f_rng, p_rng, rs_ctx));
   \                     ??ecp_mul_comb_6: (+1)
   \       0xD6   0x9816             LDR      R0,[SP, #+88]
   \       0xD8   0x9005             STR      R0,[SP, #+20]
   \       0xDA   0x9815             LDR      R0,[SP, #+84]
   \       0xDC   0x9004             STR      R0,[SP, #+16]
   \       0xDE   0x9814             LDR      R0,[SP, #+80]
   \       0xE0   0x9003             STR      R0,[SP, #+12]
   \       0xE2   0x9807             LDR      R0,[SP, #+28]
   \       0xE4   0x9002             STR      R0,[SP, #+8]
   \       0xE6   0x4648             MOV      R0,R9
   \       0xE8   0xB2C0             UXTB     R0,R0
   \       0xEA   0x9001             STR      R0,[SP, #+4]
   \       0xEC   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \       0xF0   0x9000             STR      R0,[SP, #+0]
   \       0xF2   0x0023             MOVS     R3,R4
   \       0xF4   0x9A09             LDR      R2,[SP, #+36]
   \       0xF6   0x9908             LDR      R1,[SP, #+32]
   \       0xF8   0x4650             MOV      R0,R10
   \       0xFA   0x.... 0x....      BL       ecp_mul_comb_after_precomp
   \       0xFE   0x0005             MOVS     R5,R0
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD1FF             BNE.N    ??ecp_mul_comb_3
   2401          
   2402          cleanup:
   2403          
   2404              /* does T belong to the group? */
   2405              if (T == grp->T) {
   \                     ??ecp_mul_comb_8: (+1)
   \                     ??ecp_mul_comb_3: (+1)
   \      0x104   0xF8DA 0x0058      LDR      R0,[R10, #+88]
   \      0x108   0x4284             CMP      R4,R0
   \      0x10A   0xD101             BNE.N    ??ecp_mul_comb_9
   2406                  T = NULL;
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0x0004             MOVS     R4,R0
   2407              }
   2408          
   2409              /* does T belong to the restart context? */
   2410          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2411              if (rs_ctx != NULL && rs_ctx->rsm != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS && T != NULL) {
   2412                  /* transfer ownership of T from local function to rsm */
   2413                  rs_ctx->rsm->T_size = T_size;
   2414                  rs_ctx->rsm->T = T;
   2415                  T = NULL;
   2416              }
   2417          #endif
   2418          
   2419              /* did T belong to us? then let's destroy it! */
   2420              if (T != NULL) {
   \                     ??ecp_mul_comb_9: (+1)
   \      0x110   0x2C00             CMP      R4,#+0
   \      0x112   0xD014             BEQ.N    ??ecp_mul_comb_10
   2421                  for (i = 0; i < T_size; i++) {
   \      0x114   0x2000             MOVS     R0,#+0
   \      0x116   0x0006             MOVS     R6,R0
   \                     ??ecp_mul_comb_11: (+1)
   \      0x118   0x0031             MOVS     R1,R6
   \      0x11A   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \      0x11E   0xB2C9             UXTB     R1,R1
   \      0x120   0x4281             CMP      R1,R0
   \      0x122   0xD209             BCS.N    ??ecp_mul_comb_12
   2422                      mbedtls_ecp_point_free(&T[i]);
   \      0x124   0x0031             MOVS     R1,R6
   \      0x126   0xB2C9             UXTB     R1,R1
   \      0x128   0x2018             MOVS     R0,#+24
   \      0x12A   0x4341             MULS     R1,R0,R1
   \      0x12C   0xEB04 0x0001      ADD      R0,R4,R1
   \      0x130   0x.... 0x....      BL       mbedtls_ecp_point_free
   2423                  }
   \      0x134   0x1C76             ADDS     R6,R6,#+1
   \      0x136   0xE7EF             B.N      ??ecp_mul_comb_11
   2424                  mbedtls_free(T);
   \                     ??ecp_mul_comb_12: (+1)
   \      0x138   0x0020             MOVS     R0,R4
   \      0x13A   0x.... 0x....      BL       sl_free
   2425              }
   2426          
   2427              /* prevent caller from using invalid value */
   2428              int should_free_R = (ret != 0);
   \                     ??ecp_mul_comb_10: (+1)
   \      0x13E   0x2D00             CMP      R5,#+0
   \      0x140   0xD002             BEQ.N    ??ecp_mul_comb_13
   \      0x142   0xF05F 0x0B01      MOVS     R11,#+1
   \      0x146   0xE001             B.N      ??ecp_mul_comb_14
   \                     ??ecp_mul_comb_13: (+1)
   \      0x148   0xF05F 0x0B00      MOVS     R11,#+0
   2429          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2430              /* don't free R while in progress in case R == P */
   2431              if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2432                  should_free_R = 0;
   2433              }
   2434          #endif
   2435              if (should_free_R) {
   \                     ??ecp_mul_comb_14: (+1)
   \      0x14C   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x150   0xD002             BEQ.N    ??ecp_mul_comb_15
   2436                  mbedtls_ecp_point_free(R);
   \      0x152   0x9808             LDR      R0,[SP, #+32]
   \      0x154   0x.... 0x....      BL       mbedtls_ecp_point_free
   2437              }
   2438          
   2439              ECP_RS_LEAVE(rsm);
   2440          
   2441              return ret;
   \                     ??ecp_mul_comb_15: (+1)
   \      0x158   0x0028             MOVS     R0,R5
   \      0x15A   0xB00B             ADD      SP,SP,#+44
   \      0x15C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2442          }
   2443          
   2444          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   2445          
   2446          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   2447          /*
   2448           * For Montgomery curves, we do all the internal arithmetic in projective
   2449           * coordinates. Import/export of points uses only the x coordinates, which is
   2450           * internally represented as X / Z.
   2451           *
   2452           * For scalar multiplication, we'll use a Montgomery ladder.
   2453           */
   2454          
   2455          /*
   2456           * Normalize Montgomery x/z coordinates: X = X/Z, Z = 1
   2457           * Cost: 1M + 1I
   2458           */
   2459          static int ecp_normalize_mxz(const mbedtls_ecp_group *grp, mbedtls_ecp_point *P)
   2460          {
   2461          #if defined(MBEDTLS_ECP_NORMALIZE_MXZ_ALT)
   2462              if (mbedtls_internal_ecp_grp_capable(grp)) {
   2463                  return mbedtls_internal_ecp_normalize_mxz(grp, P);
   2464              }
   2465          #endif /* MBEDTLS_ECP_NORMALIZE_MXZ_ALT */
   2466          
   2467          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_NORMALIZE_MXZ_ALT)
   2468              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   2469          #else
   2470              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2471              MPI_ECP_INV(&P->Z, &P->Z);
   2472              MPI_ECP_MUL(&P->X, &P->X, &P->Z);
   2473              MPI_ECP_LSET(&P->Z, 1);
   2474          
   2475          cleanup:
   2476              return ret;
   2477          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_NORMALIZE_MXZ_ALT) */
   2478          }
   2479          
   2480          /*
   2481           * Randomize projective x/z coordinates:
   2482           * (X, Z) -> (l X, l Z) for random l
   2483           * This is sort of the reverse operation of ecp_normalize_mxz().
   2484           *
   2485           * This countermeasure was first suggested in [2].
   2486           * Cost: 2M
   2487           */
   2488          static int ecp_randomize_mxz(const mbedtls_ecp_group *grp, mbedtls_ecp_point *P,
   2489                                       int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   2490          {
   2491          #if defined(MBEDTLS_ECP_RANDOMIZE_MXZ_ALT)
   2492              if (mbedtls_internal_ecp_grp_capable(grp)) {
   2493                  return mbedtls_internal_ecp_randomize_mxz(grp, P, f_rng, p_rng);
   2494              }
   2495          #endif /* MBEDTLS_ECP_RANDOMIZE_MXZ_ALT */
   2496          
   2497          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_RANDOMIZE_MXZ_ALT)
   2498              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   2499          #else
   2500              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2501              mbedtls_mpi l;
   2502              mbedtls_mpi_init(&l);
   2503          
   2504              /* Generate l such that 1 < l < p */
   2505              MPI_ECP_RAND(&l);
   2506          
   2507              MPI_ECP_MUL(&P->X, &P->X, &l);
   2508              MPI_ECP_MUL(&P->Z, &P->Z, &l);
   2509          
   2510          cleanup:
   2511              mbedtls_mpi_free(&l);
   2512          
   2513              if (ret == MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) {
   2514                  ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
   2515              }
   2516              return ret;
   2517          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_RANDOMIZE_MXZ_ALT) */
   2518          }
   2519          
   2520          /*
   2521           * Double-and-add: R = 2P, S = P + Q, with d = X(P - Q),
   2522           * for Montgomery curves in x/z coordinates.
   2523           *
   2524           * http://www.hyperelliptic.org/EFD/g1p/auto-code/montgom/xz/ladder/mladd-1987-m.op3
   2525           * with
   2526           * d =  X1
   2527           * P = (X2, Z2)
   2528           * Q = (X3, Z3)
   2529           * R = (X4, Z4)
   2530           * S = (X5, Z5)
   2531           * and eliminating temporary variables tO, ..., t4.
   2532           *
   2533           * Cost: 5M + 4S
   2534           */
   2535          static int ecp_double_add_mxz(const mbedtls_ecp_group *grp,
   2536                                        mbedtls_ecp_point *R, mbedtls_ecp_point *S,
   2537                                        const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q,
   2538                                        const mbedtls_mpi *d,
   2539                                        mbedtls_mpi T[4])
   2540          {
   2541          #if defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT)
   2542              if (mbedtls_internal_ecp_grp_capable(grp)) {
   2543                  return mbedtls_internal_ecp_double_add_mxz(grp, R, S, P, Q, d);
   2544              }
   2545          #endif /* MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT */
   2546          
   2547          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT)
   2548              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   2549          #else
   2550              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2551          
   2552              MPI_ECP_ADD(&T[0], &P->X,   &P->Z);   /* Pp := PX + PZ                    */
   2553              MPI_ECP_SUB(&T[1], &P->X,   &P->Z);   /* Pm := PX - PZ                    */
   2554              MPI_ECP_ADD(&T[2], &Q->X,   &Q->Z);   /* Qp := QX + XZ                    */
   2555              MPI_ECP_SUB(&T[3], &Q->X,   &Q->Z);   /* Qm := QX - QZ                    */
   2556              MPI_ECP_MUL(&T[3], &T[3],   &T[0]);   /* Qm * Pp                          */
   2557              MPI_ECP_MUL(&T[2], &T[2],   &T[1]);   /* Qp * Pm                          */
   2558              MPI_ECP_SQR(&T[0], &T[0]);            /* Pp^2                             */
   2559              MPI_ECP_SQR(&T[1], &T[1]);            /* Pm^2                             */
   2560              MPI_ECP_MUL(&R->X, &T[0],   &T[1]);   /* Pp^2 * Pm^2                      */
   2561              MPI_ECP_SUB(&T[0], &T[0],   &T[1]);   /* Pp^2 - Pm^2                      */
   2562              MPI_ECP_MUL(&R->Z, &grp->A, &T[0]);   /* A * (Pp^2 - Pm^2)                */
   2563              MPI_ECP_ADD(&R->Z, &T[1],   &R->Z);   /* [ A * (Pp^2-Pm^2) ] + Pm^2       */
   2564              MPI_ECP_ADD(&S->X, &T[3],   &T[2]);   /* Qm*Pp + Qp*Pm                    */
   2565              MPI_ECP_SQR(&S->X, &S->X);            /* (Qm*Pp + Qp*Pm)^2                */
   2566              MPI_ECP_SUB(&S->Z, &T[3],   &T[2]);   /* Qm*Pp - Qp*Pm                    */
   2567              MPI_ECP_SQR(&S->Z, &S->Z);            /* (Qm*Pp - Qp*Pm)^2                */
   2568              MPI_ECP_MUL(&S->Z, d,       &S->Z);   /* d * ( Qm*Pp - Qp*Pm )^2          */
   2569              MPI_ECP_MUL(&R->Z, &T[0],   &R->Z);   /* [A*(Pp^2-Pm^2)+Pm^2]*(Pp^2-Pm^2) */
   2570          
   2571          cleanup:
   2572          
   2573              return ret;
   2574          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT) */
   2575          }
   2576          
   2577          /*
   2578           * Multiplication with Montgomery ladder in x/z coordinates,
   2579           * for curves in Montgomery form
   2580           */
   2581          static int ecp_mul_mxz(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2582                                 const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2583                                 int (*f_rng)(void *, unsigned char *, size_t),
   2584                                 void *p_rng)
   2585          {
   2586              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2587              size_t i;
   2588              unsigned char b;
   2589              mbedtls_ecp_point RP;
   2590              mbedtls_mpi PX;
   2591              mbedtls_mpi tmp[4];
   2592              mbedtls_ecp_point_init(&RP); mbedtls_mpi_init(&PX);
   2593          
   2594              mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   2595          
   2596              if (f_rng == NULL) {
   2597                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   2598              }
   2599          
   2600              /* Save PX and read from P before writing to R, in case P == R */
   2601              MPI_ECP_MOV(&PX, &P->X);
   2602              MBEDTLS_MPI_CHK(mbedtls_ecp_copy(&RP, P));
   2603          
   2604              /* Set R to zero in modified x/z coordinates */
   2605              MPI_ECP_LSET(&R->X, 1);
   2606              MPI_ECP_LSET(&R->Z, 0);
   2607              mbedtls_mpi_free(&R->Y);
   2608          
   2609              /* RP.X might be slightly larger than P, so reduce it */
   2610              MOD_ADD(&RP.X);
   2611          
   2612              /* Randomize coordinates of the starting point */
   2613              MBEDTLS_MPI_CHK(ecp_randomize_mxz(grp, &RP, f_rng, p_rng));
   2614          
   2615              /* Loop invariant: R = result so far, RP = R + P */
   2616              i = grp->nbits + 1; /* one past the (zero-based) required msb for private keys */
   2617              while (i-- > 0) {
   2618                  b = mbedtls_mpi_get_bit(m, i);
   2619                  /*
   2620                   *  if (b) R = 2R + P else R = 2R,
   2621                   * which is:
   2622                   *  if (b) double_add( RP, R, RP, R )
   2623                   *  else   double_add( R, RP, R, RP )
   2624                   * but using safe conditional swaps to avoid leaks
   2625                   */
   2626                  MPI_ECP_COND_SWAP(&R->X, &RP.X, b);
   2627                  MPI_ECP_COND_SWAP(&R->Z, &RP.Z, b);
   2628                  MBEDTLS_MPI_CHK(ecp_double_add_mxz(grp, R, &RP, R, &RP, &PX, tmp));
   2629                  MPI_ECP_COND_SWAP(&R->X, &RP.X, b);
   2630                  MPI_ECP_COND_SWAP(&R->Z, &RP.Z, b);
   2631              }
   2632          
   2633              /*
   2634               * Knowledge of the projective coordinates may leak the last few bits of the
   2635               * scalar [1], and since our MPI implementation isn't constant-flow,
   2636               * inversion (used for coordinate normalization) may leak the full value
   2637               * of its input via side-channels [2].
   2638               *
   2639               * [1] https://eprint.iacr.org/2003/191
   2640               * [2] https://eprint.iacr.org/2020/055
   2641               *
   2642               * Avoid the leak by randomizing coordinates before we normalize them.
   2643               */
   2644              MBEDTLS_MPI_CHK(ecp_randomize_mxz(grp, R, f_rng, p_rng));
   2645              MBEDTLS_MPI_CHK(ecp_normalize_mxz(grp, R));
   2646          
   2647          cleanup:
   2648              mbedtls_ecp_point_free(&RP); mbedtls_mpi_free(&PX);
   2649          
   2650              mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   2651              return ret;
   2652          }
   2653          
   2654          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   2655          
   2656          /*
   2657           * Restartable multiplication R = m * P
   2658           *
   2659           * This internal function can be called without an RNG in case where we know
   2660           * the inputs are not sensitive.
   2661           */

   \                                 In section .text, align 2, keep-with-next
   2662          static int ecp_mul_restartable_internal(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2663                                                  const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2664                                                  int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   2665                                                  mbedtls_ecp_restart_ctx *rs_ctx)
   2666          {
   \                     ecp_mul_restartable_internal: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   2667              int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable20
   \       0x10   0x46C1             MOV      R9,R8
   2668              int restarting = 0;
   \       0x12   0x2400             MOVS     R4,#+0
   2669          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2670              char is_grp_capable = 0;
   2671          #endif
   2672          
   2673          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2674              /* reset ops count for this call if top-level */
   2675              if (rs_ctx != NULL && rs_ctx->depth++ == 0) {
   2676                  rs_ctx->ops_done = 0;
   2677              }
   2678          #else
   2679              (void) rs_ctx;
   2680          #endif
   2681          
   2682          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2683              if ((is_grp_capable = mbedtls_internal_ecp_grp_capable(grp))) {
   2684                  MBEDTLS_MPI_CHK(mbedtls_internal_ecp_init(grp));
   2685              }
   2686          #endif /* MBEDTLS_ECP_INTERNAL_ALT */
   2687          
   2688          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2689              restarting = (rs_ctx != NULL && rs_ctx->rsm != NULL);
   2690          #endif
   2691              /* skip argument check when restarting */
   2692              if (!restarting) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD10D             BNE.N    ??ecp_mul_restartable_internal_0
   2693                  /* check_privkey is free */
   2694                  MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_CHK);
   2695          
   2696                  /* Common sanity checks */
   2697                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_privkey(grp, m));
   \       0x18   0x0031             MOVS     R1,R6
   \       0x1A   0x4650             MOV      R0,R10
   \       0x1C   0x.... 0x....      BL       mbedtls_ecp_check_privkey
   \       0x20   0x4681             MOV      R9,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD11B             BNE.N    ??ecp_mul_restartable_internal_1
   2698                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   \                     ??ecp_mul_restartable_internal_2: (+1)
   \       0x26   0x0039             MOVS     R1,R7
   \       0x28   0x4650             MOV      R0,R10
   \       0x2A   0x.... 0x....      BL       mbedtls_ecp_check_pubkey
   \       0x2E   0x4681             MOV      R9,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD114             BNE.N    ??ecp_mul_restartable_internal_1
   2699              }
   2700          
   2701              ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??ecp_mul_restartable_internal_3: (+1)
   \                     ??ecp_mul_restartable_internal_0: (+1)
   \       0x34   0x46C1             MOV      R9,R8
   2702          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   2703              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   2704                  MBEDTLS_MPI_CHK(ecp_mul_mxz(grp, R, m, P, f_rng, p_rng));
   2705              }
   2706          #endif
   2707          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   2708              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x36   0x4650             MOV      R0,R10
   \       0x38   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xD10E             BNE.N    ??ecp_mul_restartable_internal_1
   2709                  MBEDTLS_MPI_CHK(ecp_mul_comb(grp, R, m, P, f_rng, p_rng, rs_ctx));
   \       0x40   0x980E             LDR      R0,[SP, #+56]
   \       0x42   0x9002             STR      R0,[SP, #+8]
   \       0x44   0x980D             LDR      R0,[SP, #+52]
   \       0x46   0x9001             STR      R0,[SP, #+4]
   \       0x48   0x980C             LDR      R0,[SP, #+48]
   \       0x4A   0x9000             STR      R0,[SP, #+0]
   \       0x4C   0x003B             MOVS     R3,R7
   \       0x4E   0x0032             MOVS     R2,R6
   \       0x50   0x0029             MOVS     R1,R5
   \       0x52   0x4650             MOV      R0,R10
   \       0x54   0x.... 0x....      BL       ecp_mul_comb
   \       0x58   0x4681             MOV      R9,R0
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD1FF             BNE.N    ??ecp_mul_restartable_internal_1
   2710              }
   2711          #endif
   2712          
   2713          cleanup:
   2714          
   2715          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2716              if (is_grp_capable) {
   2717                  mbedtls_internal_ecp_free(grp);
   2718              }
   2719          #endif /* MBEDTLS_ECP_INTERNAL_ALT */
   2720          
   2721          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2722              if (rs_ctx != NULL) {
   2723                  rs_ctx->depth--;
   2724              }
   2725          #endif
   2726          
   2727              return ret;
   \                     ??ecp_mul_restartable_internal_4: (+1)
   \                     ??ecp_mul_restartable_internal_1: (+1)
   \       0x5E   0x4648             MOV      R0,R9
   \       0x60   0xB004             ADD      SP,SP,#+16
   \       0x62   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2728          }
   2729          
   2730          /*
   2731           * Restartable multiplication R = m * P
   2732           */

   \                                 In section .text, align 2, keep-with-next
   2733          int mbedtls_ecp_mul_restartable(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2734                                          const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2735                                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   2736                                          mbedtls_ecp_restart_ctx *rs_ctx)
   2737          {
   \                     mbedtls_ecp_mul_restartable: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   2738              if (f_rng == NULL) {
   \       0x10   0x4640             MOV      R0,R8
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??mbedtls_ecp_mul_restartable_0
   2739                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x16   0x....             LDR.N    R0,??DataTable20
   \       0x18   0xE00B             B.N      ??mbedtls_ecp_mul_restartable_1
   2740              }
   2741          
   2742              return ecp_mul_restartable_internal(grp, R, m, P, f_rng, p_rng, rs_ctx);
   \                     ??mbedtls_ecp_mul_restartable_0: (+1)
   \       0x1A   0x980C             LDR      R0,[SP, #+48]
   \       0x1C   0x9002             STR      R0,[SP, #+8]
   \       0x1E   0x980B             LDR      R0,[SP, #+44]
   \       0x20   0x9001             STR      R0,[SP, #+4]
   \       0x22   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x26   0x003B             MOVS     R3,R7
   \       0x28   0x0032             MOVS     R2,R6
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       ecp_mul_restartable_internal
   \                     ??mbedtls_ecp_mul_restartable_1: (+1)
   \       0x32   0xB004             ADD      SP,SP,#+16
   \       0x34   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2743          }
   2744          
   2745          /*
   2746           * Multiplication R = m * P
   2747           */

   \                                 In section .text, align 2, keep-with-next
   2748          int mbedtls_ecp_mul(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2749                              const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2750                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   2751          {
   \                     mbedtls_ecp_mul: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   2752              return mbedtls_ecp_mul_restartable(grp, R, m, P, f_rng, p_rng, NULL);
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9002             STR      R0,[SP, #+8]
   \        0xE   0x9809             LDR      R0,[SP, #+36]
   \       0x10   0x9001             STR      R0,[SP, #+4]
   \       0x12   0x9808             LDR      R0,[SP, #+32]
   \       0x14   0x9000             STR      R0,[SP, #+0]
   \       0x16   0x003B             MOVS     R3,R7
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       mbedtls_ecp_mul_restartable
   \       0x22   0xBDFE             POP      {R1-R7,PC}
   2753          }
   2754          #endif /* MBEDTLS_ECP_C */
   2755          
   2756          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   2757          /*
   2758           * Check that an affine point is valid as a public key,
   2759           * short weierstrass curves (SEC1 3.2.3.1)
   2760           */

   \                                 In section .text, align 2, keep-with-next
   2761          static int ecp_check_pubkey_sw(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt)
   2762          {
   \                     ecp_check_pubkey_sw: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   2763              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x076D      MVNS     R7,#+109
   2764              mbedtls_mpi YY, RHS;
   2765          
   2766              /* pt coordinates must be normalized for our checks */
   2767              if (mbedtls_mpi_cmp_int(&pt->X, 0) < 0 ||
   2768                  mbedtls_mpi_cmp_int(&pt->Y, 0) < 0 ||
   2769                  mbedtls_mpi_cmp_mpi(&pt->X, &grp->P) >= 0 ||
   2770                  mbedtls_mpi_cmp_mpi(&pt->Y, &grp->P) >= 0) {
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD413             BMI.N    ??ecp_check_pubkey_sw_0
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD40C             BMI.N    ??ecp_check_pubkey_sw_0
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD506             BPL.N    ??ecp_check_pubkey_sw_0
   \       0x32   0x1D21             ADDS     R1,R4,#+4
   \       0x34   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD402             BMI.N    ??ecp_check_pubkey_sw_1
   2771                  return MBEDTLS_ERR_ECP_INVALID_KEY;
   \                     ??ecp_check_pubkey_sw_0: (+1)
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \       0x44   0xE028             B.N      ??ecp_check_pubkey_sw_2
   2772              }
   2773          
   2774              mbedtls_mpi_init(&YY); mbedtls_mpi_init(&RHS);
   \                     ??ecp_check_pubkey_sw_1: (+1)
   \       0x46   0xA802             ADD      R0,SP,#+8
   \       0x48   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x4C   0x4668             MOV      R0,SP
   \       0x4E   0x.... 0x....      BL       mbedtls_mpi_init
   2775          
   2776              /*
   2777               * YY = Y^2
   2778               * RHS = X^3 + A X + B
   2779               */
   2780              MPI_ECP_SQR(&YY,  &pt->Y);
   \       0x52   0xF115 0x0308      ADDS     R3,R5,#+8
   \       0x56   0xF115 0x0208      ADDS     R2,R5,#+8
   \       0x5A   0xA902             ADD      R1,SP,#+8
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0x62   0x0006             MOVS     R6,R0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD110             BNE.N    ??ecp_check_pubkey_sw_3
   2781              MBEDTLS_MPI_CHK(ecp_sw_rhs(grp, &RHS, &pt->X));
   \                     ??ecp_check_pubkey_sw_4: (+1)
   \       0x68   0x002A             MOVS     R2,R5
   \       0x6A   0x4669             MOV      R1,SP
   \       0x6C   0x0020             MOVS     R0,R4
   \       0x6E   0x.... 0x....      BL       ecp_sw_rhs
   \       0x72   0x0006             MOVS     R6,R0
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD108             BNE.N    ??ecp_check_pubkey_sw_3
   2782          
   2783              if (MPI_ECP_CMP(&YY, &RHS) != 0) {
   \                     ??ecp_check_pubkey_sw_5: (+1)
   \       0x78   0x4669             MOV      R1,SP
   \       0x7A   0xA802             ADD      R0,SP,#+8
   \       0x7C   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD002             BEQ.N    ??ecp_check_pubkey_sw_3
   2784                  ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \       0x88   0x0006             MOVS     R6,R0
   2785              }
   2786          
   2787          cleanup:
   2788          
   2789              mbedtls_mpi_free(&YY); mbedtls_mpi_free(&RHS);
   \                     ??ecp_check_pubkey_sw_3: (+1)
   \       0x8A   0xA802             ADD      R0,SP,#+8
   \       0x8C   0x.... 0x....      BL       mbedtls_mpi_free
   \       0x90   0x4668             MOV      R0,SP
   \       0x92   0x.... 0x....      BL       mbedtls_mpi_free
   2790          
   2791              return ret;
   \       0x96   0x0030             MOVS     R0,R6
   \                     ??ecp_check_pubkey_sw_2: (+1)
   \       0x98   0xB005             ADD      SP,SP,#+20
   \       0x9A   0xBDF0             POP      {R4-R7,PC}
   2792          }
   2793          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   2794          
   2795          #if defined(MBEDTLS_ECP_C)
   2796          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   2797          /*
   2798           * R = m * P with shortcuts for m == 0, m == 1 and m == -1
   2799           * NOT constant-time - ONLY for short Weierstrass!
   2800           */

   \                                 In section .text, align 2, keep-with-next
   2801          static int mbedtls_ecp_mul_shortcuts(mbedtls_ecp_group *grp,
   2802                                               mbedtls_ecp_point *R,
   2803                                               const mbedtls_mpi *m,
   2804                                               const mbedtls_ecp_point *P,
   2805                                               mbedtls_ecp_restart_ctx *rs_ctx)
   2806          {
   \                     mbedtls_ecp_mul_shortcuts: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
   2807              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x076D      MVNS     R7,#+109
   2808              mbedtls_mpi tmp;
   2809              mbedtls_mpi_init(&tmp);
   \       0x12   0xA803             ADD      R0,SP,#+12
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_init
   2810          
   2811              if (mbedtls_mpi_cmp_int(m, 0) == 0) {
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD10D             BNE.N    ??mbedtls_ecp_mul_shortcuts_0
   2812                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   \       0x24   0x0031             MOVS     R1,R6
   \       0x26   0x4648             MOV      R0,R9
   \       0x28   0x.... 0x....      BL       mbedtls_ecp_check_pubkey
   \       0x2C   0x4680             MOV      R8,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD15E             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   2813                  MBEDTLS_MPI_CHK(mbedtls_ecp_set_zero(R));
   \                     ??mbedtls_ecp_mul_shortcuts_2: (+1)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       mbedtls_ecp_set_zero
   \       0x38   0x4680             MOV      R8,R0
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD158             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   \                     ??mbedtls_ecp_mul_shortcuts_3: (+1)
   \       0x3E   0xE057             B.N      ??mbedtls_ecp_mul_shortcuts_1
   2814              } else if (mbedtls_mpi_cmp_int(m, 1) == 0) {
   \                     ??mbedtls_ecp_mul_shortcuts_0: (+1)
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD10E             BNE.N    ??mbedtls_ecp_mul_shortcuts_4
   2815                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   \       0x4C   0x0031             MOVS     R1,R6
   \       0x4E   0x4648             MOV      R0,R9
   \       0x50   0x.... 0x....      BL       mbedtls_ecp_check_pubkey
   \       0x54   0x4680             MOV      R8,R0
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD14A             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   2816                  MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, P));
   \                     ??mbedtls_ecp_mul_shortcuts_5: (+1)
   \       0x5A   0x0031             MOVS     R1,R6
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x62   0x4680             MOV      R8,R0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD143             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   \                     ??mbedtls_ecp_mul_shortcuts_6: (+1)
   \       0x68   0xE042             B.N      ??mbedtls_ecp_mul_shortcuts_1
   2817              } else if (mbedtls_mpi_cmp_int(m, -1) == 0) {
   \                     ??mbedtls_ecp_mul_shortcuts_4: (+1)
   \       0x6A   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x6E   0x0028             MOVS     R0,R5
   \       0x70   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD12C             BNE.N    ??mbedtls_ecp_mul_shortcuts_7
   2818                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   \       0x78   0x0031             MOVS     R1,R6
   \       0x7A   0x4648             MOV      R0,R9
   \       0x7C   0x.... 0x....      BL       mbedtls_ecp_check_pubkey
   \       0x80   0x4680             MOV      R8,R0
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD134             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   2819                  MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, P));
   \                     ??mbedtls_ecp_mul_shortcuts_8: (+1)
   \       0x86   0x0031             MOVS     R1,R6
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x8E   0x4680             MOV      R8,R0
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD12D             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   2820                  MPI_ECP_NEG(&R->Y);
   \                     ??mbedtls_ecp_mul_shortcuts_9: (+1)
   \       0x94   0x2100             MOVS     R1,#+0
   \       0x96   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x9A   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD001             BEQ.N    ??mbedtls_ecp_mul_shortcuts_10
   \       0xA2   0x2701             MOVS     R7,#+1
   \       0xA4   0xE000             B.N      ??mbedtls_ecp_mul_shortcuts_11
   \                     ??mbedtls_ecp_mul_shortcuts_10: (+1)
   \       0xA6   0x2700             MOVS     R7,#+0
   \                     ??mbedtls_ecp_mul_shortcuts_11: (+1)
   \       0xA8   0xF114 0x0208      ADDS     R2,R4,#+8
   \       0xAC   0xF119 0x0104      ADDS     R1,R9,#+4
   \       0xB0   0xA803             ADD      R0,SP,#+12
   \       0xB2   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0xB6   0x4680             MOV      R8,R0
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD119             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   \                     ??mbedtls_ecp_mul_shortcuts_12: (+1)
   \       0xBC   0xF017 0x0201      ANDS     R2,R7,#0x1
   \       0xC0   0xA903             ADD      R1,SP,#+12
   \       0xC2   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0xC6   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0xCA   0x4680             MOV      R8,R0
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD10F             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   \                     ??mbedtls_ecp_mul_shortcuts_13: (+1)
   \       0xD0   0xE00E             B.N      ??mbedtls_ecp_mul_shortcuts_1
   2821              } else {
   2822                  MBEDTLS_MPI_CHK(ecp_mul_restartable_internal(grp, R, m, P,
   2823                                                               NULL, NULL, rs_ctx));
   \                     ??mbedtls_ecp_mul_shortcuts_7: (+1)
   \       0xD2   0x980C             LDR      R0,[SP, #+48]
   \       0xD4   0x9002             STR      R0,[SP, #+8]
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x9001             STR      R0,[SP, #+4]
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0x9000             STR      R0,[SP, #+0]
   \       0xDE   0x0033             MOVS     R3,R6
   \       0xE0   0x002A             MOVS     R2,R5
   \       0xE2   0x0021             MOVS     R1,R4
   \       0xE4   0x4648             MOV      R0,R9
   \       0xE6   0x.... 0x....      BL       ecp_mul_restartable_internal
   \       0xEA   0x4680             MOV      R8,R0
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD1FF             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   2824              }
   2825          
   2826          cleanup:
   2827              mbedtls_mpi_free(&tmp);
   \                     ??mbedtls_ecp_mul_shortcuts_14: (+1)
   \                     ??mbedtls_ecp_mul_shortcuts_1: (+1)
   \       0xF0   0xA803             ADD      R0,SP,#+12
   \       0xF2   0x.... 0x....      BL       mbedtls_mpi_free
   2828          
   2829              return ret;
   \       0xF6   0x4640             MOV      R0,R8
   \       0xF8   0xB005             ADD      SP,SP,#+20
   \       0xFA   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2830          }
   2831          
   2832          /*
   2833           * Restartable linear combination
   2834           * NOT constant-time
   2835           */

   \                                 In section .text, align 2, keep-with-next
   2836          int mbedtls_ecp_muladd_restartable(
   2837              mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2838              const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2839              const mbedtls_mpi *n, const mbedtls_ecp_point *Q,
   2840              mbedtls_ecp_restart_ctx *rs_ctx)
   2841          {
   \                     mbedtls_ecp_muladd_restartable: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB091             SUB      SP,SP,#+68
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
   \        0xE   0x9F1A             LDR      R7,[SP, #+104]
   \       0x10   0xF8DD 0x806C      LDR      R8,[SP, #+108]
   \       0x14   0xF8DD 0x9070      LDR      R9,[SP, #+112]
   2842              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x18   0xF07F 0x006D      MVNS     R0,#+109
   \       0x1C   0x9001             STR      R0,[SP, #+4]
   2843              mbedtls_ecp_point mP;
   2844              mbedtls_ecp_point *pmP = &mP;
   \       0x1E   0xF10D 0x0A2C      ADD      R10,SP,#+44
   2845              mbedtls_ecp_point *pR = R;
   \       0x22   0x9402             STR      R4,[SP, #+8]
   2846              mbedtls_mpi tmp[4];
   2847          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2848              char is_grp_capable = 0;
   2849          #endif
   2850              if (mbedtls_ecp_get_type(grp) != MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x24   0x4658             MOV      R0,R11
   \       0x26   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD002             BEQ.N    ??mbedtls_ecp_muladd_restartable_0
   2851                  return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \       0x32   0xE036             B.N      ??mbedtls_ecp_muladd_restartable_1
   2852              }
   2853          
   2854              mbedtls_ecp_point_init(&mP);
   \                     ??mbedtls_ecp_muladd_restartable_0: (+1)
   \       0x34   0xA80B             ADD      R0,SP,#+44
   \       0x36   0x.... 0x....      BL       mbedtls_ecp_point_init
   2855              mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   \       0x3A   0x2104             MOVS     R1,#+4
   \       0x3C   0xA803             ADD      R0,SP,#+12
   \       0x3E   0x.... 0x....      BL       mpi_init_many
   2856          
   2857              ECP_RS_ENTER(ma);
   2858          
   2859          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2860              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2861                  /* redirect intermediate results to restart context */
   2862                  pmP = &rs_ctx->ma->mP;
   2863                  pR  = &rs_ctx->ma->R;
   2864          
   2865                  /* jump to next operation */
   2866                  if (rs_ctx->ma->state == ecp_rsma_mul2) {
   2867                      goto mul2;
   2868                  }
   2869                  if (rs_ctx->ma->state == ecp_rsma_add) {
   2870                      goto add;
   2871                  }
   2872                  if (rs_ctx->ma->state == ecp_rsma_norm) {
   2873                      goto norm;
   2874                  }
   2875              }
   2876          #endif /* MBEDTLS_ECP_RESTARTABLE */
   2877          
   2878              MBEDTLS_MPI_CHK(mbedtls_ecp_mul_shortcuts(grp, pmP, m, P, rs_ctx));
   \       0x42   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x46   0x0033             MOVS     R3,R6
   \       0x48   0x002A             MOVS     R2,R5
   \       0x4A   0x4651             MOV      R1,R10
   \       0x4C   0x4658             MOV      R0,R11
   \       0x4E   0x.... 0x....      BL       mbedtls_ecp_mul_shortcuts
   \       0x52   0x9001             STR      R0,[SP, #+4]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD11C             BNE.N    ??mbedtls_ecp_muladd_restartable_2
   2879          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2880              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2881                  rs_ctx->ma->state = ecp_rsma_mul2;
   2882              }
   2883          
   2884          mul2:
   2885          #endif
   2886              MBEDTLS_MPI_CHK(mbedtls_ecp_mul_shortcuts(grp, pR,  n, Q, rs_ctx));
   \                     ??mbedtls_ecp_muladd_restartable_3: (+1)
   \       0x58   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x5C   0x4643             MOV      R3,R8
   \       0x5E   0x003A             MOVS     R2,R7
   \       0x60   0x9902             LDR      R1,[SP, #+8]
   \       0x62   0x4658             MOV      R0,R11
   \       0x64   0x.... 0x....      BL       mbedtls_ecp_mul_shortcuts
   \       0x68   0x9001             STR      R0,[SP, #+4]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD111             BNE.N    ??mbedtls_ecp_muladd_restartable_2
   2887          
   2888          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2889              if ((is_grp_capable = mbedtls_internal_ecp_grp_capable(grp))) {
   2890                  MBEDTLS_MPI_CHK(mbedtls_internal_ecp_init(grp));
   2891              }
   2892          #endif /* MBEDTLS_ECP_INTERNAL_ALT */
   2893          
   2894          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2895              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2896                  rs_ctx->ma->state = ecp_rsma_add;
   2897              }
   2898          
   2899          add:
   2900          #endif
   2901              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_ADD);
   2902              MBEDTLS_MPI_CHK(ecp_add_mixed(grp, pR, pmP, pR, tmp));
   \                     ??mbedtls_ecp_muladd_restartable_4: (+1)
   \       0x6E   0xA803             ADD      R0,SP,#+12
   \       0x70   0x9000             STR      R0,[SP, #+0]
   \       0x72   0x9B02             LDR      R3,[SP, #+8]
   \       0x74   0x4652             MOV      R2,R10
   \       0x76   0x9902             LDR      R1,[SP, #+8]
   \       0x78   0x4658             MOV      R0,R11
   \       0x7A   0x.... 0x....      BL       ecp_add_mixed
   \       0x7E   0x9001             STR      R0,[SP, #+4]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD106             BNE.N    ??mbedtls_ecp_muladd_restartable_2
   2903          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2904              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2905                  rs_ctx->ma->state = ecp_rsma_norm;
   2906              }
   2907          
   2908          norm:
   2909          #endif
   2910              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV);
   2911              MBEDTLS_MPI_CHK(ecp_normalize_jac(grp, pR));
   \                     ??mbedtls_ecp_muladd_restartable_5: (+1)
   \       0x84   0x9902             LDR      R1,[SP, #+8]
   \       0x86   0x4658             MOV      R0,R11
   \       0x88   0x.... 0x....      BL       ecp_normalize_jac
   \       0x8C   0x9001             STR      R0,[SP, #+4]
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD1FF             BNE.N    ??mbedtls_ecp_muladd_restartable_2
   2912          
   2913          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2914              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2915                  MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, pR));
   2916              }
   2917          #endif
   2918          
   2919          cleanup:
   2920          
   2921              mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   \                     ??mbedtls_ecp_muladd_restartable_6: (+1)
   \                     ??mbedtls_ecp_muladd_restartable_2: (+1)
   \       0x92   0x2104             MOVS     R1,#+4
   \       0x94   0xA803             ADD      R0,SP,#+12
   \       0x96   0x.... 0x....      BL       mpi_free_many
   2922          
   2923          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2924              if (is_grp_capable) {
   2925                  mbedtls_internal_ecp_free(grp);
   2926              }
   2927          #endif /* MBEDTLS_ECP_INTERNAL_ALT */
   2928          
   2929              mbedtls_ecp_point_free(&mP);
   \       0x9A   0xA80B             ADD      R0,SP,#+44
   \       0x9C   0x.... 0x....      BL       mbedtls_ecp_point_free
   2930          
   2931              ECP_RS_LEAVE(ma);
   2932          
   2933              return ret;
   \       0xA0   0x9801             LDR      R0,[SP, #+4]
   \                     ??mbedtls_ecp_muladd_restartable_1: (+1)
   \       0xA2   0xB011             ADD      SP,SP,#+68
   \       0xA4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2934          }
   2935          
   2936          /*
   2937           * Linear combination
   2938           * NOT constant-time
   2939           */

   \                                 In section .text, align 2, keep-with-next
   2940          int mbedtls_ecp_muladd(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2941                                 const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2942                                 const mbedtls_mpi *n, const mbedtls_ecp_point *Q)
   2943          {
   \                     mbedtls_ecp_muladd: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   2944              return mbedtls_ecp_muladd_restartable(grp, R, m, P, n, Q, NULL);
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9002             STR      R0,[SP, #+8]
   \        0xE   0x9809             LDR      R0,[SP, #+36]
   \       0x10   0x9001             STR      R0,[SP, #+4]
   \       0x12   0x9808             LDR      R0,[SP, #+32]
   \       0x14   0x9000             STR      R0,[SP, #+0]
   \       0x16   0x003B             MOVS     R3,R7
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       mbedtls_ecp_muladd_restartable
   \       0x22   0xBDFE             POP      {R1-R7,PC}
   2945          }
   2946          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   2947          #endif /* MBEDTLS_ECP_C */
   2948          
   2949          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   2950          #if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
   2951          #define ECP_MPI_INIT(_p, _n) { .p = (mbedtls_mpi_uint *) (_p), .s = 1, .n = (_n) }
   2952          #define ECP_MPI_INIT_ARRAY(x)   \
   2953              ECP_MPI_INIT(x, sizeof(x) / sizeof(mbedtls_mpi_uint))
   2954          /*
   2955           * Constants for the two points other than 0, 1, -1 (mod p) in
   2956           * https://cr.yp.to/ecdh.html#validate
   2957           * See ecp_check_pubkey_x25519().
   2958           */
   2959          static const mbedtls_mpi_uint x25519_bad_point_1[] = {
   2960              MBEDTLS_BYTES_TO_T_UINT_8(0xe0, 0xeb, 0x7a, 0x7c, 0x3b, 0x41, 0xb8, 0xae),
   2961              MBEDTLS_BYTES_TO_T_UINT_8(0x16, 0x56, 0xe3, 0xfa, 0xf1, 0x9f, 0xc4, 0x6a),
   2962              MBEDTLS_BYTES_TO_T_UINT_8(0xda, 0x09, 0x8d, 0xeb, 0x9c, 0x32, 0xb1, 0xfd),
   2963              MBEDTLS_BYTES_TO_T_UINT_8(0x86, 0x62, 0x05, 0x16, 0x5f, 0x49, 0xb8, 0x00),
   2964          };
   2965          static const mbedtls_mpi_uint x25519_bad_point_2[] = {
   2966              MBEDTLS_BYTES_TO_T_UINT_8(0x5f, 0x9c, 0x95, 0xbc, 0xa3, 0x50, 0x8c, 0x24),
   2967              MBEDTLS_BYTES_TO_T_UINT_8(0xb1, 0xd0, 0xb1, 0x55, 0x9c, 0x83, 0xef, 0x5b),
   2968              MBEDTLS_BYTES_TO_T_UINT_8(0x04, 0x44, 0x5c, 0xc4, 0x58, 0x1c, 0x8e, 0x86),
   2969              MBEDTLS_BYTES_TO_T_UINT_8(0xd8, 0x22, 0x4e, 0xdd, 0xd0, 0x9f, 0x11, 0x57),
   2970          };
   2971          static const mbedtls_mpi ecp_x25519_bad_point_1 = ECP_MPI_INIT_ARRAY(
   2972              x25519_bad_point_1);
   2973          static const mbedtls_mpi ecp_x25519_bad_point_2 = ECP_MPI_INIT_ARRAY(
   2974              x25519_bad_point_2);
   2975          #endif /* MBEDTLS_ECP_DP_CURVE25519_ENABLED */
   2976          
   2977          /*
   2978           * Check that the input point is not one of the low-order points.
   2979           * This is recommended by the "May the Fourth" paper:
   2980           * https://eprint.iacr.org/2017/806.pdf
   2981           * Those points are never sent by an honest peer.
   2982           */
   2983          static int ecp_check_bad_points_mx(const mbedtls_mpi *X, const mbedtls_mpi *P,
   2984                                             const mbedtls_ecp_group_id grp_id)
   2985          {
   2986              int ret;
   2987              mbedtls_mpi XmP;
   2988          
   2989              mbedtls_mpi_init(&XmP);
   2990          
   2991              /* Reduce X mod P so that we only need to check values less than P.
   2992               * We know X < 2^256 so we can proceed by subtraction. */
   2993              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&XmP, X));
   2994              while (mbedtls_mpi_cmp_mpi(&XmP, P) >= 0) {
   2995                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&XmP, &XmP, P));
   2996              }
   2997          
   2998              /* Check against the known bad values that are less than P. For Curve448
   2999               * these are 0, 1 and -1. For Curve25519 we check the values less than P
   3000               * from the following list: https://cr.yp.to/ecdh.html#validate */
   3001              if (mbedtls_mpi_cmp_int(&XmP, 1) <= 0) {  /* takes care of 0 and 1 */
   3002                  ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   3003                  goto cleanup;
   3004              }
   3005          
   3006          #if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
   3007              if (grp_id == MBEDTLS_ECP_DP_CURVE25519) {
   3008                  if (mbedtls_mpi_cmp_mpi(&XmP, &ecp_x25519_bad_point_1) == 0) {
   3009                      ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   3010                      goto cleanup;
   3011                  }
   3012          
   3013                  if (mbedtls_mpi_cmp_mpi(&XmP, &ecp_x25519_bad_point_2) == 0) {
   3014                      ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   3015                      goto cleanup;
   3016                  }
   3017              }
   3018          #else
   3019              (void) grp_id;
   3020          #endif
   3021          
   3022              /* Final check: check if XmP + 1 is P (final because it changes XmP!) */
   3023              MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&XmP, &XmP, 1));
   3024              if (mbedtls_mpi_cmp_mpi(&XmP, P) == 0) {
   3025                  ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   3026                  goto cleanup;
   3027              }
   3028          
   3029              ret = 0;
   3030          
   3031          cleanup:
   3032              mbedtls_mpi_free(&XmP);
   3033          
   3034              return ret;
   3035          }
   3036          
   3037          /*
   3038           * Check validity of a public key for Montgomery curves with x-only schemes
   3039           */
   3040          static int ecp_check_pubkey_mx(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt)
   3041          {
   3042              /* [Curve25519 p. 5] Just check X is the correct number of bytes */
   3043              /* Allow any public value, if it's too big then we'll just reduce it mod p
   3044               * (RFC 7748 sec. 5 para. 3). */
   3045              if (mbedtls_mpi_size(&pt->X) > (grp->nbits + 7) / 8) {
   3046                  return MBEDTLS_ERR_ECP_INVALID_KEY;
   3047              }
   3048          
   3049              /* Implicit in all standards (as they don't consider negative numbers):
   3050               * X must be non-negative. This is normally ensured by the way it's
   3051               * encoded for transmission, but let's be extra sure. */
   3052              if (mbedtls_mpi_cmp_int(&pt->X, 0) < 0) {
   3053                  return MBEDTLS_ERR_ECP_INVALID_KEY;
   3054              }
   3055          
   3056              return ecp_check_bad_points_mx(&pt->X, &grp->P, grp->id);
   3057          }
   3058          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3059          
   3060          /*
   3061           * Check that a point is valid as a public key
   3062           */

   \                                 In section .text, align 2, keep-with-next
   3063          int mbedtls_ecp_check_pubkey(const mbedtls_ecp_group *grp,
   3064                                       const mbedtls_ecp_point *pt)
   3065          {
   \                     mbedtls_ecp_check_pubkey: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   3066              /* Must use affine coordinates */
   3067              if (mbedtls_mpi_cmp_int(&pt->Z, 1) != 0) {
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0xF114 0x0010      ADDS     R0,R4,#+16
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD001             BEQ.N    ??mbedtls_ecp_check_pubkey_0
   3068                  return MBEDTLS_ERR_ECP_INVALID_KEY;
   \       0x14   0x....             LDR.N    R0,??DataTable26_2
   \       0x16   0xE00A             B.N      ??mbedtls_ecp_check_pubkey_1
   3069              }
   3070          
   3071          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3072              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3073                  return ecp_check_pubkey_mx(grp, pt);
   3074              }
   3075          #endif
   3076          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3077              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \                     ??mbedtls_ecp_check_pubkey_0: (+1)
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD104             BNE.N    ??mbedtls_ecp_check_pubkey_2
   3078                  return ecp_check_pubkey_sw(grp, pt);
   \       0x22   0x0021             MOVS     R1,R4
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       ecp_check_pubkey_sw
   \       0x2A   0xE000             B.N      ??mbedtls_ecp_check_pubkey_1
   3079              }
   3080          #endif
   3081              return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_check_pubkey_2: (+1)
   \       0x2C   0x....             LDR.N    R0,??DataTable20
   \                     ??mbedtls_ecp_check_pubkey_1: (+1)
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
   3082          }
   3083          
   3084          /*
   3085           * Check that an mbedtls_mpi is valid as a private key
   3086           */

   \                                 In section .text, align 2, keep-with-next
   3087          int mbedtls_ecp_check_privkey(const mbedtls_ecp_group *grp,
   3088                                        const mbedtls_mpi *d)
   3089          {
   \                     mbedtls_ecp_check_privkey: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   3090          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3091              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3092                  /* see RFC 7748 sec. 5 para. 5 */
   3093                  if (mbedtls_mpi_get_bit(d, 0) != 0 ||
   3094                      mbedtls_mpi_get_bit(d, 1) != 0 ||
   3095                      mbedtls_mpi_bitlen(d) - 1 != grp->nbits) {  /* mbedtls_mpi_bitlen is one-based! */
   3096                      return MBEDTLS_ERR_ECP_INVALID_KEY;
   3097                  }
   3098          
   3099                  /* see [Curve25519] page 5 */
   3100                  if (grp->nbits == 254 && mbedtls_mpi_get_bit(d, 2) != 0) {
   3101                      return MBEDTLS_ERR_ECP_INVALID_KEY;
   3102                  }
   3103          
   3104                  return 0;
   3105              }
   3106          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3107          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3108              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       mbedtls_ecp_get_type
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD110             BNE.N    ??mbedtls_ecp_check_privkey_0
   3109                  /* see SEC1 3.2 */
   3110                  if (mbedtls_mpi_cmp_int(d, 1) < 0 ||
   3111                      mbedtls_mpi_cmp_mpi(d, &grp->N) >= 0) {
   \       0x10   0x2101             MOVS     R1,#+1
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD406             BMI.N    ??mbedtls_ecp_check_privkey_1
   \       0x1C   0xF115 0x0134      ADDS     R1,R5,#+52
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD401             BMI.N    ??mbedtls_ecp_check_privkey_2
   3112                      return MBEDTLS_ERR_ECP_INVALID_KEY;
   \                     ??mbedtls_ecp_check_privkey_1: (+1)
   \       0x2A   0x....             LDR.N    R0,??DataTable26_2
   \       0x2C   0xE002             B.N      ??mbedtls_ecp_check_privkey_3
   3113                  } else {
   3114                      return 0;
   \                     ??mbedtls_ecp_check_privkey_2: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xE000             B.N      ??mbedtls_ecp_check_privkey_3
   3115                  }
   3116              }
   3117          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3118          
   3119              return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_check_privkey_0: (+1)
   \       0x32   0x....             LDR.N    R0,??DataTable26_4
   \                     ??mbedtls_ecp_check_privkey_3: (+1)
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}
   3120          }
   3121          
   3122          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3123          MBEDTLS_STATIC_TESTABLE
   3124          int mbedtls_ecp_gen_privkey_mx(size_t high_bit,
   3125                                         mbedtls_mpi *d,
   3126                                         int (*f_rng)(void *, unsigned char *, size_t),
   3127                                         void *p_rng)
   3128          {
   3129              int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   3130              size_t n_random_bytes = high_bit / 8 + 1;
   3131          
   3132              /* [Curve25519] page 5 */
   3133              /* Generate a (high_bit+1)-bit random number by generating just enough
   3134               * random bytes, then shifting out extra bits from the top (necessary
   3135               * when (high_bit+1) is not a multiple of 8). */
   3136              MBEDTLS_MPI_CHK(mbedtls_mpi_fill_random(d, n_random_bytes,
   3137                                                      f_rng, p_rng));
   3138              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(d, 8 * n_random_bytes - high_bit - 1));
   3139          
   3140              MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, high_bit, 1));
   3141          
   3142              /* Make sure the last two bits are unset for Curve448, three bits for
   3143                 Curve25519 */
   3144              MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, 0, 0));
   3145              MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, 1, 0));
   3146              if (high_bit == 254) {
   3147                  MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, 2, 0));
   3148              }
   3149          
   3150          cleanup:
   3151              return ret;
   3152          }
   3153          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3154          
   3155          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   3156          static int mbedtls_ecp_gen_privkey_sw(
   3157              const mbedtls_mpi *N, mbedtls_mpi *d,
   3158              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   3159          {
   \                     mbedtls_ecp_gen_privkey_sw: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   3160              int ret = mbedtls_mpi_random(d, 1, N, f_rng, p_rng);
   \        0xA   0x9700             STR      R7,[SP, #+0]
   \        0xC   0x0033             MOVS     R3,R6
   \        0xE   0x0022             MOVS     R2,R4
   \       0x10   0x2101             MOVS     R1,#+1
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_random
   \       0x18   0x0001             MOVS     R1,R0
   3161              switch (ret) {
   \       0x1A   0xF111 0x0F0E      CMN      R1,#+14
   \       0x1E   0xD101             BNE.N    ??mbedtls_ecp_gen_privkey_sw_0
   3162                  case MBEDTLS_ERR_MPI_NOT_ACCEPTABLE:
   3163                      return MBEDTLS_ERR_ECP_RANDOM_FAILED;
   \       0x20   0x....             LDR.N    R0,??DataTable26
   \       0x22   0xE000             B.N      ??mbedtls_ecp_gen_privkey_sw_1
   3164                  default:
   3165                      return ret;
   \                     ??mbedtls_ecp_gen_privkey_sw_0: (+1)
   \       0x24   0x0008             MOVS     R0,R1
   \                     ??mbedtls_ecp_gen_privkey_sw_1: (+1)
   \       0x26   0xBDF2             POP      {R1,R4-R7,PC}
   3166              }
   3167          }
   3168          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3169          
   3170          /*
   3171           * Generate a private key
   3172           */

   \                                 In section .text, align 2, keep-with-next
   3173          int mbedtls_ecp_gen_privkey(const mbedtls_ecp_group *grp,
   3174                                      mbedtls_mpi *d,
   3175                                      int (*f_rng)(void *, unsigned char *, size_t),
   3176                                      void *p_rng)
   3177          {
   \                     mbedtls_ecp_gen_privkey: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001E             MOVS     R6,R3
   3178          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3179              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3180                  return mbedtls_ecp_gen_privkey_mx(grp->nbits, d, f_rng, p_rng);
   3181              }
   3182          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3183          
   3184          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3185              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \        0xA   0x0038             MOVS     R0,R7
   \        0xC   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD107             BNE.N    ??mbedtls_ecp_gen_privkey_0
   3186                  return mbedtls_ecp_gen_privkey_sw(&grp->N, d, f_rng, p_rng);
   \       0x14   0x0033             MOVS     R3,R6
   \       0x16   0x002A             MOVS     R2,R5
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0xF117 0x0034      ADDS     R0,R7,#+52
   \       0x1E   0x.... 0x....      BL       mbedtls_ecp_gen_privkey_sw
   \       0x22   0xE000             B.N      ??mbedtls_ecp_gen_privkey_1
   3187              }
   3188          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3189          
   3190              return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_gen_privkey_0: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable26_4
   \                     ??mbedtls_ecp_gen_privkey_1: (+1)
   \       0x26   0xBDF2             POP      {R1,R4-R7,PC}
   3191          }
   3192          
   3193          #if defined(MBEDTLS_ECP_C)
   3194          /*
   3195           * Generate a keypair with configurable base point
   3196           */

   \                                 In section .text, align 2, keep-with-next
   3197          int mbedtls_ecp_gen_keypair_base(mbedtls_ecp_group *grp,
   3198                                           const mbedtls_ecp_point *G,
   3199                                           mbedtls_mpi *d, mbedtls_ecp_point *Q,
   3200                                           int (*f_rng)(void *, unsigned char *, size_t),
   3201                                           void *p_rng)
   3202          {
   \                     mbedtls_ecp_gen_keypair_base: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0C             LDR      R7,[SP, #+48]
   \        0xE   0xF8DD 0x8034      LDR      R8,[SP, #+52]
   3203              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x096D      MVNS     R9,#+109
   3204              MBEDTLS_MPI_CHK(mbedtls_ecp_gen_privkey(grp, d, f_rng, p_rng));
   \       0x16   0x4643             MOV      R3,R8
   \       0x18   0x003A             MOVS     R2,R7
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0x4658             MOV      R0,R11
   \       0x1E   0x.... 0x....      BL       mbedtls_ecp_gen_privkey
   \       0x22   0x4682             MOV      R10,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD10B             BNE.N    ??mbedtls_ecp_gen_keypair_base_0
   3205              MBEDTLS_MPI_CHK(mbedtls_ecp_mul(grp, Q, d, G, f_rng, p_rng));
   \                     ??mbedtls_ecp_gen_keypair_base_1: (+1)
   \       0x28   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x2C   0x9700             STR      R7,[SP, #+0]
   \       0x2E   0x0023             MOVS     R3,R4
   \       0x30   0x002A             MOVS     R2,R5
   \       0x32   0x0031             MOVS     R1,R6
   \       0x34   0x4658             MOV      R0,R11
   \       0x36   0x.... 0x....      BL       mbedtls_ecp_mul
   \       0x3A   0x4682             MOV      R10,R0
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD1FF             BNE.N    ??mbedtls_ecp_gen_keypair_base_0
   3206          
   3207          cleanup:
   3208              return ret;
   \                     ??mbedtls_ecp_gen_keypair_base_2: (+1)
   \                     ??mbedtls_ecp_gen_keypair_base_0: (+1)
   \       0x40   0x4650             MOV      R0,R10
   \       0x42   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   3209          }
   3210          
   3211          /*
   3212           * Generate key pair, wrapper for conventional base point
   3213           */

   \                                 In section .text, align 2, keep-with-next
   3214          int mbedtls_ecp_gen_keypair(mbedtls_ecp_group *grp,
   3215                                      mbedtls_mpi *d, mbedtls_ecp_point *Q,
   3216                                      int (*f_rng)(void *, unsigned char *, size_t),
   3217                                      void *p_rng)
   3218          {
   \                     mbedtls_ecp_gen_keypair: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   3219              return mbedtls_ecp_gen_keypair_base(grp, &grp->G, d, Q, f_rng, p_rng);
   \        0xA   0x9808             LDR      R0,[SP, #+32]
   \        0xC   0x9001             STR      R0,[SP, #+4]
   \        0xE   0x9700             STR      R7,[SP, #+0]
   \       0x10   0x0033             MOVS     R3,R6
   \       0x12   0x002A             MOVS     R2,R5
   \       0x14   0xF114 0x011C      ADDS     R1,R4,#+28
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       mbedtls_ecp_gen_keypair_base
   \       0x1E   0xBDFE             POP      {R1-R7,PC}
   3220          }
   3221          
   3222          /*
   3223           * Generate a keypair, prettier wrapper
   3224           */

   \                                 In section .text, align 2, keep-with-next
   3225          int mbedtls_ecp_gen_key(mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
   3226                                  int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   3227          {
   \                     mbedtls_ecp_gen_key: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   3228              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
   3229              if ((ret = mbedtls_ecp_group_load(&key->grp, grp_id)) != 0) {
   \       0x10   0x4649             MOV      R1,R9
   \       0x12   0xB2C9             UXTB     R1,R1
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       mbedtls_ecp_group_load
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD001             BEQ.N    ??mbedtls_ecp_gen_key_0
   3230                  return ret;
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0xE008             B.N      ??mbedtls_ecp_gen_key_1
   3231              }
   3232          
   3233              return mbedtls_ecp_gen_keypair(&key->grp, &key->d, &key->Q, f_rng, p_rng);
   \                     ??mbedtls_ecp_gen_key_0: (+1)
   \       0x24   0x9600             STR      R6,[SP, #+0]
   \       0x26   0x002B             MOVS     R3,R5
   \       0x28   0xF114 0x0268      ADDS     R2,R4,#+104
   \       0x2C   0xF114 0x0160      ADDS     R1,R4,#+96
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       mbedtls_ecp_gen_keypair
   \                     ??mbedtls_ecp_gen_key_1: (+1)
   \       0x36   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   3234          }
   3235          #endif /* MBEDTLS_ECP_C */
   3236          
   3237          #define ECP_CURVE25519_KEY_SIZE 32
   3238          #define ECP_CURVE448_KEY_SIZE   56
   3239          /*
   3240           * Read a private key.
   3241           */

   \                                 In section .text, align 2, keep-with-next
   3242          int mbedtls_ecp_read_key(mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
   3243                                   const unsigned char *buf, size_t buflen)
   3244          {
   \                     mbedtls_ecp_read_key: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3245              int ret = 0;
   \        0xC   0x2400             MOVS     R4,#+0
   3246          
   3247              if ((ret = mbedtls_ecp_group_load(&key->grp, grp_id)) != 0) {
   \        0xE   0x4641             MOV      R1,R8
   \       0x10   0xB2C9             UXTB     R1,R1
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       mbedtls_ecp_group_load
   \       0x18   0x4681             MOV      R9,R0
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??mbedtls_ecp_read_key_0
   3248                  return ret;
   \       0x1E   0x4648             MOV      R0,R9
   \       0x20   0xE01D             B.N      ??mbedtls_ecp_read_key_1
   3249              }
   3250          
   3251              ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_ecp_read_key_0: (+1)
   \       0x22   0x....             LDR.N    R4,??DataTable26_3
   3252          
   3253          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3254              if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3255                  /*
   3256                   * Mask the key as mandated by RFC7748 for Curve25519 and Curve448.
   3257                   */
   3258                  if (grp_id == MBEDTLS_ECP_DP_CURVE25519) {
   3259                      if (buflen != ECP_CURVE25519_KEY_SIZE) {
   3260                          return MBEDTLS_ERR_ECP_INVALID_KEY;
   3261                      }
   3262          
   3263                      MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary_le(&key->d, buf, buflen));
   3264          
   3265                      /* Set the three least significant bits to 0 */
   3266                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 0, 0));
   3267                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 1, 0));
   3268                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 2, 0));
   3269          
   3270                      /* Set the most significant bit to 0 */
   3271                      MBEDTLS_MPI_CHK(
   3272                          mbedtls_mpi_set_bit(&key->d,
   3273                                              ECP_CURVE25519_KEY_SIZE * 8 - 1, 0)
   3274                          );
   3275          
   3276                      /* Set the second most significant bit to 1 */
   3277                      MBEDTLS_MPI_CHK(
   3278                          mbedtls_mpi_set_bit(&key->d,
   3279                                              ECP_CURVE25519_KEY_SIZE * 8 - 2, 1)
   3280                          );
   3281                  } else if (grp_id == MBEDTLS_ECP_DP_CURVE448) {
   3282                      if (buflen != ECP_CURVE448_KEY_SIZE) {
   3283                          return MBEDTLS_ERR_ECP_INVALID_KEY;
   3284                      }
   3285          
   3286                      MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary_le(&key->d, buf, buflen));
   3287          
   3288                      /* Set the two least significant bits to 0 */
   3289                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 0, 0));
   3290                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 1, 0));
   3291          
   3292                      /* Set the most significant bit to 1 */
   3293                      MBEDTLS_MPI_CHK(
   3294                          mbedtls_mpi_set_bit(&key->d,
   3295                                              ECP_CURVE448_KEY_SIZE * 8 - 1, 1)
   3296                          );
   3297                  }
   3298              }
   3299          #endif
   3300          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3301              if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD108             BNE.N    ??mbedtls_ecp_read_key_2
   3302                  MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&key->d, buf, buflen));
   \       0x2E   0x003A             MOVS     R2,R7
   \       0x30   0x0031             MOVS     R1,R6
   \       0x32   0xF115 0x0060      ADDS     R0,R5,#+96
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_read_binary
   \       0x3A   0x0004             MOVS     R4,R0
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD107             BNE.N    ??mbedtls_ecp_read_key_3
   3303              }
   3304          #endif
   3305              MBEDTLS_MPI_CHK(mbedtls_ecp_check_privkey(&key->grp, &key->d));
   \                     ??mbedtls_ecp_read_key_4: (+1)
   \                     ??mbedtls_ecp_read_key_2: (+1)
   \       0x40   0xF115 0x0160      ADDS     R1,R5,#+96
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0x.... 0x....      BL       mbedtls_ecp_check_privkey
   \       0x4A   0x0004             MOVS     R4,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD1FF             BNE.N    ??mbedtls_ecp_read_key_3
   3306          
   3307          cleanup:
   3308          
   3309              if (ret != 0) {
   \                     ??mbedtls_ecp_read_key_5: (+1)
   \                     ??mbedtls_ecp_read_key_3: (+1)
   \       0x50   0x2C00             CMP      R4,#+0
   \       0x52   0xD003             BEQ.N    ??mbedtls_ecp_read_key_6
   3310                  mbedtls_mpi_free(&key->d);
   \       0x54   0xF115 0x0060      ADDS     R0,R5,#+96
   \       0x58   0x.... 0x....      BL       mbedtls_mpi_free
   3311              }
   3312          
   3313              return ret;
   \                     ??mbedtls_ecp_read_key_6: (+1)
   \       0x5C   0x0020             MOVS     R0,R4
   \                     ??mbedtls_ecp_read_key_1: (+1)
   \       0x5E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   3314          }
   3315          
   3316          /*
   3317           * Write a private key.
   3318           */

   \                                 In section .text, align 2, keep-with-next
   3319          int mbedtls_ecp_write_key(mbedtls_ecp_keypair *key,
   3320                                    unsigned char *buf, size_t buflen)
   3321          {
   \                     mbedtls_ecp_write_key: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   3322              int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \        0x8   0x....             LDR.N    R6,??DataTable26_3
   3323          
   3324          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3325              if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3326                  if (key->grp.id == MBEDTLS_ECP_DP_CURVE25519) {
   3327                      if (buflen < ECP_CURVE25519_KEY_SIZE) {
   3328                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   3329                      }
   3330          
   3331                  } else if (key->grp.id == MBEDTLS_ECP_DP_CURVE448) {
   3332                      if (buflen < ECP_CURVE448_KEY_SIZE) {
   3333                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   3334                      }
   3335                  }
   3336                  MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary_le(&key->d, buf, buflen));
   3337              }
   3338          #endif
   3339          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3340              if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \        0xA   0x0038             MOVS     R0,R7
   \        0xC   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD108             BNE.N    ??mbedtls_ecp_write_key_0
   3341                  MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&key->d, buf, buflen));
   \       0x14   0x002A             MOVS     R2,R5
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0xF117 0x0060      ADDS     R0,R7,#+96
   \       0x1C   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x20   0x0006             MOVS     R6,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD1FF             BNE.N    ??mbedtls_ecp_write_key_0
   3342              }
   3343          
   3344          #endif
   3345          cleanup:
   3346          
   3347              return ret;
   \                     ??mbedtls_ecp_write_key_1: (+1)
   \                     ??mbedtls_ecp_write_key_0: (+1)
   \       0x26   0x0030             MOVS     R0,R6
   \       0x28   0xBDF2             POP      {R1,R4-R7,PC}
   3348          }
   3349          
   3350          #if defined(MBEDTLS_ECP_C)
   3351          /*
   3352           * Check a public-private key pair
   3353           */

   \                                 In section .text, align 2, keep-with-next
   3354          int mbedtls_ecp_check_pub_priv(
   3355              const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv,
   3356              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   3357          {
   \                     mbedtls_ecp_check_pub_priv: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB0A0             SUB      SP,SP,#+128
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   3358              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x086D      MVNS     R8,#+109
   3359              mbedtls_ecp_point Q;
   3360              mbedtls_ecp_group grp;
   3361              if (pub->grp.id == MBEDTLS_ECP_DP_NONE ||
   3362                  pub->grp.id != prv->grp.id ||
   3363                  mbedtls_mpi_cmp_mpi(&pub->Q.X, &prv->Q.X) ||
   3364                  mbedtls_mpi_cmp_mpi(&pub->Q.Y, &prv->Q.Y) ||
   3365                  mbedtls_mpi_cmp_mpi(&pub->Q.Z, &prv->Q.Z)) {
   \       0x12   0x7820             LDRB     R0,[R4, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD01B             BEQ.N    ??mbedtls_ecp_check_pub_priv_0
   \       0x18   0x7821             LDRB     R1,[R4, #+0]
   \       0x1A   0x7828             LDRB     R0,[R5, #+0]
   \       0x1C   0x4281             CMP      R1,R0
   \       0x1E   0xD117             BNE.N    ??mbedtls_ecp_check_pub_priv_0
   \       0x20   0xF115 0x0168      ADDS     R1,R5,#+104
   \       0x24   0xF114 0x0068      ADDS     R0,R4,#+104
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD10F             BNE.N    ??mbedtls_ecp_check_pub_priv_0
   \       0x30   0xF115 0x0170      ADDS     R1,R5,#+112
   \       0x34   0xF114 0x0070      ADDS     R0,R4,#+112
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD107             BNE.N    ??mbedtls_ecp_check_pub_priv_0
   \       0x40   0xF115 0x0178      ADDS     R1,R5,#+120
   \       0x44   0xF114 0x0078      ADDS     R0,R4,#+120
   \       0x48   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD001             BEQ.N    ??mbedtls_ecp_check_pub_priv_1
   3366                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_check_pub_priv_0: (+1)
   \       0x50   0x....             LDR.N    R0,??DataTable26_4
   \       0x52   0xE034             B.N      ??mbedtls_ecp_check_pub_priv_2
   3367              }
   3368          
   3369              mbedtls_ecp_point_init(&Q);
   \                     ??mbedtls_ecp_check_pub_priv_1: (+1)
   \       0x54   0xA802             ADD      R0,SP,#+8
   \       0x56   0x.... 0x....      BL       mbedtls_ecp_point_init
   3370              mbedtls_ecp_group_init(&grp);
   \       0x5A   0xA808             ADD      R0,SP,#+32
   \       0x5C   0x.... 0x....      BL       mbedtls_ecp_group_init
   3371          
   3372              /* mbedtls_ecp_mul() needs a non-const group... */
   3373              mbedtls_ecp_group_copy(&grp, &prv->grp);
   \       0x60   0x0029             MOVS     R1,R5
   \       0x62   0xA808             ADD      R0,SP,#+32
   \       0x64   0x.... 0x....      BL       mbedtls_ecp_group_copy
   3374          
   3375              /* Also checks d is valid */
   3376              MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&grp, &Q, &prv->d, &prv->grp.G, f_rng, p_rng));
   \       0x68   0x9701             STR      R7,[SP, #+4]
   \       0x6A   0x9600             STR      R6,[SP, #+0]
   \       0x6C   0xF115 0x031C      ADDS     R3,R5,#+28
   \       0x70   0xF115 0x0260      ADDS     R2,R5,#+96
   \       0x74   0xA902             ADD      R1,SP,#+8
   \       0x76   0xA808             ADD      R0,SP,#+32
   \       0x78   0x.... 0x....      BL       mbedtls_ecp_mul
   \       0x7C   0x4681             MOV      R9,R0
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD116             BNE.N    ??mbedtls_ecp_check_pub_priv_3
   3377          
   3378              if (mbedtls_mpi_cmp_mpi(&Q.X, &prv->Q.X) ||
   3379                  mbedtls_mpi_cmp_mpi(&Q.Y, &prv->Q.Y) ||
   3380                  mbedtls_mpi_cmp_mpi(&Q.Z, &prv->Q.Z)) {
   \                     ??mbedtls_ecp_check_pub_priv_4: (+1)
   \       0x82   0xF115 0x0168      ADDS     R1,R5,#+104
   \       0x86   0xA802             ADD      R0,SP,#+8
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD10D             BNE.N    ??mbedtls_ecp_check_pub_priv_5
   \       0x90   0xF115 0x0170      ADDS     R1,R5,#+112
   \       0x94   0xA804             ADD      R0,SP,#+16
   \       0x96   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD106             BNE.N    ??mbedtls_ecp_check_pub_priv_5
   \       0x9E   0xF115 0x0178      ADDS     R1,R5,#+120
   \       0xA2   0xA806             ADD      R0,SP,#+24
   \       0xA4   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD001             BEQ.N    ??mbedtls_ecp_check_pub_priv_3
   3381                  ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_check_pub_priv_5: (+1)
   \       0xAC   0x....             LDR.N    R0,??DataTable26_4
   \       0xAE   0x4681             MOV      R9,R0
   3382                  goto cleanup;
   3383              }
   3384          
   3385          cleanup:
   3386              mbedtls_ecp_point_free(&Q);
   \                     ??mbedtls_ecp_check_pub_priv_3: (+1)
   \       0xB0   0xA802             ADD      R0,SP,#+8
   \       0xB2   0x.... 0x....      BL       mbedtls_ecp_point_free
   3387              mbedtls_ecp_group_free(&grp);
   \       0xB6   0xA808             ADD      R0,SP,#+32
   \       0xB8   0x.... 0x....      BL       mbedtls_ecp_group_free
   3388          
   3389              return ret;
   \       0xBC   0x4648             MOV      R0,R9
   \                     ??mbedtls_ecp_check_pub_priv_2: (+1)
   \       0xBE   0xB021             ADD      SP,SP,#+132
   \       0xC0   0xE8BD 0x83F0      POP      {R4-R9,PC}
   3390          }
   3391          #endif /* MBEDTLS_ECP_C */
   3392          
   3393          /*
   3394           * Export generic key-pair parameters.
   3395           */

   \                                 In section .text, align 2, keep-with-next
   3396          int mbedtls_ecp_export(const mbedtls_ecp_keypair *key, mbedtls_ecp_group *grp,
   3397                                 mbedtls_mpi *d, mbedtls_ecp_point *Q)
   3398          {
   \                     mbedtls_ecp_export: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3399              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x086D      MVNS     R8,#+109
   3400          
   3401              if ((ret = mbedtls_ecp_group_copy(grp, &key->grp)) != 0) {
   \       0x10   0x0021             MOVS     R1,R4
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       mbedtls_ecp_group_copy
   \       0x18   0x4681             MOV      R9,R0
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??mbedtls_ecp_export_0
   3402                  return ret;
   \       0x1E   0x4648             MOV      R0,R9
   \       0x20   0xE014             B.N      ??mbedtls_ecp_export_1
   3403              }
   3404          
   3405              if ((ret = mbedtls_mpi_copy(d, &key->d)) != 0) {
   \                     ??mbedtls_ecp_export_0: (+1)
   \       0x22   0xF114 0x0160      ADDS     R1,R4,#+96
   \       0x26   0x0030             MOVS     R0,R6
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x2C   0x4680             MOV      R8,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD001             BEQ.N    ??mbedtls_ecp_export_2
   3406                  return ret;
   \       0x32   0x4640             MOV      R0,R8
   \       0x34   0xE00A             B.N      ??mbedtls_ecp_export_1
   3407              }
   3408          
   3409              if ((ret = mbedtls_ecp_copy(Q, &key->Q)) != 0) {
   \                     ??mbedtls_ecp_export_2: (+1)
   \       0x36   0xF114 0x0168      ADDS     R1,R4,#+104
   \       0x3A   0x0038             MOVS     R0,R7
   \       0x3C   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x40   0x0001             MOVS     R1,R0
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD001             BEQ.N    ??mbedtls_ecp_export_3
   3410                  return ret;
   \       0x46   0x0008             MOVS     R0,R1
   \       0x48   0xE000             B.N      ??mbedtls_ecp_export_1
   3411              }
   3412          
   3413              return 0;
   \                     ??mbedtls_ecp_export_3: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ecp_export_1: (+1)
   \       0x4C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   3414          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     ecp_supported_curves

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     `mbedtls_ecp_grp_id_list::init_done`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x....'....        DC32     ecp_supported_grp_id

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0xFFFF'B080        DC32     0xffffb080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0xFFFF'B180        DC32     0xffffb180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0xFFFF'B100        DC32     0xffffb100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     mbedtls_byte_order_detector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0xFFFF'B280        DC32     0xffffb280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0xFFFF'B080        DC32     0xffffb080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0xFFFF'B300        DC32     0xffffb300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \        0x0   0xFFFF'B280        DC32     0xffffb280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \        0x0   0xFFFF'B380        DC32     0xffffb380

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \        0x0   0xFFFF'B180        DC32     0xffffb180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \        0x0   0xFFFF'B080        DC32     0xffffb080

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x73 0x65          DC8 "secp256r1"
   \              0x63 0x70    
   \              0x32 0x35    
   \              0x36 0x72    
   \              0x31 0x00
   \        0xA                      DS8 2
   3415          
   3416          #if defined(MBEDTLS_SELF_TEST)
   3417          
   3418          #if defined(MBEDTLS_ECP_C)
   3419          /*
   3420           * PRNG for test - !!!INSECURE NEVER USE IN PRODUCTION!!!
   3421           *
   3422           * This is the linear congruential generator from numerical recipes,
   3423           * except we only use the low byte as the output. See
   3424           * https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
   3425           */
   3426          static int self_test_rng(void *ctx, unsigned char *out, size_t len)
   3427          {
   3428              static uint32_t state = 42;
   3429          
   3430              (void) ctx;
   3431          
   3432              for (size_t i = 0; i < len; i++) {
   3433                  state = state * 1664525u + 1013904223u;
   3434                  out[i] = (unsigned char) state;
   3435              }
   3436          
   3437              return 0;
   3438          }
   3439          
   3440          /* Adjust the exponent to be a valid private point for the specified curve.
   3441           * This is sometimes necessary because we use a single set of exponents
   3442           * for all curves but the validity of values depends on the curve. */
   3443          static int self_test_adjust_exponent(const mbedtls_ecp_group *grp,
   3444                                               mbedtls_mpi *m)
   3445          {
   3446              int ret = 0;
   3447              switch (grp->id) {
   3448              /* If Curve25519 is available, then that's what we use for the
   3449               * Montgomery test, so we don't need the adjustment code. */
   3450          #if !defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
   3451          #if defined(MBEDTLS_ECP_DP_CURVE448_ENABLED)
   3452                  case MBEDTLS_ECP_DP_CURVE448:
   3453                      /* Move highest bit from 254 to N-1. Setting bit N-1 is
   3454                       * necessary to enforce the highest-bit-set constraint. */
   3455                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(m, 254, 0));
   3456                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(m, grp->nbits, 1));
   3457                      /* Copy second-highest bit from 253 to N-2. This is not
   3458                       * necessary but improves the test variety a bit. */
   3459                      MBEDTLS_MPI_CHK(
   3460                          mbedtls_mpi_set_bit(m, grp->nbits - 1,
   3461                                              mbedtls_mpi_get_bit(m, 253)));
   3462                      break;
   3463          #endif
   3464          #endif /* ! defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED) */
   3465                  default:
   3466                      /* Non-Montgomery curves and Curve25519 need no adjustment. */
   3467                      (void) grp;
   3468                      (void) m;
   3469                      goto cleanup;
   3470              }
   3471          cleanup:
   3472              return ret;
   3473          }
   3474          
   3475          /* Calculate R = m.P for each m in exponents. Check that the number of
   3476           * basic operations doesn't depend on the value of m. */
   3477          static int self_test_point(int verbose,
   3478                                     mbedtls_ecp_group *grp,
   3479                                     mbedtls_ecp_point *R,
   3480                                     mbedtls_mpi *m,
   3481                                     const mbedtls_ecp_point *P,
   3482                                     const char *const *exponents,
   3483                                     size_t n_exponents)
   3484          {
   3485              int ret = 0;
   3486              size_t i = 0;
   3487              unsigned long add_c_prev, dbl_c_prev, mul_c_prev;
   3488              add_count = 0;
   3489              dbl_count = 0;
   3490              mul_count = 0;
   3491          
   3492              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(m, 16, exponents[0]));
   3493              MBEDTLS_MPI_CHK(self_test_adjust_exponent(grp, m));
   3494              MBEDTLS_MPI_CHK(mbedtls_ecp_mul(grp, R, m, P, self_test_rng, NULL));
   3495          
   3496              for (i = 1; i < n_exponents; i++) {
   3497                  add_c_prev = add_count;
   3498                  dbl_c_prev = dbl_count;
   3499                  mul_c_prev = mul_count;
   3500                  add_count = 0;
   3501                  dbl_count = 0;
   3502                  mul_count = 0;
   3503          
   3504                  MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(m, 16, exponents[i]));
   3505                  MBEDTLS_MPI_CHK(self_test_adjust_exponent(grp, m));
   3506                  MBEDTLS_MPI_CHK(mbedtls_ecp_mul(grp, R, m, P, self_test_rng, NULL));
   3507          
   3508                  if (add_count != add_c_prev ||
   3509                      dbl_count != dbl_c_prev ||
   3510                      mul_count != mul_c_prev) {
   3511                      ret = 1;
   3512                      break;
   3513                  }
   3514              }
   3515          
   3516          cleanup:
   3517              if (verbose != 0) {
   3518                  if (ret != 0) {
   3519                      mbedtls_printf("failed (%u)\n", (unsigned int) i);
   3520                  } else {
   3521                      mbedtls_printf("passed\n");
   3522                  }
   3523              }
   3524              return ret;
   3525          }
   3526          #endif /* MBEDTLS_ECP_C */
   3527          
   3528          /*
   3529           * Checkup routine
   3530           */
   3531          int mbedtls_ecp_self_test(int verbose)
   3532          {
   3533          #if defined(MBEDTLS_ECP_C)
   3534              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3535              mbedtls_ecp_group grp;
   3536              mbedtls_ecp_point R, P;
   3537              mbedtls_mpi m;
   3538          
   3539          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3540              /* Exponents especially adapted for secp192k1, which has the lowest
   3541               * order n of all supported curves (secp192r1 is in a slightly larger
   3542               * field but the order of its base point is slightly smaller). */
   3543              const char *sw_exponents[] =
   3544              {
   3545                  "000000000000000000000000000000000000000000000001", /* one */
   3546                  "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8C", /* n - 1 */
   3547                  "5EA6F389A38B8BC81E767753B15AA5569E1782E30ABE7D25", /* random */
   3548                  "400000000000000000000000000000000000000000000000", /* one and zeros */
   3549                  "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", /* all ones */
   3550                  "555555555555555555555555555555555555555555555555", /* 101010... */
   3551              };
   3552          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3553          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3554              const char *m_exponents[] =
   3555              {
   3556                  /* Valid private values for Curve25519. In a build with Curve448
   3557                   * but not Curve25519, they will be adjusted in
   3558                   * self_test_adjust_exponent(). */
   3559                  "4000000000000000000000000000000000000000000000000000000000000000",
   3560                  "5C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C30",
   3561                  "5715ECCE24583F7A7023C24164390586842E816D7280A49EF6DF4EAE6B280BF8",
   3562                  "41A2B017516F6D254E1F002BCCBADD54BE30F8CEC737A0E912B4963B6BA74460",
   3563                  "5555555555555555555555555555555555555555555555555555555555555550",
   3564                  "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8",
   3565              };
   3566          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3567          
   3568              mbedtls_ecp_group_init(&grp);
   3569              mbedtls_ecp_point_init(&R);
   3570              mbedtls_ecp_point_init(&P);
   3571              mbedtls_mpi_init(&m);
   3572          
   3573          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3574              /* Use secp192r1 if available, or any available curve */
   3575          #if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
   3576              MBEDTLS_MPI_CHK(mbedtls_ecp_group_load(&grp, MBEDTLS_ECP_DP_SECP192R1));
   3577          #else
   3578              MBEDTLS_MPI_CHK(mbedtls_ecp_group_load(&grp, mbedtls_ecp_curve_list()->grp_id));
   3579          #endif
   3580          
   3581              if (verbose != 0) {
   3582                  mbedtls_printf("  ECP SW test #1 (constant op_count, base point G): ");
   3583              }
   3584              /* Do a dummy multiplication first to trigger precomputation */
   3585              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&m, 2));
   3586              MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&grp, &P, &m, &grp.G, self_test_rng, NULL));
   3587              ret = self_test_point(verbose,
   3588                                    &grp, &R, &m, &grp.G,
   3589                                    sw_exponents,
   3590                                    sizeof(sw_exponents) / sizeof(sw_exponents[0]));
   3591              if (ret != 0) {
   3592                  goto cleanup;
   3593              }
   3594          
   3595              if (verbose != 0) {
   3596                  mbedtls_printf("  ECP SW test #2 (constant op_count, other point): ");
   3597              }
   3598              /* We computed P = 2G last time, use it */
   3599              ret = self_test_point(verbose,
   3600                                    &grp, &R, &m, &P,
   3601                                    sw_exponents,
   3602                                    sizeof(sw_exponents) / sizeof(sw_exponents[0]));
   3603              if (ret != 0) {
   3604                  goto cleanup;
   3605              }
   3606          
   3607              mbedtls_ecp_group_free(&grp);
   3608              mbedtls_ecp_point_free(&R);
   3609          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3610          
   3611          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3612              if (verbose != 0) {
   3613                  mbedtls_printf("  ECP Montgomery test (constant op_count): ");
   3614              }
   3615          #if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
   3616              MBEDTLS_MPI_CHK(mbedtls_ecp_group_load(&grp, MBEDTLS_ECP_DP_CURVE25519));
   3617          #elif defined(MBEDTLS_ECP_DP_CURVE448_ENABLED)
   3618              MBEDTLS_MPI_CHK(mbedtls_ecp_group_load(&grp, MBEDTLS_ECP_DP_CURVE448));
   3619          #else
   3620          #error "MBEDTLS_ECP_MONTGOMERY_ENABLED is defined, but no curve is supported for self-test"
   3621          #endif
   3622              ret = self_test_point(verbose,
   3623                                    &grp, &R, &m, &grp.G,
   3624                                    m_exponents,
   3625                                    sizeof(m_exponents) / sizeof(m_exponents[0]));
   3626              if (ret != 0) {
   3627                  goto cleanup;
   3628              }
   3629          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3630          
   3631          cleanup:
   3632          
   3633              if (ret < 0 && verbose != 0) {
   3634                  mbedtls_printf("Unexpected error, return code = %08X\n", (unsigned int) ret);
   3635              }
   3636          
   3637              mbedtls_ecp_group_free(&grp);
   3638              mbedtls_ecp_point_free(&R);
   3639              mbedtls_ecp_point_free(&P);
   3640              mbedtls_mpi_free(&m);
   3641          
   3642              if (verbose != 0) {
   3643                  mbedtls_printf("\n");
   3644              }
   3645          
   3646              return ret;
   3647          #else /* MBEDTLS_ECP_C */
   3648              (void) verbose;
   3649              return 0;
   3650          #endif /* MBEDTLS_ECP_C */
   3651          }
   3652          
   3653          #endif /* MBEDTLS_SELF_TEST */
   3654          
   3655          #endif /* !MBEDTLS_ECP_ALT */
   3656          
   3657          #endif /* MBEDTLS_ECP_LIGHT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   ecp_add_mixed
        48   -> ecp_double_jac
        48   -> mbedtls_ecp_copy
        48   -> mbedtls_ecp_set_zero
        48   -> mbedtls_mpi_cmp_int
        48   -> mbedtls_mpi_copy
        48   -> mbedtls_mpi_mul_mod
        48   -> mbedtls_mpi_shift_l_mod
        48   -> mbedtls_mpi_sub_mod
      40   ecp_check_pubkey_sw
        40   -> ecp_sw_rhs
        40   -> mbedtls_mpi_cmp_int
        40   -> mbedtls_mpi_cmp_mpi
        40   -> mbedtls_mpi_free
        40   -> mbedtls_mpi_init
        40   -> mbedtls_mpi_mul_mod
      48   ecp_comb_recode_core
        48   -> __aeabi_memset
        48   -> mbedtls_mpi_get_bit
      56   ecp_comb_recode_scalar
        56   -> ecp_comb_recode_core
        56   -> mbedtls_mpi_copy
        56   -> mbedtls_mpi_free
        56   -> mbedtls_mpi_get_bit
        56   -> mbedtls_mpi_init
        56   -> mbedtls_mpi_safe_cond_assign
        56   -> mbedtls_mpi_sub_mpi
      32   ecp_double_jac
        32   -> mbedtls_ecp_group_a_is_minus_3
        32   -> mbedtls_mpi_add_mod
        32   -> mbedtls_mpi_cmp_int
        32   -> mbedtls_mpi_copy
        32   -> mbedtls_mpi_mul_int_mod
        32   -> mbedtls_mpi_mul_mod
        32   -> mbedtls_mpi_shift_l_mod
        32   -> mbedtls_mpi_sub_mod
       0   ecp_group_is_static_comb_table
      24   ecp_modp
        24   -- Indirect call
        24   -> mbedtls_mpi_add_mpi
        24   -> mbedtls_mpi_bitlen
        24   -> mbedtls_mpi_cmp_int
        24   -> mbedtls_mpi_cmp_mpi
        24   -> mbedtls_mpi_mod_mpi
        24   -> mbedtls_mpi_sub_abs
      80   ecp_mul_comb
        80   -> ecp_mul_comb_after_precomp
        80   -> ecp_pick_window_size
        80   -> ecp_precompute_comb
        80   -> mbedtls_ecp_point_free
        80   -> mbedtls_ecp_point_init
        80   -> sl_calloc
        80   -> sl_free
     200   ecp_mul_comb_after_precomp
       200   -> ecp_comb_recode_scalar
       200   -> ecp_mul_comb_core
       200   -> ecp_normalize_jac
       200   -> ecp_randomize_jac
       200   -> ecp_safe_invert_jac
     104   ecp_mul_comb_core
       104   -> ecp_add_mixed
       104   -> ecp_double_jac
       104   -> ecp_randomize_jac
       104   -> ecp_select_comb
       104   -> mbedtls_ecp_point_free
       104   -> mbedtls_ecp_point_init
       104   -> mpi_free_many
       104   -> mpi_init_many
      48   ecp_mul_restartable_internal
        48   -> ecp_mul_comb
        48   -> mbedtls_ecp_check_privkey
        48   -> mbedtls_ecp_check_pubkey
        48   -> mbedtls_ecp_get_type
      32   ecp_normalize_jac
        32   -> mbedtls_mpi_cmp_int
        32   -> mbedtls_mpi_free
        32   -> mbedtls_mpi_init
        32   -> mbedtls_mpi_inv_mod
        32   -> mbedtls_mpi_lset
        32   -> mbedtls_mpi_mul_mod
      40   ecp_normalize_jac_many
        40   -> ecp_normalize_jac
        40   -> mbedtls_mpi_copy
        40   -> mbedtls_mpi_free
        40   -> mbedtls_mpi_init
        40   -> mbedtls_mpi_inv_mod
        40   -> mbedtls_mpi_lset
        40   -> mbedtls_mpi_mul_mod
        40   -> mbedtls_mpi_shrink
        40   -> mpi_free_many
        40   -> mpi_init_many
        40   -> sl_calloc
        40   -> sl_free
      16   ecp_pick_window_size
        16   -> ecp_group_is_static_comb_table
      88   ecp_precompute_comb
        88   -> ecp_add_mixed
        88   -> ecp_double_jac
        88   -> ecp_normalize_jac_many
        88   -> mbedtls_ecp_copy
        88   -> mbedtls_mpi_free
        88   -> mpi_free_many
        88   -> mpi_init_many
      40   ecp_randomize_jac
        40   -> mbedtls_mpi_free
        40   -> mbedtls_mpi_init
        40   -> mbedtls_mpi_mul_mod
        40   -> mbedtls_mpi_random
      40   ecp_safe_invert_jac
        40   -> mbedtls_mpi_cmp_int
        40   -> mbedtls_mpi_free
        40   -> mbedtls_mpi_init
        40   -> mbedtls_mpi_safe_cond_assign
        40   -> mbedtls_mpi_sub_mpi
      40   ecp_select_comb
        40   -> ecp_safe_invert_jac
        40   -> mbedtls_mpi_lset
        40   -> mbedtls_mpi_safe_cond_assign
      24   ecp_sw_rhs
        24   -> mbedtls_ecp_group_a_is_minus_3
        24   -> mbedtls_mpi_add_mod
        24   -> mbedtls_mpi_mul_mod
        24   -> mbedtls_mpi_sub_int_mod
       0   mbedtls_bswap16
      16   mbedtls_ecp_check_privkey
        16   -> mbedtls_ecp_get_type
        16   -> mbedtls_mpi_cmp_int
        16   -> mbedtls_mpi_cmp_mpi
     160   mbedtls_ecp_check_pub_priv
       160   -> mbedtls_ecp_group_copy
       160   -> mbedtls_ecp_group_free
       160   -> mbedtls_ecp_group_init
       160   -> mbedtls_ecp_mul
       160   -> mbedtls_ecp_point_free
       160   -> mbedtls_ecp_point_init
       160   -> mbedtls_mpi_cmp_mpi
      16   mbedtls_ecp_check_pubkey
        16   -> ecp_check_pubkey_sw
        16   -> mbedtls_ecp_get_type
        16   -> mbedtls_mpi_cmp_int
      24   mbedtls_ecp_copy
        24   -> mbedtls_mpi_copy
       8   mbedtls_ecp_curve_info_from_grp_id
         8   -> mbedtls_ecp_curve_list
      16   mbedtls_ecp_curve_info_from_name
        16   -> mbedtls_ecp_curve_list
        16   -> strcmp
       8   mbedtls_ecp_curve_info_from_tls_id
         8   -> mbedtls_ecp_curve_list
       0   mbedtls_ecp_curve_list
      32   mbedtls_ecp_export
        32   -> mbedtls_ecp_copy
        32   -> mbedtls_ecp_group_copy
        32   -> mbedtls_mpi_copy
      32   mbedtls_ecp_gen_key
        32   -> mbedtls_ecp_gen_keypair
        32   -> mbedtls_ecp_group_load
      32   mbedtls_ecp_gen_keypair
        32   -> mbedtls_ecp_gen_keypair_base
      48   mbedtls_ecp_gen_keypair_base
        48   -> mbedtls_ecp_gen_privkey
        48   -> mbedtls_ecp_mul
      24   mbedtls_ecp_gen_privkey
        24   -> mbedtls_ecp_gen_privkey_sw
        24   -> mbedtls_ecp_get_type
      24   mbedtls_ecp_gen_privkey_sw
        24   -> mbedtls_mpi_random
       0   mbedtls_ecp_get_type
       0   mbedtls_ecp_group_a_is_minus_3
      16   mbedtls_ecp_group_copy
        16   -> mbedtls_ecp_group_load
      16   mbedtls_ecp_group_free
        16   -> ecp_group_is_static_comb_table
        16   -> mbedtls_ecp_point_free
        16   -> mbedtls_mpi_free
        16   -> mbedtls_platform_zeroize
        16   -> sl_free
       8   mbedtls_ecp_group_init
         8   -> mbedtls_ecp_point_init
         8   -> mbedtls_mpi_init
      16   mbedtls_ecp_grp_id_list
        16   -> mbedtls_ecp_curve_list
       8   mbedtls_ecp_is_zero
         8   -> mbedtls_mpi_cmp_int
       8   mbedtls_ecp_keypair_free
         8   -> mbedtls_ecp_group_free
         8   -> mbedtls_ecp_point_free
         8   -> mbedtls_mpi_free
       8   mbedtls_ecp_keypair_init
         8   -> mbedtls_ecp_group_init
         8   -> mbedtls_ecp_point_init
         8   -> mbedtls_mpi_init
      32   mbedtls_ecp_mul
        32   -> mbedtls_ecp_mul_restartable
      40   mbedtls_ecp_mul_restartable
        40   -> ecp_mul_restartable_internal
      48   mbedtls_ecp_mul_shortcuts
        48   -> ecp_mul_restartable_internal
        48   -> mbedtls_ecp_check_pubkey
        48   -> mbedtls_ecp_copy
        48   -> mbedtls_ecp_set_zero
        48   -> mbedtls_mpi_cmp_int
        48   -> mbedtls_mpi_free
        48   -> mbedtls_mpi_init
        48   -> mbedtls_mpi_safe_cond_assign
        48   -> mbedtls_mpi_sub_mpi
      32   mbedtls_ecp_muladd
        32   -> mbedtls_ecp_muladd_restartable
     104   mbedtls_ecp_muladd_restartable
       104   -> ecp_add_mixed
       104   -> ecp_normalize_jac
       104   -> mbedtls_ecp_get_type
       104   -> mbedtls_ecp_mul_shortcuts
       104   -> mbedtls_ecp_point_free
       104   -> mbedtls_ecp_point_init
       104   -> mpi_free_many
       104   -> mpi_init_many
      16   mbedtls_ecp_point_cmp
        16   -> mbedtls_mpi_cmp_mpi
       8   mbedtls_ecp_point_free
         8   -> mbedtls_mpi_free
       8   mbedtls_ecp_point_init
         8   -> mbedtls_mpi_init
      32   mbedtls_ecp_point_read_binary
        32   -> mbedtls_ecp_get_type
        32   -> mbedtls_ecp_set_zero
        32   -> mbedtls_mpi_lset
        32   -> mbedtls_mpi_read_binary
        32   -> mbedtls_mpi_size
      32   mbedtls_ecp_point_read_string
        32   -> mbedtls_mpi_lset
        32   -> mbedtls_mpi_read_string
      40   mbedtls_ecp_point_write_binary
        40   -> mbedtls_ecp_get_type
        40   -> mbedtls_mpi_cmp_int
        40   -> mbedtls_mpi_get_bit
        40   -> mbedtls_mpi_size
        40   -> mbedtls_mpi_write_binary
      32   mbedtls_ecp_read_key
        32   -> mbedtls_ecp_check_privkey
        32   -> mbedtls_ecp_get_type
        32   -> mbedtls_ecp_group_load
        32   -> mbedtls_mpi_free
        32   -> mbedtls_mpi_read_binary
      16   mbedtls_ecp_set_zero
        16   -> mbedtls_mpi_lset
      32   mbedtls_ecp_tls_read_group
        32   -> mbedtls_ecp_group_load
        32   -> mbedtls_ecp_tls_read_group_id
      24   mbedtls_ecp_tls_read_group_id
        24   -> mbedtls_bswap16
        24   -> mbedtls_ecp_curve_info_from_tls_id
        24   -> mbedtls_get_unaligned_uint16
      32   mbedtls_ecp_tls_read_point
        32   -> mbedtls_ecp_point_read_binary
      24   mbedtls_ecp_tls_write_group
        24   -> mbedtls_bswap16
        24   -> mbedtls_ecp_curve_info_from_grp_id
        24   -> mbedtls_put_unaligned_uint16
      40   mbedtls_ecp_tls_write_point
        40   -> mbedtls_ecp_point_write_binary
      24   mbedtls_ecp_write_key
        24   -> mbedtls_ecp_get_type
        24   -> mbedtls_mpi_write_binary
      24   mbedtls_get_unaligned_uint16
        24   -> __aeabi_memcpy
      32   mbedtls_mpi_add_mod
        32   -> mbedtls_mpi_add_mpi
        32   -> mbedtls_mpi_cmp_mpi
        32   -> mbedtls_mpi_sub_abs
      32   mbedtls_mpi_mul_int_mod
        32   -> mbedtls_mpi_cmp_mpi
        32   -> mbedtls_mpi_mul_int
        32   -> mbedtls_mpi_sub_abs
      32   mbedtls_mpi_mul_mod
        32   -> ecp_modp
        32   -> mbedtls_mpi_mul_mpi
      24   mbedtls_mpi_shift_l_mod
        24   -> mbedtls_mpi_cmp_mpi
        24   -> mbedtls_mpi_shift_l
        24   -> mbedtls_mpi_sub_abs
      32   mbedtls_mpi_sub_int_mod
        32   -> mbedtls_mpi_add_mpi
        32   -> mbedtls_mpi_cmp_int
        32   -> mbedtls_mpi_sub_int
      32   mbedtls_mpi_sub_mod
        32   -> mbedtls_mpi_add_mpi
        32   -> mbedtls_mpi_cmp_int
        32   -> mbedtls_mpi_sub_mpi
      24   mbedtls_put_unaligned_uint16
        24   -> __aeabi_memcpy
      16   mpi_free_many
        16   -> mbedtls_mpi_free
      16   mpi_init_many
        16   -> mbedtls_mpi_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable20
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
      12  ?_0
       4  ?_1
     578  ecp_add_mixed
     156  ecp_check_pubkey_sw
     206  ecp_comb_recode_core
     162  ecp_comb_recode_scalar
     678  ecp_double_jac
       6  ecp_group_is_static_comb_table
     152  ecp_modp
     352  ecp_mul_comb
     164  ecp_mul_comb_after_precomp
     190  ecp_mul_comb_core
     102  ecp_mul_restartable_internal
     158  ecp_normalize_jac
     428  ecp_normalize_jac_many
      80  ecp_pick_window_size
     410  ecp_precompute_comb
     170  ecp_randomize_jac
      92  ecp_safe_invert_jac
     188  ecp_select_comb
      24  ecp_supported_curves
       2  ecp_supported_grp_id
     118  ecp_sw_rhs
       4  init_done
      16  mbedtls_bswap16
       2  mbedtls_byte_order_detector
      54  mbedtls_ecp_check_privkey
     196  mbedtls_ecp_check_pub_priv
      48  mbedtls_ecp_check_pubkey
      64  mbedtls_ecp_copy
      38  mbedtls_ecp_curve_info_from_grp_id
      48  mbedtls_ecp_curve_info_from_name
      38  mbedtls_ecp_curve_info_from_tls_id
       6  mbedtls_ecp_curve_list
      80  mbedtls_ecp_export
      58  mbedtls_ecp_gen_key
      32  mbedtls_ecp_gen_keypair
      70  mbedtls_ecp_gen_keypair_base
      40  mbedtls_ecp_gen_privkey
      40  mbedtls_ecp_gen_privkey_sw
      26  mbedtls_ecp_get_type
      16  mbedtls_ecp_group_a_is_minus_3
      16  mbedtls_ecp_group_copy
     112  mbedtls_ecp_group_free
      84  mbedtls_ecp_group_init
      56  mbedtls_ecp_grp_id_list
      28  mbedtls_ecp_is_zero
      32  mbedtls_ecp_keypair_free
      28  mbedtls_ecp_keypair_init
      36  mbedtls_ecp_mul
      56  mbedtls_ecp_mul_restartable
     254  mbedtls_ecp_mul_shortcuts
      36  mbedtls_ecp_muladd
     168  mbedtls_ecp_muladd_restartable
      60  mbedtls_ecp_point_cmp
      32  mbedtls_ecp_point_free
      28  mbedtls_ecp_point_init
     168  mbedtls_ecp_point_read_binary
      72  mbedtls_ecp_point_read_string
     228  mbedtls_ecp_point_write_binary
      98  mbedtls_ecp_read_key
      58  mbedtls_ecp_set_zero
      48  mbedtls_ecp_tls_read_group
     104  mbedtls_ecp_tls_read_group_id
      88  mbedtls_ecp_tls_read_point
      98  mbedtls_ecp_tls_write_group
      96  mbedtls_ecp_tls_write_point
      42  mbedtls_ecp_write_key
      26  mbedtls_get_unaligned_uint16
      72  mbedtls_mpi_add_mod
      72  mbedtls_mpi_mul_int_mod
      52  mbedtls_mpi_mul_mod
      64  mbedtls_mpi_shift_l_mod
      76  mbedtls_mpi_sub_int_mod
      76  mbedtls_mpi_sub_mod
      22  mbedtls_put_unaligned_uint16
      26  mpi_free_many
      26  mpi_init_many

 
     6 bytes in section .bss
    42 bytes in section .rodata
 7'954 bytes in section .text
 
 7'906 bytes of CODE  memory (+ 48 bytes shared)
    42 bytes of CONST memory
     6 bytes of DATA  memory

Errors: none
Warnings: none
