###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:42
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\cipher.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\cipher.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\cipher.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\cipher.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\cipher.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\cipher.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\cipher.c
      1          /**
      2           * \file cipher.c
      3           *
      4           * \brief Generic cipher wrapper for Mbed TLS
      5           *
      6           * \author Adriaan de Jong <dejong@fox-it.com>
      7           *
      8           *  Copyright The Mbed TLS Contributors
      9           *  SPDX-License-Identifier: Apache-2.0
     10           *
     11           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     12           *  not use this file except in compliance with the License.
     13           *  You may obtain a copy of the License at
     14           *
     15           *  http://www.apache.org/licenses/LICENSE-2.0
     16           *
     17           *  Unless required by applicable law or agreed to in writing, software
     18           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     19           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     20           *  See the License for the specific language governing permissions and
     21           *  limitations under the License.
     22           */
     23          
     24          #include "common.h"
     25          
     26          #if defined(MBEDTLS_CIPHER_C)
     27          
     28          #include "mbedtls/cipher.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_cipher_info_get_key_bitlen(mbedtls_cipher_info_t const *)
   \                     mbedtls_cipher_info_get_key_bitlen: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD101             BNE.N    ??mbedtls_cipher_info_get_key_bitlen_0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE003             B.N      ??mbedtls_cipher_info_get_key_bitlen_1
   \                     ??mbedtls_cipher_info_get_key_bitlen_0: (+1)
   \        0xA   0x6848             LDR      R0,[R1, #+4]
   \        0xC   0xF3C0 0x2003      UBFX     R0,R0,#+8,#+4
   \       0x10   0x0180             LSLS     R0,R0,#+6
   \                     ??mbedtls_cipher_info_get_key_bitlen_1: (+1)
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_cipher_info_get_iv_size(mbedtls_cipher_info_t const *)
   \                     mbedtls_cipher_info_get_iv_size: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD101             BNE.N    ??mbedtls_cipher_info_get_iv_size_0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE003             B.N      ??mbedtls_cipher_info_get_iv_size_1
   \                     ??mbedtls_cipher_info_get_iv_size_0: (+1)
   \        0xA   0x6848             LDR      R0,[R1, #+4]
   \        0xC   0x08C0             LSRS     R0,R0,#+3
   \        0xE   0xF010 0x001C      ANDS     R0,R0,#0x1C
   \                     ??mbedtls_cipher_info_get_iv_size_1: (+1)
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp unsigned int mbedtls_cipher_get_block_size(mbedtls_cipher_context_t const *)
   \                     mbedtls_cipher_get_block_size: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD101             BNE.N    ??mbedtls_cipher_get_block_size_0
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE003             B.N      ??mbedtls_cipher_get_block_size_1
   \                     ??mbedtls_cipher_get_block_size_0: (+1)
   \        0xC   0x6808             LDR      R0,[R1, #+0]
   \        0xE   0x7900             LDRB     R0,[R0, #+4]
   \       0x10   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \                     ??mbedtls_cipher_get_block_size_1: (+1)
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_cipher_get_iv_size(mbedtls_cipher_context_t const *)
   \                     mbedtls_cipher_get_iv_size: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD101             BNE.N    ??mbedtls_cipher_get_iv_size_0
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE009             B.N      ??mbedtls_cipher_get_iv_size_1
   \                     ??mbedtls_cipher_get_iv_size_0: (+1)
   \        0xC   0x6B88             LDR      R0,[R1, #+56]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD001             BEQ.N    ??mbedtls_cipher_get_iv_size_2
   \       0x12   0x6B88             LDR      R0,[R1, #+56]
   \       0x14   0xE004             B.N      ??mbedtls_cipher_get_iv_size_1
   \                     ??mbedtls_cipher_get_iv_size_2: (+1)
   \       0x16   0x6808             LDR      R0,[R1, #+0]
   \       0x18   0x6840             LDR      R0,[R0, #+4]
   \       0x1A   0xF3C0 0x1042      UBFX     R0,R0,#+5,#+3
   \       0x1E   0x0080             LSLS     R0,R0,#+2
   \                     ??mbedtls_cipher_get_iv_size_1: (+1)
   \       0x20   0x4770             BX       LR
     29          #include "cipher_wrap.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_extend_key_usage_flags(uint32_t *)
   \                     psa_extend_key_usage_flags: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x04C9             LSLS     R1,R1,#+19
   \        0x4   0xD503             BPL.N    ??psa_extend_key_usage_flags_0
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0xF451 0x6180      ORRS     R1,R1,#0x400
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \                     ??psa_extend_key_usage_flags_0: (+1)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x0489             LSLS     R1,R1,#+18
   \       0x12   0xD503             BPL.N    ??psa_extend_key_usage_flags_1
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF451 0x6100      ORRS     R1,R1,#0x800
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   \                     ??psa_extend_key_usage_flags_1: (+1)
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_usage_flags(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_usage_flags: (+1)
   \        0x0   0xB513             PUSH     {R0,R1,R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0xA801             ADD      R0,SP,#+4
   \        0x6   0x.... 0x....      BL       psa_extend_key_usage_flags
   \        0xA   0x9801             LDR      R0,[SP, #+4]
   \        0xC   0x60E0             STR      R0,[R4, #+12]
   \        0xE   0xBD13             POP      {R0,R1,R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_algorithm(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_algorithm: (+1)
   \        0x0   0x6101             STR      R1,[R0, #+16]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_type(psa_key_attributes_t *, uint16_t)
   \                     psa_set_key_type: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x69E8             LDR      R0,[R5, #+28]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??psa_set_key_type_0
   \        0xC   0x802C             STRH     R4,[R5, #+0]
   \        0xE   0xE006             B.N      ??psa_set_key_type_1
   \                     ??psa_set_key_type_0: (+1)
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x0021             MOVS     R1,R4
   \       0x16   0xB289             UXTH     R1,R1
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       psa_set_key_domain_parameters
   \                     ??psa_set_key_type_1: (+1)
   \       0x1E   0xBD31             POP      {R0,R4,R5,PC}
     30          #include "mbedtls/platform_util.h"
     31          #include "mbedtls/error.h"
     32          #include "mbedtls/constant_time.h"
     33          #include "constant_time_internal.h"
     34          
     35          #include <stdlib.h>
     36          #include <string.h>
     37          
     38          #if defined(MBEDTLS_CHACHAPOLY_C)
     39          #include "mbedtls/chachapoly.h"
     40          #endif
     41          
     42          #if defined(MBEDTLS_GCM_C)
     43          #include "mbedtls/gcm.h"
     44          #endif
     45          
     46          #if defined(MBEDTLS_CCM_C)
     47          #include "mbedtls/ccm.h"
     48          #endif
     49          
     50          #if defined(MBEDTLS_CHACHA20_C)
     51          #include "mbedtls/chacha20.h"
     52          #endif
     53          
     54          #if defined(MBEDTLS_CMAC_C)
     55          #include "mbedtls/cmac.h"
     56          #endif
     57          
     58          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
     59          #include "psa/crypto.h"
     60          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
     61          
     62          #if defined(MBEDTLS_NIST_KW_C)
     63          #include "mbedtls/nist_kw.h"
     64          #endif
     65          
     66          #include "mbedtls/platform.h"
     67          

   \                                 In section .bss, align 4
     68          static int supported_init = 0;
   \                     supported_init:
   \        0x0                      DS8 4
     69          

   \                                 In section .text, align 2, keep-with-next
     70          static inline const mbedtls_cipher_base_t *mbedtls_cipher_get_base(
     71              const mbedtls_cipher_info_t *info)
     72          {
     73              return mbedtls_cipher_base_lookup_table[info->base_idx];
   \                     mbedtls_cipher_get_base: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable17
   \        0x4   0x6840             LDR      R0,[R0, #+4]
   \        0x6   0xF3C0 0x6084      UBFX     R0,R0,#+26,#+5
   \        0xA   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \        0xE   0x4770             BX       LR
     74          }
     75          

   \                                 In section .text, align 2, keep-with-next
     76          const int *mbedtls_cipher_list(void)
     77          {
     78              const mbedtls_cipher_definition_t *def;
     79              int *type;
     80          
     81              if (!supported_init) {
   \                     mbedtls_cipher_list: (+1)
   \        0x0   0x.... 0x....      LDR.W    R3,??DataTable17_1
   \        0x4   0x6818             LDR      R0,[R3, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD111             BNE.N    ??mbedtls_cipher_list_0
     82                  def = mbedtls_cipher_definitions;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \        0xE   0x0001             MOVS     R1,R0
     83                  type = mbedtls_cipher_supported;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \       0x14   0x0002             MOVS     R2,R0
     84          
     85                  while (def->type != 0) {
   \                     ??mbedtls_cipher_list_1: (+1)
   \       0x16   0x7808             LDRB     R0,[R1, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD004             BEQ.N    ??mbedtls_cipher_list_2
     86                      *type++ = (*def++).type;
   \       0x1C   0x7808             LDRB     R0,[R1, #+0]
   \       0x1E   0x6010             STR      R0,[R2, #+0]
   \       0x20   0x3108             ADDS     R1,R1,#+8
   \       0x22   0x1D12             ADDS     R2,R2,#+4
   \       0x24   0xE7F7             B.N      ??mbedtls_cipher_list_1
     87                  }
     88          
     89                  *type = 0;
   \                     ??mbedtls_cipher_list_2: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6010             STR      R0,[R2, #+0]
     90          
     91                  supported_init = 1;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0x6018             STR      R0,[R3, #+0]
     92              }
     93          
     94              return mbedtls_cipher_supported;
   \                     ??mbedtls_cipher_list_0: (+1)
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \       0x32   0x4770             BX       LR
     95          }
     96          

   \                                 In section .text, align 2, keep-with-next
     97          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_type(
     98              const mbedtls_cipher_type_t cipher_type)
     99          {
   \                     mbedtls_cipher_info_from_type: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    100              const mbedtls_cipher_definition_t *def;
    101          
    102              for (def = mbedtls_cipher_definitions; def->info != NULL; def++) {
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \                     ??mbedtls_cipher_info_from_type_0: (+1)
   \        0x6   0x6848             LDR      R0,[R1, #+4]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD008             BEQ.N    ??mbedtls_cipher_info_from_type_1
    103                  if (def->type == cipher_type) {
   \        0xC   0x780B             LDRB     R3,[R1, #+0]
   \        0xE   0x0010             MOVS     R0,R2
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x4283             CMP      R3,R0
   \       0x14   0xD101             BNE.N    ??mbedtls_cipher_info_from_type_2
    104                      return def->info;
   \       0x16   0x6848             LDR      R0,[R1, #+4]
   \       0x18   0xE002             B.N      ??mbedtls_cipher_info_from_type_3
    105                  }
    106              }
   \                     ??mbedtls_cipher_info_from_type_2: (+1)
   \       0x1A   0x3108             ADDS     R1,R1,#+8
   \       0x1C   0xE7F3             B.N      ??mbedtls_cipher_info_from_type_0
    107          
    108              return NULL;
   \                     ??mbedtls_cipher_info_from_type_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_info_from_type_3: (+1)
   \       0x20   0x4770             BX       LR
    109          }
    110          

   \                                 In section .text, align 2, keep-with-next
    111          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_string(
    112              const char *cipher_name)
    113          {
   \                     mbedtls_cipher_info_from_string: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    114              const mbedtls_cipher_definition_t *def;
    115          
    116              if (NULL == cipher_name) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??mbedtls_cipher_info_from_string_0
    117                  return NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE010             B.N      ??mbedtls_cipher_info_from_string_1
    118              }
    119          
    120              for (def = mbedtls_cipher_definitions; def->info != NULL; def++) {
   \                     ??mbedtls_cipher_info_from_string_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R5,??DataTable17_2
   \                     ??mbedtls_cipher_info_from_string_2: (+1)
   \       0x10   0x6868             LDR      R0,[R5, #+4]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD00A             BEQ.N    ??mbedtls_cipher_info_from_string_3
    121                  if (!strcmp(def->info->name, cipher_name)) {
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0x6868             LDR      R0,[R5, #+4]
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x.... 0x....      BL       strcmp
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??mbedtls_cipher_info_from_string_4
    122                      return def->info;
   \       0x24   0x6868             LDR      R0,[R5, #+4]
   \       0x26   0xE002             B.N      ??mbedtls_cipher_info_from_string_1
    123                  }
    124              }
   \                     ??mbedtls_cipher_info_from_string_4: (+1)
   \       0x28   0x3508             ADDS     R5,R5,#+8
   \       0x2A   0xE7F1             B.N      ??mbedtls_cipher_info_from_string_2
    125          
    126              return NULL;
   \                     ??mbedtls_cipher_info_from_string_3: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_info_from_string_1: (+1)
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
    127          }
    128          

   \                                 In section .text, align 2, keep-with-next
    129          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_values(
    130              const mbedtls_cipher_id_t cipher_id,
    131              int key_bitlen,
    132              const mbedtls_cipher_mode_t mode)
    133          {
   \                     mbedtls_cipher_info_from_values: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0017             MOVS     R7,R2
    134              const mbedtls_cipher_definition_t *def;
    135          
    136              for (def = mbedtls_cipher_definitions; def->info != NULL; def++) {
   \        0x8   0x.... 0x....      LDR.W    R6,??DataTable17_2
   \                     ??mbedtls_cipher_info_from_values_0: (+1)
   \        0xC   0x6870             LDR      R0,[R6, #+4]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD018             BEQ.N    ??mbedtls_cipher_info_from_values_1
    137                  if (mbedtls_cipher_get_base(def->info)->cipher == cipher_id &&
    138                      mbedtls_cipher_info_get_key_bitlen(def->info) == (unsigned) key_bitlen &&
    139                      def->info->mode == mode) {
   \       0x12   0x6870             LDR      R0,[R6, #+4]
   \       0x14   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0x18   0x7801             LDRB     R1,[R0, #+0]
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x4281             CMP      R1,R0
   \       0x20   0xD10E             BNE.N    ??mbedtls_cipher_info_from_values_2
   \       0x22   0x6870             LDR      R0,[R6, #+4]
   \       0x24   0x.... 0x....      BL       mbedtls_cipher_info_get_key_bitlen
   \       0x28   0x42A8             CMP      R0,R5
   \       0x2A   0xD109             BNE.N    ??mbedtls_cipher_info_from_values_2
   \       0x2C   0x6870             LDR      R0,[R6, #+4]
   \       0x2E   0x6840             LDR      R0,[R0, #+4]
   \       0x30   0xF3C0 0x3103      UBFX     R1,R0,#+12,#+4
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0x4281             CMP      R1,R0
   \       0x3A   0xD101             BNE.N    ??mbedtls_cipher_info_from_values_2
    140                      return def->info;
   \       0x3C   0x6870             LDR      R0,[R6, #+4]
   \       0x3E   0xE002             B.N      ??mbedtls_cipher_info_from_values_3
    141                  }
    142              }
   \                     ??mbedtls_cipher_info_from_values_2: (+1)
   \       0x40   0x3608             ADDS     R6,R6,#+8
   \       0x42   0xE7E3             B.N      ??mbedtls_cipher_info_from_values_0
    143          
    144              return NULL;
   \                     ??mbedtls_cipher_info_from_values_1: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_info_from_values_3: (+1)
   \       0x46   0xBDF2             POP      {R1,R4-R7,PC}
    145          }
    146          
    147          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)

   \                                 In section .text, align 2, keep-with-next
    148          static inline psa_key_type_t mbedtls_psa_translate_cipher_type(
    149              mbedtls_cipher_type_t cipher)
    150          {
   \                     mbedtls_psa_translate_cipher_type: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    151              switch (cipher) {
   \        0x2   0x000A             MOVS     R2,R1
   \        0x4   0xB2D2             UXTB     R2,R2
   \        0x6   0x1E92             SUBS     R2,R2,#+2
   \        0x8   0x2A05             CMP      R2,#+5
   \        0xA   0xD905             BLS.N    ??mbedtls_psa_translate_cipher_type_0
   \        0xC   0x3A0C             SUBS     R2,R2,#+12
   \        0xE   0x2A02             CMP      R2,#+2
   \       0x10   0xD902             BLS.N    ??mbedtls_psa_translate_cipher_type_0
   \       0x12   0x3A18             SUBS     R2,R2,#+24
   \       0x14   0x2A05             CMP      R2,#+5
   \       0x16   0xD802             BHI.N    ??mbedtls_psa_translate_cipher_type_1
    152                  case MBEDTLS_CIPHER_AES_128_CCM:
    153                  case MBEDTLS_CIPHER_AES_192_CCM:
    154                  case MBEDTLS_CIPHER_AES_256_CCM:
    155                  case MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG:
    156                  case MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG:
    157                  case MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG:
    158                  case MBEDTLS_CIPHER_AES_128_GCM:
    159                  case MBEDTLS_CIPHER_AES_192_GCM:
    160                  case MBEDTLS_CIPHER_AES_256_GCM:
    161                  case MBEDTLS_CIPHER_AES_128_CBC:
    162                  case MBEDTLS_CIPHER_AES_192_CBC:
    163                  case MBEDTLS_CIPHER_AES_256_CBC:
    164                  case MBEDTLS_CIPHER_AES_128_ECB:
    165                  case MBEDTLS_CIPHER_AES_192_ECB:
    166                  case MBEDTLS_CIPHER_AES_256_ECB:
    167                      return PSA_KEY_TYPE_AES;
   \                     ??mbedtls_psa_translate_cipher_type_0: (+1)
   \       0x18   0xF44F 0x5010      MOV      R0,#+9216
   \       0x1C   0xE000             B.N      ??mbedtls_psa_translate_cipher_type_2
    168          
    169                  /* ARIA not yet supported in PSA. */
    170                  /* case MBEDTLS_CIPHER_ARIA_128_CCM:
    171                     case MBEDTLS_CIPHER_ARIA_192_CCM:
    172                     case MBEDTLS_CIPHER_ARIA_256_CCM:
    173                     case MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG:
    174                     case MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG:
    175                     case MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG:
    176                     case MBEDTLS_CIPHER_ARIA_128_GCM:
    177                     case MBEDTLS_CIPHER_ARIA_192_GCM:
    178                     case MBEDTLS_CIPHER_ARIA_256_GCM:
    179                     case MBEDTLS_CIPHER_ARIA_128_CBC:
    180                     case MBEDTLS_CIPHER_ARIA_192_CBC:
    181                     case MBEDTLS_CIPHER_ARIA_256_CBC:
    182                         return( PSA_KEY_TYPE_ARIA ); */
    183          
    184                  default:
    185                      return 0;
   \                     ??mbedtls_psa_translate_cipher_type_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_psa_translate_cipher_type_2: (+1)
   \       0x20   0x4770             BX       LR
    186              }
    187          }
    188          

   \                                 In section .text, align 2, keep-with-next
    189          static inline psa_algorithm_t mbedtls_psa_translate_cipher_mode(
    190              mbedtls_cipher_mode_t mode, size_t taglen)
    191          {
   \                     mbedtls_psa_translate_cipher_mode: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    192              switch (mode) {
   \        0x2   0x0010             MOVS     R0,R2
   \        0x4   0xB2C0             UXTB     R0,R0
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD008             BEQ.N    ??mbedtls_psa_translate_cipher_mode_0
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD01E             BEQ.N    ??mbedtls_psa_translate_cipher_mode_1
   \        0xE   0x2806             CMP      R0,#+6
   \       0x10   0xD007             BEQ.N    ??mbedtls_psa_translate_cipher_mode_2
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xD00E             BEQ.N    ??mbedtls_psa_translate_cipher_mode_3
   \       0x16   0x2809             CMP      R0,#+9
   \       0x18   0xD015             BEQ.N    ??mbedtls_psa_translate_cipher_mode_4
   \       0x1A   0xE01E             B.N      ??mbedtls_psa_translate_cipher_mode_5
    193                  case MBEDTLS_MODE_ECB:
    194                      return PSA_ALG_ECB_NO_PADDING;
   \                     ??mbedtls_psa_translate_cipher_mode_0: (+1)
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable18
   \       0x20   0xE01C             B.N      ??mbedtls_psa_translate_cipher_mode_6
    195                  case MBEDTLS_MODE_GCM:
    196                      return PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, taglen);
   \                     ??mbedtls_psa_translate_cipher_mode_2: (+1)
   \       0x22   0x0409             LSLS     R1,R1,#+16
   \       0x24   0xF411 0x117C      ANDS     R1,R1,#0x3F0000
   \       0x28   0xF041 0x61A8      ORR      R1,R1,#0x5400000
   \       0x2C   0xF451 0x7100      ORRS     R1,R1,#0x200
   \       0x30   0x0008             MOVS     R0,R1
   \       0x32   0xE013             B.N      ??mbedtls_psa_translate_cipher_mode_6
    197                  case MBEDTLS_MODE_CCM:
    198                      return PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen);
   \                     ??mbedtls_psa_translate_cipher_mode_3: (+1)
   \       0x34   0x0409             LSLS     R1,R1,#+16
   \       0x36   0xF411 0x117C      ANDS     R1,R1,#0x3F0000
   \       0x3A   0xF041 0x61A8      ORR      R1,R1,#0x5400000
   \       0x3E   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x42   0x0008             MOVS     R0,R1
   \       0x44   0xE00A             B.N      ??mbedtls_psa_translate_cipher_mode_6
    199                  case MBEDTLS_MODE_CCM_STAR_NO_TAG:
    200                      return PSA_ALG_CCM_STAR_NO_TAG;
   \                     ??mbedtls_psa_translate_cipher_mode_4: (+1)
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \       0x4A   0xE007             B.N      ??mbedtls_psa_translate_cipher_mode_6
    201                  case MBEDTLS_MODE_CBC:
    202                      if (taglen == 0) {
   \                     ??mbedtls_psa_translate_cipher_mode_1: (+1)
   \       0x4C   0x2900             CMP      R1,#+0
   \       0x4E   0xD102             BNE.N    ??mbedtls_psa_translate_cipher_mode_7
    203                          return PSA_ALG_CBC_NO_PADDING;
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable19
   \       0x54   0xE002             B.N      ??mbedtls_psa_translate_cipher_mode_6
    204                      } else {
    205                          return 0;
   \                     ??mbedtls_psa_translate_cipher_mode_7: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xE000             B.N      ??mbedtls_psa_translate_cipher_mode_6
    206                      }
    207                  default:
    208                      return 0;
   \                     ??mbedtls_psa_translate_cipher_mode_5: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_psa_translate_cipher_mode_6: (+1)
   \       0x5C   0x4770             BX       LR
    209              }
    210          }
    211          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    212          

   \                                 In section .text, align 2, keep-with-next
    213          void mbedtls_cipher_init(mbedtls_cipher_context_t *ctx)
    214          {
   \                     mbedtls_cipher_init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
    215              memset(ctx, 0, sizeof(mbedtls_cipher_context_t));
   \        0x4   0x2448             MOVS     R4,#+72
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memset
    216          }
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}
    217          

   \                                 In section .text, align 2, keep-with-next
    218          void mbedtls_cipher_free(mbedtls_cipher_context_t *ctx)
    219          {
   \                     mbedtls_cipher_free: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    220              if (ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD024             BEQ.N    ??mbedtls_cipher_free_0
    221                  return;
    222              }
    223          
    224          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    225              if (ctx->psa_enabled == 1) {
   \                     ??mbedtls_cipher_free_1: (+1)
   \        0x8   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD112             BNE.N    ??mbedtls_cipher_free_2
    226                  if (ctx->cipher_ctx != NULL) {
   \       0x10   0x6BE0             LDR      R0,[R4, #+60]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD00A             BEQ.N    ??mbedtls_cipher_free_3
    227                      mbedtls_cipher_context_psa * const cipher_psa =
    228                          (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
   \       0x16   0x6BE5             LDR      R5,[R4, #+60]
    229          
    230                      if (cipher_psa->slot_state == MBEDTLS_CIPHER_PSA_KEY_OWNED) {
   \       0x18   0x7A28             LDRB     R0,[R5, #+8]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD102             BNE.N    ??mbedtls_cipher_free_4
    231                          /* xxx_free() doesn't allow to return failures. */
    232                          (void) psa_destroy_key(cipher_psa->slot);
   \       0x1E   0x6868             LDR      R0,[R5, #+4]
   \       0x20   0x.... 0x....      BL       psa_destroy_key
    233                      }
    234          
    235                      mbedtls_zeroize_and_free(cipher_psa, sizeof(*cipher_psa));
   \                     ??mbedtls_cipher_free_4: (+1)
   \       0x24   0x210C             MOVS     R1,#+12
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       mbedtls_zeroize_and_free
    236                  }
    237          
    238                  mbedtls_platform_zeroize(ctx, sizeof(mbedtls_cipher_context_t));
   \                     ??mbedtls_cipher_free_3: (+1)
   \       0x2C   0x2148             MOVS     R1,#+72
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       mbedtls_platform_zeroize
    239                  return;
   \       0x34   0xE00D             B.N      ??mbedtls_cipher_free_0
    240              }
    241          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    242          
    243          #if defined(MBEDTLS_CMAC_C)
    244              if (ctx->cmac_ctx) {
    245                  mbedtls_zeroize_and_free(ctx->cmac_ctx,
    246                                           sizeof(mbedtls_cmac_context_t));
    247              }
    248          #endif
    249          
    250              if (ctx->cipher_ctx) {
   \                     ??mbedtls_cipher_free_2: (+1)
   \       0x36   0x6BE0             LDR      R0,[R4, #+60]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD006             BEQ.N    ??mbedtls_cipher_free_5
    251                  mbedtls_cipher_get_base(ctx->cipher_info)->ctx_free_func(ctx->cipher_ctx);
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0x42   0x0001             MOVS     R1,R0
   \       0x44   0x6BE0             LDR      R0,[R4, #+60]
   \       0x46   0x6989             LDR      R1,[R1, #+24]
   \       0x48   0x4788             BLX      R1
    252              }
    253          
    254              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_cipher_context_t));
   \                     ??mbedtls_cipher_free_5: (+1)
   \       0x4A   0x2148             MOVS     R1,#+72
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       mbedtls_platform_zeroize
    255          }
   \                     ??mbedtls_cipher_free_0: (+1)
   \       0x52   0xBD31             POP      {R0,R4,R5,PC}
    256          

   \                                 In section .text, align 2, keep-with-next
    257          int mbedtls_cipher_setup(mbedtls_cipher_context_t *ctx,
    258                                   const mbedtls_cipher_info_t *cipher_info)
    259          {
   \                     mbedtls_cipher_setup: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
    260              if (cipher_info == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD102             BNE.N    ??mbedtls_cipher_setup_0
    261                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x10   0xE014             B.N      ??mbedtls_cipher_setup_1
    262              }
    263          
    264              memset(ctx, 0, sizeof(mbedtls_cipher_context_t));
   \                     ??mbedtls_cipher_setup_0: (+1)
   \       0x12   0x2648             MOVS     R6,#+72
   \       0x14   0x2700             MOVS     R7,#+0
   \       0x16   0x46A8             MOV      R8,R5
   \       0x18   0x003A             MOVS     R2,R7
   \       0x1A   0x0031             MOVS     R1,R6
   \       0x1C   0x4640             MOV      R0,R8
   \       0x1E   0x.... 0x....      BL       __aeabi_memset
    265          
    266              if (NULL == (ctx->cipher_ctx = mbedtls_cipher_get_base(cipher_info)->ctx_alloc_func())) {
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0x28   0x6940             LDR      R0,[R0, #+20]
   \       0x2A   0x4780             BLX      R0
   \       0x2C   0x63E8             STR      R0,[R5, #+60]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD102             BNE.N    ??mbedtls_cipher_setup_2
    267                  return MBEDTLS_ERR_CIPHER_ALLOC_FAILED;
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0x36   0xE001             B.N      ??mbedtls_cipher_setup_1
    268              }
    269          
    270              ctx->cipher_info = cipher_info;
   \                     ??mbedtls_cipher_setup_2: (+1)
   \       0x38   0x602C             STR      R4,[R5, #+0]
    271          
    272              return 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_setup_1: (+1)
   \       0x3C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    273          }
    274          
    275          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)

   \                                 In section .text, align 2, keep-with-next
    276          int mbedtls_cipher_setup_psa(mbedtls_cipher_context_t *ctx,
    277                                       const mbedtls_cipher_info_t *cipher_info,
    278                                       size_t taglen)
    279          {
   \                     mbedtls_cipher_setup_psa: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0017             MOVS     R7,R2
    280              psa_algorithm_t alg;
    281              mbedtls_cipher_context_psa *cipher_psa;
    282          
    283              if (NULL == cipher_info || NULL == ctx) {
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD001             BEQ.N    ??mbedtls_cipher_setup_psa_0
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD102             BNE.N    ??mbedtls_cipher_setup_psa_1
    284                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_setup_psa_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x16   0xE031             B.N      ??mbedtls_cipher_setup_psa_2
    285              }
    286          
    287              /* Check that the underlying cipher mode and cipher type are
    288               * supported by the underlying PSA Crypto implementation. */
    289              alg = mbedtls_psa_translate_cipher_mode(((mbedtls_cipher_mode_t) cipher_info->mode), taglen);
   \                     ??mbedtls_cipher_setup_psa_1: (+1)
   \       0x18   0x0039             MOVS     R1,R7
   \       0x1A   0x6868             LDR      R0,[R5, #+4]
   \       0x1C   0x0B00             LSRS     R0,R0,#+12
   \       0x1E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x22   0x.... 0x....      BL       mbedtls_psa_translate_cipher_mode
   \       0x26   0x0006             MOVS     R6,R0
    290              if (alg == 0) {
   \       0x28   0x2E00             CMP      R6,#+0
   \       0x2A   0xD102             BNE.N    ??mbedtls_cipher_setup_psa_3
    291                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x30   0xE024             B.N      ??mbedtls_cipher_setup_psa_2
    292              }
    293              if (mbedtls_psa_translate_cipher_type(((mbedtls_cipher_type_t) cipher_info->type)) == 0) {
   \                     ??mbedtls_cipher_setup_psa_3: (+1)
   \       0x32   0x6868             LDR      R0,[R5, #+4]
   \       0x34   0x0C00             LSRS     R0,R0,#+16
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0x.... 0x....      BL       mbedtls_psa_translate_cipher_type
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD102             BNE.N    ??mbedtls_cipher_setup_psa_4
    294                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x44   0xE01A             B.N      ??mbedtls_cipher_setup_psa_2
    295              }
    296          
    297              memset(ctx, 0, sizeof(mbedtls_cipher_context_t));
   \                     ??mbedtls_cipher_setup_psa_4: (+1)
   \       0x46   0xF05F 0x0848      MOVS     R8,#+72
   \       0x4A   0xF05F 0x0900      MOVS     R9,#+0
   \       0x4E   0x46A2             MOV      R10,R4
   \       0x50   0x464A             MOV      R2,R9
   \       0x52   0x4641             MOV      R1,R8
   \       0x54   0x4650             MOV      R0,R10
   \       0x56   0x.... 0x....      BL       __aeabi_memset
    298          
    299              cipher_psa = mbedtls_calloc(1, sizeof(mbedtls_cipher_context_psa));
   \       0x5A   0x210C             MOVS     R1,#+12
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0x.... 0x....      BL       sl_calloc
   \       0x62   0x0001             MOVS     R1,R0
    300              if (cipher_psa == NULL) {
   \       0x64   0x2900             CMP      R1,#+0
   \       0x66   0xD102             BNE.N    ??mbedtls_cipher_setup_psa_5
    301                  return MBEDTLS_ERR_CIPHER_ALLOC_FAILED;
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0x6C   0xE006             B.N      ??mbedtls_cipher_setup_psa_2
    302              }
    303              cipher_psa->alg  = alg;
   \                     ??mbedtls_cipher_setup_psa_5: (+1)
   \       0x6E   0x600E             STR      R6,[R1, #+0]
    304              ctx->cipher_ctx  = cipher_psa;
   \       0x70   0x63E1             STR      R1,[R4, #+60]
    305              ctx->cipher_info = cipher_info;
   \       0x72   0x6025             STR      R5,[R4, #+0]
    306              ctx->psa_enabled = 1;
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xF884 0x0044      STRB     R0,[R4, #+68]
    307              return 0;
   \       0x7A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_setup_psa_2: (+1)
   \       0x7C   0xE8BD 0x87F0      POP      {R4-R10,PC}
    308          }
    309          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    310          

   \                                 In section .text, align 2, keep-with-next
    311          int mbedtls_cipher_setkey(mbedtls_cipher_context_t *ctx,
    312                                    const unsigned char *key,
    313                                    int key_bitlen,
    314                                    const mbedtls_operation_t operation)
    315          {
   \                     mbedtls_cipher_setkey: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
    316              if (operation != MBEDTLS_ENCRYPT && operation != MBEDTLS_DECRYPT) {
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0xB240             SXTB     R0,R0
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD006             BEQ.N    ??mbedtls_cipher_setkey_0
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xB240             SXTB     R0,R0
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD002             BEQ.N    ??mbedtls_cipher_setkey_0
    317                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x22   0xE0AE             B.N      ??mbedtls_cipher_setkey_1
    318              }
    319              if (ctx->cipher_info == NULL) {
   \                     ??mbedtls_cipher_setkey_0: (+1)
   \       0x24   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD102             BNE.N    ??mbedtls_cipher_setkey_2
    320                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x30   0xE0A7             B.N      ??mbedtls_cipher_setkey_1
    321              }
    322          
    323          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    324              if (ctx->psa_enabled == 1) {
   \                     ??mbedtls_cipher_setkey_2: (+1)
   \       0x32   0xF899 0x0044      LDRB     R0,[R9, #+68]
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD154             BNE.N    ??mbedtls_cipher_setkey_3
    325                  mbedtls_cipher_context_psa * const cipher_psa =
    326                      (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
   \       0x3A   0xF8D9 0x703C      LDR      R7,[R9, #+60]
    327          
    328                  size_t const key_bytelen = ((size_t) key_bitlen + 7) / 8;
   \       0x3E   0xF115 0x0807      ADDS     R8,R5,#+7
   \       0x42   0xEA5F 0x08D8      LSRS     R8,R8,#+3
    329          
    330                  psa_status_t status;
    331                  psa_key_type_t key_type;
    332                  psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x2124             MOVS     R1,#+36
   \       0x4A   0x.... 0x....      BL       __aeabi_memclr4
    333          
    334                  /* PSA Crypto API only accepts byte-aligned keys. */
    335                  if (key_bitlen % 8 != 0) {
   \       0x4E   0xF015 0x0F07      TST      R5,#0x7
   \       0x52   0xD002             BEQ.N    ??mbedtls_cipher_setkey_4
    336                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x58   0xE093             B.N      ??mbedtls_cipher_setkey_1
    337                  }
    338          
    339                  /* Don't allow keys to be set multiple times. */
    340                  if (cipher_psa->slot_state != MBEDTLS_CIPHER_PSA_KEY_UNSET) {
   \                     ??mbedtls_cipher_setkey_4: (+1)
   \       0x5A   0x7A38             LDRB     R0,[R7, #+8]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD002             BEQ.N    ??mbedtls_cipher_setkey_5
    341                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x64   0xE08D             B.N      ??mbedtls_cipher_setkey_1
    342                  }
    343          
    344                  key_type = mbedtls_psa_translate_cipher_type(
    345                      ((mbedtls_cipher_type_t) ctx->cipher_info->type));
   \                     ??mbedtls_cipher_setkey_5: (+1)
   \       0x66   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x6A   0x6840             LDR      R0,[R0, #+4]
   \       0x6C   0x0C00             LSRS     R0,R0,#+16
   \       0x6E   0xB2C0             UXTB     R0,R0
   \       0x70   0x.... 0x....      BL       mbedtls_psa_translate_cipher_type
   \       0x74   0x4682             MOV      R10,R0
    346                  if (key_type == 0) {
   \       0x76   0x4650             MOV      R0,R10
   \       0x78   0xB280             UXTH     R0,R0
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD102             BNE.N    ??mbedtls_cipher_setkey_6
    347                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x82   0xE07E             B.N      ??mbedtls_cipher_setkey_1
    348                  }
    349                  psa_set_key_type(&attributes, key_type);
   \                     ??mbedtls_cipher_setkey_6: (+1)
   \       0x84   0x4651             MOV      R1,R10
   \       0x86   0xB289             UXTH     R1,R1
   \       0x88   0x4668             MOV      R0,SP
   \       0x8A   0x.... 0x....      BL       psa_set_key_type
    350          
    351                  /* Mbed TLS' cipher layer doesn't enforce the mode of operation
    352                   * (encrypt vs. decrypt): it is possible to setup a key for encryption
    353                   * and use it for AEAD decryption. Until tests relying on this
    354                   * are changed, allow any usage in PSA. */
    355                  psa_set_key_usage_flags(&attributes,
    356                                          PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
   \       0x8E   0xF44F 0x7140      MOV      R1,#+768
   \       0x92   0x4668             MOV      R0,SP
   \       0x94   0x.... 0x....      BL       psa_set_key_usage_flags
    357                  psa_set_key_algorithm(&attributes, cipher_psa->alg);
   \       0x98   0x6839             LDR      R1,[R7, #+0]
   \       0x9A   0x4668             MOV      R0,SP
   \       0x9C   0x.... 0x....      BL       psa_set_key_algorithm
    358          
    359                  status = psa_import_key(&attributes, key, key_bytelen,
    360                                          &cipher_psa->slot);
   \       0xA0   0x1D3B             ADDS     R3,R7,#+4
   \       0xA2   0x4642             MOV      R2,R8
   \       0xA4   0x0021             MOVS     R1,R4
   \       0xA6   0x4668             MOV      R0,SP
   \       0xA8   0x.... 0x....      BL       psa_import_key
   \       0xAC   0x0001             MOVS     R1,R0
    361                  switch (status) {
   \       0xAE   0x000A             MOVS     R2,R1
   \       0xB0   0x2A00             CMP      R2,#+0
   \       0xB2   0xD006             BEQ.N    ??mbedtls_cipher_setkey_7
   \       0xB4   0xF07F 0x008C      MVNS     R0,#+140
   \       0xB8   0x1A12             SUBS     R2,R2,R0
   \       0xBA   0xD00A             BEQ.N    ??mbedtls_cipher_setkey_8
   \       0xBC   0x1FD2             SUBS     R2,R2,#+7
   \       0xBE   0xD00B             BEQ.N    ??mbedtls_cipher_setkey_9
   \       0xC0   0xE00D             B.N      ??mbedtls_cipher_setkey_10
    362                      case PSA_SUCCESS:
    363                          break;
    364                      case PSA_ERROR_INSUFFICIENT_MEMORY:
    365                          return MBEDTLS_ERR_CIPHER_ALLOC_FAILED;
    366                      case PSA_ERROR_NOT_SUPPORTED:
    367                          return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    368                      default:
    369                          return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
    370                  }
    371                  /* Indicate that we own the key slot and need to
    372                   * destroy it in mbedtls_cipher_free(). */
    373                  cipher_psa->slot_state = MBEDTLS_CIPHER_PSA_KEY_OWNED;
   \                     ??mbedtls_cipher_setkey_7: (+1)
   \       0xC2   0x2001             MOVS     R0,#+1
   \       0xC4   0x7238             STRB     R0,[R7, #+8]
    374          
    375                  ctx->key_bitlen = key_bitlen;
   \       0xC6   0xF8C9 0x5004      STR      R5,[R9, #+4]
    376                  ctx->operation = operation;
   \       0xCA   0xF889 0x6008      STRB     R6,[R9, #+8]
    377                  return 0;
   \       0xCE   0x2000             MOVS     R0,#+0
   \       0xD0   0xE057             B.N      ??mbedtls_cipher_setkey_1
   \                     ??mbedtls_cipher_setkey_8: (+1)
   \       0xD2   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0xD6   0xE054             B.N      ??mbedtls_cipher_setkey_1
   \                     ??mbedtls_cipher_setkey_9: (+1)
   \       0xD8   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0xDC   0xE051             B.N      ??mbedtls_cipher_setkey_1
   \                     ??mbedtls_cipher_setkey_10: (+1)
   \       0xDE   0xF07F 0x006F      MVNS     R0,#+111
   \       0xE2   0xE04E             B.N      ??mbedtls_cipher_setkey_1
    378              }
    379          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    380          
    381              if ((ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN) == 0 &&
    382                  (int) mbedtls_cipher_info_get_key_bitlen(ctx->cipher_info) != key_bitlen) {
   \                     ??mbedtls_cipher_setkey_3: (+1)
   \       0xE4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xE8   0x6840             LDR      R0,[R0, #+4]
   \       0xEA   0x0E00             LSRS     R0,R0,#+24
   \       0xEC   0x0780             LSLS     R0,R0,#+30
   \       0xEE   0xD408             BMI.N    ??mbedtls_cipher_setkey_11
   \       0xF0   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xF4   0x.... 0x....      BL       mbedtls_cipher_info_get_key_bitlen
   \       0xF8   0x42A8             CMP      R0,R5
   \       0xFA   0xD002             BEQ.N    ??mbedtls_cipher_setkey_11
    383                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0xFC   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \      0x100   0xE03F             B.N      ??mbedtls_cipher_setkey_1
    384              }
    385          
    386              ctx->key_bitlen = key_bitlen;
   \                     ??mbedtls_cipher_setkey_11: (+1)
   \      0x102   0xF8C9 0x5004      STR      R5,[R9, #+4]
    387              ctx->operation = operation;
   \      0x106   0xF889 0x6008      STRB     R6,[R9, #+8]
    388          
    389              /*
    390               * For OFB, CFB and CTR mode always use the encryption key schedule
    391               */
    392              if (MBEDTLS_ENCRYPT == operation ||
    393                  MBEDTLS_MODE_CFB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
    394                  MBEDTLS_MODE_OFB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
    395                  MBEDTLS_MODE_CTR == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \      0x10A   0x0030             MOVS     R0,R6
   \      0x10C   0xB240             SXTB     R0,R0
   \      0x10E   0x2801             CMP      R0,#+1
   \      0x110   0xD017             BEQ.N    ??mbedtls_cipher_setkey_12
   \      0x112   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x116   0x6840             LDR      R0,[R0, #+4]
   \      0x118   0x0B00             LSRS     R0,R0,#+12
   \      0x11A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x11E   0x2803             CMP      R0,#+3
   \      0x120   0xD00F             BEQ.N    ??mbedtls_cipher_setkey_12
   \      0x122   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x126   0x6840             LDR      R0,[R0, #+4]
   \      0x128   0x0B00             LSRS     R0,R0,#+12
   \      0x12A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x12E   0x2804             CMP      R0,#+4
   \      0x130   0xD007             BEQ.N    ??mbedtls_cipher_setkey_12
   \      0x132   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x136   0x6840             LDR      R0,[R0, #+4]
   \      0x138   0x0B00             LSRS     R0,R0,#+12
   \      0x13A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x13E   0x2805             CMP      R0,#+5
   \      0x140   0xD10C             BNE.N    ??mbedtls_cipher_setkey_13
    396                  return mbedtls_cipher_get_base(ctx->cipher_info)->setkey_enc_func(ctx->cipher_ctx, key,
    397                                                                                    ctx->key_bitlen);
   \                     ??mbedtls_cipher_setkey_12: (+1)
   \      0x142   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x146   0x.... 0x....      BL       mbedtls_cipher_get_base
   \      0x14A   0x0003             MOVS     R3,R0
   \      0x14C   0xF8D9 0x2004      LDR      R2,[R9, #+4]
   \      0x150   0x0021             MOVS     R1,R4
   \      0x152   0xF8D9 0x003C      LDR      R0,[R9, #+60]
   \      0x156   0x68DB             LDR      R3,[R3, #+12]
   \      0x158   0x4798             BLX      R3
   \      0x15A   0xE012             B.N      ??mbedtls_cipher_setkey_1
    398              }
    399          
    400              if (MBEDTLS_DECRYPT == operation) {
   \                     ??mbedtls_cipher_setkey_13: (+1)
   \      0x15C   0x0030             MOVS     R0,R6
   \      0x15E   0xB240             SXTB     R0,R0
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD10C             BNE.N    ??mbedtls_cipher_setkey_14
    401                  return mbedtls_cipher_get_base(ctx->cipher_info)->setkey_dec_func(ctx->cipher_ctx, key,
    402                                                                                    ctx->key_bitlen);
   \      0x164   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x168   0x.... 0x....      BL       mbedtls_cipher_get_base
   \      0x16C   0x0003             MOVS     R3,R0
   \      0x16E   0xF8D9 0x2004      LDR      R2,[R9, #+4]
   \      0x172   0x0021             MOVS     R1,R4
   \      0x174   0xF8D9 0x003C      LDR      R0,[R9, #+60]
   \      0x178   0x691B             LDR      R3,[R3, #+16]
   \      0x17A   0x4798             BLX      R3
   \      0x17C   0xE001             B.N      ??mbedtls_cipher_setkey_1
    403              }
    404          
    405              return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_setkey_14: (+1)
   \      0x17E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \                     ??mbedtls_cipher_setkey_1: (+1)
   \      0x182   0xB00A             ADD      SP,SP,#+40
   \      0x184   0xE8BD 0x87F0      POP      {R4-R10,PC}
    406          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
    407          

   \                                 In section .text, align 2, keep-with-next
    408          int mbedtls_cipher_set_iv(mbedtls_cipher_context_t *ctx,
    409                                    const unsigned char *iv,
    410                                    size_t iv_len)
    411          {
   \                     mbedtls_cipher_set_iv: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
    412              size_t actual_iv_size;
    413          
    414              if (ctx->cipher_info == NULL) {
   \        0xA   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD102             BNE.N    ??mbedtls_cipher_set_iv_0
    415                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x16   0xE059             B.N      ??mbedtls_cipher_set_iv_1
    416              }
    417          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    418              if (ctx->psa_enabled == 1) {
   \                     ??mbedtls_cipher_set_iv_0: (+1)
   \       0x18   0xF898 0x0044      LDRB     R0,[R8, #+68]
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD102             BNE.N    ??mbedtls_cipher_set_iv_2
    419                  /* While PSA Crypto has an API for multipart
    420                   * operations, we currently don't make it
    421                   * accessible through the cipher layer. */
    422                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x24   0xE052             B.N      ??mbedtls_cipher_set_iv_1
    423              }
    424          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    425          
    426              /* avoid buffer overflow in ctx->iv */
    427              if (iv_len > MBEDTLS_MAX_IV_LENGTH) {
   \                     ??mbedtls_cipher_set_iv_2: (+1)
   \       0x26   0x2F11             CMP      R7,#+17
   \       0x28   0xD302             BCC.N    ??mbedtls_cipher_set_iv_3
    428                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x2E   0xE04D             B.N      ??mbedtls_cipher_set_iv_1
    429              }
    430          
    431              if ((ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_IV_LEN) != 0) {
   \                     ??mbedtls_cipher_set_iv_3: (+1)
   \       0x30   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x34   0x6840             LDR      R0,[R0, #+4]
   \       0x36   0xF3C0 0x6000      UBFX     R0,R0,#+24,#+1
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD001             BEQ.N    ??mbedtls_cipher_set_iv_4
    432                  actual_iv_size = iv_len;
   \       0x3E   0x003C             MOVS     R4,R7
   \       0x40   0xE009             B.N      ??mbedtls_cipher_set_iv_5
    433              } else {
    434                  actual_iv_size = mbedtls_cipher_info_get_iv_size(ctx->cipher_info);
   \                     ??mbedtls_cipher_set_iv_4: (+1)
   \       0x42   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x46   0x.... 0x....      BL       mbedtls_cipher_info_get_iv_size
   \       0x4A   0x0004             MOVS     R4,R0
    435          
    436                  /* avoid reading past the end of input buffer */
    437                  if (actual_iv_size > iv_len) {
   \       0x4C   0x42A7             CMP      R7,R4
   \       0x4E   0xD202             BCS.N    ??mbedtls_cipher_set_iv_5
    438                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x54   0xE03A             B.N      ??mbedtls_cipher_set_iv_1
    439                  }
    440              }
    441          
    442          #if defined(MBEDTLS_CHACHA20_C)
    443              if (((mbedtls_cipher_type_t) ctx->cipher_info->type) == MBEDTLS_CIPHER_CHACHA20) {
    444                  /* Even though the actual_iv_size is overwritten with a correct value
    445                   * of 12 from the cipher info, return an error to indicate that
    446                   * the input iv_len is wrong. */
    447                  if (iv_len != 12) {
    448                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    449                  }
    450          
    451                  if (0 != mbedtls_chacha20_starts((mbedtls_chacha20_context *) ctx->cipher_ctx,
    452                                                   iv,
    453                                                   0U)) {   /* Initial counter value */
    454                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    455                  }
    456              }
    457          #if defined(MBEDTLS_CHACHAPOLY_C)
    458              if (((mbedtls_cipher_type_t) ctx->cipher_info->type) == MBEDTLS_CIPHER_CHACHA20_POLY1305 &&
    459                  iv_len != 12) {
    460                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    461              }
    462          #endif
    463          #endif
    464          
    465          #if defined(MBEDTLS_GCM_C)
    466              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
    467                  return mbedtls_gcm_starts((mbedtls_gcm_context *) ctx->cipher_ctx,
    468                                            ctx->operation,
    469                                            iv, iv_len);
    470              }
    471          #endif
    472          
    473          #if defined(MBEDTLS_CCM_C)
    474              if (MBEDTLS_MODE_CCM_STAR_NO_TAG == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \                     ??mbedtls_cipher_set_iv_5: (+1)
   \       0x56   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x5A   0x6840             LDR      R0,[R0, #+4]
   \       0x5C   0x0B00             LSRS     R0,R0,#+12
   \       0x5E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x62   0x2809             CMP      R0,#+9
   \       0x64   0xD124             BNE.N    ??mbedtls_cipher_set_iv_6
    475                  int set_lengths_result;
    476                  int ccm_star_mode;
    477          
    478                  set_lengths_result = mbedtls_ccm_set_lengths(
    479                      (mbedtls_ccm_context *) ctx->cipher_ctx,
    480                      0, 0, 0);
   \       0x66   0x2300             MOVS     R3,#+0
   \       0x68   0x2200             MOVS     R2,#+0
   \       0x6A   0x2100             MOVS     R1,#+0
   \       0x6C   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \       0x70   0x.... 0x....      BL       mbedtls_ccm_set_lengths
   \       0x74   0x0005             MOVS     R5,R0
    481                  if (set_lengths_result != 0) {
   \       0x76   0x2D00             CMP      R5,#+0
   \       0x78   0xD001             BEQ.N    ??mbedtls_cipher_set_iv_7
    482                      return set_lengths_result;
   \       0x7A   0x0028             MOVS     R0,R5
   \       0x7C   0xE026             B.N      ??mbedtls_cipher_set_iv_1
    483                  }
    484          
    485                  if (ctx->operation == MBEDTLS_DECRYPT) {
   \                     ??mbedtls_cipher_set_iv_7: (+1)
   \       0x7E   0xF998 0x0008      LDRSB    R0,[R8, #+8]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD102             BNE.N    ??mbedtls_cipher_set_iv_8
    486                      ccm_star_mode = MBEDTLS_CCM_STAR_DECRYPT;
   \       0x86   0xF05F 0x0902      MOVS     R9,#+2
   \       0x8A   0xE009             B.N      ??mbedtls_cipher_set_iv_9
    487                  } else if (ctx->operation == MBEDTLS_ENCRYPT) {
   \                     ??mbedtls_cipher_set_iv_8: (+1)
   \       0x8C   0xF998 0x0008      LDRSB    R0,[R8, #+8]
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD102             BNE.N    ??mbedtls_cipher_set_iv_10
    488                      ccm_star_mode = MBEDTLS_CCM_STAR_ENCRYPT;
   \       0x94   0xF05F 0x0903      MOVS     R9,#+3
   \       0x98   0xE002             B.N      ??mbedtls_cipher_set_iv_9
    489                  } else {
    490                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_set_iv_10: (+1)
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x9E   0xE015             B.N      ??mbedtls_cipher_set_iv_1
    491                  }
    492          
    493                  return mbedtls_ccm_starts((mbedtls_ccm_context *) ctx->cipher_ctx,
    494                                            ccm_star_mode,
    495                                            iv, iv_len);
   \                     ??mbedtls_cipher_set_iv_9: (+1)
   \       0xA0   0x003B             MOVS     R3,R7
   \       0xA2   0x0032             MOVS     R2,R6
   \       0xA4   0x4649             MOV      R1,R9
   \       0xA6   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \       0xAA   0x.... 0x....      BL       mbedtls_ccm_starts
   \       0xAE   0xE00D             B.N      ??mbedtls_cipher_set_iv_1
    496              }
    497          #endif
    498          
    499              if (actual_iv_size != 0) {
   \                     ??mbedtls_cipher_set_iv_6: (+1)
   \       0xB0   0x2C00             CMP      R4,#+0
   \       0xB2   0xD00A             BEQ.N    ??mbedtls_cipher_set_iv_11
    500                  memcpy(ctx->iv, iv, actual_iv_size);
   \       0xB4   0x46A2             MOV      R10,R4
   \       0xB6   0x0035             MOVS     R5,R6
   \       0xB8   0xF118 0x0928      ADDS     R9,R8,#+40
   \       0xBC   0x4652             MOV      R2,R10
   \       0xBE   0x0029             MOVS     R1,R5
   \       0xC0   0x4648             MOV      R0,R9
   \       0xC2   0x.... 0x....      BL       __aeabi_memcpy
    501                  ctx->iv_size = actual_iv_size;
   \       0xC6   0xF8C8 0x4038      STR      R4,[R8, #+56]
    502              }
    503          
    504              return 0;
   \                     ??mbedtls_cipher_set_iv_11: (+1)
   \       0xCA   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_set_iv_1: (+1)
   \       0xCC   0xE8BD 0x87F0      POP      {R4-R10,PC}
    505          }
    506          

   \                                 In section .text, align 2, keep-with-next
    507          int mbedtls_cipher_reset(mbedtls_cipher_context_t *ctx)
    508          {
   \                     mbedtls_cipher_reset: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    509              if (ctx->cipher_info == NULL) {
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD102             BNE.N    ??mbedtls_cipher_reset_0
    510                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \        0xC   0xE009             B.N      ??mbedtls_cipher_reset_1
    511              }
    512          
    513          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    514              if (ctx->psa_enabled == 1) {
   \                     ??mbedtls_cipher_reset_0: (+1)
   \        0xE   0xF891 0x0044      LDRB     R0,[R1, #+68]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD102             BNE.N    ??mbedtls_cipher_reset_2
    515                  /* We don't support resetting PSA-based
    516                   * cipher contexts, yet. */
    517                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x1A   0xE002             B.N      ??mbedtls_cipher_reset_1
    518              }
    519          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    520          
    521              ctx->unprocessed_len = 0;
   \                     ??mbedtls_cipher_reset_2: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x6248             STR      R0,[R1, #+36]
    522          
    523              return 0;
   \       0x20   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_reset_1: (+1)
   \       0x22   0x4770             BX       LR
    524          }
    525          
    526          #if defined(MBEDTLS_GCM_C) || defined(MBEDTLS_CHACHAPOLY_C)
    527          int mbedtls_cipher_update_ad(mbedtls_cipher_context_t *ctx,
    528                                       const unsigned char *ad, size_t ad_len)
    529          {
    530              if (ctx->cipher_info == NULL) {
    531                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    532              }
    533          
    534          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    535              if (ctx->psa_enabled == 1) {
    536                  /* While PSA Crypto has an API for multipart
    537                   * operations, we currently don't make it
    538                   * accessible through the cipher layer. */
    539                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    540              }
    541          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    542          
    543          #if defined(MBEDTLS_GCM_C)
    544              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
    545                  return mbedtls_gcm_update_ad((mbedtls_gcm_context *) ctx->cipher_ctx,
    546                                               ad, ad_len);
    547              }
    548          #endif
    549          
    550          #if defined(MBEDTLS_CHACHAPOLY_C)
    551              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
    552                  int result;
    553                  mbedtls_chachapoly_mode_t mode;
    554          
    555                  mode = (ctx->operation == MBEDTLS_ENCRYPT)
    556                          ? MBEDTLS_CHACHAPOLY_ENCRYPT
    557                          : MBEDTLS_CHACHAPOLY_DECRYPT;
    558          
    559                  result = mbedtls_chachapoly_starts((mbedtls_chachapoly_context *) ctx->cipher_ctx,
    560                                                     ctx->iv,
    561                                                     mode);
    562                  if (result != 0) {
    563                      return result;
    564                  }
    565          
    566                  return mbedtls_chachapoly_update_aad((mbedtls_chachapoly_context *) ctx->cipher_ctx,
    567                                                       ad, ad_len);
    568              }
    569          #endif
    570          
    571              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    572          }
    573          #endif /* MBEDTLS_GCM_C || MBEDTLS_CHACHAPOLY_C */
    574          

   \                                 In section .text, align 2, keep-with-next
    575          int mbedtls_cipher_update(mbedtls_cipher_context_t *ctx, const unsigned char *input,
    576                                    size_t ilen, unsigned char *output, size_t *olen)
    577          {
   \                     mbedtls_cipher_update: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000F             MOVS     R7,R1
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0xF8DD 0x9038      LDR      R9,[SP, #+56]
    578              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x0A6D      MVNS     R10,#+109
    579              size_t block_size;
    580          
    581              if (ctx->cipher_info == NULL) {
   \       0x16   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??mbedtls_cipher_update_0
    582                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x22   0xE118             B.N      ??mbedtls_cipher_update_1
    583              }
    584          
    585          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    586              if (ctx->psa_enabled == 1) {
   \                     ??mbedtls_cipher_update_0: (+1)
   \       0x24   0xF89B 0x0044      LDRB     R0,[R11, #+68]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD102             BNE.N    ??mbedtls_cipher_update_2
    587                  /* While PSA Crypto has an API for multipart
    588                   * operations, we currently don't make it
    589                   * accessible through the cipher layer. */
    590                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x30   0xE111             B.N      ??mbedtls_cipher_update_1
    591              }
    592          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    593          
    594              *olen = 0;
   \                     ??mbedtls_cipher_update_2: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF8C9 0x0000      STR      R0,[R9, #+0]
    595              block_size = mbedtls_cipher_get_block_size(ctx);
   \       0x38   0x4658             MOV      R0,R11
   \       0x3A   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \       0x3E   0x0005             MOVS     R5,R0
    596              if (0 == block_size) {
   \       0x40   0x2D00             CMP      R5,#+0
   \       0x42   0xD102             BNE.N    ??mbedtls_cipher_update_3
    597                  return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \       0x48   0xE105             B.N      ??mbedtls_cipher_update_1
    598              }
    599          
    600              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_ECB) {
   \                     ??mbedtls_cipher_update_3: (+1)
   \       0x4A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x4E   0x6840             LDR      R0,[R0, #+4]
   \       0x50   0x0B00             LSRS     R0,R0,#+12
   \       0x52   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD11A             BNE.N    ??mbedtls_cipher_update_4
    601                  if (ilen != block_size) {
   \       0x5A   0x42AC             CMP      R4,R5
   \       0x5C   0xD002             BEQ.N    ??mbedtls_cipher_update_5
    602                      return MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED;
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \       0x62   0xE0F8             B.N      ??mbedtls_cipher_update_1
    603                  }
    604          
    605                  *olen = ilen;
   \                     ??mbedtls_cipher_update_5: (+1)
   \       0x64   0xF8C9 0x4000      STR      R4,[R9, #+0]
    606          
    607                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->ecb_func(ctx->cipher_ctx,
    608                                                                                      ctx->operation, input,
    609                                                                                      output))) {
   \       0x68   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x6C   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0x70   0x0006             MOVS     R6,R0
   \       0x72   0x4643             MOV      R3,R8
   \       0x74   0x003A             MOVS     R2,R7
   \       0x76   0xF99B 0x1008      LDRSB    R1,[R11, #+8]
   \       0x7A   0xF8DB 0x003C      LDR      R0,[R11, #+60]
   \       0x7E   0x6876             LDR      R6,[R6, #+4]
   \       0x80   0x47B0             BLX      R6
   \       0x82   0x0001             MOVS     R1,R0
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD001             BEQ.N    ??mbedtls_cipher_update_6
    610                      return ret;
   \       0x88   0x0008             MOVS     R0,R1
   \       0x8A   0xE0E4             B.N      ??mbedtls_cipher_update_1
    611                  }
    612          
    613                  return 0;
   \                     ??mbedtls_cipher_update_6: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xE0E2             B.N      ??mbedtls_cipher_update_1
    614              }
    615          
    616          #if defined(MBEDTLS_GCM_C)
    617              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_GCM) {
    618                  return mbedtls_gcm_update((mbedtls_gcm_context *) ctx->cipher_ctx,
    619                                            input, ilen,
    620                                            output, ilen, olen);
    621              }
    622          #endif
    623          
    624          #if defined(MBEDTLS_CCM_C)
    625              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_CCM_STAR_NO_TAG) {
   \                     ??mbedtls_cipher_update_4: (+1)
   \       0x90   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x94   0x6840             LDR      R0,[R0, #+4]
   \       0x96   0x0B00             LSRS     R0,R0,#+12
   \       0x98   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x9C   0x2809             CMP      R0,#+9
   \       0x9E   0xD10A             BNE.N    ??mbedtls_cipher_update_7
    626                  return mbedtls_ccm_update((mbedtls_ccm_context *) ctx->cipher_ctx,
    627                                            input, ilen,
    628                                            output, ilen, olen);
   \       0xA0   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0xA4   0x9400             STR      R4,[SP, #+0]
   \       0xA6   0x4643             MOV      R3,R8
   \       0xA8   0x0022             MOVS     R2,R4
   \       0xAA   0x0039             MOVS     R1,R7
   \       0xAC   0xF8DB 0x003C      LDR      R0,[R11, #+60]
   \       0xB0   0x.... 0x....      BL       mbedtls_ccm_update
   \       0xB4   0xE0CF             B.N      ??mbedtls_cipher_update_1
    629              }
    630          #endif
    631          
    632          #if defined(MBEDTLS_CHACHAPOLY_C)
    633              if (((mbedtls_cipher_type_t) ctx->cipher_info->type) == MBEDTLS_CIPHER_CHACHA20_POLY1305) {
    634                  *olen = ilen;
    635                  return mbedtls_chachapoly_update((mbedtls_chachapoly_context *) ctx->cipher_ctx,
    636                                                   ilen, input, output);
    637              }
    638          #endif
    639          
    640              if (input == output &&
    641                  (ctx->unprocessed_len != 0 || ilen % block_size)) {
   \                     ??mbedtls_cipher_update_7: (+1)
   \       0xB6   0x4547             CMP      R7,R8
   \       0xB8   0xD10C             BNE.N    ??mbedtls_cipher_update_8
   \       0xBA   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD105             BNE.N    ??mbedtls_cipher_update_9
   \       0xC2   0xFBB4 0xF0F5      UDIV     R0,R4,R5
   \       0xC6   0xFB05 0x4010      MLS      R0,R5,R0,R4
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD002             BEQ.N    ??mbedtls_cipher_update_8
    642                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_update_9: (+1)
   \       0xCE   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0xD2   0xE0C0             B.N      ??mbedtls_cipher_update_1
    643              }
    644          
    645          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    646              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_CBC) {
   \                     ??mbedtls_cipher_update_8: (+1)
   \       0xD4   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0xD8   0x6840             LDR      R0,[R0, #+4]
   \       0xDA   0x0B00             LSRS     R0,R0,#+12
   \       0xDC   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xE0   0x2802             CMP      R0,#+2
   \       0xE2   0xF040 0x80B6      BNE.W    ??mbedtls_cipher_update_10
    647                  size_t copy_len = 0;
   \       0xE6   0x2600             MOVS     R6,#+0
    648          
    649                  /*
    650                   * If there is not enough data for a full block, cache it.
    651                   */
    652                  if ((ctx->operation == MBEDTLS_DECRYPT && NULL != ctx->add_padding &&
    653                       ilen <= block_size - ctx->unprocessed_len) ||
    654                      (ctx->operation == MBEDTLS_DECRYPT && NULL == ctx->add_padding &&
    655                       ilen < block_size - ctx->unprocessed_len) ||
    656                      (ctx->operation == MBEDTLS_ENCRYPT &&
    657                       ilen < block_size - ctx->unprocessed_len)) {
   \       0xE8   0xF99B 0x0008      LDRSB    R0,[R11, #+8]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD108             BNE.N    ??mbedtls_cipher_update_11
   \       0xF0   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \       0xF4   0x2800             CMP      R0,#+0
   \       0xF6   0xD004             BEQ.N    ??mbedtls_cipher_update_11
   \       0xF8   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \       0xFC   0x1A28             SUBS     R0,R5,R0
   \       0xFE   0x42A0             CMP      R0,R4
   \      0x100   0xD215             BCS.N    ??mbedtls_cipher_update_12
   \                     ??mbedtls_cipher_update_11: (+1)
   \      0x102   0xF99B 0x0008      LDRSB    R0,[R11, #+8]
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD108             BNE.N    ??mbedtls_cipher_update_13
   \      0x10A   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD104             BNE.N    ??mbedtls_cipher_update_13
   \      0x112   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \      0x116   0x1A28             SUBS     R0,R5,R0
   \      0x118   0x4284             CMP      R4,R0
   \      0x11A   0xD308             BCC.N    ??mbedtls_cipher_update_12
   \                     ??mbedtls_cipher_update_13: (+1)
   \      0x11C   0xF99B 0x0008      LDRSB    R0,[R11, #+8]
   \      0x120   0x2801             CMP      R0,#+1
   \      0x122   0xD118             BNE.N    ??mbedtls_cipher_update_14
   \      0x124   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \      0x128   0x1A28             SUBS     R0,R5,R0
   \      0x12A   0x4284             CMP      R4,R0
   \      0x12C   0xD213             BCS.N    ??mbedtls_cipher_update_14
    658                      memcpy(&(ctx->unprocessed_data[ctx->unprocessed_len]), input,
    659                             ilen);
   \                     ??mbedtls_cipher_update_12: (+1)
   \      0x12E   0x9402             STR      R4,[SP, #+8]
   \      0x130   0x9701             STR      R7,[SP, #+4]
   \      0x132   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \      0x136   0x4458             ADD      R0,R11,R0
   \      0x138   0x3014             ADDS     R0,R0,#+20
   \      0x13A   0x9000             STR      R0,[SP, #+0]
   \      0x13C   0x9A02             LDR      R2,[SP, #+8]
   \      0x13E   0x9901             LDR      R1,[SP, #+4]
   \      0x140   0x9800             LDR      R0,[SP, #+0]
   \      0x142   0x.... 0x....      BL       __aeabi_memcpy
   \      0x146   0x9800             LDR      R0,[SP, #+0]
    660          
    661                      ctx->unprocessed_len += ilen;
   \      0x148   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \      0x14C   0x1820             ADDS     R0,R4,R0
   \      0x14E   0xF8CB 0x0024      STR      R0,[R11, #+36]
    662                      return 0;
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0xE07F             B.N      ??mbedtls_cipher_update_1
    663                  }
    664          
    665                  /*
    666                   * Process cached data first
    667                   */
    668                  if (0 != ctx->unprocessed_len) {
   \                     ??mbedtls_cipher_update_14: (+1)
   \      0x156   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \      0x15A   0x2800             CMP      R0,#+0
   \      0x15C   0xD034             BEQ.N    ??mbedtls_cipher_update_15
    669                      copy_len = block_size - ctx->unprocessed_len;
   \      0x15E   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \      0x162   0x1A28             SUBS     R0,R5,R0
   \      0x164   0x0006             MOVS     R6,R0
    670          
    671                      memcpy(&(ctx->unprocessed_data[ctx->unprocessed_len]), input,
    672                             copy_len);
   \      0x166   0x9603             STR      R6,[SP, #+12]
   \      0x168   0x9702             STR      R7,[SP, #+8]
   \      0x16A   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \      0x16E   0x4458             ADD      R0,R11,R0
   \      0x170   0x3014             ADDS     R0,R0,#+20
   \      0x172   0x9000             STR      R0,[SP, #+0]
   \      0x174   0x9A03             LDR      R2,[SP, #+12]
   \      0x176   0x9902             LDR      R1,[SP, #+8]
   \      0x178   0x9800             LDR      R0,[SP, #+0]
   \      0x17A   0x.... 0x....      BL       __aeabi_memcpy
   \      0x17E   0x9800             LDR      R0,[SP, #+0]
    673          
    674                      if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->cbc_func(ctx->cipher_ctx,
    675                                                                                          ctx->operation,
    676                                                                                          block_size, ctx->iv,
    677                                                                                          ctx->
    678                                                                                          unprocessed_data,
    679                                                                                          output))) {
   \      0x180   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x184   0x.... 0x....      BL       mbedtls_cipher_get_base
   \      0x188   0x4684             MOV      R12,R0
   \      0x18A   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \      0x18E   0xF11B 0x0014      ADDS     R0,R11,#+20
   \      0x192   0x9000             STR      R0,[SP, #+0]
   \      0x194   0xF11B 0x0328      ADDS     R3,R11,#+40
   \      0x198   0x002A             MOVS     R2,R5
   \      0x19A   0xF99B 0x1008      LDRSB    R1,[R11, #+8]
   \      0x19E   0xF8DB 0x003C      LDR      R0,[R11, #+60]
   \      0x1A2   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \      0x1A6   0x47E0             BLX      R12
   \      0x1A8   0x4682             MOV      R10,R0
   \      0x1AA   0x2800             CMP      R0,#+0
   \      0x1AC   0xD001             BEQ.N    ??mbedtls_cipher_update_16
    680                          return ret;
   \      0x1AE   0x4650             MOV      R0,R10
   \      0x1B0   0xE051             B.N      ??mbedtls_cipher_update_1
    681                      }
    682          
    683                      *olen += block_size;
   \                     ??mbedtls_cipher_update_16: (+1)
   \      0x1B2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x1B6   0x1828             ADDS     R0,R5,R0
   \      0x1B8   0xF8C9 0x0000      STR      R0,[R9, #+0]
    684                      output += block_size;
   \      0x1BC   0x44A8             ADD      R8,R8,R5
    685                      ctx->unprocessed_len = 0;
   \      0x1BE   0x2000             MOVS     R0,#+0
   \      0x1C0   0xF8CB 0x0024      STR      R0,[R11, #+36]
    686          
    687                      input += copy_len;
   \      0x1C4   0x4437             ADD      R7,R7,R6
    688                      ilen -= copy_len;
   \      0x1C6   0x1BA4             SUBS     R4,R4,R6
    689                  }
    690          
    691                  /*
    692                   * Cache final, incomplete block
    693                   */
    694                  if (0 != ilen) {
   \                     ??mbedtls_cipher_update_15: (+1)
   \      0x1C8   0x2C00             CMP      R4,#+0
   \      0x1CA   0xD022             BEQ.N    ??mbedtls_cipher_update_17
    695                      /* Encryption: only cache partial blocks
    696                       * Decryption w/ padding: always keep at least one whole block
    697                       * Decryption w/o padding: only cache partial blocks
    698                       */
    699                      copy_len = ilen % block_size;
   \      0x1CC   0xFBB4 0xF0F5      UDIV     R0,R4,R5
   \      0x1D0   0xFB05 0x4010      MLS      R0,R5,R0,R4
   \      0x1D4   0x0006             MOVS     R6,R0
    700                      if (copy_len == 0 &&
    701                          ctx->operation == MBEDTLS_DECRYPT &&
    702                          NULL != ctx->add_padding) {
   \      0x1D6   0x2E00             CMP      R6,#+0
   \      0x1D8   0xD108             BNE.N    ??mbedtls_cipher_update_18
   \      0x1DA   0xF99B 0x0008      LDRSB    R0,[R11, #+8]
   \      0x1DE   0x2800             CMP      R0,#+0
   \      0x1E0   0xD104             BNE.N    ??mbedtls_cipher_update_18
   \      0x1E2   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \      0x1E6   0x2800             CMP      R0,#+0
   \      0x1E8   0xD000             BEQ.N    ??mbedtls_cipher_update_18
    703                          copy_len = block_size;
   \      0x1EA   0x002E             MOVS     R6,R5
    704                      }
    705          
    706                      memcpy(ctx->unprocessed_data, &(input[ilen - copy_len]),
    707                             copy_len);
   \                     ??mbedtls_cipher_update_18: (+1)
   \      0x1EC   0x9602             STR      R6,[SP, #+8]
   \      0x1EE   0x1BA0             SUBS     R0,R4,R6
   \      0x1F0   0x4438             ADD      R0,R7,R0
   \      0x1F2   0x9001             STR      R0,[SP, #+4]
   \      0x1F4   0xF11B 0x0014      ADDS     R0,R11,#+20
   \      0x1F8   0x9000             STR      R0,[SP, #+0]
   \      0x1FA   0x9A02             LDR      R2,[SP, #+8]
   \      0x1FC   0x9901             LDR      R1,[SP, #+4]
   \      0x1FE   0x9800             LDR      R0,[SP, #+0]
   \      0x200   0x.... 0x....      BL       __aeabi_memcpy
   \      0x204   0x9800             LDR      R0,[SP, #+0]
    708          
    709                      ctx->unprocessed_len += copy_len;
   \      0x206   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \      0x20A   0x1830             ADDS     R0,R6,R0
   \      0x20C   0xF8CB 0x0024      STR      R0,[R11, #+36]
    710                      ilen -= copy_len;
   \      0x210   0x1BA4             SUBS     R4,R4,R6
    711                  }
    712          
    713                  /*
    714                   * Process remaining full blocks
    715                   */
    716                  if (ilen) {
   \                     ??mbedtls_cipher_update_17: (+1)
   \      0x212   0x2C00             CMP      R4,#+0
   \      0x214   0xD01B             BEQ.N    ??mbedtls_cipher_update_19
    717                      if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->cbc_func(ctx->cipher_ctx,
    718                                                                                          ctx->operation,
    719                                                                                          ilen, ctx->iv,
    720                                                                                          input,
    721                                                                                          output))) {
   \      0x216   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x21A   0x.... 0x....      BL       mbedtls_cipher_get_base
   \      0x21E   0x4684             MOV      R12,R0
   \      0x220   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \      0x224   0x9700             STR      R7,[SP, #+0]
   \      0x226   0xF11B 0x0328      ADDS     R3,R11,#+40
   \      0x22A   0x0022             MOVS     R2,R4
   \      0x22C   0xF99B 0x1008      LDRSB    R1,[R11, #+8]
   \      0x230   0xF8DB 0x003C      LDR      R0,[R11, #+60]
   \      0x234   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \      0x238   0x47E0             BLX      R12
   \      0x23A   0x4682             MOV      R10,R0
   \      0x23C   0x2800             CMP      R0,#+0
   \      0x23E   0xD001             BEQ.N    ??mbedtls_cipher_update_20
    722                          return ret;
   \      0x240   0x4650             MOV      R0,R10
   \      0x242   0xE008             B.N      ??mbedtls_cipher_update_1
    723                      }
    724          
    725                      *olen += ilen;
   \                     ??mbedtls_cipher_update_20: (+1)
   \      0x244   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x248   0x1820             ADDS     R0,R4,R0
   \      0x24A   0xF8C9 0x0000      STR      R0,[R9, #+0]
    726                  }
    727          
    728                  return 0;
   \                     ??mbedtls_cipher_update_19: (+1)
   \      0x24E   0x2000             MOVS     R0,#+0
   \      0x250   0xE001             B.N      ??mbedtls_cipher_update_1
    729              }
    730          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    731          
    732          #if defined(MBEDTLS_CIPHER_MODE_CFB)
    733              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_CFB) {
    734                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->cfb_func(ctx->cipher_ctx,
    735                                                                                      ctx->operation, ilen,
    736                                                                                      &ctx->unprocessed_len,
    737                                                                                      ctx->iv,
    738                                                                                      input, output))) {
    739                      return ret;
    740                  }
    741          
    742                  *olen = ilen;
    743          
    744                  return 0;
    745              }
    746          #endif /* MBEDTLS_CIPHER_MODE_CFB */
    747          
    748          #if defined(MBEDTLS_CIPHER_MODE_OFB)
    749              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_OFB) {
    750                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->ofb_func(ctx->cipher_ctx,
    751                                                                                      ilen,
    752                                                                                      &ctx->unprocessed_len,
    753                                                                                      ctx->iv,
    754                                                                                      input, output))) {
    755                      return ret;
    756                  }
    757          
    758                  *olen = ilen;
    759          
    760                  return 0;
    761              }
    762          #endif /* MBEDTLS_CIPHER_MODE_OFB */
    763          
    764          #if defined(MBEDTLS_CIPHER_MODE_CTR)
    765              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_CTR) {
    766                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->ctr_func(ctx->cipher_ctx,
    767                                                                                      ilen,
    768                                                                                      &ctx->unprocessed_len,
    769                                                                                      ctx->iv,
    770                                                                                      ctx->unprocessed_data,
    771                                                                                      input, output))) {
    772                      return ret;
    773                  }
    774          
    775                  *olen = ilen;
    776          
    777                  return 0;
    778              }
    779          #endif /* MBEDTLS_CIPHER_MODE_CTR */
    780          
    781          #if defined(MBEDTLS_CIPHER_MODE_XTS)
    782              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_XTS) {
    783                  if (ctx->unprocessed_len > 0) {
    784                      /* We can only process an entire data unit at a time. */
    785                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    786                  }
    787          
    788                  ret = mbedtls_cipher_get_base(ctx->cipher_info)->xts_func(ctx->cipher_ctx,
    789                                                                            ctx->operation,
    790                                                                            ilen,
    791                                                                            ctx->iv,
    792                                                                            input,
    793                                                                            output);
    794                  if (ret != 0) {
    795                      return ret;
    796                  }
    797          
    798                  *olen = ilen;
    799          
    800                  return 0;
    801              }
    802          #endif /* MBEDTLS_CIPHER_MODE_XTS */
    803          
    804          #if defined(MBEDTLS_CIPHER_MODE_STREAM)
    805              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_STREAM) {
    806                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->stream_func(ctx->cipher_ctx,
    807                                                                                         ilen, input,
    808                                                                                         output))) {
    809                      return ret;
    810                  }
    811          
    812                  *olen = ilen;
    813          
    814                  return 0;
    815              }
    816          #endif /* MBEDTLS_CIPHER_MODE_STREAM */
    817          
    818              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_cipher_update_10: (+1)
   \      0x252   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \                     ??mbedtls_cipher_update_1: (+1)
   \      0x256   0xB005             ADD      SP,SP,#+20
   \      0x258   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    819          }
    820          
    821          #if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
    822          #if defined(MBEDTLS_CIPHER_PADDING_PKCS7)
    823          /*
    824           * PKCS7 (and PKCS5) padding: fill with ll bytes, with ll = padding_len
    825           */
    826          static void add_pkcs_padding(unsigned char *output, size_t output_len,
    827                                       size_t data_len)
    828          {
    829              size_t padding_len = output_len - data_len;
    830              unsigned char i;
    831          
    832              for (i = 0; i < padding_len; i++) {
    833                  output[data_len + i] = (unsigned char) padding_len;
    834              }
    835          }
    836          
    837          static int get_pkcs_padding(unsigned char *input, size_t input_len,
    838                                      size_t *data_len)
    839          {
    840              size_t i, pad_idx;
    841              unsigned char padding_len;
    842          
    843              if (NULL == input || NULL == data_len) {
    844                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    845              }
    846          
    847              padding_len = input[input_len - 1];
    848              *data_len = input_len - padding_len;
    849          
    850              mbedtls_ct_condition_t bad = mbedtls_ct_uint_gt(padding_len, input_len);
    851              bad = mbedtls_ct_bool_or(bad, mbedtls_ct_uint_eq(padding_len, 0));
    852          
    853              /* The number of bytes checked must be independent of padding_len,
    854               * so pick input_len, which is usually 8 or 16 (one block) */
    855              pad_idx = input_len - padding_len;
    856              for (i = 0; i < input_len; i++) {
    857                  mbedtls_ct_condition_t in_padding = mbedtls_ct_uint_ge(i, pad_idx);
    858                  mbedtls_ct_condition_t different  = mbedtls_ct_uint_ne(input[i], padding_len);
    859                  bad = mbedtls_ct_bool_or(bad, mbedtls_ct_bool_and(in_padding, different));
    860              }
    861          
    862              return mbedtls_ct_error_if_else_0(bad, MBEDTLS_ERR_CIPHER_INVALID_PADDING);
    863          }
    864          #endif /* MBEDTLS_CIPHER_PADDING_PKCS7 */
    865          
    866          #if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)
    867          /*
    868           * One and zeros padding: fill with 80 00 ... 00
    869           */
    870          static void add_one_and_zeros_padding(unsigned char *output,
    871                                                size_t output_len, size_t data_len)
    872          {
    873              size_t padding_len = output_len - data_len;
    874              unsigned char i = 0;
    875          
    876              output[data_len] = 0x80;
    877              for (i = 1; i < padding_len; i++) {
    878                  output[data_len + i] = 0x00;
    879              }
    880          }
    881          
    882          static int get_one_and_zeros_padding(unsigned char *input, size_t input_len,
    883                                               size_t *data_len)
    884          {
    885              if (NULL == input || NULL == data_len) {
    886                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    887              }
    888          
    889              mbedtls_ct_condition_t in_padding = MBEDTLS_CT_TRUE;
    890              mbedtls_ct_condition_t bad = MBEDTLS_CT_TRUE;
    891          
    892              *data_len = 0;
    893          
    894              for (ptrdiff_t i = (ptrdiff_t) (input_len) - 1; i >= 0; i--) {
    895                  mbedtls_ct_condition_t is_nonzero = mbedtls_ct_bool(input[i]);
    896          
    897                  mbedtls_ct_condition_t hit_first_nonzero = mbedtls_ct_bool_and(is_nonzero, in_padding);
    898          
    899                  *data_len = mbedtls_ct_size_if(hit_first_nonzero, i, *data_len);
    900          
    901                  bad = mbedtls_ct_bool_if(hit_first_nonzero, mbedtls_ct_uint_ne(input[i], 0x80), bad);
    902          
    903                  in_padding = mbedtls_ct_bool_and(in_padding, mbedtls_ct_bool_not(is_nonzero));
    904              }
    905          
    906              return mbedtls_ct_error_if_else_0(bad, MBEDTLS_ERR_CIPHER_INVALID_PADDING);
    907          }
    908          #endif /* MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS */
    909          
    910          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)
    911          /*
    912           * Zeros and len padding: fill with 00 ... 00 ll, where ll is padding length
    913           */
    914          static void add_zeros_and_len_padding(unsigned char *output,
    915                                                size_t output_len, size_t data_len)
    916          {
    917              size_t padding_len = output_len - data_len;
    918              unsigned char i = 0;
    919          
    920              for (i = 1; i < padding_len; i++) {
    921                  output[data_len + i - 1] = 0x00;
    922              }
    923              output[output_len - 1] = (unsigned char) padding_len;
    924          }
    925          
    926          static int get_zeros_and_len_padding(unsigned char *input, size_t input_len,
    927                                               size_t *data_len)
    928          {
    929              size_t i, pad_idx;
    930              unsigned char padding_len;
    931              mbedtls_ct_condition_t bad;
    932          
    933              if (NULL == input || NULL == data_len) {
    934                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    935              }
    936          
    937              padding_len = input[input_len - 1];
    938              *data_len = input_len - padding_len;
    939          
    940              /* Avoid logical || since it results in a branch */
    941              bad = mbedtls_ct_uint_gt(padding_len, input_len);
    942              bad = mbedtls_ct_bool_or(bad, mbedtls_ct_uint_eq(padding_len, 0));
    943          
    944              /* The number of bytes checked must be independent of padding_len */
    945              pad_idx = input_len - padding_len;
    946              for (i = 0; i < input_len - 1; i++) {
    947                  mbedtls_ct_condition_t is_padding = mbedtls_ct_uint_ge(i, pad_idx);
    948                  mbedtls_ct_condition_t nonzero_pad_byte;
    949                  nonzero_pad_byte = mbedtls_ct_bool_if_else_0(is_padding, mbedtls_ct_bool(input[i]));
    950                  bad = mbedtls_ct_bool_or(bad, nonzero_pad_byte);
    951              }
    952          
    953              return mbedtls_ct_error_if_else_0(bad, MBEDTLS_ERR_CIPHER_INVALID_PADDING);
    954          }
    955          #endif /* MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN */
    956          
    957          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS)
    958          /*
    959           * Zero padding: fill with 00 ... 00
    960           */
    961          static void add_zeros_padding(unsigned char *output,
    962                                        size_t output_len, size_t data_len)
    963          {
    964              memset(output + data_len, 0, output_len - data_len);
    965          }
    966          
    967          static int get_zeros_padding(unsigned char *input, size_t input_len,
    968                                       size_t *data_len)
    969          {
    970              size_t i;
    971              mbedtls_ct_condition_t done = MBEDTLS_CT_FALSE, prev_done;
    972          
    973              if (NULL == input || NULL == data_len) {
    974                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    975              }
    976          
    977              *data_len = 0;
    978              for (i = input_len; i > 0; i--) {
    979                  prev_done = done;
    980                  done = mbedtls_ct_bool_or(done, mbedtls_ct_uint_ne(input[i-1], 0));
    981                  *data_len = mbedtls_ct_size_if(mbedtls_ct_bool_ne(done, prev_done), i, *data_len);
    982              }
    983          
    984              return 0;
    985          }
    986          #endif /* MBEDTLS_CIPHER_PADDING_ZEROS */
    987          
    988          /*
    989           * No padding: don't pad :)
    990           *
    991           * There is no add_padding function (check for NULL in mbedtls_cipher_finish)
    992           * but a trivial get_padding function
    993           */

   \                                 In section .text, align 2, keep-with-next
    994          static int get_no_padding(unsigned char *input, size_t input_len,
    995                                    size_t *data_len)
    996          {
   \                     get_no_padding: (+1)
   \        0x0   0x0003             MOVS     R3,R0
    997              if (NULL == input || NULL == data_len) {
   \        0x2   0x2B00             CMP      R3,#+0
   \        0x4   0xD001             BEQ.N    ??get_no_padding_0
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD102             BNE.N    ??get_no_padding_1
    998                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??get_no_padding_0: (+1)
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \        0xE   0xE001             B.N      ??get_no_padding_2
    999              }
   1000          
   1001              *data_len = input_len;
   \                     ??get_no_padding_1: (+1)
   \       0x10   0x6011             STR      R1,[R2, #+0]
   1002          
   1003              return 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \                     ??get_no_padding_2: (+1)
   \       0x14   0x4770             BX       LR
   1004          }
   1005          #endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */
   1006          

   \                                 In section .text, align 2, keep-with-next
   1007          int mbedtls_cipher_finish(mbedtls_cipher_context_t *ctx,
   1008                                    unsigned char *output, size_t *olen)
   1009          {
   \                     mbedtls_cipher_finish: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   1010              if (ctx->cipher_info == NULL) {
   \        0xA   0x6830             LDR      R0,[R6, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD102             BNE.N    ??mbedtls_cipher_finish_0
   1011                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x14   0xE0C6             B.N      ??mbedtls_cipher_finish_1
   1012              }
   1013          
   1014          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1015              if (ctx->psa_enabled == 1) {
   \                     ??mbedtls_cipher_finish_0: (+1)
   \       0x16   0xF896 0x0044      LDRB     R0,[R6, #+68]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD102             BNE.N    ??mbedtls_cipher_finish_2
   1016                  /* While PSA Crypto has an API for multipart
   1017                   * operations, we currently don't make it
   1018                   * accessible through the cipher layer. */
   1019                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x22   0xE0BF             B.N      ??mbedtls_cipher_finish_1
   1020              }
   1021          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1022          
   1023              *olen = 0;
   \                     ??mbedtls_cipher_finish_2: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6028             STR      R0,[R5, #+0]
   1024          
   1025          #if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
   1026              /* CBC mode requires padding so we make sure a call to
   1027               * mbedtls_cipher_set_padding_mode has been done successfully. */
   1028              if (MBEDTLS_MODE_CBC == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \       0x28   0x6830             LDR      R0,[R6, #+0]
   \       0x2A   0x6840             LDR      R0,[R0, #+4]
   \       0x2C   0x0B00             LSRS     R0,R0,#+12
   \       0x2E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x32   0x2802             CMP      R0,#+2
   \       0x34   0xD105             BNE.N    ??mbedtls_cipher_finish_3
   1029                  if (ctx->get_padding == NULL) {
   \       0x36   0x6930             LDR      R0,[R6, #+16]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD102             BNE.N    ??mbedtls_cipher_finish_3
   1030                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x40   0xE0B0             B.N      ??mbedtls_cipher_finish_1
   1031                  }
   1032              }
   1033          #endif
   1034          
   1035              if (MBEDTLS_MODE_CFB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1036                  MBEDTLS_MODE_OFB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1037                  MBEDTLS_MODE_CTR == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1038                  MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1039                  MBEDTLS_MODE_CCM_STAR_NO_TAG == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1040                  MBEDTLS_MODE_XTS == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1041                  MBEDTLS_MODE_STREAM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \                     ??mbedtls_cipher_finish_3: (+1)
   \       0x42   0x6830             LDR      R0,[R6, #+0]
   \       0x44   0x6840             LDR      R0,[R0, #+4]
   \       0x46   0x0B00             LSRS     R0,R0,#+12
   \       0x48   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x4C   0x2803             CMP      R0,#+3
   \       0x4E   0xD029             BEQ.N    ??mbedtls_cipher_finish_4
   \       0x50   0x6830             LDR      R0,[R6, #+0]
   \       0x52   0x6840             LDR      R0,[R0, #+4]
   \       0x54   0x0B00             LSRS     R0,R0,#+12
   \       0x56   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x5A   0x2804             CMP      R0,#+4
   \       0x5C   0xD022             BEQ.N    ??mbedtls_cipher_finish_4
   \       0x5E   0x6830             LDR      R0,[R6, #+0]
   \       0x60   0x6840             LDR      R0,[R0, #+4]
   \       0x62   0x0B00             LSRS     R0,R0,#+12
   \       0x64   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x68   0x2805             CMP      R0,#+5
   \       0x6A   0xD01B             BEQ.N    ??mbedtls_cipher_finish_4
   \       0x6C   0x6830             LDR      R0,[R6, #+0]
   \       0x6E   0x6840             LDR      R0,[R0, #+4]
   \       0x70   0x0B00             LSRS     R0,R0,#+12
   \       0x72   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x76   0x2806             CMP      R0,#+6
   \       0x78   0xD014             BEQ.N    ??mbedtls_cipher_finish_4
   \       0x7A   0x6830             LDR      R0,[R6, #+0]
   \       0x7C   0x6840             LDR      R0,[R0, #+4]
   \       0x7E   0x0B00             LSRS     R0,R0,#+12
   \       0x80   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x84   0x2809             CMP      R0,#+9
   \       0x86   0xD00D             BEQ.N    ??mbedtls_cipher_finish_4
   \       0x88   0x6830             LDR      R0,[R6, #+0]
   \       0x8A   0x6840             LDR      R0,[R0, #+4]
   \       0x8C   0x0B00             LSRS     R0,R0,#+12
   \       0x8E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x92   0x280A             CMP      R0,#+10
   \       0x94   0xD006             BEQ.N    ??mbedtls_cipher_finish_4
   \       0x96   0x6830             LDR      R0,[R6, #+0]
   \       0x98   0x6840             LDR      R0,[R0, #+4]
   \       0x9A   0x0B00             LSRS     R0,R0,#+12
   \       0x9C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xA0   0x2807             CMP      R0,#+7
   \       0xA2   0xD101             BNE.N    ??mbedtls_cipher_finish_5
   1042                  return 0;
   \                     ??mbedtls_cipher_finish_4: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0xE07D             B.N      ??mbedtls_cipher_finish_1
   1043              }
   1044          
   1045              if ((MBEDTLS_CIPHER_CHACHA20          == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) ||
   1046                  (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type))) {
   \                     ??mbedtls_cipher_finish_5: (+1)
   \       0xA8   0x6830             LDR      R0,[R6, #+0]
   \       0xAA   0x6840             LDR      R0,[R0, #+4]
   \       0xAC   0x0C00             LSRS     R0,R0,#+16
   \       0xAE   0xB2C0             UXTB     R0,R0
   \       0xB0   0x284C             CMP      R0,#+76
   \       0xB2   0xD005             BEQ.N    ??mbedtls_cipher_finish_6
   \       0xB4   0x6830             LDR      R0,[R6, #+0]
   \       0xB6   0x6840             LDR      R0,[R0, #+4]
   \       0xB8   0x0C00             LSRS     R0,R0,#+16
   \       0xBA   0xB2C0             UXTB     R0,R0
   \       0xBC   0x284D             CMP      R0,#+77
   \       0xBE   0xD101             BNE.N    ??mbedtls_cipher_finish_7
   1047                  return 0;
   \                     ??mbedtls_cipher_finish_6: (+1)
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xE06F             B.N      ??mbedtls_cipher_finish_1
   1048              }
   1049          
   1050              if (MBEDTLS_MODE_ECB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \                     ??mbedtls_cipher_finish_7: (+1)
   \       0xC4   0x6830             LDR      R0,[R6, #+0]
   \       0xC6   0x6840             LDR      R0,[R0, #+4]
   \       0xC8   0x0B00             LSRS     R0,R0,#+12
   \       0xCA   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xCE   0x2801             CMP      R0,#+1
   \       0xD0   0xD107             BNE.N    ??mbedtls_cipher_finish_8
   1051                  if (ctx->unprocessed_len != 0) {
   \       0xD2   0x6A70             LDR      R0,[R6, #+36]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD002             BEQ.N    ??mbedtls_cipher_finish_9
   1052                      return MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED;
   \       0xD8   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \       0xDC   0xE062             B.N      ??mbedtls_cipher_finish_1
   1053                  }
   1054          
   1055                  return 0;
   \                     ??mbedtls_cipher_finish_9: (+1)
   \       0xDE   0x2000             MOVS     R0,#+0
   \       0xE0   0xE060             B.N      ??mbedtls_cipher_finish_1
   1056              }
   1057          
   1058          #if defined(MBEDTLS_CIPHER_MODE_CBC)
   1059              if (MBEDTLS_MODE_CBC == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \                     ??mbedtls_cipher_finish_8: (+1)
   \       0xE2   0x6830             LDR      R0,[R6, #+0]
   \       0xE4   0x6840             LDR      R0,[R0, #+4]
   \       0xE6   0x0B00             LSRS     R0,R0,#+12
   \       0xE8   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xEC   0x2802             CMP      R0,#+2
   \       0xEE   0xD157             BNE.N    ??mbedtls_cipher_finish_10
   1060                  int ret = 0;
   \       0xF0   0x2700             MOVS     R7,#+0
   1061          
   1062                  if (MBEDTLS_ENCRYPT == ctx->operation) {
   \       0xF2   0xF996 0x0008      LDRSB    R0,[R6, #+8]
   \       0xF6   0x2801             CMP      R0,#+1
   \       0xF8   0xD114             BNE.N    ??mbedtls_cipher_finish_11
   1063                      /* check for 'no padding' mode */
   1064                      if (NULL == ctx->add_padding) {
   \       0xFA   0x68F0             LDR      R0,[R6, #+12]
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD107             BNE.N    ??mbedtls_cipher_finish_12
   1065                          if (0 != ctx->unprocessed_len) {
   \      0x100   0x6A70             LDR      R0,[R6, #+36]
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD002             BEQ.N    ??mbedtls_cipher_finish_13
   1066                              return MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED;
   \      0x106   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \      0x10A   0xE04B             B.N      ??mbedtls_cipher_finish_1
   1067                          }
   1068          
   1069                          return 0;
   \                     ??mbedtls_cipher_finish_13: (+1)
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0xE049             B.N      ??mbedtls_cipher_finish_1
   1070                      }
   1071          
   1072                      ctx->add_padding(ctx->unprocessed_data, mbedtls_cipher_get_iv_size(ctx),
   1073                                       ctx->unprocessed_len);
   \                     ??mbedtls_cipher_finish_12: (+1)
   \      0x110   0x0030             MOVS     R0,R6
   \      0x112   0x.... 0x....      BL       mbedtls_cipher_get_iv_size
   \      0x116   0x6A72             LDR      R2,[R6, #+36]
   \      0x118   0x0001             MOVS     R1,R0
   \      0x11A   0xF116 0x0014      ADDS     R0,R6,#+20
   \      0x11E   0x68F3             LDR      R3,[R6, #+12]
   \      0x120   0x4798             BLX      R3
   \      0x122   0xE010             B.N      ??mbedtls_cipher_finish_14
   1074                  } else if (mbedtls_cipher_get_block_size(ctx) != ctx->unprocessed_len) {
   \                     ??mbedtls_cipher_finish_11: (+1)
   \      0x124   0x0030             MOVS     R0,R6
   \      0x126   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \      0x12A   0x6A71             LDR      R1,[R6, #+36]
   \      0x12C   0x4288             CMP      R0,R1
   \      0x12E   0xD00A             BEQ.N    ??mbedtls_cipher_finish_14
   1075                      /*
   1076                       * For decrypt operations, expect a full block,
   1077                       * or an empty block if no padding
   1078                       */
   1079                      if (NULL == ctx->add_padding && 0 == ctx->unprocessed_len) {
   \      0x130   0x68F0             LDR      R0,[R6, #+12]
   \      0x132   0x2800             CMP      R0,#+0
   \      0x134   0xD104             BNE.N    ??mbedtls_cipher_finish_15
   \      0x136   0x6A70             LDR      R0,[R6, #+36]
   \      0x138   0x2800             CMP      R0,#+0
   \      0x13A   0xD101             BNE.N    ??mbedtls_cipher_finish_15
   1080                          return 0;
   \      0x13C   0x2000             MOVS     R0,#+0
   \      0x13E   0xE031             B.N      ??mbedtls_cipher_finish_1
   1081                      }
   1082          
   1083                      return MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED;
   \                     ??mbedtls_cipher_finish_15: (+1)
   \      0x140   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \      0x144   0xE02E             B.N      ??mbedtls_cipher_finish_1
   1084                  }
   1085          
   1086                  /* cipher block */
   1087                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->cbc_func(ctx->cipher_ctx,
   1088                                                                                      ctx->operation,
   1089                                                                                      mbedtls_cipher_get_block_size(
   1090                                                                                          ctx),
   1091                                                                                      ctx->iv,
   1092                                                                                      ctx->unprocessed_data,
   1093                                                                                      output))) {
   \                     ??mbedtls_cipher_finish_14: (+1)
   \      0x146   0x0030             MOVS     R0,R6
   \      0x148   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \      0x14C   0x4680             MOV      R8,R0
   \      0x14E   0x6830             LDR      R0,[R6, #+0]
   \      0x150   0x.... 0x....      BL       mbedtls_cipher_get_base
   \      0x154   0x4684             MOV      R12,R0
   \      0x156   0x9401             STR      R4,[SP, #+4]
   \      0x158   0xF116 0x0014      ADDS     R0,R6,#+20
   \      0x15C   0x9000             STR      R0,[SP, #+0]
   \      0x15E   0xF116 0x0328      ADDS     R3,R6,#+40
   \      0x162   0x4642             MOV      R2,R8
   \      0x164   0xF996 0x1008      LDRSB    R1,[R6, #+8]
   \      0x168   0x6BF0             LDR      R0,[R6, #+60]
   \      0x16A   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \      0x16E   0x47E0             BLX      R12
   \      0x170   0x4680             MOV      R8,R0
   \      0x172   0x2800             CMP      R0,#+0
   \      0x174   0xD001             BEQ.N    ??mbedtls_cipher_finish_16
   1094                      return ret;
   \      0x176   0x4640             MOV      R0,R8
   \      0x178   0xE014             B.N      ??mbedtls_cipher_finish_1
   1095                  }
   1096          
   1097                  /* Set output size for decryption */
   1098                  if (MBEDTLS_DECRYPT == ctx->operation) {
   \                     ??mbedtls_cipher_finish_16: (+1)
   \      0x17A   0xF996 0x0008      LDRSB    R0,[R6, #+8]
   \      0x17E   0x2800             CMP      R0,#+0
   \      0x180   0xD108             BNE.N    ??mbedtls_cipher_finish_17
   1099                      return ctx->get_padding(output, mbedtls_cipher_get_block_size(ctx),
   1100                                              olen);
   \      0x182   0x0030             MOVS     R0,R6
   \      0x184   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \      0x188   0x002A             MOVS     R2,R5
   \      0x18A   0x0001             MOVS     R1,R0
   \      0x18C   0x0020             MOVS     R0,R4
   \      0x18E   0x6933             LDR      R3,[R6, #+16]
   \      0x190   0x4798             BLX      R3
   \      0x192   0xE007             B.N      ??mbedtls_cipher_finish_1
   1101                  }
   1102          
   1103                  /* Set output size for encryption */
   1104                  *olen = mbedtls_cipher_get_block_size(ctx);
   \                     ??mbedtls_cipher_finish_17: (+1)
   \      0x194   0x0030             MOVS     R0,R6
   \      0x196   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \      0x19A   0x6028             STR      R0,[R5, #+0]
   1105                  return 0;
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0xE001             B.N      ??mbedtls_cipher_finish_1
   1106              }
   1107          #else
   1108              ((void) output);
   1109          #endif /* MBEDTLS_CIPHER_MODE_CBC */
   1110          
   1111              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_cipher_finish_10: (+1)
   \      0x1A0   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \                     ??mbedtls_cipher_finish_1: (+1)
   \      0x1A4   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1112          }
   1113          
   1114          #if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)

   \                                 In section .text, align 2, keep-with-next
   1115          int mbedtls_cipher_set_padding_mode(mbedtls_cipher_context_t *ctx,
   1116                                              mbedtls_cipher_padding_t mode)
   1117          {
   \                     mbedtls_cipher_set_padding_mode: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   1118              if (NULL == ctx->cipher_info ||
   1119                  MBEDTLS_MODE_CBC != ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \        0x2   0x6810             LDR      R0,[R2, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD006             BEQ.N    ??mbedtls_cipher_set_padding_mode_0
   \        0x8   0x6810             LDR      R0,[R2, #+0]
   \        0xA   0x6840             LDR      R0,[R0, #+4]
   \        0xC   0x0B00             LSRS     R0,R0,#+12
   \        0xE   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x12   0x2802             CMP      R0,#+2
   \       0x14   0xD002             BEQ.N    ??mbedtls_cipher_set_padding_mode_1
   1120                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_set_padding_mode_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x1A   0xE019             B.N      ??mbedtls_cipher_set_padding_mode_2
   1121              }
   1122          
   1123          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1124              if (ctx->psa_enabled == 1) {
   \                     ??mbedtls_cipher_set_padding_mode_1: (+1)
   \       0x1C   0xF892 0x0044      LDRB     R0,[R2, #+68]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD108             BNE.N    ??mbedtls_cipher_set_padding_mode_3
   1125                  /* While PSA Crypto knows about CBC padding
   1126                   * schemes, we currently don't make them
   1127                   * accessible through the cipher layer. */
   1128                  if (mode != MBEDTLS_PADDING_NONE) {
   \       0x24   0x0008             MOVS     R0,R1
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x2804             CMP      R0,#+4
   \       0x2A   0xD002             BEQ.N    ??mbedtls_cipher_set_padding_mode_4
   1129                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x30   0xE00E             B.N      ??mbedtls_cipher_set_padding_mode_2
   1130                  }
   1131          
   1132                  return 0;
   \                     ??mbedtls_cipher_set_padding_mode_4: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE00C             B.N      ??mbedtls_cipher_set_padding_mode_2
   1133              }
   1134          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1135          
   1136              switch (mode) {
   \                     ??mbedtls_cipher_set_padding_mode_3: (+1)
   \       0x36   0x0008             MOVS     R0,R1
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD106             BNE.N    ??mbedtls_cipher_set_padding_mode_5
   1137          #if defined(MBEDTLS_CIPHER_PADDING_PKCS7)
   1138                  case MBEDTLS_PADDING_PKCS7:
   1139                      ctx->add_padding = add_pkcs_padding;
   1140                      ctx->get_padding = get_pkcs_padding;
   1141                      break;
   1142          #endif
   1143          #if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)
   1144                  case MBEDTLS_PADDING_ONE_AND_ZEROS:
   1145                      ctx->add_padding = add_one_and_zeros_padding;
   1146                      ctx->get_padding = get_one_and_zeros_padding;
   1147                      break;
   1148          #endif
   1149          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)
   1150                  case MBEDTLS_PADDING_ZEROS_AND_LEN:
   1151                      ctx->add_padding = add_zeros_and_len_padding;
   1152                      ctx->get_padding = get_zeros_and_len_padding;
   1153                      break;
   1154          #endif
   1155          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS)
   1156                  case MBEDTLS_PADDING_ZEROS:
   1157                      ctx->add_padding = add_zeros_padding;
   1158                      ctx->get_padding = get_zeros_padding;
   1159                      break;
   1160          #endif
   1161                  case MBEDTLS_PADDING_NONE:
   1162                      ctx->add_padding = NULL;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x60D0             STR      R0,[R2, #+12]
   1163                      ctx->get_padding = get_no_padding;
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \       0x46   0x6110             STR      R0,[R2, #+16]
   1164                      break;
   1165          
   1166                  default:
   1167                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1168              }
   1169          
   1170              return 0;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xE001             B.N      ??mbedtls_cipher_set_padding_mode_2
   \                     ??mbedtls_cipher_set_padding_mode_5: (+1)
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \                     ??mbedtls_cipher_set_padding_mode_2: (+1)
   \       0x50   0x4770             BX       LR
   1171          }
   1172          #endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */
   1173          
   1174          #if defined(MBEDTLS_GCM_C) || defined(MBEDTLS_CHACHAPOLY_C)
   1175          int mbedtls_cipher_write_tag(mbedtls_cipher_context_t *ctx,
   1176                                       unsigned char *tag, size_t tag_len)
   1177          {
   1178              if (ctx->cipher_info == NULL) {
   1179                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1180              }
   1181          
   1182              if (MBEDTLS_ENCRYPT != ctx->operation) {
   1183                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1184              }
   1185          
   1186          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1187              if (ctx->psa_enabled == 1) {
   1188                  /* While PSA Crypto has an API for multipart
   1189                   * operations, we currently don't make it
   1190                   * accessible through the cipher layer. */
   1191                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1192              }
   1193          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1194          
   1195          #if defined(MBEDTLS_GCM_C)
   1196              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1197                  size_t output_length;
   1198                  /* The code here doesn't yet support alternative implementations
   1199                   * that can delay up to a block of output. */
   1200                  return mbedtls_gcm_finish((mbedtls_gcm_context *) ctx->cipher_ctx,
   1201                                            NULL, 0, &output_length,
   1202                                            tag, tag_len);
   1203              }
   1204          #endif
   1205          
   1206          #if defined(MBEDTLS_CHACHAPOLY_C)
   1207              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
   1208                  /* Don't allow truncated MAC for Poly1305 */
   1209                  if (tag_len != 16U) {
   1210                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1211                  }
   1212          
   1213                  return mbedtls_chachapoly_finish(
   1214                      (mbedtls_chachapoly_context *) ctx->cipher_ctx, tag);
   1215              }
   1216          #endif
   1217          
   1218              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1219          }
   1220          
   1221          int mbedtls_cipher_check_tag(mbedtls_cipher_context_t *ctx,
   1222                                       const unsigned char *tag, size_t tag_len)
   1223          {
   1224              unsigned char check_tag[16];
   1225              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1226          
   1227              if (ctx->cipher_info == NULL) {
   1228                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1229              }
   1230          
   1231              if (MBEDTLS_DECRYPT != ctx->operation) {
   1232                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1233              }
   1234          
   1235          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1236              if (ctx->psa_enabled == 1) {
   1237                  /* While PSA Crypto has an API for multipart
   1238                   * operations, we currently don't make it
   1239                   * accessible through the cipher layer. */
   1240                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1241              }
   1242          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1243          
   1244              /* Status to return on a non-authenticated algorithm. */
   1245              ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1246          
   1247          #if defined(MBEDTLS_GCM_C)
   1248              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1249                  size_t output_length;
   1250                  /* The code here doesn't yet support alternative implementations
   1251                   * that can delay up to a block of output. */
   1252          
   1253                  if (tag_len > sizeof(check_tag)) {
   1254                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1255                  }
   1256          
   1257                  if (0 != (ret = mbedtls_gcm_finish(
   1258                                (mbedtls_gcm_context *) ctx->cipher_ctx,
   1259                                NULL, 0, &output_length,
   1260                                check_tag, tag_len))) {
   1261                      return ret;
   1262                  }
   1263          
   1264                  /* Check the tag in "constant-time" */
   1265                  if (mbedtls_ct_memcmp(tag, check_tag, tag_len) != 0) {
   1266                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1267                      goto exit;
   1268                  }
   1269              }
   1270          #endif /* MBEDTLS_GCM_C */
   1271          
   1272          #if defined(MBEDTLS_CHACHAPOLY_C)
   1273              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
   1274                  /* Don't allow truncated MAC for Poly1305 */
   1275                  if (tag_len != sizeof(check_tag)) {
   1276                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1277                  }
   1278          
   1279                  ret = mbedtls_chachapoly_finish(
   1280                      (mbedtls_chachapoly_context *) ctx->cipher_ctx, check_tag);
   1281                  if (ret != 0) {
   1282                      return ret;
   1283                  }
   1284          
   1285                  /* Check the tag in "constant-time" */
   1286                  if (mbedtls_ct_memcmp(tag, check_tag, tag_len) != 0) {
   1287                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1288                      goto exit;
   1289                  }
   1290              }
   1291          #endif /* MBEDTLS_CHACHAPOLY_C */
   1292          
   1293          exit:
   1294              mbedtls_platform_zeroize(check_tag, tag_len);
   1295              return ret;
   1296          }
   1297          #endif /* MBEDTLS_GCM_C || MBEDTLS_CHACHAPOLY_C */
   1298          
   1299          /*
   1300           * Packet-oriented wrapper for non-AEAD modes
   1301           */

   \                                 In section .text, align 2, keep-with-next
   1302          int mbedtls_cipher_crypt(mbedtls_cipher_context_t *ctx,
   1303                                   const unsigned char *iv, size_t iv_len,
   1304                                   const unsigned char *input, size_t ilen,
   1305                                   unsigned char *output, size_t *olen)
   1306          {
   \                     mbedtls_cipher_crypt: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB0AC             SUB      SP,SP,#+176
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x468A             MOV      R10,R1
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0x001D             MOVS     R5,R3
   \        0xE   0x9E36             LDR      R6,[SP, #+216]
   \       0x10   0x9F37             LDR      R7,[SP, #+220]
   \       0x12   0xF8DD 0x80E0      LDR      R8,[SP, #+224]
   1307              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x006D      MVNS     R0,#+109
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   1308              size_t finish_olen;
   1309          
   1310          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1311              if (ctx->psa_enabled == 1) {
   \       0x1C   0xF899 0x0044      LDRB     R0,[R9, #+68]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD16C             BNE.N    ??mbedtls_cipher_crypt_0
   1312                  /* As in the non-PSA case, we don't check that
   1313                   * a key has been set. If not, the key slot will
   1314                   * still be in its default state of 0, which is
   1315                   * guaranteed to be invalid, hence the PSA-call
   1316                   * below will gracefully fail. */
   1317                  mbedtls_cipher_context_psa * const cipher_psa =
   1318                      (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
   \       0x24   0xF8D9 0x003C      LDR      R0,[R9, #+60]
   \       0x28   0x9002             STR      R0,[SP, #+8]
   1319          
   1320                  psa_status_t status;
   1321                  psa_cipher_operation_t cipher_op = PSA_CIPHER_OPERATION_INIT;
   \       0x2A   0xA806             ADD      R0,SP,#+24
   \       0x2C   0x2198             MOVS     R1,#+152
   \       0x2E   0x.... 0x....      BL       __aeabi_memclr4
   1322                  size_t part_len;
   1323          
   1324                  if (ctx->operation == MBEDTLS_DECRYPT) {
   \       0x32   0xF999 0x0008      LDRSB    R0,[R9, #+8]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD108             BNE.N    ??mbedtls_cipher_crypt_1
   1325                      status = psa_cipher_decrypt_setup(&cipher_op,
   1326                                                        cipher_psa->slot,
   1327                                                        cipher_psa->alg);
   \       0x3A   0x9802             LDR      R0,[SP, #+8]
   \       0x3C   0x6802             LDR      R2,[R0, #+0]
   \       0x3E   0x9802             LDR      R0,[SP, #+8]
   \       0x40   0x6841             LDR      R1,[R0, #+4]
   \       0x42   0xA806             ADD      R0,SP,#+24
   \       0x44   0x.... 0x....      BL       psa_cipher_decrypt_setup
   \       0x48   0x4683             MOV      R11,R0
   \       0x4A   0xE00F             B.N      ??mbedtls_cipher_crypt_2
   1328                  } else if (ctx->operation == MBEDTLS_ENCRYPT) {
   \                     ??mbedtls_cipher_crypt_1: (+1)
   \       0x4C   0xF999 0x0008      LDRSB    R0,[R9, #+8]
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD108             BNE.N    ??mbedtls_cipher_crypt_3
   1329                      status = psa_cipher_encrypt_setup(&cipher_op,
   1330                                                        cipher_psa->slot,
   1331                                                        cipher_psa->alg);
   \       0x54   0x9802             LDR      R0,[SP, #+8]
   \       0x56   0x6802             LDR      R2,[R0, #+0]
   \       0x58   0x9802             LDR      R0,[SP, #+8]
   \       0x5A   0x6841             LDR      R1,[R0, #+4]
   \       0x5C   0xA806             ADD      R0,SP,#+24
   \       0x5E   0x.... 0x....      BL       psa_cipher_encrypt_setup
   \       0x62   0x4683             MOV      R11,R0
   \       0x64   0xE002             B.N      ??mbedtls_cipher_crypt_2
   1332                  } else {
   1333                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_crypt_3: (+1)
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \       0x6A   0xE07B             B.N      ??mbedtls_cipher_crypt_4
   1334                  }
   1335          
   1336                  /* In the following, we can immediately return on an error,
   1337                   * because the PSA Crypto API guarantees that cipher operations
   1338                   * are terminated by unsuccessful calls to psa_cipher_update(),
   1339                   * and by any call to psa_cipher_finish(). */
   1340                  if (status == PSA_ERROR_NOT_SUPPORTED) {
   \                     ??mbedtls_cipher_crypt_2: (+1)
   \       0x6C   0xF11B 0x0F86      CMN      R11,#+134
   \       0x70   0xD102             BNE.N    ??mbedtls_cipher_crypt_5
   1341                      return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
   \       0x72   0xF07F 0x0071      MVNS     R0,#+113
   \       0x76   0xE075             B.N      ??mbedtls_cipher_crypt_4
   1342                  } else if (status != PSA_SUCCESS) {
   \                     ??mbedtls_cipher_crypt_5: (+1)
   \       0x78   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x7C   0xD002             BEQ.N    ??mbedtls_cipher_crypt_6
   1343                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0x7E   0xF07F 0x006F      MVNS     R0,#+111
   \       0x82   0xE06F             B.N      ??mbedtls_cipher_crypt_4
   1344                  }
   1345          
   1346                  if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) != MBEDTLS_MODE_ECB) {
   \                     ??mbedtls_cipher_crypt_6: (+1)
   \       0x84   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x88   0x6840             LDR      R0,[R0, #+4]
   \       0x8A   0x0B00             LSRS     R0,R0,#+12
   \       0x8C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD00B             BEQ.N    ??mbedtls_cipher_crypt_7
   1347                      status = psa_cipher_set_iv(&cipher_op, iv, iv_len);
   \       0x94   0x0022             MOVS     R2,R4
   \       0x96   0x4651             MOV      R1,R10
   \       0x98   0xA806             ADD      R0,SP,#+24
   \       0x9A   0x.... 0x....      BL       psa_cipher_set_iv
   \       0x9E   0x4683             MOV      R11,R0
   1348                      if (status != PSA_SUCCESS) {
   \       0xA0   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xA4   0xD002             BEQ.N    ??mbedtls_cipher_crypt_7
   1349                          return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0xA6   0xF07F 0x006F      MVNS     R0,#+111
   \       0xAA   0xE05B             B.N      ??mbedtls_cipher_crypt_4
   1350                      }
   1351                  }
   1352          
   1353                  status = psa_cipher_update(&cipher_op,
   1354                                             input, ilen,
   1355                                             output, ilen, olen);
   \                     ??mbedtls_cipher_crypt_7: (+1)
   \       0xAC   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0xB0   0x9600             STR      R6,[SP, #+0]
   \       0xB2   0x003B             MOVS     R3,R7
   \       0xB4   0x0032             MOVS     R2,R6
   \       0xB6   0x0029             MOVS     R1,R5
   \       0xB8   0xA806             ADD      R0,SP,#+24
   \       0xBA   0x.... 0x....      BL       psa_cipher_update
   \       0xBE   0x9000             STR      R0,[SP, #+0]
   1356                  if (status != PSA_SUCCESS) {
   \       0xC0   0x9800             LDR      R0,[SP, #+0]
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD002             BEQ.N    ??mbedtls_cipher_crypt_8
   1357                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0xC6   0xF07F 0x006F      MVNS     R0,#+111
   \       0xCA   0xE04B             B.N      ??mbedtls_cipher_crypt_4
   1358                  }
   1359          
   1360                  status = psa_cipher_finish(&cipher_op,
   1361                                             output + *olen, ilen - *olen,
   1362                                             &part_len);
   \                     ??mbedtls_cipher_crypt_8: (+1)
   \       0xCC   0xAB04             ADD      R3,SP,#+16
   \       0xCE   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0xD2   0x1AB2             SUBS     R2,R6,R2
   \       0xD4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xD8   0xEB07 0x0100      ADD      R1,R7,R0
   \       0xDC   0xA806             ADD      R0,SP,#+24
   \       0xDE   0x.... 0x....      BL       psa_cipher_finish
   \       0xE2   0x0001             MOVS     R1,R0
   1363                  if (status != PSA_SUCCESS) {
   \       0xE4   0x2900             CMP      R1,#+0
   \       0xE6   0xD002             BEQ.N    ??mbedtls_cipher_crypt_9
   1364                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0xE8   0xF07F 0x006F      MVNS     R0,#+111
   \       0xEC   0xE03A             B.N      ??mbedtls_cipher_crypt_4
   1365                  }
   1366          
   1367                  *olen += part_len;
   \                     ??mbedtls_cipher_crypt_9: (+1)
   \       0xEE   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0xF2   0x9804             LDR      R0,[SP, #+16]
   \       0xF4   0x1882             ADDS     R2,R0,R2
   \       0xF6   0xF8C8 0x2000      STR      R2,[R8, #+0]
   1368                  return 0;
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0xE032             B.N      ??mbedtls_cipher_crypt_4
   1369              }
   1370          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1371          
   1372              if ((ret = mbedtls_cipher_set_iv(ctx, iv, iv_len)) != 0) {
   \                     ??mbedtls_cipher_crypt_0: (+1)
   \       0xFE   0x0022             MOVS     R2,R4
   \      0x100   0x4651             MOV      R1,R10
   \      0x102   0x4648             MOV      R0,R9
   \      0x104   0x.... 0x....      BL       mbedtls_cipher_set_iv
   \      0x108   0x4683             MOV      R11,R0
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD001             BEQ.N    ??mbedtls_cipher_crypt_10
   1373                  return ret;
   \      0x10E   0x4658             MOV      R0,R11
   \      0x110   0xE028             B.N      ??mbedtls_cipher_crypt_4
   1374              }
   1375          
   1376              if ((ret = mbedtls_cipher_reset(ctx)) != 0) {
   \                     ??mbedtls_cipher_crypt_10: (+1)
   \      0x112   0x4648             MOV      R0,R9
   \      0x114   0x.... 0x....      BL       mbedtls_cipher_reset
   \      0x118   0x9003             STR      R0,[SP, #+12]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD001             BEQ.N    ??mbedtls_cipher_crypt_11
   1377                  return ret;
   \      0x11E   0x9803             LDR      R0,[SP, #+12]
   \      0x120   0xE020             B.N      ??mbedtls_cipher_crypt_4
   1378              }
   1379          
   1380              if ((ret = mbedtls_cipher_update(ctx, input, ilen,
   1381                                               output, olen)) != 0) {
   \                     ??mbedtls_cipher_crypt_11: (+1)
   \      0x122   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x126   0x003B             MOVS     R3,R7
   \      0x128   0x0032             MOVS     R2,R6
   \      0x12A   0x0029             MOVS     R1,R5
   \      0x12C   0x4648             MOV      R0,R9
   \      0x12E   0x.... 0x....      BL       mbedtls_cipher_update
   \      0x132   0x4683             MOV      R11,R0
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD001             BEQ.N    ??mbedtls_cipher_crypt_12
   1382                  return ret;
   \      0x138   0x4658             MOV      R0,R11
   \      0x13A   0xE013             B.N      ??mbedtls_cipher_crypt_4
   1383              }
   1384          
   1385              if ((ret = mbedtls_cipher_finish(ctx, output + *olen,
   1386                                               &finish_olen)) != 0) {
   \                     ??mbedtls_cipher_crypt_12: (+1)
   \      0x13C   0xAA05             ADD      R2,SP,#+20
   \      0x13E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x142   0xEB07 0x0100      ADD      R1,R7,R0
   \      0x146   0x4648             MOV      R0,R9
   \      0x148   0x.... 0x....      BL       mbedtls_cipher_finish
   \      0x14C   0x0001             MOVS     R1,R0
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD001             BEQ.N    ??mbedtls_cipher_crypt_13
   1387                  return ret;
   \      0x152   0x0008             MOVS     R0,R1
   \      0x154   0xE006             B.N      ??mbedtls_cipher_crypt_4
   1388              }
   1389          
   1390              *olen += finish_olen;
   \                     ??mbedtls_cipher_crypt_13: (+1)
   \      0x156   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \      0x15A   0x9805             LDR      R0,[SP, #+20]
   \      0x15C   0x1882             ADDS     R2,R0,R2
   \      0x15E   0xF8C8 0x2000      STR      R2,[R8, #+0]
   1391          
   1392              return 0;
   \      0x162   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_crypt_4: (+1)
   \      0x164   0xB02D             ADD      SP,SP,#+180
   \      0x166   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1393          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0
   \        0x6                      DS8 2
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 140
   1394          
   1395          #if defined(MBEDTLS_CIPHER_MODE_AEAD)
   1396          /*
   1397           * Packet-oriented encryption for AEAD modes: internal function used by
   1398           * mbedtls_cipher_auth_encrypt_ext().
   1399           */

   \                                 In section .text, align 2, keep-with-next
   1400          static int mbedtls_cipher_aead_encrypt(mbedtls_cipher_context_t *ctx,
   1401                                                 const unsigned char *iv, size_t iv_len,
   1402                                                 const unsigned char *ad, size_t ad_len,
   1403                                                 const unsigned char *input, size_t ilen,
   1404                                                 unsigned char *output, size_t *olen,
   1405                                                 unsigned char *tag, size_t tag_len)
   1406          {
   \                     mbedtls_cipher_aead_encrypt: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x9D14             LDR      R5,[SP, #+80]
   \        0xA   0x9E15             LDR      R6,[SP, #+84]
   \        0xC   0x9F16             LDR      R7,[SP, #+88]
   \        0xE   0x9C17             LDR      R4,[SP, #+92]
   \       0x10   0xF8DD 0x8060      LDR      R8,[SP, #+96]
   \       0x14   0xF8DD 0x9064      LDR      R9,[SP, #+100]
   \       0x18   0xF8DD 0xA068      LDR      R10,[SP, #+104]
   1407          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1408              if (ctx->psa_enabled == 1) {
   \       0x1C   0xF89B 0x0044      LDRB     R0,[R11, #+68]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD131             BNE.N    ??mbedtls_cipher_aead_encrypt_0
   1409                  /* As in the non-PSA case, we don't check that
   1410                   * a key has been set. If not, the key slot will
   1411                   * still be in its default state of 0, which is
   1412                   * guaranteed to be invalid, hence the PSA-call
   1413                   * below will gracefully fail. */
   1414                  mbedtls_cipher_context_psa * const cipher_psa =
   1415                      (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
   \       0x24   0xF8DB 0x003C      LDR      R0,[R11, #+60]
   \       0x28   0x9007             STR      R0,[SP, #+28]
   1416          
   1417                  psa_status_t status;
   1418          
   1419                  /* PSA Crypto API always writes the authentication tag
   1420                   * at the end of the encrypted message. */
   1421                  if (output == NULL || tag != output + ilen) {
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD003             BEQ.N    ??mbedtls_cipher_aead_encrypt_1
   \       0x2E   0xEB04 0x0007      ADD      R0,R4,R7
   \       0x32   0x4581             CMP      R9,R0
   \       0x34   0xD001             BEQ.N    ??mbedtls_cipher_aead_encrypt_2
   1422                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_cipher_aead_encrypt_1: (+1)
   \       0x36   0x....             LDR.N    R0,??DataTable20_1
   \       0x38   0xE042             B.N      ??mbedtls_cipher_aead_encrypt_3
   1423                  }
   1424          
   1425                  status = psa_aead_encrypt(cipher_psa->slot,
   1426                                            cipher_psa->alg,
   1427                                            iv, iv_len,
   1428                                            ad, ad_len,
   1429                                            input, ilen,
   1430                                            output, ilen + tag_len, olen);
   \                     ??mbedtls_cipher_aead_encrypt_2: (+1)
   \       0x3A   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \       0x3E   0xEB1A 0x0007      ADDS     R0,R10,R7
   \       0x42   0x9005             STR      R0,[SP, #+20]
   \       0x44   0x9404             STR      R4,[SP, #+16]
   \       0x46   0x9703             STR      R7,[SP, #+12]
   \       0x48   0x9602             STR      R6,[SP, #+8]
   \       0x4A   0x9501             STR      R5,[SP, #+4]
   \       0x4C   0x980A             LDR      R0,[SP, #+40]
   \       0x4E   0x9000             STR      R0,[SP, #+0]
   \       0x50   0x9B09             LDR      R3,[SP, #+36]
   \       0x52   0x9A08             LDR      R2,[SP, #+32]
   \       0x54   0x9807             LDR      R0,[SP, #+28]
   \       0x56   0x6801             LDR      R1,[R0, #+0]
   \       0x58   0x9807             LDR      R0,[SP, #+28]
   \       0x5A   0x6840             LDR      R0,[R0, #+4]
   \       0x5C   0x.... 0x....      BL       psa_aead_encrypt
   \       0x60   0x0001             MOVS     R1,R0
   1431                  if (status == PSA_ERROR_NOT_SUPPORTED) {
   \       0x62   0xF111 0x0F86      CMN      R1,#+134
   \       0x66   0xD102             BNE.N    ??mbedtls_cipher_aead_encrypt_4
   1432                      return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
   \       0x68   0xF07F 0x0071      MVNS     R0,#+113
   \       0x6C   0xE028             B.N      ??mbedtls_cipher_aead_encrypt_3
   1433                  } else if (status != PSA_SUCCESS) {
   \                     ??mbedtls_cipher_aead_encrypt_4: (+1)
   \       0x6E   0x2900             CMP      R1,#+0
   \       0x70   0xD002             BEQ.N    ??mbedtls_cipher_aead_encrypt_5
   1434                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0x72   0xF07F 0x006F      MVNS     R0,#+111
   \       0x76   0xE023             B.N      ??mbedtls_cipher_aead_encrypt_3
   1435                  }
   1436          
   1437                  *olen -= tag_len;
   \                     ??mbedtls_cipher_aead_encrypt_5: (+1)
   \       0x78   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x7C   0xEBB0 0x000A      SUBS     R0,R0,R10
   \       0x80   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1438                  return 0;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xE01B             B.N      ??mbedtls_cipher_aead_encrypt_3
   1439              }
   1440          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1441          
   1442          #if defined(MBEDTLS_GCM_C)
   1443              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1444                  *olen = ilen;
   1445                  return mbedtls_gcm_crypt_and_tag(ctx->cipher_ctx, MBEDTLS_GCM_ENCRYPT,
   1446                                                   ilen, iv, iv_len, ad, ad_len,
   1447                                                   input, output, tag_len, tag);
   1448              }
   1449          #endif /* MBEDTLS_GCM_C */
   1450          #if defined(MBEDTLS_CCM_C)
   1451              if (MBEDTLS_MODE_CCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \                     ??mbedtls_cipher_aead_encrypt_0: (+1)
   \       0x88   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x8C   0x6840             LDR      R0,[R0, #+4]
   \       0x8E   0x0B00             LSRS     R0,R0,#+12
   \       0x90   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x94   0x2808             CMP      R0,#+8
   \       0x96   0xD112             BNE.N    ??mbedtls_cipher_aead_encrypt_6
   1452                  *olen = ilen;
   \       0x98   0xF8C8 0x7000      STR      R7,[R8, #+0]
   1453                  return mbedtls_ccm_encrypt_and_tag(ctx->cipher_ctx, ilen,
   1454                                                     iv, iv_len, ad, ad_len, input, output,
   1455                                                     tag, tag_len);
   \       0x9C   0xF8CD 0xA014      STR      R10,[SP, #+20]
   \       0xA0   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0xA4   0x9403             STR      R4,[SP, #+12]
   \       0xA6   0x9602             STR      R6,[SP, #+8]
   \       0xA8   0x9501             STR      R5,[SP, #+4]
   \       0xAA   0x980A             LDR      R0,[SP, #+40]
   \       0xAC   0x9000             STR      R0,[SP, #+0]
   \       0xAE   0x9B09             LDR      R3,[SP, #+36]
   \       0xB0   0x9A08             LDR      R2,[SP, #+32]
   \       0xB2   0x0039             MOVS     R1,R7
   \       0xB4   0xF8DB 0x003C      LDR      R0,[R11, #+60]
   \       0xB8   0x.... 0x....      BL       mbedtls_ccm_encrypt_and_tag
   \       0xBC   0xE000             B.N      ??mbedtls_cipher_aead_encrypt_3
   1456              }
   1457          #endif /* MBEDTLS_CCM_C */
   1458          #if defined(MBEDTLS_CHACHAPOLY_C)
   1459              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
   1460                  /* ChachaPoly has fixed length nonce and MAC (tag) */
   1461                  if ((iv_len != mbedtls_cipher_info_get_iv_size(ctx->cipher_info)) ||
   1462                      (tag_len != 16U)) {
   1463                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1464                  }
   1465          
   1466                  *olen = ilen;
   1467                  return mbedtls_chachapoly_encrypt_and_tag(ctx->cipher_ctx,
   1468                                                            ilen, iv, ad, ad_len, input, output, tag);
   1469              }
   1470          #endif /* MBEDTLS_CHACHAPOLY_C */
   1471          
   1472              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_cipher_aead_encrypt_6: (+1)
   \       0xBE   0x....             LDR.N    R0,??DataTable20_1
   \                     ??mbedtls_cipher_aead_encrypt_3: (+1)
   \       0xC0   0xB00B             ADD      SP,SP,#+44
   \       0xC2   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1473          }
   1474          
   1475          /*
   1476           * Packet-oriented encryption for AEAD modes: internal function used by
   1477           * mbedtls_cipher_auth_encrypt_ext().
   1478           */

   \                                 In section .text, align 2, keep-with-next
   1479          static int mbedtls_cipher_aead_decrypt(mbedtls_cipher_context_t *ctx,
   1480                                                 const unsigned char *iv, size_t iv_len,
   1481                                                 const unsigned char *ad, size_t ad_len,
   1482                                                 const unsigned char *input, size_t ilen,
   1483                                                 unsigned char *output, size_t *olen,
   1484                                                 const unsigned char *tag, size_t tag_len)
   1485          {
   \                     mbedtls_cipher_aead_decrypt: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x9D14             LDR      R5,[SP, #+80]
   \        0xA   0x9C15             LDR      R4,[SP, #+84]
   \        0xC   0x9E16             LDR      R6,[SP, #+88]
   \        0xE   0x9F17             LDR      R7,[SP, #+92]
   \       0x10   0xF8DD 0x8060      LDR      R8,[SP, #+96]
   \       0x14   0xF8DD 0x9064      LDR      R9,[SP, #+100]
   \       0x18   0xF8DD 0xA068      LDR      R10,[SP, #+104]
   1486          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1487              if (ctx->psa_enabled == 1) {
   \       0x1C   0xF89B 0x0044      LDRB     R0,[R11, #+68]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD130             BNE.N    ??mbedtls_cipher_aead_decrypt_0
   1488                  /* As in the non-PSA case, we don't check that
   1489                   * a key has been set. If not, the key slot will
   1490                   * still be in its default state of 0, which is
   1491                   * guaranteed to be invalid, hence the PSA-call
   1492                   * below will gracefully fail. */
   1493                  mbedtls_cipher_context_psa * const cipher_psa =
   1494                      (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
   \       0x24   0xF8DB 0x003C      LDR      R0,[R11, #+60]
   \       0x28   0x9007             STR      R0,[SP, #+28]
   1495          
   1496                  psa_status_t status;
   1497          
   1498                  /* PSA Crypto API always writes the authentication tag
   1499                   * at the end of the encrypted message. */
   1500                  if (input == NULL || tag != input + ilen) {
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD003             BEQ.N    ??mbedtls_cipher_aead_decrypt_1
   \       0x2E   0xEB04 0x0006      ADD      R0,R4,R6
   \       0x32   0x4581             CMP      R9,R0
   \       0x34   0xD001             BEQ.N    ??mbedtls_cipher_aead_decrypt_2
   1501                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_cipher_aead_decrypt_1: (+1)
   \       0x36   0x....             LDR.N    R0,??DataTable20_1
   \       0x38   0xE049             B.N      ??mbedtls_cipher_aead_decrypt_3
   1502                  }
   1503          
   1504                  status = psa_aead_decrypt(cipher_psa->slot,
   1505                                            cipher_psa->alg,
   1506                                            iv, iv_len,
   1507                                            ad, ad_len,
   1508                                            input, ilen + tag_len,
   1509                                            output, ilen, olen);
   \                     ??mbedtls_cipher_aead_decrypt_2: (+1)
   \       0x3A   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \       0x3E   0x9605             STR      R6,[SP, #+20]
   \       0x40   0x9704             STR      R7,[SP, #+16]
   \       0x42   0xEB1A 0x0006      ADDS     R0,R10,R6
   \       0x46   0x9003             STR      R0,[SP, #+12]
   \       0x48   0x9402             STR      R4,[SP, #+8]
   \       0x4A   0x9501             STR      R5,[SP, #+4]
   \       0x4C   0x980A             LDR      R0,[SP, #+40]
   \       0x4E   0x9000             STR      R0,[SP, #+0]
   \       0x50   0x9B09             LDR      R3,[SP, #+36]
   \       0x52   0x9A08             LDR      R2,[SP, #+32]
   \       0x54   0x9807             LDR      R0,[SP, #+28]
   \       0x56   0x6801             LDR      R1,[R0, #+0]
   \       0x58   0x9807             LDR      R0,[SP, #+28]
   \       0x5A   0x6840             LDR      R0,[R0, #+4]
   \       0x5C   0x.... 0x....      BL       psa_aead_decrypt
   \       0x60   0x0001             MOVS     R1,R0
   1510                  if (status == PSA_ERROR_INVALID_SIGNATURE) {
   \       0x62   0xF111 0x0F95      CMN      R1,#+149
   \       0x66   0xD101             BNE.N    ??mbedtls_cipher_aead_decrypt_4
   1511                      return MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   \       0x68   0x....             LDR.N    R0,??DataTable20_5
   \       0x6A   0xE030             B.N      ??mbedtls_cipher_aead_decrypt_3
   1512                  } else if (status == PSA_ERROR_NOT_SUPPORTED) {
   \                     ??mbedtls_cipher_aead_decrypt_4: (+1)
   \       0x6C   0xF111 0x0F86      CMN      R1,#+134
   \       0x70   0xD102             BNE.N    ??mbedtls_cipher_aead_decrypt_5
   1513                      return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
   \       0x72   0xF07F 0x0071      MVNS     R0,#+113
   \       0x76   0xE02A             B.N      ??mbedtls_cipher_aead_decrypt_3
   1514                  } else if (status != PSA_SUCCESS) {
   \                     ??mbedtls_cipher_aead_decrypt_5: (+1)
   \       0x78   0x2900             CMP      R1,#+0
   \       0x7A   0xD002             BEQ.N    ??mbedtls_cipher_aead_decrypt_6
   1515                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0x7C   0xF07F 0x006F      MVNS     R0,#+111
   \       0x80   0xE025             B.N      ??mbedtls_cipher_aead_decrypt_3
   1516                  }
   1517          
   1518                  return 0;
   \                     ??mbedtls_cipher_aead_decrypt_6: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xE023             B.N      ??mbedtls_cipher_aead_decrypt_3
   1519              }
   1520          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1521          
   1522          #if defined(MBEDTLS_GCM_C)
   1523              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1524                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1525          
   1526                  *olen = ilen;
   1527                  ret = mbedtls_gcm_auth_decrypt(ctx->cipher_ctx, ilen,
   1528                                                 iv, iv_len, ad, ad_len,
   1529                                                 tag, tag_len, input, output);
   1530          
   1531                  if (ret == MBEDTLS_ERR_GCM_AUTH_FAILED) {
   1532                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1533                  }
   1534          
   1535                  return ret;
   1536              }
   1537          #endif /* MBEDTLS_GCM_C */
   1538          #if defined(MBEDTLS_CCM_C)
   1539              if (MBEDTLS_MODE_CCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \                     ??mbedtls_cipher_aead_decrypt_0: (+1)
   \       0x86   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x8A   0x6840             LDR      R0,[R0, #+4]
   \       0x8C   0x0B00             LSRS     R0,R0,#+12
   \       0x8E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x92   0x2808             CMP      R0,#+8
   \       0x94   0xD11A             BNE.N    ??mbedtls_cipher_aead_decrypt_7
   1540                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x96   0xF07F 0x006D      MVNS     R0,#+109
   \       0x9A   0x9006             STR      R0,[SP, #+24]
   1541          
   1542                  *olen = ilen;
   \       0x9C   0xF8C8 0x6000      STR      R6,[R8, #+0]
   1543                  ret = mbedtls_ccm_auth_decrypt(ctx->cipher_ctx, ilen,
   1544                                                 iv, iv_len, ad, ad_len,
   1545                                                 input, output, tag, tag_len);
   \       0xA0   0xF8CD 0xA014      STR      R10,[SP, #+20]
   \       0xA4   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0xA8   0x9703             STR      R7,[SP, #+12]
   \       0xAA   0x9402             STR      R4,[SP, #+8]
   \       0xAC   0x9501             STR      R5,[SP, #+4]
   \       0xAE   0x980A             LDR      R0,[SP, #+40]
   \       0xB0   0x9000             STR      R0,[SP, #+0]
   \       0xB2   0x9B09             LDR      R3,[SP, #+36]
   \       0xB4   0x9A08             LDR      R2,[SP, #+32]
   \       0xB6   0x0031             MOVS     R1,R6
   \       0xB8   0xF8DB 0x003C      LDR      R0,[R11, #+60]
   \       0xBC   0x.... 0x....      BL       mbedtls_ccm_auth_decrypt
   1546          
   1547                  if (ret == MBEDTLS_ERR_CCM_AUTH_FAILED) {
   \       0xC0   0xF110 0x0F0F      CMN      R0,#+15
   \       0xC4   0xD101             BNE.N    ??mbedtls_cipher_aead_decrypt_8
   1548                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   \       0xC6   0x....             LDR.N    R1,??DataTable20_5
   \       0xC8   0x0008             MOVS     R0,R1
   1549                  }
   1550          
   1551                  return ret;
   \                     ??mbedtls_cipher_aead_decrypt_8: (+1)
   \       0xCA   0xE000             B.N      ??mbedtls_cipher_aead_decrypt_3
   1552              }
   1553          #endif /* MBEDTLS_CCM_C */
   1554          #if defined(MBEDTLS_CHACHAPOLY_C)
   1555              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
   1556                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1557          
   1558                  /* ChachaPoly has fixed length nonce and MAC (tag) */
   1559                  if ((iv_len != mbedtls_cipher_info_get_iv_size(ctx->cipher_info)) ||
   1560                      (tag_len != 16U)) {
   1561                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1562                  }
   1563          
   1564                  *olen = ilen;
   1565                  ret = mbedtls_chachapoly_auth_decrypt(ctx->cipher_ctx, ilen,
   1566                                                        iv, ad, ad_len, tag, input, output);
   1567          
   1568                  if (ret == MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED) {
   1569                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1570                  }
   1571          
   1572                  return ret;
   1573              }
   1574          #endif /* MBEDTLS_CHACHAPOLY_C */
   1575          
   1576              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_cipher_aead_decrypt_7: (+1)
   \       0xCC   0x....             LDR.N    R0,??DataTable20_1
   \                     ??mbedtls_cipher_aead_decrypt_3: (+1)
   \       0xCE   0xB00B             ADD      SP,SP,#+44
   \       0xD0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1577          }
   1578          #endif /* MBEDTLS_CIPHER_MODE_AEAD */
   1579          
   1580          #if defined(MBEDTLS_CIPHER_MODE_AEAD) || defined(MBEDTLS_NIST_KW_C)
   1581          /*
   1582           * Packet-oriented encryption for AEAD/NIST_KW: public function.
   1583           */

   \                                 In section .text, align 2, keep-with-next
   1584          int mbedtls_cipher_auth_encrypt_ext(mbedtls_cipher_context_t *ctx,
   1585                                              const unsigned char *iv, size_t iv_len,
   1586                                              const unsigned char *ad, size_t ad_len,
   1587                                              const unsigned char *input, size_t ilen,
   1588                                              unsigned char *output, size_t output_len,
   1589                                              size_t *olen, size_t tag_len)
   1590          {
   \                     mbedtls_cipher_auth_encrypt_ext: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x9C15             LDR      R4,[SP, #+84]
   \        0xA   0x9D16             LDR      R5,[SP, #+88]
   \        0xC   0x9E17             LDR      R6,[SP, #+92]
   \        0xE   0x9F18             LDR      R7,[SP, #+96]
   \       0x10   0xF8DD 0x8064      LDR      R8,[SP, #+100]
   \       0x14   0xF8DD 0x9068      LDR      R9,[SP, #+104]
   1591          #if defined(MBEDTLS_NIST_KW_C)
   1592              if (
   1593          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1594                  ctx->psa_enabled == 0 &&
   1595          #endif
   1596                  (MBEDTLS_MODE_KW == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1597                   MBEDTLS_MODE_KWP == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode))) {
   \       0x18   0xF89A 0x0044      LDRB     R0,[R10, #+68]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD132             BNE.N    ??mbedtls_cipher_auth_encrypt_ext_0
   \       0x20   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x24   0x6840             LDR      R0,[R0, #+4]
   \       0x26   0x0B00             LSRS     R0,R0,#+12
   \       0x28   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x2C   0x280C             CMP      R0,#+12
   \       0x2E   0xD007             BEQ.N    ??mbedtls_cipher_auth_encrypt_ext_1
   \       0x30   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x34   0x6840             LDR      R0,[R0, #+4]
   \       0x36   0x0B00             LSRS     R0,R0,#+12
   \       0x38   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x3C   0x280D             CMP      R0,#+13
   \       0x3E   0xD122             BNE.N    ??mbedtls_cipher_auth_encrypt_ext_0
   1598                  mbedtls_nist_kw_mode_t mode =
   1599                      (MBEDTLS_MODE_KW == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) ?
   1600                      MBEDTLS_KW_MODE_KW : MBEDTLS_KW_MODE_KWP;
   \                     ??mbedtls_cipher_auth_encrypt_ext_1: (+1)
   \       0x40   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x44   0x6840             LDR      R0,[R0, #+4]
   \       0x46   0x0B00             LSRS     R0,R0,#+12
   \       0x48   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x4C   0x280C             CMP      R0,#+12
   \       0x4E   0xD102             BNE.N    ??mbedtls_cipher_auth_encrypt_ext_2
   \       0x50   0xF05F 0x0B00      MOVS     R11,#+0
   \       0x54   0xE001             B.N      ??mbedtls_cipher_auth_encrypt_ext_3
   \                     ??mbedtls_cipher_auth_encrypt_ext_2: (+1)
   \       0x56   0xF05F 0x0B01      MOVS     R11,#+1
   1601          
   1602                  /* There is no iv, tag or ad associated with KW and KWP,
   1603                   * so these length should be 0 as documented. */
   1604                  if (iv_len != 0 || tag_len != 0 || ad_len != 0) {
   \                     ??mbedtls_cipher_auth_encrypt_ext_3: (+1)
   \       0x5A   0x9809             LDR      R0,[SP, #+36]
   \       0x5C   0xEA59 0x0000      ORRS     R0,R9,R0
   \       0x60   0x9914             LDR      R1,[SP, #+80]
   \       0x62   0x4308             ORRS     R0,R1,R0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD001             BEQ.N    ??mbedtls_cipher_auth_encrypt_ext_4
   1605                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x68   0x....             LDR.N    R0,??DataTable19_1
   \       0x6A   0xE02A             B.N      ??mbedtls_cipher_auth_encrypt_ext_5
   1606                  }
   1607          
   1608                  (void) iv;
   1609                  (void) ad;
   1610          
   1611                  return mbedtls_nist_kw_wrap(ctx->cipher_ctx, mode, input, ilen,
   1612                                              output, olen, output_len);
   \                     ??mbedtls_cipher_auth_encrypt_ext_4: (+1)
   \       0x6C   0x9702             STR      R7,[SP, #+8]
   \       0x6E   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x72   0x9600             STR      R6,[SP, #+0]
   \       0x74   0x002B             MOVS     R3,R5
   \       0x76   0x0022             MOVS     R2,R4
   \       0x78   0x4659             MOV      R1,R11
   \       0x7A   0xB2C9             UXTB     R1,R1
   \       0x7C   0xF8DA 0x003C      LDR      R0,[R10, #+60]
   \       0x80   0x.... 0x....      BL       mbedtls_nist_kw_wrap
   \       0x84   0xE01D             B.N      ??mbedtls_cipher_auth_encrypt_ext_5
   1613              }
   1614          #endif /* MBEDTLS_NIST_KW_C */
   1615          
   1616          #if defined(MBEDTLS_CIPHER_MODE_AEAD)
   1617              /* AEAD case: check length before passing on to shared function */
   1618              if (output_len < ilen + tag_len) {
   \                     ??mbedtls_cipher_auth_encrypt_ext_0: (+1)
   \       0x86   0xEB19 0x0005      ADDS     R0,R9,R5
   \       0x8A   0x4287             CMP      R7,R0
   \       0x8C   0xD201             BCS.N    ??mbedtls_cipher_auth_encrypt_ext_6
   1619                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x8E   0x....             LDR.N    R0,??DataTable19_1
   \       0x90   0xE017             B.N      ??mbedtls_cipher_auth_encrypt_ext_5
   1620              }
   1621          
   1622              int ret = mbedtls_cipher_aead_encrypt(ctx, iv, iv_len, ad, ad_len,
   1623                                                    input, ilen, output, olen,
   1624                                                    output + ilen, tag_len);
   \                     ??mbedtls_cipher_auth_encrypt_ext_6: (+1)
   \       0x92   0xF8CD 0x9018      STR      R9,[SP, #+24]
   \       0x96   0xEB06 0x0005      ADD      R0,R6,R5
   \       0x9A   0x9005             STR      R0,[SP, #+20]
   \       0x9C   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0xA0   0x9603             STR      R6,[SP, #+12]
   \       0xA2   0x9502             STR      R5,[SP, #+8]
   \       0xA4   0x9401             STR      R4,[SP, #+4]
   \       0xA6   0x9814             LDR      R0,[SP, #+80]
   \       0xA8   0x9000             STR      R0,[SP, #+0]
   \       0xAA   0x9B0A             LDR      R3,[SP, #+40]
   \       0xAC   0x9A09             LDR      R2,[SP, #+36]
   \       0xAE   0x9908             LDR      R1,[SP, #+32]
   \       0xB0   0x4650             MOV      R0,R10
   \       0xB2   0x.... 0x....      BL       mbedtls_cipher_aead_encrypt
   1625              *olen += tag_len;
   \       0xB6   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xBA   0xEB19 0x0101      ADDS     R1,R9,R1
   \       0xBE   0xF8C8 0x1000      STR      R1,[R8, #+0]
   1626              return ret;
   \                     ??mbedtls_cipher_auth_encrypt_ext_5: (+1)
   \       0xC2   0xB00B             ADD      SP,SP,#+44
   \       0xC4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1627          #else
   1628              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1629          #endif /* MBEDTLS_CIPHER_MODE_AEAD */
   1630          }
   1631          
   1632          /*
   1633           * Packet-oriented decryption for AEAD/NIST_KW: public function.
   1634           */

   \                                 In section .text, align 2, keep-with-next
   1635          int mbedtls_cipher_auth_decrypt_ext(mbedtls_cipher_context_t *ctx,
   1636                                              const unsigned char *iv, size_t iv_len,
   1637                                              const unsigned char *ad, size_t ad_len,
   1638                                              const unsigned char *input, size_t ilen,
   1639                                              unsigned char *output, size_t output_len,
   1640                                              size_t *olen, size_t tag_len)
   1641          {
   \                     mbedtls_cipher_auth_decrypt_ext: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x9C15             LDR      R4,[SP, #+84]
   \        0xA   0x9D16             LDR      R5,[SP, #+88]
   \        0xC   0x9E17             LDR      R6,[SP, #+92]
   \        0xE   0x9F18             LDR      R7,[SP, #+96]
   \       0x10   0xF8DD 0x8064      LDR      R8,[SP, #+100]
   \       0x14   0xF8DD 0x9068      LDR      R9,[SP, #+104]
   1642          #if defined(MBEDTLS_NIST_KW_C)
   1643              if (
   1644          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1645                  ctx->psa_enabled == 0 &&
   1646          #endif
   1647                  (MBEDTLS_MODE_KW == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1648                   MBEDTLS_MODE_KWP == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode))) {
   \       0x18   0xF89A 0x0044      LDRB     R0,[R10, #+68]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD132             BNE.N    ??mbedtls_cipher_auth_decrypt_ext_0
   \       0x20   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x24   0x6840             LDR      R0,[R0, #+4]
   \       0x26   0x0B00             LSRS     R0,R0,#+12
   \       0x28   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x2C   0x280C             CMP      R0,#+12
   \       0x2E   0xD007             BEQ.N    ??mbedtls_cipher_auth_decrypt_ext_1
   \       0x30   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x34   0x6840             LDR      R0,[R0, #+4]
   \       0x36   0x0B00             LSRS     R0,R0,#+12
   \       0x38   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x3C   0x280D             CMP      R0,#+13
   \       0x3E   0xD122             BNE.N    ??mbedtls_cipher_auth_decrypt_ext_0
   1649                  mbedtls_nist_kw_mode_t mode =
   1650                      (MBEDTLS_MODE_KW == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) ?
   1651                      MBEDTLS_KW_MODE_KW : MBEDTLS_KW_MODE_KWP;
   \                     ??mbedtls_cipher_auth_decrypt_ext_1: (+1)
   \       0x40   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x44   0x6840             LDR      R0,[R0, #+4]
   \       0x46   0x0B00             LSRS     R0,R0,#+12
   \       0x48   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x4C   0x280C             CMP      R0,#+12
   \       0x4E   0xD102             BNE.N    ??mbedtls_cipher_auth_decrypt_ext_2
   \       0x50   0xF05F 0x0B00      MOVS     R11,#+0
   \       0x54   0xE001             B.N      ??mbedtls_cipher_auth_decrypt_ext_3
   \                     ??mbedtls_cipher_auth_decrypt_ext_2: (+1)
   \       0x56   0xF05F 0x0B01      MOVS     R11,#+1
   1652          
   1653                  /* There is no iv, tag or ad associated with KW and KWP,
   1654                   * so these length should be 0 as documented. */
   1655                  if (iv_len != 0 || tag_len != 0 || ad_len != 0) {
   \                     ??mbedtls_cipher_auth_decrypt_ext_3: (+1)
   \       0x5A   0x9809             LDR      R0,[SP, #+36]
   \       0x5C   0xEA59 0x0000      ORRS     R0,R9,R0
   \       0x60   0x9914             LDR      R1,[SP, #+80]
   \       0x62   0x4308             ORRS     R0,R1,R0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD001             BEQ.N    ??mbedtls_cipher_auth_decrypt_ext_4
   1656                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x68   0x....             LDR.N    R0,??DataTable20_6
   \       0x6A   0xE02B             B.N      ??mbedtls_cipher_auth_decrypt_ext_5
   1657                  }
   1658          
   1659                  (void) iv;
   1660                  (void) ad;
   1661          
   1662                  return mbedtls_nist_kw_unwrap(ctx->cipher_ctx, mode, input, ilen,
   1663                                                output, olen, output_len);
   \                     ??mbedtls_cipher_auth_decrypt_ext_4: (+1)
   \       0x6C   0x9702             STR      R7,[SP, #+8]
   \       0x6E   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x72   0x9600             STR      R6,[SP, #+0]
   \       0x74   0x002B             MOVS     R3,R5
   \       0x76   0x0022             MOVS     R2,R4
   \       0x78   0x4659             MOV      R1,R11
   \       0x7A   0xB2C9             UXTB     R1,R1
   \       0x7C   0xF8DA 0x003C      LDR      R0,[R10, #+60]
   \       0x80   0x.... 0x....      BL       mbedtls_nist_kw_unwrap
   \       0x84   0xE01E             B.N      ??mbedtls_cipher_auth_decrypt_ext_5
   1664              }
   1665          #endif /* MBEDTLS_NIST_KW_C */
   1666          
   1667          #if defined(MBEDTLS_CIPHER_MODE_AEAD)
   1668              /* AEAD case: check length before passing on to shared function */
   1669              if (ilen < tag_len || output_len < ilen - tag_len) {
   \                     ??mbedtls_cipher_auth_decrypt_ext_0: (+1)
   \       0x86   0x454D             CMP      R5,R9
   \       0x88   0xD303             BCC.N    ??mbedtls_cipher_auth_decrypt_ext_6
   \       0x8A   0xEBB5 0x0009      SUBS     R0,R5,R9
   \       0x8E   0x4287             CMP      R7,R0
   \       0x90   0xD201             BCS.N    ??mbedtls_cipher_auth_decrypt_ext_7
   1670                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_auth_decrypt_ext_6: (+1)
   \       0x92   0x....             LDR.N    R0,??DataTable20_6
   \       0x94   0xE016             B.N      ??mbedtls_cipher_auth_decrypt_ext_5
   1671              }
   1672          
   1673              return mbedtls_cipher_aead_decrypt(ctx, iv, iv_len, ad, ad_len,
   1674                                                 input, ilen - tag_len, output, olen,
   1675                                                 input + ilen - tag_len, tag_len);
   \                     ??mbedtls_cipher_auth_decrypt_ext_7: (+1)
   \       0x96   0xF8CD 0x9018      STR      R9,[SP, #+24]
   \       0x9A   0xEB04 0x0105      ADD      R1,R4,R5
   \       0x9E   0xF1D9 0x0000      RSBS     R0,R9,#+0
   \       0xA2   0x4408             ADD      R0,R1,R0
   \       0xA4   0x9005             STR      R0,[SP, #+20]
   \       0xA6   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0xAA   0x9603             STR      R6,[SP, #+12]
   \       0xAC   0xEBB5 0x0009      SUBS     R0,R5,R9
   \       0xB0   0x9002             STR      R0,[SP, #+8]
   \       0xB2   0x9401             STR      R4,[SP, #+4]
   \       0xB4   0x9814             LDR      R0,[SP, #+80]
   \       0xB6   0x9000             STR      R0,[SP, #+0]
   \       0xB8   0x9B0A             LDR      R3,[SP, #+40]
   \       0xBA   0x9A09             LDR      R2,[SP, #+36]
   \       0xBC   0x9908             LDR      R1,[SP, #+32]
   \       0xBE   0x4650             MOV      R0,R10
   \       0xC0   0x.... 0x....      BL       mbedtls_cipher_aead_decrypt
   \                     ??mbedtls_cipher_auth_decrypt_ext_5: (+1)
   \       0xC4   0xB00B             ADD      SP,SP,#+44
   \       0xC6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1676          #else
   1677              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1678          #endif /* MBEDTLS_CIPHER_MODE_AEAD */
   1679          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     mbedtls_cipher_base_lookup_table

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     supported_init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x....'....        DC32     mbedtls_cipher_definitions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \        0x0   0x....'....        DC32     mbedtls_cipher_supported

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x0440'4400        DC32     0x4404400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x04C0'1300        DC32     0x4c01300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x0440'4000        DC32     0x4404000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0xFFFF'9F00        DC32     0xffff9f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0xFFFF'9E80        DC32     0xffff9e80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0xFFFF'9F80        DC32     0xffff9f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0xFFFF'9C80        DC32     0xffff9c80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \        0x0   0xFFFF'9D80        DC32     0xffff9d80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \        0x0   0x....'....        DC32     get_no_padding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \        0x0   0xFFFF'9D00        DC32     0xffff9d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \        0x0   0xFFFF'9F00        DC32     0xffff9f00
   1680          #endif /* MBEDTLS_CIPHER_MODE_AEAD || MBEDTLS_NIST_KW_C */
   1681          
   1682          #endif /* MBEDTLS_CIPHER_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   get_no_padding
      80   mbedtls_cipher_aead_decrypt
        80   -> mbedtls_ccm_auth_decrypt
        80   -> psa_aead_decrypt
      80   mbedtls_cipher_aead_encrypt
        80   -> mbedtls_ccm_encrypt_and_tag
        80   -> psa_aead_encrypt
      80   mbedtls_cipher_auth_decrypt_ext
        80   -> mbedtls_cipher_aead_decrypt
        80   -> mbedtls_nist_kw_unwrap
      80   mbedtls_cipher_auth_encrypt_ext
        80   -> mbedtls_cipher_aead_encrypt
        80   -> mbedtls_nist_kw_wrap
     216   mbedtls_cipher_crypt
       216   -> __aeabi_memclr4
       216   -> mbedtls_cipher_finish
       216   -> mbedtls_cipher_reset
       216   -> mbedtls_cipher_set_iv
       216   -> mbedtls_cipher_update
       216   -> psa_cipher_decrypt_setup
       216   -> psa_cipher_encrypt_setup
       216   -> psa_cipher_finish
       216   -> psa_cipher_set_iv
       216   -> psa_cipher_update
      32   mbedtls_cipher_finish
        32   -- Indirect call
        32   -> mbedtls_cipher_get_base
        32   -> mbedtls_cipher_get_block_size
        32   -> mbedtls_cipher_get_iv_size
      16   mbedtls_cipher_free
        16   -- Indirect call
        16   -> mbedtls_cipher_get_base
        16   -> mbedtls_platform_zeroize
        16   -> mbedtls_zeroize_and_free
        16   -> psa_destroy_key
       0   mbedtls_cipher_get_base
       0   mbedtls_cipher_get_block_size
       0   mbedtls_cipher_get_iv_size
      16   mbedtls_cipher_info_from_string
        16   -> strcmp
       0   mbedtls_cipher_info_from_type
      24   mbedtls_cipher_info_from_values
        24   -> mbedtls_cipher_get_base
        24   -> mbedtls_cipher_info_get_key_bitlen
       0   mbedtls_cipher_info_get_iv_size
       0   mbedtls_cipher_info_get_key_bitlen
      24   mbedtls_cipher_init
        24   -> __aeabi_memset
       0   mbedtls_cipher_list
       0   mbedtls_cipher_reset
      32   mbedtls_cipher_set_iv
        32   -> __aeabi_memcpy
        32   -> mbedtls_ccm_set_lengths
        32   -> mbedtls_ccm_starts
        32   -> mbedtls_cipher_info_get_iv_size
       0   mbedtls_cipher_set_padding_mode
      72   mbedtls_cipher_setkey
        72   -- Indirect call
        72   -> __aeabi_memclr4
        72   -> mbedtls_cipher_get_base
        72   -> mbedtls_cipher_info_get_key_bitlen
        72   -> mbedtls_psa_translate_cipher_type
        72   -> psa_import_key
        72   -> psa_set_key_algorithm
        72   -> psa_set_key_type
        72   -> psa_set_key_usage_flags
      24   mbedtls_cipher_setup
        24   -- Indirect call
        24   -> __aeabi_memset
        24   -> mbedtls_cipher_get_base
      32   mbedtls_cipher_setup_psa
        32   -> __aeabi_memset
        32   -> mbedtls_psa_translate_cipher_mode
        32   -> mbedtls_psa_translate_cipher_type
        32   -> sl_calloc
      56   mbedtls_cipher_update
        56   -- Indirect call
        56   -> __aeabi_memcpy
        56   -> mbedtls_ccm_update
        56   -> mbedtls_cipher_get_base
        56   -> mbedtls_cipher_get_block_size
       0   mbedtls_psa_translate_cipher_mode
       0   mbedtls_psa_translate_cipher_type
       0   psa_extend_key_usage_flags
       0   psa_set_key_algorithm
      16   psa_set_key_type
        16   -> psa_set_key_domain_parameters
      16   psa_set_key_usage_flags
        16   -> psa_extend_key_usage_flags


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
      36  ?_0
     152  ?_1
      22  get_no_padding
     212  mbedtls_cipher_aead_decrypt
     198  mbedtls_cipher_aead_encrypt
     202  mbedtls_cipher_auth_decrypt_ext
     200  mbedtls_cipher_auth_encrypt_ext
     362  mbedtls_cipher_crypt
     424  mbedtls_cipher_finish
      84  mbedtls_cipher_free
      16  mbedtls_cipher_get_base
      22  mbedtls_cipher_get_block_size
      34  mbedtls_cipher_get_iv_size
      48  mbedtls_cipher_info_from_string
      34  mbedtls_cipher_info_from_type
      72  mbedtls_cipher_info_from_values
      20  mbedtls_cipher_info_get_iv_size
      20  mbedtls_cipher_info_get_key_bitlen
      22  mbedtls_cipher_init
      52  mbedtls_cipher_list
      36  mbedtls_cipher_reset
     208  mbedtls_cipher_set_iv
      82  mbedtls_cipher_set_padding_mode
     392  mbedtls_cipher_setkey
      64  mbedtls_cipher_setup
     128  mbedtls_cipher_setup_psa
     604  mbedtls_cipher_update
      94  mbedtls_psa_translate_cipher_mode
      34  mbedtls_psa_translate_cipher_type
      30  psa_extend_key_usage_flags
       4  psa_set_key_algorithm
      32  psa_set_key_type
      16  psa_set_key_usage_flags
       4  supported_init

 
     4 bytes in section .bss
   188 bytes in section .rodata
 3'828 bytes in section .text
 
 3'828 bytes of CODE  memory
   188 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
