###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:43
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\constant_time.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\constant_time.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\constant_time.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\constant_time.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\constant_time.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\constant_time.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\constant_time.c
      1          /**
      2           *  Constant-time functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           * The following functions are implemented without using comparison operators, as those
     22           * might be translated to branches by some compilers on some platforms.
     23           */
     24          
     25          #include <stdint.h>
     26          #include <limits.h>
     27          
     28          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint32_t mbedtls_get_unaligned_uint32(void const *)
   \                     mbedtls_get_unaligned_uint32: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2404             MOVS     R4,#+4
   \        0x6   0x003D             MOVS     R5,R7
   \        0x8   0x466E             MOV      R6,SP
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint32(void *, uint32_t)
   \                     mbedtls_put_unaligned_uint32: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2404             MOVS     R4,#+4
   \        0x6   0x466D             MOV      R5,SP
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}
     29          #include "constant_time_internal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_compiler_opaque(uint32_t)
   \                     mbedtls_ct_compiler_opaque: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable0
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0x4048             EORS     R0,R1,R0
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool(uint32_t)
   \                     mbedtls_ct_bool: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xA   0x0002             MOVS     R2,R0
   \        0xC   0x4251             RSBS     R1,R2,#+0
   \        0xE   0x0010             MOVS     R0,R2
   \       0x10   0x0840             LSRS     R0,R0,#+1
   \       0x12   0x4240             RSBS     R0,R0,#+0
   \       0x14   0x4308             ORRS     R0,R0,R1
   \       0x16   0x0FC0             LSRS     R0,R0,#+31
   \       0x18   0x4240             RSBS     R0,R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_if(uint32_t, uint32_t, uint32_t)
   \                     mbedtls_ct_if: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xE   0x43C0             MVNS     R0,R0
   \       0x10   0x4026             ANDS     R6,R4,R6
   \       0x12   0x4005             ANDS     R5,R5,R0
   \       0x14   0x432E             ORRS     R6,R5,R6
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_lt(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_lt: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x4648             MOV      R0,R9
   \        0xA   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xE   0x0005             MOVS     R5,R0
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x16   0x0006             MOVS     R6,R0
   \       0x18   0xEA96 0x0005      EORS     R0,R6,R5
   \       0x1C   0x0FC0             LSRS     R0,R0,#+31
   \       0x1E   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x22   0x0007             MOVS     R7,R0
   \       0x24   0x1BAA             SUBS     R2,R5,R6
   \       0x26   0x0031             MOVS     R1,R6
   \       0x28   0x0038             MOVS     R0,R7
   \       0x2A   0x.... 0x....      BL       mbedtls_ct_if
   \       0x2E   0x4680             MOV      R8,R0
   \       0x30   0xEA5F 0x78D8      LSRS     R8,R8,#+31
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x3A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_ne(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_ne: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0038             MOVS     R0,R7
   \        0x8   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xC   0x0005             MOVS     R5,R0
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x14   0x0006             MOVS     R6,R0
   \       0x16   0x406E             EORS     R6,R6,R5
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp unsigned int mbedtls_ct_uint_if_else_0(uint32_t, unsigned int)
   \                     mbedtls_ct_uint_if_else_0: (+1)
   \        0x0   0x4008             ANDS     R0,R1,R0
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_eq(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_eq: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0021             MOVS     R1,R4
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_ct_uint_ne
   \        0xE   0x43C0             MVNS     R0,R0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_ge(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_ge: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0021             MOVS     R1,R4
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_ct_uint_lt
   \        0xE   0x43C0             MVNS     R0,R0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool_and(uint32_t, uint32_t)
   \                     mbedtls_ct_bool_and: (+1)
   \        0x0   0x4008             ANDS     R0,R1,R0
   \        0x2   0x4770             BX       LR
     30          #include "mbedtls/constant_time.h"
     31          #include "mbedtls/error.h"
     32          #include "mbedtls/platform_util.h"
     33          
     34          #include <string.h>
     35          
     36          #if defined(MBEDTLS_USE_PSA_CRYPTO) && defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
     37          #include "psa/crypto.h"
     38          /* Define a local translating function to save code size by not using too many
     39           * arguments in each translating place. */
     40          static int local_err_translation(psa_status_t status)
     41          {
     42              return psa_status_to_mbedtls(status, psa_to_ssl_errors,
     43                                           ARRAY_LENGTH(psa_to_ssl_errors),
     44                                           psa_generic_status_to_mbedtls);
     45          }
     46          #define PSA_TO_MBEDTLS_ERR(status) local_err_translation(status)
     47          #endif
     48          
     49          #if !defined(MBEDTLS_CT_ASM)
     50          /*
     51           * Define an object with the value zero, such that the compiler cannot prove that it
     52           * has the value zero (because it is volatile, it "may be modified in ways unknown to
     53           * the implementation").
     54           */

   \                                 In section .bss, align 4
     55          volatile mbedtls_ct_uint_t mbedtls_ct_zero = 0;
   \                     mbedtls_ct_zero:
   \        0x0                      DS8 4
     56          #endif
     57          
     58          /*
     59           * Define MBEDTLS_EFFICIENT_UNALIGNED_VOLATILE_ACCESS where assembly is present to
     60           * perform fast unaligned access to volatile data.
     61           *
     62           * This is needed because mbedtls_get_unaligned_uintXX etc don't support volatile
     63           * memory accesses.
     64           *
     65           * Some of these definitions could be moved into alignment.h but for now they are
     66           * only used here.
     67           */
     68          #if defined(MBEDTLS_EFFICIENT_UNALIGNED_ACCESS) && \
     69              ((defined(MBEDTLS_CT_ARM_ASM) && (UINTPTR_MAX == 0xfffffffful)) || \
     70              defined(MBEDTLS_CT_AARCH64_ASM))
     71          /* We check pointer sizes to avoid issues with them not matching register size requirements */
     72          #define MBEDTLS_EFFICIENT_UNALIGNED_VOLATILE_ACCESS
     73          
     74          static inline uint32_t mbedtls_get_unaligned_volatile_uint32(volatile const unsigned char *p)
     75          {
     76              /* This is UB, even where it's safe:
     77               *    return *((volatile uint32_t*)p);
     78               * so instead the same thing is expressed in assembly below.
     79               */
     80              uint32_t r;
     81          #if defined(MBEDTLS_CT_ARM_ASM)
     82              asm volatile ("ldr %0, [%1]" : "=r" (r) : "r" (p) :);
     83          #elif defined(MBEDTLS_CT_AARCH64_ASM)
     84              asm volatile ("ldr %w0, [%1]" : "=r" (r) : MBEDTLS_ASM_AARCH64_PTR_CONSTRAINT(p) :);
     85          #else
     86          #error "No assembly defined for mbedtls_get_unaligned_volatile_uint32"
     87          #endif
     88              return r;
     89          }
     90          #endif /* defined(MBEDTLS_EFFICIENT_UNALIGNED_ACCESS) &&
     91                    (defined(MBEDTLS_CT_ARM_ASM) || defined(MBEDTLS_CT_AARCH64_ASM)) */
     92          

   \                                 In section .text, align 2, keep-with-next
     93          int mbedtls_ct_memcmp(const void *a,
     94                                const void *b,
     95                                size_t n)
     96          {
   \                     mbedtls_ct_memcmp: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0003             MOVS     R3,R0
     97              size_t i = 0;
   \        0x4   0x2400             MOVS     R4,#+0
     98              /*
     99               * `A` and `B` are cast to volatile to ensure that the compiler
    100               * generates code that always fully reads both buffers.
    101               * Otherwise it could generate a test to exit early if `diff` has all
    102               * bits set early in the loop.
    103               */
    104              volatile const unsigned char *A = (volatile const unsigned char *) a;
   \        0x6   0x001D             MOVS     R5,R3
    105              volatile const unsigned char *B = (volatile const unsigned char *) b;
   \        0x8   0x000E             MOVS     R6,R1
    106              uint32_t diff = 0;
   \        0xA   0x2700             MOVS     R7,#+0
    107          
    108          #if defined(MBEDTLS_EFFICIENT_UNALIGNED_VOLATILE_ACCESS)
    109              for (; (i + 4) <= n; i += 4) {
    110                  uint32_t x = mbedtls_get_unaligned_volatile_uint32(A + i);
    111                  uint32_t y = mbedtls_get_unaligned_volatile_uint32(B + i);
    112                  diff |= x ^ y;
    113              }
    114          #endif
    115          
    116              for (; i < n; i++) {
   \                     ??mbedtls_ct_memcmp_0: (+1)
   \        0xC   0x4294             CMP      R4,R2
   \        0xE   0xD20B             BCS.N    ??mbedtls_ct_memcmp_1
    117                  /* Read volatile data in order before computing diff.
    118                   * This avoids IAR compiler warning:
    119                   * 'the order of volatile accesses is undefined ..' */
    120                  unsigned char x = A[i], y = B[i];
   \       0x10   0xF815 0xC004      LDRB     R12,[R5, R4]
   \       0x14   0x5D30             LDRB     R0,[R6, R4]
    121                  diff |= x ^ y;
   \       0x16   0xFA5F 0xFC8C      UXTB     R12,R12
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0xEA90 0x0C0C      EORS     R12,R0,R12
   \       0x20   0xEA5C 0x0707      ORRS     R7,R12,R7
    122              }
   \       0x24   0x1C64             ADDS     R4,R4,#+1
   \       0x26   0xE7F1             B.N      ??mbedtls_ct_memcmp_0
    123          
    124          
    125          #if (INT_MAX < INT32_MAX)
    126              /* We don't support int smaller than 32-bits, but if someone tried to build
    127               * with this configuration, there is a risk that, for differing data, the
    128               * only bits set in diff are in the top 16-bits, and would be lost by a
    129               * simple cast from uint32 to int.
    130               * This would have significant security implications, so protect against it. */
    131          #error "mbedtls_ct_memcmp() requires minimum 32-bit ints"
    132          #else
    133              /* The bit-twiddling ensures that when we cast uint32_t to int, we are casting
    134               * a value that is in the range 0..INT_MAX - a value larger than this would
    135               * result in implementation defined behaviour.
    136               *
    137               * This ensures that the value returned by the function is non-zero iff
    138               * diff is non-zero.
    139               */
    140              return (int) ((diff & 0xffff) | (diff >> 16));
   \                     ??mbedtls_ct_memcmp_1: (+1)
   \       0x28   0xB2B8             UXTH     R0,R7
   \       0x2A   0xEA50 0x4017      ORRS     R0,R0,R7, LSR #+16
   \       0x2E   0xBCF0             POP      {R4-R7}
   \       0x30   0x4770             BX       LR
    141          #endif
    142          }
    143          
    144          #if defined(MBEDTLS_NIST_KW_C)
    145          

   \                                 In section .text, align 2, keep-with-next
    146          int mbedtls_ct_memcmp_partial(const void *a,
    147                                        const void *b,
    148                                        size_t n,
    149                                        size_t skip_head,
    150                                        size_t skip_tail)
    151          {
   \                     mbedtls_ct_memcmp_partial: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
   \        0xE   0x9F0E             LDR      R7,[SP, #+56]
    152              unsigned int diff = 0;
   \       0x10   0xF05F 0x0800      MOVS     R8,#+0
    153          
    154              volatile const unsigned char *A = (volatile const unsigned char *) a;
   \       0x14   0xF8CD 0xB010      STR      R11,[SP, #+16]
    155              volatile const unsigned char *B = (volatile const unsigned char *) b;
   \       0x18   0x9403             STR      R4,[SP, #+12]
    156          
    157              size_t valid_end = n - skip_tail;
   \       0x1A   0x1BE8             SUBS     R0,R5,R7
   \       0x1C   0x9002             STR      R0,[SP, #+8]
    158          
    159              for (size_t i = 0; i < n; i++) {
   \       0x1E   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??mbedtls_ct_memcmp_partial_0: (+1)
   \       0x22   0x45A9             CMP      R9,R5
   \       0x24   0xD226             BCS.N    ??mbedtls_ct_memcmp_partial_1
    160                  unsigned char x = A[i], y = B[i];
   \       0x26   0x9804             LDR      R0,[SP, #+16]
   \       0x28   0xF810 0x0009      LDRB     R0,[R0, R9]
   \       0x2C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \       0x30   0x9803             LDR      R0,[SP, #+12]
   \       0x32   0xF810 0x0009      LDRB     R0,[R0, R9]
   \       0x36   0xF88D 0x0000      STRB     R0,[SP, #+0]
    161                  unsigned int d = x ^ y;
   \       0x3A   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \       0x3E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x42   0x4041             EORS     R1,R0,R1
   \       0x44   0x9101             STR      R1,[SP, #+4]
    162                  mbedtls_ct_condition_t valid = mbedtls_ct_bool_and(mbedtls_ct_uint_ge(i, skip_head),
    163                                                                     mbedtls_ct_uint_lt(i, valid_end));
   \       0x46   0x9902             LDR      R1,[SP, #+8]
   \       0x48   0x4648             MOV      R0,R9
   \       0x4A   0x.... 0x....      BL       mbedtls_ct_uint_lt
   \       0x4E   0x4682             MOV      R10,R0
   \       0x50   0x0031             MOVS     R1,R6
   \       0x52   0x4648             MOV      R0,R9
   \       0x54   0x.... 0x....      BL       mbedtls_ct_uint_ge
   \       0x58   0x4651             MOV      R1,R10
   \       0x5A   0x.... 0x....      BL       mbedtls_ct_bool_and
   \       0x5E   0x4682             MOV      R10,R0
    164                  diff |= mbedtls_ct_uint_if_else_0(valid, d);
   \       0x60   0x9901             LDR      R1,[SP, #+4]
   \       0x62   0x4650             MOV      R0,R10
   \       0x64   0x.... 0x....      BL       mbedtls_ct_uint_if_else_0
   \       0x68   0xEA50 0x0008      ORRS     R0,R0,R8
   \       0x6C   0x4680             MOV      R8,R0
    165              }
   \       0x6E   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x72   0xE7D6             B.N      ??mbedtls_ct_memcmp_partial_0
    166          
    167              /* Since we go byte-by-byte, the only bits set will be in the bottom 8 bits, so the
    168               * cast from uint to int is safe. */
    169              return (int) diff;
   \                     ??mbedtls_ct_memcmp_partial_1: (+1)
   \       0x74   0x4640             MOV      R0,R8
   \       0x76   0xB005             ADD      SP,SP,#+20
   \       0x78   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    170          }
    171          
    172          #endif
    173          
    174          #if defined(MBEDTLS_PKCS1_V15) && defined(MBEDTLS_RSA_C) && !defined(MBEDTLS_RSA_ALT)
    175          
    176          void mbedtls_ct_memmove_left(void *start, size_t total, size_t offset)
    177          {
    178              volatile unsigned char *buf = start;
    179              for (size_t i = 0; i < total; i++) {
    180                  mbedtls_ct_condition_t no_op = mbedtls_ct_uint_gt(total - offset, i);
    181                  /* The first `total - offset` passes are a no-op. The last
    182                   * `offset` passes shift the data one byte to the left and
    183                   * zero out the last byte. */
    184                  for (size_t n = 0; n < total - 1; n++) {
    185                      unsigned char current = buf[n];
    186                      unsigned char next    = buf[n+1];
    187                      buf[n] = mbedtls_ct_uint_if(no_op, current, next);
    188                  }
    189                  buf[total-1] = mbedtls_ct_uint_if_else_0(no_op, buf[total-1]);
    190              }
    191          }
    192          
    193          #endif /* MBEDTLS_PKCS1_V15 && MBEDTLS_RSA_C && ! MBEDTLS_RSA_ALT */
    194          

   \                                 In section .text, align 2, keep-with-next
    195          void mbedtls_ct_memcpy_if(mbedtls_ct_condition_t condition,
    196                                    unsigned char *dest,
    197                                    const unsigned char *src1,
    198                                    const unsigned char *src2,
    199                                    size_t len)
    200          {
   \                     mbedtls_ct_memcpy_if: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB082             SUB      SP,SP,#+8
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9F0C             LDR      R7,[SP, #+48]
    201          #if defined(MBEDTLS_CT_SIZE_64)
    202              const uint64_t mask     = (uint64_t) condition;
    203              const uint64_t not_mask = (uint64_t) ~mbedtls_ct_compiler_opaque(condition);
    204          #else
    205              const uint32_t mask     = (uint32_t) condition;
   \        0xE   0x9802             LDR      R0,[SP, #+8]
   \       0x10   0x9000             STR      R0,[SP, #+0]
    206              const uint32_t not_mask = (uint32_t) ~mbedtls_ct_compiler_opaque(condition);
   \       0x12   0x9802             LDR      R0,[SP, #+8]
   \       0x14   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x18   0x4680             MOV      R8,R0
   \       0x1A   0xEA7F 0x0808      MVNS     R8,R8
    207          #endif
    208          
    209              /* If src2 is NULL, setup src2 so that we read from the destination address.
    210               *
    211               * This means that if src2 == NULL && condition is false, the result will be a
    212               * no-op because we read from dest and write the same data back into dest.
    213               */
    214              if (src2 == NULL) {
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD100             BNE.N    ??mbedtls_ct_memcpy_if_0
    215                  src2 = dest;
   \       0x22   0x002C             MOVS     R4,R5
    216              }
    217          
    218              /* dest[i] = c1 == c2 ? src[i] : dest[i] */
    219              size_t i = 0;
   \                     ??mbedtls_ct_memcpy_if_0: (+1)
   \       0x24   0xF05F 0x0900      MOVS     R9,#+0
    220          #if defined(MBEDTLS_EFFICIENT_UNALIGNED_ACCESS)
    221          #if defined(MBEDTLS_CT_SIZE_64)
    222              for (; (i + 8) <= len; i += 8) {
    223                  uint64_t a = mbedtls_get_unaligned_uint64(src1 + i) & mask;
    224                  uint64_t b = mbedtls_get_unaligned_uint64(src2 + i) & not_mask;
    225                  mbedtls_put_unaligned_uint64(dest + i, a | b);
    226              }
    227          #else
    228              for (; (i + 4) <= len; i += 4) {
   \                     ??mbedtls_ct_memcpy_if_1: (+1)
   \       0x28   0xF119 0x0004      ADDS     R0,R9,#+4
   \       0x2C   0x4287             CMP      R7,R0
   \       0x2E   0xD317             BCC.N    ??mbedtls_ct_memcpy_if_2
    229                  uint32_t a = mbedtls_get_unaligned_uint32(src1 + i) & mask;
   \       0x30   0xEB06 0x0009      ADD      R0,R6,R9
   \       0x34   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x38   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \       0x3C   0xEA1B 0x0B00      ANDS     R11,R11,R0
    230                  uint32_t b = mbedtls_get_unaligned_uint32(src2 + i) & not_mask;
   \       0x40   0xEB04 0x0009      ADD      R0,R4,R9
   \       0x44   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x48   0x4682             MOV      R10,R0
   \       0x4A   0xEA18 0x0A0A      ANDS     R10,R8,R10
    231                  mbedtls_put_unaligned_uint32(dest + i, a | b);
   \       0x4E   0xEA5A 0x010B      ORRS     R1,R10,R11
   \       0x52   0xEB05 0x0009      ADD      R0,R5,R9
   \       0x56   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
    232              }
   \       0x5A   0xF119 0x0904      ADDS     R9,R9,#+4
   \       0x5E   0xE7E3             B.N      ??mbedtls_ct_memcpy_if_1
    233          #endif /* defined(MBEDTLS_CT_SIZE_64) */
    234          #endif /* MBEDTLS_EFFICIENT_UNALIGNED_ACCESS */
    235              for (; i < len; i++) {
   \                     ??mbedtls_ct_memcpy_if_2: (+1)
   \       0x60   0x45B9             CMP      R9,R7
   \       0x62   0xD20D             BCS.N    ??mbedtls_ct_memcpy_if_3
    236                  dest[i] = (src1[i] & mask) | (src2[i] & not_mask);
   \       0x64   0xF816 0x1009      LDRB     R1,[R6, R9]
   \       0x68   0x9800             LDR      R0,[SP, #+0]
   \       0x6A   0x4001             ANDS     R1,R0,R1
   \       0x6C   0xF814 0x0009      LDRB     R0,[R4, R9]
   \       0x70   0xEA18 0x0000      ANDS     R0,R8,R0
   \       0x74   0x4301             ORRS     R1,R0,R1
   \       0x76   0xF805 0x1009      STRB     R1,[R5, R9]
    237              }
   \       0x7A   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x7E   0xE7EF             B.N      ??mbedtls_ct_memcpy_if_2
    238          }
   \                     ??mbedtls_ct_memcpy_if_3: (+1)
   \       0x80   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    239          

   \                                 In section .text, align 2, keep-with-next
    240          void mbedtls_ct_memcpy_offset(unsigned char *dest,
    241                                        const unsigned char *src,
    242                                        size_t offset,
    243                                        size_t offset_min,
    244                                        size_t offset_max,
    245                                        size_t len)
    246          {
   \                     mbedtls_ct_memcpy_offset: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    247              size_t offsetval;
    248          
    249              for (offsetval = offset_min; offsetval <= offset_max; offsetval++) {
   \       0x10   0x46B9             MOV      R9,R7
   \                     ??mbedtls_ct_memcpy_offset_0: (+1)
   \       0x12   0x45C8             CMP      R8,R9
   \       0x14   0xD30E             BCC.N    ??mbedtls_ct_memcpy_offset_1
    250                  mbedtls_ct_memcpy_if(mbedtls_ct_uint_eq(offsetval, offset), dest, src + offsetval, NULL,
    251                                       len);
   \       0x16   0x0031             MOVS     R1,R6
   \       0x18   0x4648             MOV      R0,R9
   \       0x1A   0x.... 0x....      BL       mbedtls_ct_uint_eq
   \       0x1E   0x9909             LDR      R1,[SP, #+36]
   \       0x20   0x9100             STR      R1,[SP, #+0]
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0xEB05 0x0209      ADD      R2,R5,R9
   \       0x28   0x0021             MOVS     R1,R4
   \       0x2A   0x.... 0x....      BL       mbedtls_ct_memcpy_if
    252              }
   \       0x2E   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x32   0xE7EE             B.N      ??mbedtls_ct_memcpy_offset_0
    253          }
   \                     ??mbedtls_ct_memcpy_offset_1: (+1)
   \       0x34   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x....'....        DC32     mbedtls_ct_zero
    254          
    255          #if defined(MBEDTLS_PKCS1_V15) && defined(MBEDTLS_RSA_C) && !defined(MBEDTLS_RSA_ALT)
    256          
    257          void mbedtls_ct_zeroize_if(mbedtls_ct_condition_t condition, void *buf, size_t len)
    258          {
    259              uint32_t mask = (uint32_t) ~condition;
    260              uint8_t *p = (uint8_t *) buf;
    261              size_t i = 0;
    262          #if defined(MBEDTLS_EFFICIENT_UNALIGNED_ACCESS)
    263              for (; (i + 4) <= len; i += 4) {
    264                  mbedtls_put_unaligned_uint32((void *) (p + i),
    265                                               mbedtls_get_unaligned_uint32((void *) (p + i)) & mask);
    266              }
    267          #endif
    268              for (; i < len; i++) {
    269                  p[i] = p[i] & mask;
    270              }
    271          }
    272          
    273          #endif /* defined(MBEDTLS_PKCS1_V15) && defined(MBEDTLS_RSA_C) && !defined(MBEDTLS_RSA_ALT) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   mbedtls_ct_bool
         8   -> mbedtls_ct_compiler_opaque
       0   mbedtls_ct_bool_and
       0   mbedtls_ct_compiler_opaque
      16   mbedtls_ct_if
        16   -> mbedtls_ct_compiler_opaque
      16   mbedtls_ct_memcmp
      56   mbedtls_ct_memcmp_partial
        56   -> mbedtls_ct_bool_and
        56   -> mbedtls_ct_uint_ge
        56   -> mbedtls_ct_uint_if_else_0
        56   -> mbedtls_ct_uint_lt
      48   mbedtls_ct_memcpy_if
        48   -> mbedtls_ct_compiler_opaque
        48   -> mbedtls_get_unaligned_uint32
        48   -> mbedtls_put_unaligned_uint32
      32   mbedtls_ct_memcpy_offset
        32   -> mbedtls_ct_memcpy_if
        32   -> mbedtls_ct_uint_eq
      16   mbedtls_ct_uint_eq
        16   -> mbedtls_ct_uint_ne
      16   mbedtls_ct_uint_ge
        16   -> mbedtls_ct_uint_lt
       0   mbedtls_ct_uint_if_else_0
      32   mbedtls_ct_uint_lt
        32   -> mbedtls_ct_bool
        32   -> mbedtls_ct_compiler_opaque
        32   -> mbedtls_ct_if
      24   mbedtls_ct_uint_ne
        24   -> mbedtls_ct_bool
        24   -> mbedtls_ct_compiler_opaque
      24   mbedtls_get_unaligned_uint32
        24   -> __aeabi_memcpy
      24   mbedtls_put_unaligned_uint32
        24   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      28  mbedtls_ct_bool
       4  mbedtls_ct_bool_and
       8  mbedtls_ct_compiler_opaque
      26  mbedtls_ct_if
      50  mbedtls_ct_memcmp
     124  mbedtls_ct_memcmp_partial
     132  mbedtls_ct_memcpy_if
      56  mbedtls_ct_memcpy_offset
      18  mbedtls_ct_uint_eq
      18  mbedtls_ct_uint_ge
       4  mbedtls_ct_uint_if_else_0
      62  mbedtls_ct_uint_lt
      32  mbedtls_ct_uint_ne
       4  mbedtls_ct_zero
      24  mbedtls_get_unaligned_uint32
      22  mbedtls_put_unaligned_uint32

 
   4 bytes in section .bss
 612 bytes in section .text
 
 566 bytes of CODE memory (+ 46 bytes shared)
   4 bytes of DATA memory

Errors: none
Warnings: none
