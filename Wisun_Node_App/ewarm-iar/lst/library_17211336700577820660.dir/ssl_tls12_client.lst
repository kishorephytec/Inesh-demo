###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:54:03
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_tls12_client.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ssl_tls12_client.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_tls12_client.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ssl_tls12_client.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\ssl_tls12_client.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ssl_tls12_client.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_tls12_client.c
      1          /*
      2           *  TLS client-side functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint16_t mbedtls_get_unaligned_uint16(void const *)
   \                     mbedtls_get_unaligned_uint16: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2402             MOVS     R4,#+2
   \        0x6   0x003D             MOVS     R5,R7
   \        0x8   0x466E             MOV      R6,SP
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x18   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2402             MOVS     R4,#+2
   \        0x6   0x466D             MOV      R5,SP
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t mbedtls_bswap16(uint16_t)
   \                     mbedtls_bswap16: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x0A00             LSRS     R0,R0,#+8
   \        0x8   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x4770             BX       LR

   \                                 In section .rodata, align 2
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     21          
     22          #if defined(MBEDTLS_SSL_CLI_C) && defined(MBEDTLS_SSL_PROTO_TLS1_2)
     23          
     24          #include "mbedtls/platform.h"
     25          
     26          #include "mbedtls/ssl.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp struct psa_key_attributes_s psa_key_attributes_init(void)
   \                     psa_key_attributes_init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x2124             MOVS     R1,#+36
   \        0xA   0x.... 0x....      BL       __aeabi_memclr4
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x2224             MOVS     R2,#+36
   \       0x14   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x18   0xB00A             ADD      SP,SP,#+40
   \       0x1A   0xBD10             POP      {R4,PC}

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_extend_key_usage_flags(uint32_t *)
   \                     psa_extend_key_usage_flags: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x04C9             LSLS     R1,R1,#+19
   \        0x4   0xD503             BPL.N    ??psa_extend_key_usage_flags_0
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0xF451 0x6180      ORRS     R1,R1,#0x400
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \                     ??psa_extend_key_usage_flags_0: (+1)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x0489             LSLS     R1,R1,#+18
   \       0x12   0xD503             BPL.N    ??psa_extend_key_usage_flags_1
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF451 0x6100      ORRS     R1,R1,#0x800
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   \                     ??psa_extend_key_usage_flags_1: (+1)
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_usage_flags(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_usage_flags: (+1)
   \        0x0   0xB513             PUSH     {R0,R1,R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0xA801             ADD      R0,SP,#+4
   \        0x6   0x.... 0x....      BL       psa_extend_key_usage_flags
   \        0xA   0x9801             LDR      R0,[SP, #+4]
   \        0xC   0x60E0             STR      R0,[R4, #+12]
   \        0xE   0xBD13             POP      {R0,R1,R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_algorithm(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_algorithm: (+1)
   \        0x0   0x6101             STR      R1,[R0, #+16]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_type(psa_key_attributes_t *, uint16_t)
   \                     psa_set_key_type: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x69E8             LDR      R0,[R5, #+28]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??psa_set_key_type_0
   \        0xC   0x802C             STRH     R4,[R5, #+0]
   \        0xE   0xE006             B.N      ??psa_set_key_type_1
   \                     ??psa_set_key_type_0: (+1)
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x0021             MOVS     R1,R4
   \       0x16   0xB289             UXTH     R1,R1
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       psa_set_key_domain_parameters
   \                     ??psa_set_key_type_1: (+1)
   \       0x1E   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_bits(psa_key_attributes_t *, size_t)
   \                     psa_set_key_bits: (+1)
   \        0x0   0xF64F 0x72F9      MOVW     R2,#+65529
   \        0x4   0x4291             CMP      R1,R2
   \        0x6   0xD303             BCC.N    ??psa_set_key_bits_0
   \        0x8   0xF64F 0x72FF      MOVW     R2,#+65535
   \        0xC   0x8042             STRH     R2,[R0, #+2]
   \        0xE   0xE000             B.N      ??psa_set_key_bits_1
   \                     ??psa_set_key_bits_0: (+1)
   \       0x10   0x8041             STRH     R1,[R0, #+2]
   \                     ??psa_set_key_bits_1: (+1)
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_ciphersuite_cert_req_allowed(mbedtls_ssl_ciphersuite_t const *)
   \                     mbedtls_ssl_ciphersuite_cert_req_allowed: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x7A8A             LDRB     R2,[R1, #+10]
   \        0x4   0x1E52             SUBS     R2,R2,#+1
   \        0x6   0x2A03             CMP      R2,#+3
   \        0x8   0xD902             BLS.N    ??mbedtls_ssl_ciphersuite_cert_req_allowed_0
   \        0xA   0x3A08             SUBS     R2,R2,#+8
   \        0xC   0x2A01             CMP      R2,#+1
   \        0xE   0xD801             BHI.N    ??mbedtls_ssl_ciphersuite_cert_req_allowed_1
   \                     ??mbedtls_ssl_ciphersuite_cert_req_allowed_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE000             B.N      ??mbedtls_ssl_ciphersuite_cert_req_allowed_2
   \                     ??mbedtls_ssl_ciphersuite_cert_req_allowed_1: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_ciphersuite_cert_req_allowed_2: (+1)
   \       0x16   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_ciphersuite_uses_server_signature(mbedtls_ssl_ciphersuite_t const *)
   \                     mbedtls_ssl_ciphersuite_uses_server_signature: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x7A8A             LDRB     R2,[R1, #+10]
   \        0x4   0x1E92             SUBS     R2,R2,#+2
   \        0x6   0x2A02             CMP      R2,#+2
   \        0x8   0xD801             BHI.N    ??mbedtls_ssl_ciphersuite_uses_server_signature_0
   \                     ??mbedtls_ssl_ciphersuite_uses_server_signature_1: (+1)
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??mbedtls_ssl_ciphersuite_uses_server_signature_2
   \                     ??mbedtls_ssl_ciphersuite_uses_server_signature_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_ciphersuite_uses_server_signature_2: (+1)
   \       0x10   0x4770             BX       LR
     27          #include "ssl_client.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_chk_buf_ptr(uint8_t const *, uint8_t const *, size_t)
   \                     mbedtls_ssl_chk_buf_ptr: (+1)
   \        0x0   0x4281             CMP      R1,R0
   \        0x2   0xD302             BCC.N    ??mbedtls_ssl_chk_buf_ptr_0
   \        0x4   0x1A08             SUBS     R0,R1,R0
   \        0x6   0x4290             CMP      R0,R2
   \        0x8   0xD201             BCS.N    ??mbedtls_ssl_chk_buf_ptr_1
   \                     ??mbedtls_ssl_chk_buf_ptr_0: (+1)
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??mbedtls_ssl_chk_buf_ptr_2
   \                     ??mbedtls_ssl_chk_buf_ptr_1: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_chk_buf_ptr_2: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_write_handshake_msg(mbedtls_ssl_context *)
   \                     mbedtls_ssl_write_handshake_msg: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       mbedtls_ssl_write_handshake_msg_ext
   \        0xE   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp mbedtls_pk_context *mbedtls_ssl_own_key(mbedtls_ssl_context *)
   \                     mbedtls_ssl_own_key: (+1)
   \        0x0   0x6B81             LDR      R1,[R0, #+56]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD008             BEQ.N    ??mbedtls_ssl_own_key_0
   \        0x6   0x6B81             LDR      R1,[R0, #+56]
   \        0x8   0xF8D1 0x10A4      LDR      R1,[R1, #+164]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??mbedtls_ssl_own_key_0
   \       0x10   0x6B81             LDR      R1,[R0, #+56]
   \       0x12   0xF8D1 0x10A4      LDR      R1,[R1, #+164]
   \       0x16   0xE001             B.N      ??mbedtls_ssl_own_key_1
   \                     ??mbedtls_ssl_own_key_0: (+1)
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x6B89             LDR      R1,[R1, #+56]
   \                     ??mbedtls_ssl_own_key_1: (+1)
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD101             BNE.N    ??mbedtls_ssl_own_key_2
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xE000             B.N      ??mbedtls_ssl_own_key_3
   \                     ??mbedtls_ssl_own_key_2: (+1)
   \       0x24   0x6848             LDR      R0,[R1, #+4]
   \                     ??mbedtls_ssl_own_key_3: (+1)
   \       0x26   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp mbedtls_x509_crt *mbedtls_ssl_own_cert(mbedtls_ssl_context *)
   \                     mbedtls_ssl_own_cert: (+1)
   \        0x0   0x6B81             LDR      R1,[R0, #+56]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD008             BEQ.N    ??mbedtls_ssl_own_cert_0
   \        0x6   0x6B81             LDR      R1,[R0, #+56]
   \        0x8   0xF8D1 0x10A4      LDR      R1,[R1, #+164]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??mbedtls_ssl_own_cert_0
   \       0x10   0x6B81             LDR      R1,[R0, #+56]
   \       0x12   0xF8D1 0x10A4      LDR      R1,[R1, #+164]
   \       0x16   0xE001             B.N      ??mbedtls_ssl_own_cert_1
   \                     ??mbedtls_ssl_own_cert_0: (+1)
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x6B89             LDR      R1,[R1, #+56]
   \                     ??mbedtls_ssl_own_cert_1: (+1)
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD101             BNE.N    ??mbedtls_ssl_own_cert_2
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xE000             B.N      ??mbedtls_ssl_own_cert_3
   \                     ??mbedtls_ssl_own_cert_2: (+1)
   \       0x24   0x6808             LDR      R0,[R1, #+0]
   \                     ??mbedtls_ssl_own_cert_3: (+1)
   \       0x26   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_ssl_hs_hdr_len(mbedtls_ssl_context const *)
   \                     mbedtls_ssl_hs_hdr_len: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x2004             MOVS     R0,#+4
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void const *mbedtls_ssl_get_sig_algs(mbedtls_ssl_context const *)
   \                     mbedtls_ssl_get_sig_algs: (+1)
   \        0x0   0x6B81             LDR      R1,[R0, #+56]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD00A             BEQ.N    ??mbedtls_ssl_get_sig_algs_0
   \        0x6   0x6B81             LDR      R1,[R0, #+56]
   \        0x8   0x7949             LDRB     R1,[R1, #+5]
   \        0xA   0x2901             CMP      R1,#+1
   \        0xC   0xD106             BNE.N    ??mbedtls_ssl_get_sig_algs_0
   \        0xE   0x6B81             LDR      R1,[R0, #+56]
   \       0x10   0x6C89             LDR      R1,[R1, #+72]
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD002             BEQ.N    ??mbedtls_ssl_get_sig_algs_0
   \       0x16   0x6B80             LDR      R0,[R0, #+56]
   \       0x18   0x6C80             LDR      R0,[R0, #+72]
   \       0x1A   0xE001             B.N      ??mbedtls_ssl_get_sig_algs_1
   \                     ??mbedtls_ssl_get_sig_algs_0: (+1)
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0x6C80             LDR      R0,[R0, #+72]
   \                     ??mbedtls_ssl_get_sig_algs_1: (+1)
   \       0x20   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_sig_alg_is_offered(mbedtls_ssl_context const *, uint16_t)
   \                     mbedtls_ssl_sig_alg_is_offered: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       mbedtls_ssl_get_sig_algs
   \        0xC   0x0001             MOVS     R1,R0
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD101             BNE.N    ??mbedtls_ssl_sig_alg_is_offered_0
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE00C             B.N      ??mbedtls_ssl_sig_alg_is_offered_1
   \                     ??mbedtls_ssl_sig_alg_is_offered_0: (+1)
   \       0x16   0x8808             LDRH     R0,[R1, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD008             BEQ.N    ??mbedtls_ssl_sig_alg_is_offered_2
   \       0x1C   0x880A             LDRH     R2,[R1, #+0]
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0x4282             CMP      R2,R0
   \       0x24   0xD101             BNE.N    ??mbedtls_ssl_sig_alg_is_offered_3
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE002             B.N      ??mbedtls_ssl_sig_alg_is_offered_1
   \                     ??mbedtls_ssl_sig_alg_is_offered_3: (+1)
   \       0x2A   0x1C89             ADDS     R1,R1,#+2
   \       0x2C   0xE7F3             B.N      ??mbedtls_ssl_sig_alg_is_offered_0
   \                     ??mbedtls_ssl_sig_alg_is_offered_2: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_sig_alg_is_offered_1: (+1)
   \       0x30   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(uint16_t, mbedtls_pk_type_t *, mbedtls_md_type_t *)
   \                     mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x.... 0x....      BL       mbedtls_ssl_pk_alg_from_sig
   \       0x10   0x7020             STRB     R0,[R4, #+0]
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x0A00             LSRS     R0,R0,#+8
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x.... 0x....      BL       mbedtls_ssl_md_alg_from_hash
   \       0x1E   0x7028             STRB     R0,[R5, #+0]
   \       0x20   0x7820             LDRB     R0,[R4, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD004             BEQ.N    ??mbedtls_ssl_get_pk_type_and_md_alg_from_sig_a_0
   \       0x26   0x7828             LDRB     R0,[R5, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD001             BEQ.N    ??mbedtls_ssl_get_pk_type_and_md_alg_from_sig_a_0
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xE001             B.N      ??mbedtls_ssl_get_pk_type_and_md_alg_from_sig_a_1
   \                     ??mbedtls_ssl_get_pk_type_and_md_alg_from_sig_a_0: (+1)
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable12
   \                     ??mbedtls_ssl_get_pk_type_and_md_alg_from_sig_a_1: (+1)
   \       0x34   0xBD70             POP      {R4-R6,PC}

      return 0;
      ^
"D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_misc.h",2433  Warning[Pe111]: 
          statement is unreachable

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_tls12_sig_alg_is_supported(uint16_t const)
   \                     mbedtls_ssl_tls12_sig_alg_is_supported: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x000A             MOVS     R2,R1
   \        0x4   0xB292             UXTH     R2,R2
   \        0x6   0x0A12             LSRS     R2,R2,#+8
   \        0x8   0x000B             MOVS     R3,R1
   \        0xA   0x0010             MOVS     R0,R2
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD004             BEQ.N    ??mbedtls_ssl_tls12_sig_alg_is_supported_0
   \       0x12   0xD306             BCC.N    ??mbedtls_ssl_tls12_sig_alg_is_supported_1
   \       0x14   0x2804             CMP      R0,#+4
   \       0x16   0xD003             BEQ.N    ??mbedtls_ssl_tls12_sig_alg_is_supported_2
   \       0x18   0xD301             BCC.N    ??mbedtls_ssl_tls12_sig_alg_is_supported_3
   \       0x1A   0xE002             B.N      ??mbedtls_ssl_tls12_sig_alg_is_supported_1
   \                     ??mbedtls_ssl_tls12_sig_alg_is_supported_0: (+1)
   \       0x1C   0xE003             B.N      ??mbedtls_ssl_tls12_sig_alg_is_supported_4
   \                     ??mbedtls_ssl_tls12_sig_alg_is_supported_3: (+1)
   \       0x1E   0xE002             B.N      ??mbedtls_ssl_tls12_sig_alg_is_supported_4
   \                     ??mbedtls_ssl_tls12_sig_alg_is_supported_2: (+1)
   \       0x20   0xE001             B.N      ??mbedtls_ssl_tls12_sig_alg_is_supported_4
   \                     ??mbedtls_ssl_tls12_sig_alg_is_supported_1: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xE006             B.N      ??mbedtls_ssl_tls12_sig_alg_is_supported_5
   \                     ??mbedtls_ssl_tls12_sig_alg_is_supported_4: (+1)
   \       0x26   0x0018             MOVS     R0,R3
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x2803             CMP      R0,#+3
   \       0x2C   0xD101             BNE.N    ??mbedtls_ssl_tls12_sig_alg_is_supported_6
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xE000             B.N      ??mbedtls_ssl_tls12_sig_alg_is_supported_5
   \                     ??mbedtls_ssl_tls12_sig_alg_is_supported_6: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_tls12_sig_alg_is_supported_5: (+1)
   \       0x34   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_sig_alg_is_supported(mbedtls_ssl_context const *, uint16_t const)
   \                     mbedtls_ssl_sig_alg_is_supported: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0xF9B4 0x1008      LDRSH    R1,[R4, #+8]
   \        0xA   0xF240 0x3003      MOVW     R0,#+771
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xD104             BNE.N    ??mbedtls_ssl_sig_alg_is_supported_0
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x.... 0x....      BL       mbedtls_ssl_tls12_sig_alg_is_supported
   \       0x1A   0xE000             B.N      ??mbedtls_ssl_sig_alg_is_supported_1
   \                     ??mbedtls_ssl_sig_alg_is_supported_0: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_sig_alg_is_supported_1: (+1)
   \       0x1E   0xBD32             POP      {R1,R4,R5,PC}
     28          #include "ssl_misc.h"
     29          #include "mbedtls/debug.h"
     30          #include "mbedtls/error.h"
     31          #include "mbedtls/constant_time.h"
     32          
     33          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     34          #include "psa_util_internal.h"
     35          #include "psa/crypto.h"
     36          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
     37          /* Define a local translating function to save code size by not using too many
     38           * arguments in each translating place. */
     39          static int local_err_translation(psa_status_t status)
     40          {
     41              return psa_status_to_mbedtls(status, psa_to_ssl_errors,
     42                                           ARRAY_LENGTH(psa_to_ssl_errors),
     43                                           psa_generic_status_to_mbedtls);
     44          }
     45          #define PSA_TO_MBEDTLS_ERR(status) local_err_translation(status)
     46          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
     47          #endif /* MBEDTLS_USE_PSA_CRYPTO */
     48          
     49          #include <string.h>
     50          
     51          #include <stdint.h>
     52          
     53          #if defined(MBEDTLS_HAVE_TIME)
     54          #include "mbedtls/platform_time.h"
     55          #endif
     56          
     57          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
     58          #include "mbedtls/platform_util.h"
     59          #endif
     60          
     61          #if defined(MBEDTLS_SSL_RENEGOTIATION)
     62          MBEDTLS_CHECK_RETURN_CRITICAL
     63          static int ssl_write_renegotiation_ext(mbedtls_ssl_context *ssl,
     64                                                 unsigned char *buf,
     65                                                 const unsigned char *end,
     66                                                 size_t *olen)
     67          {
     68              unsigned char *p = buf;
     69          
     70              *olen = 0;
     71          
     72              /* We're always including a TLS_EMPTY_RENEGOTIATION_INFO_SCSV in the
     73               * initial ClientHello, in which case also adding the renegotiation
     74               * info extension is NOT RECOMMENDED as per RFC 5746 Section 3.4. */
     75              if (ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS) {
     76                  return 0;
     77              }
     78          
     79              MBEDTLS_SSL_DEBUG_MSG(3,
     80                                    ("client hello, adding renegotiation extension"));
     81          
     82              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 5 + ssl->verify_data_len);
     83          
     84              /*
     85               * Secure renegotiation
     86               */
     87              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_RENEGOTIATION_INFO, p, 0);
     88              p += 2;
     89          
     90              *p++ = 0x00;
     91              *p++ = MBEDTLS_BYTE_0(ssl->verify_data_len + 1);
     92              *p++ = MBEDTLS_BYTE_0(ssl->verify_data_len);
     93          
     94              memcpy(p, ssl->own_verify_data, ssl->verify_data_len);
     95          
     96              *olen = 5 + ssl->verify_data_len;
     97          
     98              return 0;
     99          }
    100          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    101          
    102          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
    103              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
    104              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    105          
    106          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    107          static int ssl_write_supported_point_formats_ext(mbedtls_ssl_context *ssl,
    108                                                           unsigned char *buf,
    109                                                           const unsigned char *end,
    110                                                           size_t *olen)
    111          {
   \                     ssl_write_supported_point_formats_ext: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    112              unsigned char *p = buf;
   \        0xC   0x46A8             MOV      R8,R5
    113              (void) ssl; /* ssl used for debugging only */
    114          
    115              *olen = 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x6038             STR      R0,[R7, #+0]
    116          
    117              MBEDTLS_SSL_DEBUG_MSG(3,
    118                                    ("client hello, adding supported_point_formats extension"));
    119              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 6);
   \       0x12   0x2206             MOVS     R2,#+6
   \       0x14   0x0031             MOVS     R1,R6
   \       0x16   0x4640             MOV      R0,R8
   \       0x18   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD002             BEQ.N    ??ssl_write_supported_point_formats_ext_0
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \       0x24   0xE022             B.N      ??ssl_write_supported_point_formats_ext_1
    120          
    121              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS, p, 0);
   \                     ??ssl_write_supported_point_formats_ext_0: (+1)
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \       0x2A   0x7800             LDRB     R0,[R0, #+0]
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD104             BNE.N    ??ssl_write_supported_point_formats_ext_2
   \       0x30   0x210B             MOVS     R1,#+11
   \       0x32   0x4640             MOV      R0,R8
   \       0x34   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x38   0xE007             B.N      ??ssl_write_supported_point_formats_ext_3
   \                     ??ssl_write_supported_point_formats_ext_2: (+1)
   \       0x3A   0x200B             MOVS     R0,#+11
   \       0x3C   0x.... 0x....      BL       mbedtls_bswap16
   \       0x40   0x0001             MOVS     R1,R0
   \       0x42   0xB289             UXTH     R1,R1
   \       0x44   0x4640             MOV      R0,R8
   \       0x46   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    122              p += 2;
   \                     ??ssl_write_supported_point_formats_ext_3: (+1)
   \       0x4A   0xF118 0x0102      ADDS     R1,R8,#+2
    123          
    124              *p++ = 0x00;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x7008             STRB     R0,[R1, #+0]
   \       0x52   0x1C49             ADDS     R1,R1,#+1
    125              *p++ = 2;
   \       0x54   0x2002             MOVS     R0,#+2
   \       0x56   0x7008             STRB     R0,[R1, #+0]
   \       0x58   0x1C49             ADDS     R1,R1,#+1
    126          
    127              *p++ = 1;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x7008             STRB     R0,[R1, #+0]
   \       0x5E   0x1C49             ADDS     R1,R1,#+1
    128              *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x7008             STRB     R0,[R1, #+0]
   \       0x64   0x1C49             ADDS     R1,R1,#+1
    129          
    130              *olen = 6;
   \       0x66   0x2006             MOVS     R0,#+6
   \       0x68   0x6038             STR      R0,[R7, #+0]
    131          
    132              return 0;
   \       0x6A   0x2000             MOVS     R0,#+0
   \                     ??ssl_write_supported_point_formats_ext_1: (+1)
   \       0x6C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    133          }
    134          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED ||
    135                    MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED ||
    136                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    137          
    138          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    139          MBEDTLS_CHECK_RETURN_CRITICAL
    140          static int ssl_write_ecjpake_kkpp_ext(mbedtls_ssl_context *ssl,
    141                                                unsigned char *buf,
    142                                                const unsigned char *end,
    143                                                size_t *olen)
    144          {
    145              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    146              unsigned char *p = buf;
    147              size_t kkpp_len = 0;
    148          
    149              *olen = 0;
    150          
    151              /* Skip costly extension if we can't use EC J-PAKE anyway */
    152          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    153              if (ssl->handshake->psa_pake_ctx_is_ok != 1) {
    154                  return 0;
    155              }
    156          #else
    157              if (mbedtls_ecjpake_check(&ssl->handshake->ecjpake_ctx) != 0) {
    158                  return 0;
    159              }
    160          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    161          
    162              MBEDTLS_SSL_DEBUG_MSG(3,
    163                                    ("client hello, adding ecjpake_kkpp extension"));
    164          
    165              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 4);
    166          
    167              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_ECJPAKE_KKPP, p, 0);
    168              p += 2;
    169          
    170              /*
    171               * We may need to send ClientHello multiple times for Hello verification.
    172               * We don't want to compute fresh values every time (both for performance
    173               * and consistency reasons), so cache the extension content.
    174               */
    175              if (ssl->handshake->ecjpake_cache == NULL ||
    176                  ssl->handshake->ecjpake_cache_len == 0) {
    177                  MBEDTLS_SSL_DEBUG_MSG(3, ("generating new ecjpake parameters"));
    178          
    179          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    180                  ret = mbedtls_psa_ecjpake_write_round(&ssl->handshake->psa_pake_ctx,
    181                                                        p + 2, end - p - 2, &kkpp_len,
    182                                                        MBEDTLS_ECJPAKE_ROUND_ONE);
    183                  if (ret != 0) {
    184                      psa_destroy_key(ssl->handshake->psa_pake_password);
    185                      psa_pake_abort(&ssl->handshake->psa_pake_ctx);
    186                      MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_output", ret);
    187                      return ret;
    188                  }
    189          #else
    190                  ret = mbedtls_ecjpake_write_round_one(&ssl->handshake->ecjpake_ctx,
    191                                                        p + 2, end - p - 2, &kkpp_len,
    192                                                        ssl->conf->f_rng, ssl->conf->p_rng);
    193                  if (ret != 0) {
    194                      MBEDTLS_SSL_DEBUG_RET(1,
    195                                            "mbedtls_ecjpake_write_round_one", ret);
    196                      return ret;
    197                  }
    198          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    199          
    200                  ssl->handshake->ecjpake_cache = mbedtls_calloc(1, kkpp_len);
    201                  if (ssl->handshake->ecjpake_cache == NULL) {
    202                      MBEDTLS_SSL_DEBUG_MSG(1, ("allocation failed"));
    203                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
    204                  }
    205          
    206                  memcpy(ssl->handshake->ecjpake_cache, p + 2, kkpp_len);
    207                  ssl->handshake->ecjpake_cache_len = kkpp_len;
    208              } else {
    209                  MBEDTLS_SSL_DEBUG_MSG(3, ("re-using cached ecjpake parameters"));
    210          
    211                  kkpp_len = ssl->handshake->ecjpake_cache_len;
    212                  MBEDTLS_SSL_CHK_BUF_PTR(p + 2, end, kkpp_len);
    213          
    214                  memcpy(p + 2, ssl->handshake->ecjpake_cache, kkpp_len);
    215              }
    216          
    217              MBEDTLS_PUT_UINT16_BE(kkpp_len, p, 0);
    218              p += 2;
    219          
    220              *olen = kkpp_len + 4;
    221          
    222              return 0;
    223          }
    224          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    225          
    226          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
    227          MBEDTLS_CHECK_RETURN_CRITICAL
    228          static int ssl_write_cid_ext(mbedtls_ssl_context *ssl,
    229                                       unsigned char *buf,
    230                                       const unsigned char *end,
    231                                       size_t *olen)
    232          {
    233              unsigned char *p = buf;
    234              size_t ext_len;
    235          
    236              /*
    237               *   struct {
    238               *      opaque cid<0..2^8-1>;
    239               *   } ConnectionId;
    240               */
    241          
    242              *olen = 0;
    243              if (ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM ||
    244                  ssl->negotiate_cid == MBEDTLS_SSL_CID_DISABLED) {
    245                  return 0;
    246              }
    247              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, adding CID extension"));
    248          
    249              /* ssl->own_cid_len is at most MBEDTLS_SSL_CID_IN_LEN_MAX
    250               * which is at most 255, so the increment cannot overflow. */
    251              MBEDTLS_SSL_CHK_BUF_PTR(p, end, (unsigned) (ssl->own_cid_len + 5));
    252          
    253              /* Add extension ID + size */
    254              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_CID, p, 0);
    255              p += 2;
    256              ext_len = (size_t) ssl->own_cid_len + 1;
    257              MBEDTLS_PUT_UINT16_BE(ext_len, p, 0);
    258              p += 2;
    259          
    260              *p++ = (uint8_t) ssl->own_cid_len;
    261              memcpy(p, ssl->own_cid, ssl->own_cid_len);
    262          
    263              *olen = ssl->own_cid_len + 5;
    264          
    265              return 0;
    266          }
    267          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    268          
    269          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    270          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    271          static int ssl_write_max_fragment_length_ext(mbedtls_ssl_context *ssl,
    272                                                       unsigned char *buf,
    273                                                       const unsigned char *end,
    274                                                       size_t *olen)
    275          {
   \                     ssl_write_max_fragment_length_ext: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    276              unsigned char *p = buf;
   \        0xC   0x46A8             MOV      R8,R5
    277          
    278              *olen = 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x6038             STR      R0,[R7, #+0]
    279          
    280              if (ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE) {
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x7A00             LDRB     R0,[R0, #+8]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??ssl_write_max_fragment_length_ext_0
    281                  return 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE02A             B.N      ??ssl_write_max_fragment_length_ext_1
    282              }
    283          
    284              MBEDTLS_SSL_DEBUG_MSG(3,
    285                                    ("client hello, adding max_fragment_length extension"));
    286          
    287              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 5);
   \                     ??ssl_write_max_fragment_length_ext_0: (+1)
   \       0x1E   0x2205             MOVS     R2,#+5
   \       0x20   0x0031             MOVS     R1,R6
   \       0x22   0x4640             MOV      R0,R8
   \       0x24   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??ssl_write_max_fragment_length_ext_2
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \       0x30   0xE020             B.N      ??ssl_write_max_fragment_length_ext_1
    288          
    289              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH, p, 0);
   \                     ??ssl_write_max_fragment_length_ext_2: (+1)
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \       0x36   0x7800             LDRB     R0,[R0, #+0]
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD104             BNE.N    ??ssl_write_max_fragment_length_ext_3
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0x4640             MOV      R0,R8
   \       0x40   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x44   0xE007             B.N      ??ssl_write_max_fragment_length_ext_4
   \                     ??ssl_write_max_fragment_length_ext_3: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0x.... 0x....      BL       mbedtls_bswap16
   \       0x4C   0x0001             MOVS     R1,R0
   \       0x4E   0xB289             UXTH     R1,R1
   \       0x50   0x4640             MOV      R0,R8
   \       0x52   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    290              p += 2;
   \                     ??ssl_write_max_fragment_length_ext_4: (+1)
   \       0x56   0xF118 0x0102      ADDS     R1,R8,#+2
    291          
    292              *p++ = 0x00;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x7008             STRB     R0,[R1, #+0]
   \       0x5E   0x1C49             ADDS     R1,R1,#+1
    293              *p++ = 1;
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x7008             STRB     R0,[R1, #+0]
   \       0x64   0x1C48             ADDS     R0,R1,#+1
    294          
    295              *p++ = ssl->conf->mfl_code;
   \       0x66   0x6821             LDR      R1,[R4, #+0]
   \       0x68   0x7A09             LDRB     R1,[R1, #+8]
   \       0x6A   0x7001             STRB     R1,[R0, #+0]
   \       0x6C   0x1C41             ADDS     R1,R0,#+1
    296          
    297              *olen = 5;
   \       0x6E   0x2005             MOVS     R0,#+5
   \       0x70   0x6038             STR      R0,[R7, #+0]
    298          
    299              return 0;
   \       0x72   0x2000             MOVS     R0,#+0
   \                     ??ssl_write_max_fragment_length_ext_1: (+1)
   \       0x74   0xE8BD 0x81F0      POP      {R4-R8,PC}
    300          }
    301          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
    302          
    303          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    304          MBEDTLS_CHECK_RETURN_CRITICAL
    305          static int ssl_write_encrypt_then_mac_ext(mbedtls_ssl_context *ssl,
    306                                                    unsigned char *buf,
    307                                                    const unsigned char *end,
    308                                                    size_t *olen)
    309          {
    310              unsigned char *p = buf;
    311          
    312              *olen = 0;
    313          
    314              if (ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED) {
    315                  return 0;
    316              }
    317          
    318              MBEDTLS_SSL_DEBUG_MSG(3,
    319                                    ("client hello, adding encrypt_then_mac extension"));
    320          
    321              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 4);
    322          
    323              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC, p, 0);
    324              p += 2;
    325          
    326              *p++ = 0x00;
    327              *p++ = 0x00;
    328          
    329              *olen = 4;
    330          
    331              return 0;
    332          }
    333          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
    334          
    335          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    336          MBEDTLS_CHECK_RETURN_CRITICAL
    337          static int ssl_write_extended_ms_ext(mbedtls_ssl_context *ssl,
    338                                               unsigned char *buf,
    339                                               const unsigned char *end,
    340                                               size_t *olen)
    341          {
    342              unsigned char *p = buf;
    343          
    344              *olen = 0;
    345          
    346              if (ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED) {
    347                  return 0;
    348              }
    349          
    350              MBEDTLS_SSL_DEBUG_MSG(3,
    351                                    ("client hello, adding extended_master_secret extension"));
    352          
    353              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 4);
    354          
    355              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET, p, 0);
    356              p += 2;
    357          
    358              *p++ = 0x00;
    359              *p++ = 0x00;
    360          
    361              *olen = 4;
    362          
    363              return 0;
    364          }
    365          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
    366          
    367          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    368          MBEDTLS_CHECK_RETURN_CRITICAL
    369          static int ssl_write_session_ticket_ext(mbedtls_ssl_context *ssl,
    370                                                  unsigned char *buf,
    371                                                  const unsigned char *end,
    372                                                  size_t *olen)
    373          {
    374              unsigned char *p = buf;
    375              size_t tlen = ssl->session_negotiate->ticket_len;
    376          
    377              *olen = 0;
    378          
    379              if (ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED) {
    380                  return 0;
    381              }
    382          
    383              MBEDTLS_SSL_DEBUG_MSG(3,
    384                                    ("client hello, adding session ticket extension"));
    385          
    386              /* The addition is safe here since the ticket length is 16 bit. */
    387              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 4 + tlen);
    388          
    389              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0);
    390              p += 2;
    391          
    392              MBEDTLS_PUT_UINT16_BE(tlen, p, 0);
    393              p += 2;
    394          
    395              *olen = 4;
    396          
    397              if (ssl->session_negotiate->ticket == NULL || tlen == 0) {
    398                  return 0;
    399              }
    400          
    401              MBEDTLS_SSL_DEBUG_MSG(3,
    402                                    ("sending session ticket of length %" MBEDTLS_PRINTF_SIZET, tlen));
    403          
    404              memcpy(p, ssl->session_negotiate->ticket, tlen);
    405          
    406              *olen += tlen;
    407          
    408              return 0;
    409          }
    410          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
    411          
    412          #if defined(MBEDTLS_SSL_DTLS_SRTP)
    413          MBEDTLS_CHECK_RETURN_CRITICAL
    414          static int ssl_write_use_srtp_ext(mbedtls_ssl_context *ssl,
    415                                            unsigned char *buf,
    416                                            const unsigned char *end,
    417                                            size_t *olen)
    418          {
    419              unsigned char *p = buf;
    420              size_t protection_profiles_index = 0, ext_len = 0;
    421              uint16_t mki_len = 0, profile_value = 0;
    422          
    423              *olen = 0;
    424          
    425              if ((ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) ||
    426                  (ssl->conf->dtls_srtp_profile_list == NULL) ||
    427                  (ssl->conf->dtls_srtp_profile_list_len == 0)) {
    428                  return 0;
    429              }
    430          
    431              /* RFC 5764 section 4.1.1
    432               * uint8 SRTPProtectionProfile[2];
    433               *
    434               * struct {
    435               *   SRTPProtectionProfiles SRTPProtectionProfiles;
    436               *   opaque srtp_mki<0..255>;
    437               * } UseSRTPData;
    438               * SRTPProtectionProfile SRTPProtectionProfiles<2..2^16-1>;
    439               */
    440              if (ssl->conf->dtls_srtp_mki_support == MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED) {
    441                  mki_len = ssl->dtls_srtp_info.mki_len;
    442              }
    443              /* Extension length = 2 bytes for profiles length,
    444               *                    ssl->conf->dtls_srtp_profile_list_len * 2 (each profile is 2 bytes length ),
    445               *                    1 byte for srtp_mki vector length and the mki_len value
    446               */
    447              ext_len = 2 + 2 * (ssl->conf->dtls_srtp_profile_list_len) + 1 + mki_len;
    448          
    449              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, adding use_srtp extension"));
    450          
    451              /* Check there is room in the buffer for the extension + 4 bytes
    452               * - the extension tag (2 bytes)
    453               * - the extension length (2 bytes)
    454               */
    455              MBEDTLS_SSL_CHK_BUF_PTR(p, end, ext_len + 4);
    456          
    457              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_USE_SRTP, p, 0);
    458              p += 2;
    459          
    460              MBEDTLS_PUT_UINT16_BE(ext_len, p, 0);
    461              p += 2;
    462          
    463              /* protection profile length: 2*(ssl->conf->dtls_srtp_profile_list_len) */
    464              /* micro-optimization:
    465               * the list size is limited to MBEDTLS_TLS_SRTP_MAX_PROFILE_LIST_LENGTH
    466               * which is lower than 127, so the upper byte of the length is always 0
    467               * For the documentation, the more generic code is left in comments
    468               * *p++ = (unsigned char)( ( ( 2 * ssl->conf->dtls_srtp_profile_list_len )
    469               *                        >> 8 ) & 0xFF );
    470               */
    471              *p++ = 0;
    472              *p++ = MBEDTLS_BYTE_0(2 * ssl->conf->dtls_srtp_profile_list_len);
    473          
    474              for (protection_profiles_index = 0;
    475                   protection_profiles_index < ssl->conf->dtls_srtp_profile_list_len;
    476                   protection_profiles_index++) {
    477                  profile_value = mbedtls_ssl_check_srtp_profile_value
    478                                      (ssl->conf->dtls_srtp_profile_list[protection_profiles_index]);
    479                  if (profile_value != MBEDTLS_TLS_SRTP_UNSET) {
    480                      MBEDTLS_SSL_DEBUG_MSG(3, ("ssl_write_use_srtp_ext, add profile: %04x",
    481                                                profile_value));
    482                      MBEDTLS_PUT_UINT16_BE(profile_value, p, 0);
    483                      p += 2;
    484                  } else {
    485                      /*
    486                       * Note: we shall never arrive here as protection profiles
    487                       * is checked by mbedtls_ssl_conf_dtls_srtp_protection_profiles function
    488                       */
    489                      MBEDTLS_SSL_DEBUG_MSG(3,
    490                                            ("client hello, "
    491                                             "illegal DTLS-SRTP protection profile %d",
    492                                             ssl->conf->dtls_srtp_profile_list[protection_profiles_index]
    493                                            ));
    494                      return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    495                  }
    496              }
    497          
    498              *p++ = mki_len & 0xFF;
    499          
    500              if (mki_len != 0) {
    501                  memcpy(p, ssl->dtls_srtp_info.mki_value, mki_len);
    502                  /*
    503                   * Increment p to point to the current position.
    504                   */
    505                  p += mki_len;
    506                  MBEDTLS_SSL_DEBUG_BUF(3, "sending mki",  ssl->dtls_srtp_info.mki_value,
    507                                        ssl->dtls_srtp_info.mki_len);
    508              }
    509          
    510              /*
    511               * total extension length: extension type (2 bytes)
    512               *                         + extension length (2 bytes)
    513               *                         + protection profile length (2 bytes)
    514               *                         + 2 * number of protection profiles
    515               *                         + srtp_mki vector length(1 byte)
    516               *                         + mki value
    517               */
    518              *olen = p - buf;
    519          
    520              return 0;
    521          }
    522          #endif /* MBEDTLS_SSL_DTLS_SRTP */
    523          

   \                                 In section .text, align 2, keep-with-next
    524          int mbedtls_ssl_tls12_write_client_hello_exts(mbedtls_ssl_context *ssl,
    525                                                        unsigned char *buf,
    526                                                        const unsigned char *end,
    527                                                        int uses_ec,
    528                                                        size_t *out_len)
    529          {
   \                     mbedtls_ssl_tls12_write_client_hello_exts: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9F0A             LDR      R7,[SP, #+40]
    530              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x086D      MVNS     R8,#+109
    531              unsigned char *p = buf;
   \       0x12   0x46A9             MOV      R9,R5
    532              size_t ext_len = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9000             STR      R0,[SP, #+0]
    533          
    534              (void) ssl;
    535              (void) end;
    536              (void) uses_ec;
    537              (void) ret;
    538              (void) ext_len;
    539          
    540              *out_len = 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6038             STR      R0,[R7, #+0]
    541          
    542              /* Note that TLS_EMPTY_RENEGOTIATION_INFO_SCSV is always added
    543               * even if MBEDTLS_SSL_RENEGOTIATION is not defined. */
    544          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    545              if ((ret = ssl_write_renegotiation_ext(ssl, p, end, &ext_len)) != 0) {
    546                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_renegotiation_ext", ret);
    547                  return ret;
    548              }
    549              p += ext_len;
    550          #endif
    551          
    552          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
    553              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
    554              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    555              if (uses_ec) {
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD00C             BEQ.N    ??mbedtls_ssl_tls12_write_client_hello_exts_0
    556                  if ((ret = ssl_write_supported_point_formats_ext(ssl, p, end,
    557                                                                   &ext_len)) != 0) {
   \       0x20   0x466B             MOV      R3,SP
   \       0x22   0x0032             MOVS     R2,R6
   \       0x24   0x4649             MOV      R1,R9
   \       0x26   0x4650             MOV      R0,R10
   \       0x28   0x.... 0x....      BL       ssl_write_supported_point_formats_ext
   \       0x2C   0x4680             MOV      R8,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD001             BEQ.N    ??mbedtls_ssl_tls12_write_client_hello_exts_1
    558                      MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_supported_point_formats_ext", ret);
    559                      return ret;
   \       0x32   0x4640             MOV      R0,R8
   \       0x34   0xE012             B.N      ??mbedtls_ssl_tls12_write_client_hello_exts_2
    560                  }
    561                  p += ext_len;
   \                     ??mbedtls_ssl_tls12_write_client_hello_exts_1: (+1)
   \       0x36   0x9800             LDR      R0,[SP, #+0]
   \       0x38   0x4481             ADD      R9,R9,R0
    562              }
    563          #endif
    564          
    565          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    566              if ((ret = ssl_write_ecjpake_kkpp_ext(ssl, p, end, &ext_len)) != 0) {
    567                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_ecjpake_kkpp_ext", ret);
    568                  return ret;
    569              }
    570              p += ext_len;
    571          #endif
    572          
    573          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
    574              if ((ret = ssl_write_cid_ext(ssl, p, end, &ext_len)) != 0) {
    575                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_cid_ext", ret);
    576                  return ret;
    577              }
    578              p += ext_len;
    579          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    580          
    581          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    582              if ((ret = ssl_write_max_fragment_length_ext(ssl, p, end,
    583                                                           &ext_len)) != 0) {
   \                     ??mbedtls_ssl_tls12_write_client_hello_exts_0: (+1)
   \       0x3A   0x466B             MOV      R3,SP
   \       0x3C   0x0032             MOVS     R2,R6
   \       0x3E   0x4649             MOV      R1,R9
   \       0x40   0x4650             MOV      R0,R10
   \       0x42   0x.... 0x....      BL       ssl_write_max_fragment_length_ext
   \       0x46   0x0001             MOVS     R1,R0
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD001             BEQ.N    ??mbedtls_ssl_tls12_write_client_hello_exts_3
    584                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_max_fragment_length_ext", ret);
    585                  return ret;
   \       0x4C   0x0008             MOVS     R0,R1
   \       0x4E   0xE005             B.N      ??mbedtls_ssl_tls12_write_client_hello_exts_2
    586              }
    587              p += ext_len;
   \                     ??mbedtls_ssl_tls12_write_client_hello_exts_3: (+1)
   \       0x50   0x9800             LDR      R0,[SP, #+0]
   \       0x52   0xEB09 0x0200      ADD      R2,R9,R0
    588          #endif
    589          
    590          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    591              if ((ret = ssl_write_encrypt_then_mac_ext(ssl, p, end, &ext_len)) != 0) {
    592                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_encrypt_then_mac_ext", ret);
    593                  return ret;
    594              }
    595              p += ext_len;
    596          #endif
    597          
    598          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    599              if ((ret = ssl_write_extended_ms_ext(ssl, p, end, &ext_len)) != 0) {
    600                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_extended_ms_ext", ret);
    601                  return ret;
    602              }
    603              p += ext_len;
    604          #endif
    605          
    606          #if defined(MBEDTLS_SSL_DTLS_SRTP)
    607              if ((ret = ssl_write_use_srtp_ext(ssl, p, end, &ext_len)) != 0) {
    608                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_use_srtp_ext", ret);
    609                  return ret;
    610              }
    611              p += ext_len;
    612          #endif
    613          
    614          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    615              if ((ret = ssl_write_session_ticket_ext(ssl, p, end, &ext_len)) != 0) {
    616                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_session_ticket_ext", ret);
    617                  return ret;
    618              }
    619              p += ext_len;
    620          #endif
    621          
    622              *out_len = p - buf;
   \       0x56   0x1B50             SUBS     R0,R2,R5
   \       0x58   0x6038             STR      R0,[R7, #+0]
    623          
    624              return 0;
   \       0x5A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_tls12_write_client_hello_exts_2: (+1)
   \       0x5C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    625          }
    626          
    627          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    628          static int ssl_parse_renegotiation_info(mbedtls_ssl_context *ssl,
    629                                                  const unsigned char *buf,
    630                                                  size_t len)
    631          {
   \                     ssl_parse_renegotiation_info: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    632          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    633              if (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE) {
    634                  /* Check verify-data in constant-time. The length OTOH is no secret */
    635                  if (len    != 1 + ssl->verify_data_len * 2 ||
    636                      buf[0] !=     ssl->verify_data_len * 2 ||
    637                      mbedtls_ct_memcmp(buf + 1,
    638                                        ssl->own_verify_data, ssl->verify_data_len) != 0 ||
    639                      mbedtls_ct_memcmp(buf + 1 + ssl->verify_data_len,
    640                                        ssl->peer_verify_data, ssl->verify_data_len) != 0) {
    641                      MBEDTLS_SSL_DEBUG_MSG(1, ("non-matching renegotiation info"));
    642                      mbedtls_ssl_send_alert_message(
    643                          ssl,
    644                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    645                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    646                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
    647                  }
    648              } else
    649          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    650              {
    651                  if (len != 1 || buf[0] != 0x00) {
   \        0x8   0x2E01             CMP      R6,#+1
   \        0xA   0xD102             BNE.N    ??ssl_parse_renegotiation_info_0
   \        0xC   0x7828             LDRB     R0,[R5, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD007             BEQ.N    ??ssl_parse_renegotiation_info_1
    652                      MBEDTLS_SSL_DEBUG_MSG(1,
    653                                            ("non-zero length renegotiation info"));
    654                      mbedtls_ssl_send_alert_message(
    655                          ssl,
    656                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    657                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   \                     ??ssl_parse_renegotiation_info_0: (+1)
   \       0x12   0x2228             MOVS     R2,#+40
   \       0x14   0x2102             MOVS     R1,#+2
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
    658                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x20   0xE003             B.N      ??ssl_parse_renegotiation_info_2
    659                  }
    660          
    661                  ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
   \                     ??ssl_parse_renegotiation_info_1: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xF8C4 0x00C4      STR      R0,[R4, #+196]
    662              }
    663          
    664              return 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??ssl_parse_renegotiation_info_2: (+1)
   \       0x2A   0xBD70             POP      {R4-R6,PC}
    665          }
    666          
    667          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    668          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    669          static int ssl_parse_max_fragment_length_ext(mbedtls_ssl_context *ssl,
    670                                                       const unsigned char *buf,
    671                                                       size_t len)
    672          {
   \                     ssl_parse_max_fragment_length_ext: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    673              /*
    674               * server should use the extension only if we did,
    675               * and if so the server's value should match ours (and len is always 1)
    676               */
    677              if (ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE ||
    678                  len != 1 ||
    679                  buf[0] != ssl->conf->mfl_code) {
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x7A00             LDRB     R0,[R0, #+8]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD006             BEQ.N    ??ssl_parse_max_fragment_length_ext_0
   \       0x10   0x2E01             CMP      R6,#+1
   \       0x12   0xD104             BNE.N    ??ssl_parse_max_fragment_length_ext_0
   \       0x14   0x7828             LDRB     R0,[R5, #+0]
   \       0x16   0x6821             LDR      R1,[R4, #+0]
   \       0x18   0x7A09             LDRB     R1,[R1, #+8]
   \       0x1A   0x4288             CMP      R0,R1
   \       0x1C   0xD007             BEQ.N    ??ssl_parse_max_fragment_length_ext_1
    680                  MBEDTLS_SSL_DEBUG_MSG(1,
    681                                        ("non-matching max fragment length extension"));
    682                  mbedtls_ssl_send_alert_message(
    683                      ssl,
    684                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    685                      MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   \                     ??ssl_parse_max_fragment_length_ext_0: (+1)
   \       0x1E   0x222F             MOVS     R2,#+47
   \       0x20   0x2102             MOVS     R1,#+2
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
    686                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x2C   0xE000             B.N      ??ssl_parse_max_fragment_length_ext_2
    687              }
    688          
    689              return 0;
   \                     ??ssl_parse_max_fragment_length_ext_1: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??ssl_parse_max_fragment_length_ext_2: (+1)
   \       0x30   0xBD70             POP      {R4-R6,PC}
    690          }
    691          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
    692          
    693          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
    694          MBEDTLS_CHECK_RETURN_CRITICAL
    695          static int ssl_parse_cid_ext(mbedtls_ssl_context *ssl,
    696                                       const unsigned char *buf,
    697                                       size_t len)
    698          {
    699              size_t peer_cid_len;
    700          
    701              if ( /* CID extension only makes sense in DTLS */
    702                  ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM ||
    703                  /* The server must only send the CID extension if we have offered it. */
    704                  ssl->negotiate_cid == MBEDTLS_SSL_CID_DISABLED) {
    705                  MBEDTLS_SSL_DEBUG_MSG(1, ("CID extension unexpected"));
    706                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    707                                                 MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    708                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    709              }
    710          
    711              if (len == 0) {
    712                  MBEDTLS_SSL_DEBUG_MSG(1, ("CID extension invalid"));
    713                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    714                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    715                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    716              }
    717          
    718              peer_cid_len = *buf++;
    719              len--;
    720          
    721              if (peer_cid_len > MBEDTLS_SSL_CID_OUT_LEN_MAX) {
    722                  MBEDTLS_SSL_DEBUG_MSG(1, ("CID extension invalid"));
    723                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    724                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
    725                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
    726              }
    727          
    728              if (len != peer_cid_len) {
    729                  MBEDTLS_SSL_DEBUG_MSG(1, ("CID extension invalid"));
    730                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    731                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    732                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    733              }
    734          
    735              ssl->handshake->cid_in_use = MBEDTLS_SSL_CID_ENABLED;
    736              ssl->handshake->peer_cid_len = (uint8_t) peer_cid_len;
    737              memcpy(ssl->handshake->peer_cid, buf, peer_cid_len);
    738          
    739              MBEDTLS_SSL_DEBUG_MSG(3, ("Use of CID extension negotiated"));
    740              MBEDTLS_SSL_DEBUG_BUF(3, "Server CID", buf, peer_cid_len);
    741          
    742              return 0;
    743          }
    744          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    745          
    746          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    747          MBEDTLS_CHECK_RETURN_CRITICAL
    748          static int ssl_parse_encrypt_then_mac_ext(mbedtls_ssl_context *ssl,
    749                                                    const unsigned char *buf,
    750                                                    size_t len)
    751          {
    752              if (ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED ||
    753                  len != 0) {
    754                  MBEDTLS_SSL_DEBUG_MSG(1,
    755                                        ("non-matching encrypt-then-MAC extension"));
    756                  mbedtls_ssl_send_alert_message(
    757                      ssl,
    758                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    759                      MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    760                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    761              }
    762          
    763              ((void) buf);
    764          
    765              ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
    766          
    767              return 0;
    768          }
    769          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
    770          
    771          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    772          MBEDTLS_CHECK_RETURN_CRITICAL
    773          static int ssl_parse_extended_ms_ext(mbedtls_ssl_context *ssl,
    774                                               const unsigned char *buf,
    775                                               size_t len)
    776          {
    777              if (ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
    778                  len != 0) {
    779                  MBEDTLS_SSL_DEBUG_MSG(1,
    780                                        ("non-matching extended master secret extension"));
    781                  mbedtls_ssl_send_alert_message(
    782                      ssl,
    783                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    784                      MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    785                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    786              }
    787          
    788              ((void) buf);
    789          
    790              ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
    791          
    792              return 0;
    793          }
    794          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
    795          
    796          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    797          MBEDTLS_CHECK_RETURN_CRITICAL
    798          static int ssl_parse_session_ticket_ext(mbedtls_ssl_context *ssl,
    799                                                  const unsigned char *buf,
    800                                                  size_t len)
    801          {
    802              if (ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED ||
    803                  len != 0) {
    804                  MBEDTLS_SSL_DEBUG_MSG(1,
    805                                        ("non-matching session ticket extension"));
    806                  mbedtls_ssl_send_alert_message(
    807                      ssl,
    808                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    809                      MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    810                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    811              }
    812          
    813              ((void) buf);
    814          
    815              ssl->handshake->new_session_ticket = 1;
    816          
    817              return 0;
    818          }
    819          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
    820          
    821          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
    822              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
    823              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    824          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    825          static int ssl_parse_supported_point_formats_ext(mbedtls_ssl_context *ssl,
    826                                                           const unsigned char *buf,
    827                                                           size_t len)
    828          {
   \                     ssl_parse_supported_point_formats_ext: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0015             MOVS     R5,R2
    829              size_t list_size;
    830              const unsigned char *p;
    831          
    832              if (len == 0 || (size_t) (buf[0] + 1) != len) {
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD003             BEQ.N    ??ssl_parse_supported_point_formats_ext_0
   \        0xE   0x7838             LDRB     R0,[R7, #+0]
   \       0x10   0x1C40             ADDS     R0,R0,#+1
   \       0x12   0x42A8             CMP      R0,R5
   \       0x14   0xD007             BEQ.N    ??ssl_parse_supported_point_formats_ext_1
    833                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
    834                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    835                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \                     ??ssl_parse_supported_point_formats_ext_0: (+1)
   \       0x16   0x2232             MOVS     R2,#+50
   \       0x18   0x2102             MOVS     R1,#+2
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
    836                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x24   0xE019             B.N      ??ssl_parse_supported_point_formats_ext_2
    837              }
    838              list_size = buf[0];
   \                     ??ssl_parse_supported_point_formats_ext_1: (+1)
   \       0x26   0x783C             LDRB     R4,[R7, #+0]
    839          
    840              p = buf + 1;
   \       0x28   0xF117 0x0801      ADDS     R8,R7,#+1
    841              while (list_size > 0) {
   \                     ??ssl_parse_supported_point_formats_ext_3: (+1)
   \       0x2C   0x2C00             CMP      R4,#+0
   \       0x2E   0xD00D             BEQ.N    ??ssl_parse_supported_point_formats_ext_4
    842                  if (p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||
    843                      p[0] == MBEDTLS_ECP_PF_COMPRESSED) {
   \       0x30   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD003             BEQ.N    ??ssl_parse_supported_point_formats_ext_5
   \       0x38   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xD101             BNE.N    ??ssl_parse_supported_point_formats_ext_6
    844          #if !defined(MBEDTLS_USE_PSA_CRYPTO) && \
    845                      defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED)
    846                      ssl->handshake->ecdh_ctx.point_format = p[0];
    847          #endif /* !MBEDTLS_USE_PSA_CRYPTO && MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED */
    848          #if !defined(MBEDTLS_USE_PSA_CRYPTO) &&                             \
    849                      defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    850                      mbedtls_ecjpake_set_point_format(&ssl->handshake->ecjpake_ctx,
    851                                                       p[0]);
    852          #endif /* !MBEDTLS_USE_PSA_CRYPTO && MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    853                      MBEDTLS_SSL_DEBUG_MSG(4, ("point format selected: %d", p[0]));
    854                      return 0;
   \                     ??ssl_parse_supported_point_formats_ext_5: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xE00A             B.N      ??ssl_parse_supported_point_formats_ext_2
    855                  }
    856          
    857                  list_size--;
   \                     ??ssl_parse_supported_point_formats_ext_6: (+1)
   \       0x44   0x1E64             SUBS     R4,R4,#+1
    858                  p++;
   \       0x46   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x4A   0xE7EF             B.N      ??ssl_parse_supported_point_formats_ext_3
    859              }
    860          
    861              MBEDTLS_SSL_DEBUG_MSG(1, ("no point format in common"));
    862              mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    863                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   \                     ??ssl_parse_supported_point_formats_ext_4: (+1)
   \       0x4C   0x2228             MOVS     R2,#+40
   \       0x4E   0x2102             MOVS     R1,#+2
   \       0x50   0x0030             MOVS     R0,R6
   \       0x52   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
    864              return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable13
   \                     ??ssl_parse_supported_point_formats_ext_2: (+1)
   \       0x5A   0xE8BD 0x81F0      POP      {R4-R8,PC}
    865          }
    866          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED ||
    867                    MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED ||
    868                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    869          
    870          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    871          MBEDTLS_CHECK_RETURN_CRITICAL
    872          static int ssl_parse_ecjpake_kkpp(mbedtls_ssl_context *ssl,
    873                                            const unsigned char *buf,
    874                                            size_t len)
    875          {
    876              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    877          
    878              if (ssl->handshake->ciphersuite_info->key_exchange !=
    879                  MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
    880                  MBEDTLS_SSL_DEBUG_MSG(3, ("skip ecjpake kkpp extension"));
    881                  return 0;
    882              }
    883          
    884              /* If we got here, we no longer need our cached extension */
    885              mbedtls_free(ssl->handshake->ecjpake_cache);
    886              ssl->handshake->ecjpake_cache = NULL;
    887              ssl->handshake->ecjpake_cache_len = 0;
    888          
    889          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    890              if ((ret = mbedtls_psa_ecjpake_read_round(
    891                       &ssl->handshake->psa_pake_ctx, buf, len,
    892                       MBEDTLS_ECJPAKE_ROUND_ONE)) != 0) {
    893                  psa_destroy_key(ssl->handshake->psa_pake_password);
    894                  psa_pake_abort(&ssl->handshake->psa_pake_ctx);
    895          
    896                  MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_input round one", ret);
    897                  mbedtls_ssl_send_alert_message(
    898                      ssl,
    899                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    900                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    901                  return ret;
    902              }
    903          
    904              return 0;
    905          #else
    906              if ((ret = mbedtls_ecjpake_read_round_one(&ssl->handshake->ecjpake_ctx,
    907                                                        buf, len)) != 0) {
    908                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_read_round_one", ret);
    909                  mbedtls_ssl_send_alert_message(
    910                      ssl,
    911                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    912                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    913                  return ret;
    914              }
    915          
    916              return 0;
    917          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    918          }
    919          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    920          
    921          #if defined(MBEDTLS_SSL_ALPN)
    922          MBEDTLS_CHECK_RETURN_CRITICAL
    923          static int ssl_parse_alpn_ext(mbedtls_ssl_context *ssl,
    924                                        const unsigned char *buf, size_t len)
    925          {
    926              size_t list_len, name_len;
    927              const char **p;
    928          
    929              /* If we didn't send it, the server shouldn't send it */
    930              if (ssl->conf->alpn_list == NULL) {
    931                  MBEDTLS_SSL_DEBUG_MSG(1, ("non-matching ALPN extension"));
    932                  mbedtls_ssl_send_alert_message(
    933                      ssl,
    934                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    935                      MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    936                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    937              }
    938          
    939              /*
    940               * opaque ProtocolName<1..2^8-1>;
    941               *
    942               * struct {
    943               *     ProtocolName protocol_name_list<2..2^16-1>
    944               * } ProtocolNameList;
    945               *
    946               * the "ProtocolNameList" MUST contain exactly one "ProtocolName"
    947               */
    948          
    949              /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */
    950              if (len < 4) {
    951                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    952                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    953                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    954              }
    955          
    956              list_len = (buf[0] << 8) | buf[1];
    957              if (list_len != len - 2) {
    958                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    959                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    960                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    961              }
    962          
    963              name_len = buf[2];
    964              if (name_len != list_len - 1) {
    965                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    966                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    967                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    968              }
    969          
    970              /* Check that the server chosen protocol was in our list and save it */
    971              for (p = ssl->conf->alpn_list; *p != NULL; p++) {
    972                  if (name_len == strlen(*p) &&
    973                      memcmp(buf + 3, *p, name_len) == 0) {
    974                      ssl->alpn_chosen = *p;
    975                      return 0;
    976                  }
    977              }
    978          
    979              MBEDTLS_SSL_DEBUG_MSG(1, ("ALPN extension: no matching protocol"));
    980              mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    981                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    982              return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
    983          }
    984          #endif /* MBEDTLS_SSL_ALPN */
    985          
    986          #if defined(MBEDTLS_SSL_DTLS_SRTP)
    987          MBEDTLS_CHECK_RETURN_CRITICAL
    988          static int ssl_parse_use_srtp_ext(mbedtls_ssl_context *ssl,
    989                                            const unsigned char *buf,
    990                                            size_t len)
    991          {
    992              mbedtls_ssl_srtp_profile server_protection = MBEDTLS_TLS_SRTP_UNSET;
    993              size_t i, mki_len = 0;
    994              uint16_t server_protection_profile_value = 0;
    995          
    996              /* If use_srtp is not configured, just ignore the extension */
    997              if ((ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) ||
    998                  (ssl->conf->dtls_srtp_profile_list == NULL) ||
    999                  (ssl->conf->dtls_srtp_profile_list_len == 0)) {
   1000                  return 0;
   1001              }
   1002          
   1003              /* RFC 5764 section 4.1.1
   1004               * uint8 SRTPProtectionProfile[2];
   1005               *
   1006               * struct {
   1007               *   SRTPProtectionProfiles SRTPProtectionProfiles;
   1008               *   opaque srtp_mki<0..255>;
   1009               * } UseSRTPData;
   1010          
   1011               * SRTPProtectionProfile SRTPProtectionProfiles<2..2^16-1>;
   1012               *
   1013               */
   1014              if (ssl->conf->dtls_srtp_mki_support == MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED) {
   1015                  mki_len = ssl->dtls_srtp_info.mki_len;
   1016              }
   1017          
   1018              /*
   1019               * Length is 5 + optional mki_value : one protection profile length (2 bytes)
   1020               *                                      + protection profile (2 bytes)
   1021               *                                      + mki_len(1 byte)
   1022               *                                      and optional srtp_mki
   1023               */
   1024              if ((len < 5) || (len != (buf[4] + 5u))) {
   1025                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1026              }
   1027          
   1028              /*
   1029               * get the server protection profile
   1030               */
   1031          
   1032              /*
   1033               * protection profile length must be 0x0002 as we must have only
   1034               * one protection profile in server Hello
   1035               */
   1036              if ((buf[0] != 0) || (buf[1] != 2)) {
   1037                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1038              }
   1039          
   1040              server_protection_profile_value = (buf[2] << 8) | buf[3];
   1041              server_protection = mbedtls_ssl_check_srtp_profile_value(
   1042                  server_protection_profile_value);
   1043              if (server_protection != MBEDTLS_TLS_SRTP_UNSET) {
   1044                  MBEDTLS_SSL_DEBUG_MSG(3, ("found srtp profile: %s",
   1045                                            mbedtls_ssl_get_srtp_profile_as_string(
   1046                                                server_protection)));
   1047              }
   1048          
   1049              ssl->dtls_srtp_info.chosen_dtls_srtp_profile = MBEDTLS_TLS_SRTP_UNSET;
   1050          
   1051              /*
   1052               * Check we have the server profile in our list
   1053               */
   1054              for (i = 0; i < ssl->conf->dtls_srtp_profile_list_len; i++) {
   1055                  if (server_protection == ssl->conf->dtls_srtp_profile_list[i]) {
   1056                      ssl->dtls_srtp_info.chosen_dtls_srtp_profile = ssl->conf->dtls_srtp_profile_list[i];
   1057                      MBEDTLS_SSL_DEBUG_MSG(3, ("selected srtp profile: %s",
   1058                                                mbedtls_ssl_get_srtp_profile_as_string(
   1059                                                    server_protection)));
   1060                      break;
   1061                  }
   1062              }
   1063          
   1064              /* If no match was found : server problem, it shall never answer with incompatible profile */
   1065              if (ssl->dtls_srtp_info.chosen_dtls_srtp_profile == MBEDTLS_TLS_SRTP_UNSET) {
   1066                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1067                                                 MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   1068                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1069              }
   1070          
   1071              /* If server does not use mki in its reply, make sure the client won't keep
   1072               * one as negotiated */
   1073              if (len == 5) {
   1074                  ssl->dtls_srtp_info.mki_len = 0;
   1075              }
   1076          
   1077              /*
   1078               * RFC5764:
   1079               *  If the client detects a nonzero-length MKI in the server's response
   1080               *  that is different than the one the client offered, then the client
   1081               *  MUST abort the handshake and SHOULD send an invalid_parameter alert.
   1082               */
   1083              if (len > 5  && (buf[4] != mki_len ||
   1084                               (memcmp(ssl->dtls_srtp_info.mki_value, &buf[5], mki_len)))) {
   1085                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1086                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   1087                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   1088              }
   1089          #if defined(MBEDTLS_DEBUG_C)
   1090              if (len > 5) {
   1091                  MBEDTLS_SSL_DEBUG_BUF(3, "received mki", ssl->dtls_srtp_info.mki_value,
   1092                                        ssl->dtls_srtp_info.mki_len);
   1093              }
   1094          #endif
   1095              return 0;
   1096          }
   1097          #endif /* MBEDTLS_SSL_DTLS_SRTP */
   1098          
   1099          /*
   1100           * Parse HelloVerifyRequest.  Only called after verifying the HS type.
   1101           */
   1102          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1103          MBEDTLS_CHECK_RETURN_CRITICAL
   1104          static int ssl_parse_hello_verify_request(mbedtls_ssl_context *ssl)
   1105          {
   1106              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1107              const unsigned char *p = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
   1108              uint16_t dtls_legacy_version;
   1109          
   1110          #if !defined(MBEDTLS_SSL_PROTO_TLS1_3)
   1111              uint8_t cookie_len;
   1112          #else
   1113              uint16_t cookie_len;
   1114          #endif
   1115          
   1116              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse hello verify request"));
   1117          
   1118              /* Check that there is enough room for:
   1119               * - 2 bytes of version
   1120               * - 1 byte of cookie_len
   1121               */
   1122              if (mbedtls_ssl_hs_hdr_len(ssl) + 3 > ssl->in_msglen) {
   1123                  MBEDTLS_SSL_DEBUG_MSG(1,
   1124                                        ("incoming HelloVerifyRequest message is too short"));
   1125                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1126                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1127                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1128              }
   1129          
   1130              /*
   1131               * struct {
   1132               *   ProtocolVersion server_version;
   1133               *   opaque cookie<0..2^8-1>;
   1134               * } HelloVerifyRequest;
   1135               */
   1136              MBEDTLS_SSL_DEBUG_BUF(3, "server version", p, 2);
   1137              dtls_legacy_version = MBEDTLS_GET_UINT16_BE(p, 0);
   1138              p += 2;
   1139          
   1140              /*
   1141               * Since the RFC is not clear on this point, accept DTLS 1.0 (0xfeff)
   1142               * The DTLS 1.3 (current draft) renames ProtocolVersion server_version to
   1143               * legacy_version and locks the value of legacy_version to 0xfefd (DTLS 1.2)
   1144               */
   1145              if (dtls_legacy_version != 0xfefd && dtls_legacy_version != 0xfeff) {
   1146                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server version"));
   1147          
   1148                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1149                                                 MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION);
   1150          
   1151                  return MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION;
   1152              }
   1153          
   1154              cookie_len = *p++;
   1155              if ((ssl->in_msg + ssl->in_msglen) - p < cookie_len) {
   1156                  MBEDTLS_SSL_DEBUG_MSG(1,
   1157                                        ("cookie length does not match incoming message size"));
   1158                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1159                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1160                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1161              }
   1162              MBEDTLS_SSL_DEBUG_BUF(3, "cookie", p, cookie_len);
   1163          
   1164              mbedtls_free(ssl->handshake->cookie);
   1165          
   1166              ssl->handshake->cookie = mbedtls_calloc(1, cookie_len);
   1167              if (ssl->handshake->cookie  == NULL) {
   1168                  MBEDTLS_SSL_DEBUG_MSG(1, ("alloc failed (%d bytes)", cookie_len));
   1169                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   1170              }
   1171          
   1172              memcpy(ssl->handshake->cookie, p, cookie_len);
   1173              ssl->handshake->cookie_len = cookie_len;
   1174          
   1175              /* Start over at ClientHello */
   1176              ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
   1177              ret = mbedtls_ssl_reset_checksum(ssl);
   1178              if (0 != ret) {
   1179                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ssl_reset_checksum"), ret);
   1180                  return ret;
   1181              }
   1182          
   1183              mbedtls_ssl_recv_flight_completed(ssl);
   1184          
   1185              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse hello verify request"));
   1186          
   1187              return 0;
   1188          }
   1189          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1190          
   1191          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   1192          static int ssl_parse_server_hello(mbedtls_ssl_context *ssl)
   1193          {
   \                     ssl_parse_server_hello: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4683             MOV      R11,R0
   1194              int ret, i;
   1195              size_t n;
   1196              size_t ext_len;
   1197              unsigned char *buf, *ext;
   1198              unsigned char comp;
   1199          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1200              int renegotiation_info_seen = 0;
   1201          #endif
   1202              int handshake_failure = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9001             STR      R0,[SP, #+4]
   1203              const mbedtls_ssl_ciphersuite_t *suite_info;
   1204          
   1205              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse server hello"));
   1206          
   1207              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x4658             MOV      R0,R11
   \       0x10   0x.... 0x....      BL       mbedtls_ssl_read_record
   \       0x14   0x0006             MOVS     R6,R0
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??ssl_parse_server_hello_0
   1208                  /* No alert on a read error. */
   1209                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   1210                  return ret;
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0xE1D3             B.N      ??ssl_parse_server_hello_1
   1211              }
   1212          
   1213              buf = ssl->in_msg;
   \                     ??ssl_parse_server_hello_0: (+1)
   \       0x1E   0xF8DB 0x406C      LDR      R4,[R11, #+108]
   1214          
   1215              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   \       0x22   0xF8DB 0x0074      LDR      R0,[R11, #+116]
   \       0x26   0x2816             CMP      R0,#+22
   \       0x28   0xD007             BEQ.N    ??ssl_parse_server_hello_2
   1216          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1217                  if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS) {
   1218                      ssl->renego_records_seen++;
   1219          
   1220                      if (ssl->conf->renego_max_records >= 0 &&
   1221                          ssl->renego_records_seen > ssl->conf->renego_max_records) {
   1222                          MBEDTLS_SSL_DEBUG_MSG(1,
   1223                                                ("renegotiation requested, but not honored by server"));
   1224                          return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   1225                      }
   1226          
   1227                      MBEDTLS_SSL_DEBUG_MSG(1,
   1228                                            ("non-handshake message during renegotiation"));
   1229          
   1230                      ssl->keep_current_message = 1;
   1231                      return MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO;
   1232                  }
   1233          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1234          
   1235                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1236                  mbedtls_ssl_send_alert_message(
   1237                      ssl,
   1238                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1239                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   \       0x2A   0x220A             MOVS     R2,#+10
   \       0x2C   0x2102             MOVS     R1,#+2
   \       0x2E   0x4658             MOV      R0,R11
   \       0x30   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1240                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x38   0xE1C5             B.N      ??ssl_parse_server_hello_1
   1241              }
   1242          
   1243          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1244              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   1245                  if (buf[0] == MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST) {
   1246                      MBEDTLS_SSL_DEBUG_MSG(2, ("received hello verify request"));
   1247                      MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse server hello"));
   1248                      return ssl_parse_hello_verify_request(ssl);
   1249                  } else {
   1250                      /* We made it through the verification process */
   1251                      mbedtls_free(ssl->handshake->cookie);
   1252                      ssl->handshake->cookie = NULL;
   1253                      ssl->handshake->cookie_len = 0;
   1254                  }
   1255              }
   1256          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1257          
   1258              if (ssl->in_hslen < 38 + mbedtls_ssl_hs_hdr_len(ssl) ||
   1259                  buf[0] != MBEDTLS_SSL_HS_SERVER_HELLO) {
   \                     ??ssl_parse_server_hello_2: (+1)
   \       0x3A   0x4658             MOV      R0,R11
   \       0x3C   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0x40   0xF8DB 0x1080      LDR      R1,[R11, #+128]
   \       0x44   0x3026             ADDS     R0,R0,#+38
   \       0x46   0x4281             CMP      R1,R0
   \       0x48   0xD302             BCC.N    ??ssl_parse_server_hello_3
   \       0x4A   0x7820             LDRB     R0,[R4, #+0]
   \       0x4C   0x2802             CMP      R0,#+2
   \       0x4E   0xD007             BEQ.N    ??ssl_parse_server_hello_4
   1260                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1261                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1262                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \                     ??ssl_parse_server_hello_3: (+1)
   \       0x50   0x2232             MOVS     R2,#+50
   \       0x52   0x2102             MOVS     R1,#+2
   \       0x54   0x4658             MOV      R0,R11
   \       0x56   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1263                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x5E   0xE1B2             B.N      ??ssl_parse_server_hello_1
   1264              }
   1265          
   1266              /*
   1267               *  0   .  1    server_version
   1268               *  2   . 33    random (maybe including 4 bytes of Unix time)
   1269               * 34   . 34    session_id length = n
   1270               * 35   . 34+n  session_id
   1271               * 35+n . 36+n  cipher_suite
   1272               * 37+n . 37+n  compression_method
   1273               *
   1274               * 38+n . 39+n  extensions length (optional)
   1275               * 40+n .  ..   extensions
   1276               */
   1277              buf += mbedtls_ssl_hs_hdr_len(ssl);
   \                     ??ssl_parse_server_hello_4: (+1)
   \       0x60   0x4658             MOV      R0,R11
   \       0x62   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0x66   0xEB04 0x0700      ADD      R7,R4,R0
   1278          
   1279              MBEDTLS_SSL_DEBUG_BUF(3, "server hello, version", buf, 2);
   1280              ssl->tls_version = (mbedtls_ssl_protocol_version) mbedtls_ssl_read_version(buf,
   1281                                                                                         ssl->conf->transport);
   \       0x6A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x6E   0x7941             LDRB     R1,[R0, #+5]
   \       0x70   0x0038             MOVS     R0,R7
   \       0x72   0x.... 0x....      BL       mbedtls_ssl_read_version
   \       0x76   0xF8AB 0x0008      STRH     R0,[R11, #+8]
   1282              ssl->session_negotiate->tls_version = ssl->tls_version;
   \       0x7A   0xF8BB 0x1008      LDRH     R1,[R11, #+8]
   \       0x7E   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \       0x82   0x8041             STRH     R1,[R0, #+2]
   1283          
   1284              if (ssl->tls_version < ssl->conf->min_tls_version ||
   1285                  ssl->tls_version > ssl->conf->max_tls_version) {
   \       0x84   0xF9BB 0x0008      LDRSH    R0,[R11, #+8]
   \       0x88   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \       0x8C   0xF9B1 0x1002      LDRSH    R1,[R1, #+2]
   \       0x90   0x4288             CMP      R0,R1
   \       0x92   0xDB07             BLT.N    ??ssl_parse_server_hello_5
   \       0x94   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x98   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \       0x9C   0xF9BB 0x0008      LDRSH    R0,[R11, #+8]
   \       0xA0   0x4281             CMP      R1,R0
   \       0xA2   0xDA07             BGE.N    ??ssl_parse_server_hello_6
   1286                  MBEDTLS_SSL_DEBUG_MSG(1,
   1287                                        (
   1288                                            "server version out of bounds -  min: [0x%x], server: [0x%x], max: [0x%x]",
   1289                                            (unsigned) ssl->conf->min_tls_version,
   1290                                            (unsigned) ssl->tls_version,
   1291                                            (unsigned) ssl->conf->max_tls_version));
   1292          
   1293                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1294                                                 MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION);
   \                     ??ssl_parse_server_hello_5: (+1)
   \       0xA4   0x2246             MOVS     R2,#+70
   \       0xA6   0x2102             MOVS     R1,#+2
   \       0xA8   0x4658             MOV      R0,R11
   \       0xAA   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1295          
   1296                  return MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION;
   \       0xAE   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0xB2   0xE188             B.N      ??ssl_parse_server_hello_1
   1297              }
   1298          
   1299              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, current time: %lu",
   1300                                        ((unsigned long) buf[2] << 24) |
   1301                                        ((unsigned long) buf[3] << 16) |
   1302                                        ((unsigned long) buf[4] <<  8) |
   1303                                        ((unsigned long) buf[5])));
   1304          
   1305              memcpy(ssl->handshake->randbytes + 32, buf + 2, 32);
   \                     ??ssl_parse_server_hello_6: (+1)
   \       0xB4   0x2420             MOVS     R4,#+32
   \       0xB6   0xF117 0x0802      ADDS     R8,R7,#+2
   \       0xBA   0xF8DB 0x0038      LDR      R0,[R11, #+56]
   \       0xBE   0xF510 0x7506      ADDS     R5,R0,#+536
   \       0xC2   0x0022             MOVS     R2,R4
   \       0xC4   0x4641             MOV      R1,R8
   \       0xC6   0x0028             MOVS     R0,R5
   \       0xC8   0x.... 0x....      BL       __aeabi_memcpy
   1306          
   1307              n = buf[34];
   \       0xCC   0xF897 0x5022      LDRB     R5,[R7, #+34]
   1308          
   1309              MBEDTLS_SSL_DEBUG_BUF(3,   "server hello, random bytes", buf + 2, 32);
   1310          
   1311              if (n > 32) {
   \       0xD0   0x2D21             CMP      R5,#+33
   \       0xD2   0xD307             BCC.N    ??ssl_parse_server_hello_7
   1312                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1313                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1314                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \       0xD4   0x2232             MOVS     R2,#+50
   \       0xD6   0x2102             MOVS     R1,#+2
   \       0xD8   0x4658             MOV      R0,R11
   \       0xDA   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1315                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \       0xDE   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0xE2   0xE170             B.N      ??ssl_parse_server_hello_1
   1316              }
   1317          
   1318              if (ssl->in_hslen > mbedtls_ssl_hs_hdr_len(ssl) + 39 + n) {
   \                     ??ssl_parse_server_hello_7: (+1)
   \       0xE4   0x4658             MOV      R0,R11
   \       0xE6   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0xEA   0x1828             ADDS     R0,R5,R0
   \       0xEC   0x3027             ADDS     R0,R0,#+39
   \       0xEE   0xF8DB 0x1080      LDR      R1,[R11, #+128]
   \       0xF2   0x4288             CMP      R0,R1
   \       0xF4   0xD21F             BCS.N    ??ssl_parse_server_hello_8
   1319                  ext_len = ((buf[38 + n] <<  8)
   1320                             | (buf[39 + n]));
   \       0xF6   0xEB07 0x0005      ADD      R0,R7,R5
   \       0xFA   0xF890 0x0026      LDRB     R0,[R0, #+38]
   \       0xFE   0xEB07 0x0105      ADD      R1,R7,R5
   \      0x102   0xF891 0x4027      LDRB     R4,[R1, #+39]
   \      0x106   0xEA54 0x2400      ORRS     R4,R4,R0, LSL #+8
   1321          
   1322                  if ((ext_len > 0 && ext_len < 4) ||
   1323                      ssl->in_hslen != mbedtls_ssl_hs_hdr_len(ssl) + 40 + n + ext_len) {
   \      0x10A   0x2C00             CMP      R4,#+0
   \      0x10C   0xD001             BEQ.N    ??ssl_parse_server_hello_9
   \      0x10E   0x2C04             CMP      R4,#+4
   \      0x110   0xD309             BCC.N    ??ssl_parse_server_hello_10
   \                     ??ssl_parse_server_hello_9: (+1)
   \      0x112   0x4658             MOV      R0,R11
   \      0x114   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \      0x118   0xF8DB 0x1080      LDR      R1,[R11, #+128]
   \      0x11C   0x1828             ADDS     R0,R5,R0
   \      0x11E   0x1820             ADDS     R0,R4,R0
   \      0x120   0x3028             ADDS     R0,R0,#+40
   \      0x122   0x4281             CMP      R1,R0
   \      0x124   0xD01A             BEQ.N    ??ssl_parse_server_hello_11
   1324                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1325                      mbedtls_ssl_send_alert_message(
   1326                          ssl,
   1327                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1328                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \                     ??ssl_parse_server_hello_10: (+1)
   \      0x126   0x2232             MOVS     R2,#+50
   \      0x128   0x2102             MOVS     R1,#+2
   \      0x12A   0x4658             MOV      R0,R11
   \      0x12C   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1329                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \      0x130   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \      0x134   0xE147             B.N      ??ssl_parse_server_hello_1
   1330                  }
   1331              } else if (ssl->in_hslen == mbedtls_ssl_hs_hdr_len(ssl) + 38 + n) {
   \                     ??ssl_parse_server_hello_8: (+1)
   \      0x136   0x4658             MOV      R0,R11
   \      0x138   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \      0x13C   0xF8DB 0x1080      LDR      R1,[R11, #+128]
   \      0x140   0x1828             ADDS     R0,R5,R0
   \      0x142   0x3026             ADDS     R0,R0,#+38
   \      0x144   0x4281             CMP      R1,R0
   \      0x146   0xD101             BNE.N    ??ssl_parse_server_hello_12
   1332                  ext_len = 0;
   \      0x148   0x2400             MOVS     R4,#+0
   \      0x14A   0xE007             B.N      ??ssl_parse_server_hello_11
   1333              } else {
   1334                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1335                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1336                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \                     ??ssl_parse_server_hello_12: (+1)
   \      0x14C   0x2232             MOVS     R2,#+50
   \      0x14E   0x2102             MOVS     R1,#+2
   \      0x150   0x4658             MOV      R0,R11
   \      0x152   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1337                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \      0x156   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \      0x15A   0xE134             B.N      ??ssl_parse_server_hello_1
   1338              }
   1339          
   1340              /* ciphersuite (used later) */
   1341              i = (buf[35 + n] << 8) | buf[36 + n];
   \                     ??ssl_parse_server_hello_11: (+1)
   \      0x15C   0xEB07 0x0005      ADD      R0,R7,R5
   \      0x160   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \      0x164   0xEB07 0x0105      ADD      R1,R7,R5
   \      0x168   0xF891 0x9024      LDRB     R9,[R1, #+36]
   \      0x16C   0xEA59 0x2900      ORRS     R9,R9,R0, LSL #+8
   1342          
   1343              /*
   1344               * Read and check compression
   1345               */
   1346              comp = buf[37 + n];
   \      0x170   0xEB07 0x0005      ADD      R0,R7,R5
   \      0x174   0xF890 0x0025      LDRB     R0,[R0, #+37]
   \      0x178   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1347          
   1348              if (comp != MBEDTLS_SSL_COMPRESS_NULL) {
   \      0x17C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xD007             BEQ.N    ??ssl_parse_server_hello_13
   1349                  MBEDTLS_SSL_DEBUG_MSG(1,
   1350                                        ("server hello, bad compression: %d", comp));
   1351                  mbedtls_ssl_send_alert_message(
   1352                      ssl,
   1353                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1354                      MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   \      0x184   0x222F             MOVS     R2,#+47
   \      0x186   0x2102             MOVS     R1,#+2
   \      0x188   0x4658             MOV      R0,R11
   \      0x18A   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1355                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   \      0x18E   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x192   0xE118             B.N      ??ssl_parse_server_hello_1
   1356              }
   1357          
   1358              /*
   1359               * Initialize update checksum functions
   1360               */
   1361              ssl->handshake->ciphersuite_info = mbedtls_ssl_ciphersuite_from_id(i);
   \                     ??ssl_parse_server_hello_13: (+1)
   \      0x194   0x4648             MOV      R0,R9
   \      0x196   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_from_id
   \      0x19A   0xF8DB 0x1038      LDR      R1,[R11, #+56]
   \      0x19E   0x6088             STR      R0,[R1, #+8]
   1362              if (ssl->handshake->ciphersuite_info == NULL) {
   \      0x1A0   0xF8DB 0x0038      LDR      R0,[R11, #+56]
   \      0x1A4   0x6880             LDR      R0,[R0, #+8]
   \      0x1A6   0x2800             CMP      R0,#+0
   \      0x1A8   0xD107             BNE.N    ??ssl_parse_server_hello_14
   1363                  MBEDTLS_SSL_DEBUG_MSG(1,
   1364                                        ("ciphersuite info for %04x not found", (unsigned int) i));
   1365                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1366                                                 MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   \      0x1AA   0x2250             MOVS     R2,#+80
   \      0x1AC   0x2102             MOVS     R1,#+2
   \      0x1AE   0x4658             MOV      R0,R11
   \      0x1B0   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1367                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \      0x1B4   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \      0x1B8   0xE105             B.N      ??ssl_parse_server_hello_1
   1368              }
   1369          
   1370              mbedtls_ssl_optimize_checksum(ssl, ssl->handshake->ciphersuite_info);
   \                     ??ssl_parse_server_hello_14: (+1)
   \      0x1BA   0xF8DB 0x0038      LDR      R0,[R11, #+56]
   \      0x1BE   0x6881             LDR      R1,[R0, #+8]
   \      0x1C0   0x4658             MOV      R0,R11
   \      0x1C2   0x.... 0x....      BL       mbedtls_ssl_optimize_checksum
   1371          
   1372              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, session id len.: %" MBEDTLS_PRINTF_SIZET, n));
   1373              MBEDTLS_SSL_DEBUG_BUF(3,   "server hello, session id", buf + 35, n);
   1374          
   1375              /*
   1376               * Check if the session can be resumed
   1377               */
   1378              if (ssl->handshake->resume == 0 || n == 0 ||
   1379          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1380                  ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE ||
   1381          #endif
   1382                  ssl->session_negotiate->ciphersuite != i ||
   1383                  ssl->session_negotiate->id_len != n ||
   1384                  memcmp(ssl->session_negotiate->id, buf + 35, n) != 0) {
   \      0x1C6   0xF8DB 0x0038      LDR      R0,[R11, #+56]
   \      0x1CA   0x7800             LDRB     R0,[R0, #+0]
   \      0x1CC   0x2800             CMP      R0,#+0
   \      0x1CE   0xD015             BEQ.N    ??ssl_parse_server_hello_15
   \      0x1D0   0x2D00             CMP      R5,#+0
   \      0x1D2   0xD013             BEQ.N    ??ssl_parse_server_hello_15
   \      0x1D4   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \      0x1D8   0x6840             LDR      R0,[R0, #+4]
   \      0x1DA   0x4548             CMP      R0,R9
   \      0x1DC   0xD10E             BNE.N    ??ssl_parse_server_hello_15
   \      0x1DE   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \      0x1E2   0x6880             LDR      R0,[R0, #+8]
   \      0x1E4   0x42A8             CMP      R0,R5
   \      0x1E6   0xD109             BNE.N    ??ssl_parse_server_hello_15
   \      0x1E8   0x002A             MOVS     R2,R5
   \      0x1EA   0xF117 0x0123      ADDS     R1,R7,#+35
   \      0x1EE   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \      0x1F2   0x300C             ADDS     R0,R0,#+12
   \      0x1F4   0x.... 0x....      BL       memcmp
   \      0x1F8   0x2800             CMP      R0,#+0
   \      0x1FA   0xD01C             BEQ.N    ??ssl_parse_server_hello_16
   1385                  ssl->state++;
   \                     ??ssl_parse_server_hello_15: (+1)
   \      0x1FC   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x200   0x1C40             ADDS     R0,R0,#+1
   \      0x202   0xF8CB 0x0004      STR      R0,[R11, #+4]
   1386                  ssl->handshake->resume = 0;
   \      0x206   0x2100             MOVS     R1,#+0
   \      0x208   0xF8DB 0x0038      LDR      R0,[R11, #+56]
   \      0x20C   0x7001             STRB     R1,[R0, #+0]
   1387          #if defined(MBEDTLS_HAVE_TIME)
   1388                  ssl->session_negotiate->start = mbedtls_time(NULL);
   1389          #endif
   1390                  ssl->session_negotiate->ciphersuite = i;
   \      0x20E   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \      0x212   0xF8C0 0x9004      STR      R9,[R0, #+4]
   1391                  ssl->session_negotiate->id_len = n;
   \      0x216   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \      0x21A   0x6085             STR      R5,[R0, #+8]
   1392                  memcpy(ssl->session_negotiate->id, buf + 35, n);
   \      0x21C   0x9502             STR      R5,[SP, #+8]
   \      0x21E   0xF117 0x0A23      ADDS     R10,R7,#+35
   \      0x222   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \      0x226   0xF110 0x080C      ADDS     R8,R0,#+12
   \      0x22A   0x9A02             LDR      R2,[SP, #+8]
   \      0x22C   0x4651             MOV      R1,R10
   \      0x22E   0x4640             MOV      R0,R8
   \      0x230   0x.... 0x....      BL       __aeabi_memcpy
   1393              } else {
   \      0x234   0xE002             B.N      ??ssl_parse_server_hello_17
   1394                  ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
   \                     ??ssl_parse_server_hello_16: (+1)
   \      0x236   0x200C             MOVS     R0,#+12
   \      0x238   0xF8CB 0x0004      STR      R0,[R11, #+4]
   1395              }
   1396          
   1397              MBEDTLS_SSL_DEBUG_MSG(3, ("%s session has been resumed",
   1398                                        ssl->handshake->resume ? "a" : "no"));
   1399          
   1400              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, chosen ciphersuite: %04x", (unsigned) i));
   1401              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, compress alg.: %d",
   1402                                        buf[37 + n]));
   1403          
   1404              /*
   1405               * Perform cipher suite validation in same way as in ssl_write_client_hello.
   1406               */
   1407              i = 0;
   \                     ??ssl_parse_server_hello_17: (+1)
   \      0x23C   0xF05F 0x0800      MOVS     R8,#+0
   1408              while (1) {
   1409                  if (ssl->conf->ciphersuite_list[i] == 0) {
   \                     ??ssl_parse_server_hello_18: (+1)
   \      0x240   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x244   0x68C0             LDR      R0,[R0, #+12]
   \      0x246   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \      0x24A   0x2800             CMP      R0,#+0
   \      0x24C   0xD107             BNE.N    ??ssl_parse_server_hello_19
   1410                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1411                      mbedtls_ssl_send_alert_message(
   1412                          ssl,
   1413                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1414                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   \      0x24E   0x222F             MOVS     R2,#+47
   \      0x250   0x2102             MOVS     R1,#+2
   \      0x252   0x4658             MOV      R0,R11
   \      0x254   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1415                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   \      0x258   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \      0x25C   0xE0B3             B.N      ??ssl_parse_server_hello_1
   1416                  }
   1417          
   1418                  if (ssl->conf->ciphersuite_list[i++] ==
   1419                      ssl->session_negotiate->ciphersuite) {
   \                     ??ssl_parse_server_hello_19: (+1)
   \      0x25E   0x4640             MOV      R0,R8
   \      0x260   0xF110 0x0801      ADDS     R8,R0,#+1
   \      0x264   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x268   0x68C9             LDR      R1,[R1, #+12]
   \      0x26A   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \      0x26E   0xF8DB 0x1034      LDR      R1,[R11, #+52]
   \      0x272   0x6849             LDR      R1,[R1, #+4]
   \      0x274   0x4288             CMP      R0,R1
   \      0x276   0xD1E3             BNE.N    ??ssl_parse_server_hello_18
   1420                      break;
   1421                  }
   1422              }
   1423          
   1424              suite_info = mbedtls_ssl_ciphersuite_from_id(
   1425                  ssl->session_negotiate->ciphersuite);
   \      0x278   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \      0x27C   0x6840             LDR      R0,[R0, #+4]
   \      0x27E   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_from_id
   \      0x282   0x9003             STR      R0,[SP, #+12]
   1426              if (mbedtls_ssl_validate_ciphersuite(ssl, suite_info, ssl->tls_version,
   1427                                                   ssl->tls_version) != 0) {
   \      0x284   0xF9BB 0x3008      LDRSH    R3,[R11, #+8]
   \      0x288   0xF9BB 0x2008      LDRSH    R2,[R11, #+8]
   \      0x28C   0x9903             LDR      R1,[SP, #+12]
   \      0x28E   0x4658             MOV      R0,R11
   \      0x290   0x.... 0x....      BL       mbedtls_ssl_validate_ciphersuite
   \      0x294   0x2800             CMP      R0,#+0
   \      0x296   0xD007             BEQ.N    ??ssl_parse_server_hello_20
   1428                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1429                  mbedtls_ssl_send_alert_message(
   1430                      ssl,
   1431                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1432                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   \      0x298   0x2228             MOVS     R2,#+40
   \      0x29A   0x2102             MOVS     R1,#+2
   \      0x29C   0x4658             MOV      R0,R11
   \      0x29E   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1433                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \      0x2A2   0x.... 0x....      LDR.W    R0,??DataTable13
   \      0x2A6   0xE08E             B.N      ??ssl_parse_server_hello_1
   1434              }
   1435          
   1436              MBEDTLS_SSL_DEBUG_MSG(3,
   1437                                    ("server hello, chosen ciphersuite: %s", suite_info->name));
   1438          
   1439          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   1440              if (suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA &&
   1441                  ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_2) {
   1442                  ssl->handshake->ecrs_enabled = 1;
   1443              }
   1444          #endif
   1445          
   1446              if (comp != MBEDTLS_SSL_COMPRESS_NULL) {
   \                     ??ssl_parse_server_hello_20: (+1)
   \      0x2A8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x2AC   0x2800             CMP      R0,#+0
   \      0x2AE   0xD007             BEQ.N    ??ssl_parse_server_hello_21
   1447                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1448                  mbedtls_ssl_send_alert_message(
   1449                      ssl,
   1450                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1451                      MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   \      0x2B0   0x222F             MOVS     R2,#+47
   \      0x2B2   0x2102             MOVS     R1,#+2
   \      0x2B4   0x4658             MOV      R0,R11
   \      0x2B6   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1452                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   \      0x2BA   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \      0x2BE   0xE082             B.N      ??ssl_parse_server_hello_1
   1453              }
   1454          
   1455              ext = buf + 40 + n;
   \                     ??ssl_parse_server_hello_21: (+1)
   \      0x2C0   0xEB07 0x0005      ADD      R0,R7,R5
   \      0x2C4   0xF110 0x0928      ADDS     R9,R0,#+40
   1456          
   1457              MBEDTLS_SSL_DEBUG_MSG(2,
   1458                                    ("server hello, total extension length: %" MBEDTLS_PRINTF_SIZET,
   1459                                     ext_len));
   1460          
   1461              while (ext_len) {
   \                     ??ssl_parse_server_hello_22: (+1)
   \      0x2C8   0x2C00             CMP      R4,#+0
   \      0x2CA   0xD053             BEQ.N    ??ssl_parse_server_hello_23
   1462                  unsigned int ext_id   = ((ext[0] <<  8)
   1463                                           | (ext[1]));
   \      0x2CC   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \      0x2D0   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \      0x2D4   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \      0x2D8   0x9002             STR      R0,[SP, #+8]
   1464                  unsigned int ext_size = ((ext[2] <<  8)
   1465                                           | (ext[3]));
   \      0x2DA   0xF899 0x0002      LDRB     R0,[R9, #+2]
   \      0x2DE   0xF899 0xA003      LDRB     R10,[R9, #+3]
   \      0x2E2   0xEA5A 0x2A00      ORRS     R10,R10,R0, LSL #+8
   1466          
   1467                  if (ext_size + 4 > ext_len) {
   \      0x2E6   0xF11A 0x0004      ADDS     R0,R10,#+4
   \      0x2EA   0x4284             CMP      R4,R0
   \      0x2EC   0xD207             BCS.N    ??ssl_parse_server_hello_24
   1468                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1469                      mbedtls_ssl_send_alert_message(
   1470                          ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1471                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \      0x2EE   0x2232             MOVS     R2,#+50
   \      0x2F0   0x2102             MOVS     R1,#+2
   \      0x2F2   0x4658             MOV      R0,R11
   \      0x2F4   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1472                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \      0x2F8   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \      0x2FC   0xE063             B.N      ??ssl_parse_server_hello_1
   1473                  }
   1474          
   1475                  switch (ext_id) {
   \                     ??ssl_parse_server_hello_24: (+1)
   \      0x2FE   0x9802             LDR      R0,[SP, #+8]
   \      0x300   0x2801             CMP      R0,#+1
   \      0x302   0xD011             BEQ.N    ??ssl_parse_server_hello_25
   \      0x304   0x280B             CMP      R0,#+11
   \      0x306   0xD01B             BEQ.N    ??ssl_parse_server_hello_26
   \      0x308   0xF64F 0x7101      MOVW     R1,#+65281
   \      0x30C   0x4288             CMP      R0,R1
   \      0x30E   0xD123             BNE.N    ??ssl_parse_server_hello_27
   1476                      case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:
   1477                          MBEDTLS_SSL_DEBUG_MSG(3, ("found renegotiation extension"));
   1478          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1479                          renegotiation_info_seen = 1;
   1480          #endif
   1481          
   1482                          if ((ret = ssl_parse_renegotiation_info(ssl, ext + 4,
   1483                                                                  ext_size)) != 0) {
   \                     ??ssl_parse_server_hello_28: (+1)
   \      0x310   0x4652             MOV      R2,R10
   \      0x312   0xF119 0x0104      ADDS     R1,R9,#+4
   \      0x316   0x4658             MOV      R0,R11
   \      0x318   0x.... 0x....      BL       ssl_parse_renegotiation_info
   \      0x31C   0x0006             MOVS     R6,R0
   \      0x31E   0x2800             CMP      R0,#+0
   \      0x320   0xD001             BEQ.N    ??ssl_parse_server_hello_29
   1484                              return ret;
   \      0x322   0x0030             MOVS     R0,R6
   \      0x324   0xE04F             B.N      ??ssl_parse_server_hello_1
   1485                          }
   1486          
   1487                          break;
   \                     ??ssl_parse_server_hello_29: (+1)
   \      0x326   0xE017             B.N      ??ssl_parse_server_hello_30
   1488          
   1489          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   1490                      case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:
   1491                          MBEDTLS_SSL_DEBUG_MSG(3,
   1492                                                ("found max_fragment_length extension"));
   1493          
   1494                          if ((ret = ssl_parse_max_fragment_length_ext(ssl,
   1495                                                                       ext + 4, ext_size)) != 0) {
   \                     ??ssl_parse_server_hello_25: (+1)
   \      0x328   0x4652             MOV      R2,R10
   \      0x32A   0xF119 0x0104      ADDS     R1,R9,#+4
   \      0x32E   0x4658             MOV      R0,R11
   \      0x330   0x.... 0x....      BL       ssl_parse_max_fragment_length_ext
   \      0x334   0x0006             MOVS     R6,R0
   \      0x336   0x2800             CMP      R0,#+0
   \      0x338   0xD001             BEQ.N    ??ssl_parse_server_hello_31
   1496                              return ret;
   \      0x33A   0x0030             MOVS     R0,R6
   \      0x33C   0xE043             B.N      ??ssl_parse_server_hello_1
   1497                          }
   1498          
   1499                          break;
   \                     ??ssl_parse_server_hello_31: (+1)
   \      0x33E   0xE00B             B.N      ??ssl_parse_server_hello_30
   1500          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   1501          
   1502          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   1503                      case MBEDTLS_TLS_EXT_CID:
   1504                          MBEDTLS_SSL_DEBUG_MSG(3, ("found CID extension"));
   1505          
   1506                          if ((ret = ssl_parse_cid_ext(ssl,
   1507                                                       ext + 4,
   1508                                                       ext_size)) != 0) {
   1509                              return ret;
   1510                          }
   1511          
   1512                          break;
   1513          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   1514          
   1515          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1516                      case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:
   1517                          MBEDTLS_SSL_DEBUG_MSG(3, ("found encrypt_then_mac extension"));
   1518          
   1519                          if ((ret = ssl_parse_encrypt_then_mac_ext(ssl,
   1520                                                                    ext + 4, ext_size)) != 0) {
   1521                              return ret;
   1522                          }
   1523          
   1524                          break;
   1525          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   1526          
   1527          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   1528                      case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:
   1529                          MBEDTLS_SSL_DEBUG_MSG(3,
   1530                                                ("found extended_master_secret extension"));
   1531          
   1532                          if ((ret = ssl_parse_extended_ms_ext(ssl,
   1533                                                               ext + 4, ext_size)) != 0) {
   1534                              return ret;
   1535                          }
   1536          
   1537                          break;
   1538          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   1539          
   1540          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   1541                      case MBEDTLS_TLS_EXT_SESSION_TICKET:
   1542                          MBEDTLS_SSL_DEBUG_MSG(3, ("found session_ticket extension"));
   1543          
   1544                          if ((ret = ssl_parse_session_ticket_ext(ssl,
   1545                                                                  ext + 4, ext_size)) != 0) {
   1546                              return ret;
   1547                          }
   1548          
   1549                          break;
   1550          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   1551          
   1552          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
   1553                          defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
   1554                          defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1555                      case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:
   1556                          MBEDTLS_SSL_DEBUG_MSG(3,
   1557                                                ("found supported_point_formats extension"));
   1558          
   1559                          if ((ret = ssl_parse_supported_point_formats_ext(ssl,
   1560                                                                           ext + 4, ext_size)) != 0) {
   \                     ??ssl_parse_server_hello_26: (+1)
   \      0x340   0x4652             MOV      R2,R10
   \      0x342   0xF119 0x0104      ADDS     R1,R9,#+4
   \      0x346   0x4658             MOV      R0,R11
   \      0x348   0x.... 0x....      BL       ssl_parse_supported_point_formats_ext
   \      0x34C   0x0006             MOVS     R6,R0
   \      0x34E   0x2800             CMP      R0,#+0
   \      0x350   0xD001             BEQ.N    ??ssl_parse_server_hello_32
   1561                              return ret;
   \      0x352   0x0030             MOVS     R0,R6
   \      0x354   0xE037             B.N      ??ssl_parse_server_hello_1
   1562                          }
   1563          
   1564                          break;
   \                     ??ssl_parse_server_hello_32: (+1)
   \      0x356   0xE7FF             B.N      ??ssl_parse_server_hello_30
   1565          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED ||
   1566                    MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED ||
   1567                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1568          
   1569          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1570                      case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:
   1571                          MBEDTLS_SSL_DEBUG_MSG(3, ("found ecjpake_kkpp extension"));
   1572          
   1573                          if ((ret = ssl_parse_ecjpake_kkpp(ssl,
   1574                                                            ext + 4, ext_size)) != 0) {
   1575                              return ret;
   1576                          }
   1577          
   1578                          break;
   1579          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1580          
   1581          #if defined(MBEDTLS_SSL_ALPN)
   1582                      case MBEDTLS_TLS_EXT_ALPN:
   1583                          MBEDTLS_SSL_DEBUG_MSG(3, ("found alpn extension"));
   1584          
   1585                          if ((ret = ssl_parse_alpn_ext(ssl, ext + 4, ext_size)) != 0) {
   1586                              return ret;
   1587                          }
   1588          
   1589                          break;
   1590          #endif /* MBEDTLS_SSL_ALPN */
   1591          
   1592          #if defined(MBEDTLS_SSL_DTLS_SRTP)
   1593                      case MBEDTLS_TLS_EXT_USE_SRTP:
   1594                          MBEDTLS_SSL_DEBUG_MSG(3, ("found use_srtp extension"));
   1595          
   1596                          if ((ret = ssl_parse_use_srtp_ext(ssl, ext + 4, ext_size)) != 0) {
   1597                              return ret;
   1598                          }
   1599          
   1600                          break;
   1601          #endif /* MBEDTLS_SSL_DTLS_SRTP */
   1602          
   1603                      default:
   1604                          MBEDTLS_SSL_DEBUG_MSG(3,
   1605                                                ("unknown extension found: %u (ignoring)", ext_id));
   1606                  }
   1607          
   1608                  ext_len -= 4 + ext_size;
   \                     ??ssl_parse_server_hello_27: (+1)
   \                     ??ssl_parse_server_hello_30: (+1)
   \      0x358   0xEBB4 0x040A      SUBS     R4,R4,R10
   \      0x35C   0x1F24             SUBS     R4,R4,#+4
   1609                  ext += 4 + ext_size;
   \      0x35E   0xEB09 0x000A      ADD      R0,R9,R10
   \      0x362   0xF110 0x0904      ADDS     R9,R0,#+4
   1610          
   1611                  if (ext_len > 0 && ext_len < 4) {
   \      0x366   0x2C00             CMP      R4,#+0
   \      0x368   0xD0AE             BEQ.N    ??ssl_parse_server_hello_22
   \      0x36A   0x2C04             CMP      R4,#+4
   \      0x36C   0xD2AC             BCS.N    ??ssl_parse_server_hello_22
   1612                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1613                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \      0x36E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \      0x372   0xE028             B.N      ??ssl_parse_server_hello_1
   1614                  }
   1615              }
   1616          
   1617              /*
   1618               * mbedtls_ssl_derive_keys() has to be called after the parsing of the
   1619               * extensions. It sets the transform data for the resumed session which in
   1620               * case of DTLS includes the server CID extracted from the CID extension.
   1621               */
   1622              if (ssl->handshake->resume) {
   \                     ??ssl_parse_server_hello_23: (+1)
   \      0x374   0xF8DB 0x0038      LDR      R0,[R11, #+56]
   \      0x378   0x7800             LDRB     R0,[R0, #+0]
   \      0x37A   0x2800             CMP      R0,#+0
   \      0x37C   0xD00C             BEQ.N    ??ssl_parse_server_hello_33
   1623                  if ((ret = mbedtls_ssl_derive_keys(ssl)) != 0) {
   \      0x37E   0x4658             MOV      R0,R11
   \      0x380   0x.... 0x....      BL       mbedtls_ssl_derive_keys
   \      0x384   0x0006             MOVS     R6,R0
   \      0x386   0x2800             CMP      R0,#+0
   \      0x388   0xD006             BEQ.N    ??ssl_parse_server_hello_33
   1624                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_derive_keys", ret);
   1625                      mbedtls_ssl_send_alert_message(
   1626                          ssl,
   1627                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1628                          MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   \      0x38A   0x2250             MOVS     R2,#+80
   \      0x38C   0x2102             MOVS     R1,#+2
   \      0x38E   0x4658             MOV      R0,R11
   \      0x390   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1629                      return ret;
   \      0x394   0x0030             MOVS     R0,R6
   \      0x396   0xE016             B.N      ??ssl_parse_server_hello_1
   1630                  }
   1631              }
   1632          
   1633              /*
   1634               * Renegotiation security checks
   1635               */
   1636              if (ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1637                  ssl->conf->allow_legacy_renegotiation ==
   1638                  MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE) {
   \                     ??ssl_parse_server_hello_33: (+1)
   \      0x398   0xF8DB 0x00C4      LDR      R0,[R11, #+196]
   \      0x39C   0x2800             CMP      R0,#+0
   \      0x39E   0xD106             BNE.N    ??ssl_parse_server_hello_34
   \      0x3A0   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x3A4   0x79C0             LDRB     R0,[R0, #+7]
   \      0x3A6   0x2802             CMP      R0,#+2
   \      0x3A8   0xD101             BNE.N    ??ssl_parse_server_hello_34
   1639                  MBEDTLS_SSL_DEBUG_MSG(1,
   1640                                        ("legacy renegotiation, breaking off handshake"));
   1641                  handshake_failure = 1;
   \      0x3AA   0x2001             MOVS     R0,#+1
   \      0x3AC   0x9001             STR      R0,[SP, #+4]
   1642              }
   1643          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1644              else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1645                       ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&
   1646                       renegotiation_info_seen == 0) {
   1647                  MBEDTLS_SSL_DEBUG_MSG(1,
   1648                                        ("renegotiation_info extension missing (secure)"));
   1649                  handshake_failure = 1;
   1650              } else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1651                         ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1652                         ssl->conf->allow_legacy_renegotiation ==
   1653                         MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION) {
   1654                  MBEDTLS_SSL_DEBUG_MSG(1, ("legacy renegotiation not allowed"));
   1655                  handshake_failure = 1;
   1656              } else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1657                         ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1658                         renegotiation_info_seen == 1) {
   1659                  MBEDTLS_SSL_DEBUG_MSG(1,
   1660                                        ("renegotiation_info extension present (legacy)"));
   1661                  handshake_failure = 1;
   1662              }
   1663          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1664          
   1665              if (handshake_failure == 1) {
   \                     ??ssl_parse_server_hello_34: (+1)
   \      0x3AE   0x9801             LDR      R0,[SP, #+4]
   \      0x3B0   0x2801             CMP      R0,#+1
   \      0x3B2   0xD107             BNE.N    ??ssl_parse_server_hello_35
   1666                  mbedtls_ssl_send_alert_message(
   1667                      ssl,
   1668                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1669                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   \      0x3B4   0x2228             MOVS     R2,#+40
   \      0x3B6   0x2102             MOVS     R1,#+2
   \      0x3B8   0x4658             MOV      R0,R11
   \      0x3BA   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   1670                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \      0x3BE   0x.... 0x....      LDR.W    R0,??DataTable13
   \      0x3C2   0xE000             B.N      ??ssl_parse_server_hello_1
   1671              }
   1672          
   1673              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse server hello"));
   1674          
   1675              return 0;
   \                     ??ssl_parse_server_hello_35: (+1)
   \      0x3C4   0x2000             MOVS     R0,#+0
   \                     ??ssl_parse_server_hello_1: (+1)
   \      0x3C6   0xB005             ADD      SP,SP,#+20
   \      0x3C8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1676          }
   1677          
   1678          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
   1679              defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   1680          MBEDTLS_CHECK_RETURN_CRITICAL
   1681          static int ssl_parse_server_dh_params(mbedtls_ssl_context *ssl,
   1682                                                unsigned char **p,
   1683                                                unsigned char *end)
   1684          {
   1685              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1686              size_t dhm_actual_bitlen;
   1687          
   1688              /*
   1689               * Ephemeral DH parameters:
   1690               *
   1691               * struct {
   1692               *     opaque dh_p<1..2^16-1>;
   1693               *     opaque dh_g<1..2^16-1>;
   1694               *     opaque dh_Ys<1..2^16-1>;
   1695               * } ServerDHParams;
   1696               */
   1697              if ((ret = mbedtls_dhm_read_params(&ssl->handshake->dhm_ctx,
   1698                                                 p, end)) != 0) {
   1699                  MBEDTLS_SSL_DEBUG_RET(2, ("mbedtls_dhm_read_params"), ret);
   1700                  return ret;
   1701              }
   1702          
   1703              dhm_actual_bitlen = mbedtls_dhm_get_bitlen(&ssl->handshake->dhm_ctx);
   1704              if (dhm_actual_bitlen < ssl->conf->dhm_min_bitlen) {
   1705                  MBEDTLS_SSL_DEBUG_MSG(1, ("DHM prime too short: %" MBEDTLS_PRINTF_SIZET " < %u",
   1706                                            dhm_actual_bitlen,
   1707                                            ssl->conf->dhm_min_bitlen));
   1708                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1709              }
   1710          
   1711              MBEDTLS_SSL_DEBUG_MPI(3, "DHM: P ", &ssl->handshake->dhm_ctx.P);
   1712              MBEDTLS_SSL_DEBUG_MPI(3, "DHM: G ", &ssl->handshake->dhm_ctx.G);
   1713              MBEDTLS_SSL_DEBUG_MPI(3, "DHM: GY", &ssl->handshake->dhm_ctx.GY);
   1714          
   1715              return ret;
   1716          }
   1717          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
   1718                    MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   1719          
   1720          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1721          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)   ||   \
   1722              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)   ||   \
   1723              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   1724          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   1725          static int ssl_parse_server_ecdh_params(mbedtls_ssl_context *ssl,
   1726                                                  unsigned char **p,
   1727                                                  unsigned char *end)
   1728          {
   \                     ssl_parse_server_ecdh_params: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   1729              uint16_t tls_id;
   1730              size_t ecpoint_len;
   1731              mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   \        0xA   0x6BBE             LDR      R6,[R7, #+56]
   1732              psa_key_type_t key_type = PSA_KEY_TYPE_NONE;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1733              size_t ec_bits = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9001             STR      R0,[SP, #+4]
   1734          
   1735              /*
   1736               * struct {
   1737               *     ECParameters curve_params;
   1738               *     ECPoint      public;
   1739               * } ServerECDHParams;
   1740               *
   1741               *  1       curve_type (must be "named_curve")
   1742               *  2..3    NamedCurve
   1743               *  4       ECPoint.len
   1744               *  5+      ECPoint contents
   1745               */
   1746              if (end - *p < 4) {
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x1A28             SUBS     R0,R5,R0
   \       0x1A   0x2804             CMP      R0,#+4
   \       0x1C   0xDA02             BGE.N    ??ssl_parse_server_ecdh_params_0
   1747                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x22   0xE054             B.N      ??ssl_parse_server_ecdh_params_1
   1748              }
   1749          
   1750              /* First byte is curve_type; only named_curve is handled */
   1751              if (*(*p)++ != MBEDTLS_ECP_TLS_NAMED_CURVE) {
   \                     ??ssl_parse_server_ecdh_params_0: (+1)
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x1C48             ADDS     R0,R1,#+1
   \       0x28   0x6020             STR      R0,[R4, #+0]
   \       0x2A   0x7808             LDRB     R0,[R1, #+0]
   \       0x2C   0x2803             CMP      R0,#+3
   \       0x2E   0xD002             BEQ.N    ??ssl_parse_server_ecdh_params_2
   1752                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x34   0xE04B             B.N      ??ssl_parse_server_ecdh_params_1
   1753              }
   1754          
   1755              /* Next two bytes are the namedcurve value */
   1756              tls_id = *(*p)++;
   \                     ??ssl_parse_server_ecdh_params_2: (+1)
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x1C48             ADDS     R0,R1,#+1
   \       0x3A   0x6020             STR      R0,[R4, #+0]
   \       0x3C   0xF891 0x8000      LDRB     R8,[R1, #+0]
   1757              tls_id <<= 8;
   \       0x40   0xEA5F 0x2808      LSLS     R8,R8,#+8
   1758              tls_id |= *(*p)++;
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x1C48             ADDS     R0,R1,#+1
   \       0x48   0x6020             STR      R0,[R4, #+0]
   \       0x4A   0x7808             LDRB     R0,[R1, #+0]
   \       0x4C   0xEA50 0x0808      ORRS     R8,R0,R8
   1759          
   1760              /* Check it's a curve we offered */
   1761              if (mbedtls_ssl_check_curve_tls_id(ssl, tls_id) != 0) {
   \       0x50   0x4641             MOV      R1,R8
   \       0x52   0xB289             UXTH     R1,R1
   \       0x54   0x0038             MOVS     R0,R7
   \       0x56   0x.... 0x....      BL       mbedtls_ssl_check_curve_tls_id
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD002             BEQ.N    ??ssl_parse_server_ecdh_params_3
   1762                  MBEDTLS_SSL_DEBUG_MSG(2,
   1763                                        ("bad server key exchange message (ECDHE curve): %u",
   1764                                         (unsigned) tls_id));
   1765                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x62   0xE034             B.N      ??ssl_parse_server_ecdh_params_1
   1766              }
   1767          
   1768              /* Convert EC's TLS ID to PSA key type. */
   1769              if (mbedtls_ssl_get_psa_curve_info_from_tls_id(tls_id, &key_type,
   1770                                                             &ec_bits) == PSA_ERROR_NOT_SUPPORTED) {
   \                     ??ssl_parse_server_ecdh_params_3: (+1)
   \       0x64   0xAA01             ADD      R2,SP,#+4
   \       0x66   0x4669             MOV      R1,SP
   \       0x68   0x4640             MOV      R0,R8
   \       0x6A   0xB280             UXTH     R0,R0
   \       0x6C   0x.... 0x....      BL       mbedtls_ssl_get_psa_curve_info_from_tls_id
   \       0x70   0xF110 0x0F86      CMN      R0,#+134
   \       0x74   0xD102             BNE.N    ??ssl_parse_server_ecdh_params_4
   1771                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x7A   0xE028             B.N      ??ssl_parse_server_ecdh_params_1
   1772              }
   1773              handshake->xxdh_psa_type = key_type;
   \                     ??ssl_parse_server_ecdh_params_4: (+1)
   \       0x7C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x80   0xF8A6 0x004C      STRH     R0,[R6, #+76]
   1774              handshake->xxdh_psa_bits = ec_bits;
   \       0x84   0x9801             LDR      R0,[SP, #+4]
   \       0x86   0x6530             STR      R0,[R6, #+80]
   1775          
   1776              /* Keep a copy of the peer's public key */
   1777              ecpoint_len = *(*p)++;
   \       0x88   0x6821             LDR      R1,[R4, #+0]
   \       0x8A   0x1C48             ADDS     R0,R1,#+1
   \       0x8C   0x6020             STR      R0,[R4, #+0]
   \       0x8E   0xF891 0x9000      LDRB     R9,[R1, #+0]
   1778              if ((size_t) (end - *p) < ecpoint_len) {
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x1A28             SUBS     R0,R5,R0
   \       0x96   0x4548             CMP      R0,R9
   \       0x98   0xD202             BCS.N    ??ssl_parse_server_ecdh_params_5
   1779                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x9E   0xE016             B.N      ??ssl_parse_server_ecdh_params_1
   1780              }
   1781          
   1782              if (ecpoint_len > sizeof(handshake->xxdh_psa_peerkey)) {
   \                     ??ssl_parse_server_ecdh_params_5: (+1)
   \       0xA0   0xF1B9 0x0F42      CMP      R9,#+66
   \       0xA4   0xD302             BCC.N    ??ssl_parse_server_ecdh_params_6
   1783                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0xAA   0xE010             B.N      ??ssl_parse_server_ecdh_params_1
   1784              }
   1785          
   1786              memcpy(handshake->xxdh_psa_peerkey, *p, ecpoint_len);
   \                     ??ssl_parse_server_ecdh_params_6: (+1)
   \       0xAC   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0xB0   0xF8D4 0xB000      LDR      R11,[R4, #+0]
   \       0xB4   0xF116 0x0A59      ADDS     R10,R6,#+89
   \       0xB8   0x9A02             LDR      R2,[SP, #+8]
   \       0xBA   0x4659             MOV      R1,R11
   \       0xBC   0x4650             MOV      R0,R10
   \       0xBE   0x.... 0x....      BL       __aeabi_memcpy
   1787              handshake->xxdh_psa_peerkey_len = ecpoint_len;
   \       0xC2   0xF8C6 0x909C      STR      R9,[R6, #+156]
   1788              *p += ecpoint_len;
   \       0xC6   0x6820             LDR      R0,[R4, #+0]
   \       0xC8   0x4448             ADD      R0,R0,R9
   \       0xCA   0x6020             STR      R0,[R4, #+0]
   1789          
   1790              return 0;
   \       0xCC   0x2000             MOVS     R0,#+0
   \                     ??ssl_parse_server_ecdh_params_1: (+1)
   \       0xCE   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1791          }
   1792          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED   ||
   1793                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED   ||
   1794                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   1795          #else
   1796          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)   ||   \
   1797              defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)    ||   \
   1798              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)   ||   \
   1799              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||   \
   1800              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   1801          MBEDTLS_CHECK_RETURN_CRITICAL
   1802          static int ssl_check_server_ecdh_params(const mbedtls_ssl_context *ssl)
   1803          {
   1804              uint16_t tls_id;
   1805              mbedtls_ecp_group_id grp_id;
   1806          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
   1807              grp_id = ssl->handshake->ecdh_ctx.grp.id;
   1808          #else
   1809              grp_id = ssl->handshake->ecdh_ctx.grp_id;
   1810          #endif
   1811          
   1812              tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(grp_id);
   1813              if (tls_id == 0) {
   1814                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   1815                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   1816              }
   1817          
   1818              MBEDTLS_SSL_DEBUG_MSG(2, ("ECDH curve: %s",
   1819                                        mbedtls_ssl_get_curve_name_from_tls_id(tls_id)));
   1820          
   1821              if (mbedtls_ssl_check_curve(ssl, grp_id) != 0) {
   1822                  return -1;
   1823              }
   1824          
   1825              MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   1826                                     MBEDTLS_DEBUG_ECDH_QP);
   1827          
   1828              return 0;
   1829          }
   1830          
   1831          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED   ||
   1832                    MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED    ||
   1833                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED   ||
   1834                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
   1835                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   1836          
   1837          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||     \
   1838              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||     \
   1839              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   1840          MBEDTLS_CHECK_RETURN_CRITICAL
   1841          static int ssl_parse_server_ecdh_params(mbedtls_ssl_context *ssl,
   1842                                                  unsigned char **p,
   1843                                                  unsigned char *end)
   1844          {
   1845              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1846          
   1847              /*
   1848               * Ephemeral ECDH parameters:
   1849               *
   1850               * struct {
   1851               *     ECParameters curve_params;
   1852               *     ECPoint      public;
   1853               * } ServerECDHParams;
   1854               */
   1855              if ((ret = mbedtls_ecdh_read_params(&ssl->handshake->ecdh_ctx,
   1856                                                  (const unsigned char **) p, end)) != 0) {
   1857                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ecdh_read_params"), ret);
   1858          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   1859                  if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   1860                      ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   1861                  }
   1862          #endif
   1863                  return ret;
   1864              }
   1865          
   1866              if (ssl_check_server_ecdh_params(ssl) != 0) {
   1867                  MBEDTLS_SSL_DEBUG_MSG(1,
   1868                                        ("bad server key exchange message (ECDHE curve)"));
   1869                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1870              }
   1871          
   1872              return ret;
   1873          }
   1874          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED || \
   1875                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED || \
   1876                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   1877          #endif /* !MBEDTLS_USE_PSA_CRYPTO */
   1878          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   1879          MBEDTLS_CHECK_RETURN_CRITICAL
   1880          static int ssl_parse_server_psk_hint(mbedtls_ssl_context *ssl,
   1881                                               unsigned char **p,
   1882                                               unsigned char *end)
   1883          {
   1884              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1885              uint16_t  len;
   1886              ((void) ssl);
   1887          
   1888              /*
   1889               * PSK parameters:
   1890               *
   1891               * opaque psk_identity_hint<0..2^16-1>;
   1892               */
   1893              if (end - (*p) < 2) {
   1894                  MBEDTLS_SSL_DEBUG_MSG(1,
   1895                                        ("bad server key exchange message (psk_identity_hint length)"));
   1896                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1897              }
   1898              len = (*p)[0] << 8 | (*p)[1];
   1899              *p += 2;
   1900          
   1901              if (end - (*p) < len) {
   1902                  MBEDTLS_SSL_DEBUG_MSG(1,
   1903                                        ("bad server key exchange message (psk_identity_hint length)"));
   1904                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1905              }
   1906          
   1907              /*
   1908               * Note: we currently ignore the PSK identity hint, as we only allow one
   1909               * PSK to be provisioned on the client. This could be changed later if
   1910               * someone needs that feature.
   1911               */
   1912              *p += len;
   1913              ret = 0;
   1914          
   1915              return ret;
   1916          }
   1917          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
   1918          
   1919          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \
   1920              defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   1921          /*
   1922           * Generate a pre-master secret and encrypt it with the server's RSA key
   1923           */
   1924          MBEDTLS_CHECK_RETURN_CRITICAL
   1925          static int ssl_write_encrypted_pms(mbedtls_ssl_context *ssl,
   1926                                             size_t offset, size_t *olen,
   1927                                             size_t pms_offset)
   1928          {
   1929              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1930              size_t len_bytes = 2;
   1931              unsigned char *p = ssl->handshake->premaster + pms_offset;
   1932              mbedtls_pk_context *peer_pk;
   1933          
   1934              if (offset + len_bytes > MBEDTLS_SSL_OUT_CONTENT_LEN) {
   1935                  MBEDTLS_SSL_DEBUG_MSG(1, ("buffer too small for encrypted pms"));
   1936                  return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   1937              }
   1938          
   1939              /*
   1940               * Generate (part of) the pre-master as
   1941               *  struct {
   1942               *      ProtocolVersion client_version;
   1943               *      opaque random[46];
   1944               *  } PreMasterSecret;
   1945               */
   1946              mbedtls_ssl_write_version(p, ssl->conf->transport,
   1947                                        MBEDTLS_SSL_VERSION_TLS1_2);
   1948          
   1949              if ((ret = ssl->conf->f_rng(ssl->conf->p_rng, p + 2, 46)) != 0) {
   1950                  MBEDTLS_SSL_DEBUG_RET(1, "f_rng", ret);
   1951                  return ret;
   1952              }
   1953          
   1954              ssl->handshake->pmslen = 48;
   1955          
   1956          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   1957              peer_pk = &ssl->handshake->peer_pubkey;
   1958          #else /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   1959              if (ssl->session_negotiate->peer_cert == NULL) {
   1960                  /* Should never happen */
   1961                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   1962                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   1963              }
   1964              peer_pk = &ssl->session_negotiate->peer_cert->pk;
   1965          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   1966          
   1967              /*
   1968               * Now write it out, encrypted
   1969               */
   1970              if (!mbedtls_pk_can_do(peer_pk, MBEDTLS_PK_RSA)) {
   1971                  MBEDTLS_SSL_DEBUG_MSG(1, ("certificate key type mismatch"));
   1972                  return MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH;
   1973              }
   1974          
   1975              if ((ret = mbedtls_pk_encrypt(peer_pk,
   1976                                            p, ssl->handshake->pmslen,
   1977                                            ssl->out_msg + offset + len_bytes, olen,
   1978                                            MBEDTLS_SSL_OUT_CONTENT_LEN - offset - len_bytes,
   1979                                            ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   1980                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_rsa_pkcs1_encrypt", ret);
   1981                  return ret;
   1982              }
   1983          
   1984              if (len_bytes == 2) {
   1985                  MBEDTLS_PUT_UINT16_BE(*olen, ssl->out_msg, offset);
   1986                  *olen += 2;
   1987              }
   1988          
   1989          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   1990              /* We don't need the peer's public key anymore. Free it. */
   1991              mbedtls_pk_free(peer_pk);
   1992          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   1993              return 0;
   1994          }
   1995          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||
   1996                    MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   1997          
   1998          #if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
   1999              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   2000          MBEDTLS_CHECK_RETURN_CRITICAL
   2001          static int ssl_get_ecdh_params_from_cert(mbedtls_ssl_context *ssl)
   2002          {
   2003              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2004              mbedtls_pk_context *peer_pk;
   2005          
   2006          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   2007              peer_pk = &ssl->handshake->peer_pubkey;
   2008          #else /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2009              if (ssl->session_negotiate->peer_cert == NULL) {
   2010                  /* Should never happen */
   2011                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2012                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2013              }
   2014              peer_pk = &ssl->session_negotiate->peer_cert->pk;
   2015          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2016          
   2017              /* This is a public key, so it can't be opaque, so can_do() is a good
   2018               * enough check to ensure pk_ec() is safe to use below. */
   2019              if (!mbedtls_pk_can_do(peer_pk, MBEDTLS_PK_ECKEY)) {
   2020                  MBEDTLS_SSL_DEBUG_MSG(1, ("server key not ECDH capable"));
   2021                  return MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH;
   2022              }
   2023          
   2024          #if defined(MBEDTLS_ECP_C)
   2025              const mbedtls_ecp_keypair *peer_key = mbedtls_pk_ec_ro(*peer_pk);
   2026          #endif /* MBEDTLS_ECP_C */
   2027          
   2028          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2029              uint16_t tls_id = 0;
   2030              psa_key_type_t key_type = PSA_KEY_TYPE_NONE;
   2031              mbedtls_ecp_group_id grp_id = mbedtls_pk_get_group_id(peer_pk);
   2032          
   2033              if (mbedtls_ssl_check_curve(ssl, grp_id) != 0) {
   2034                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server certificate (ECDH curve)"));
   2035                  return MBEDTLS_ERR_SSL_BAD_CERTIFICATE;
   2036              }
   2037          
   2038              tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(grp_id);
   2039              if (tls_id == 0) {
   2040                  MBEDTLS_SSL_DEBUG_MSG(1, ("ECC group %u not suported",
   2041                                            grp_id));
   2042                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2043              }
   2044          
   2045              /* If the above conversion to TLS ID was fine, then also this one will be,
   2046                 so there is no need to check the return value here */
   2047              mbedtls_ssl_get_psa_curve_info_from_tls_id(tls_id, &key_type,
   2048                                                         &ssl->handshake->xxdh_psa_bits);
   2049          
   2050              ssl->handshake->xxdh_psa_type = key_type;
   2051          
   2052              /* Store peer's public key in psa format. */
   2053          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   2054              memcpy(ssl->handshake->xxdh_psa_peerkey, peer_pk->pub_raw, peer_pk->pub_raw_len);
   2055              ssl->handshake->xxdh_psa_peerkey_len = peer_pk->pub_raw_len;
   2056              ret = 0;
   2057          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   2058              size_t olen = 0;
   2059              ret = mbedtls_ecp_point_write_binary(&peer_key->grp, &peer_key->Q,
   2060                                                   MBEDTLS_ECP_PF_UNCOMPRESSED, &olen,
   2061                                                   ssl->handshake->xxdh_psa_peerkey,
   2062                                                   sizeof(ssl->handshake->xxdh_psa_peerkey));
   2063          
   2064              if (ret != 0) {
   2065                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ecp_point_write_binary"), ret);
   2066                  return ret;
   2067              }
   2068              ssl->handshake->xxdh_psa_peerkey_len = olen;
   2069          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   2070          #else /* MBEDTLS_USE_PSA_CRYPTO */
   2071              if ((ret = mbedtls_ecdh_get_params(&ssl->handshake->ecdh_ctx, peer_key,
   2072                                                 MBEDTLS_ECDH_THEIRS)) != 0) {
   2073                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ecdh_get_params"), ret);
   2074                  return ret;
   2075              }
   2076          
   2077              if (ssl_check_server_ecdh_params(ssl) != 0) {
   2078                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server certificate (ECDH curve)"));
   2079                  return MBEDTLS_ERR_SSL_BAD_CERTIFICATE;
   2080              }
   2081          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2082          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   2083              /* We don't need the peer's public key anymore. Free it,
   2084               * so that more RAM is available for upcoming expensive
   2085               * operations like ECDHE. */
   2086              mbedtls_pk_free(peer_pk);
   2087          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2088          
   2089              return ret;
   2090          }
   2091          #endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||
   2092                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   2093          
   2094          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   2095          static int ssl_parse_server_key_exchange(mbedtls_ssl_context *ssl)
   2096          {
   \                     ssl_parse_server_key_exchange: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB091             SUB      SP,SP,#+68
   \        0x6   0x4681             MOV      R9,R0
   2097              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x056D      MVNS     R5,#+109
   2098              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2099                  ssl->handshake->ciphersuite_info;
   \        0xC   0xF8D9 0x0038      LDR      R0,[R9, #+56]
   \       0x10   0x6887             LDR      R7,[R0, #+8]
   2100              unsigned char *p = NULL, *end = NULL;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9004             STR      R0,[SP, #+16]
   \       0x16   0xF05F 0x0800      MOVS     R8,#+0
   2101          
   2102              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse server key exchange"));
   2103          
   2104          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
   2105              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA) {
   2106                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse server key exchange"));
   2107                  ssl->state++;
   2108                  return 0;
   2109              }
   2110              ((void) p);
   2111              ((void) end);
   2112          #endif
   2113          
   2114          #if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
   2115              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   2116              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
   2117                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA) {
   2118                  if ((ret = ssl_get_ecdh_params_from_cert(ssl)) != 0) {
   2119                      MBEDTLS_SSL_DEBUG_RET(1, "ssl_get_ecdh_params_from_cert", ret);
   2120                      mbedtls_ssl_send_alert_message(
   2121                          ssl,
   2122                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2123                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   2124                      return ret;
   2125                  }
   2126          
   2127                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse server key exchange"));
   2128                  ssl->state++;
   2129                  return 0;
   2130              }
   2131              ((void) p);
   2132              ((void) end);
   2133          #endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
   2134                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   2135          
   2136          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2137              if (ssl->handshake->ecrs_enabled &&
   2138                  ssl->handshake->ecrs_state == ssl_ecrs_ske_start_processing) {
   2139                  goto start_processing;
   2140              }
   2141          #endif
   2142          
   2143              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x4648             MOV      R0,R9
   \       0x1E   0x.... 0x....      BL       mbedtls_ssl_read_record
   \       0x22   0x0004             MOVS     R4,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD001             BEQ.N    ??ssl_parse_server_key_exchange_0
   2144                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   2145                  return ret;
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0xE12E             B.N      ??ssl_parse_server_key_exchange_1
   2146              }
   2147          
   2148              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   \                     ??ssl_parse_server_key_exchange_0: (+1)
   \       0x2C   0xF8D9 0x0074      LDR      R0,[R9, #+116]
   \       0x30   0x2816             CMP      R0,#+22
   \       0x32   0xD007             BEQ.N    ??ssl_parse_server_key_exchange_2
   2149                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2150                  mbedtls_ssl_send_alert_message(
   2151                      ssl,
   2152                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2153                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   \       0x34   0x220A             MOVS     R2,#+10
   \       0x36   0x2102             MOVS     R1,#+2
   \       0x38   0x4648             MOV      R0,R9
   \       0x3A   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2154                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x42   0xE122             B.N      ??ssl_parse_server_key_exchange_1
   2155              }
   2156          
   2157              /*
   2158               * ServerKeyExchange may be skipped with PSK and RSA-PSK when the server
   2159               * doesn't use a psk_identity_hint
   2160               */
   2161              if (ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE) {
   \                     ??ssl_parse_server_key_exchange_2: (+1)
   \       0x44   0xF8D9 0x006C      LDR      R0,[R9, #+108]
   \       0x48   0x7800             LDRB     R0,[R0, #+0]
   \       0x4A   0x280C             CMP      R0,#+12
   \       0x4C   0xD011             BEQ.N    ??ssl_parse_server_key_exchange_3
   2162                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2163                      ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK) {
   \       0x4E   0x7AB8             LDRB     R0,[R7, #+10]
   \       0x50   0x2805             CMP      R0,#+5
   \       0x52   0xD002             BEQ.N    ??ssl_parse_server_key_exchange_4
   \       0x54   0x7AB8             LDRB     R0,[R7, #+10]
   \       0x56   0x2807             CMP      R0,#+7
   \       0x58   0xD103             BNE.N    ??ssl_parse_server_key_exchange_5
   2164                      /* Current message is probably either
   2165                       * CertificateRequest or ServerHelloDone */
   2166                      ssl->keep_current_message = 1;
   \                     ??ssl_parse_server_key_exchange_4: (+1)
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0xF8C9 0x0088      STR      R0,[R9, #+136]
   2167                      goto exit;
   \       0x60   0xE10D             B.N      ??ssl_parse_server_key_exchange_6
   2168                  }
   2169          
   2170                  MBEDTLS_SSL_DEBUG_MSG(1,
   2171                                        ("server key exchange message must not be skipped"));
   2172                  mbedtls_ssl_send_alert_message(
   2173                      ssl,
   2174                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2175                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   \                     ??ssl_parse_server_key_exchange_5: (+1)
   \       0x62   0x220A             MOVS     R2,#+10
   \       0x64   0x2102             MOVS     R1,#+2
   \       0x66   0x4648             MOV      R0,R9
   \       0x68   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2176          
   2177                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x70   0xE10B             B.N      ??ssl_parse_server_key_exchange_1
   2178              }
   2179          
   2180          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2181              if (ssl->handshake->ecrs_enabled) {
   2182                  ssl->handshake->ecrs_state = ssl_ecrs_ske_start_processing;
   2183              }
   2184          
   2185          start_processing:
   2186          #endif
   2187              p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
   \                     ??ssl_parse_server_key_exchange_3: (+1)
   \       0x72   0x4648             MOV      R0,R9
   \       0x74   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0x78   0xF8D9 0x106C      LDR      R1,[R9, #+108]
   \       0x7C   0x4408             ADD      R0,R1,R0
   \       0x7E   0x9004             STR      R0,[SP, #+16]
   2188              end = ssl->in_msg + ssl->in_hslen;
   \       0x80   0xF8D9 0x106C      LDR      R1,[R9, #+108]
   \       0x84   0xF8D9 0x0080      LDR      R0,[R9, #+128]
   \       0x88   0x4408             ADD      R0,R1,R0
   \       0x8A   0x4680             MOV      R8,R0
   2189              MBEDTLS_SSL_DEBUG_BUF(3,   "server key exchange", p, end - p);
   2190          
   2191          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   2192              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2193                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   2194                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   2195                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK) {
   2196                  if (ssl_parse_server_psk_hint(ssl, &p, end) != 0) {
   2197                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2198                      mbedtls_ssl_send_alert_message(
   2199                          ssl,
   2200                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2201                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2202                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2203                  }
   2204              } /* FALLTHROUGH */
   2205          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
   2206          
   2207          #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \
   2208              defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   2209              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2210                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK) {
   2211                  ; /* nothing more to do */
   2212              } else
   2213          #endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED ||
   2214                    MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   2215          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
   2216              defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   2217              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||
   2218                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK) {
   2219                  if (ssl_parse_server_dh_params(ssl, &p, end) != 0) {
   2220                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2221                      mbedtls_ssl_send_alert_message(
   2222                          ssl,
   2223                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2224                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   2225                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2226                  }
   2227              } else
   2228          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
   2229                    MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   2230          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||     \
   2231              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||     \
   2232              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   2233              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
   2234                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   2235                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) {
   \       0x8C   0x7AB8             LDRB     R0,[R7, #+10]
   \       0x8E   0x2803             CMP      R0,#+3
   \       0x90   0xD005             BEQ.N    ??ssl_parse_server_key_exchange_7
   \       0x92   0x7AB8             LDRB     R0,[R7, #+10]
   \       0x94   0x2808             CMP      R0,#+8
   \       0x96   0xD002             BEQ.N    ??ssl_parse_server_key_exchange_7
   \       0x98   0x7AB8             LDRB     R0,[R7, #+10]
   \       0x9A   0x2804             CMP      R0,#+4
   \       0x9C   0xD114             BNE.N    ??ssl_parse_server_key_exchange_8
   2236                  if (ssl_parse_server_ecdh_params(ssl, &p, end) != 0) {
   \                     ??ssl_parse_server_key_exchange_7: (+1)
   \       0x9E   0x4642             MOV      R2,R8
   \       0xA0   0xA904             ADD      R1,SP,#+16
   \       0xA2   0x4648             MOV      R0,R9
   \       0xA4   0x.... 0x....      BL       ssl_parse_server_ecdh_params
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD007             BEQ.N    ??ssl_parse_server_key_exchange_9
   2237                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2238                      mbedtls_ssl_send_alert_message(
   2239                          ssl,
   2240                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2241                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   \       0xAC   0x222F             MOVS     R2,#+47
   \       0xAE   0x2102             MOVS     R1,#+2
   \       0xB0   0x4648             MOV      R0,R9
   \       0xB2   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2242                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   \       0xB6   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0xBA   0xE0E6             B.N      ??ssl_parse_server_key_exchange_1
   2243                  }
   2244              } else
   2245          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
   2246                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||
   2247                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   2248          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2249              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
   2250          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2251                  /*
   2252                   * The first 3 bytes are:
   2253                   * [0] MBEDTLS_ECP_TLS_NAMED_CURVE
   2254                   * [1, 2] elliptic curve's TLS ID
   2255                   *
   2256                   * However since we only support secp256r1 for now, we check only
   2257                   * that TLS ID here
   2258                   */
   2259                  uint16_t read_tls_id = MBEDTLS_GET_UINT16_BE(p, 1);
   2260                  uint16_t exp_tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(
   2261                      MBEDTLS_ECP_DP_SECP256R1);
   2262          
   2263                  if (exp_tls_id == 0) {
   2264                      return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2265                  }
   2266          
   2267                  if ((*p != MBEDTLS_ECP_TLS_NAMED_CURVE) ||
   2268                      (read_tls_id != exp_tls_id)) {
   2269                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2270                  }
   2271          
   2272                  p += 3;
   2273          
   2274                  if ((ret = mbedtls_psa_ecjpake_read_round(
   2275                           &ssl->handshake->psa_pake_ctx, p, end - p,
   2276                           MBEDTLS_ECJPAKE_ROUND_TWO)) != 0) {
   2277                      psa_destroy_key(ssl->handshake->psa_pake_password);
   2278                      psa_pake_abort(&ssl->handshake->psa_pake_ctx);
   2279          
   2280                      MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_input round two", ret);
   2281                      mbedtls_ssl_send_alert_message(
   2282                          ssl,
   2283                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2284                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   2285                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   2286                  }
   2287          #else
   2288                  ret = mbedtls_ecjpake_read_round_two(&ssl->handshake->ecjpake_ctx,
   2289                                                       p, end - p);
   2290                  if (ret != 0) {
   2291                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_read_round_two", ret);
   2292                      mbedtls_ssl_send_alert_message(
   2293                          ssl,
   2294                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2295                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   2296                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   2297                  }
   2298          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2299              } else
   2300          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2301              {
   2302                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2303                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2304              }
   2305          
   2306          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
   2307              if (mbedtls_ssl_ciphersuite_uses_server_signature(ciphersuite_info)) {
   \                     ??ssl_parse_server_key_exchange_9: (+1)
   \       0xBC   0x0038             MOVS     R0,R7
   \       0xBE   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_uses_server_signature
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD103             BNE.N    ??ssl_parse_server_key_exchange_10
   \       0xC6   0xE0DA             B.N      ??ssl_parse_server_key_exchange_6
   \                     ??ssl_parse_server_key_exchange_8: (+1)
   \       0xC8   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \       0xCC   0xE0DD             B.N      ??ssl_parse_server_key_exchange_1
   2308                  size_t sig_len, hashlen;
   2309                  unsigned char hash[MBEDTLS_MD_MAX_SIZE];
   2310          
   2311                  mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
   \                     ??ssl_parse_server_key_exchange_10: (+1)
   \       0xCE   0x2000             MOVS     R0,#+0
   \       0xD0   0xF88D 0x000C      STRB     R0,[SP, #+12]
   2312                  mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0xF88D 0x000D      STRB     R0,[SP, #+13]
   2313                  unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
   \       0xDA   0x4648             MOV      R0,R9
   \       0xDC   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0xE0   0xF8D9 0x106C      LDR      R1,[R9, #+108]
   \       0xE4   0x4408             ADD      R0,R1,R0
   \       0xE6   0x9006             STR      R0,[SP, #+24]
   2314                  size_t params_len = p - params;
   \       0xE8   0xF8DD 0xA010      LDR      R10,[SP, #+16]
   \       0xEC   0x9806             LDR      R0,[SP, #+24]
   \       0xEE   0xEBBA 0x0A00      SUBS     R10,R10,R0
   2315                  void *rs_ctx = NULL;
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0x9008             STR      R0,[SP, #+32]
   2316                  uint16_t sig_alg;
   2317          
   2318                  mbedtls_pk_context *peer_pk;
   2319          
   2320          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   2321                  peer_pk = &ssl->handshake->peer_pubkey;
   2322          #else /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2323                  if (ssl->session_negotiate->peer_cert == NULL) {
   \       0xF6   0xF8D9 0x0034      LDR      R0,[R9, #+52]
   \       0xFA   0x6DC0             LDR      R0,[R0, #+92]
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD102             BNE.N    ??ssl_parse_server_key_exchange_11
   2324                      /* Should never happen */
   2325                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2326                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \      0x100   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \      0x104   0xE0C1             B.N      ??ssl_parse_server_key_exchange_1
   2327                  }
   2328                  peer_pk = &ssl->session_negotiate->peer_cert->pk;
   \                     ??ssl_parse_server_key_exchange_11: (+1)
   \      0x106   0xF8D9 0x0034      LDR      R0,[R9, #+52]
   \      0x10A   0x6DC0             LDR      R0,[R0, #+92]
   \      0x10C   0x30CC             ADDS     R0,R0,#+204
   \      0x10E   0x9005             STR      R0,[SP, #+20]
   2329          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2330          
   2331                  /*
   2332                   * Handle the digitally-signed structure
   2333                   */
   2334                  MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, 2);
   \      0x110   0x2202             MOVS     R2,#+2
   \      0x112   0x4641             MOV      R1,R8
   \      0x114   0x9804             LDR      R0,[SP, #+16]
   \      0x116   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD008             BEQ.N    ??ssl_parse_server_key_exchange_12
   \      0x11E   0x.... 0x....      LDR.W    R5,??DataTable13_2
   \      0x122   0x002A             MOVS     R2,R5
   \      0x124   0x2132             MOVS     R1,#+50
   \      0x126   0x4648             MOV      R0,R9
   \      0x128   0x.... 0x....      BL       mbedtls_ssl_pend_fatal_alert
   \      0x12C   0x0028             MOVS     R0,R5
   \      0x12E   0xE0AC             B.N      ??ssl_parse_server_key_exchange_1
   2335                  sig_alg = MBEDTLS_GET_UINT16_BE(p, 0);
   \                     ??ssl_parse_server_key_exchange_12: (+1)
   \      0x130   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \      0x134   0x7800             LDRB     R0,[R0, #+0]
   \      0x136   0x2801             CMP      R0,#+1
   \      0x138   0xD103             BNE.N    ??ssl_parse_server_key_exchange_13
   \      0x13A   0x9804             LDR      R0,[SP, #+16]
   \      0x13C   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \      0x140   0xE005             B.N      ??ssl_parse_server_key_exchange_14
   \                     ??ssl_parse_server_key_exchange_13: (+1)
   \      0x142   0x9804             LDR      R0,[SP, #+16]
   \      0x144   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \      0x148   0xB280             UXTH     R0,R0
   \      0x14A   0x.... 0x....      BL       mbedtls_bswap16
   \                     ??ssl_parse_server_key_exchange_14: (+1)
   \      0x14E   0x0005             MOVS     R5,R0
   2336                  if (mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
   2337                          sig_alg, &pk_alg, &md_alg) != 0 &&
   2338                      !mbedtls_ssl_sig_alg_is_offered(ssl, sig_alg) &&
   2339                      !mbedtls_ssl_sig_alg_is_supported(ssl, sig_alg)) {
   \      0x150   0xAA03             ADD      R2,SP,#+12
   \      0x152   0xF10D 0x010D      ADD      R1,SP,#+13
   \      0x156   0x0028             MOVS     R0,R5
   \      0x158   0xB280             UXTH     R0,R0
   \      0x15A   0x.... 0x....      BL       mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg
   \      0x15E   0x2800             CMP      R0,#+0
   \      0x160   0xD015             BEQ.N    ??ssl_parse_server_key_exchange_15
   \      0x162   0x0029             MOVS     R1,R5
   \      0x164   0xB289             UXTH     R1,R1
   \      0x166   0x4648             MOV      R0,R9
   \      0x168   0x.... 0x....      BL       mbedtls_ssl_sig_alg_is_offered
   \      0x16C   0x2800             CMP      R0,#+0
   \      0x16E   0xD10E             BNE.N    ??ssl_parse_server_key_exchange_15
   \      0x170   0x0029             MOVS     R1,R5
   \      0x172   0xB289             UXTH     R1,R1
   \      0x174   0x4648             MOV      R0,R9
   \      0x176   0x.... 0x....      BL       mbedtls_ssl_sig_alg_is_supported
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xD107             BNE.N    ??ssl_parse_server_key_exchange_15
   2340                      MBEDTLS_SSL_DEBUG_MSG(1,
   2341                                            ("bad server key exchange message"));
   2342                      mbedtls_ssl_send_alert_message(
   2343                          ssl,
   2344                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2345                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   \      0x17E   0x222F             MOVS     R2,#+47
   \      0x180   0x2102             MOVS     R1,#+2
   \      0x182   0x4648             MOV      R0,R9
   \      0x184   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2346                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   \      0x188   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \      0x18C   0xE07D             B.N      ??ssl_parse_server_key_exchange_1
   2347                  }
   2348                  p += 2;
   \                     ??ssl_parse_server_key_exchange_15: (+1)
   \      0x18E   0x9804             LDR      R0,[SP, #+16]
   \      0x190   0x1C80             ADDS     R0,R0,#+2
   \      0x192   0x9004             STR      R0,[SP, #+16]
   2349          
   2350                  if (!mbedtls_pk_can_do(peer_pk, pk_alg)) {
   \      0x194   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \      0x198   0x9805             LDR      R0,[SP, #+20]
   \      0x19A   0x.... 0x....      BL       mbedtls_pk_can_do
   \      0x19E   0x2800             CMP      R0,#+0
   \      0x1A0   0xD107             BNE.N    ??ssl_parse_server_key_exchange_16
   2351                      MBEDTLS_SSL_DEBUG_MSG(1,
   2352                                            ("bad server key exchange message"));
   2353                      mbedtls_ssl_send_alert_message(
   2354                          ssl,
   2355                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2356                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   \      0x1A2   0x222F             MOVS     R2,#+47
   \      0x1A4   0x2102             MOVS     R1,#+2
   \      0x1A6   0x4648             MOV      R0,R9
   \      0x1A8   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2357                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   \      0x1AC   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \      0x1B0   0xE06B             B.N      ??ssl_parse_server_key_exchange_1
   2358                  }
   2359          
   2360                  /*
   2361                   * Read signature
   2362                   */
   2363          
   2364                  if (p > end - 2) {
   \                     ??ssl_parse_server_key_exchange_16: (+1)
   \      0x1B2   0xF1B8 0x0102      SUBS     R1,R8,#+2
   \      0x1B6   0x9804             LDR      R0,[SP, #+16]
   \      0x1B8   0x4281             CMP      R1,R0
   \      0x1BA   0xD207             BCS.N    ??ssl_parse_server_key_exchange_17
   2365                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2366                      mbedtls_ssl_send_alert_message(
   2367                          ssl,
   2368                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2369                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \      0x1BC   0x2232             MOVS     R2,#+50
   \      0x1BE   0x2102             MOVS     R1,#+2
   \      0x1C0   0x4648             MOV      R0,R9
   \      0x1C2   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2370                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \      0x1C6   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \      0x1CA   0xE05E             B.N      ??ssl_parse_server_key_exchange_1
   2371                  }
   2372                  sig_len = (p[0] << 8) | p[1];
   \                     ??ssl_parse_server_key_exchange_17: (+1)
   \      0x1CC   0x9804             LDR      R0,[SP, #+16]
   \      0x1CE   0x7800             LDRB     R0,[R0, #+0]
   \      0x1D0   0x9904             LDR      R1,[SP, #+16]
   \      0x1D2   0xF891 0xB001      LDRB     R11,[R1, #+1]
   \      0x1D6   0xEA5B 0x2B00      ORRS     R11,R11,R0, LSL #+8
   2373                  p += 2;
   \      0x1DA   0x9804             LDR      R0,[SP, #+16]
   \      0x1DC   0x1C80             ADDS     R0,R0,#+2
   \      0x1DE   0x9004             STR      R0,[SP, #+16]
   2374          
   2375                  if (p != end - sig_len) {
   \      0x1E0   0x9804             LDR      R0,[SP, #+16]
   \      0x1E2   0xF1DB 0x0100      RSBS     R1,R11,#+0
   \      0x1E6   0x4441             ADD      R1,R8,R1
   \      0x1E8   0x4288             CMP      R0,R1
   \      0x1EA   0xD007             BEQ.N    ??ssl_parse_server_key_exchange_18
   2376                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2377                      mbedtls_ssl_send_alert_message(
   2378                          ssl,
   2379                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2380                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \      0x1EC   0x2232             MOVS     R2,#+50
   \      0x1EE   0x2102             MOVS     R1,#+2
   \      0x1F0   0x4648             MOV      R0,R9
   \      0x1F2   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2381                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \      0x1F6   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \      0x1FA   0xE046             B.N      ??ssl_parse_server_key_exchange_1
   2382                  }
   2383          
   2384                  MBEDTLS_SSL_DEBUG_BUF(3, "signature", p, sig_len);
   2385          
   2386                  /*
   2387                   * Compute the hash that has been signed
   2388                   */
   2389                  if (md_alg != MBEDTLS_MD_NONE) {
   \                     ??ssl_parse_server_key_exchange_18: (+1)
   \      0x1FC   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0x200   0x2800             CMP      R0,#+0
   \      0x202   0xD017             BEQ.N    ??ssl_parse_server_key_exchange_19
   2390                      ret = mbedtls_ssl_get_key_exchange_md_tls1_2(ssl, hash, &hashlen,
   2391                                                                   params, params_len,
   2392                                                                   md_alg);
   \      0x204   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0x208   0x9001             STR      R0,[SP, #+4]
   \      0x20A   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \      0x20E   0x9B06             LDR      R3,[SP, #+24]
   \      0x210   0xAA07             ADD      R2,SP,#+28
   \      0x212   0xA909             ADD      R1,SP,#+36
   \      0x214   0x4648             MOV      R0,R9
   \      0x216   0x.... 0x....      BL       mbedtls_ssl_get_key_exchange_md_tls1_2
   \      0x21A   0x0006             MOVS     R6,R0
   2393                      if (ret != 0) {
   \      0x21C   0x2E00             CMP      R6,#+0
   \      0x21E   0xD001             BEQ.N    ??ssl_parse_server_key_exchange_20
   2394                          return ret;
   \      0x220   0x0030             MOVS     R0,R6
   \      0x222   0xE032             B.N      ??ssl_parse_server_key_exchange_1
   2395                      }
   2396                  } else {
   2397                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2398                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2399                  }
   2400          
   2401                  MBEDTLS_SSL_DEBUG_BUF(3, "parameters hash", hash, hashlen);
   2402          
   2403                  /*
   2404                   * Verify signature
   2405                   */
   2406                  if (!mbedtls_pk_can_do(peer_pk, pk_alg)) {
   \                     ??ssl_parse_server_key_exchange_20: (+1)
   \      0x224   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \      0x228   0x9805             LDR      R0,[SP, #+20]
   \      0x22A   0x.... 0x....      BL       mbedtls_pk_can_do
   \      0x22E   0x2800             CMP      R0,#+0
   \      0x230   0xD10B             BNE.N    ??ssl_parse_server_key_exchange_21
   \      0x232   0xE002             B.N      ??ssl_parse_server_key_exchange_22
   \                     ??ssl_parse_server_key_exchange_19: (+1)
   \      0x234   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \      0x238   0xE027             B.N      ??ssl_parse_server_key_exchange_1
   2407                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2408                      mbedtls_ssl_send_alert_message(
   2409                          ssl,
   2410                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2411                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   \                     ??ssl_parse_server_key_exchange_22: (+1)
   \      0x23A   0x2228             MOVS     R2,#+40
   \      0x23C   0x2102             MOVS     R1,#+2
   \      0x23E   0x4648             MOV      R0,R9
   \      0x240   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2412                      return MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH;
   \      0x244   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \      0x248   0xE01F             B.N      ??ssl_parse_server_key_exchange_1
   2413                  }
   2414          
   2415          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2416                  if (ssl->handshake->ecrs_enabled) {
   2417                      rs_ctx = &ssl->handshake->ecrs_ctx.pk;
   2418                  }
   2419          #endif
   2420          
   2421          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
   2422                  if (pk_alg == MBEDTLS_PK_RSASSA_PSS) {
   2423                      mbedtls_pk_rsassa_pss_options rsassa_pss_options;
   2424                      rsassa_pss_options.mgf1_hash_id = md_alg;
   2425                      rsassa_pss_options.expected_salt_len =
   2426                          mbedtls_md_get_size_from_type(md_alg);
   2427                      if (rsassa_pss_options.expected_salt_len == 0) {
   2428                          return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2429                      }
   2430          
   2431                      ret = mbedtls_pk_verify_ext(pk_alg, &rsassa_pss_options,
   2432                                                  peer_pk,
   2433                                                  md_alg, hash, hashlen,
   2434                                                  p, sig_len);
   2435                  } else
   2436          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
   2437                  ret = mbedtls_pk_verify_restartable(peer_pk,
   2438                                                      md_alg, hash, hashlen, p, sig_len, rs_ctx);
   \                     ??ssl_parse_server_key_exchange_21: (+1)
   \      0x24A   0x9808             LDR      R0,[SP, #+32]
   \      0x24C   0x9002             STR      R0,[SP, #+8]
   \      0x24E   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \      0x252   0x9804             LDR      R0,[SP, #+16]
   \      0x254   0x9000             STR      R0,[SP, #+0]
   \      0x256   0x9B07             LDR      R3,[SP, #+28]
   \      0x258   0xAA09             ADD      R2,SP,#+36
   \      0x25A   0xF89D 0x100C      LDRB     R1,[SP, #+12]
   \      0x25E   0x9805             LDR      R0,[SP, #+20]
   \      0x260   0x.... 0x....      BL       mbedtls_pk_verify_restartable
   \      0x264   0x0004             MOVS     R4,R0
   2439          
   2440                  if (ret != 0) {
   \      0x266   0x2C00             CMP      R4,#+0
   \      0x268   0xD009             BEQ.N    ??ssl_parse_server_key_exchange_6
   2441                      int send_alert_msg = 1;
   \      0x26A   0x2601             MOVS     R6,#+1
   2442          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2443                      send_alert_msg = (ret != MBEDTLS_ERR_ECP_IN_PROGRESS);
   2444          #endif
   2445                      if (send_alert_msg) {
   \      0x26C   0x2E00             CMP      R6,#+0
   \      0x26E   0xD004             BEQ.N    ??ssl_parse_server_key_exchange_23
   2446                          mbedtls_ssl_send_alert_message(
   2447                              ssl,
   2448                              MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2449                              MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR);
   \      0x270   0x2233             MOVS     R2,#+51
   \      0x272   0x2102             MOVS     R1,#+2
   \      0x274   0x4648             MOV      R0,R9
   \      0x276   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2450                      }
   2451                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_pk_verify", ret);
   2452          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2453                      if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2454                          ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   2455                      }
   2456          #endif
   2457                      return ret;
   \                     ??ssl_parse_server_key_exchange_23: (+1)
   \      0x27A   0x0020             MOVS     R0,R4
   \      0x27C   0xE005             B.N      ??ssl_parse_server_key_exchange_1
   2458                  }
   2459          
   2460          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   2461                  /* We don't need the peer's public key anymore. Free it,
   2462                   * so that more RAM is available for upcoming expensive
   2463                   * operations like ECDHE. */
   2464                  mbedtls_pk_free(peer_pk);
   2465          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2466              }
   2467          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED */
   2468          
   2469          exit:
   2470              ssl->state++;
   \                     ??ssl_parse_server_key_exchange_6: (+1)
   \      0x27E   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x282   0x1C40             ADDS     R0,R0,#+1
   \      0x284   0xF8C9 0x0004      STR      R0,[R9, #+4]
   2471          
   2472              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse server key exchange"));
   2473          
   2474              return 0;
   \      0x288   0x2000             MOVS     R0,#+0
   \                     ??ssl_parse_server_key_exchange_1: (+1)
   \      0x28A   0xB011             ADD      SP,SP,#+68
   \      0x28C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2475          }
   2476          
   2477          #if !defined(MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED)
   2478          MBEDTLS_CHECK_RETURN_CRITICAL
   2479          static int ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
   2480          {
   2481              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2482                  ssl->handshake->ciphersuite_info;
   2483          
   2484              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse certificate request"));
   2485          
   2486              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   2487                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate request"));
   2488                  ssl->state++;
   2489                  return 0;
   2490              }
   2491          
   2492              MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2493              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2494          }
   2495          #else /* MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   2496          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   2497          static int ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
   2498          {
   \                     ssl_parse_certificate_request: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   2499              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x056D      MVNS     R5,#+109
   2500              unsigned char *buf;
   2501              size_t n = 0;
   \        0xA   0x2600             MOVS     R6,#+0
   2502              size_t cert_type_len = 0, dn_len = 0;
   \        0xC   0x2700             MOVS     R7,#+0
   \        0xE   0xF05F 0x0800      MOVS     R8,#+0
   2503              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2504                  ssl->handshake->ciphersuite_info;
   \       0x12   0x6BA0             LDR      R0,[R4, #+56]
   \       0x14   0xF8D0 0x9008      LDR      R9,[R0, #+8]
   2505              size_t sig_alg_len;
   2506          #if defined(MBEDTLS_DEBUG_C)
   2507              unsigned char *sig_alg;
   2508              unsigned char *dn;
   2509          #endif
   2510          
   2511              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse certificate request"));
   2512          
   2513              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   \       0x18   0x4648             MOV      R0,R9
   \       0x1A   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_cert_req_allowed
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD104             BNE.N    ??ssl_parse_certificate_request_0
   2514                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate request"));
   2515                  ssl->state++;
   \       0x22   0x6860             LDR      R0,[R4, #+4]
   \       0x24   0x1C40             ADDS     R0,R0,#+1
   \       0x26   0x6060             STR      R0,[R4, #+4]
   2516                  return 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE09E             B.N      ??ssl_parse_certificate_request_1
   2517              }
   2518          
   2519              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   \                     ??ssl_parse_certificate_request_0: (+1)
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       mbedtls_ssl_read_record
   \       0x34   0x4682             MOV      R10,R0
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD001             BEQ.N    ??ssl_parse_certificate_request_2
   2520                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   2521                  return ret;
   \       0x3A   0x4650             MOV      R0,R10
   \       0x3C   0xE095             B.N      ??ssl_parse_certificate_request_1
   2522              }
   2523          
   2524              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   \                     ??ssl_parse_certificate_request_2: (+1)
   \       0x3E   0x6F60             LDR      R0,[R4, #+116]
   \       0x40   0x2816             CMP      R0,#+22
   \       0x42   0xD007             BEQ.N    ??ssl_parse_certificate_request_3
   2525                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2526                  mbedtls_ssl_send_alert_message(
   2527                      ssl,
   2528                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2529                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   \       0x44   0x220A             MOVS     R2,#+10
   \       0x46   0x2102             MOVS     R1,#+2
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2530                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x52   0xE08A             B.N      ??ssl_parse_certificate_request_1
   2531              }
   2532          
   2533              ssl->state++;
   \                     ??ssl_parse_certificate_request_3: (+1)
   \       0x54   0x6860             LDR      R0,[R4, #+4]
   \       0x56   0x1C40             ADDS     R0,R0,#+1
   \       0x58   0x6060             STR      R0,[R4, #+4]
   2534              ssl->handshake->client_auth =
   2535                  (ssl->in_msg[0] == MBEDTLS_SSL_HS_CERTIFICATE_REQUEST);
   \       0x5A   0x6EE0             LDR      R0,[R4, #+108]
   \       0x5C   0x7800             LDRB     R0,[R0, #+0]
   \       0x5E   0x280D             CMP      R0,#+13
   \       0x60   0xD101             BNE.N    ??ssl_parse_certificate_request_4
   \       0x62   0x2101             MOVS     R1,#+1
   \       0x64   0xE000             B.N      ??ssl_parse_certificate_request_5
   \                     ??ssl_parse_certificate_request_4: (+1)
   \       0x66   0x2100             MOVS     R1,#+0
   \                     ??ssl_parse_certificate_request_5: (+1)
   \       0x68   0x6BA0             LDR      R0,[R4, #+56]
   \       0x6A   0xF880 0x11CC      STRB     R1,[R0, #+460]
   2536          
   2537              MBEDTLS_SSL_DEBUG_MSG(3, ("got %s certificate request",
   2538                                        ssl->handshake->client_auth ? "a" : "no"));
   2539          
   2540              if (ssl->handshake->client_auth == 0) {
   \       0x6E   0x6BA0             LDR      R0,[R4, #+56]
   \       0x70   0xF890 0x01CC      LDRB     R0,[R0, #+460]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD103             BNE.N    ??ssl_parse_certificate_request_6
   2541                  /* Current message is probably the ServerHelloDone */
   2542                  ssl->keep_current_message = 1;
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0xF8C4 0x0088      STR      R0,[R4, #+136]
   2543                  goto exit;
   \       0x7E   0xE073             B.N      ??ssl_parse_certificate_request_7
   2544              }
   2545          
   2546              /*
   2547               *  struct {
   2548               *      ClientCertificateType certificate_types<1..2^8-1>;
   2549               *      SignatureAndHashAlgorithm
   2550               *        supported_signature_algorithms<2^16-1>; -- TLS 1.2 only
   2551               *      DistinguishedName certificate_authorities<0..2^16-1>;
   2552               *  } CertificateRequest;
   2553               *
   2554               *  Since we only support a single certificate on clients, let's just
   2555               *  ignore all the information that's supposed to help us pick a
   2556               *  certificate.
   2557               *
   2558               *  We could check that our certificate matches the request, and bail out
   2559               *  if it doesn't, but it's simpler to just send the certificate anyway,
   2560               *  and give the server the opportunity to decide if it should terminate
   2561               *  the connection when it doesn't like our certificate.
   2562               *
   2563               *  Same goes for the hash in TLS 1.2's signature_algorithms: at this
   2564               *  point we only have one hash available (see comments in
   2565               *  write_certificate_verify), so let's just use what we have.
   2566               *
   2567               *  However, we still minimally parse the message to check it is at least
   2568               *  superficially sane.
   2569               */
   2570              buf = ssl->in_msg;
   \                     ??ssl_parse_certificate_request_6: (+1)
   \       0x80   0x6EE0             LDR      R0,[R4, #+108]
   \       0x82   0x4683             MOV      R11,R0
   2571          
   2572              /* certificate_types */
   2573              if (ssl->in_hslen <= mbedtls_ssl_hs_hdr_len(ssl)) {
   \       0x84   0x0020             MOVS     R0,R4
   \       0x86   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0x8A   0xF8D4 0x1080      LDR      R1,[R4, #+128]
   \       0x8E   0x4288             CMP      R0,R1
   \       0x90   0xD307             BCC.N    ??ssl_parse_certificate_request_8
   2574                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2575                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2576                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \       0x92   0x2232             MOVS     R2,#+50
   \       0x94   0x2102             MOVS     R1,#+2
   \       0x96   0x0020             MOVS     R0,R4
   \       0x98   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2577                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0xA0   0xE063             B.N      ??ssl_parse_certificate_request_1
   2578              }
   2579              cert_type_len = buf[mbedtls_ssl_hs_hdr_len(ssl)];
   \                     ??ssl_parse_certificate_request_8: (+1)
   \       0xA2   0x0020             MOVS     R0,R4
   \       0xA4   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0xA8   0xF81B 0x0000      LDRB     R0,[R11, R0]
   \       0xAC   0x0007             MOVS     R7,R0
   2580              n = cert_type_len;
   \       0xAE   0x003D             MOVS     R5,R7
   2581          
   2582              /*
   2583               * In the subsequent code there are two paths that read from buf:
   2584               *     * the length of the signature algorithms field (if minor version of
   2585               *       SSL is 3),
   2586               *     * distinguished name length otherwise.
   2587               * Both reach at most the index:
   2588               *    ...hdr_len + 2 + n,
   2589               * therefore the buffer length at this point must be greater than that
   2590               * regardless of the actual code path.
   2591               */
   2592              if (ssl->in_hslen <= mbedtls_ssl_hs_hdr_len(ssl) + 2 + n) {
   \       0xB0   0x0020             MOVS     R0,R4
   \       0xB2   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0xB6   0x1828             ADDS     R0,R5,R0
   \       0xB8   0x1C80             ADDS     R0,R0,#+2
   \       0xBA   0xF8D4 0x1080      LDR      R1,[R4, #+128]
   \       0xBE   0x4288             CMP      R0,R1
   \       0xC0   0xD307             BCC.N    ??ssl_parse_certificate_request_9
   2593                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2594                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2595                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \       0xC2   0x2232             MOVS     R2,#+50
   \       0xC4   0x2102             MOVS     R1,#+2
   \       0xC6   0x0020             MOVS     R0,R4
   \       0xC8   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2596                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \       0xCC   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0xD0   0xE04B             B.N      ??ssl_parse_certificate_request_1
   2597              }
   2598          
   2599              /* supported_signature_algorithms */
   2600              sig_alg_len = ((buf[mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] <<  8)
   2601                             | (buf[mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
   \                     ??ssl_parse_certificate_request_9: (+1)
   \       0xD2   0x0020             MOVS     R0,R4
   \       0xD4   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0xD8   0x0006             MOVS     R6,R0
   \       0xDA   0x0020             MOVS     R0,R4
   \       0xDC   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0xE0   0x19AE             ADDS     R6,R5,R6
   \       0xE2   0xEB0B 0x0106      ADD      R1,R11,R6
   \       0xE6   0x7849             LDRB     R1,[R1, #+1]
   \       0xE8   0x1828             ADDS     R0,R5,R0
   \       0xEA   0x4458             ADD      R0,R11,R0
   \       0xEC   0x7880             LDRB     R0,[R0, #+2]
   \       0xEE   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \       0xF2   0x9000             STR      R0,[SP, #+0]
   2602          
   2603              /*
   2604               * The furthest access in buf is in the loop few lines below:
   2605               *     sig_alg[i + 1],
   2606               * where:
   2607               *     sig_alg = buf + ...hdr_len + 3 + n,
   2608               *     max(i) = sig_alg_len - 1.
   2609               * Therefore the furthest access is:
   2610               *     buf[...hdr_len + 3 + n + sig_alg_len - 1 + 1],
   2611               * which reduces to:
   2612               *     buf[...hdr_len + 3 + n + sig_alg_len],
   2613               * which is one less than we need the buf to be.
   2614               */
   2615              if (ssl->in_hslen <= mbedtls_ssl_hs_hdr_len(ssl) + 3 + n + sig_alg_len) {
   \       0xF4   0x0020             MOVS     R0,R4
   \       0xF6   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0xFA   0x1828             ADDS     R0,R5,R0
   \       0xFC   0x9900             LDR      R1,[SP, #+0]
   \       0xFE   0x1808             ADDS     R0,R1,R0
   \      0x100   0x1CC0             ADDS     R0,R0,#+3
   \      0x102   0xF8D4 0x1080      LDR      R1,[R4, #+128]
   \      0x106   0x4288             CMP      R0,R1
   \      0x108   0xD307             BCC.N    ??ssl_parse_certificate_request_10
   2616                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2617                  mbedtls_ssl_send_alert_message(
   2618                      ssl,
   2619                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2620                      MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \      0x10A   0x2232             MOVS     R2,#+50
   \      0x10C   0x2102             MOVS     R1,#+2
   \      0x10E   0x0020             MOVS     R0,R4
   \      0x110   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2621                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \      0x114   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \      0x118   0xE027             B.N      ??ssl_parse_certificate_request_1
   2622              }
   2623          
   2624          #if defined(MBEDTLS_DEBUG_C)
   2625              sig_alg = buf + mbedtls_ssl_hs_hdr_len(ssl) + 3 + n;
   2626              for (size_t i = 0; i < sig_alg_len; i += 2) {
   2627                  MBEDTLS_SSL_DEBUG_MSG(3,
   2628                                        ("Supported Signature Algorithm found: %02x %02x",
   2629                                         sig_alg[i], sig_alg[i + 1]));
   2630              }
   2631          #endif
   2632          
   2633              n += 2 + sig_alg_len;
   \                     ??ssl_parse_certificate_request_10: (+1)
   \      0x11A   0x9800             LDR      R0,[SP, #+0]
   \      0x11C   0x1945             ADDS     R5,R0,R5
   \      0x11E   0x1CAD             ADDS     R5,R5,#+2
   \      0x120   0x002E             MOVS     R6,R5
   2634          
   2635              /* certificate_authorities */
   2636              dn_len = ((buf[mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] <<  8)
   2637                        | (buf[mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
   \      0x122   0x0020             MOVS     R0,R4
   \      0x124   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \      0x128   0x0005             MOVS     R5,R0
   \      0x12A   0x0020             MOVS     R0,R4
   \      0x12C   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \      0x130   0x1975             ADDS     R5,R6,R5
   \      0x132   0xEB0B 0x0105      ADD      R1,R11,R5
   \      0x136   0x7849             LDRB     R1,[R1, #+1]
   \      0x138   0x1830             ADDS     R0,R6,R0
   \      0x13A   0x4458             ADD      R0,R11,R0
   \      0x13C   0x7880             LDRB     R0,[R0, #+2]
   \      0x13E   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \      0x142   0x4680             MOV      R8,R0
   2638          
   2639              n += dn_len;
   \      0x144   0xEB18 0x0606      ADDS     R6,R8,R6
   2640              if (ssl->in_hslen != mbedtls_ssl_hs_hdr_len(ssl) + 3 + n) {
   \      0x148   0x0020             MOVS     R0,R4
   \      0x14A   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \      0x14E   0xF8D4 0x1080      LDR      R1,[R4, #+128]
   \      0x152   0x1830             ADDS     R0,R6,R0
   \      0x154   0x1CC0             ADDS     R0,R0,#+3
   \      0x156   0x4281             CMP      R1,R0
   \      0x158   0xD006             BEQ.N    ??ssl_parse_certificate_request_7
   2641                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2642                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2643                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \      0x15A   0x2232             MOVS     R2,#+50
   \      0x15C   0x2102             MOVS     R1,#+2
   \      0x15E   0x0020             MOVS     R0,R4
   \      0x160   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2644                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \      0x164   0x....             LDR.N    R0,??DataTable13_2
   \      0x166   0xE000             B.N      ??ssl_parse_certificate_request_1
   2645              }
   2646          
   2647          #if defined(MBEDTLS_DEBUG_C)
   2648              dn = buf + mbedtls_ssl_hs_hdr_len(ssl) + 3 + n - dn_len;
   2649              for (size_t i = 0, dni_len = 0; i < dn_len; i += 2 + dni_len) {
   2650                  unsigned char *p = dn + i + 2;
   2651                  mbedtls_x509_name name;
   2652                  size_t asn1_len;
   2653                  char s[MBEDTLS_X509_MAX_DN_NAME_SIZE];
   2654                  memset(&name, 0, sizeof(name));
   2655                  dni_len = MBEDTLS_GET_UINT16_BE(dn + i, 0);
   2656                  if (dni_len > dn_len - i - 2 ||
   2657                      mbedtls_asn1_get_tag(&p, p + dni_len, &asn1_len,
   2658                                           MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE) != 0 ||
   2659                      mbedtls_x509_get_name(&p, p + asn1_len, &name) != 0) {
   2660                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2661                      mbedtls_ssl_send_alert_message(
   2662                          ssl,
   2663                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2664                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2665                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2666                  }
   2667                  MBEDTLS_SSL_DEBUG_MSG(3,
   2668                                        ("DN hint: %.*s",
   2669                                         mbedtls_x509_dn_gets(s, sizeof(s), &name), s));
   2670                  mbedtls_asn1_free_named_data_list_shallow(name.next);
   2671              }
   2672          #endif
   2673          
   2674          exit:
   2675              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse certificate request"));
   2676          
   2677              return 0;
   \                     ??ssl_parse_certificate_request_7: (+1)
   \      0x168   0x2000             MOVS     R0,#+0
   \                     ??ssl_parse_certificate_request_1: (+1)
   \      0x16A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   2678          }
   2679          #endif /* MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   2680          
   2681          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   2682          static int ssl_parse_server_hello_done(mbedtls_ssl_context *ssl)
   2683          {
   \                     ssl_parse_server_hello_done: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2684              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x066D      MVNS     R6,#+109
   2685          
   2686              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse server hello done"));
   2687          
   2688              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       mbedtls_ssl_read_record
   \       0x10   0x0005             MOVS     R5,R0
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD001             BEQ.N    ??ssl_parse_server_hello_done_0
   2689                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   2690                  return ret;
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0xE01B             B.N      ??ssl_parse_server_hello_done_1
   2691              }
   2692          
   2693              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   \                     ??ssl_parse_server_hello_done_0: (+1)
   \       0x1A   0x6F60             LDR      R0,[R4, #+116]
   \       0x1C   0x2816             CMP      R0,#+22
   \       0x1E   0xD002             BEQ.N    ??ssl_parse_server_hello_done_2
   2694                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello done message"));
   2695                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x24   0xE015             B.N      ??ssl_parse_server_hello_done_1
   2696              }
   2697          
   2698              if (ssl->in_hslen  != mbedtls_ssl_hs_hdr_len(ssl) ||
   2699                  ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO_DONE) {
   \                     ??ssl_parse_server_hello_done_2: (+1)
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       mbedtls_ssl_hs_hdr_len
   \       0x2C   0xF8D4 0x1080      LDR      R1,[R4, #+128]
   \       0x30   0x4281             CMP      R1,R0
   \       0x32   0xD103             BNE.N    ??ssl_parse_server_hello_done_3
   \       0x34   0x6EE0             LDR      R0,[R4, #+108]
   \       0x36   0x7800             LDRB     R0,[R0, #+0]
   \       0x38   0x280E             CMP      R0,#+14
   \       0x3A   0xD006             BEQ.N    ??ssl_parse_server_hello_done_4
   2700                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello done message"));
   2701                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2702                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \                     ??ssl_parse_server_hello_done_3: (+1)
   \       0x3C   0x2232             MOVS     R2,#+50
   \       0x3E   0x2102             MOVS     R1,#+2
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   2703                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   \       0x46   0x....             LDR.N    R0,??DataTable13_2
   \       0x48   0xE003             B.N      ??ssl_parse_server_hello_done_1
   2704              }
   2705          
   2706              ssl->state++;
   \                     ??ssl_parse_server_hello_done_4: (+1)
   \       0x4A   0x6860             LDR      R0,[R4, #+4]
   \       0x4C   0x1C40             ADDS     R0,R0,#+1
   \       0x4E   0x6060             STR      R0,[R4, #+4]
   2707          
   2708          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2709              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   2710                  mbedtls_ssl_recv_flight_completed(ssl);
   2711              }
   2712          #endif
   2713          
   2714              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse server hello done"));
   2715          
   2716              return 0;
   \       0x50   0x2000             MOVS     R0,#+0
   \                     ??ssl_parse_server_hello_done_1: (+1)
   \       0x52   0xBD70             POP      {R4-R6,PC}
   2717          }
   2718          
   2719          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   2720          static int ssl_write_client_key_exchange(mbedtls_ssl_context *ssl)
   2721          {
   \                     ssl_write_client_key_exchange: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB091             SUB      SP,SP,#+68
   \        0x6   0x0005             MOVS     R5,R0
   2722              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x066D      MVNS     R6,#+109
   2723          
   2724              size_t header_len;
   2725              size_t content_len;
   2726              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2727                  ssl->handshake->ciphersuite_info;
   \        0xC   0x6BA8             LDR      R0,[R5, #+56]
   \        0xE   0x6880             LDR      R0,[R0, #+8]
   \       0x10   0x9003             STR      R0,[SP, #+12]
   2728          
   2729              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write client key exchange"));
   2730          
   2731          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)
   2732              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA) {
   2733                  /*
   2734                   * DHM key exchange -- send G^X mod P
   2735                   */
   2736                  content_len = mbedtls_dhm_get_len(&ssl->handshake->dhm_ctx);
   2737          
   2738                  MBEDTLS_PUT_UINT16_BE(content_len, ssl->out_msg, 4);
   2739                  header_len = 6;
   2740          
   2741                  ret = mbedtls_dhm_make_public(&ssl->handshake->dhm_ctx,
   2742                                                (int) mbedtls_dhm_get_len(&ssl->handshake->dhm_ctx),
   2743                                                &ssl->out_msg[header_len], content_len,
   2744                                                ssl->conf->f_rng, ssl->conf->p_rng);
   2745                  if (ret != 0) {
   2746                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_make_public", ret);
   2747                      return ret;
   2748                  }
   2749          
   2750                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: X ", &ssl->handshake->dhm_ctx.X);
   2751                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: GX", &ssl->handshake->dhm_ctx.GX);
   2752          
   2753                  if ((ret = mbedtls_dhm_calc_secret(&ssl->handshake->dhm_ctx,
   2754                                                     ssl->handshake->premaster,
   2755                                                     MBEDTLS_PREMASTER_SIZE,
   2756                                                     &ssl->handshake->pmslen,
   2757                                                     ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   2758                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_calc_secret", ret);
   2759                      return ret;
   2760                  }
   2761          
   2762                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: K ", &ssl->handshake->dhm_ctx.K);
   2763              } else
   2764          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */
   2765          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
   2766              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
   2767              defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
   2768              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   2769              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
   2770                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
   2771                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
   2772                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA) {
   \       0x12   0x9803             LDR      R0,[SP, #+12]
   \       0x14   0x7A80             LDRB     R0,[R0, #+10]
   \       0x16   0x2803             CMP      R0,#+3
   \       0x18   0xD00C             BEQ.N    ??ssl_write_client_key_exchange_0
   \       0x1A   0x9803             LDR      R0,[SP, #+12]
   \       0x1C   0x7A80             LDRB     R0,[R0, #+10]
   \       0x1E   0x2804             CMP      R0,#+4
   \       0x20   0xD008             BEQ.N    ??ssl_write_client_key_exchange_0
   \       0x22   0x9803             LDR      R0,[SP, #+12]
   \       0x24   0x7A80             LDRB     R0,[R0, #+10]
   \       0x26   0x2809             CMP      R0,#+9
   \       0x28   0xD004             BEQ.N    ??ssl_write_client_key_exchange_0
   \       0x2A   0x9803             LDR      R0,[SP, #+12]
   \       0x2C   0x7A80             LDRB     R0,[R0, #+10]
   \       0x2E   0x280A             CMP      R0,#+10
   \       0x30   0xF040 0x808A      BNE.W    ??ssl_write_client_key_exchange_1
   2773          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2774                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??ssl_write_client_key_exchange_0: (+1)
   \       0x34   0xF07F 0x0B96      MVNS     R11,#+150
   \       0x38   0x465C             MOV      R4,R11
   2775                  psa_status_t destruction_status = PSA_ERROR_CORRUPTION_DETECTED;
   2776                  psa_key_attributes_t key_attributes;
   2777          
   2778                  mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   \       0x3A   0xF8D5 0x9038      LDR      R9,[R5, #+56]
   2779          
   2780                  header_len = 4;
   \       0x3E   0x2704             MOVS     R7,#+4
   2781          
   2782                  MBEDTLS_SSL_DEBUG_MSG(1, ("Perform PSA-based ECDH computation."));
   2783          
   2784                  /*
   2785                   * Generate EC private key for ECDHE exchange.
   2786                   */
   2787          
   2788                  /* The master secret is obtained from the shared ECDH secret by
   2789                   * applying the TLS 1.2 PRF with a specific salt and label. While
   2790                   * the PSA Crypto API encourages combining key agreement schemes
   2791                   * such as ECDH with fixed KDFs such as TLS 1.2 PRF, it does not
   2792                   * yet support the provisioning of salt + label to the KDF.
   2793                   * For the time being, we therefore need to split the computation
   2794                   * of the ECDH secret and the application of the TLS 1.2 PRF. */
   2795                  key_attributes = psa_key_attributes_init();
   \       0x40   0xA808             ADD      R0,SP,#+32
   \       0x42   0x.... 0x....      BL       psa_key_attributes_init
   2796                  psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
   \       0x46   0xF44F 0x4180      MOV      R1,#+16384
   \       0x4A   0xA808             ADD      R0,SP,#+32
   \       0x4C   0x.... 0x....      BL       psa_set_key_usage_flags
   2797                  psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDH);
   \       0x50   0x.... 0x....      LDR.W    R10,??DataTable14_5
   \       0x54   0x4651             MOV      R1,R10
   \       0x56   0xA808             ADD      R0,SP,#+32
   \       0x58   0x.... 0x....      BL       psa_set_key_algorithm
   2798                  psa_set_key_type(&key_attributes, handshake->xxdh_psa_type);
   \       0x5C   0xF8B9 0x104C      LDRH     R1,[R9, #+76]
   \       0x60   0xA808             ADD      R0,SP,#+32
   \       0x62   0x.... 0x....      BL       psa_set_key_type
   2799                  psa_set_key_bits(&key_attributes, handshake->xxdh_psa_bits);
   \       0x66   0xF8D9 0x1050      LDR      R1,[R9, #+80]
   \       0x6A   0xA808             ADD      R0,SP,#+32
   \       0x6C   0x.... 0x....      BL       psa_set_key_bits
   2800          
   2801                  /* Generate ECDH private key. */
   2802                  status = psa_generate_key(&key_attributes,
   2803                                            &handshake->xxdh_psa_privkey);
   \       0x70   0xF119 0x0154      ADDS     R1,R9,#+84
   \       0x74   0xA808             ADD      R0,SP,#+32
   \       0x76   0x.... 0x....      BL       psa_generate_key
   \       0x7A   0x4680             MOV      R8,R0
   2804                  if (status != PSA_SUCCESS) {
   \       0x7C   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x80   0xD002             BEQ.N    ??ssl_write_client_key_exchange_2
   2805                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \       0x86   0xE064             B.N      ??ssl_write_client_key_exchange_3
   2806                  }
   2807          
   2808                  /* Export the public part of the ECDH private key from PSA.
   2809                   * The export format is an ECPoint structure as expected by TLS,
   2810                   * but we just need to add a length byte before that. */
   2811                  unsigned char *own_pubkey = ssl->out_msg + header_len + 1;
   \                     ??ssl_write_client_key_exchange_2: (+1)
   \       0x88   0xF8D5 0x00A8      LDR      R0,[R5, #+168]
   \       0x8C   0x4438             ADD      R0,R0,R7
   \       0x8E   0x1C40             ADDS     R0,R0,#+1
   \       0x90   0x9005             STR      R0,[SP, #+20]
   2812                  unsigned char *end = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN;
   \       0x92   0xF8D5 0x00A8      LDR      R0,[R5, #+168]
   \       0x96   0xF510 0x7040      ADDS     R0,R0,#+768
   \       0x9A   0x9007             STR      R0,[SP, #+28]
   2813                  size_t own_pubkey_max_len = (size_t) (end - own_pubkey);
   \       0x9C   0x9907             LDR      R1,[SP, #+28]
   \       0x9E   0x9805             LDR      R0,[SP, #+20]
   \       0xA0   0x1A09             SUBS     R1,R1,R0
   \       0xA2   0x9106             STR      R1,[SP, #+24]
   2814                  size_t own_pubkey_len;
   2815          
   2816                  status = psa_export_public_key(handshake->xxdh_psa_privkey,
   2817                                                 own_pubkey, own_pubkey_max_len,
   2818                                                 &own_pubkey_len);
   \       0xA4   0xAB04             ADD      R3,SP,#+16
   \       0xA6   0x9A06             LDR      R2,[SP, #+24]
   \       0xA8   0x9905             LDR      R1,[SP, #+20]
   \       0xAA   0xF8D9 0x0054      LDR      R0,[R9, #+84]
   \       0xAE   0x.... 0x....      BL       psa_export_public_key
   \       0xB2   0x0004             MOVS     R4,R0
   2819                  if (status != PSA_SUCCESS) {
   \       0xB4   0x2C00             CMP      R4,#+0
   \       0xB6   0xD008             BEQ.N    ??ssl_write_client_key_exchange_4
   2820                      psa_destroy_key(handshake->xxdh_psa_privkey);
   \       0xB8   0xF8D9 0x0054      LDR      R0,[R9, #+84]
   \       0xBC   0x.... 0x....      BL       psa_destroy_key
   2821                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xF8C9 0x0054      STR      R0,[R9, #+84]
   2822                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   \       0xC6   0x....             LDR.N    R0,??DataTable14_6
   \       0xC8   0xE043             B.N      ??ssl_write_client_key_exchange_3
   2823                  }
   2824          
   2825                  ssl->out_msg[header_len] = (unsigned char) own_pubkey_len;
   \                     ??ssl_write_client_key_exchange_4: (+1)
   \       0xCA   0x9904             LDR      R1,[SP, #+16]
   \       0xCC   0xF8D5 0x00A8      LDR      R0,[R5, #+168]
   \       0xD0   0x55C1             STRB     R1,[R0, R7]
   2826                  content_len = own_pubkey_len + 1;
   \       0xD2   0xF8DD 0x8010      LDR      R8,[SP, #+16]
   \       0xD6   0xF118 0x0801      ADDS     R8,R8,#+1
   2827          
   2828                  /* The ECDH secret is the premaster secret used for key derivation. */
   2829          
   2830                  /* Compute ECDH shared secret. */
   2831                  status = psa_raw_key_agreement(PSA_ALG_ECDH,
   2832                                                 handshake->xxdh_psa_privkey,
   2833                                                 handshake->xxdh_psa_peerkey,
   2834                                                 handshake->xxdh_psa_peerkey_len,
   2835                                                 ssl->handshake->premaster,
   2836                                                 sizeof(ssl->handshake->premaster),
   2837                                                 &ssl->handshake->pmslen);
   \       0xDA   0x6BA8             LDR      R0,[R5, #+56]
   \       0xDC   0xF510 0x7016      ADDS     R0,R0,#+600
   \       0xE0   0x9002             STR      R0,[SP, #+8]
   \       0xE2   0x2020             MOVS     R0,#+32
   \       0xE4   0x9001             STR      R0,[SP, #+4]
   \       0xE6   0x6BA8             LDR      R0,[R5, #+56]
   \       0xE8   0xF510 0x700E      ADDS     R0,R0,#+568
   \       0xEC   0x9000             STR      R0,[SP, #+0]
   \       0xEE   0xF8D9 0x309C      LDR      R3,[R9, #+156]
   \       0xF2   0xF119 0x0259      ADDS     R2,R9,#+89
   \       0xF6   0xF8D9 0x1054      LDR      R1,[R9, #+84]
   \       0xFA   0x4650             MOV      R0,R10
   \       0xFC   0x.... 0x....      BL       psa_raw_key_agreement
   \      0x100   0x4682             MOV      R10,R0
   2838          
   2839                  destruction_status = psa_destroy_key(handshake->xxdh_psa_privkey);
   \      0x102   0xF8D9 0x0054      LDR      R0,[R9, #+84]
   \      0x106   0x.... 0x....      BL       psa_destroy_key
   \      0x10A   0x0001             MOVS     R1,R0
   2840                  handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0xF8C9 0x0054      STR      R0,[R9, #+84]
   2841          
   2842                  if (status != PSA_SUCCESS || destruction_status != PSA_SUCCESS) {
   \      0x112   0xEA51 0x000A      ORRS     R0,R1,R10
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD001             BEQ.N    ??ssl_write_client_key_exchange_5
   2843                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   \      0x11A   0x....             LDR.N    R0,??DataTable14_6
   \      0x11C   0xE019             B.N      ??ssl_write_client_key_exchange_3
   2844                  }
   2845          #else
   2846                  /*
   2847                   * ECDH key exchange -- send client public value
   2848                   */
   2849                  header_len = 4;
   2850          
   2851          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2852                  if (ssl->handshake->ecrs_enabled) {
   2853                      if (ssl->handshake->ecrs_state == ssl_ecrs_cke_ecdh_calc_secret) {
   2854                          goto ecdh_calc_secret;
   2855                      }
   2856          
   2857                      mbedtls_ecdh_enable_restart(&ssl->handshake->ecdh_ctx);
   2858                  }
   2859          #endif
   2860          
   2861                  ret = mbedtls_ecdh_make_public(&ssl->handshake->ecdh_ctx,
   2862                                                 &content_len,
   2863                                                 &ssl->out_msg[header_len], 1000,
   2864                                                 ssl->conf->f_rng, ssl->conf->p_rng);
   2865                  if (ret != 0) {
   2866                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_make_public", ret);
   2867          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2868                      if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2869                          ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   2870                      }
   2871          #endif
   2872                      return ret;
   2873                  }
   2874          
   2875                  MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   2876                                         MBEDTLS_DEBUG_ECDH_Q);
   2877          
   2878          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2879                  if (ssl->handshake->ecrs_enabled) {
   2880                      ssl->handshake->ecrs_n = content_len;
   2881                      ssl->handshake->ecrs_state = ssl_ecrs_cke_ecdh_calc_secret;
   2882                  }
   2883          
   2884          ecdh_calc_secret:
   2885                  if (ssl->handshake->ecrs_enabled) {
   2886                      content_len = ssl->handshake->ecrs_n;
   2887                  }
   2888          #endif
   2889                  if ((ret = mbedtls_ecdh_calc_secret(&ssl->handshake->ecdh_ctx,
   2890                                                      &ssl->handshake->pmslen,
   2891                                                      ssl->handshake->premaster,
   2892                                                      MBEDTLS_MPI_MAX_SIZE,
   2893                                                      ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   2894                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_calc_secret", ret);
   2895          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2896                      if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2897                          ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   2898                      }
   2899          #endif
   2900                      return ret;
   2901                  }
   2902          
   2903                  MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   2904                                         MBEDTLS_DEBUG_ECDH_Z);
   2905          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2906              } else
   2907          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
   2908                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
   2909                    MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
   2910                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   2911          #if defined(MBEDTLS_USE_PSA_CRYPTO) &&                           \
   2912              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   2913              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK) {
   2914                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   2915                  psa_status_t destruction_status = PSA_ERROR_CORRUPTION_DETECTED;
   2916                  psa_key_attributes_t key_attributes;
   2917          
   2918                  mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   2919          
   2920                  /*
   2921                   * opaque psk_identity<0..2^16-1>;
   2922                   */
   2923                  if (mbedtls_ssl_conf_has_static_psk(ssl->conf) == 0) {
   2924                      /* We don't offer PSK suites if we don't have a PSK,
   2925                       * and we check that the server's choice is among the
   2926                       * ciphersuites we offered, so this should never happen. */
   2927                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2928                  }
   2929          
   2930                  /* uint16 to store content length */
   2931                  const size_t content_len_size = 2;
   2932          
   2933                  header_len = 4;
   2934          
   2935                  if (header_len + content_len_size + ssl->conf->psk_identity_len
   2936                      > MBEDTLS_SSL_OUT_CONTENT_LEN) {
   2937                      MBEDTLS_SSL_DEBUG_MSG(1,
   2938                                            ("psk identity too long or SSL buffer too short"));
   2939                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   2940                  }
   2941          
   2942                  unsigned char *p = ssl->out_msg + header_len;
   2943          
   2944                  *p++ = MBEDTLS_BYTE_1(ssl->conf->psk_identity_len);
   2945                  *p++ = MBEDTLS_BYTE_0(ssl->conf->psk_identity_len);
   2946                  header_len += content_len_size;
   2947          
   2948                  memcpy(p, ssl->conf->psk_identity,
   2949                         ssl->conf->psk_identity_len);
   2950                  p += ssl->conf->psk_identity_len;
   2951          
   2952                  header_len += ssl->conf->psk_identity_len;
   2953          
   2954                  MBEDTLS_SSL_DEBUG_MSG(1, ("Perform PSA-based ECDH computation."));
   2955          
   2956                  /*
   2957                   * Generate EC private key for ECDHE exchange.
   2958                   */
   2959          
   2960                  /* The master secret is obtained from the shared ECDH secret by
   2961                   * applying the TLS 1.2 PRF with a specific salt and label. While
   2962                   * the PSA Crypto API encourages combining key agreement schemes
   2963                   * such as ECDH with fixed KDFs such as TLS 1.2 PRF, it does not
   2964                   * yet support the provisioning of salt + label to the KDF.
   2965                   * For the time being, we therefore need to split the computation
   2966                   * of the ECDH secret and the application of the TLS 1.2 PRF. */
   2967                  key_attributes = psa_key_attributes_init();
   2968                  psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
   2969                  psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDH);
   2970                  psa_set_key_type(&key_attributes, handshake->xxdh_psa_type);
   2971                  psa_set_key_bits(&key_attributes, handshake->xxdh_psa_bits);
   2972          
   2973                  /* Generate ECDH private key. */
   2974                  status = psa_generate_key(&key_attributes,
   2975                                            &handshake->xxdh_psa_privkey);
   2976                  if (status != PSA_SUCCESS) {
   2977                      return PSA_TO_MBEDTLS_ERR(status);
   2978                  }
   2979          
   2980                  /* Export the public part of the ECDH private key from PSA.
   2981                   * The export format is an ECPoint structure as expected by TLS,
   2982                   * but we just need to add a length byte before that. */
   2983                  unsigned char *own_pubkey = p + 1;
   2984                  unsigned char *end = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN;
   2985                  size_t own_pubkey_max_len = (size_t) (end - own_pubkey);
   2986                  size_t own_pubkey_len = 0;
   2987          
   2988                  status = psa_export_public_key(handshake->xxdh_psa_privkey,
   2989                                                 own_pubkey, own_pubkey_max_len,
   2990                                                 &own_pubkey_len);
   2991                  if (status != PSA_SUCCESS) {
   2992                      psa_destroy_key(handshake->xxdh_psa_privkey);
   2993                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   2994                      return PSA_TO_MBEDTLS_ERR(status);
   2995                  }
   2996          
   2997                  *p = (unsigned char) own_pubkey_len;
   2998                  content_len = own_pubkey_len + 1;
   2999          
   3000                  /* As RFC 5489 section 2, the premaster secret is formed as follows:
   3001                   * - a uint16 containing the length (in octets) of the ECDH computation
   3002                   * - the octet string produced by the ECDH computation
   3003                   * - a uint16 containing the length (in octets) of the PSK
   3004                   * - the PSK itself
   3005                   */
   3006                  unsigned char *pms = ssl->handshake->premaster;
   3007                  const unsigned char * const pms_end = pms +
   3008                                                        sizeof(ssl->handshake->premaster);
   3009                  /* uint16 to store length (in octets) of the ECDH computation */
   3010                  const size_t zlen_size = 2;
   3011                  size_t zlen = 0;
   3012          
   3013                  /* Perform ECDH computation after the uint16 reserved for the length */
   3014                  status = psa_raw_key_agreement(PSA_ALG_ECDH,
   3015                                                 handshake->xxdh_psa_privkey,
   3016                                                 handshake->xxdh_psa_peerkey,
   3017                                                 handshake->xxdh_psa_peerkey_len,
   3018                                                 pms + zlen_size,
   3019                                                 pms_end - (pms + zlen_size),
   3020                                                 &zlen);
   3021          
   3022                  destruction_status = psa_destroy_key(handshake->xxdh_psa_privkey);
   3023                  handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3024          
   3025                  if (status != PSA_SUCCESS) {
   3026                      return PSA_TO_MBEDTLS_ERR(status);
   3027                  } else if (destruction_status != PSA_SUCCESS) {
   3028                      return PSA_TO_MBEDTLS_ERR(destruction_status);
   3029                  }
   3030          
   3031                  /* Write the ECDH computation length before the ECDH computation */
   3032                  MBEDTLS_PUT_UINT16_BE(zlen, pms, 0);
   3033                  pms += zlen_size + zlen;
   3034              } else
   3035          #endif /* MBEDTLS_USE_PSA_CRYPTO &&
   3036                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   3037          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   3038              if (mbedtls_ssl_ciphersuite_uses_psk(ciphersuite_info)) {
   3039                  /*
   3040                   * opaque psk_identity<0..2^16-1>;
   3041                   */
   3042                  if (mbedtls_ssl_conf_has_static_psk(ssl->conf) == 0) {
   3043                      /* We don't offer PSK suites if we don't have a PSK,
   3044                       * and we check that the server's choice is among the
   3045                       * ciphersuites we offered, so this should never happen. */
   3046                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3047                  }
   3048          
   3049                  header_len = 4;
   3050                  content_len = ssl->conf->psk_identity_len;
   3051          
   3052                  if (header_len + 2 + content_len > MBEDTLS_SSL_OUT_CONTENT_LEN) {
   3053                      MBEDTLS_SSL_DEBUG_MSG(1,
   3054                                            ("psk identity too long or SSL buffer too short"));
   3055                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   3056                  }
   3057          
   3058                  ssl->out_msg[header_len++] = MBEDTLS_BYTE_1(content_len);
   3059                  ssl->out_msg[header_len++] = MBEDTLS_BYTE_0(content_len);
   3060          
   3061                  memcpy(ssl->out_msg + header_len,
   3062                         ssl->conf->psk_identity,
   3063                         ssl->conf->psk_identity_len);
   3064                  header_len += ssl->conf->psk_identity_len;
   3065          
   3066          #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
   3067                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK) {
   3068                      content_len = 0;
   3069                  } else
   3070          #endif
   3071          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   3072                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK) {
   3073                      if ((ret = ssl_write_encrypted_pms(ssl, header_len,
   3074                                                         &content_len, 2)) != 0) {
   3075                          return ret;
   3076                      }
   3077                  } else
   3078          #endif
   3079          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   3080                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK) {
   3081                      /*
   3082                       * ClientDiffieHellmanPublic public (DHM send G^X mod P)
   3083                       */
   3084                      content_len = mbedtls_dhm_get_len(&ssl->handshake->dhm_ctx);
   3085          
   3086                      if (header_len + 2 + content_len >
   3087                          MBEDTLS_SSL_OUT_CONTENT_LEN) {
   3088                          MBEDTLS_SSL_DEBUG_MSG(1,
   3089                                                ("psk identity or DHM size too long or SSL buffer too short"));
   3090                          return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   3091                      }
   3092          
   3093                      ssl->out_msg[header_len++] = MBEDTLS_BYTE_1(content_len);
   3094                      ssl->out_msg[header_len++] = MBEDTLS_BYTE_0(content_len);
   3095          
   3096                      ret = mbedtls_dhm_make_public(&ssl->handshake->dhm_ctx,
   3097                                                    (int) mbedtls_dhm_get_len(&ssl->handshake->dhm_ctx),
   3098                                                    &ssl->out_msg[header_len], content_len,
   3099                                                    ssl->conf->f_rng, ssl->conf->p_rng);
   3100                      if (ret != 0) {
   3101                          MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_make_public", ret);
   3102                          return ret;
   3103                      }
   3104          
   3105          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   3106                      unsigned char *pms = ssl->handshake->premaster;
   3107                      unsigned char *pms_end = pms + sizeof(ssl->handshake->premaster);
   3108                      size_t pms_len;
   3109          
   3110                      /* Write length only when we know the actual value */
   3111                      if ((ret = mbedtls_dhm_calc_secret(&ssl->handshake->dhm_ctx,
   3112                                                         pms + 2, pms_end - (pms + 2), &pms_len,
   3113                                                         ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   3114                          MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_calc_secret", ret);
   3115                          return ret;
   3116                      }
   3117                      MBEDTLS_PUT_UINT16_BE(pms_len, pms, 0);
   3118                      pms += 2 + pms_len;
   3119          
   3120                      MBEDTLS_SSL_DEBUG_MPI(3, "DHM: K ", &ssl->handshake->dhm_ctx.K);
   3121          #endif
   3122                  } else
   3123          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   3124          #if !defined(MBEDTLS_USE_PSA_CRYPTO) &&                             \
   3125                  defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   3126                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK) {
   3127                      /*
   3128                       * ClientECDiffieHellmanPublic public;
   3129                       */
   3130                      ret = mbedtls_ecdh_make_public(&ssl->handshake->ecdh_ctx,
   3131                                                     &content_len,
   3132                                                     &ssl->out_msg[header_len],
   3133                                                     MBEDTLS_SSL_OUT_CONTENT_LEN - header_len,
   3134                                                     ssl->conf->f_rng, ssl->conf->p_rng);
   3135                      if (ret != 0) {
   3136                          MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_make_public", ret);
   3137                          return ret;
   3138                      }
   3139          
   3140                      MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   3141                                             MBEDTLS_DEBUG_ECDH_Q);
   3142                  } else
   3143          #endif /* !MBEDTLS_USE_PSA_CRYPTO && MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   3144                  {
   3145                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3146                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3147                  }
   3148          
   3149          #if !defined(MBEDTLS_USE_PSA_CRYPTO)
   3150                  if ((ret = mbedtls_ssl_psk_derive_premaster(ssl,
   3151                                                              (mbedtls_key_exchange_type_t) ciphersuite_info->
   3152                                                              key_exchange)) != 0) {
   3153                      MBEDTLS_SSL_DEBUG_RET(1,
   3154                                            "mbedtls_ssl_psk_derive_premaster", ret);
   3155                      return ret;
   3156                  }
   3157          #endif /* !MBEDTLS_USE_PSA_CRYPTO */
   3158              } else
   3159          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
   3160          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
   3161              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA) {
   3162                  header_len = 4;
   3163                  if ((ret = ssl_write_encrypted_pms(ssl, header_len,
   3164                                                     &content_len, 0)) != 0) {
   3165                      return ret;
   3166                  }
   3167              } else
   3168          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */
   3169          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   3170              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
   3171                  header_len = 4;
   3172          
   3173          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   3174                  unsigned char *out_p = ssl->out_msg + header_len;
   3175                  unsigned char *end_p = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN -
   3176                                         header_len;
   3177                  ret = mbedtls_psa_ecjpake_write_round(&ssl->handshake->psa_pake_ctx,
   3178                                                        out_p, end_p - out_p, &content_len,
   3179                                                        MBEDTLS_ECJPAKE_ROUND_TWO);
   3180                  if (ret != 0) {
   3181                      psa_destroy_key(ssl->handshake->psa_pake_password);
   3182                      psa_pake_abort(&ssl->handshake->psa_pake_ctx);
   3183                      MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_output", ret);
   3184                      return ret;
   3185                  }
   3186          #else
   3187                  ret = mbedtls_ecjpake_write_round_two(&ssl->handshake->ecjpake_ctx,
   3188                                                        ssl->out_msg + header_len,
   3189                                                        MBEDTLS_SSL_OUT_CONTENT_LEN - header_len,
   3190                                                        &content_len,
   3191                                                        ssl->conf->f_rng, ssl->conf->p_rng);
   3192                  if (ret != 0) {
   3193                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_write_round_two", ret);
   3194                      return ret;
   3195                  }
   3196          
   3197                  ret = mbedtls_ecjpake_derive_secret(&ssl->handshake->ecjpake_ctx,
   3198                                                      ssl->handshake->premaster, 32, &ssl->handshake->pmslen,
   3199                                                      ssl->conf->f_rng, ssl->conf->p_rng);
   3200                  if (ret != 0) {
   3201                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_derive_secret", ret);
   3202                      return ret;
   3203                  }
   3204          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   3205              } else
   3206          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */
   3207              {
   3208                  ((void) ciphersuite_info);
   3209                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3210                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3211              }
   3212          
   3213              ssl->out_msglen  = header_len + content_len;
   \                     ??ssl_write_client_key_exchange_5: (+1)
   \      0x11E   0xEB18 0x0007      ADDS     R0,R8,R7
   \      0x122   0xF8C5 0x00B0      STR      R0,[R5, #+176]
   3214              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   \      0x126   0x2016             MOVS     R0,#+22
   \      0x128   0xF8C5 0x00AC      STR      R0,[R5, #+172]
   3215              ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE;
   \      0x12C   0x2010             MOVS     R0,#+16
   \      0x12E   0xF8D5 0x10A8      LDR      R1,[R5, #+168]
   \      0x132   0x7008             STRB     R0,[R1, #+0]
   3216          
   3217              ssl->state++;
   \      0x134   0x6868             LDR      R0,[R5, #+4]
   \      0x136   0x1C40             ADDS     R0,R0,#+1
   \      0x138   0x6068             STR      R0,[R5, #+4]
   3218          
   3219              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   \      0x13A   0x0028             MOVS     R0,R5
   \      0x13C   0x.... 0x....      BL       mbedtls_ssl_write_handshake_msg
   \      0x140   0x0001             MOVS     R1,R0
   \      0x142   0x2800             CMP      R0,#+0
   \      0x144   0xD102             BNE.N    ??ssl_write_client_key_exchange_6
   \      0x146   0xE003             B.N      ??ssl_write_client_key_exchange_7
   \                     ??ssl_write_client_key_exchange_1: (+1)
   \      0x148   0x....             LDR.N    R0,??DataTable14_3
   \      0x14A   0xE002             B.N      ??ssl_write_client_key_exchange_3
   3220                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   3221                  return ret;
   \                     ??ssl_write_client_key_exchange_6: (+1)
   \      0x14C   0x0008             MOVS     R0,R1
   \      0x14E   0xE000             B.N      ??ssl_write_client_key_exchange_3
   3222              }
   3223          
   3224              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write client key exchange"));
   3225          
   3226              return 0;
   \                     ??ssl_write_client_key_exchange_7: (+1)
   \      0x150   0x2000             MOVS     R0,#+0
   \                     ??ssl_write_client_key_exchange_3: (+1)
   \      0x152   0xB011             ADD      SP,SP,#+68
   \      0x154   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3227          }
   3228          
   3229          #if !defined(MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED)
   3230          MBEDTLS_CHECK_RETURN_CRITICAL
   3231          static int ssl_write_certificate_verify(mbedtls_ssl_context *ssl)
   3232          {
   3233              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   3234                  ssl->handshake->ciphersuite_info;
   3235              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3236          
   3237              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write certificate verify"));
   3238          
   3239              if ((ret = mbedtls_ssl_derive_keys(ssl)) != 0) {
   3240                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_derive_keys", ret);
   3241                  return ret;
   3242              }
   3243          
   3244              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   3245                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate verify"));
   3246                  ssl->state++;
   3247                  return 0;
   3248              }
   3249          
   3250              MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3251              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3252          }
   3253          #else /* !MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   3254          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   3255          static int ssl_write_certificate_verify(mbedtls_ssl_context *ssl)
   3256          {
   \                     ssl_write_certificate_verify: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x4682             MOV      R10,R0
   3257              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   \        0x8   0x....             LDR.N    R4,??DataTable14_7
   3258              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   3259                  ssl->handshake->ciphersuite_info;
   \        0xA   0xF8DA 0x0038      LDR      R0,[R10, #+56]
   \        0xE   0x6880             LDR      R0,[R0, #+8]
   \       0x10   0x9008             STR      R0,[SP, #+32]
   3260              size_t n = 0, offset = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9006             STR      R0,[SP, #+24]
   \       0x16   0xF05F 0x0B00      MOVS     R11,#+0
   3261              unsigned char hash[48];
   3262              unsigned char *hash_start = hash;
   \       0x1A   0xAD09             ADD      R5,SP,#+36
   3263              mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
   \       0x1C   0xF05F 0x0900      MOVS     R9,#+0
   3264              size_t hashlen;
   3265              void *rs_ctx = NULL;
   \       0x20   0x2600             MOVS     R6,#+0
   3266          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   3267              size_t out_buf_len = ssl->out_buf_len - (ssl->out_msg - ssl->out_buf);
   3268          #else
   3269              size_t out_buf_len = MBEDTLS_SSL_OUT_BUFFER_LEN - (ssl->out_msg - ssl->out_buf);
   \       0x22   0xF240 0x413D      MOVW     R1,#+1085
   \       0x26   0xF8DA 0x00A8      LDR      R0,[R10, #+168]
   \       0x2A   0x1A09             SUBS     R1,R1,R0
   \       0x2C   0xF8DA 0x7094      LDR      R7,[R10, #+148]
   \       0x30   0x187F             ADDS     R7,R7,R1
   3270          #endif
   3271          
   3272              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write certificate verify"));
   3273          
   3274          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   3275              if (ssl->handshake->ecrs_enabled &&
   3276                  ssl->handshake->ecrs_state == ssl_ecrs_crt_vrfy_sign) {
   3277                  goto sign;
   3278              }
   3279          #endif
   3280          
   3281              if ((ret = mbedtls_ssl_derive_keys(ssl)) != 0) {
   \       0x32   0x4650             MOV      R0,R10
   \       0x34   0x.... 0x....      BL       mbedtls_ssl_derive_keys
   \       0x38   0x4680             MOV      R8,R0
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD001             BEQ.N    ??ssl_write_certificate_verify_0
   3282                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_derive_keys", ret);
   3283                  return ret;
   \       0x3E   0x4640             MOV      R0,R8
   \       0x40   0xE0A3             B.N      ??ssl_write_certificate_verify_1
   3284              }
   3285          
   3286              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   \                     ??ssl_write_certificate_verify_0: (+1)
   \       0x42   0x9808             LDR      R0,[SP, #+32]
   \       0x44   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_cert_req_allowed
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD106             BNE.N    ??ssl_write_certificate_verify_2
   3287                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate verify"));
   3288                  ssl->state++;
   \       0x4C   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x50   0x1C40             ADDS     R0,R0,#+1
   \       0x52   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3289                  return 0;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xE097             B.N      ??ssl_write_certificate_verify_1
   3290              }
   3291          
   3292              if (ssl->handshake->client_auth == 0 ||
   3293                  mbedtls_ssl_own_cert(ssl) == NULL) {
   \                     ??ssl_write_certificate_verify_2: (+1)
   \       0x5A   0xF8DA 0x0038      LDR      R0,[R10, #+56]
   \       0x5E   0xF890 0x01CC      LDRB     R0,[R0, #+460]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD004             BEQ.N    ??ssl_write_certificate_verify_3
   \       0x66   0x4650             MOV      R0,R10
   \       0x68   0x.... 0x....      BL       mbedtls_ssl_own_cert
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD106             BNE.N    ??ssl_write_certificate_verify_4
   3294                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate verify"));
   3295                  ssl->state++;
   \                     ??ssl_write_certificate_verify_3: (+1)
   \       0x70   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x74   0x1C40             ADDS     R0,R0,#+1
   \       0x76   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3296                  return 0;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xE085             B.N      ??ssl_write_certificate_verify_1
   3297              }
   3298          
   3299              if (mbedtls_ssl_own_key(ssl) == NULL) {
   \                     ??ssl_write_certificate_verify_4: (+1)
   \       0x7E   0x4650             MOV      R0,R10
   \       0x80   0x.... 0x....      BL       mbedtls_ssl_own_key
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD101             BNE.N    ??ssl_write_certificate_verify_5
   3300                  MBEDTLS_SSL_DEBUG_MSG(1, ("got no private key for certificate"));
   3301                  return MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED;
   \       0x88   0x....             LDR.N    R0,??DataTable14_8
   \       0x8A   0xE07E             B.N      ??ssl_write_certificate_verify_1
   3302              }
   3303          
   3304              /*
   3305               * Make a signature of the handshake digests
   3306               */
   3307          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   3308              if (ssl->handshake->ecrs_enabled) {
   3309                  ssl->handshake->ecrs_state = ssl_ecrs_crt_vrfy_sign;
   3310              }
   3311          
   3312          sign:
   3313          #endif
   3314          
   3315              ret = ssl->handshake->calc_verify(ssl, hash, &hashlen);
   \                     ??ssl_write_certificate_verify_5: (+1)
   \       0x8C   0xAA07             ADD      R2,SP,#+28
   \       0x8E   0xA909             ADD      R1,SP,#+36
   \       0x90   0x4650             MOV      R0,R10
   \       0x92   0xF8DA 0x3038      LDR      R3,[R10, #+56]
   \       0x96   0x691B             LDR      R3,[R3, #+16]
   \       0x98   0x4798             BLX      R3
   \       0x9A   0x0004             MOVS     R4,R0
   3316              if (0 != ret) {
   \       0x9C   0x2C00             CMP      R4,#+0
   \       0x9E   0xD001             BEQ.N    ??ssl_write_certificate_verify_6
   3317                  MBEDTLS_SSL_DEBUG_RET(1, ("calc_verify"), ret);
   3318                  return ret;
   \       0xA0   0x0020             MOVS     R0,R4
   \       0xA2   0xE072             B.N      ??ssl_write_certificate_verify_1
   3319              }
   3320          
   3321              /*
   3322               * digitally-signed struct {
   3323               *     opaque handshake_messages[handshake_messages_length];
   3324               * };
   3325               *
   3326               * Taking shortcut here. We assume that the server always allows the
   3327               * PRF Hash function and has sent it in the allowed signature
   3328               * algorithms list received in the Certificate Request message.
   3329               *
   3330               * Until we encounter a server that does not, we will take this
   3331               * shortcut.
   3332               *
   3333               * Reason: Otherwise we should have running hashes for SHA512 and
   3334               *         SHA224 in order to satisfy 'weird' needs from the server
   3335               *         side.
   3336               */
   3337              if (ssl->handshake->ciphersuite_info->mac == MBEDTLS_MD_SHA384) {
   \                     ??ssl_write_certificate_verify_6: (+1)
   \       0xA4   0xF8DA 0x0038      LDR      R0,[R10, #+56]
   \       0xA8   0x6880             LDR      R0,[R0, #+8]
   \       0xAA   0x7A40             LDRB     R0,[R0, #+9]
   \       0xAC   0x280A             CMP      R0,#+10
   \       0xAE   0xD106             BNE.N    ??ssl_write_certificate_verify_7
   3338                  md_alg = MBEDTLS_MD_SHA384;
   \       0xB0   0xF05F 0x080A      MOVS     R8,#+10
   3339                  ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA384;
   \       0xB4   0x2105             MOVS     R1,#+5
   \       0xB6   0xF8DA 0x00A8      LDR      R0,[R10, #+168]
   \       0xBA   0x7101             STRB     R1,[R0, #+4]
   \       0xBC   0xE005             B.N      ??ssl_write_certificate_verify_8
   3340              } else {
   3341                  md_alg = MBEDTLS_MD_SHA256;
   \                     ??ssl_write_certificate_verify_7: (+1)
   \       0xBE   0xF05F 0x0809      MOVS     R8,#+9
   3342                  ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA256;
   \       0xC2   0x2104             MOVS     R1,#+4
   \       0xC4   0xF8DA 0x00A8      LDR      R0,[R10, #+168]
   \       0xC8   0x7101             STRB     R1,[R0, #+4]
   3343              }
   3344              ssl->out_msg[5] = mbedtls_ssl_sig_from_pk(mbedtls_ssl_own_key(ssl));
   \                     ??ssl_write_certificate_verify_8: (+1)
   \       0xCA   0x4650             MOV      R0,R10
   \       0xCC   0x.... 0x....      BL       mbedtls_ssl_own_key
   \       0xD0   0x.... 0x....      BL       mbedtls_ssl_sig_from_pk
   \       0xD4   0xF8DA 0x10A8      LDR      R1,[R10, #+168]
   \       0xD8   0x7148             STRB     R0,[R1, #+5]
   3345          
   3346              /* Info from md_alg will be used instead */
   3347              hashlen = 0;
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0x9007             STR      R0,[SP, #+28]
   3348              offset = 2;
   \       0xDE   0xF05F 0x0902      MOVS     R9,#+2
   3349          
   3350          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   3351              if (ssl->handshake->ecrs_enabled) {
   3352                  rs_ctx = &ssl->handshake->ecrs_ctx.pk;
   3353              }
   3354          #endif
   3355          
   3356              if ((ret = mbedtls_pk_sign_restartable(mbedtls_ssl_own_key(ssl),
   3357                                                     md_alg, hash_start, hashlen,
   3358                                                     ssl->out_msg + 6 + offset,
   3359                                                     out_buf_len - 6 - offset,
   3360                                                     &n,
   3361                                                     ssl->conf->f_rng, ssl->conf->p_rng, rs_ctx)) != 0) {
   \       0xE2   0x4650             MOV      R0,R10
   \       0xE4   0x.... 0x....      BL       mbedtls_ssl_own_key
   \       0xE8   0x9605             STR      R6,[SP, #+20]
   \       0xEA   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \       0xEE   0x69C9             LDR      R1,[R1, #+28]
   \       0xF0   0x9104             STR      R1,[SP, #+16]
   \       0xF2   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \       0xF6   0x6989             LDR      R1,[R1, #+24]
   \       0xF8   0x9103             STR      R1,[SP, #+12]
   \       0xFA   0xA906             ADD      R1,SP,#+24
   \       0xFC   0x9102             STR      R1,[SP, #+8]
   \       0xFE   0x1FB9             SUBS     R1,R7,#+6
   \      0x100   0xEBB1 0x0109      SUBS     R1,R1,R9
   \      0x104   0x9101             STR      R1,[SP, #+4]
   \      0x106   0xF8DA 0x10A8      LDR      R1,[R10, #+168]
   \      0x10A   0x4449             ADD      R1,R1,R9
   \      0x10C   0x1D89             ADDS     R1,R1,#+6
   \      0x10E   0x9100             STR      R1,[SP, #+0]
   \      0x110   0x9B07             LDR      R3,[SP, #+28]
   \      0x112   0x002A             MOVS     R2,R5
   \      0x114   0x4641             MOV      R1,R8
   \      0x116   0xB2C9             UXTB     R1,R1
   \      0x118   0x.... 0x....      BL       mbedtls_pk_sign_restartable
   \      0x11C   0x9000             STR      R0,[SP, #+0]
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD001             BEQ.N    ??ssl_write_certificate_verify_9
   3362                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_pk_sign", ret);
   3363          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   3364                  if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   3365                      ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   3366                  }
   3367          #endif
   3368                  return ret;
   \      0x122   0x9800             LDR      R0,[SP, #+0]
   \      0x124   0xE031             B.N      ??ssl_write_certificate_verify_1
   3369              }
   3370          
   3371              MBEDTLS_PUT_UINT16_BE(n, ssl->out_msg, offset + 4);
   \                     ??ssl_write_certificate_verify_9: (+1)
   \      0x126   0x....             LDR.N    R0,??DataTable14_9
   \      0x128   0x7800             LDRB     R0,[R0, #+0]
   \      0x12A   0x2801             CMP      R0,#+1
   \      0x12C   0xD108             BNE.N    ??ssl_write_certificate_verify_10
   \      0x12E   0x9906             LDR      R1,[SP, #+24]
   \      0x130   0xB289             UXTH     R1,R1
   \      0x132   0xF8DA 0x00A8      LDR      R0,[R10, #+168]
   \      0x136   0x4448             ADD      R0,R0,R9
   \      0x138   0x1D00             ADDS     R0,R0,#+4
   \      0x13A   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \      0x13E   0xE00B             B.N      ??ssl_write_certificate_verify_11
   \                     ??ssl_write_certificate_verify_10: (+1)
   \      0x140   0x9806             LDR      R0,[SP, #+24]
   \      0x142   0xB280             UXTH     R0,R0
   \      0x144   0x.... 0x....      BL       mbedtls_bswap16
   \      0x148   0x0001             MOVS     R1,R0
   \      0x14A   0xB289             UXTH     R1,R1
   \      0x14C   0xF8DA 0x00A8      LDR      R0,[R10, #+168]
   \      0x150   0x4448             ADD      R0,R0,R9
   \      0x152   0x1D00             ADDS     R0,R0,#+4
   \      0x154   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   3372          
   3373              ssl->out_msglen  = 6 + n + offset;
   \                     ??ssl_write_certificate_verify_11: (+1)
   \      0x158   0x9806             LDR      R0,[SP, #+24]
   \      0x15A   0xEB19 0x0000      ADDS     R0,R9,R0
   \      0x15E   0x1D80             ADDS     R0,R0,#+6
   \      0x160   0xF8CA 0x00B0      STR      R0,[R10, #+176]
   3374              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   \      0x164   0x2016             MOVS     R0,#+22
   \      0x166   0xF8CA 0x00AC      STR      R0,[R10, #+172]
   3375              ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_VERIFY;
   \      0x16A   0x200F             MOVS     R0,#+15
   \      0x16C   0xF8DA 0x10A8      LDR      R1,[R10, #+168]
   \      0x170   0x7008             STRB     R0,[R1, #+0]
   3376          
   3377              ssl->state++;
   \      0x172   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x176   0x1C40             ADDS     R0,R0,#+1
   \      0x178   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3378          
   3379              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   \      0x17C   0x4650             MOV      R0,R10
   \      0x17E   0x.... 0x....      BL       mbedtls_ssl_write_handshake_msg
   \      0x182   0x0001             MOVS     R1,R0
   \      0x184   0x0008             MOVS     R0,R1
   \      0x186   0x2900             CMP      R1,#+0
   \      0x188   0xD1FF             BNE.N    ??ssl_write_certificate_verify_1
   3380                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   3381                  return ret;
   3382              }
   3383          
   3384              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write certificate verify"));
   3385          
   3386              return ret;
   \                     ??ssl_write_certificate_verify_12: (+1)
   \                     ??ssl_write_certificate_verify_1: (+1)
   \      0x18A   0xB015             ADD      SP,SP,#+84
   \      0x18C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3387          }
   3388          #endif /* MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   3389          
   3390          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3391          MBEDTLS_CHECK_RETURN_CRITICAL
   3392          static int ssl_parse_new_session_ticket(mbedtls_ssl_context *ssl)
   3393          {
   3394              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3395              uint32_t lifetime;
   3396              size_t ticket_len;
   3397              unsigned char *ticket;
   3398              const unsigned char *msg;
   3399          
   3400              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse new session ticket"));
   3401          
   3402              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   3403                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   3404                  return ret;
   3405              }
   3406          
   3407              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   3408                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad new session ticket message"));
   3409                  mbedtls_ssl_send_alert_message(
   3410                      ssl,
   3411                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3412                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   3413                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   3414              }
   3415          
   3416              /*
   3417               * struct {
   3418               *     uint32 ticket_lifetime_hint;
   3419               *     opaque ticket<0..2^16-1>;
   3420               * } NewSessionTicket;
   3421               *
   3422               * 0  .  3   ticket_lifetime_hint
   3423               * 4  .  5   ticket_len (n)
   3424               * 6  .  5+n ticket content
   3425               */
   3426              if (ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET ||
   3427                  ssl->in_hslen < 6 + mbedtls_ssl_hs_hdr_len(ssl)) {
   3428                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad new session ticket message"));
   3429                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3430                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   3431                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3432              }
   3433          
   3434              msg = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
   3435          
   3436              lifetime = (((uint32_t) msg[0]) << 24) | (msg[1] << 16) |
   3437                         (msg[2] << 8) | (msg[3]);
   3438          
   3439              ticket_len = (msg[4] << 8) | (msg[5]);
   3440          
   3441              if (ticket_len + 6 + mbedtls_ssl_hs_hdr_len(ssl) != ssl->in_hslen) {
   3442                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad new session ticket message"));
   3443                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3444                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   3445                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3446              }
   3447          
   3448              MBEDTLS_SSL_DEBUG_MSG(3, ("ticket length: %" MBEDTLS_PRINTF_SIZET, ticket_len));
   3449          
   3450              /* We're not waiting for a NewSessionTicket message any more */
   3451              ssl->handshake->new_session_ticket = 0;
   3452              ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
   3453          
   3454              /*
   3455               * Zero-length ticket means the server changed his mind and doesn't want
   3456               * to send a ticket after all, so just forget it
   3457               */
   3458              if (ticket_len == 0) {
   3459                  return 0;
   3460              }
   3461          
   3462              if (ssl->session != NULL && ssl->session->ticket != NULL) {
   3463                  mbedtls_zeroize_and_free(ssl->session->ticket,
   3464                                           ssl->session->ticket_len);
   3465                  ssl->session->ticket = NULL;
   3466                  ssl->session->ticket_len = 0;
   3467              }
   3468          
   3469              mbedtls_zeroize_and_free(ssl->session_negotiate->ticket,
   3470                                       ssl->session_negotiate->ticket_len);
   3471              ssl->session_negotiate->ticket = NULL;
   3472              ssl->session_negotiate->ticket_len = 0;
   3473          
   3474              if ((ticket = mbedtls_calloc(1, ticket_len)) == NULL) {
   3475                  MBEDTLS_SSL_DEBUG_MSG(1, ("ticket alloc failed"));
   3476                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3477                                                 MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   3478                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   3479              }
   3480          
   3481              memcpy(ticket, msg + 6, ticket_len);
   3482          
   3483              ssl->session_negotiate->ticket = ticket;
   3484              ssl->session_negotiate->ticket_len = ticket_len;
   3485              ssl->session_negotiate->ticket_lifetime = lifetime;
   3486          
   3487              /*
   3488               * RFC 5077 section 3.4:
   3489               * "If the client receives a session ticket from the server, then it
   3490               * discards any Session ID that was sent in the ServerHello."
   3491               */
   3492              MBEDTLS_SSL_DEBUG_MSG(3, ("ticket in use, discarding session id"));
   3493              ssl->session_negotiate->id_len = 0;
   3494          
   3495              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse new session ticket"));
   3496          
   3497              return 0;
   3498          }
   3499          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   3500          
   3501          /*
   3502           * SSL handshake -- client side -- single step
   3503           */

   \                                 In section .text, align 2, keep-with-next
   3504          int mbedtls_ssl_handshake_client_step(mbedtls_ssl_context *ssl)
   3505          {
   \                     mbedtls_ssl_handshake_client_step: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3506              int ret = 0;
   \        0x4   0x2500             MOVS     R5,#+0
   3507          
   3508              /* Change state now, so that it is right in mbedtls_ssl_read_record(), used
   3509               * by DTLS for dropping out-of-sequence ChangeCipherSpec records */
   3510          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3511              if (ssl->state == MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC &&
   3512                  ssl->handshake->new_session_ticket != 0) {
   3513                  ssl->state = MBEDTLS_SSL_NEW_SESSION_TICKET;
   3514              }
   3515          #endif
   3516          
   3517              switch (ssl->state) {
   \        0x6   0x6860             LDR      R0,[R4, #+4]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD017             BEQ.N    ??mbedtls_ssl_handshake_client_step_0
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD01D             BEQ.N    ??mbedtls_ssl_handshake_client_step_1
   \       0x10   0xD317             BCC.N    ??mbedtls_ssl_handshake_client_step_2
   \       0x12   0x2804             CMP      R0,#+4
   \       0x14   0xD024             BEQ.N    ??mbedtls_ssl_handshake_client_step_3
   \       0x16   0xD31E             BCC.N    ??mbedtls_ssl_handshake_client_step_4
   \       0x18   0x2806             CMP      R0,#+6
   \       0x1A   0xD02B             BEQ.N    ??mbedtls_ssl_handshake_client_step_5
   \       0x1C   0xD325             BCC.N    ??mbedtls_ssl_handshake_client_step_6
   \       0x1E   0x2808             CMP      R0,#+8
   \       0x20   0xD032             BEQ.N    ??mbedtls_ssl_handshake_client_step_7
   \       0x22   0xD32C             BCC.N    ??mbedtls_ssl_handshake_client_step_8
   \       0x24   0x280A             CMP      R0,#+10
   \       0x26   0xD039             BEQ.N    ??mbedtls_ssl_handshake_client_step_9
   \       0x28   0xD333             BCC.N    ??mbedtls_ssl_handshake_client_step_10
   \       0x2A   0x280C             CMP      R0,#+12
   \       0x2C   0xD040             BEQ.N    ??mbedtls_ssl_handshake_client_step_11
   \       0x2E   0xD33A             BCC.N    ??mbedtls_ssl_handshake_client_step_12
   \       0x30   0x280E             CMP      R0,#+14
   \       0x32   0xD047             BEQ.N    ??mbedtls_ssl_handshake_client_step_13
   \       0x34   0xD341             BCC.N    ??mbedtls_ssl_handshake_client_step_14
   \       0x36   0x280F             CMP      R0,#+15
   \       0x38   0xD047             BEQ.N    ??mbedtls_ssl_handshake_client_step_15
   \       0x3A   0xE04A             B.N      ??mbedtls_ssl_handshake_client_step_16
   3518                  case MBEDTLS_SSL_HELLO_REQUEST:
   3519                      ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
   \                     ??mbedtls_ssl_handshake_client_step_0: (+1)
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x6060             STR      R0,[R4, #+4]
   3520                      break;
   \       0x40   0xE049             B.N      ??mbedtls_ssl_handshake_client_step_17
   3521          
   3522                  /*
   3523                   *  ==>   ClientHello
   3524                   */
   3525                  case MBEDTLS_SSL_CLIENT_HELLO:
   3526                      ret = mbedtls_ssl_write_client_hello(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_2: (+1)
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x.... 0x....      BL       mbedtls_ssl_write_client_hello
   \       0x48   0x0005             MOVS     R5,R0
   3527                      break;
   \       0x4A   0xE044             B.N      ??mbedtls_ssl_handshake_client_step_17
   3528          
   3529                  /*
   3530                   *  <==   ServerHello
   3531                   *        Certificate
   3532                   *      ( ServerKeyExchange  )
   3533                   *      ( CertificateRequest )
   3534                   *        ServerHelloDone
   3535                   */
   3536                  case MBEDTLS_SSL_SERVER_HELLO:
   3537                      ret = ssl_parse_server_hello(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_1: (+1)
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       ssl_parse_server_hello
   \       0x52   0x0005             MOVS     R5,R0
   3538                      break;
   \       0x54   0xE03F             B.N      ??mbedtls_ssl_handshake_client_step_17
   3539          
   3540                  case MBEDTLS_SSL_SERVER_CERTIFICATE:
   3541                      ret = mbedtls_ssl_parse_certificate(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_4: (+1)
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       mbedtls_ssl_parse_certificate
   \       0x5C   0x0005             MOVS     R5,R0
   3542                      break;
   \       0x5E   0xE03A             B.N      ??mbedtls_ssl_handshake_client_step_17
   3543          
   3544                  case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
   3545                      ret = ssl_parse_server_key_exchange(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_3: (+1)
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       ssl_parse_server_key_exchange
   \       0x66   0x0005             MOVS     R5,R0
   3546                      break;
   \       0x68   0xE035             B.N      ??mbedtls_ssl_handshake_client_step_17
   3547          
   3548                  case MBEDTLS_SSL_CERTIFICATE_REQUEST:
   3549                      ret = ssl_parse_certificate_request(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_6: (+1)
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0x.... 0x....      BL       ssl_parse_certificate_request
   \       0x70   0x0005             MOVS     R5,R0
   3550                      break;
   \       0x72   0xE030             B.N      ??mbedtls_ssl_handshake_client_step_17
   3551          
   3552                  case MBEDTLS_SSL_SERVER_HELLO_DONE:
   3553                      ret = ssl_parse_server_hello_done(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_5: (+1)
   \       0x74   0x0020             MOVS     R0,R4
   \       0x76   0x.... 0x....      BL       ssl_parse_server_hello_done
   \       0x7A   0x0005             MOVS     R5,R0
   3554                      break;
   \       0x7C   0xE02B             B.N      ??mbedtls_ssl_handshake_client_step_17
   3555          
   3556                  /*
   3557                   *  ==> ( Certificate/Alert  )
   3558                   *        ClientKeyExchange
   3559                   *      ( CertificateVerify  )
   3560                   *        ChangeCipherSpec
   3561                   *        Finished
   3562                   */
   3563                  case MBEDTLS_SSL_CLIENT_CERTIFICATE:
   3564                      ret = mbedtls_ssl_write_certificate(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_8: (+1)
   \       0x7E   0x0020             MOVS     R0,R4
   \       0x80   0x.... 0x....      BL       mbedtls_ssl_write_certificate
   \       0x84   0x0005             MOVS     R5,R0
   3565                      break;
   \       0x86   0xE026             B.N      ??mbedtls_ssl_handshake_client_step_17
   3566          
   3567                  case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:
   3568                      ret = ssl_write_client_key_exchange(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_7: (+1)
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x.... 0x....      BL       ssl_write_client_key_exchange
   \       0x8E   0x0005             MOVS     R5,R0
   3569                      break;
   \       0x90   0xE021             B.N      ??mbedtls_ssl_handshake_client_step_17
   3570          
   3571                  case MBEDTLS_SSL_CERTIFICATE_VERIFY:
   3572                      ret = ssl_write_certificate_verify(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_10: (+1)
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x.... 0x....      BL       ssl_write_certificate_verify
   \       0x98   0x0005             MOVS     R5,R0
   3573                      break;
   \       0x9A   0xE01C             B.N      ??mbedtls_ssl_handshake_client_step_17
   3574          
   3575                  case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:
   3576                      ret = mbedtls_ssl_write_change_cipher_spec(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_9: (+1)
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x.... 0x....      BL       mbedtls_ssl_write_change_cipher_spec
   \       0xA2   0x0005             MOVS     R5,R0
   3577                      break;
   \       0xA4   0xE017             B.N      ??mbedtls_ssl_handshake_client_step_17
   3578          
   3579                  case MBEDTLS_SSL_CLIENT_FINISHED:
   3580                      ret = mbedtls_ssl_write_finished(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_12: (+1)
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0x.... 0x....      BL       mbedtls_ssl_write_finished
   \       0xAC   0x0005             MOVS     R5,R0
   3581                      break;
   \       0xAE   0xE012             B.N      ??mbedtls_ssl_handshake_client_step_17
   3582          
   3583                      /*
   3584                       *  <==   ( NewSessionTicket )
   3585                       *        ChangeCipherSpec
   3586                       *        Finished
   3587                       */
   3588          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3589                  case MBEDTLS_SSL_NEW_SESSION_TICKET:
   3590                      ret = ssl_parse_new_session_ticket(ssl);
   3591                      break;
   3592          #endif
   3593          
   3594                  case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:
   3595                      ret = mbedtls_ssl_parse_change_cipher_spec(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_11: (+1)
   \       0xB0   0x0020             MOVS     R0,R4
   \       0xB2   0x.... 0x....      BL       mbedtls_ssl_parse_change_cipher_spec
   \       0xB6   0x0005             MOVS     R5,R0
   3596                      break;
   \       0xB8   0xE00D             B.N      ??mbedtls_ssl_handshake_client_step_17
   3597          
   3598                  case MBEDTLS_SSL_SERVER_FINISHED:
   3599                      ret = mbedtls_ssl_parse_finished(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_14: (+1)
   \       0xBA   0x0020             MOVS     R0,R4
   \       0xBC   0x.... 0x....      BL       mbedtls_ssl_parse_finished
   \       0xC0   0x0005             MOVS     R5,R0
   3600                      break;
   \       0xC2   0xE008             B.N      ??mbedtls_ssl_handshake_client_step_17
   3601          
   3602                  case MBEDTLS_SSL_FLUSH_BUFFERS:
   3603                      MBEDTLS_SSL_DEBUG_MSG(2, ("handshake: done"));
   3604                      ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
   \                     ??mbedtls_ssl_handshake_client_step_13: (+1)
   \       0xC4   0x200F             MOVS     R0,#+15
   \       0xC6   0x6060             STR      R0,[R4, #+4]
   3605                      break;
   \       0xC8   0xE005             B.N      ??mbedtls_ssl_handshake_client_step_17
   3606          
   3607                  case MBEDTLS_SSL_HANDSHAKE_WRAPUP:
   3608                      mbedtls_ssl_handshake_wrapup(ssl);
   \                     ??mbedtls_ssl_handshake_client_step_15: (+1)
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0x.... 0x....      BL       mbedtls_ssl_handshake_wrapup
   3609                      break;
   \       0xD0   0xE001             B.N      ??mbedtls_ssl_handshake_client_step_17
   3610          
   3611                  default:
   3612                      MBEDTLS_SSL_DEBUG_MSG(1, ("invalid state %d", ssl->state));
   3613                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \                     ??mbedtls_ssl_handshake_client_step_16: (+1)
   \       0xD2   0x....             LDR.N    R0,??DataTable14_2
   \       0xD4   0xE000             B.N      ??mbedtls_ssl_handshake_client_step_18
   3614              }
   3615          
   3616              return ret;
   \                     ??mbedtls_ssl_handshake_client_step_17: (+1)
   \       0xD6   0x0028             MOVS     R0,R5
   \                     ??mbedtls_ssl_handshake_client_step_18: (+1)
   \       0xD8   0xBD32             POP      {R1,R4,R5,PC}
   3617          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0xFFFF'8F80        DC32     0xffff8f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0xFFFF'9600        DC32     0xffff9600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     mbedtls_byte_order_detector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0xFFFF'9200        DC32     0xffff9200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0xFFFF'9A00        DC32     0xffff9a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0xFFFF'8D00        DC32     0xffff8d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0xFFFF'8900        DC32     0xffff8900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0xFFFF'9180        DC32     0xffff9180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0xFFFF'8F00        DC32     0xffff8f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0xFFFF'9400        DC32     0xffff9400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0xFFFF'9300        DC32     0xffff9300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x0902'0000        DC32     0x9020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0xFFFF'8080        DC32     0xffff8080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0xFFFF'8F80        DC32     0xffff8f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0xFFFF'8A00        DC32     0xffff8a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x....'....        DC32     mbedtls_byte_order_detector
   3618          
   3619          #endif /* MBEDTLS_SSL_CLI_C && MBEDTLS_SSL_PROTO_TLS1_2 */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_bswap16
      24   mbedtls_get_unaligned_uint16
        24   -> __aeabi_memcpy
      24   mbedtls_put_unaligned_uint16
        24   -> __aeabi_memcpy
       0   mbedtls_ssl_chk_buf_ptr
       0   mbedtls_ssl_ciphersuite_cert_req_allowed
       0   mbedtls_ssl_ciphersuite_uses_server_signature
      16   mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg
        16   -> mbedtls_ssl_md_alg_from_hash
        16   -> mbedtls_ssl_pk_alg_from_sig
       0   mbedtls_ssl_get_sig_algs
      16   mbedtls_ssl_handshake_client_step
        16   -> mbedtls_ssl_handshake_wrapup
        16   -> mbedtls_ssl_parse_certificate
        16   -> mbedtls_ssl_parse_change_cipher_spec
        16   -> mbedtls_ssl_parse_finished
        16   -> mbedtls_ssl_write_certificate
        16   -> mbedtls_ssl_write_change_cipher_spec
        16   -> mbedtls_ssl_write_client_hello
        16   -> mbedtls_ssl_write_finished
        16   -> ssl_parse_certificate_request
        16   -> ssl_parse_server_hello
        16   -> ssl_parse_server_hello_done
        16   -> ssl_parse_server_key_exchange
        16   -> ssl_write_certificate_verify
        16   -> ssl_write_client_key_exchange
       0   mbedtls_ssl_hs_hdr_len
       0   mbedtls_ssl_own_cert
       0   mbedtls_ssl_own_key
      16   mbedtls_ssl_sig_alg_is_offered
        16   -> mbedtls_ssl_get_sig_algs
      16   mbedtls_ssl_sig_alg_is_supported
        16   -> mbedtls_ssl_tls12_sig_alg_is_supported
       0   mbedtls_ssl_tls12_sig_alg_is_supported
      40   mbedtls_ssl_tls12_write_client_hello_exts
        40   -> ssl_write_max_fragment_length_ext
        40   -> ssl_write_supported_point_formats_ext
       8   mbedtls_ssl_write_handshake_msg
         8   -> mbedtls_ssl_write_handshake_msg_ext
       0   psa_extend_key_usage_flags
      48   psa_key_attributes_init
        48   -> __aeabi_memclr4
        48   -> __aeabi_memcpy4
       0   psa_set_key_algorithm
       0   psa_set_key_bits
      16   psa_set_key_type
        16   -> psa_set_key_domain_parameters
      16   psa_set_key_usage_flags
        16   -> psa_extend_key_usage_flags
      40   ssl_parse_certificate_request
        40   -> mbedtls_ssl_ciphersuite_cert_req_allowed
        40   -> mbedtls_ssl_hs_hdr_len
        40   -> mbedtls_ssl_read_record
        40   -> mbedtls_ssl_send_alert_message
      16   ssl_parse_max_fragment_length_ext
        16   -> mbedtls_ssl_send_alert_message
      16   ssl_parse_renegotiation_info
        16   -> mbedtls_ssl_send_alert_message
      48   ssl_parse_server_ecdh_params
        48   -> __aeabi_memcpy
        48   -> mbedtls_ssl_check_curve_tls_id
        48   -> mbedtls_ssl_get_psa_curve_info_from_tls_id
      56   ssl_parse_server_hello
        56   -> __aeabi_memcpy
        56   -> mbedtls_ssl_ciphersuite_from_id
        56   -> mbedtls_ssl_derive_keys
        56   -> mbedtls_ssl_hs_hdr_len
        56   -> mbedtls_ssl_optimize_checksum
        56   -> mbedtls_ssl_read_record
        56   -> mbedtls_ssl_read_version
        56   -> mbedtls_ssl_send_alert_message
        56   -> mbedtls_ssl_validate_ciphersuite
        56   -> memcmp
        56   -> ssl_parse_max_fragment_length_ext
        56   -> ssl_parse_renegotiation_info
        56   -> ssl_parse_supported_point_formats_ext
      16   ssl_parse_server_hello_done
        16   -> mbedtls_ssl_hs_hdr_len
        16   -> mbedtls_ssl_read_record
        16   -> mbedtls_ssl_send_alert_message
     104   ssl_parse_server_key_exchange
       104   -> mbedtls_bswap16
       104   -> mbedtls_get_unaligned_uint16
       104   -> mbedtls_pk_can_do
       104   -> mbedtls_pk_verify_restartable
       104   -> mbedtls_ssl_chk_buf_ptr
       104   -> mbedtls_ssl_ciphersuite_uses_server_signature
       104   -> mbedtls_ssl_get_key_exchange_md_tls1_2
       104   -> mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg
       104   -> mbedtls_ssl_hs_hdr_len
       104   -> mbedtls_ssl_pend_fatal_alert
       104   -> mbedtls_ssl_read_record
       104   -> mbedtls_ssl_send_alert_message
       104   -> mbedtls_ssl_sig_alg_is_offered
       104   -> mbedtls_ssl_sig_alg_is_supported
       104   -> ssl_parse_server_ecdh_params
      24   ssl_parse_supported_point_formats_ext
        24   -> mbedtls_ssl_send_alert_message
     120   ssl_write_certificate_verify
       120   -- Indirect call
       120   -> mbedtls_bswap16
       120   -> mbedtls_pk_sign_restartable
       120   -> mbedtls_put_unaligned_uint16
       120   -> mbedtls_ssl_ciphersuite_cert_req_allowed
       120   -> mbedtls_ssl_derive_keys
       120   -> mbedtls_ssl_own_cert
       120   -> mbedtls_ssl_own_key
       120   -> mbedtls_ssl_sig_from_pk
       120   -> mbedtls_ssl_write_handshake_msg
     104   ssl_write_client_key_exchange
       104   -> mbedtls_ssl_write_handshake_msg
       104   -> psa_destroy_key
       104   -> psa_export_public_key
       104   -> psa_generate_key
       104   -> psa_key_attributes_init
       104   -> psa_raw_key_agreement
       104   -> psa_set_key_algorithm
       104   -> psa_set_key_bits
       104   -> psa_set_key_type
       104   -> psa_set_key_usage_flags
      24   ssl_write_max_fragment_length_ext
        24   -> mbedtls_bswap16
        24   -> mbedtls_put_unaligned_uint16
        24   -> mbedtls_ssl_chk_buf_ptr
      24   ssl_write_supported_point_formats_ext
        24   -> mbedtls_bswap16
        24   -> mbedtls_put_unaligned_uint16
        24   -> mbedtls_ssl_chk_buf_ptr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      36  ?_0
      16  mbedtls_bswap16
       2  mbedtls_byte_order_detector
      26  mbedtls_get_unaligned_uint16
      22  mbedtls_put_unaligned_uint16
      20  mbedtls_ssl_chk_buf_ptr
      24  mbedtls_ssl_ciphersuite_cert_req_allowed
      18  mbedtls_ssl_ciphersuite_uses_server_signature
      54  mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg
      34  mbedtls_ssl_get_sig_algs
     218  mbedtls_ssl_handshake_client_step
       6  mbedtls_ssl_hs_hdr_len
      40  mbedtls_ssl_own_cert
      40  mbedtls_ssl_own_key
      50  mbedtls_ssl_sig_alg_is_offered
      32  mbedtls_ssl_sig_alg_is_supported
      54  mbedtls_ssl_tls12_sig_alg_is_supported
      96  mbedtls_ssl_tls12_write_client_hello_exts
      16  mbedtls_ssl_write_handshake_msg
      30  psa_extend_key_usage_flags
      28  psa_key_attributes_init
       4  psa_set_key_algorithm
      20  psa_set_key_bits
      32  psa_set_key_type
      16  psa_set_key_usage_flags
     366  ssl_parse_certificate_request
      50  ssl_parse_max_fragment_length_ext
      44  ssl_parse_renegotiation_info
     210  ssl_parse_server_ecdh_params
     972  ssl_parse_server_hello
      84  ssl_parse_server_hello_done
     656  ssl_parse_server_key_exchange
      94  ssl_parse_supported_point_formats_ext
     400  ssl_write_certificate_verify
     344  ssl_write_client_key_exchange
     120  ssl_write_max_fragment_length_ext
     112  ssl_write_supported_point_formats_ext

 
    38 bytes in section .rodata
 4'412 bytes in section .text
 
 4'364 bytes of CODE  memory (+ 48 bytes shared)
    38 bytes of CONST memory

Errors: none
Warnings: 1
