###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:54:06
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\x509_crt.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\x509_crt.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\x509_crt.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\x509_crt.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\x509_crt.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\x509_crt.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf      =  flags,widths
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\x509_crt.c
      1          /*
      2           *  X.509 certificate parsing and verification
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          /*
     20           *  The ITU-T X.509 standard defines a certificate format for PKI.
     21           *
     22           *  http://www.ietf.org/rfc/rfc5280.txt (Certificates and CRLs)
     23           *  http://www.ietf.org/rfc/rfc3279.txt (Alg IDs for CRLs)
     24           *  http://www.ietf.org/rfc/rfc2986.txt (CSRs, aka PKCS#10)
     25           *
     26           *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf
     27           *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
     28           *
     29           *  [SIRO] https://cabforum.org/wp-content/uploads/Chunghwatelecom201503cabforumV4.pdf
     30           */
     31          
     32          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2402             MOVS     R4,#+2
   \        0x6   0x466D             MOV      R5,SP
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t mbedtls_bswap16(uint16_t)
   \                     mbedtls_bswap16: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x0A00             LSRS     R0,R0,#+8
   \        0x8   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x4770             BX       LR

   \                                 In section .rodata, align 2
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     33          
     34          #if defined(MBEDTLS_X509_CRT_PARSE_C)
     35          
     36          #include "mbedtls/x509_crt.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t psa_get_key_type(psa_key_attributes_t const *)
   \                     psa_get_key_type: (+1)
   \        0x0   0x8800             LDRH     R0,[R0, #+0]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t psa_get_key_bits(psa_key_attributes_t const *)
   \                     psa_get_key_bits: (+1)
   \        0x0   0x8840             LDRH     R0,[R0, #+2]
   \        0x2   0x4770             BX       LR
     37          #include "mbedtls/error.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_error_add(int, int, char const *, int)
   \                     mbedtls_error_add: (+1)
   \        0x0   0x1808             ADDS     R0,R1,R0
   \        0x2   0x4770             BX       LR
     38          #include "mbedtls/oid.h"
     39          #include "mbedtls/platform_util.h"
     40          
     41          #include <string.h>
     42          
     43          #if defined(MBEDTLS_PEM_PARSE_C)
     44          #include "mbedtls/pem.h"
     45          #endif
     46          
     47          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     48          #include "psa/crypto.h"
     49          #include "psa_util_internal.h"
     50          #include "md_psa.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_md_psa_alg_from_type(mbedtls_md_type_t)
   \                     mbedtls_md_psa_alg_from_type: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0
   \        0x2   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \        0x6   0x4770             BX       LR
     51          #endif /* MBEDTLS_USE_PSA_CRYPTO */
     52          #include "pk_internal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp mbedtls_ecp_keypair const *mbedtls_pk_ec_ro(mbedtls_pk_context const)
   \                     mbedtls_pk_ec_ro: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB580             PUSH     {R7,LR}
   \        0x4   0xA802             ADD      R0,SP,#+8
   \        0x6   0x.... 0x....      BL       mbedtls_pk_get_type
   \        0xA   0x1E80             SUBS     R0,R0,#+2
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD801             BHI.N    ??mbedtls_pk_ec_ro_0
   \                     ??mbedtls_pk_ec_ro_1: (+1)
   \       0x10   0x9803             LDR      R0,[SP, #+12]
   \       0x12   0xE000             B.N      ??mbedtls_pk_ec_ro_2
   \                     ??mbedtls_pk_ec_ro_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_pk_ec_ro_2: (+1)
   \       0x16   0xBC02             POP      {R1}
   \       0x18   0xF85D 0xFB14      LDR      PC,[SP], #+20

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp enum <unnamed>#124 mbedtls_pk_get_group_id(mbedtls_pk_context const *)
   \                     mbedtls_pk_get_group_id: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB0A4             SUB      SP,SP,#+144
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       mbedtls_pk_get_type
   \        0xC   0x2807             CMP      R0,#+7
   \        0xE   0xD128             BNE.N    ??mbedtls_pk_get_group_id_0
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x2124             MOVS     R1,#+36
   \       0x14   0x.... 0x....      BL       __aeabi_memclr4
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x68A0             LDR      R0,[R4, #+8]
   \       0x1C   0x.... 0x....      BL       psa_get_key_attributes
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD001             BEQ.N    ??mbedtls_pk_get_group_id_1
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE028             B.N      ??mbedtls_pk_get_group_id_2
   \                     ??mbedtls_pk_get_group_id_1: (+1)
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x.... 0x....      BL       psa_get_key_type
   \       0x2E   0x0005             MOVS     R5,R0
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0xB289             UXTH     R1,R1
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x38   0x4001             ANDS     R1,R0,R1
   \       0x3A   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x3E   0xD101             BNE.N    ??mbedtls_pk_get_group_id_3
   \       0x40   0x002E             MOVS     R6,R5
   \       0x42   0xE000             B.N      ??mbedtls_pk_get_group_id_4
   \                     ??mbedtls_pk_get_group_id_3: (+1)
   \       0x44   0x2600             MOVS     R6,#+0
   \                     ??mbedtls_pk_get_group_id_4: (+1)
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x.... 0x....      BL       psa_get_key_bits
   \       0x4C   0x0001             MOVS     R1,R0
   \       0x4E   0x2200             MOVS     R2,#+0
   \       0x50   0x0030             MOVS     R0,R6
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0x.... 0x....      BL       mbedtls_ecc_group_of_psa
   \       0x58   0x0007             MOVS     R7,R0
   \       0x5A   0x4668             MOV      R0,SP
   \       0x5C   0x.... 0x....      BL       psa_reset_key_attributes
   \       0x60   0xE009             B.N      ??mbedtls_pk_get_group_id_5
   \                     ??mbedtls_pk_get_group_id_0: (+1)
   \       0x62   0x0021             MOVS     R1,R4
   \       0x64   0xB084             SUB      SP,SP,#+16
   \       0x66   0x4668             MOV      R0,SP
   \       0x68   0x22A0             MOVS     R2,#+160
   \       0x6A   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x6E   0xBC0F             POP      {R0-R3}
   \       0x70   0x.... 0x....      BL       mbedtls_pk_ec_ro
   \       0x74   0x7807             LDRB     R7,[R0, #+0]
   \                     ??mbedtls_pk_get_group_id_5: (+1)
   \       0x76   0x0038             MOVS     R0,R7
   \       0x78   0xB2C0             UXTB     R0,R0
   \                     ??mbedtls_pk_get_group_id_2: (+1)
   \       0x7A   0xB025             ADD      SP,SP,#+148
   \       0x7C   0xBDF0             POP      {R4-R7,PC}

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
     53          
     54          #include "mbedtls/platform.h"
     55          
     56          #if defined(MBEDTLS_THREADING_C)
     57          #include "mbedtls/threading.h"
     58          #endif
     59          
     60          #if defined(MBEDTLS_HAVE_TIME)
     61          #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
     62          #define WIN32_LEAN_AND_MEAN
     63          #include <windows.h>
     64          #else
     65          #include <time.h>
     66          #endif
     67          #endif
     68          
     69          #if !defined( MBEDTLS_X509_CRT_PARSE_PATH_ALT )
     70          #if defined(MBEDTLS_FS_IO)
     71          #include <stdio.h>
     72          #if !defined(_WIN32) || defined(EFIX64) || defined(EFI32)
     73          #include <sys/types.h>
     74          #include <sys/stat.h>
     75          #if defined(__MBED__)
     76          #include <platform/mbed_retarget.h>
     77          #else
     78          #include <dirent.h>
     79          #endif /* __MBED__ */
     80          #include <errno.h>
     81          #endif /* !_WIN32 || EFIX64 || EFI32 */
     82          #endif
     83          #endif
     84          
     85          /*
     86           * Item in a verification chain: cert and flags for it
     87           */
     88          typedef struct {
     89              mbedtls_x509_crt *crt;
     90              uint32_t flags;
     91          } x509_crt_verify_chain_item;
     92          
     93          /*
     94           * Max size of verification chain: end-entity + intermediates + trusted root
     95           */
     96          #define X509_MAX_VERIFY_CHAIN_SIZE    (MBEDTLS_X509_MAX_INTERMEDIATE_CA + 2)
     97          
     98          /* Default profile. Do not remove items unless there are serious security
     99           * concerns. */

   \                                 In section .rodata, align 4
    100          const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default =
   \                     mbedtls_x509_crt_profile_default:
   \        0x0   0x0000'0700        DC32 1'792, 268'435'455, 252, 2'048
   \              0x0FFF'FFFF  
   \              0x0000'00FC  
   \              0x0000'0800
    101          {
    102              /* Hashes from SHA-256 and above. Note that this selection
    103               * should be aligned with ssl_preset_default_hashes in ssl_tls.c. */
    104              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |
    105              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384) |
    106              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA512),
    107              0xFFFFFFF, /* Any PK alg    */
    108          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    109              /* Curves at or above 128-bit security level. Note that this selection
    110               * should be aligned with ssl_preset_default_curves in ssl_tls.c. */
    111              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256R1) |
    112              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP384R1) |
    113              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP521R1) |
    114              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP256R1) |
    115              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP384R1) |
    116              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP512R1) |
    117              0,
    118          #else /* MBEDTLS_PK_HAVE_ECC_KEYS */
    119              0,
    120          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
    121              2048,
    122          };
    123          
    124          /* Next-generation profile. Currently identical to the default, but may
    125           * be tightened at any time. */

   \                                 In section .rodata, align 4
    126          const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next =
   \                     mbedtls_x509_crt_profile_next:
   \        0x0   0x0000'0700        DC32 1'792, 268'435'455, 2'300, 2'048
   \              0x0FFF'FFFF  
   \              0x0000'08FC  
   \              0x0000'0800
    127          {
    128              /* Hashes from SHA-256 and above. */
    129              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |
    130              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384) |
    131              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA512),
    132              0xFFFFFFF, /* Any PK alg    */
    133          #if defined(MBEDTLS_ECP_C)
    134              /* Curves at or above 128-bit security level. */
    135              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256R1) |
    136              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP384R1) |
    137              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP521R1) |
    138              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP256R1) |
    139              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP384R1) |
    140              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP512R1) |
    141              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256K1),
    142          #else
    143              0,
    144          #endif
    145              2048,
    146          };
    147          
    148          /*
    149           * NSA Suite B Profile
    150           */

   \                                 In section .rodata, align 4
    151          const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb =
   \                     mbedtls_x509_crt_profile_suiteb:
   \        0x0   0x0000'0300        DC32 768, 10, 12, 0
   \              0x0000'000A  
   \              0x0000'000C  
   \              0x0000'0000
    152          {
    153              /* Only SHA-256 and 384 */
    154              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |
    155              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384),
    156              /* Only ECDSA */
    157              MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECDSA) |
    158              MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECKEY),
    159          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    160              /* Only NIST P-256 and P-384 */
    161              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256R1) |
    162              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP384R1),
    163          #else /* MBEDTLS_PK_HAVE_ECC_KEYS */
    164              0,
    165          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
    166              0,
    167          };
    168          
    169          /*
    170           * Empty / all-forbidden profile
    171           */

   \                                 In section .rodata, align 4
    172          const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_none =
   \                     mbedtls_x509_crt_profile_none:
   \        0x0   0x0000'0000        DC32 0, 0, 0, 4'294'967'295
   \              0x0000'0000  
   \              0x0000'0000  
   \              0xFFFF'FFFF
    173          {
    174              0,
    175              0,
    176              0,
    177              (uint32_t) -1,
    178          };
    179          
    180          /*
    181           * Check md_alg against profile
    182           * Return 0 if md_alg is acceptable for this profile, -1 otherwise
    183           */

   \                                 In section .text, align 2, keep-with-next
    184          static int x509_profile_check_md_alg(const mbedtls_x509_crt_profile *profile,
    185                                               mbedtls_md_type_t md_alg)
    186          {
   \                     x509_profile_check_md_alg: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    187              if (md_alg == MBEDTLS_MD_NONE) {
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB2C0             UXTB     R0,R0
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD102             BNE.N    ??x509_profile_check_md_alg_0
    188                  return -1;
   \        0xA   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \        0xE   0xE008             B.N      ??x509_profile_check_md_alg_1
    189              }
    190          
    191              if ((profile->allowed_mds & MBEDTLS_X509_ID_FLAG(md_alg)) != 0) {
   \                     ??x509_profile_check_md_alg_0: (+1)
   \       0x10   0x6813             LDR      R3,[R2, #+0]
   \       0x12   0x1E48             SUBS     R0,R1,#+1
   \       0x14   0x40C3             LSRS     R3,R3,R0
   \       0x16   0x07D8             LSLS     R0,R3,#+31
   \       0x18   0xD501             BPL.N    ??x509_profile_check_md_alg_2
    192                  return 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE001             B.N      ??x509_profile_check_md_alg_1
    193              }
    194          
    195              return -1;
   \                     ??x509_profile_check_md_alg_2: (+1)
   \       0x1E   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_profile_check_md_alg_1: (+1)
   \       0x22   0x4770             BX       LR
    196          }
    197          
    198          /*
    199           * Check pk_alg against profile
    200           * Return 0 if pk_alg is acceptable for this profile, -1 otherwise
    201           */

   \                                 In section .text, align 2, keep-with-next
    202          static int x509_profile_check_pk_alg(const mbedtls_x509_crt_profile *profile,
    203                                               mbedtls_pk_type_t pk_alg)
    204          {
   \                     x509_profile_check_pk_alg: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    205              if (pk_alg == MBEDTLS_PK_NONE) {
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB2C0             UXTB     R0,R0
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD102             BNE.N    ??x509_profile_check_pk_alg_0
    206                  return -1;
   \        0xA   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \        0xE   0xE008             B.N      ??x509_profile_check_pk_alg_1
    207              }
    208          
    209              if ((profile->allowed_pks & MBEDTLS_X509_ID_FLAG(pk_alg)) != 0) {
   \                     ??x509_profile_check_pk_alg_0: (+1)
   \       0x10   0x6853             LDR      R3,[R2, #+4]
   \       0x12   0x1E48             SUBS     R0,R1,#+1
   \       0x14   0x40C3             LSRS     R3,R3,R0
   \       0x16   0x07D8             LSLS     R0,R3,#+31
   \       0x18   0xD501             BPL.N    ??x509_profile_check_pk_alg_2
    210                  return 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE001             B.N      ??x509_profile_check_pk_alg_1
    211              }
    212          
    213              return -1;
   \                     ??x509_profile_check_pk_alg_2: (+1)
   \       0x1E   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_profile_check_pk_alg_1: (+1)
   \       0x22   0x4770             BX       LR
    214          }
    215          
    216          /*
    217           * Check key against profile
    218           * Return 0 if pk is acceptable for this profile, -1 otherwise
    219           */

   \                                 In section .text, align 2, keep-with-next
    220          static int x509_profile_check_key(const mbedtls_x509_crt_profile *profile,
    221                                            const mbedtls_pk_context *pk)
    222          {
   \                     x509_profile_check_key: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    223              const mbedtls_pk_type_t pk_alg = mbedtls_pk_get_type(pk);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       mbedtls_pk_get_type
   \        0xC   0x0006             MOVS     R6,R0
    224          
    225          #if defined(MBEDTLS_RSA_C)
    226              if (pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS) {
    227                  if (mbedtls_pk_get_bitlen(pk) >= profile->rsa_min_bitlen) {
    228                      return 0;
    229                  }
    230          
    231                  return -1;
    232              }
    233          #endif /* MBEDTLS_RSA_C */
    234          
    235          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    236              if (pk_alg == MBEDTLS_PK_ECDSA ||
    237                  pk_alg == MBEDTLS_PK_ECKEY ||
    238                  pk_alg == MBEDTLS_PK_ECKEY_DH) {
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x2804             CMP      R0,#+4
   \       0x14   0xD007             BEQ.N    ??x509_profile_check_key_0
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x2802             CMP      R0,#+2
   \       0x1C   0xD003             BEQ.N    ??x509_profile_check_key_0
   \       0x1E   0x0030             MOVS     R0,R6
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2803             CMP      R0,#+3
   \       0x24   0xD114             BNE.N    ??x509_profile_check_key_1
    239                  const mbedtls_ecp_group_id gid = mbedtls_pk_get_group_id(pk);
   \                     ??x509_profile_check_key_0: (+1)
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       mbedtls_pk_get_group_id
   \       0x2C   0x0001             MOVS     R1,R0
    240          
    241                  if (gid == MBEDTLS_ECP_DP_NONE) {
   \       0x2E   0x0008             MOVS     R0,R1
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD102             BNE.N    ??x509_profile_check_key_2
    242                      return -1;
   \       0x36   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x3A   0xE00B             B.N      ??x509_profile_check_key_3
    243                  }
    244          
    245                  if ((profile->allowed_curves & MBEDTLS_X509_ID_FLAG(gid)) != 0) {
   \                     ??x509_profile_check_key_2: (+1)
   \       0x3C   0x68A2             LDR      R2,[R4, #+8]
   \       0x3E   0x1E48             SUBS     R0,R1,#+1
   \       0x40   0x40C2             LSRS     R2,R2,R0
   \       0x42   0x07D0             LSLS     R0,R2,#+31
   \       0x44   0xD501             BPL.N    ??x509_profile_check_key_4
    246                      return 0;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xE004             B.N      ??x509_profile_check_key_3
    247                  }
    248          
    249                  return -1;
   \                     ??x509_profile_check_key_4: (+1)
   \       0x4A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x4E   0xE001             B.N      ??x509_profile_check_key_3
    250              }
    251          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
    252          
    253              return -1;
   \                     ??x509_profile_check_key_1: (+1)
   \       0x50   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_profile_check_key_3: (+1)
   \       0x54   0xBD70             POP      {R4-R6,PC}
    254          }
    255          
    256          /*
    257           * Like memcmp, but case-insensitive and always returns -1 if different
    258           */

   \                                 In section .text, align 2, keep-with-next
    259          static int x509_memcasecmp(const void *s1, const void *s2, size_t len)
    260          {
   \                     x509_memcasecmp: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0003             MOVS     R3,R0
    261              size_t i;
    262              unsigned char diff;
    263              const unsigned char *n1 = s1, *n2 = s2;
   \        0x4   0x001D             MOVS     R5,R3
   \        0x6   0x000E             MOVS     R6,R1
    264          
    265              for (i = 0; i < len; i++) {
   \        0x8   0x2700             MOVS     R7,#+0
   \                     ??x509_memcasecmp_0: (+1)
   \        0xA   0x4297             CMP      R7,R2
   \        0xC   0xD21F             BCS.N    ??x509_memcasecmp_1
    266                  diff = n1[i] ^ n2[i];
   \        0xE   0xF815 0xC007      LDRB     R12,[R5, R7]
   \       0x12   0x5DF0             LDRB     R0,[R6, R7]
   \       0x14   0xEA90 0x0C0C      EORS     R12,R0,R12
   \       0x18   0x4664             MOV      R4,R12
    267          
    268                  if (diff == 0) {
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD013             BEQ.N    ??x509_memcasecmp_2
    269                      continue;
    270                  }
    271          
    272                  if (diff == 32 &&
    273                      ((n1[i] >= 'a' && n1[i] <= 'z') ||
    274                       (n1[i] >= 'A' && n1[i] <= 'Z'))) {
   \                     ??x509_memcasecmp_3: (+1)
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2820             CMP      R0,#+32
   \       0x28   0xD10C             BNE.N    ??x509_memcasecmp_4
   \       0x2A   0x5DE8             LDRB     R0,[R5, R7]
   \       0x2C   0x2861             CMP      R0,#+97
   \       0x2E   0xDB02             BLT.N    ??x509_memcasecmp_5
   \       0x30   0x5DE8             LDRB     R0,[R5, R7]
   \       0x32   0x287B             CMP      R0,#+123
   \       0x34   0xDB05             BLT.N    ??x509_memcasecmp_6
   \                     ??x509_memcasecmp_5: (+1)
   \       0x36   0x5DE8             LDRB     R0,[R5, R7]
   \       0x38   0x2841             CMP      R0,#+65
   \       0x3A   0xDB03             BLT.N    ??x509_memcasecmp_4
   \       0x3C   0x5DE8             LDRB     R0,[R5, R7]
   \       0x3E   0x285B             CMP      R0,#+91
   \       0x40   0xDA00             BGE.N    ??x509_memcasecmp_4
    275                      continue;
   \                     ??x509_memcasecmp_6: (+1)
   \       0x42   0xE002             B.N      ??x509_memcasecmp_2
    276                  }
    277          
    278                  return -1;
   \                     ??x509_memcasecmp_4: (+1)
   \       0x44   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x48   0xE002             B.N      ??x509_memcasecmp_7
    279              }
   \                     ??x509_memcasecmp_2: (+1)
   \       0x4A   0x1C7F             ADDS     R7,R7,#+1
   \       0x4C   0xE7DD             B.N      ??x509_memcasecmp_0
    280          
    281              return 0;
   \                     ??x509_memcasecmp_1: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??x509_memcasecmp_7: (+1)
   \       0x50   0xBCF0             POP      {R4-R7}
   \       0x52   0x4770             BX       LR
    282          }
    283          
    284          /*
    285           * Return 0 if name matches wildcard, -1 otherwise
    286           */

   \                                 In section .text, align 2, keep-with-next
    287          static int x509_check_wildcard(const char *cn, const mbedtls_x509_buf *name)
    288          {
   \                     x509_check_wildcard: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
    289              size_t i;
    290              size_t cn_idx = 0, cn_len = strlen(cn);
   \        0x8   0x2400             MOVS     R4,#+0
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0x.... 0x....      BL       strlen
   \       0x10   0x0007             MOVS     R7,R0
    291          
    292              /* We can't have a match if there is no wildcard to match */
    293              if (name->len < 3 || name->p[0] != '*' || name->p[1] != '.') {
   \       0x12   0x6870             LDR      R0,[R6, #+4]
   \       0x14   0x2803             CMP      R0,#+3
   \       0x16   0xD307             BCC.N    ??x509_check_wildcard_0
   \       0x18   0x68B0             LDR      R0,[R6, #+8]
   \       0x1A   0x7800             LDRB     R0,[R0, #+0]
   \       0x1C   0x282A             CMP      R0,#+42
   \       0x1E   0xD103             BNE.N    ??x509_check_wildcard_0
   \       0x20   0x68B0             LDR      R0,[R6, #+8]
   \       0x22   0x7840             LDRB     R0,[R0, #+1]
   \       0x24   0x282E             CMP      R0,#+46
   \       0x26   0xD002             BEQ.N    ??x509_check_wildcard_1
    294                  return -1;
   \                     ??x509_check_wildcard_0: (+1)
   \       0x28   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x2C   0xE024             B.N      ??x509_check_wildcard_2
    295              }
    296          
    297              for (i = 0; i < cn_len; ++i) {
   \                     ??x509_check_wildcard_1: (+1)
   \       0x2E   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??x509_check_wildcard_3: (+1)
   \       0x32   0x45B8             CMP      R8,R7
   \       0x34   0xD208             BCS.N    ??x509_check_wildcard_4
    298                  if (cn[i] == '.') {
   \       0x36   0xF815 0x0008      LDRB     R0,[R5, R8]
   \       0x3A   0x282E             CMP      R0,#+46
   \       0x3C   0xD101             BNE.N    ??x509_check_wildcard_5
    299                      cn_idx = i;
   \       0x3E   0x4644             MOV      R4,R8
    300                      break;
   \       0x40   0xE002             B.N      ??x509_check_wildcard_4
    301                  }
    302              }
   \                     ??x509_check_wildcard_5: (+1)
   \       0x42   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x46   0xE7F4             B.N      ??x509_check_wildcard_3
    303          
    304              if (cn_idx == 0) {
   \                     ??x509_check_wildcard_4: (+1)
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD102             BNE.N    ??x509_check_wildcard_6
    305                  return -1;
   \       0x4C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x50   0xE012             B.N      ??x509_check_wildcard_2
    306              }
    307          
    308              if (cn_len - cn_idx == name->len - 1 &&
    309                  x509_memcasecmp(name->p + 1, cn + cn_idx, name->len - 1) == 0) {
   \                     ??x509_check_wildcard_6: (+1)
   \       0x52   0x1B39             SUBS     R1,R7,R4
   \       0x54   0x6870             LDR      R0,[R6, #+4]
   \       0x56   0x1E40             SUBS     R0,R0,#+1
   \       0x58   0x4281             CMP      R1,R0
   \       0x5A   0xD10B             BNE.N    ??x509_check_wildcard_7
   \       0x5C   0x6872             LDR      R2,[R6, #+4]
   \       0x5E   0x1E52             SUBS     R2,R2,#+1
   \       0x60   0xEB05 0x0104      ADD      R1,R5,R4
   \       0x64   0x68B0             LDR      R0,[R6, #+8]
   \       0x66   0x1C40             ADDS     R0,R0,#+1
   \       0x68   0x.... 0x....      BL       x509_memcasecmp
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD101             BNE.N    ??x509_check_wildcard_7
    310                  return 0;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xE001             B.N      ??x509_check_wildcard_2
    311              }
    312          
    313              return -1;
   \                     ??x509_check_wildcard_7: (+1)
   \       0x74   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_check_wildcard_2: (+1)
   \       0x78   0xE8BD 0x81F0      POP      {R4-R8,PC}
    314          }
    315          
    316          /*
    317           * Compare two X.509 strings, case-insensitive, and allowing for some encoding
    318           * variations (but not all).
    319           *
    320           * Return 0 if equal, -1 otherwise.
    321           */

   \                                 In section .text, align 2, keep-with-next
    322          static int x509_string_cmp(const mbedtls_x509_buf *a, const mbedtls_x509_buf *b)
    323          {
   \                     x509_string_cmp: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    324              if (a->tag == b->tag &&
    325                  a->len == b->len &&
    326                  memcmp(a->p, b->p, b->len) == 0) {
   \        0x6   0x6821             LDR      R1,[R4, #+0]
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x4281             CMP      R1,R0
   \        0xC   0xD10C             BNE.N    ??x509_string_cmp_0
   \        0xE   0x6861             LDR      R1,[R4, #+4]
   \       0x10   0x6868             LDR      R0,[R5, #+4]
   \       0x12   0x4281             CMP      R1,R0
   \       0x14   0xD108             BNE.N    ??x509_string_cmp_0
   \       0x16   0x686A             LDR      R2,[R5, #+4]
   \       0x18   0x68A9             LDR      R1,[R5, #+8]
   \       0x1A   0x68A0             LDR      R0,[R4, #+8]
   \       0x1C   0x.... 0x....      BL       memcmp
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??x509_string_cmp_0
    327                  return 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE01A             B.N      ??x509_string_cmp_1
    328              }
    329          
    330              if ((a->tag == MBEDTLS_ASN1_UTF8_STRING || a->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
    331                  (b->tag == MBEDTLS_ASN1_UTF8_STRING || b->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
    332                  a->len == b->len &&
    333                  x509_memcasecmp(a->p, b->p, b->len) == 0) {
   \                     ??x509_string_cmp_0: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x280C             CMP      R0,#+12
   \       0x2C   0xD002             BEQ.N    ??x509_string_cmp_2
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x2813             CMP      R0,#+19
   \       0x32   0xD112             BNE.N    ??x509_string_cmp_3
   \                     ??x509_string_cmp_2: (+1)
   \       0x34   0x6828             LDR      R0,[R5, #+0]
   \       0x36   0x280C             CMP      R0,#+12
   \       0x38   0xD002             BEQ.N    ??x509_string_cmp_4
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x2813             CMP      R0,#+19
   \       0x3E   0xD10C             BNE.N    ??x509_string_cmp_3
   \                     ??x509_string_cmp_4: (+1)
   \       0x40   0x6861             LDR      R1,[R4, #+4]
   \       0x42   0x6868             LDR      R0,[R5, #+4]
   \       0x44   0x4281             CMP      R1,R0
   \       0x46   0xD108             BNE.N    ??x509_string_cmp_3
   \       0x48   0x686A             LDR      R2,[R5, #+4]
   \       0x4A   0x68A9             LDR      R1,[R5, #+8]
   \       0x4C   0x68A0             LDR      R0,[R4, #+8]
   \       0x4E   0x.... 0x....      BL       x509_memcasecmp
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD101             BNE.N    ??x509_string_cmp_3
    334                  return 0;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xE001             B.N      ??x509_string_cmp_1
    335              }
    336          
    337              return -1;
   \                     ??x509_string_cmp_3: (+1)
   \       0x5A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_string_cmp_1: (+1)
   \       0x5E   0xBD32             POP      {R1,R4,R5,PC}
    338          }
    339          
    340          /*
    341           * Compare two X.509 Names (aka rdnSequence).
    342           *
    343           * See RFC 5280 section 7.1, though we don't implement the whole algorithm:
    344           * we sometimes return unequal when the full algorithm would return equal,
    345           * but never the other way. (In particular, we don't do Unicode normalisation
    346           * or space folding.)
    347           *
    348           * Return 0 if equal, -1 otherwise.
    349           */

   \                                 In section .text, align 2, keep-with-next
    350          static int x509_name_cmp(const mbedtls_x509_name *a, const mbedtls_x509_name *b)
    351          {
   \                     x509_name_cmp: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    352              /* Avoid recursion, it might not be optimised by the compiler */
    353              while (a != NULL || b != NULL) {
   \                     ??x509_name_cmp_0: (+1)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??x509_name_cmp_1
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD02D             BEQ.N    ??x509_name_cmp_2
    354                  if (a == NULL || b == NULL) {
   \                     ??x509_name_cmp_1: (+1)
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD001             BEQ.N    ??x509_name_cmp_3
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD102             BNE.N    ??x509_name_cmp_4
    355                      return -1;
   \                     ??x509_name_cmp_3: (+1)
   \       0x16   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1A   0xE027             B.N      ??x509_name_cmp_5
    356                  }
    357          
    358                  /* type */
    359                  if (a->oid.tag != b->oid.tag ||
    360                      a->oid.len != b->oid.len ||
    361                      memcmp(a->oid.p, b->oid.p, b->oid.len) != 0) {
   \                     ??x509_name_cmp_4: (+1)
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0x4281             CMP      R1,R0
   \       0x22   0xD10A             BNE.N    ??x509_name_cmp_6
   \       0x24   0x6861             LDR      R1,[R4, #+4]
   \       0x26   0x6868             LDR      R0,[R5, #+4]
   \       0x28   0x4281             CMP      R1,R0
   \       0x2A   0xD106             BNE.N    ??x509_name_cmp_6
   \       0x2C   0x686A             LDR      R2,[R5, #+4]
   \       0x2E   0x68A9             LDR      R1,[R5, #+8]
   \       0x30   0x68A0             LDR      R0,[R4, #+8]
   \       0x32   0x.... 0x....      BL       memcmp
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD002             BEQ.N    ??x509_name_cmp_7
    362                      return -1;
   \                     ??x509_name_cmp_6: (+1)
   \       0x3A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x3E   0xE015             B.N      ??x509_name_cmp_5
    363                  }
    364          
    365                  /* value */
    366                  if (x509_string_cmp(&a->val, &b->val) != 0) {
   \                     ??x509_name_cmp_7: (+1)
   \       0x40   0xF115 0x010C      ADDS     R1,R5,#+12
   \       0x44   0xF114 0x000C      ADDS     R0,R4,#+12
   \       0x48   0x.... 0x....      BL       x509_string_cmp
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD002             BEQ.N    ??x509_name_cmp_8
    367                      return -1;
   \       0x50   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x54   0xE00A             B.N      ??x509_name_cmp_5
    368                  }
    369          
    370                  /* structure of the list of sets */
    371                  if (a->next_merged != b->next_merged) {
   \                     ??x509_name_cmp_8: (+1)
   \       0x56   0x7F21             LDRB     R1,[R4, #+28]
   \       0x58   0x7F28             LDRB     R0,[R5, #+28]
   \       0x5A   0x4281             CMP      R1,R0
   \       0x5C   0xD002             BEQ.N    ??x509_name_cmp_9
    372                      return -1;
   \       0x5E   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x62   0xE003             B.N      ??x509_name_cmp_5
    373                  }
    374          
    375                  a = a->next;
   \                     ??x509_name_cmp_9: (+1)
   \       0x64   0x69A4             LDR      R4,[R4, #+24]
    376                  b = b->next;
   \       0x66   0x69AD             LDR      R5,[R5, #+24]
   \       0x68   0xE7CD             B.N      ??x509_name_cmp_0
    377              }
    378          
    379              /* a == NULL == b */
    380              return 0;
   \                     ??x509_name_cmp_2: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \                     ??x509_name_cmp_5: (+1)
   \       0x6C   0xBD32             POP      {R1,R4,R5,PC}
    381          }
    382          
    383          /*
    384           * Reset (init or clear) a verify_chain
    385           */

   \                                 In section .text, align 2, keep-with-next
    386          static void x509_crt_verify_chain_reset(
    387              mbedtls_x509_crt_verify_chain *ver_chain)
    388          {
    389              size_t i;
    390          
    391              for (i = 0; i < MBEDTLS_X509_MAX_VERIFY_CHAIN_SIZE; i++) {
   \                     x509_crt_verify_chain_reset: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \                     ??x509_crt_verify_chain_reset_0: (+1)
   \        0x2   0x290A             CMP      R1,#+10
   \        0x4   0xD209             BCS.N    ??x509_crt_verify_chain_reset_1
    392                  ver_chain->items[i].crt = NULL;
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0xF840 0x2031      STR      R2,[R0, R1, LSL #+3]
    393                  ver_chain->items[i].flags = (uint32_t) -1;
   \        0xC   0xF05F 0x33FF      MOVS     R3,#+4294967295
   \       0x10   0xEB00 0x02C1      ADD      R2,R0,R1, LSL #+3
   \       0x14   0x6053             STR      R3,[R2, #+4]
    394              }
   \       0x16   0x1C49             ADDS     R1,R1,#+1
   \       0x18   0xE7F3             B.N      ??x509_crt_verify_chain_reset_0
    395          
    396              ver_chain->len = 0;
   \                     ??x509_crt_verify_chain_reset_1: (+1)
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x6502             STR      R2,[R0, #+80]
    397          
    398          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
    399              ver_chain->trust_ca_cb_result = NULL;
    400          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
    401          }
   \       0x1E   0x4770             BX       LR
    402          
    403          /*
    404           *  Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
    405           */

   \                                 In section .text, align 2, keep-with-next
    406          static int x509_get_version(unsigned char **p,
    407                                      const unsigned char *end,
    408                                      int *ver)
    409          {
   \                     x509_get_version: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    410              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x086D      MVNS     R8,#+109
    411              size_t len;
    412          
    413              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    414                                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    415                                              0)) != 0) {
   \        0xE   0x23A0             MOVS     R3,#+160
   \       0x10   0x466A             MOV      R2,SP
   \       0x12   0x0029             MOVS     R1,R5
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x1A   0x0007             MOVS     R7,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD010             BEQ.N    ??x509_get_version_0
    416                  if (ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
   \       0x20   0xF117 0x0F62      CMN      R7,#+98
   \       0x24   0xD103             BNE.N    ??x509_get_version_1
    417                      *ver = 0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6030             STR      R0,[R6, #+0]
    418                      return 0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xE02E             B.N      ??x509_get_version_2
    419                  }
    420          
    421                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
   \                     ??x509_get_version_1: (+1)
   \       0x2E   0xF240 0x13A5      MOVW     R3,#+421
   \       0x32   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x36   0x0039             MOVS     R1,R7
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \       0x3C   0x.... 0x....      BL       mbedtls_error_add
   \       0x40   0xE024             B.N      ??x509_get_version_2
    422              }
    423          
    424              end = *p + len;
   \                     ??x509_get_version_0: (+1)
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x9800             LDR      R0,[SP, #+0]
   \       0x46   0xEB01 0x0800      ADD      R8,R1,R0
    425          
    426              if ((ret = mbedtls_asn1_get_int(p, end, ver)) != 0) {
   \       0x4A   0x0032             MOVS     R2,R6
   \       0x4C   0x4641             MOV      R1,R8
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       mbedtls_asn1_get_int
   \       0x54   0x4681             MOV      R9,R0
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD009             BEQ.N    ??x509_get_version_3
    427                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_VERSION, ret);
   \       0x5A   0xF240 0x13AB      MOVW     R3,#+427
   \       0x5E   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x62   0x4649             MOV      R1,R9
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \       0x68   0x.... 0x....      BL       mbedtls_error_add
   \       0x6C   0xE00E             B.N      ??x509_get_version_2
    428              }
    429          
    430              if (*p != end) {
   \                     ??x509_get_version_3: (+1)
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x4540             CMP      R0,R8
   \       0x72   0xD00A             BEQ.N    ??x509_get_version_4
    431                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_VERSION,
    432                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \       0x74   0xF44F 0x73D8      MOV      R3,#+432
   \       0x78   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x7C   0xF07F 0x0165      MVNS     R1,#+101
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \       0x84   0x.... 0x....      BL       mbedtls_error_add
   \       0x88   0xE000             B.N      ??x509_get_version_2
    433              }
    434          
    435              return 0;
   \                     ??x509_get_version_4: (+1)
   \       0x8A   0x2000             MOVS     R0,#+0
   \                     ??x509_get_version_2: (+1)
   \       0x8C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    436          }
    437          
    438          /*
    439           *  Validity ::= SEQUENCE {
    440           *       notBefore      Time,
    441           *       notAfter       Time }
    442           */

   \                                 In section .text, align 2, keep-with-next
    443          static int x509_get_dates(unsigned char **p,
    444                                    const unsigned char *end,
    445                                    mbedtls_x509_time *from,
    446                                    mbedtls_x509_time *to)
    447          {
   \                     x509_get_dates: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
    448              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
    449              size_t len;
    450          
    451              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    452                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0x10   0x2330             MOVS     R3,#+48
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x4651             MOV      R1,R10
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x1C   0x4681             MOV      R9,R0
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD009             BEQ.N    ??x509_get_dates_0
    453                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_DATE, ret);
   \       0x22   0xF240 0x13C5      MOVW     R3,#+453
   \       0x26   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x2A   0x4649             MOV      R1,R9
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable11
   \       0x30   0x.... 0x....      BL       mbedtls_error_add
   \       0x34   0xE026             B.N      ??x509_get_dates_1
    454              }
    455          
    456              end = *p + len;
   \                     ??x509_get_dates_0: (+1)
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x9800             LDR      R0,[SP, #+0]
   \       0x3A   0xEB01 0x0700      ADD      R7,R1,R0
    457          
    458              if ((ret = mbedtls_x509_get_time(p, end, from)) != 0) {
   \       0x3E   0x002A             MOVS     R2,R5
   \       0x40   0x0039             MOVS     R1,R7
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x.... 0x....      BL       mbedtls_x509_get_time
   \       0x48   0x4680             MOV      R8,R0
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD001             BEQ.N    ??x509_get_dates_2
    459                  return ret;
   \       0x4E   0x4640             MOV      R0,R8
   \       0x50   0xE018             B.N      ??x509_get_dates_1
    460              }
    461          
    462              if ((ret = mbedtls_x509_get_time(p, end, to)) != 0) {
   \                     ??x509_get_dates_2: (+1)
   \       0x52   0x0032             MOVS     R2,R6
   \       0x54   0x0039             MOVS     R1,R7
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       mbedtls_x509_get_time
   \       0x5C   0x4681             MOV      R9,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD001             BEQ.N    ??x509_get_dates_3
    463                  return ret;
   \       0x62   0x4648             MOV      R0,R9
   \       0x64   0xE00E             B.N      ??x509_get_dates_1
    464              }
    465          
    466              if (*p != end) {
   \                     ??x509_get_dates_3: (+1)
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x42B8             CMP      R0,R7
   \       0x6A   0xD00A             BEQ.N    ??x509_get_dates_4
    467                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_DATE,
    468                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \       0x6C   0xF44F 0x73EA      MOV      R3,#+468
   \       0x70   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x74   0xF07F 0x0165      MVNS     R1,#+101
   \       0x78   0x.... 0x....      LDR.W    R0,??DataTable11
   \       0x7C   0x.... 0x....      BL       mbedtls_error_add
   \       0x80   0xE000             B.N      ??x509_get_dates_1
    469              }
    470          
    471              return 0;
   \                     ??x509_get_dates_4: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   \                     ??x509_get_dates_1: (+1)
   \       0x84   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    472          }
    473          
    474          /*
    475           * X.509 v2/v3 unique identifier (not parsed)
    476           */

   \                                 In section .text, align 2, keep-with-next
    477          static int x509_get_uid(unsigned char **p,
    478                                  const unsigned char *end,
    479                                  mbedtls_x509_buf *uid, int n)
    480          {
   \                     x509_get_uid: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    481              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x096D      MVNS     R9,#+109
    482          
    483              if (*p == end) {
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x42A8             CMP      R0,R5
   \       0x14   0xD101             BNE.N    ??x509_get_uid_0
    484                  return 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE022             B.N      ??x509_get_uid_1
    485              }
    486          
    487              uid->tag = **p;
   \                     ??x509_get_uid_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x7800             LDRB     R0,[R0, #+0]
   \       0x1E   0x6030             STR      R0,[R6, #+0]
    488          
    489              if ((ret = mbedtls_asn1_get_tag(p, end, &uid->len,
    490                                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    491                                              n)) != 0) {
   \       0x20   0xF057 0x03A0      ORRS     R3,R7,#0xA0
   \       0x24   0x1D32             ADDS     R2,R6,#+4
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x2E   0x4680             MOV      R8,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD00E             BEQ.N    ??x509_get_uid_2
    492                  if (ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
   \       0x34   0xF118 0x0F62      CMN      R8,#+98
   \       0x38   0xD101             BNE.N    ??x509_get_uid_3
    493                      return 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xE010             B.N      ??x509_get_uid_1
    494                  }
    495          
    496                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
   \                     ??x509_get_uid_3: (+1)
   \       0x3E   0xF44F 0x73F8      MOV      R3,#+496
   \       0x42   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x46   0x4641             MOV      R1,R8
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \       0x4C   0x.... 0x....      BL       mbedtls_error_add
   \       0x50   0xE006             B.N      ??x509_get_uid_1
    497              }
    498          
    499              uid->p = *p;
   \                     ??x509_get_uid_2: (+1)
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x60B0             STR      R0,[R6, #+8]
    500              *p += uid->len;
   \       0x56   0x6821             LDR      R1,[R4, #+0]
   \       0x58   0x6870             LDR      R0,[R6, #+4]
   \       0x5A   0x4408             ADD      R0,R1,R0
   \       0x5C   0x6020             STR      R0,[R4, #+0]
    501          
    502              return 0;
   \       0x5E   0x2000             MOVS     R0,#+0
   \                     ??x509_get_uid_1: (+1)
   \       0x60   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    503          }
    504          

   \                                 In section .text, align 2, keep-with-next
    505          static int x509_get_basic_constraints(unsigned char **p,
    506                                                const unsigned char *end,
    507                                                int *ca_istrue,
    508                                                int *max_pathlen)
    509          {
   \                     x509_get_basic_constraints: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    510              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x046D      MVNS     R4,#+109
    511              size_t len;
    512          
    513              /*
    514               * BasicConstraints ::= SEQUENCE {
    515               *      cA                      BOOLEAN DEFAULT FALSE,
    516               *      pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
    517               */
    518              *ca_istrue = 0; /* DEFAULT FALSE */
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x6030             STR      R0,[R6, #+0]
    519              *max_pathlen = 0; /* endless */
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6038             STR      R0,[R7, #+0]
    520          
    521              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    522                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0x18   0x2330             MOVS     R3,#+48
   \       0x1A   0x466A             MOV      R2,SP
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0x4640             MOV      R0,R8
   \       0x20   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x24   0x4681             MOV      R9,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD009             BEQ.N    ??x509_get_basic_constraints_0
    523                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x2A   0xF240 0x230B      MOVW     R3,#+523
   \       0x2E   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x32   0x4649             MOV      R1,R9
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x38   0x.... 0x....      BL       mbedtls_error_add
   \       0x3C   0xE062             B.N      ??x509_get_basic_constraints_1
    524              }
    525          
    526              if (*p == end) {
   \                     ??x509_get_basic_constraints_0: (+1)
   \       0x3E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x42   0x42A8             CMP      R0,R5
   \       0x44   0xD101             BNE.N    ??x509_get_basic_constraints_2
    527                  return 0;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xE05C             B.N      ??x509_get_basic_constraints_1
    528              }
    529          
    530              if ((ret = mbedtls_asn1_get_bool(p, end, ca_istrue)) != 0) {
   \                     ??x509_get_basic_constraints_2: (+1)
   \       0x4A   0x0032             MOVS     R2,R6
   \       0x4C   0x0029             MOVS     R1,R5
   \       0x4E   0x4640             MOV      R0,R8
   \       0x50   0x.... 0x....      BL       mbedtls_asn1_get_bool
   \       0x54   0x0004             MOVS     R4,R0
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD019             BEQ.N    ??x509_get_basic_constraints_3
    531                  if (ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
   \       0x5A   0xF114 0x0F62      CMN      R4,#+98
   \       0x5E   0xD105             BNE.N    ??x509_get_basic_constraints_4
    532                      ret = mbedtls_asn1_get_int(p, end, ca_istrue);
   \       0x60   0x0032             MOVS     R2,R6
   \       0x62   0x0029             MOVS     R1,R5
   \       0x64   0x4640             MOV      R0,R8
   \       0x66   0x.... 0x....      BL       mbedtls_asn1_get_int
   \       0x6A   0x0004             MOVS     R4,R0
    533                  }
    534          
    535                  if (ret != 0) {
   \                     ??x509_get_basic_constraints_4: (+1)
   \       0x6C   0x2C00             CMP      R4,#+0
   \       0x6E   0xD009             BEQ.N    ??x509_get_basic_constraints_5
    536                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x70   0xF44F 0x7306      MOV      R3,#+536
   \       0x74   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x78   0x0021             MOVS     R1,R4
   \       0x7A   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x7E   0x.... 0x....      BL       mbedtls_error_add
   \       0x82   0xE03F             B.N      ??x509_get_basic_constraints_1
    537                  }
    538          
    539                  if (*ca_istrue != 0) {
   \                     ??x509_get_basic_constraints_5: (+1)
   \       0x84   0x6830             LDR      R0,[R6, #+0]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD001             BEQ.N    ??x509_get_basic_constraints_3
    540                      *ca_istrue = 1;
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0x6030             STR      R0,[R6, #+0]
    541                  }
    542              }
    543          
    544              if (*p == end) {
   \                     ??x509_get_basic_constraints_3: (+1)
   \       0x8E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x92   0x42A8             CMP      R0,R5
   \       0x94   0xD101             BNE.N    ??x509_get_basic_constraints_6
    545                  return 0;
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xE034             B.N      ??x509_get_basic_constraints_1
    546              }
    547          
    548              if ((ret = mbedtls_asn1_get_int(p, end, max_pathlen)) != 0) {
   \                     ??x509_get_basic_constraints_6: (+1)
   \       0x9A   0x003A             MOVS     R2,R7
   \       0x9C   0x0029             MOVS     R1,R5
   \       0x9E   0x4640             MOV      R0,R8
   \       0xA0   0x.... 0x....      BL       mbedtls_asn1_get_int
   \       0xA4   0x4681             MOV      R9,R0
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD009             BEQ.N    ??x509_get_basic_constraints_7
    549                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0xAA   0xF240 0x2325      MOVW     R3,#+549
   \       0xAE   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0xB2   0x4649             MOV      R1,R9
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0xB8   0x.... 0x....      BL       mbedtls_error_add
   \       0xBC   0xE022             B.N      ??x509_get_basic_constraints_1
    550              }
    551          
    552              if (*p != end) {
   \                     ??x509_get_basic_constraints_7: (+1)
   \       0xBE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xC2   0x42A8             CMP      R0,R5
   \       0xC4   0xD00A             BEQ.N    ??x509_get_basic_constraints_8
    553                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    554                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \       0xC6   0xF240 0x232A      MOVW     R3,#+554
   \       0xCA   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0xCE   0xF07F 0x0165      MVNS     R1,#+101
   \       0xD2   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0xD6   0x.... 0x....      BL       mbedtls_error_add
   \       0xDA   0xE013             B.N      ??x509_get_basic_constraints_1
    555              }
    556          
    557              /* Do not accept max_pathlen equal to INT_MAX to avoid a signed integer
    558               * overflow, which is an undefined behavior. */
    559              if (*max_pathlen == INT_MAX) {
   \                     ??x509_get_basic_constraints_8: (+1)
   \       0xDC   0x6839             LDR      R1,[R7, #+0]
   \       0xDE   0xF07F 0x4000      MVNS     R0,#+2147483648
   \       0xE2   0x4281             CMP      R1,R0
   \       0xE4   0xD10A             BNE.N    ??x509_get_basic_constraints_9
    560                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    561                                           MBEDTLS_ERR_ASN1_INVALID_LENGTH);
   \       0xE6   0xF240 0x2331      MOVW     R3,#+561
   \       0xEA   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0xEE   0xF07F 0x0163      MVNS     R1,#+99
   \       0xF2   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0xF6   0x.... 0x....      BL       mbedtls_error_add
   \       0xFA   0xE003             B.N      ??x509_get_basic_constraints_1
    562              }
    563          
    564              (*max_pathlen)++;
   \                     ??x509_get_basic_constraints_9: (+1)
   \       0xFC   0x6838             LDR      R0,[R7, #+0]
   \       0xFE   0x1C40             ADDS     R0,R0,#+1
   \      0x100   0x6038             STR      R0,[R7, #+0]
    565          
    566              return 0;
   \      0x102   0x2000             MOVS     R0,#+0
   \                     ??x509_get_basic_constraints_1: (+1)
   \      0x104   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    567          }
    568          
    569          /*
    570           * ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId
    571           *
    572           * KeyPurposeId ::= OBJECT IDENTIFIER
    573           */

   \                                 In section .text, align 2, keep-with-next
    574          static int x509_get_ext_key_usage(unsigned char **p,
    575                                            const unsigned char *end,
    576                                            mbedtls_x509_sequence *ext_key_usage)
    577          {
   \                     x509_get_ext_key_usage: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    578              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x086D      MVNS     R8,#+109
    579          
    580              if ((ret = mbedtls_asn1_get_sequence_of(p, end, ext_key_usage, MBEDTLS_ASN1_OID)) != 0) {
   \        0xE   0x2306             MOVS     R3,#+6
   \       0x10   0x0032             MOVS     R2,R6
   \       0x12   0x0029             MOVS     R1,R5
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       mbedtls_asn1_get_sequence_of
   \       0x1A   0x0007             MOVS     R7,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD009             BEQ.N    ??x509_get_ext_key_usage_0
    581                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x20   0xF240 0x2345      MOVW     R3,#+581
   \       0x24   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x28   0x0039             MOVS     R1,R7
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x2E   0x.... 0x....      BL       mbedtls_error_add
   \       0x32   0xE00E             B.N      ??x509_get_ext_key_usage_1
    582              }
    583          
    584              /* Sequence length must be >= 1 */
    585              if (ext_key_usage->buf.p == NULL) {
   \                     ??x509_get_ext_key_usage_0: (+1)
   \       0x34   0x68B0             LDR      R0,[R6, #+8]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD10A             BNE.N    ??x509_get_ext_key_usage_2
    586                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    587                                           MBEDTLS_ERR_ASN1_INVALID_LENGTH);
   \       0x3A   0xF240 0x234B      MOVW     R3,#+587
   \       0x3E   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x42   0xF07F 0x0163      MVNS     R1,#+99
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x4A   0x.... 0x....      BL       mbedtls_error_add
   \       0x4E   0xE000             B.N      ??x509_get_ext_key_usage_1
    588              }
    589          
    590              return 0;
   \                     ??x509_get_ext_key_usage_2: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \                     ??x509_get_ext_key_usage_1: (+1)
   \       0x52   0xE8BD 0x81F0      POP      {R4-R8,PC}
    591          }
    592          
    593          /*
    594           * SubjectKeyIdentifier ::= KeyIdentifier
    595           *
    596           * KeyIdentifier ::= OCTET STRING
    597           */

   \                                 In section .text, align 2, keep-with-next
    598          static int x509_get_subject_key_id(unsigned char **p,
    599                                             const unsigned char *end,
    600                                             mbedtls_x509_buf *subject_key_id)
    601          {
   \                     x509_get_subject_key_id: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    602              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x076D      MVNS     R7,#+109
    603              size_t len = 0u;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9000             STR      R0,[SP, #+0]
    604          
    605              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    606                                              MBEDTLS_ASN1_OCTET_STRING)) != 0) {
   \       0x12   0x2304             MOVS     R3,#+4
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x1E   0x4680             MOV      R8,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD009             BEQ.N    ??x509_get_subject_key_id_0
    607                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x24   0xF240 0x235F      MOVW     R3,#+607
   \       0x28   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x2C   0x4641             MOV      R1,R8
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x32   0x.... 0x....      BL       mbedtls_error_add
   \       0x36   0xE018             B.N      ??x509_get_subject_key_id_1
    608              }
    609          
    610              subject_key_id->len = len;
   \                     ??x509_get_subject_key_id_0: (+1)
   \       0x38   0x9800             LDR      R0,[SP, #+0]
   \       0x3A   0x6070             STR      R0,[R6, #+4]
    611              subject_key_id->tag = MBEDTLS_ASN1_OCTET_STRING;
   \       0x3C   0x2004             MOVS     R0,#+4
   \       0x3E   0x6030             STR      R0,[R6, #+0]
    612              subject_key_id->p = *p;
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x60B0             STR      R0,[R6, #+8]
    613              *p += len;
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0x4408             ADD      R0,R1,R0
   \       0x4A   0x6020             STR      R0,[R4, #+0]
    614          
    615              if (*p != end) {
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x42A8             CMP      R0,R5
   \       0x50   0xD00A             BEQ.N    ??x509_get_subject_key_id_2
    616                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    617                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \       0x52   0xF240 0x2369      MOVW     R3,#+617
   \       0x56   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x5A   0xF07F 0x0165      MVNS     R1,#+101
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x62   0x.... 0x....      BL       mbedtls_error_add
   \       0x66   0xE000             B.N      ??x509_get_subject_key_id_1
    618              }
    619          
    620              return 0;
   \                     ??x509_get_subject_key_id_2: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??x509_get_subject_key_id_1: (+1)
   \       0x6A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    621          }
    622          
    623          /*
    624           * AuthorityKeyIdentifier ::= SEQUENCE {
    625           *        keyIdentifier [0] KeyIdentifier OPTIONAL,
    626           *        authorityCertIssuer [1] GeneralNames OPTIONAL,
    627           *        authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL }
    628           *
    629           *    KeyIdentifier ::= OCTET STRING
    630           */

   \                                 In section .text, align 2, keep-with-next
    631          static int x509_get_authority_key_id(unsigned char **p,
    632                                               unsigned char *end,
    633                                               mbedtls_x509_authority *authority_key_id)
    634          {
   \                     x509_get_authority_key_id: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
    635              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x046D      MVNS     R4,#+109
    636              size_t len = 0u;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9000             STR      R0,[SP, #+0]
    637          
    638              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    639                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0x12   0x2330             MOVS     R3,#+48
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x0031             MOVS     R1,R6
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x1E   0x0005             MOVS     R5,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD009             BEQ.N    ??x509_get_authority_key_id_0
    640                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x24   0xF44F 0x7320      MOV      R3,#+640
   \       0x28   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x32   0x.... 0x....      BL       mbedtls_error_add
   \       0x36   0xE081             B.N      ??x509_get_authority_key_id_1
    641              }
    642          
    643              if (*p + len != end) {
   \                     ??x509_get_authority_key_id_0: (+1)
   \       0x38   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x3C   0x9800             LDR      R0,[SP, #+0]
   \       0x3E   0x4408             ADD      R0,R1,R0
   \       0x40   0x42B0             CMP      R0,R6
   \       0x42   0xD00A             BEQ.N    ??x509_get_authority_key_id_2
    644                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    645                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \       0x44   0xF240 0x2385      MOVW     R3,#+645
   \       0x48   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x4C   0xF07F 0x0165      MVNS     R1,#+101
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x54   0x.... 0x....      BL       mbedtls_error_add
   \       0x58   0xE070             B.N      ??x509_get_authority_key_id_1
    646              }
    647          
    648              ret = mbedtls_asn1_get_tag(p, end, &len,
    649                                         MBEDTLS_ASN1_CONTEXT_SPECIFIC);
   \                     ??x509_get_authority_key_id_2: (+1)
   \       0x5A   0x2380             MOVS     R3,#+128
   \       0x5C   0x466A             MOV      R2,SP
   \       0x5E   0x0031             MOVS     R1,R6
   \       0x60   0x4640             MOV      R0,R8
   \       0x62   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x66   0x0004             MOVS     R4,R0
    650          
    651              /* KeyIdentifier is an OPTIONAL field */
    652              if (ret == 0) {
   \       0x68   0x2C00             CMP      R4,#+0
   \       0x6A   0xD10D             BNE.N    ??x509_get_authority_key_id_3
    653                  authority_key_id->keyIdentifier.len = len;
   \       0x6C   0x9800             LDR      R0,[SP, #+0]
   \       0x6E   0x6078             STR      R0,[R7, #+4]
    654                  authority_key_id->keyIdentifier.p = *p;
   \       0x70   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x74   0x60B8             STR      R0,[R7, #+8]
    655                  /* Setting tag of the keyIdentfier intentionally to 0x04.
    656                   * Although the .keyIdentfier field is CONTEXT_SPECIFIC ([0] OPTIONAL),
    657                   * its tag with the content is the payload of on OCTET STRING primitive */
    658                  authority_key_id->keyIdentifier.tag = MBEDTLS_ASN1_OCTET_STRING;
   \       0x76   0x2004             MOVS     R0,#+4
   \       0x78   0x6038             STR      R0,[R7, #+0]
    659          
    660                  *p += len;
   \       0x7A   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x7E   0x9800             LDR      R0,[SP, #+0]
   \       0x80   0x4408             ADD      R0,R1,R0
   \       0x82   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \       0x86   0xE00C             B.N      ??x509_get_authority_key_id_4
    661              } else if (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
   \                     ??x509_get_authority_key_id_3: (+1)
   \       0x88   0xF114 0x0F62      CMN      R4,#+98
   \       0x8C   0xD009             BEQ.N    ??x509_get_authority_key_id_4
    662                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x8E   0xF240 0x2396      MOVW     R3,#+662
   \       0x92   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x96   0x0021             MOVS     R1,R4
   \       0x98   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x9C   0x.... 0x....      BL       mbedtls_error_add
   \       0xA0   0xE04C             B.N      ??x509_get_authority_key_id_1
    663              }
    664          
    665              if (*p < end) {
   \                     ??x509_get_authority_key_id_4: (+1)
   \       0xA2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xA6   0x42B0             CMP      R0,R6
   \       0xA8   0xD240             BCS.N    ??x509_get_authority_key_id_5
    666                  /* Getting authorityCertIssuer using the required specific class tag [1] */
    667                  if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    668                                                  MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    669                                                  1)) != 0) {
   \       0xAA   0x23A1             MOVS     R3,#+161
   \       0xAC   0x466A             MOV      R2,SP
   \       0xAE   0x0031             MOVS     R1,R6
   \       0xB0   0x4640             MOV      R0,R8
   \       0xB2   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0xB6   0x4681             MOV      R9,R0
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD009             BEQ.N    ??x509_get_authority_key_id_6
    670                      /* authorityCertIssuer and authorityCertSerialNumber MUST both
    671                         be present or both be absent. At this point we expect to have both. */
    672                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0xBC   0xF44F 0x7328      MOV      R3,#+672
   \       0xC0   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0xC4   0x4649             MOV      R1,R9
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0xCA   0x.... 0x....      BL       mbedtls_error_add
   \       0xCE   0xE035             B.N      ??x509_get_authority_key_id_1
    673                  }
    674                  /* "end" also includes the CertSerialNumber field so "len" shall be used */
    675                  ret = mbedtls_x509_get_subject_alt_name_ext(p,
    676                                                              (*p+len),
    677                                                              &authority_key_id->authorityCertIssuer);
   \                     ??x509_get_authority_key_id_6: (+1)
   \       0xD0   0xF117 0x020C      ADDS     R2,R7,#+12
   \       0xD4   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xD8   0x9800             LDR      R0,[SP, #+0]
   \       0xDA   0x4401             ADD      R1,R1,R0
   \       0xDC   0x4640             MOV      R0,R8
   \       0xDE   0x.... 0x....      BL       mbedtls_x509_get_subject_alt_name_ext
   \       0xE2   0x0005             MOVS     R5,R0
    678                  if (ret != 0) {
   \       0xE4   0x2D00             CMP      R5,#+0
   \       0xE6   0xD001             BEQ.N    ??x509_get_authority_key_id_7
    679                      return ret;
   \       0xE8   0x0028             MOVS     R0,R5
   \       0xEA   0xE027             B.N      ??x509_get_authority_key_id_1
    680                  }
    681          
    682                  /* Getting authorityCertSerialNumber using the required specific class tag [2] */
    683                  if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    684                                                  MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2)) != 0) {
   \                     ??x509_get_authority_key_id_7: (+1)
   \       0xEC   0x2382             MOVS     R3,#+130
   \       0xEE   0x466A             MOV      R2,SP
   \       0xF0   0x0031             MOVS     R1,R6
   \       0xF2   0x4640             MOV      R0,R8
   \       0xF4   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0xF8   0x0004             MOVS     R4,R0
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xD009             BEQ.N    ??x509_get_authority_key_id_8
    685                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0xFE   0xF240 0x23AD      MOVW     R3,#+685
   \      0x102   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \      0x106   0x0021             MOVS     R1,R4
   \      0x108   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x10C   0x.... 0x....      BL       mbedtls_error_add
   \      0x110   0xE014             B.N      ??x509_get_authority_key_id_1
    686                  }
    687                  authority_key_id->authorityCertSerialNumber.len = len;
   \                     ??x509_get_authority_key_id_8: (+1)
   \      0x112   0x9800             LDR      R0,[SP, #+0]
   \      0x114   0x6238             STR      R0,[R7, #+32]
    688                  authority_key_id->authorityCertSerialNumber.p = *p;
   \      0x116   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x11A   0x6278             STR      R0,[R7, #+36]
    689                  authority_key_id->authorityCertSerialNumber.tag = MBEDTLS_ASN1_INTEGER;
   \      0x11C   0x2002             MOVS     R0,#+2
   \      0x11E   0x61F8             STR      R0,[R7, #+28]
    690                  *p += len;
   \      0x120   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \      0x124   0x9800             LDR      R0,[SP, #+0]
   \      0x126   0x4408             ADD      R0,R1,R0
   \      0x128   0xF8C8 0x0000      STR      R0,[R8, #+0]
    691              }
    692          
    693              if (*p != end) {
   \                     ??x509_get_authority_key_id_5: (+1)
   \      0x12C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x130   0x42B0             CMP      R0,R6
   \      0x132   0xD002             BEQ.N    ??x509_get_authority_key_id_9
    694                  return MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
    695                         MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
   \      0x134   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x138   0xE000             B.N      ??x509_get_authority_key_id_1
    696              }
    697          
    698              return 0;
   \                     ??x509_get_authority_key_id_9: (+1)
   \      0x13A   0x2000             MOVS     R0,#+0
   \                     ??x509_get_authority_key_id_1: (+1)
   \      0x13C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    699          }
    700          
    701          /*
    702           * id-ce-certificatePolicies OBJECT IDENTIFIER ::=  { id-ce 32 }
    703           *
    704           * anyPolicy OBJECT IDENTIFIER ::= { id-ce-certificatePolicies 0 }
    705           *
    706           * certificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation
    707           *
    708           * PolicyInformation ::= SEQUENCE {
    709           *     policyIdentifier   CertPolicyId,
    710           *     policyQualifiers   SEQUENCE SIZE (1..MAX) OF
    711           *                             PolicyQualifierInfo OPTIONAL }
    712           *
    713           * CertPolicyId ::= OBJECT IDENTIFIER
    714           *
    715           * PolicyQualifierInfo ::= SEQUENCE {
    716           *      policyQualifierId  PolicyQualifierId,
    717           *      qualifier          ANY DEFINED BY policyQualifierId }
    718           *
    719           * -- policyQualifierIds for Internet policy qualifiers
    720           *
    721           * id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
    722           * id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
    723           * id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
    724           *
    725           * PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
    726           *
    727           * Qualifier ::= CHOICE {
    728           *      cPSuri           CPSuri,
    729           *      userNotice       UserNotice }
    730           *
    731           * CPSuri ::= IA5String
    732           *
    733           * UserNotice ::= SEQUENCE {
    734           *      noticeRef        NoticeReference OPTIONAL,
    735           *      explicitText     DisplayText OPTIONAL }
    736           *
    737           * NoticeReference ::= SEQUENCE {
    738           *      organization     DisplayText,
    739           *      noticeNumbers    SEQUENCE OF INTEGER }
    740           *
    741           * DisplayText ::= CHOICE {
    742           *      ia5String        IA5String      (SIZE (1..200)),
    743           *      visibleString    VisibleString  (SIZE (1..200)),
    744           *      bmpString        BMPString      (SIZE (1..200)),
    745           *      utf8String       UTF8String     (SIZE (1..200)) }
    746           *
    747           * NOTE: we only parse and use anyPolicy without qualifiers at this point
    748           * as defined in RFC 5280.
    749           */

   \                                 In section .text, align 2, keep-with-next
    750          static int x509_get_certificate_policies(unsigned char **p,
    751                                                   const unsigned char *end,
    752                                                   mbedtls_x509_sequence *certificate_policies)
    753          {
   \                     x509_get_certificate_policies: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
    754              int ret, parse_ret = 0;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
    755              size_t len;
    756              mbedtls_asn1_buf *buf;
    757              mbedtls_asn1_sequence *cur = certificate_policies;
   \       0x10   0x46B9             MOV      R9,R7
    758          
    759              /* Get main sequence tag */
    760              ret = mbedtls_asn1_get_tag(p, end, &len,
    761                                         MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
   \       0x12   0x2330             MOVS     R3,#+48
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x0031             MOVS     R1,R6
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x1E   0x0004             MOVS     R4,R0
    762              if (ret != 0) {
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD009             BEQ.N    ??x509_get_certificate_policies_0
    763                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x24   0xF240 0x23FB      MOVW     R3,#+763
   \       0x28   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x2C   0x0021             MOVS     R1,R4
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x32   0x.... 0x....      BL       mbedtls_error_add
   \       0x36   0xE0D0             B.N      ??x509_get_certificate_policies_1
    764              }
    765          
    766              if (*p + len != end) {
   \                     ??x509_get_certificate_policies_0: (+1)
   \       0x38   0x6829             LDR      R1,[R5, #+0]
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
   \       0x3C   0x4408             ADD      R0,R1,R0
   \       0x3E   0x42B0             CMP      R0,R6
   \       0x40   0xD00A             BEQ.N    ??x509_get_certificate_policies_2
    767                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    768                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \       0x42   0xF44F 0x7340      MOV      R3,#+768
   \       0x46   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x4A   0xF07F 0x0165      MVNS     R1,#+101
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x52   0x.... 0x....      BL       mbedtls_error_add
   \       0x56   0xE0C0             B.N      ??x509_get_certificate_policies_1
    769              }
    770          
    771              /*
    772               * Cannot be an empty sequence.
    773               */
    774              if (len == 0) {
   \                     ??x509_get_certificate_policies_2: (+1)
   \       0x58   0x9800             LDR      R0,[SP, #+0]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD10A             BNE.N    ??x509_get_certificate_policies_3
    775                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    776                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \       0x5E   0xF44F 0x7342      MOV      R3,#+776
   \       0x62   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x66   0xF07F 0x0165      MVNS     R1,#+101
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x6E   0x.... 0x....      BL       mbedtls_error_add
   \       0x72   0xE0B2             B.N      ??x509_get_certificate_policies_1
    777              }
    778          
    779              while (*p < end) {
   \                     ??x509_get_certificate_policies_3: (+1)
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x42B0             CMP      R0,R6
   \       0x78   0xF080 0x809D      BCS.W    ??x509_get_certificate_policies_4
    780                  mbedtls_x509_buf policy_oid;
    781                  const unsigned char *policy_end;
    782          
    783                  /*
    784                   * Get the policy sequence
    785                   */
    786                  if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    787                                                  MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0x7C   0x2330             MOVS     R3,#+48
   \       0x7E   0x466A             MOV      R2,SP
   \       0x80   0x0031             MOVS     R1,R6
   \       0x82   0x0028             MOVS     R0,R5
   \       0x84   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x88   0x9004             STR      R0,[SP, #+16]
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD009             BEQ.N    ??x509_get_certificate_policies_5
    788                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x8E   0xF44F 0x7345      MOV      R3,#+788
   \       0x92   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x96   0x9904             LDR      R1,[SP, #+16]
   \       0x98   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x9C   0x.... 0x....      BL       mbedtls_error_add
   \       0xA0   0xE09B             B.N      ??x509_get_certificate_policies_1
    789                  }
    790          
    791                  policy_end = *p + len;
   \                     ??x509_get_certificate_policies_5: (+1)
   \       0xA2   0x6828             LDR      R0,[R5, #+0]
   \       0xA4   0x9900             LDR      R1,[SP, #+0]
   \       0xA6   0xEB00 0x0A01      ADD      R10,R0,R1
    792          
    793                  if ((ret = mbedtls_asn1_get_tag(p, policy_end, &len,
    794                                                  MBEDTLS_ASN1_OID)) != 0) {
   \       0xAA   0x2306             MOVS     R3,#+6
   \       0xAC   0x466A             MOV      R2,SP
   \       0xAE   0x4651             MOV      R1,R10
   \       0xB0   0x0028             MOVS     R0,R5
   \       0xB2   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0xB6   0x0004             MOVS     R4,R0
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD009             BEQ.N    ??x509_get_certificate_policies_6
    795                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0xBC   0xF240 0x331B      MOVW     R3,#+795
   \       0xC0   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0xC4   0x0021             MOVS     R1,R4
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0xCA   0x.... 0x....      BL       mbedtls_error_add
   \       0xCE   0xE084             B.N      ??x509_get_certificate_policies_1
    796                  }
    797          
    798                  policy_oid.tag = MBEDTLS_ASN1_OID;
   \                     ??x509_get_certificate_policies_6: (+1)
   \       0xD0   0x2006             MOVS     R0,#+6
   \       0xD2   0x9001             STR      R0,[SP, #+4]
    799                  policy_oid.len = len;
   \       0xD4   0x9800             LDR      R0,[SP, #+0]
   \       0xD6   0x9002             STR      R0,[SP, #+8]
    800                  policy_oid.p = *p;
   \       0xD8   0x6828             LDR      R0,[R5, #+0]
   \       0xDA   0x9003             STR      R0,[SP, #+12]
    801          
    802                  /*
    803                   * Only AnyPolicy is currently supported when enforcing policy.
    804                   */
    805                  if (MBEDTLS_OID_CMP(MBEDTLS_OID_ANY_POLICY, &policy_oid) != 0) {
   \       0xDC   0x9802             LDR      R0,[SP, #+8]
   \       0xDE   0x2804             CMP      R0,#+4
   \       0xE0   0xD107             BNE.N    ??x509_get_certificate_policies_7
   \       0xE2   0x9A02             LDR      R2,[SP, #+8]
   \       0xE4   0x9903             LDR      R1,[SP, #+12]
   \       0xE6   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \       0xEA   0x.... 0x....      BL       memcmp
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD001             BEQ.N    ??x509_get_certificate_policies_8
   \                     ??x509_get_certificate_policies_7: (+1)
   \       0xF2   0x2001             MOVS     R0,#+1
   \       0xF4   0xE000             B.N      ??x509_get_certificate_policies_9
   \                     ??x509_get_certificate_policies_8: (+1)
   \       0xF6   0x2000             MOVS     R0,#+0
   \                     ??x509_get_certificate_policies_9: (+1)
   \       0xF8   0xB2C0             UXTB     R0,R0
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xD002             BEQ.N    ??x509_get_certificate_policies_10
    806                      /*
    807                       * Set the parsing return code but continue parsing, in case this
    808                       * extension is critical.
    809                       */
    810                      parse_ret = MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE;
   \       0xFE   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \      0x102   0x4680             MOV      R8,R0
    811                  }
    812          
    813                  /* Allocate and assign next pointer */
    814                  if (cur->buf.p != NULL) {
   \                     ??x509_get_certificate_policies_10: (+1)
   \      0x104   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD01D             BEQ.N    ??x509_get_certificate_policies_11
    815                      if (cur->next != NULL) {
   \      0x10C   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD002             BEQ.N    ??x509_get_certificate_policies_12
    816                          return MBEDTLS_ERR_X509_INVALID_EXTENSIONS;
   \      0x114   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x118   0xE05F             B.N      ??x509_get_certificate_policies_1
    817                      }
    818          
    819                      cur->next = mbedtls_calloc(1, sizeof(mbedtls_asn1_sequence));
   \                     ??x509_get_certificate_policies_12: (+1)
   \      0x11A   0x2110             MOVS     R1,#+16
   \      0x11C   0x2001             MOVS     R0,#+1
   \      0x11E   0x.... 0x....      BL       sl_calloc
   \      0x122   0xF8C9 0x000C      STR      R0,[R9, #+12]
    820          
    821                      if (cur->next == NULL) {
   \      0x126   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD10A             BNE.N    ??x509_get_certificate_policies_13
    822                          return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    823                                                   MBEDTLS_ERR_ASN1_ALLOC_FAILED);
   \      0x12E   0xF240 0x3337      MOVW     R3,#+823
   \      0x132   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \      0x136   0xF07F 0x0169      MVNS     R1,#+105
   \      0x13A   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x13E   0x.... 0x....      BL       mbedtls_error_add
   \      0x142   0xE04A             B.N      ??x509_get_certificate_policies_1
    824                      }
    825          
    826                      cur = cur->next;
   \                     ??x509_get_certificate_policies_13: (+1)
   \      0x144   0xF8D9 0x900C      LDR      R9,[R9, #+12]
    827                  }
    828          
    829                  buf = &(cur->buf);
   \                     ??x509_get_certificate_policies_11: (+1)
   \      0x148   0x46CB             MOV      R11,R9
    830                  buf->tag = policy_oid.tag;
   \      0x14A   0x9801             LDR      R0,[SP, #+4]
   \      0x14C   0xF8CB 0x0000      STR      R0,[R11, #+0]
    831                  buf->p = policy_oid.p;
   \      0x150   0x9803             LDR      R0,[SP, #+12]
   \      0x152   0xF8CB 0x0008      STR      R0,[R11, #+8]
    832                  buf->len = policy_oid.len;
   \      0x156   0x9802             LDR      R0,[SP, #+8]
   \      0x158   0xF8CB 0x0004      STR      R0,[R11, #+4]
    833          
    834                  *p += len;
   \      0x15C   0x6829             LDR      R1,[R5, #+0]
   \      0x15E   0x9800             LDR      R0,[SP, #+0]
   \      0x160   0x4408             ADD      R0,R1,R0
   \      0x162   0x6028             STR      R0,[R5, #+0]
    835          
    836                  /*
    837                   * If there is an optional qualifier, then *p < policy_end
    838                   * Check the Qualifier len to verify it doesn't exceed policy_end.
    839                   */
    840                  if (*p < policy_end) {
   \      0x164   0x6828             LDR      R0,[R5, #+0]
   \      0x166   0x4550             CMP      R0,R10
   \      0x168   0xD216             BCS.N    ??x509_get_certificate_policies_14
    841                      if ((ret = mbedtls_asn1_get_tag(p, policy_end, &len,
    842                                                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) !=
    843                          0) {
   \      0x16A   0x2330             MOVS     R3,#+48
   \      0x16C   0x466A             MOV      R2,SP
   \      0x16E   0x4651             MOV      R1,R10
   \      0x170   0x0028             MOVS     R0,R5
   \      0x172   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \      0x176   0x0004             MOVS     R4,R0
   \      0x178   0x2800             CMP      R0,#+0
   \      0x17A   0xD009             BEQ.N    ??x509_get_certificate_policies_15
    844                          return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \      0x17C   0xF44F 0x7353      MOV      R3,#+844
   \      0x180   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \      0x184   0x0021             MOVS     R1,R4
   \      0x186   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x18A   0x.... 0x....      BL       mbedtls_error_add
   \      0x18E   0xE024             B.N      ??x509_get_certificate_policies_1
    845                      }
    846                      /*
    847                       * Skip the optional policy qualifiers.
    848                       */
    849                      *p += len;
   \                     ??x509_get_certificate_policies_15: (+1)
   \      0x190   0x6829             LDR      R1,[R5, #+0]
   \      0x192   0x9800             LDR      R0,[SP, #+0]
   \      0x194   0x4408             ADD      R0,R1,R0
   \      0x196   0x6028             STR      R0,[R5, #+0]
    850                  }
    851          
    852                  if (*p != policy_end) {
   \                     ??x509_get_certificate_policies_14: (+1)
   \      0x198   0x6828             LDR      R0,[R5, #+0]
   \      0x19A   0x4550             CMP      R0,R10
   \      0x19C   0xF43F 0xAF6A      BEQ.W    ??x509_get_certificate_policies_3
    853                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    854                                               MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \      0x1A0   0xF240 0x3356      MOVW     R3,#+854
   \      0x1A4   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \      0x1A8   0xF07F 0x0165      MVNS     R1,#+101
   \      0x1AC   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x1B0   0x.... 0x....      BL       mbedtls_error_add
   \      0x1B4   0xE011             B.N      ??x509_get_certificate_policies_1
    855                  }
    856              }
    857          
    858              /* Set final sequence entry's next pointer to NULL */
    859              cur->next = NULL;
   \                     ??x509_get_certificate_policies_4: (+1)
   \      0x1B6   0x2000             MOVS     R0,#+0
   \      0x1B8   0xF8C9 0x000C      STR      R0,[R9, #+12]
    860          
    861              if (*p != end) {
   \      0x1BC   0x6828             LDR      R0,[R5, #+0]
   \      0x1BE   0x42B0             CMP      R0,R6
   \      0x1C0   0xD00A             BEQ.N    ??x509_get_certificate_policies_16
    862                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    863                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \      0x1C2   0xF240 0x335F      MOVW     R3,#+863
   \      0x1C6   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \      0x1CA   0xF07F 0x0165      MVNS     R1,#+101
   \      0x1CE   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x1D2   0x.... 0x....      BL       mbedtls_error_add
   \      0x1D6   0xE000             B.N      ??x509_get_certificate_policies_1
    864              }
    865          
    866              return parse_ret;
   \                     ??x509_get_certificate_policies_16: (+1)
   \      0x1D8   0x4640             MOV      R0,R8
   \                     ??x509_get_certificate_policies_1: (+1)
   \      0x1DA   0xB005             ADD      SP,SP,#+20
   \      0x1DC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    867          }
    868          
    869          /*
    870           * X.509 v3 extensions
    871           *
    872           */

   \                                 In section .text, align 2, keep-with-next
    873          static int x509_get_crt_ext(unsigned char **p,
    874                                      const unsigned char *end,
    875                                      mbedtls_x509_crt *crt,
    876                                      mbedtls_x509_crt_ext_cb_t cb,
    877                                      void *p_ctx)
    878          {
   \                     x509_get_crt_ext: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x0006             MOVS     R6,R0
   \        0x8   0x468A             MOV      R10,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0xF8DD 0x9050      LDR      R9,[SP, #+80]
    879              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x006D      MVNS     R0,#+109
   \       0x16   0x9000             STR      R0,[SP, #+0]
    880              size_t len;
    881              unsigned char *end_ext_data, *start_ext_octet, *end_ext_octet;
    882          
    883              if (*p == end) {
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x4550             CMP      R0,R10
   \       0x1C   0xD101             BNE.N    ??x509_get_crt_ext_0
    884                  return 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xE16D             B.N      ??x509_get_crt_ext_1
    885              }
    886          
    887              if ((ret = mbedtls_x509_get_ext(p, end, &crt->v3_ext, 3)) != 0) {
   \                     ??x509_get_crt_ext_0: (+1)
   \       0x22   0x2303             MOVS     R3,#+3
   \       0x24   0xF517 0x72C2      ADDS     R2,R7,#+388
   \       0x28   0x4651             MOV      R1,R10
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0x.... 0x....      BL       mbedtls_x509_get_ext
   \       0x30   0x0004             MOVS     R4,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD001             BEQ.N    ??x509_get_crt_ext_2
    888                  return ret;
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0xE161             B.N      ??x509_get_crt_ext_1
    889              }
    890          
    891              end = crt->v3_ext.p + crt->v3_ext.len;
   \                     ??x509_get_crt_ext_2: (+1)
   \       0x3A   0xF8D7 0x118C      LDR      R1,[R7, #+396]
   \       0x3E   0xF8D7 0x0188      LDR      R0,[R7, #+392]
   \       0x42   0x4408             ADD      R0,R1,R0
   \       0x44   0x9005             STR      R0,[SP, #+20]
    892              while (*p < end) {
   \                     ??x509_get_crt_ext_3: (+1)
   \       0x46   0x6831             LDR      R1,[R6, #+0]
   \       0x48   0x9805             LDR      R0,[SP, #+20]
   \       0x4A   0x4281             CMP      R1,R0
   \       0x4C   0xF080 0x8148      BCS.W    ??x509_get_crt_ext_4
    893                  /*
    894                   * Extension  ::=  SEQUENCE  {
    895                   *      extnID      OBJECT IDENTIFIER,
    896                   *      critical    BOOLEAN DEFAULT FALSE,
    897                   *      extnValue   OCTET STRING  }
    898                   */
    899                  mbedtls_x509_buf extn_oid = { 0, 0, NULL };
   \       0x50   0xAA06             ADD      R2,SP,#+24
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0x2300             MOVS     R3,#+0
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xE882 0x000B      STM      R2,{R0,R1,R3}
    900                  int is_critical = 0; /* DEFAULT FALSE */
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x9002             STR      R0,[SP, #+8]
    901                  int ext_type = 0;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x9003             STR      R0,[SP, #+12]
    902          
    903                  if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    904                                                  MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0x64   0x2330             MOVS     R3,#+48
   \       0x66   0xAA04             ADD      R2,SP,#+16
   \       0x68   0x9905             LDR      R1,[SP, #+20]
   \       0x6A   0x0030             MOVS     R0,R6
   \       0x6C   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x70   0x9000             STR      R0,[SP, #+0]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD009             BEQ.N    ??x509_get_crt_ext_5
    905                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x76   0xF240 0x3389      MOVW     R3,#+905
   \       0x7A   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0x7E   0x9900             LDR      R1,[SP, #+0]
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x84   0x.... 0x....      BL       mbedtls_error_add
   \       0x88   0xE139             B.N      ??x509_get_crt_ext_1
    906                  }
    907          
    908                  end_ext_data = *p + len;
   \                     ??x509_get_crt_ext_5: (+1)
   \       0x8A   0x6831             LDR      R1,[R6, #+0]
   \       0x8C   0x9804             LDR      R0,[SP, #+16]
   \       0x8E   0x4408             ADD      R0,R1,R0
   \       0x90   0x4683             MOV      R11,R0
    909          
    910                  /* Get extension ID */
    911                  if ((ret = mbedtls_asn1_get_tag(p, end_ext_data, &extn_oid.len,
    912                                                  MBEDTLS_ASN1_OID)) != 0) {
   \       0x92   0x2306             MOVS     R3,#+6
   \       0x94   0xAA07             ADD      R2,SP,#+28
   \       0x96   0x4659             MOV      R1,R11
   \       0x98   0x0030             MOVS     R0,R6
   \       0x9A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x9E   0x4682             MOV      R10,R0
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD009             BEQ.N    ??x509_get_crt_ext_6
    913                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0xA4   0xF240 0x3391      MOVW     R3,#+913
   \       0xA8   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0xAC   0x4651             MOV      R1,R10
   \       0xAE   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0xB2   0x.... 0x....      BL       mbedtls_error_add
   \       0xB6   0xE122             B.N      ??x509_get_crt_ext_1
    914                  }
    915          
    916                  extn_oid.tag = MBEDTLS_ASN1_OID;
   \                     ??x509_get_crt_ext_6: (+1)
   \       0xB8   0x2006             MOVS     R0,#+6
   \       0xBA   0x9006             STR      R0,[SP, #+24]
    917                  extn_oid.p = *p;
   \       0xBC   0x6830             LDR      R0,[R6, #+0]
   \       0xBE   0x9008             STR      R0,[SP, #+32]
    918                  *p += extn_oid.len;
   \       0xC0   0x6831             LDR      R1,[R6, #+0]
   \       0xC2   0x9807             LDR      R0,[SP, #+28]
   \       0xC4   0x4408             ADD      R0,R1,R0
   \       0xC6   0x6030             STR      R0,[R6, #+0]
    919          
    920                  /* Get optional critical */
    921                  if ((ret = mbedtls_asn1_get_bool(p, end_ext_data, &is_critical)) != 0 &&
    922                      (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG)) {
   \       0xC8   0xAA02             ADD      R2,SP,#+8
   \       0xCA   0x4659             MOV      R1,R11
   \       0xCC   0x0030             MOVS     R0,R6
   \       0xCE   0x.... 0x....      BL       mbedtls_asn1_get_bool
   \       0xD2   0x0004             MOVS     R4,R0
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD00C             BEQ.N    ??x509_get_crt_ext_7
   \       0xD8   0xF114 0x0F62      CMN      R4,#+98
   \       0xDC   0xD009             BEQ.N    ??x509_get_crt_ext_7
    923                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0xDE   0xF240 0x339B      MOVW     R3,#+923
   \       0xE2   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \       0xE6   0x0021             MOVS     R1,R4
   \       0xE8   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0xEC   0x.... 0x....      BL       mbedtls_error_add
   \       0xF0   0xE105             B.N      ??x509_get_crt_ext_1
    924                  }
    925          
    926                  /* Data should be octet string type */
    927                  if ((ret = mbedtls_asn1_get_tag(p, end_ext_data, &len,
    928                                                  MBEDTLS_ASN1_OCTET_STRING)) != 0) {
   \                     ??x509_get_crt_ext_7: (+1)
   \       0xF2   0x2304             MOVS     R3,#+4
   \       0xF4   0xAA04             ADD      R2,SP,#+16
   \       0xF6   0x4659             MOV      R1,R11
   \       0xF8   0x0030             MOVS     R0,R6
   \       0xFA   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0xFE   0x4682             MOV      R10,R0
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD009             BEQ.N    ??x509_get_crt_ext_8
    929                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \      0x104   0xF240 0x33A1      MOVW     R3,#+929
   \      0x108   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \      0x10C   0x4651             MOV      R1,R10
   \      0x10E   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x112   0x.... 0x....      BL       mbedtls_error_add
   \      0x116   0xE0F2             B.N      ??x509_get_crt_ext_1
    930                  }
    931          
    932                  start_ext_octet = *p;
   \                     ??x509_get_crt_ext_8: (+1)
   \      0x118   0x6830             LDR      R0,[R6, #+0]
   \      0x11A   0x9009             STR      R0,[SP, #+36]
    933                  end_ext_octet = *p + len;
   \      0x11C   0x6831             LDR      R1,[R6, #+0]
   \      0x11E   0x9804             LDR      R0,[SP, #+16]
   \      0x120   0x4408             ADD      R0,R1,R0
   \      0x122   0x0005             MOVS     R5,R0
    934          
    935                  if (end_ext_octet != end_ext_data) {
   \      0x124   0x455D             CMP      R5,R11
   \      0x126   0xD00A             BEQ.N    ??x509_get_crt_ext_9
    936                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    937                                               MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \      0x128   0xF240 0x33A9      MOVW     R3,#+937
   \      0x12C   0x.... 0x....      LDR.W    R2,??x509_crt_parse_der_core_0
   \      0x130   0xF07F 0x0165      MVNS     R1,#+101
   \      0x134   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x138   0x.... 0x....      BL       mbedtls_error_add
   \      0x13C   0xE0DF             B.N      ??x509_get_crt_ext_1
    938                  }
    939          
    940                  /*
    941                   * Detect supported extensions
    942                   */
    943                  ret = mbedtls_oid_get_x509_ext_type(&extn_oid, &ext_type);
   \                     ??x509_get_crt_ext_9: (+1)
   \      0x13E   0xA903             ADD      R1,SP,#+12
   \      0x140   0xA806             ADD      R0,SP,#+24
   \      0x142   0x.... 0x....      BL       mbedtls_oid_get_x509_ext_type
   \      0x146   0x0004             MOVS     R4,R0
    944          
    945                  if (ret != 0) {
   \      0x148   0x2C00             CMP      R4,#+0
   \      0x14A   0xD023             BEQ.N    ??x509_get_crt_ext_10
    946                      /* Give the callback (if any) a chance to handle the extension */
    947                      if (cb != NULL) {
   \      0x14C   0x4640             MOV      R0,R8
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD011             BEQ.N    ??x509_get_crt_ext_11
    948                          ret = cb(p_ctx, crt, &extn_oid, is_critical, *p, end_ext_octet);
   \      0x152   0x9501             STR      R5,[SP, #+4]
   \      0x154   0x6830             LDR      R0,[R6, #+0]
   \      0x156   0x9000             STR      R0,[SP, #+0]
   \      0x158   0x9B02             LDR      R3,[SP, #+8]
   \      0x15A   0xAA06             ADD      R2,SP,#+24
   \      0x15C   0x0039             MOVS     R1,R7
   \      0x15E   0x4648             MOV      R0,R9
   \      0x160   0x47C0             BLX      R8
   \      0x162   0x0004             MOVS     R4,R0
    949                          if (ret != 0 && is_critical) {
   \      0x164   0x2C00             CMP      R4,#+0
   \      0x166   0xD004             BEQ.N    ??x509_get_crt_ext_12
   \      0x168   0x9802             LDR      R0,[SP, #+8]
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD001             BEQ.N    ??x509_get_crt_ext_12
    950                              return ret;
   \      0x16E   0x0020             MOVS     R0,R4
   \      0x170   0xE0C5             B.N      ??x509_get_crt_ext_1
    951                          }
    952                          *p = end_ext_octet;
   \                     ??x509_get_crt_ext_12: (+1)
   \      0x172   0x6035             STR      R5,[R6, #+0]
    953                          continue;
   \      0x174   0xE767             B.N      ??x509_get_crt_ext_3
    954                      }
    955          
    956                      /* No parser found, skip extension */
    957                      *p = end_ext_octet;
   \                     ??x509_get_crt_ext_11: (+1)
   \      0x176   0x6035             STR      R5,[R6, #+0]
    958          
    959                      if (is_critical) {
   \      0x178   0x9802             LDR      R0,[SP, #+8]
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xD009             BEQ.N    ??x509_get_crt_ext_13
    960                          /* Data is marked as critical: fail */
    961                          return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    962                                                   MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
   \      0x17E   0xF240 0x33C2      MOVW     R3,#+962
   \      0x182   0x....             LDR.N    R2,??x509_crt_parse_der_core_0
   \      0x184   0xF07F 0x0161      MVNS     R1,#+97
   \      0x188   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x18C   0x.... 0x....      BL       mbedtls_error_add
   \      0x190   0xE0B5             B.N      ??x509_get_crt_ext_1
    963                      }
    964                      continue;
   \                     ??x509_get_crt_ext_13: (+1)
   \      0x192   0xE758             B.N      ??x509_get_crt_ext_3
    965                  }
    966          
    967                  /* Forbid repeated extensions */
    968                  if ((crt->ext_types & ext_type) != 0) {
   \                     ??x509_get_crt_ext_10: (+1)
   \      0x194   0xF8D7 0x11F0      LDR      R1,[R7, #+496]
   \      0x198   0x9803             LDR      R0,[SP, #+12]
   \      0x19A   0x4201             TST      R1,R0
   \      0x19C   0xD002             BEQ.N    ??x509_get_crt_ext_14
    969                      return MBEDTLS_ERR_X509_INVALID_EXTENSIONS;
   \      0x19E   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x1A2   0xE0AC             B.N      ??x509_get_crt_ext_1
    970                  }
    971          
    972                  crt->ext_types |= ext_type;
   \                     ??x509_get_crt_ext_14: (+1)
   \      0x1A4   0xF8D7 0x11F0      LDR      R1,[R7, #+496]
   \      0x1A8   0x9803             LDR      R0,[SP, #+12]
   \      0x1AA   0x4301             ORRS     R1,R0,R1
   \      0x1AC   0xF8C7 0x11F0      STR      R1,[R7, #+496]
    973          
    974                  switch (ext_type) {
   \      0x1B0   0x9803             LDR      R0,[SP, #+12]
   \      0x1B2   0x2801             CMP      R0,#+1
   \      0x1B4   0xD043             BEQ.N    ??x509_get_crt_ext_15
   \      0x1B6   0x2802             CMP      R0,#+2
   \      0x1B8   0xD035             BEQ.N    ??x509_get_crt_ext_16
   \      0x1BA   0x2804             CMP      R0,#+4
   \      0x1BC   0xD01B             BEQ.N    ??x509_get_crt_ext_17
   \      0x1BE   0x2808             CMP      R0,#+8
   \      0x1C0   0xD061             BEQ.N    ??x509_get_crt_ext_18
   \      0x1C2   0x2820             CMP      R0,#+32
   \      0x1C4   0xD047             BEQ.N    ??x509_get_crt_ext_19
   \      0x1C6   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x1CA   0xD006             BEQ.N    ??x509_get_crt_ext_20
   \      0x1CC   0xF5B0 0x6F00      CMP      R0,#+2048
   \      0x1D0   0xD01D             BEQ.N    ??x509_get_crt_ext_21
   \      0x1D2   0xF5B0 0x3F80      CMP      R0,#+65536
   \      0x1D6   0xD04A             BEQ.N    ??x509_get_crt_ext_22
   \      0x1D8   0xE07A             B.N      ??x509_get_crt_ext_23
    975                      case MBEDTLS_X509_EXT_BASIC_CONSTRAINTS:
    976                          /* Parse basic constraints */
    977                          if ((ret = x509_get_basic_constraints(p, end_ext_octet,
    978                                                                &crt->ca_istrue, &crt->max_pathlen)) != 0) {
   \                     ??x509_get_crt_ext_20: (+1)
   \      0x1DA   0xF517 0x73FC      ADDS     R3,R7,#+504
   \      0x1DE   0xF517 0x72FA      ADDS     R2,R7,#+500
   \      0x1E2   0x0029             MOVS     R1,R5
   \      0x1E4   0x0030             MOVS     R0,R6
   \      0x1E6   0x.... 0x....      BL       x509_get_basic_constraints
   \      0x1EA   0x0004             MOVS     R4,R0
   \      0x1EC   0x2800             CMP      R0,#+0
   \      0x1EE   0xD001             BEQ.N    ??x509_get_crt_ext_24
    979                              return ret;
   \      0x1F0   0x0020             MOVS     R0,R4
   \      0x1F2   0xE084             B.N      ??x509_get_crt_ext_1
    980                          }
    981                          break;
   \                     ??x509_get_crt_ext_24: (+1)
   \      0x1F4   0xE727             B.N      ??x509_get_crt_ext_3
    982          
    983                      case MBEDTLS_X509_EXT_KEY_USAGE:
    984                          /* Parse key usage */
    985                          if ((ret = mbedtls_x509_get_key_usage(p, end_ext_octet,
    986                                                                &crt->key_usage)) != 0) {
   \                     ??x509_get_crt_ext_17: (+1)
   \      0x1F6   0xF517 0x72FE      ADDS     R2,R7,#+508
   \      0x1FA   0x0029             MOVS     R1,R5
   \      0x1FC   0x0030             MOVS     R0,R6
   \      0x1FE   0x.... 0x....      BL       mbedtls_x509_get_key_usage
   \      0x202   0x0004             MOVS     R4,R0
   \      0x204   0x2800             CMP      R0,#+0
   \      0x206   0xD001             BEQ.N    ??x509_get_crt_ext_25
    987                              return ret;
   \      0x208   0x0020             MOVS     R0,R4
   \      0x20A   0xE078             B.N      ??x509_get_crt_ext_1
    988                          }
    989                          break;
   \                     ??x509_get_crt_ext_25: (+1)
   \      0x20C   0xE71B             B.N      ??x509_get_crt_ext_3
    990          
    991                      case MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE:
    992                          /* Parse extended key usage */
    993                          if ((ret = x509_get_ext_key_usage(p, end_ext_octet,
    994                                                            &crt->ext_key_usage)) != 0) {
   \                     ??x509_get_crt_ext_21: (+1)
   \      0x20E   0xF517 0x7200      ADDS     R2,R7,#+512
   \      0x212   0x0029             MOVS     R1,R5
   \      0x214   0x0030             MOVS     R0,R6
   \      0x216   0x.... 0x....      BL       x509_get_ext_key_usage
   \      0x21A   0x0004             MOVS     R4,R0
   \      0x21C   0x2800             CMP      R0,#+0
   \      0x21E   0xD001             BEQ.N    ??x509_get_crt_ext_26
    995                              return ret;
   \      0x220   0x0020             MOVS     R0,R4
   \      0x222   0xE06C             B.N      ??x509_get_crt_ext_1
    996                          }
    997                          break;
   \                     ??x509_get_crt_ext_26: (+1)
   \      0x224   0xE70F             B.N      ??x509_get_crt_ext_3
    998          
    999                      case MBEDTLS_X509_EXT_SUBJECT_KEY_IDENTIFIER:
   1000                          /* Parse subject key identifier */
   1001                          if ((ret = x509_get_subject_key_id(p, end_ext_data,
   1002                                                             &crt->subject_key_id)) != 0) {
   \                     ??x509_get_crt_ext_16: (+1)
   \      0x226   0xF517 0x72D0      ADDS     R2,R7,#+416
   \      0x22A   0x4659             MOV      R1,R11
   \      0x22C   0x0030             MOVS     R0,R6
   \      0x22E   0x.... 0x....      BL       x509_get_subject_key_id
   \      0x232   0x0004             MOVS     R4,R0
   \      0x234   0x2800             CMP      R0,#+0
   \      0x236   0xD001             BEQ.N    ??x509_get_crt_ext_27
   1003                              return ret;
   \      0x238   0x0020             MOVS     R0,R4
   \      0x23A   0xE060             B.N      ??x509_get_crt_ext_1
   1004                          }
   1005                          break;
   \                     ??x509_get_crt_ext_27: (+1)
   \      0x23C   0xE703             B.N      ??x509_get_crt_ext_3
   1006          
   1007                      case MBEDTLS_X509_EXT_AUTHORITY_KEY_IDENTIFIER:
   1008                          /* Parse authority key identifier */
   1009                          if ((ret = x509_get_authority_key_id(p, end_ext_octet,
   1010                                                               &crt->authority_key_id)) != 0) {
   \                     ??x509_get_crt_ext_15: (+1)
   \      0x23E   0xF517 0x72D6      ADDS     R2,R7,#+428
   \      0x242   0x0029             MOVS     R1,R5
   \      0x244   0x0030             MOVS     R0,R6
   \      0x246   0x.... 0x....      BL       x509_get_authority_key_id
   \      0x24A   0x0004             MOVS     R4,R0
   \      0x24C   0x2800             CMP      R0,#+0
   \      0x24E   0xD001             BEQ.N    ??x509_get_crt_ext_28
   1011                              return ret;
   \      0x250   0x0020             MOVS     R0,R4
   \      0x252   0xE054             B.N      ??x509_get_crt_ext_1
   1012                          }
   1013                          break;
   \                     ??x509_get_crt_ext_28: (+1)
   \      0x254   0xE6F7             B.N      ??x509_get_crt_ext_3
   1014                      case MBEDTLS_X509_EXT_SUBJECT_ALT_NAME:
   1015                          /* Parse subject alt name
   1016                           * SubjectAltName ::= GeneralNames
   1017                           */
   1018                          if ((ret = mbedtls_x509_get_subject_alt_name(p, end_ext_octet,
   1019                                                                       &crt->subject_alt_names)) != 0) {
   \                     ??x509_get_crt_ext_19: (+1)
   \      0x256   0xF517 0x72C8      ADDS     R2,R7,#+400
   \      0x25A   0x0029             MOVS     R1,R5
   \      0x25C   0x0030             MOVS     R0,R6
   \      0x25E   0x.... 0x....      BL       mbedtls_x509_get_subject_alt_name
   \      0x262   0x0004             MOVS     R4,R0
   \      0x264   0x2800             CMP      R0,#+0
   \      0x266   0xD001             BEQ.N    ??x509_get_crt_ext_29
   1020                              return ret;
   \      0x268   0x0020             MOVS     R0,R4
   \      0x26A   0xE048             B.N      ??x509_get_crt_ext_1
   1021                          }
   1022                          break;
   \                     ??x509_get_crt_ext_29: (+1)
   \      0x26C   0xE6EB             B.N      ??x509_get_crt_ext_3
   1023          
   1024                      case MBEDTLS_X509_EXT_NS_CERT_TYPE:
   1025                          /* Parse netscape certificate type */
   1026                          if ((ret = mbedtls_x509_get_ns_cert_type(p, end_ext_octet,
   1027                                                                   &crt->ns_cert_type)) != 0) {
   \                     ??x509_get_crt_ext_22: (+1)
   \      0x26E   0xF517 0x7204      ADDS     R2,R7,#+528
   \      0x272   0x0029             MOVS     R1,R5
   \      0x274   0x0030             MOVS     R0,R6
   \      0x276   0x.... 0x....      BL       mbedtls_x509_get_ns_cert_type
   \      0x27A   0x0004             MOVS     R4,R0
   \      0x27C   0x2800             CMP      R0,#+0
   \      0x27E   0xD001             BEQ.N    ??x509_get_crt_ext_30
   1028                              return ret;
   \      0x280   0x0020             MOVS     R0,R4
   \      0x282   0xE03C             B.N      ??x509_get_crt_ext_1
   1029                          }
   1030                          break;
   \                     ??x509_get_crt_ext_30: (+1)
   \      0x284   0xE6DF             B.N      ??x509_get_crt_ext_3
   1031          
   1032                      case MBEDTLS_OID_X509_EXT_CERTIFICATE_POLICIES:
   1033                          /* Parse certificate policies type */
   1034                          if ((ret = x509_get_certificate_policies(p, end_ext_octet,
   1035                                                                   &crt->certificate_policies)) != 0) {
   \                     ??x509_get_crt_ext_18: (+1)
   \      0x286   0xF517 0x72F0      ADDS     R2,R7,#+480
   \      0x28A   0x0029             MOVS     R1,R5
   \      0x28C   0x0030             MOVS     R0,R6
   \      0x28E   0x.... 0x....      BL       x509_get_certificate_policies
   \      0x292   0x0004             MOVS     R4,R0
   \      0x294   0x2800             CMP      R0,#+0
   \      0x296   0xD01A             BEQ.N    ??x509_get_crt_ext_31
   1036                              /* Give the callback (if any) a chance to handle the extension
   1037                               * if it contains unsupported policies */
   1038                              if (ret == MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE && cb != NULL &&
   1039                                  cb(p_ctx, crt, &extn_oid, is_critical,
   1040                                     start_ext_octet, end_ext_octet) == 0) {
   \      0x298   0x.... 0x....      LDR.W    R10,??DataTable15_2
   \      0x29C   0x4554             CMP      R4,R10
   \      0x29E   0xD10D             BNE.N    ??x509_get_crt_ext_32
   \      0x2A0   0x4640             MOV      R0,R8
   \      0x2A2   0x2800             CMP      R0,#+0
   \      0x2A4   0xD00A             BEQ.N    ??x509_get_crt_ext_32
   \      0x2A6   0x9501             STR      R5,[SP, #+4]
   \      0x2A8   0x9809             LDR      R0,[SP, #+36]
   \      0x2AA   0x9000             STR      R0,[SP, #+0]
   \      0x2AC   0x9B02             LDR      R3,[SP, #+8]
   \      0x2AE   0xAA06             ADD      R2,SP,#+24
   \      0x2B0   0x0039             MOVS     R1,R7
   \      0x2B2   0x4648             MOV      R0,R9
   \      0x2B4   0x47C0             BLX      R8
   \      0x2B6   0x2800             CMP      R0,#+0
   \      0x2B8   0xF43F 0xAEC5      BEQ.W    ??x509_get_crt_ext_3
   1041                                  break;
   1042                              }
   1043          
   1044                              if (is_critical) {
   \                     ??x509_get_crt_ext_32: (+1)
   \      0x2BC   0x9802             LDR      R0,[SP, #+8]
   \      0x2BE   0x2800             CMP      R0,#+0
   \      0x2C0   0xD001             BEQ.N    ??x509_get_crt_ext_33
   1045                                  return ret;
   \      0x2C2   0x0020             MOVS     R0,R4
   \      0x2C4   0xE01B             B.N      ??x509_get_crt_ext_1
   1046                              } else
   1047                              /*
   1048                               * If MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE is returned, then we
   1049                               * cannot interpret or enforce the policy. However, it is up to
   1050                               * the user to choose how to enforce the policies,
   1051                               * unless the extension is critical.
   1052                               */
   1053                              if (ret != MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) {
   \                     ??x509_get_crt_ext_33: (+1)
   \      0x2C6   0x4554             CMP      R4,R10
   \      0x2C8   0xD001             BEQ.N    ??x509_get_crt_ext_31
   1054                                  return ret;
   \      0x2CA   0x0020             MOVS     R0,R4
   \      0x2CC   0xE017             B.N      ??x509_get_crt_ext_1
   1055                              }
   1056                          }
   1057                          break;
   \                     ??x509_get_crt_ext_31: (+1)
   \      0x2CE   0xE6BA             B.N      ??x509_get_crt_ext_3
   1058          
   1059                      default:
   1060                          /*
   1061                           * If this is a non-critical extension, which the oid layer
   1062                           * supports, but there isn't an x509 parser for it,
   1063                           * skip the extension.
   1064                           */
   1065                          if (is_critical) {
   \                     ??x509_get_crt_ext_23: (+1)
   \      0x2D0   0x9802             LDR      R0,[SP, #+8]
   \      0x2D2   0x2800             CMP      R0,#+0
   \      0x2D4   0xD002             BEQ.N    ??x509_get_crt_ext_34
   1066                              return MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE;
   \      0x2D6   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \      0x2DA   0xE010             B.N      ??x509_get_crt_ext_1
   1067                          } else {
   1068                              *p = end_ext_octet;
   \                     ??x509_get_crt_ext_34: (+1)
   \      0x2DC   0x6035             STR      R5,[R6, #+0]
   \      0x2DE   0xE6B2             B.N      ??x509_get_crt_ext_3
   1069                          }
   1070                  }
   1071              }
   1072          
   1073              if (*p != end) {
   \                     ??x509_get_crt_ext_4: (+1)
   \      0x2E0   0x6831             LDR      R1,[R6, #+0]
   \      0x2E2   0x9805             LDR      R0,[SP, #+20]
   \      0x2E4   0x4281             CMP      R1,R0
   \      0x2E6   0xD009             BEQ.N    ??x509_get_crt_ext_35
   1074                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1075                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \      0x2E8   0xF240 0x4333      MOVW     R3,#+1075
   \      0x2EC   0x....             LDR.N    R2,??x509_crt_parse_der_core_0
   \      0x2EE   0xF07F 0x0165      MVNS     R1,#+101
   \      0x2F2   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x2F6   0x.... 0x....      BL       mbedtls_error_add
   \      0x2FA   0xE000             B.N      ??x509_get_crt_ext_1
   1076              }
   1077          
   1078              return 0;
   \                     ??x509_get_crt_ext_35: (+1)
   \      0x2FC   0x2000             MOVS     R0,#+0
   \                     ??x509_get_crt_ext_1: (+1)
   \      0x2FE   0xB00B             ADD      SP,SP,#+44
   \      0x300   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1079          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0, 0x0
   \              0x0000'0000  
   \              0x0000'0000
   1080          
   1081          /*
   1082           * Parse and fill a single X.509 certificate in DER format
   1083           */

   \                                 In section .text, align 4, keep-with-next
   1084          static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
   1085                                             const unsigned char *buf,
   1086                                             size_t buflen,
   1087                                             int make_copy,
   1088                                             mbedtls_x509_crt_ext_cb_t cb,
   1089                                             void *p_ctx)
   1090          {
   \                     x509_crt_parse_der_core: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   1091              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x006D      MVNS     R0,#+109
   \        0xE   0x900C             STR      R0,[SP, #+48]
   1092              size_t len;
   1093              unsigned char *p, *end, *crt_end;
   1094              mbedtls_x509_buf sig_params1, sig_params2, sig_oid2;
   1095          
   1096              memset(&sig_params1, 0, sizeof(mbedtls_x509_buf));
   \       0x10   0x200C             MOVS     R0,#+12
   \       0x12   0x9000             STR      R0,[SP, #+0]
   \       0x14   0xF05F 0x0B00      MOVS     R11,#+0
   \       0x18   0xAC03             ADD      R4,SP,#+12
   \       0x1A   0x465A             MOV      R2,R11
   \       0x1C   0x9900             LDR      R1,[SP, #+0]
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       __aeabi_memset
   1097              memset(&sig_params2, 0, sizeof(mbedtls_x509_buf));
   \       0x24   0x240C             MOVS     R4,#+12
   \       0x26   0x2700             MOVS     R7,#+0
   \       0x28   0xF10D 0x0818      ADD      R8,SP,#+24
   \       0x2C   0x003A             MOVS     R2,R7
   \       0x2E   0x0021             MOVS     R1,R4
   \       0x30   0x4640             MOV      R0,R8
   \       0x32   0x.... 0x....      BL       __aeabi_memset
   1098              memset(&sig_oid2, 0, sizeof(mbedtls_x509_buf));
   \       0x36   0xF05F 0x080C      MOVS     R8,#+12
   \       0x3A   0xF05F 0x0900      MOVS     R9,#+0
   \       0x3E   0xF10D 0x0A24      ADD      R10,SP,#+36
   \       0x42   0x464A             MOV      R2,R9
   \       0x44   0x4641             MOV      R1,R8
   \       0x46   0x4650             MOV      R0,R10
   \       0x48   0x.... 0x....      BL       __aeabi_memset
   1099          
   1100              /*
   1101               * Check for valid input
   1102               */
   1103              if (crt == NULL || buf == NULL) {
   \       0x4C   0x2D00             CMP      R5,#+0
   \       0x4E   0xD001             BEQ.N    ??x509_crt_parse_der_core_1
   \       0x50   0x2E00             CMP      R6,#+0
   \       0x52   0xD102             BNE.N    ??x509_crt_parse_der_core_2
   1104                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \                     ??x509_crt_parse_der_core_1: (+1)
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable16
   \       0x58   0xE1CF             B.N      ??x509_crt_parse_der_core_3
   1105              }
   1106          
   1107              /* Use the original buffer until we figure out actual length. */
   1108              p = (unsigned char *) buf;
   \                     ??x509_crt_parse_der_core_2: (+1)
   \       0x5A   0x9601             STR      R6,[SP, #+4]
   1109              len = buflen;
   \       0x5C   0x980D             LDR      R0,[SP, #+52]
   \       0x5E   0x9002             STR      R0,[SP, #+8]
   1110              end = p + len;
   \       0x60   0x9901             LDR      R1,[SP, #+4]
   \       0x62   0x9802             LDR      R0,[SP, #+8]
   \       0x64   0xEB01 0x0700      ADD      R7,R1,R0
   1111          
   1112              /*
   1113               * Certificate  ::=  SEQUENCE  {
   1114               *      tbsCertificate       TBSCertificate,
   1115               *      signatureAlgorithm   AlgorithmIdentifier,
   1116               *      signatureValue       BIT STRING  }
   1117               */
   1118              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1119                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0x68   0x2330             MOVS     R3,#+48
   \       0x6A   0xAA02             ADD      R2,SP,#+8
   \       0x6C   0x0039             MOVS     R1,R7
   \       0x6E   0xA801             ADD      R0,SP,#+4
   \       0x70   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x74   0x0004             MOVS     R4,R0
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD005             BEQ.N    ??x509_crt_parse_der_core_4
   1120                  mbedtls_x509_crt_free(crt);
   \       0x7A   0x0028             MOVS     R0,R5
   \       0x7C   0x.... 0x....      BL       mbedtls_x509_crt_free
   1121                  return MBEDTLS_ERR_X509_INVALID_FORMAT;
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0x84   0xE1B9             B.N      ??x509_crt_parse_der_core_3
   1122              }
   1123          
   1124              end = crt_end = p + len;
   \                     ??x509_crt_parse_der_core_4: (+1)
   \       0x86   0x9901             LDR      R1,[SP, #+4]
   \       0x88   0x9802             LDR      R0,[SP, #+8]
   \       0x8A   0xEB01 0x0800      ADD      R8,R1,R0
   \       0x8E   0x46C2             MOV      R10,R8
   1125              crt->raw.len = crt_end - buf;
   \       0x90   0xEBB8 0x0006      SUBS     R0,R8,R6
   \       0x94   0x60A8             STR      R0,[R5, #+8]
   1126              if (make_copy != 0) {
   \       0x96   0x980E             LDR      R0,[SP, #+56]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD025             BEQ.N    ??x509_crt_parse_der_core_5
   1127                  /* Create and populate a new buffer for the raw field. */
   1128                  crt->raw.p = p = mbedtls_calloc(1, crt->raw.len);
   \       0x9C   0x68A9             LDR      R1,[R5, #+8]
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0x.... 0x....      BL       sl_calloc
   \       0xA4   0x9001             STR      R0,[SP, #+4]
   \       0xA6   0x9801             LDR      R0,[SP, #+4]
   \       0xA8   0x60E8             STR      R0,[R5, #+12]
   1129                  if (crt->raw.p == NULL) {
   \       0xAA   0x68E8             LDR      R0,[R5, #+12]
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD102             BNE.N    ??x509_crt_parse_der_core_6
   1130                      return MBEDTLS_ERR_X509_ALLOC_FAILED;
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable18
   \       0xB4   0xE1A1             B.N      ??x509_crt_parse_der_core_3
   1131                  }
   1132          
   1133                  memcpy(crt->raw.p, buf, crt->raw.len);
   \                     ??x509_crt_parse_der_core_6: (+1)
   \       0xB6   0xF8D5 0x9008      LDR      R9,[R5, #+8]
   \       0xBA   0x0037             MOVS     R7,R6
   \       0xBC   0xF8D5 0xB00C      LDR      R11,[R5, #+12]
   \       0xC0   0x464A             MOV      R2,R9
   \       0xC2   0x0039             MOVS     R1,R7
   \       0xC4   0x4658             MOV      R0,R11
   \       0xC6   0x.... 0x....      BL       __aeabi_memcpy
   1134                  crt->own_buffer = 1;
   \       0xCA   0x2001             MOVS     R0,#+1
   \       0xCC   0x6028             STR      R0,[R5, #+0]
   1135          
   1136                  p += crt->raw.len - len;
   \       0xCE   0x9901             LDR      R1,[SP, #+4]
   \       0xD0   0x68AA             LDR      R2,[R5, #+8]
   \       0xD2   0x9802             LDR      R0,[SP, #+8]
   \       0xD4   0x1A12             SUBS     R2,R2,R0
   \       0xD6   0xEB01 0x0002      ADD      R0,R1,R2
   \       0xDA   0x9001             STR      R0,[SP, #+4]
   1137                  end = crt_end = p + len;
   \       0xDC   0x9801             LDR      R0,[SP, #+4]
   \       0xDE   0x9902             LDR      R1,[SP, #+8]
   \       0xE0   0x4408             ADD      R0,R0,R1
   \       0xE2   0x4680             MOV      R8,R0
   \       0xE4   0x46C2             MOV      R10,R8
   \       0xE6   0xE002             B.N      ??x509_crt_parse_der_core_7
   1138              } else {
   1139                  crt->raw.p = (unsigned char *) buf;
   \                     ??x509_crt_parse_der_core_5: (+1)
   \       0xE8   0x60EE             STR      R6,[R5, #+12]
   1140                  crt->own_buffer = 0;
   \       0xEA   0x2000             MOVS     R0,#+0
   \       0xEC   0x6028             STR      R0,[R5, #+0]
   1141              }
   1142          
   1143              /*
   1144               * TBSCertificate  ::=  SEQUENCE  {
   1145               */
   1146              crt->tbs.p = p;
   \                     ??x509_crt_parse_der_core_7: (+1)
   \       0xEE   0x9801             LDR      R0,[SP, #+4]
   \       0xF0   0x61A8             STR      R0,[R5, #+24]
   1147          
   1148              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1149                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0xF2   0x2330             MOVS     R3,#+48
   \       0xF4   0xAA02             ADD      R2,SP,#+8
   \       0xF6   0x4651             MOV      R1,R10
   \       0xF8   0xA801             ADD      R0,SP,#+4
   \       0xFA   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0xFE   0x4681             MOV      R9,R0
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD00B             BEQ.N    ??x509_crt_parse_der_core_8
   1150                  mbedtls_x509_crt_free(crt);
   \      0x104   0x0028             MOVS     R0,R5
   \      0x106   0x.... 0x....      BL       mbedtls_x509_crt_free
   1151                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
   \      0x10A   0xF240 0x437F      MOVW     R3,#+1151
   \      0x10E   0x4A1D             LDR.N    R2,??x509_crt_parse_der_core_0
   \      0x110   0x4649             MOV      R1,R9
   \      0x112   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x116   0x.... 0x....      BL       mbedtls_error_add
   \      0x11A   0xE16E             B.N      ??x509_crt_parse_der_core_3
   1152              }
   1153          
   1154              end = p + len;
   \                     ??x509_crt_parse_der_core_8: (+1)
   \      0x11C   0x9901             LDR      R1,[SP, #+4]
   \      0x11E   0x9802             LDR      R0,[SP, #+8]
   \      0x120   0xEB01 0x0700      ADD      R7,R1,R0
   1155              crt->tbs.len = end - crt->tbs.p;
   \      0x124   0x69A8             LDR      R0,[R5, #+24]
   \      0x126   0x1A38             SUBS     R0,R7,R0
   \      0x128   0x6168             STR      R0,[R5, #+20]
   1156          
   1157              /*
   1158               * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
   1159               *
   1160               * CertificateSerialNumber  ::=  INTEGER
   1161               *
   1162               * signature            AlgorithmIdentifier
   1163               */
   1164              if ((ret = x509_get_version(&p, end, &crt->version)) != 0 ||
   1165                  (ret = mbedtls_x509_get_serial(&p, end, &crt->serial)) != 0 ||
   1166                  (ret = mbedtls_x509_get_alg(&p, end, &crt->sig_oid,
   1167                                              &sig_params1)) != 0) {
   \      0x12A   0xF115 0x021C      ADDS     R2,R5,#+28
   \      0x12E   0x0039             MOVS     R1,R7
   \      0x130   0xA801             ADD      R0,SP,#+4
   \      0x132   0x.... 0x....      BL       x509_get_version
   \      0x136   0x0004             MOVS     R4,R0
   \      0x138   0x2800             CMP      R0,#+0
   \      0x13A   0xD112             BNE.N    ??x509_crt_parse_der_core_9
   \      0x13C   0xF115 0x0220      ADDS     R2,R5,#+32
   \      0x140   0x0039             MOVS     R1,R7
   \      0x142   0xA801             ADD      R0,SP,#+4
   \      0x144   0x.... 0x....      BL       mbedtls_x509_get_serial
   \      0x148   0x0004             MOVS     R4,R0
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD109             BNE.N    ??x509_crt_parse_der_core_9
   \      0x14E   0xAB03             ADD      R3,SP,#+12
   \      0x150   0xF115 0x022C      ADDS     R2,R5,#+44
   \      0x154   0x0039             MOVS     R1,R7
   \      0x156   0xA801             ADD      R0,SP,#+4
   \      0x158   0x.... 0x....      BL       mbedtls_x509_get_alg
   \      0x15C   0x0004             MOVS     R4,R0
   \      0x15E   0x2800             CMP      R0,#+0
   \      0x160   0xD004             BEQ.N    ??x509_crt_parse_der_core_10
   1168                  mbedtls_x509_crt_free(crt);
   \                     ??x509_crt_parse_der_core_9: (+1)
   \      0x162   0x0028             MOVS     R0,R5
   \      0x164   0x.... 0x....      BL       mbedtls_x509_crt_free
   1169                  return ret;
   \      0x168   0x0020             MOVS     R0,R4
   \      0x16A   0xE146             B.N      ??x509_crt_parse_der_core_3
   1170              }
   1171          
   1172              if (crt->version < 0 || crt->version > 2) {
   \                     ??x509_crt_parse_der_core_10: (+1)
   \      0x16C   0x69E8             LDR      R0,[R5, #+28]
   \      0x16E   0x2800             CMP      R0,#+0
   \      0x170   0xD402             BMI.N    ??x509_crt_parse_der_core_11
   \      0x172   0x69E8             LDR      R0,[R5, #+28]
   \      0x174   0x2803             CMP      R0,#+3
   \      0x176   0xDB07             BLT.N    ??x509_crt_parse_der_core_12
   1173                  mbedtls_x509_crt_free(crt);
   \                     ??x509_crt_parse_der_core_11: (+1)
   \      0x178   0x0028             MOVS     R0,R5
   \      0x17A   0x.... 0x....      BL       mbedtls_x509_crt_free
   1174                  return MBEDTLS_ERR_X509_UNKNOWN_VERSION;
   \      0x17E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \      0x182   0xE13A             B.N      ??x509_crt_parse_der_core_3
   \                     ??x509_crt_parse_der_core_0:
   \      0x184   0x....'....        DC32     ?_20
   1175              }
   1176          
   1177              crt->version++;
   \                     ??x509_crt_parse_der_core_12: (+1)
   \      0x188   0x69E8             LDR      R0,[R5, #+28]
   \      0x18A   0x1C40             ADDS     R0,R0,#+1
   \      0x18C   0x61E8             STR      R0,[R5, #+28]
   1178          
   1179              if ((ret = mbedtls_x509_get_sig_alg(&crt->sig_oid, &sig_params1,
   1180                                                  &crt->sig_md, &crt->sig_pk,
   1181                                                  &crt->sig_opts)) != 0) {
   \      0x18E   0xF515 0x7009      ADDS     R0,R5,#+548
   \      0x192   0x9000             STR      R0,[SP, #+0]
   \      0x194   0xF205 0x2321      ADDW     R3,R5,#+545
   \      0x198   0xF515 0x7208      ADDS     R2,R5,#+544
   \      0x19C   0xA903             ADD      R1,SP,#+12
   \      0x19E   0xF115 0x002C      ADDS     R0,R5,#+44
   \      0x1A2   0x.... 0x....      BL       mbedtls_x509_get_sig_alg
   \      0x1A6   0x4681             MOV      R9,R0
   \      0x1A8   0x2800             CMP      R0,#+0
   \      0x1AA   0xD004             BEQ.N    ??x509_crt_parse_der_core_13
   1182                  mbedtls_x509_crt_free(crt);
   \      0x1AC   0x0028             MOVS     R0,R5
   \      0x1AE   0x.... 0x....      BL       mbedtls_x509_crt_free
   1183                  return ret;
   \      0x1B2   0x4648             MOV      R0,R9
   \      0x1B4   0xE121             B.N      ??x509_crt_parse_der_core_3
   1184              }
   1185          
   1186              /*
   1187               * issuer               Name
   1188               */
   1189              crt->issuer_raw.p = p;
   \                     ??x509_crt_parse_der_core_13: (+1)
   \      0x1B6   0x9801             LDR      R0,[SP, #+4]
   \      0x1B8   0x6428             STR      R0,[R5, #+64]
   1190          
   1191              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1192                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \      0x1BA   0x2330             MOVS     R3,#+48
   \      0x1BC   0xAA02             ADD      R2,SP,#+8
   \      0x1BE   0x0039             MOVS     R1,R7
   \      0x1C0   0xA801             ADD      R0,SP,#+4
   \      0x1C2   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \      0x1C6   0x0004             MOVS     R4,R0
   \      0x1C8   0x2800             CMP      R0,#+0
   \      0x1CA   0xD00C             BEQ.N    ??x509_crt_parse_der_core_14
   1193                  mbedtls_x509_crt_free(crt);
   \      0x1CC   0x0028             MOVS     R0,R5
   \      0x1CE   0x.... 0x....      BL       mbedtls_x509_crt_free
   1194                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
   \      0x1D2   0xF240 0x43AA      MOVW     R3,#+1194
   \      0x1D6   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \      0x1DA   0x0021             MOVS     R1,R4
   \      0x1DC   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x1E0   0x.... 0x....      BL       mbedtls_error_add
   \      0x1E4   0xE109             B.N      ??x509_crt_parse_der_core_3
   1195              }
   1196          
   1197              if ((ret = mbedtls_x509_get_name(&p, p + len, &crt->issuer)) != 0) {
   \                     ??x509_crt_parse_der_core_14: (+1)
   \      0x1E6   0xF115 0x0250      ADDS     R2,R5,#+80
   \      0x1EA   0x9901             LDR      R1,[SP, #+4]
   \      0x1EC   0x9802             LDR      R0,[SP, #+8]
   \      0x1EE   0x4401             ADD      R1,R1,R0
   \      0x1F0   0xA801             ADD      R0,SP,#+4
   \      0x1F2   0x.... 0x....      BL       mbedtls_x509_get_name
   \      0x1F6   0x4681             MOV      R9,R0
   \      0x1F8   0x2800             CMP      R0,#+0
   \      0x1FA   0xD004             BEQ.N    ??x509_crt_parse_der_core_15
   1198                  mbedtls_x509_crt_free(crt);
   \      0x1FC   0x0028             MOVS     R0,R5
   \      0x1FE   0x.... 0x....      BL       mbedtls_x509_crt_free
   1199                  return ret;
   \      0x202   0x4648             MOV      R0,R9
   \      0x204   0xE0F9             B.N      ??x509_crt_parse_der_core_3
   1200              }
   1201          
   1202              crt->issuer_raw.len = p - crt->issuer_raw.p;
   \                     ??x509_crt_parse_der_core_15: (+1)
   \      0x206   0x9901             LDR      R1,[SP, #+4]
   \      0x208   0x6C28             LDR      R0,[R5, #+64]
   \      0x20A   0x1A09             SUBS     R1,R1,R0
   \      0x20C   0x63E9             STR      R1,[R5, #+60]
   1203          
   1204              /*
   1205               * Validity ::= SEQUENCE {
   1206               *      notBefore      Time,
   1207               *      notAfter       Time }
   1208               *
   1209               */
   1210              if ((ret = x509_get_dates(&p, end, &crt->valid_from,
   1211                                        &crt->valid_to)) != 0) {
   \      0x20E   0xF115 0x03A8      ADDS     R3,R5,#+168
   \      0x212   0xF115 0x0290      ADDS     R2,R5,#+144
   \      0x216   0x0039             MOVS     R1,R7
   \      0x218   0xA801             ADD      R0,SP,#+4
   \      0x21A   0x.... 0x....      BL       x509_get_dates
   \      0x21E   0x0004             MOVS     R4,R0
   \      0x220   0x2800             CMP      R0,#+0
   \      0x222   0xD004             BEQ.N    ??x509_crt_parse_der_core_16
   1212                  mbedtls_x509_crt_free(crt);
   \      0x224   0x0028             MOVS     R0,R5
   \      0x226   0x.... 0x....      BL       mbedtls_x509_crt_free
   1213                  return ret;
   \      0x22A   0x0020             MOVS     R0,R4
   \      0x22C   0xE0E5             B.N      ??x509_crt_parse_der_core_3
   1214              }
   1215          
   1216              /*
   1217               * subject              Name
   1218               */
   1219              crt->subject_raw.p = p;
   \                     ??x509_crt_parse_der_core_16: (+1)
   \      0x22E   0x9801             LDR      R0,[SP, #+4]
   \      0x230   0x64E8             STR      R0,[R5, #+76]
   1220          
   1221              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1222                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \      0x232   0x2330             MOVS     R3,#+48
   \      0x234   0xAA02             ADD      R2,SP,#+8
   \      0x236   0x0039             MOVS     R1,R7
   \      0x238   0xA801             ADD      R0,SP,#+4
   \      0x23A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \      0x23E   0x4681             MOV      R9,R0
   \      0x240   0x2800             CMP      R0,#+0
   \      0x242   0xD00C             BEQ.N    ??x509_crt_parse_der_core_17
   1223                  mbedtls_x509_crt_free(crt);
   \      0x244   0x0028             MOVS     R0,R5
   \      0x246   0x.... 0x....      BL       mbedtls_x509_crt_free
   1224                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
   \      0x24A   0xF44F 0x6399      MOV      R3,#+1224
   \      0x24E   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \      0x252   0x4649             MOV      R1,R9
   \      0x254   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x258   0x.... 0x....      BL       mbedtls_error_add
   \      0x25C   0xE0CD             B.N      ??x509_crt_parse_der_core_3
   1225              }
   1226          
   1227              if (len && (ret = mbedtls_x509_get_name(&p, p + len, &crt->subject)) != 0) {
   \                     ??x509_crt_parse_der_core_17: (+1)
   \      0x25E   0x9802             LDR      R0,[SP, #+8]
   \      0x260   0x2800             CMP      R0,#+0
   \      0x262   0xD00F             BEQ.N    ??x509_crt_parse_der_core_18
   \      0x264   0xF115 0x0270      ADDS     R2,R5,#+112
   \      0x268   0x9801             LDR      R0,[SP, #+4]
   \      0x26A   0x9902             LDR      R1,[SP, #+8]
   \      0x26C   0x4401             ADD      R1,R0,R1
   \      0x26E   0xA801             ADD      R0,SP,#+4
   \      0x270   0x.... 0x....      BL       mbedtls_x509_get_name
   \      0x274   0x4681             MOV      R9,R0
   \      0x276   0x2800             CMP      R0,#+0
   \      0x278   0xD004             BEQ.N    ??x509_crt_parse_der_core_18
   1228                  mbedtls_x509_crt_free(crt);
   \      0x27A   0x0028             MOVS     R0,R5
   \      0x27C   0x.... 0x....      BL       mbedtls_x509_crt_free
   1229                  return ret;
   \      0x280   0x4648             MOV      R0,R9
   \      0x282   0xE0BA             B.N      ??x509_crt_parse_der_core_3
   1230              }
   1231          
   1232              crt->subject_raw.len = p - crt->subject_raw.p;
   \                     ??x509_crt_parse_der_core_18: (+1)
   \      0x284   0x9901             LDR      R1,[SP, #+4]
   \      0x286   0x6CE8             LDR      R0,[R5, #+76]
   \      0x288   0x1A09             SUBS     R1,R1,R0
   \      0x28A   0x64A9             STR      R1,[R5, #+72]
   1233          
   1234              /*
   1235               * SubjectPublicKeyInfo
   1236               */
   1237              crt->pk_raw.p = p;
   \      0x28C   0x9801             LDR      R0,[SP, #+4]
   \      0x28E   0xF8C5 0x00C8      STR      R0,[R5, #+200]
   1238              if ((ret = mbedtls_pk_parse_subpubkey(&p, end, &crt->pk)) != 0) {
   \      0x292   0xF115 0x02CC      ADDS     R2,R5,#+204
   \      0x296   0x0039             MOVS     R1,R7
   \      0x298   0xA801             ADD      R0,SP,#+4
   \      0x29A   0x.... 0x....      BL       mbedtls_pk_parse_subpubkey
   \      0x29E   0x0004             MOVS     R4,R0
   \      0x2A0   0x2800             CMP      R0,#+0
   \      0x2A2   0xD004             BEQ.N    ??x509_crt_parse_der_core_19
   1239                  mbedtls_x509_crt_free(crt);
   \      0x2A4   0x0028             MOVS     R0,R5
   \      0x2A6   0x.... 0x....      BL       mbedtls_x509_crt_free
   1240                  return ret;
   \      0x2AA   0x0020             MOVS     R0,R4
   \      0x2AC   0xE0A5             B.N      ??x509_crt_parse_der_core_3
   1241              }
   1242              crt->pk_raw.len = p - crt->pk_raw.p;
   \                     ??x509_crt_parse_der_core_19: (+1)
   \      0x2AE   0x9901             LDR      R1,[SP, #+4]
   \      0x2B0   0xF8D5 0x00C8      LDR      R0,[R5, #+200]
   \      0x2B4   0x1A09             SUBS     R1,R1,R0
   \      0x2B6   0xF8C5 0x10C4      STR      R1,[R5, #+196]
   1243          
   1244              /*
   1245               *  issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
   1246               *                       -- If present, version shall be v2 or v3
   1247               *  subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
   1248               *                       -- If present, version shall be v2 or v3
   1249               *  extensions      [3]  EXPLICIT Extensions OPTIONAL
   1250               *                       -- If present, version shall be v3
   1251               */
   1252              if (crt->version == 2 || crt->version == 3) {
   \      0x2BA   0x69E8             LDR      R0,[R5, #+28]
   \      0x2BC   0x2802             CMP      R0,#+2
   \      0x2BE   0xD002             BEQ.N    ??x509_crt_parse_der_core_20
   \      0x2C0   0x69E8             LDR      R0,[R5, #+28]
   \      0x2C2   0x2803             CMP      R0,#+3
   \      0x2C4   0xD10E             BNE.N    ??x509_crt_parse_der_core_21
   1253                  ret = x509_get_uid(&p, end, &crt->issuer_id,  1);
   \                     ??x509_crt_parse_der_core_20: (+1)
   \      0x2C6   0x2301             MOVS     R3,#+1
   \      0x2C8   0xF515 0x72B6      ADDS     R2,R5,#+364
   \      0x2CC   0x0039             MOVS     R1,R7
   \      0x2CE   0xA801             ADD      R0,SP,#+4
   \      0x2D0   0x.... 0x....      BL       x509_get_uid
   \      0x2D4   0x0004             MOVS     R4,R0
   1254                  if (ret != 0) {
   \      0x2D6   0x2C00             CMP      R4,#+0
   \      0x2D8   0xD004             BEQ.N    ??x509_crt_parse_der_core_21
   1255                      mbedtls_x509_crt_free(crt);
   \      0x2DA   0x0028             MOVS     R0,R5
   \      0x2DC   0x.... 0x....      BL       mbedtls_x509_crt_free
   1256                      return ret;
   \      0x2E0   0x0020             MOVS     R0,R4
   \      0x2E2   0xE08A             B.N      ??x509_crt_parse_der_core_3
   1257                  }
   1258              }
   1259          
   1260              if (crt->version == 2 || crt->version == 3) {
   \                     ??x509_crt_parse_der_core_21: (+1)
   \      0x2E4   0x69E8             LDR      R0,[R5, #+28]
   \      0x2E6   0x2802             CMP      R0,#+2
   \      0x2E8   0xD002             BEQ.N    ??x509_crt_parse_der_core_22
   \      0x2EA   0x69E8             LDR      R0,[R5, #+28]
   \      0x2EC   0x2803             CMP      R0,#+3
   \      0x2EE   0xD10E             BNE.N    ??x509_crt_parse_der_core_23
   1261                  ret = x509_get_uid(&p, end, &crt->subject_id,  2);
   \                     ??x509_crt_parse_der_core_22: (+1)
   \      0x2F0   0x2302             MOVS     R3,#+2
   \      0x2F2   0xF515 0x72BC      ADDS     R2,R5,#+376
   \      0x2F6   0x0039             MOVS     R1,R7
   \      0x2F8   0xA801             ADD      R0,SP,#+4
   \      0x2FA   0x.... 0x....      BL       x509_get_uid
   \      0x2FE   0x0004             MOVS     R4,R0
   1262                  if (ret != 0) {
   \      0x300   0x2C00             CMP      R4,#+0
   \      0x302   0xD004             BEQ.N    ??x509_crt_parse_der_core_23
   1263                      mbedtls_x509_crt_free(crt);
   \      0x304   0x0028             MOVS     R0,R5
   \      0x306   0x.... 0x....      BL       mbedtls_x509_crt_free
   1264                      return ret;
   \      0x30A   0x0020             MOVS     R0,R4
   \      0x30C   0xE075             B.N      ??x509_crt_parse_der_core_3
   1265                  }
   1266              }
   1267          
   1268              if (crt->version == 3) {
   \                     ??x509_crt_parse_der_core_23: (+1)
   \      0x30E   0x69E8             LDR      R0,[R5, #+28]
   \      0x310   0x2803             CMP      R0,#+3
   \      0x312   0xD10F             BNE.N    ??x509_crt_parse_der_core_24
   1269                  ret = x509_get_crt_ext(&p, end, crt, cb, p_ctx);
   \      0x314   0x9819             LDR      R0,[SP, #+100]
   \      0x316   0x9000             STR      R0,[SP, #+0]
   \      0x318   0x9B18             LDR      R3,[SP, #+96]
   \      0x31A   0x002A             MOVS     R2,R5
   \      0x31C   0x0039             MOVS     R1,R7
   \      0x31E   0xA801             ADD      R0,SP,#+4
   \      0x320   0x.... 0x....      BL       x509_get_crt_ext
   \      0x324   0x0004             MOVS     R4,R0
   1270                  if (ret != 0) {
   \      0x326   0x2C00             CMP      R4,#+0
   \      0x328   0xD004             BEQ.N    ??x509_crt_parse_der_core_24
   1271                      mbedtls_x509_crt_free(crt);
   \      0x32A   0x0028             MOVS     R0,R5
   \      0x32C   0x.... 0x....      BL       mbedtls_x509_crt_free
   1272                      return ret;
   \      0x330   0x0020             MOVS     R0,R4
   \      0x332   0xE062             B.N      ??x509_crt_parse_der_core_3
   1273                  }
   1274              }
   1275          
   1276              if (p != end) {
   \                     ??x509_crt_parse_der_core_24: (+1)
   \      0x334   0x9801             LDR      R0,[SP, #+4]
   \      0x336   0x42B8             CMP      R0,R7
   \      0x338   0xD00D             BEQ.N    ??x509_crt_parse_der_core_25
   1277                  mbedtls_x509_crt_free(crt);
   \      0x33A   0x0028             MOVS     R0,R5
   \      0x33C   0x.... 0x....      BL       mbedtls_x509_crt_free
   1278                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT,
   1279                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \      0x340   0xF240 0x43FF      MOVW     R3,#+1279
   \      0x344   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \      0x348   0xF07F 0x0165      MVNS     R1,#+101
   \      0x34C   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x350   0x.... 0x....      BL       mbedtls_error_add
   \      0x354   0xE051             B.N      ??x509_crt_parse_der_core_3
   1280              }
   1281          
   1282              end = crt_end;
   \                     ??x509_crt_parse_der_core_25: (+1)
   \      0x356   0x46C2             MOV      R10,R8
   1283          
   1284              /*
   1285               *  }
   1286               *  -- end of TBSCertificate
   1287               *
   1288               *  signatureAlgorithm   AlgorithmIdentifier,
   1289               *  signatureValue       BIT STRING
   1290               */
   1291              if ((ret = mbedtls_x509_get_alg(&p, end, &sig_oid2, &sig_params2)) != 0) {
   \      0x358   0xAB06             ADD      R3,SP,#+24
   \      0x35A   0xAA09             ADD      R2,SP,#+36
   \      0x35C   0x4651             MOV      R1,R10
   \      0x35E   0xA801             ADD      R0,SP,#+4
   \      0x360   0x.... 0x....      BL       mbedtls_x509_get_alg
   \      0x364   0x4681             MOV      R9,R0
   \      0x366   0x2800             CMP      R0,#+0
   \      0x368   0xD004             BEQ.N    ??x509_crt_parse_der_core_26
   1292                  mbedtls_x509_crt_free(crt);
   \      0x36A   0x0028             MOVS     R0,R5
   \      0x36C   0x.... 0x....      BL       mbedtls_x509_crt_free
   1293                  return ret;
   \      0x370   0x4648             MOV      R0,R9
   \      0x372   0xE042             B.N      ??x509_crt_parse_der_core_3
   1294              }
   1295          
   1296              if (crt->sig_oid.len != sig_oid2.len ||
   1297                  memcmp(crt->sig_oid.p, sig_oid2.p, crt->sig_oid.len) != 0 ||
   1298                  sig_params1.tag != sig_params2.tag ||
   1299                  sig_params1.len != sig_params2.len ||
   1300                  (sig_params1.len != 0 &&
   1301                   memcmp(sig_params1.p, sig_params2.p, sig_params1.len) != 0)) {
   \                     ??x509_crt_parse_der_core_26: (+1)
   \      0x374   0x6B29             LDR      R1,[R5, #+48]
   \      0x376   0x980A             LDR      R0,[SP, #+40]
   \      0x378   0x4281             CMP      R1,R0
   \      0x37A   0xD118             BNE.N    ??x509_crt_parse_der_core_27
   \      0x37C   0x6B2A             LDR      R2,[R5, #+48]
   \      0x37E   0x990B             LDR      R1,[SP, #+44]
   \      0x380   0x6B68             LDR      R0,[R5, #+52]
   \      0x382   0x.... 0x....      BL       memcmp
   \      0x386   0x2800             CMP      R0,#+0
   \      0x388   0xD111             BNE.N    ??x509_crt_parse_der_core_27
   \      0x38A   0x9903             LDR      R1,[SP, #+12]
   \      0x38C   0x9806             LDR      R0,[SP, #+24]
   \      0x38E   0x4281             CMP      R1,R0
   \      0x390   0xD10D             BNE.N    ??x509_crt_parse_der_core_27
   \      0x392   0x9804             LDR      R0,[SP, #+16]
   \      0x394   0x9907             LDR      R1,[SP, #+28]
   \      0x396   0x4288             CMP      R0,R1
   \      0x398   0xD109             BNE.N    ??x509_crt_parse_der_core_27
   \      0x39A   0x9804             LDR      R0,[SP, #+16]
   \      0x39C   0x2800             CMP      R0,#+0
   \      0x39E   0xD00C             BEQ.N    ??x509_crt_parse_der_core_28
   \      0x3A0   0x9A04             LDR      R2,[SP, #+16]
   \      0x3A2   0x9908             LDR      R1,[SP, #+32]
   \      0x3A4   0x9805             LDR      R0,[SP, #+20]
   \      0x3A6   0x.... 0x....      BL       memcmp
   \      0x3AA   0x2800             CMP      R0,#+0
   \      0x3AC   0xD005             BEQ.N    ??x509_crt_parse_der_core_28
   1302                  mbedtls_x509_crt_free(crt);
   \                     ??x509_crt_parse_der_core_27: (+1)
   \      0x3AE   0x0028             MOVS     R0,R5
   \      0x3B0   0x.... 0x....      BL       mbedtls_x509_crt_free
   1303                  return MBEDTLS_ERR_X509_SIG_MISMATCH;
   \      0x3B4   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \      0x3B8   0xE01F             B.N      ??x509_crt_parse_der_core_3
   1304              }
   1305          
   1306              if ((ret = mbedtls_x509_get_sig(&p, end, &crt->sig)) != 0) {
   \                     ??x509_crt_parse_der_core_28: (+1)
   \      0x3BA   0xF515 0x7205      ADDS     R2,R5,#+532
   \      0x3BE   0x4651             MOV      R1,R10
   \      0x3C0   0xA801             ADD      R0,SP,#+4
   \      0x3C2   0x.... 0x....      BL       mbedtls_x509_get_sig
   \      0x3C6   0x0004             MOVS     R4,R0
   \      0x3C8   0x2800             CMP      R0,#+0
   \      0x3CA   0xD004             BEQ.N    ??x509_crt_parse_der_core_29
   1307                  mbedtls_x509_crt_free(crt);
   \      0x3CC   0x0028             MOVS     R0,R5
   \      0x3CE   0x.... 0x....      BL       mbedtls_x509_crt_free
   1308                  return ret;
   \      0x3D2   0x0020             MOVS     R0,R4
   \      0x3D4   0xE011             B.N      ??x509_crt_parse_der_core_3
   1309              }
   1310          
   1311              if (p != end) {
   \                     ??x509_crt_parse_der_core_29: (+1)
   \      0x3D6   0x9801             LDR      R0,[SP, #+4]
   \      0x3D8   0x4550             CMP      R0,R10
   \      0x3DA   0xD00D             BEQ.N    ??x509_crt_parse_der_core_30
   1312                  mbedtls_x509_crt_free(crt);
   \      0x3DC   0x0028             MOVS     R0,R5
   \      0x3DE   0x.... 0x....      BL       mbedtls_x509_crt_free
   1313                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT,
   1314                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \      0x3E2   0xF240 0x5322      MOVW     R3,#+1314
   \      0x3E6   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \      0x3EA   0xF07F 0x0165      MVNS     R1,#+101
   \      0x3EE   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x3F2   0x.... 0x....      BL       mbedtls_error_add
   \      0x3F6   0xE000             B.N      ??x509_crt_parse_der_core_3
   1315              }
   1316          
   1317              return 0;
   \                     ??x509_crt_parse_der_core_30: (+1)
   \      0x3F8   0x2000             MOVS     R0,#+0
   \                     ??x509_crt_parse_der_core_3: (+1)
   \      0x3FA   0xB00F             ADD      SP,SP,#+60
   \      0x3FC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1318          }
   1319          
   1320          /*
   1321           * Parse one X.509 certificate in DER format from a buffer and add them to a
   1322           * chained list
   1323           */

   \                                 In section .text, align 2, keep-with-next
   1324          static int mbedtls_x509_crt_parse_der_internal(mbedtls_x509_crt *chain,
   1325                                                         const unsigned char *buf,
   1326                                                         size_t buflen,
   1327                                                         int make_copy,
   1328                                                         mbedtls_x509_crt_ext_cb_t cb,
   1329                                                         void *p_ctx)
   1330          {
   \                     mbedtls_x509_crt_parse_der_internal: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   1331              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x096D      MVNS     R9,#+109
   1332              mbedtls_x509_crt *crt = chain, *prev = NULL;
   \       0x10   0x4655             MOV      R5,R10
   \       0x12   0x2600             MOVS     R6,#+0
   1333          
   1334              /*
   1335               * Check for valid input
   1336               */
   1337              if (crt == NULL || buf == NULL) {
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD001             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_0
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD102             BNE.N    ??mbedtls_x509_crt_parse_der_internal_1
   1338                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \                     ??mbedtls_x509_crt_parse_der_internal_0: (+1)
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable16
   \       0x20   0xE041             B.N      ??mbedtls_x509_crt_parse_der_internal_2
   1339              }
   1340          
   1341              while (crt->version != 0 && crt->next != NULL) {
   \                     ??mbedtls_x509_crt_parse_der_internal_1: (+1)
   \       0x22   0x69E8             LDR      R0,[R5, #+28]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD007             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_3
   \       0x28   0xF8D5 0x0228      LDR      R0,[R5, #+552]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD003             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_3
   1342                  prev = crt;
   \       0x30   0x002E             MOVS     R6,R5
   1343                  crt = crt->next;
   \       0x32   0xF8D5 0x5228      LDR      R5,[R5, #+552]
   \       0x36   0xE7F4             B.N      ??mbedtls_x509_crt_parse_der_internal_1
   1344              }
   1345          
   1346              /*
   1347               * Add new certificate on the end of the chain if needed.
   1348               */
   1349              if (crt->version != 0 && crt->next == NULL) {
   \                     ??mbedtls_x509_crt_parse_der_internal_3: (+1)
   \       0x38   0x69E8             LDR      R0,[R5, #+28]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD018             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_4
   \       0x3E   0xF8D5 0x0228      LDR      R0,[R5, #+552]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD114             BNE.N    ??mbedtls_x509_crt_parse_der_internal_4
   1350                  crt->next = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
   \       0x46   0xF44F 0x710B      MOV      R1,#+556
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0x.... 0x....      BL       sl_calloc
   \       0x50   0xF8C5 0x0228      STR      R0,[R5, #+552]
   1351          
   1352                  if (crt->next == NULL) {
   \       0x54   0xF8D5 0x0228      LDR      R0,[R5, #+552]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD102             BNE.N    ??mbedtls_x509_crt_parse_der_internal_5
   1353                      return MBEDTLS_ERR_X509_ALLOC_FAILED;
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable18
   \       0x60   0xE021             B.N      ??mbedtls_x509_crt_parse_der_internal_2
   1354                  }
   1355          
   1356                  prev = crt;
   \                     ??mbedtls_x509_crt_parse_der_internal_5: (+1)
   \       0x62   0x002E             MOVS     R6,R5
   1357                  mbedtls_x509_crt_init(crt->next);
   \       0x64   0xF8D5 0x0228      LDR      R0,[R5, #+552]
   \       0x68   0x.... 0x....      BL       mbedtls_x509_crt_init
   1358                  crt = crt->next;
   \       0x6C   0xF8D5 0x5228      LDR      R5,[R5, #+552]
   1359              }
   1360          
   1361              ret = x509_crt_parse_der_core(crt, buf, buflen, make_copy, cb, p_ctx);
   \                     ??mbedtls_x509_crt_parse_der_internal_4: (+1)
   \       0x70   0x980D             LDR      R0,[SP, #+52]
   \       0x72   0x9001             STR      R0,[SP, #+4]
   \       0x74   0x980C             LDR      R0,[SP, #+48]
   \       0x76   0x9000             STR      R0,[SP, #+0]
   \       0x78   0x4643             MOV      R3,R8
   \       0x7A   0x003A             MOVS     R2,R7
   \       0x7C   0x0021             MOVS     R1,R4
   \       0x7E   0x0028             MOVS     R0,R5
   \       0x80   0x.... 0x....      BL       x509_crt_parse_der_core
   \       0x84   0x4683             MOV      R11,R0
   1362              if (ret != 0) {
   \       0x86   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x8A   0xD00B             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_6
   1363                  if (prev) {
   \       0x8C   0x2E00             CMP      R6,#+0
   \       0x8E   0xD002             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_7
   1364                      prev->next = NULL;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xF8C6 0x0228      STR      R0,[R6, #+552]
   1365                  }
   1366          
   1367                  if (crt != chain) {
   \                     ??mbedtls_x509_crt_parse_der_internal_7: (+1)
   \       0x96   0x4555             CMP      R5,R10
   \       0x98   0xD002             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_8
   1368                      mbedtls_free(crt);
   \       0x9A   0x0028             MOVS     R0,R5
   \       0x9C   0x.... 0x....      BL       sl_free
   1369                  }
   1370          
   1371                  return ret;
   \                     ??mbedtls_x509_crt_parse_der_internal_8: (+1)
   \       0xA0   0x4658             MOV      R0,R11
   \       0xA2   0xE000             B.N      ??mbedtls_x509_crt_parse_der_internal_2
   1372              }
   1373          
   1374              return 0;
   \                     ??mbedtls_x509_crt_parse_der_internal_6: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_crt_parse_der_internal_2: (+1)
   \       0xA6   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1375          }
   1376          

   \                                 In section .text, align 2, keep-with-next
   1377          int mbedtls_x509_crt_parse_der_nocopy(mbedtls_x509_crt *chain,
   1378                                                const unsigned char *buf,
   1379                                                size_t buflen)
   1380          {
   \                     mbedtls_x509_crt_parse_der_nocopy: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1381              return mbedtls_x509_crt_parse_der_internal(chain, buf, buflen, 0, NULL, NULL);
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9001             STR      R0,[SP, #+4]
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9000             STR      R0,[SP, #+0]
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x0032             MOVS     R2,R6
   \       0x14   0x0029             MOVS     R1,R5
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_x509_crt_parse_der_internal
   \       0x1C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1382          }
   1383          

   \                                 In section .text, align 2, keep-with-next
   1384          int mbedtls_x509_crt_parse_der_with_ext_cb(mbedtls_x509_crt *chain,
   1385                                                     const unsigned char *buf,
   1386                                                     size_t buflen,
   1387                                                     int make_copy,
   1388                                                     mbedtls_x509_crt_ext_cb_t cb,
   1389                                                     void *p_ctx)
   1390          {
   \                     mbedtls_x509_crt_parse_der_with_ext_cb: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   1391              return mbedtls_x509_crt_parse_der_internal(chain, buf, buflen, make_copy, cb, p_ctx);
   \        0xA   0x9809             LDR      R0,[SP, #+36]
   \        0xC   0x9001             STR      R0,[SP, #+4]
   \        0xE   0x9808             LDR      R0,[SP, #+32]
   \       0x10   0x9000             STR      R0,[SP, #+0]
   \       0x12   0x003B             MOVS     R3,R7
   \       0x14   0x0032             MOVS     R2,R6
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       mbedtls_x509_crt_parse_der_internal
   \       0x1E   0xBDFE             POP      {R1-R7,PC}
   1392          }
   1393          

   \                                 In section .text, align 2, keep-with-next
   1394          int mbedtls_x509_crt_parse_der(mbedtls_x509_crt *chain,
   1395                                         const unsigned char *buf,
   1396                                         size_t buflen)
   1397          {
   \                     mbedtls_x509_crt_parse_der: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1398              return mbedtls_x509_crt_parse_der_internal(chain, buf, buflen, 1, NULL, NULL);
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9001             STR      R0,[SP, #+4]
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9000             STR      R0,[SP, #+0]
   \       0x10   0x2301             MOVS     R3,#+1
   \       0x12   0x0032             MOVS     R2,R6
   \       0x14   0x0029             MOVS     R1,R5
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_x509_crt_parse_der_internal
   \       0x1C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1399          }
   1400          
   1401          /*
   1402           * Parse one or more PEM certificates from a buffer and add them to the chained
   1403           * list
   1404           */

   \                                 In section .text, align 2, keep-with-next
   1405          int mbedtls_x509_crt_parse(mbedtls_x509_crt *chain,
   1406                                     const unsigned char *buf,
   1407                                     size_t buflen)
   1408          {
   \                     mbedtls_x509_crt_parse: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x0006             MOVS     R6,R0
   \        0x8   0x000F             MOVS     R7,R1
   \        0xA   0x4693             MOV      R11,R2
   1409          #if defined(MBEDTLS_PEM_PARSE_C)
   1410              int success = 0, first_error = 0, total_failed = 0;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
   \       0x10   0x2400             MOVS     R4,#+0
   \       0x12   0xF05F 0x0900      MOVS     R9,#+0
   1411              int buf_format = MBEDTLS_X509_FORMAT_DER;
   \       0x16   0xF05F 0x0A01      MOVS     R10,#+1
   1412          #endif
   1413          
   1414              /*
   1415               * Check for valid input
   1416               */
   1417              if (chain == NULL || buf == NULL) {
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD001             BEQ.N    ??mbedtls_x509_crt_parse_0
   \       0x1E   0x2F00             CMP      R7,#+0
   \       0x20   0xD102             BNE.N    ??mbedtls_x509_crt_parse_1
   1418                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \                     ??mbedtls_x509_crt_parse_0: (+1)
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable16
   \       0x26   0xE077             B.N      ??mbedtls_x509_crt_parse_2
   1419              }
   1420          
   1421              /*
   1422               * Determine buffer content. Buffer contains either one DER certificate or
   1423               * one or more PEM certificates.
   1424               */
   1425          #if defined(MBEDTLS_PEM_PARSE_C)
   1426              if (buflen != 0 && buf[buflen - 1] == '\0' &&
   1427                  strstr((const char *) buf, "-----BEGIN CERTIFICATE-----") != NULL) {
   \                     ??mbedtls_x509_crt_parse_1: (+1)
   \       0x28   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x2C   0xD00E             BEQ.N    ??mbedtls_x509_crt_parse_3
   \       0x2E   0xEB07 0x000B      ADD      R0,R7,R11
   \       0x32   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD108             BNE.N    ??mbedtls_x509_crt_parse_3
   \       0x3A   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \       0x3E   0x0038             MOVS     R0,R7
   \       0x40   0x.... 0x....      BL       strstr
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD001             BEQ.N    ??mbedtls_x509_crt_parse_3
   1428                  buf_format = MBEDTLS_X509_FORMAT_PEM;
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0x4682             MOV      R10,R0
   1429              }
   1430          
   1431              if (buf_format == MBEDTLS_X509_FORMAT_DER) {
   \                     ??mbedtls_x509_crt_parse_3: (+1)
   \       0x4C   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x50   0xD105             BNE.N    ??mbedtls_x509_crt_parse_4
   1432                  return mbedtls_x509_crt_parse_der(chain, buf, buflen);
   \       0x52   0x465A             MOV      R2,R11
   \       0x54   0x0039             MOVS     R1,R7
   \       0x56   0x0030             MOVS     R0,R6
   \       0x58   0x.... 0x....      BL       mbedtls_x509_crt_parse_der
   \       0x5C   0xE05C             B.N      ??mbedtls_x509_crt_parse_2
   1433              }
   1434          #else
   1435              return mbedtls_x509_crt_parse_der(chain, buf, buflen);
   1436          #endif
   1437          
   1438          #if defined(MBEDTLS_PEM_PARSE_C)
   1439              if (buf_format == MBEDTLS_X509_FORMAT_PEM) {
   \                     ??mbedtls_x509_crt_parse_4: (+1)
   \       0x5E   0xF1BA 0x0F02      CMP      R10,#+2
   \       0x62   0xD14E             BNE.N    ??mbedtls_x509_crt_parse_5
   1440                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x64   0xF07F 0x056D      MVNS     R5,#+109
   1441                  mbedtls_pem_context pem;
   1442          
   1443                  /* 1 rather than 0 since the terminating NULL byte is counted in */
   1444                  while (buflen > 1) {
   \                     ??mbedtls_x509_crt_parse_6: (+1)
   \       0x68   0xF1BB 0x0F02      CMP      R11,#+2
   \       0x6C   0xD349             BCC.N    ??mbedtls_x509_crt_parse_5
   1445                      size_t use_len;
   1446                      mbedtls_pem_init(&pem);
   \       0x6E   0xA804             ADD      R0,SP,#+16
   \       0x70   0x.... 0x....      BL       mbedtls_pem_init
   1447          
   1448                      /* If we get there, we know the string is null-terminated */
   1449                      ret = mbedtls_pem_read_buffer(&pem,
   1450                                                    "-----BEGIN CERTIFICATE-----",
   1451                                                    "-----END CERTIFICATE-----",
   1452                                                    buf, NULL, 0, &use_len);
   \       0x74   0xA803             ADD      R0,SP,#+12
   \       0x76   0x9002             STR      R0,[SP, #+8]
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x9001             STR      R0,[SP, #+4]
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x9000             STR      R0,[SP, #+0]
   \       0x80   0x003B             MOVS     R3,R7
   \       0x82   0x.... 0x....      LDR.W    R2,??DataTable19_3
   \       0x86   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \       0x8A   0xA804             ADD      R0,SP,#+16
   \       0x8C   0x.... 0x....      BL       mbedtls_pem_read_buffer
   \       0x90   0x0005             MOVS     R5,R0
   1453          
   1454                      if (ret == 0) {
   \       0x92   0x2D00             CMP      R5,#+0
   \       0x94   0xD110             BNE.N    ??mbedtls_x509_crt_parse_7
   1455                          /*
   1456                           * Was PEM encoded
   1457                           */
   1458                          buflen -= use_len;
   \       0x96   0x9803             LDR      R0,[SP, #+12]
   \       0x98   0xEBBB 0x0B00      SUBS     R11,R11,R0
   1459                          buf += use_len;
   \       0x9C   0x9803             LDR      R0,[SP, #+12]
   \       0x9E   0x4407             ADD      R7,R7,R0
   1460                      } else if (ret == MBEDTLS_ERR_PEM_BAD_INPUT_DATA) {
   1461                          return ret;
   1462                      } else if (ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT) {
   1463                          mbedtls_pem_free(&pem);
   1464          
   1465                          /*
   1466                           * PEM header and footer were found
   1467                           */
   1468                          buflen -= use_len;
   1469                          buf += use_len;
   1470          
   1471                          if (first_error == 0) {
   1472                              first_error = ret;
   1473                          }
   1474          
   1475                          total_failed++;
   1476                          continue;
   1477                      } else {
   1478                          break;
   1479                      }
   1480          
   1481                      ret = mbedtls_x509_crt_parse_der(chain, pem.buf, pem.buflen);
   \       0xA0   0x9A05             LDR      R2,[SP, #+20]
   \       0xA2   0x9904             LDR      R1,[SP, #+16]
   \       0xA4   0x0030             MOVS     R0,R6
   \       0xA6   0x.... 0x....      BL       mbedtls_x509_crt_parse_der
   \       0xAA   0x0005             MOVS     R5,R0
   1482          
   1483                      mbedtls_pem_free(&pem);
   \       0xAC   0xA804             ADD      R0,SP,#+16
   \       0xAE   0x.... 0x....      BL       mbedtls_pem_free
   1484          
   1485                      if (ret != 0) {
   \       0xB2   0x2D00             CMP      R5,#+0
   \       0xB4   0xD117             BNE.N    ??mbedtls_x509_crt_parse_8
   \       0xB6   0xE021             B.N      ??mbedtls_x509_crt_parse_9
   \                     ??mbedtls_x509_crt_parse_7: (+1)
   \       0xB8   0xF515 0x5FA4      CMN      R5,#+5248
   \       0xBC   0xD101             BNE.N    ??mbedtls_x509_crt_parse_10
   \       0xBE   0x0028             MOVS     R0,R5
   \       0xC0   0xE02A             B.N      ??mbedtls_x509_crt_parse_2
   \                     ??mbedtls_x509_crt_parse_10: (+1)
   \       0xC2   0xF515 0x5F84      CMN      R5,#+4224
   \       0xC6   0xD00D             BEQ.N    ??mbedtls_x509_crt_parse_11
   \       0xC8   0xA804             ADD      R0,SP,#+16
   \       0xCA   0x.... 0x....      BL       mbedtls_pem_free
   \       0xCE   0x9803             LDR      R0,[SP, #+12]
   \       0xD0   0xEBBB 0x0B00      SUBS     R11,R11,R0
   \       0xD4   0x9803             LDR      R0,[SP, #+12]
   \       0xD6   0x4407             ADD      R7,R7,R0
   \       0xD8   0x2C00             CMP      R4,#+0
   \       0xDA   0xD100             BNE.N    ??mbedtls_x509_crt_parse_12
   \       0xDC   0x002C             MOVS     R4,R5
   \                     ??mbedtls_x509_crt_parse_12: (+1)
   \       0xDE   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0xE2   0xE7C1             B.N      ??mbedtls_x509_crt_parse_6
   \                     ??mbedtls_x509_crt_parse_11: (+1)
   \       0xE4   0xE00D             B.N      ??mbedtls_x509_crt_parse_5
   1486                          /*
   1487                           * Quit parsing on a memory error
   1488                           */
   1489                          if (ret == MBEDTLS_ERR_X509_ALLOC_FAILED) {
   \                     ??mbedtls_x509_crt_parse_8: (+1)
   \       0xE6   0xF515 0x5F22      CMN      R5,#+10368
   \       0xEA   0xD101             BNE.N    ??mbedtls_x509_crt_parse_13
   1490                              return ret;
   \       0xEC   0x0028             MOVS     R0,R5
   \       0xEE   0xE013             B.N      ??mbedtls_x509_crt_parse_2
   1491                          }
   1492          
   1493                          if (first_error == 0) {
   \                     ??mbedtls_x509_crt_parse_13: (+1)
   \       0xF0   0x2C00             CMP      R4,#+0
   \       0xF2   0xD100             BNE.N    ??mbedtls_x509_crt_parse_14
   1494                              first_error = ret;
   \       0xF4   0x002C             MOVS     R4,R5
   1495                          }
   1496          
   1497                          total_failed++;
   \                     ??mbedtls_x509_crt_parse_14: (+1)
   \       0xF6   0xF119 0x0901      ADDS     R9,R9,#+1
   1498                          continue;
   \       0xFA   0xE7B5             B.N      ??mbedtls_x509_crt_parse_6
   1499                      }
   1500          
   1501                      success = 1;
   \                     ??mbedtls_x509_crt_parse_9: (+1)
   \       0xFC   0x2001             MOVS     R0,#+1
   \       0xFE   0x4680             MOV      R8,R0
   \      0x100   0xE7B2             B.N      ??mbedtls_x509_crt_parse_6
   1502                  }
   1503              }
   1504          
   1505              if (success) {
   \                     ??mbedtls_x509_crt_parse_5: (+1)
   \      0x102   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x106   0xD001             BEQ.N    ??mbedtls_x509_crt_parse_15
   1506                  return total_failed;
   \      0x108   0x4648             MOV      R0,R9
   \      0x10A   0xE005             B.N      ??mbedtls_x509_crt_parse_2
   1507              } else if (first_error) {
   \                     ??mbedtls_x509_crt_parse_15: (+1)
   \      0x10C   0x2C00             CMP      R4,#+0
   \      0x10E   0xD001             BEQ.N    ??mbedtls_x509_crt_parse_16
   1508                  return first_error;
   \      0x110   0x0020             MOVS     R0,R4
   \      0x112   0xE001             B.N      ??mbedtls_x509_crt_parse_2
   1509              } else {
   1510                  return MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT;
   \                     ??mbedtls_x509_crt_parse_16: (+1)
   \      0x114   0x.... 0x....      LDR.W    R0,??DataTable20
   \                     ??mbedtls_x509_crt_parse_2: (+1)
   \      0x118   0xB007             ADD      SP,SP,#+28
   \      0x11A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1511              }
   1512          #endif /* MBEDTLS_PEM_PARSE_C */
   1513          }
   1514          
   1515          #if defined(MBEDTLS_FS_IO)
   1516          /*
   1517           * Load one or more certificates and add them to the chained list
   1518           */
   1519          int mbedtls_x509_crt_parse_file(mbedtls_x509_crt *chain, const char *path)
   1520          {
   1521              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1522              size_t n;
   1523              unsigned char *buf;
   1524          
   1525              if ((ret = mbedtls_pk_load_file(path, &buf, &n)) != 0) {
   1526                  return ret;
   1527              }
   1528          
   1529              ret = mbedtls_x509_crt_parse(chain, buf, n);
   1530          
   1531              mbedtls_zeroize_and_free(buf, n);
   1532          
   1533              return ret;
   1534          }
   1535          
   1536          #if !defined( MBEDTLS_X509_CRT_PARSE_PATH_ALT )
   1537          int mbedtls_x509_crt_parse_path(mbedtls_x509_crt *chain, const char *path)
   1538          {
   1539              int ret = 0;
   1540          #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
   1541              int w_ret;
   1542              WCHAR szDir[MAX_PATH];
   1543              char filename[MAX_PATH];
   1544              char *p;
   1545              size_t len = strlen(path);
   1546          
   1547              WIN32_FIND_DATAW file_data;
   1548              HANDLE hFind;
   1549          
   1550              if (len > MAX_PATH - 3) {
   1551                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   1552              }
   1553          
   1554              memset(szDir, 0, sizeof(szDir));
   1555              memset(filename, 0, MAX_PATH);
   1556              memcpy(filename, path, len);
   1557              filename[len++] = '\\';
   1558              p = filename + len;
   1559              filename[len++] = '*';
   1560          
   1561              /*
   1562               * Note this function uses the code page CP_ACP which is the system default
   1563               * ANSI codepage. The input string is always described in BYTES and the
   1564               * output length is described in WCHARs.
   1565               */
   1566              w_ret = MultiByteToWideChar(CP_ACP, 0, filename, (int) len, szDir,
   1567                                          MAX_PATH - 3);
   1568              if (w_ret == 0) {
   1569                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   1570              }
   1571          
   1572              hFind = FindFirstFileW(szDir, &file_data);
   1573              if (hFind == INVALID_HANDLE_VALUE) {
   1574                  return MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1575              }
   1576          
   1577              len = MAX_PATH - len;
   1578              do {
   1579                  memset(p, 0, len);
   1580          
   1581                  if (file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
   1582                      continue;
   1583                  }
   1584                  w_ret = WideCharToMultiByte(CP_ACP, 0, file_data.cFileName,
   1585                                              -1, p, (int) len, NULL, NULL);
   1586                  if (w_ret == 0) {
   1587                      ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1588                      goto cleanup;
   1589                  }
   1590          
   1591                  w_ret = mbedtls_x509_crt_parse_file(chain, filename);
   1592                  if (w_ret < 0) {
   1593                      ret++;
   1594                  } else {
   1595                      ret += w_ret;
   1596                  }
   1597              } while (FindNextFileW(hFind, &file_data) != 0);
   1598          
   1599              if (GetLastError() != ERROR_NO_MORE_FILES) {
   1600                  ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1601              }
   1602          
   1603          cleanup:
   1604              FindClose(hFind);
   1605          #else /* _WIN32 */
   1606              int t_ret;
   1607              int snp_ret;
   1608              struct stat sb;
   1609              struct dirent *entry;
   1610              char entry_name[MBEDTLS_X509_MAX_FILE_PATH_LEN];
   1611              DIR *dir = opendir(path);
   1612          
   1613              if (dir == NULL) {
   1614                  return MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1615              }
   1616          
   1617          #if defined(MBEDTLS_THREADING_C)
   1618              if ((ret = mbedtls_mutex_lock(&mbedtls_threading_readdir_mutex)) != 0) {
   1619                  closedir(dir);
   1620                  return ret;
   1621              }
   1622          #endif /* MBEDTLS_THREADING_C */
   1623          
   1624              memset(&sb, 0, sizeof(sb));
   1625          
   1626              while ((entry = readdir(dir)) != NULL) {
   1627                  snp_ret = mbedtls_snprintf(entry_name, sizeof(entry_name),
   1628                                             "%s/%s", path, entry->d_name);
   1629          
   1630                  if (snp_ret < 0 || (size_t) snp_ret >= sizeof(entry_name)) {
   1631                      ret = MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
   1632                      goto cleanup;
   1633                  } else if (stat(entry_name, &sb) == -1) {
   1634                      if (errno == ENOENT) {
   1635                          /* Broken symbolic link - ignore this entry.
   1636                              stat(2) will return this error for either (a) a dangling
   1637                              symlink or (b) a missing file.
   1638                              Given that we have just obtained the filename from readdir,
   1639                              assume that it does exist and therefore treat this as a
   1640                              dangling symlink. */
   1641                          continue;
   1642                      } else {
   1643                          /* Some other file error; report the error. */
   1644                          ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1645                          goto cleanup;
   1646                      }
   1647                  }
   1648          
   1649                  if (!S_ISREG(sb.st_mode)) {
   1650                      continue;
   1651                  }
   1652          
   1653                  // Ignore parse errors
   1654                  //
   1655                  t_ret = mbedtls_x509_crt_parse_file(chain, entry_name);
   1656                  if (t_ret < 0) {
   1657                      ret++;
   1658                  } else {
   1659                      ret += t_ret;
   1660                  }
   1661              }
   1662          
   1663          cleanup:
   1664              closedir(dir);
   1665          
   1666          #if defined(MBEDTLS_THREADING_C)
   1667              if (mbedtls_mutex_unlock(&mbedtls_threading_readdir_mutex) != 0) {
   1668                  ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;
   1669              }
   1670          #endif /* MBEDTLS_THREADING_C */
   1671          
   1672          #endif /* _WIN32 */
   1673          
   1674              return ret;
   1675          }
   1676          #endif /* #if !defined( MBEDTLS_X509_CRT_PARSE_PATH_ALT ) */
   1677          #endif /* MBEDTLS_FS_IO */
   1678          
   1679          #if !defined(MBEDTLS_X509_REMOVE_INFO)
   1680          #define PRINT_ITEM(i)                               \
   1681              do {                                            \
   1682                  ret = mbedtls_snprintf(p, n, "%s" i, sep);  \
   1683                  MBEDTLS_X509_SAFE_SNPRINTF;                 \
   1684                  sep = ", ";                                 \
   1685              } while (0)
   1686          
   1687          #define CERT_TYPE(type, name)          \
   1688              do {                               \
   1689                  if (ns_cert_type & (type)) {   \
   1690                      PRINT_ITEM(name);          \
   1691                  }                              \
   1692              } while (0)
   1693          
   1694          #define KEY_USAGE(code, name)      \
   1695              do {                           \
   1696                  if (key_usage & (code)) {  \
   1697                      PRINT_ITEM(name);      \
   1698                  }                          \
   1699              } while (0)
   1700          

   \                                 In section .text, align 2, keep-with-next
   1701          static int x509_info_ext_key_usage(char **buf, size_t *size,
   1702                                             const mbedtls_x509_sequence *extended_key_usage)
   1703          {
   \                     x509_info_ext_key_usage: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1704              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x076D      MVNS     R7,#+109
   1705              const char *desc;
   1706              size_t n = *size;
   \        0xE   0xF8D5 0x8000      LDR      R8,[R5, #+0]
   1707              char *p = *buf;
   \       0x12   0xF8DB 0x9000      LDR      R9,[R11, #+0]
   1708              const mbedtls_x509_sequence *cur = extended_key_usage;
   \       0x16   0x0034             MOVS     R4,R6
   1709              const char *sep = "";
   \       0x18   0x.... 0x....      ADR.W    R10,??DataTable15_3
   1710          
   1711              while (cur != NULL) {
   \                     ??x509_info_ext_key_usage_0: (+1)
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD01F             BEQ.N    ??x509_info_ext_key_usage_1
   1712                  if (mbedtls_oid_get_extended_key_usage(&cur->buf, &desc) != 0) {
   \       0x20   0xA901             ADD      R1,SP,#+4
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       mbedtls_oid_get_extended_key_usage
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD001             BEQ.N    ??x509_info_ext_key_usage_2
   1713                      desc = "???";
   \       0x2C   0x....             ADR.N    R0,??DataTable15_4
   \       0x2E   0x9001             STR      R0,[SP, #+4]
   1714                  }
   1715          
   1716                  ret = mbedtls_snprintf(p, n, "%s%s", sep, desc);
   \                     ??x509_info_ext_key_usage_2: (+1)
   \       0x30   0x9801             LDR      R0,[SP, #+4]
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0x4653             MOV      R3,R10
   \       0x36   0x.... 0x....      LDR.W    R2,??DataTable19_4
   \       0x3A   0x4641             MOV      R1,R8
   \       0x3C   0x4648             MOV      R0,R9
   \       0x3E   0x.... 0x....      BL       snprintf
   \       0x42   0x0007             MOVS     R7,R0
   1717                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x44   0x2F00             CMP      R7,#+0
   \       0x46   0xD401             BMI.N    ??x509_info_ext_key_usage_3
   \       0x48   0x4547             CMP      R7,R8
   \       0x4A   0xD302             BCC.N    ??x509_info_ext_key_usage_4
   \                     ??x509_info_ext_key_usage_3: (+1)
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x50   0xE00B             B.N      ??x509_info_ext_key_usage_5
   \                     ??x509_info_ext_key_usage_4: (+1)
   \       0x52   0xEBB8 0x0807      SUBS     R8,R8,R7
   \       0x56   0x44B9             ADD      R9,R9,R7
   1718          
   1719                  sep = ", ";
   \       0x58   0x....             ADR.N    R0,??DataTable15_5
   \       0x5A   0x4682             MOV      R10,R0
   1720          
   1721                  cur = cur->next;
   \       0x5C   0x68E4             LDR      R4,[R4, #+12]
   \       0x5E   0xE7DD             B.N      ??x509_info_ext_key_usage_0
   1722              }
   1723          
   1724              *size = n;
   \                     ??x509_info_ext_key_usage_1: (+1)
   \       0x60   0xF8C5 0x8000      STR      R8,[R5, #+0]
   1725              *buf = p;
   \       0x64   0xF8CB 0x9000      STR      R9,[R11, #+0]
   1726          
   1727              return 0;
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??x509_info_ext_key_usage_5: (+1)
   \       0x6A   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1728          }
   1729          

   \                                 In section .text, align 2, keep-with-next
   1730          static int x509_info_cert_policies(char **buf, size_t *size,
   1731                                             const mbedtls_x509_sequence *certificate_policies)
   1732          {
   \                     x509_info_cert_policies: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1733              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x076D      MVNS     R7,#+109
   1734              const char *desc;
   1735              size_t n = *size;
   \        0xE   0xF8D5 0x8000      LDR      R8,[R5, #+0]
   1736              char *p = *buf;
   \       0x12   0xF8DB 0x9000      LDR      R9,[R11, #+0]
   1737              const mbedtls_x509_sequence *cur = certificate_policies;
   \       0x16   0x0034             MOVS     R4,R6
   1738              const char *sep = "";
   \       0x18   0x.... 0x....      ADR.W    R10,??DataTable15_3
   1739          
   1740              while (cur != NULL) {
   \                     ??x509_info_cert_policies_0: (+1)
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD01F             BEQ.N    ??x509_info_cert_policies_1
   1741                  if (mbedtls_oid_get_certificate_policies(&cur->buf, &desc) != 0) {
   \       0x20   0xA901             ADD      R1,SP,#+4
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       mbedtls_oid_get_certificate_policies
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD001             BEQ.N    ??x509_info_cert_policies_2
   1742                      desc = "???";
   \       0x2C   0x....             ADR.N    R0,??DataTable15_4
   \       0x2E   0x9001             STR      R0,[SP, #+4]
   1743                  }
   1744          
   1745                  ret = mbedtls_snprintf(p, n, "%s%s", sep, desc);
   \                     ??x509_info_cert_policies_2: (+1)
   \       0x30   0x9801             LDR      R0,[SP, #+4]
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0x4653             MOV      R3,R10
   \       0x36   0x.... 0x....      LDR.W    R2,??DataTable19_4
   \       0x3A   0x4641             MOV      R1,R8
   \       0x3C   0x4648             MOV      R0,R9
   \       0x3E   0x.... 0x....      BL       snprintf
   \       0x42   0x0007             MOVS     R7,R0
   1746                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x44   0x2F00             CMP      R7,#+0
   \       0x46   0xD401             BMI.N    ??x509_info_cert_policies_3
   \       0x48   0x4547             CMP      R7,R8
   \       0x4A   0xD302             BCC.N    ??x509_info_cert_policies_4
   \                     ??x509_info_cert_policies_3: (+1)
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x50   0xE00B             B.N      ??x509_info_cert_policies_5
   \                     ??x509_info_cert_policies_4: (+1)
   \       0x52   0xEBB8 0x0807      SUBS     R8,R8,R7
   \       0x56   0x44B9             ADD      R9,R9,R7
   1747          
   1748                  sep = ", ";
   \       0x58   0x....             ADR.N    R0,??DataTable15_5
   \       0x5A   0x4682             MOV      R10,R0
   1749          
   1750                  cur = cur->next;
   \       0x5C   0x68E4             LDR      R4,[R4, #+12]
   \       0x5E   0xE7DD             B.N      ??x509_info_cert_policies_0
   1751              }
   1752          
   1753              *size = n;
   \                     ??x509_info_cert_policies_1: (+1)
   \       0x60   0xF8C5 0x8000      STR      R8,[R5, #+0]
   1754              *buf = p;
   \       0x64   0xF8CB 0x9000      STR      R9,[R11, #+0]
   1755          
   1756              return 0;
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??x509_info_cert_policies_5: (+1)
   \       0x6A   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1757          }
   1758          
   1759          /*
   1760           * Return an informational string about the certificate.
   1761           */
   1762          #define BEFORE_COLON    18
   1763          #define BC              "18"

   \                                 In section .text, align 2, keep-with-next
   1764          int mbedtls_x509_crt_info(char *buf, size_t size, const char *prefix,
   1765                                    const mbedtls_x509_crt *crt)
   1766          {
   \                     mbedtls_x509_crt_info: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001C             MOVS     R4,R3
   1767              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x096D      MVNS     R9,#+109
   1768              size_t n;
   1769              char *p;
   1770              char key_size_str[BEFORE_COLON];
   1771          
   1772              p = buf;
   \       0x12   0x9507             STR      R5,[SP, #+28]
   1773              n = size;
   \       0x14   0xF8CD 0x8018      STR      R8,[SP, #+24]
   1774          
   1775              if (NULL == crt) {
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD119             BNE.N    ??mbedtls_x509_crt_info_0
   1776                  ret = mbedtls_snprintf(p, n, "\nCertificate is uninitialised!\n");
   \       0x1C   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \       0x20   0x9906             LDR      R1,[SP, #+24]
   \       0x22   0x9807             LDR      R0,[SP, #+28]
   \       0x24   0x.... 0x....      BL       snprintf
   \       0x28   0x0001             MOVS     R1,R0
   1777                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x2A   0x2900             CMP      R1,#+0
   \       0x2C   0xD402             BMI.N    ??mbedtls_x509_crt_info_1
   \       0x2E   0x9806             LDR      R0,[SP, #+24]
   \       0x30   0x4281             CMP      R1,R0
   \       0x32   0xD302             BCC.N    ??mbedtls_x509_crt_info_2
   \                     ??mbedtls_x509_crt_info_1: (+1)
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x38   0xE277             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_2: (+1)
   \       0x3A   0x9806             LDR      R0,[SP, #+24]
   \       0x3C   0x1A40             SUBS     R0,R0,R1
   \       0x3E   0x9006             STR      R0,[SP, #+24]
   \       0x40   0x9807             LDR      R0,[SP, #+28]
   \       0x42   0x4408             ADD      R0,R0,R1
   \       0x44   0x9007             STR      R0,[SP, #+28]
   1778          
   1779                  return (int) (size - n);
   \       0x46   0x9806             LDR      R0,[SP, #+24]
   \       0x48   0xEBB8 0x0800      SUBS     R8,R8,R0
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0xE26C             B.N      ??mbedtls_x509_crt_info_3
   1780              }
   1781          
   1782              ret = mbedtls_snprintf(p, n, "%scert. version     : %d\n",
   1783                                     prefix, crt->version);
   \                     ??mbedtls_x509_crt_info_0: (+1)
   \       0x50   0x69E0             LDR      R0,[R4, #+28]
   \       0x52   0x9000             STR      R0,[SP, #+0]
   \       0x54   0x0033             MOVS     R3,R6
   \       0x56   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \       0x5A   0x9906             LDR      R1,[SP, #+24]
   \       0x5C   0x9807             LDR      R0,[SP, #+28]
   \       0x5E   0x.... 0x....      BL       snprintf
   \       0x62   0x0007             MOVS     R7,R0
   1784              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x64   0x2F00             CMP      R7,#+0
   \       0x66   0xD402             BMI.N    ??mbedtls_x509_crt_info_4
   \       0x68   0x9806             LDR      R0,[SP, #+24]
   \       0x6A   0x4287             CMP      R7,R0
   \       0x6C   0xD302             BCC.N    ??mbedtls_x509_crt_info_5
   \                     ??mbedtls_x509_crt_info_4: (+1)
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x72   0xE25A             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_5: (+1)
   \       0x74   0x9806             LDR      R0,[SP, #+24]
   \       0x76   0x1BC0             SUBS     R0,R0,R7
   \       0x78   0x9006             STR      R0,[SP, #+24]
   \       0x7A   0x9807             LDR      R0,[SP, #+28]
   \       0x7C   0x4438             ADD      R0,R0,R7
   \       0x7E   0x9007             STR      R0,[SP, #+28]
   1785              ret = mbedtls_snprintf(p, n, "%sserial number     : ",
   1786                                     prefix);
   \       0x80   0x0033             MOVS     R3,R6
   \       0x82   0x.... 0x....      LDR.W    R2,??DataTable20_4
   \       0x86   0x9906             LDR      R1,[SP, #+24]
   \       0x88   0x9807             LDR      R0,[SP, #+28]
   \       0x8A   0x.... 0x....      BL       snprintf
   \       0x8E   0x4681             MOV      R9,R0
   1787              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x90   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x94   0xD402             BMI.N    ??mbedtls_x509_crt_info_6
   \       0x96   0x9806             LDR      R0,[SP, #+24]
   \       0x98   0x4581             CMP      R9,R0
   \       0x9A   0xD302             BCC.N    ??mbedtls_x509_crt_info_7
   \                     ??mbedtls_x509_crt_info_6: (+1)
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0xA0   0xE243             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_7: (+1)
   \       0xA2   0x9806             LDR      R0,[SP, #+24]
   \       0xA4   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0xA8   0x9006             STR      R0,[SP, #+24]
   \       0xAA   0x9807             LDR      R0,[SP, #+28]
   \       0xAC   0x4448             ADD      R0,R0,R9
   \       0xAE   0x9007             STR      R0,[SP, #+28]
   1788          
   1789              ret = mbedtls_x509_serial_gets(p, n, &crt->serial);
   \       0xB0   0xF114 0x0220      ADDS     R2,R4,#+32
   \       0xB4   0x9906             LDR      R1,[SP, #+24]
   \       0xB6   0x9807             LDR      R0,[SP, #+28]
   \       0xB8   0x.... 0x....      BL       mbedtls_x509_serial_gets
   \       0xBC   0x0007             MOVS     R7,R0
   1790              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0xBE   0x2F00             CMP      R7,#+0
   \       0xC0   0xD402             BMI.N    ??mbedtls_x509_crt_info_8
   \       0xC2   0x9806             LDR      R0,[SP, #+24]
   \       0xC4   0x4287             CMP      R7,R0
   \       0xC6   0xD302             BCC.N    ??mbedtls_x509_crt_info_9
   \                     ??mbedtls_x509_crt_info_8: (+1)
   \       0xC8   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0xCC   0xE22D             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_9: (+1)
   \       0xCE   0x9806             LDR      R0,[SP, #+24]
   \       0xD0   0x1BC0             SUBS     R0,R0,R7
   \       0xD2   0x9006             STR      R0,[SP, #+24]
   \       0xD4   0x9807             LDR      R0,[SP, #+28]
   \       0xD6   0x4438             ADD      R0,R0,R7
   \       0xD8   0x9007             STR      R0,[SP, #+28]
   1791          
   1792              ret = mbedtls_snprintf(p, n, "\n%sissuer name       : ", prefix);
   \       0xDA   0x0033             MOVS     R3,R6
   \       0xDC   0x.... 0x....      LDR.W    R2,??DataTable20_5
   \       0xE0   0x9906             LDR      R1,[SP, #+24]
   \       0xE2   0x9807             LDR      R0,[SP, #+28]
   \       0xE4   0x.... 0x....      BL       snprintf
   \       0xE8   0x4681             MOV      R9,R0
   1793              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0xEA   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xEE   0xD402             BMI.N    ??mbedtls_x509_crt_info_10
   \       0xF0   0x9806             LDR      R0,[SP, #+24]
   \       0xF2   0x4581             CMP      R9,R0
   \       0xF4   0xD302             BCC.N    ??mbedtls_x509_crt_info_11
   \                     ??mbedtls_x509_crt_info_10: (+1)
   \       0xF6   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0xFA   0xE216             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_11: (+1)
   \       0xFC   0x9806             LDR      R0,[SP, #+24]
   \       0xFE   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x102   0x9006             STR      R0,[SP, #+24]
   \      0x104   0x9807             LDR      R0,[SP, #+28]
   \      0x106   0x4448             ADD      R0,R0,R9
   \      0x108   0x9007             STR      R0,[SP, #+28]
   1794              ret = mbedtls_x509_dn_gets(p, n, &crt->issuer);
   \      0x10A   0xF114 0x0250      ADDS     R2,R4,#+80
   \      0x10E   0x9906             LDR      R1,[SP, #+24]
   \      0x110   0x9807             LDR      R0,[SP, #+28]
   \      0x112   0x.... 0x....      BL       mbedtls_x509_dn_gets
   \      0x116   0x0007             MOVS     R7,R0
   1795              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x118   0x2F00             CMP      R7,#+0
   \      0x11A   0xD402             BMI.N    ??mbedtls_x509_crt_info_12
   \      0x11C   0x9806             LDR      R0,[SP, #+24]
   \      0x11E   0x4287             CMP      R7,R0
   \      0x120   0xD302             BCC.N    ??mbedtls_x509_crt_info_13
   \                     ??mbedtls_x509_crt_info_12: (+1)
   \      0x122   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x126   0xE200             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_13: (+1)
   \      0x128   0x9806             LDR      R0,[SP, #+24]
   \      0x12A   0x1BC0             SUBS     R0,R0,R7
   \      0x12C   0x9006             STR      R0,[SP, #+24]
   \      0x12E   0x9807             LDR      R0,[SP, #+28]
   \      0x130   0x4438             ADD      R0,R0,R7
   \      0x132   0x9007             STR      R0,[SP, #+28]
   1796          
   1797              ret = mbedtls_snprintf(p, n, "\n%ssubject name      : ", prefix);
   \      0x134   0x0033             MOVS     R3,R6
   \      0x136   0x.... 0x....      LDR.W    R2,??DataTable20_6
   \      0x13A   0x9906             LDR      R1,[SP, #+24]
   \      0x13C   0x9807             LDR      R0,[SP, #+28]
   \      0x13E   0x.... 0x....      BL       snprintf
   \      0x142   0x4681             MOV      R9,R0
   1798              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x144   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x148   0xD402             BMI.N    ??mbedtls_x509_crt_info_14
   \      0x14A   0x9806             LDR      R0,[SP, #+24]
   \      0x14C   0x4581             CMP      R9,R0
   \      0x14E   0xD302             BCC.N    ??mbedtls_x509_crt_info_15
   \                     ??mbedtls_x509_crt_info_14: (+1)
   \      0x150   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x154   0xE1E9             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_15: (+1)
   \      0x156   0x9806             LDR      R0,[SP, #+24]
   \      0x158   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x15C   0x9006             STR      R0,[SP, #+24]
   \      0x15E   0x9807             LDR      R0,[SP, #+28]
   \      0x160   0x4448             ADD      R0,R0,R9
   \      0x162   0x9007             STR      R0,[SP, #+28]
   1799              ret = mbedtls_x509_dn_gets(p, n, &crt->subject);
   \      0x164   0xF114 0x0270      ADDS     R2,R4,#+112
   \      0x168   0x9906             LDR      R1,[SP, #+24]
   \      0x16A   0x9807             LDR      R0,[SP, #+28]
   \      0x16C   0x.... 0x....      BL       mbedtls_x509_dn_gets
   \      0x170   0x0007             MOVS     R7,R0
   1800              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x172   0x2F00             CMP      R7,#+0
   \      0x174   0xD402             BMI.N    ??mbedtls_x509_crt_info_16
   \      0x176   0x9806             LDR      R0,[SP, #+24]
   \      0x178   0x4287             CMP      R7,R0
   \      0x17A   0xD302             BCC.N    ??mbedtls_x509_crt_info_17
   \                     ??mbedtls_x509_crt_info_16: (+1)
   \      0x17C   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x180   0xE1D3             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_17: (+1)
   \      0x182   0x9806             LDR      R0,[SP, #+24]
   \      0x184   0x1BC0             SUBS     R0,R0,R7
   \      0x186   0x9006             STR      R0,[SP, #+24]
   \      0x188   0x9807             LDR      R0,[SP, #+28]
   \      0x18A   0x4438             ADD      R0,R0,R7
   \      0x18C   0x9007             STR      R0,[SP, #+28]
   1801          
   1802              ret = mbedtls_snprintf(p, n, "\n%sissued  on        : " \
   1803                                           "%04d-%02d-%02d %02d:%02d:%02d", prefix,
   1804                                     crt->valid_from.year, crt->valid_from.mon,
   1805                                     crt->valid_from.day,  crt->valid_from.hour,
   1806                                     crt->valid_from.min,  crt->valid_from.sec);
   \      0x18E   0xF8D4 0x00A4      LDR      R0,[R4, #+164]
   \      0x192   0x9005             STR      R0,[SP, #+20]
   \      0x194   0xF8D4 0x00A0      LDR      R0,[R4, #+160]
   \      0x198   0x9004             STR      R0,[SP, #+16]
   \      0x19A   0xF8D4 0x009C      LDR      R0,[R4, #+156]
   \      0x19E   0x9003             STR      R0,[SP, #+12]
   \      0x1A0   0xF8D4 0x0098      LDR      R0,[R4, #+152]
   \      0x1A4   0x9002             STR      R0,[SP, #+8]
   \      0x1A6   0xF8D4 0x0094      LDR      R0,[R4, #+148]
   \      0x1AA   0x9001             STR      R0,[SP, #+4]
   \      0x1AC   0xF8D4 0x0090      LDR      R0,[R4, #+144]
   \      0x1B0   0x9000             STR      R0,[SP, #+0]
   \      0x1B2   0x0033             MOVS     R3,R6
   \      0x1B4   0x.... 0x....      LDR.W    R2,??DataTable21
   \      0x1B8   0x9906             LDR      R1,[SP, #+24]
   \      0x1BA   0x9807             LDR      R0,[SP, #+28]
   \      0x1BC   0x.... 0x....      BL       snprintf
   \      0x1C0   0x4681             MOV      R9,R0
   1807              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x1C2   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x1C6   0xD402             BMI.N    ??mbedtls_x509_crt_info_18
   \      0x1C8   0x9806             LDR      R0,[SP, #+24]
   \      0x1CA   0x4581             CMP      R9,R0
   \      0x1CC   0xD302             BCC.N    ??mbedtls_x509_crt_info_19
   \                     ??mbedtls_x509_crt_info_18: (+1)
   \      0x1CE   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x1D2   0xE1AA             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_19: (+1)
   \      0x1D4   0x9806             LDR      R0,[SP, #+24]
   \      0x1D6   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x1DA   0x9006             STR      R0,[SP, #+24]
   \      0x1DC   0x9807             LDR      R0,[SP, #+28]
   \      0x1DE   0x4448             ADD      R0,R0,R9
   \      0x1E0   0x9007             STR      R0,[SP, #+28]
   1808          
   1809              ret = mbedtls_snprintf(p, n, "\n%sexpires on        : " \
   1810                                           "%04d-%02d-%02d %02d:%02d:%02d", prefix,
   1811                                     crt->valid_to.year, crt->valid_to.mon,
   1812                                     crt->valid_to.day,  crt->valid_to.hour,
   1813                                     crt->valid_to.min,  crt->valid_to.sec);
   \      0x1E2   0xF8D4 0x00BC      LDR      R0,[R4, #+188]
   \      0x1E6   0x9005             STR      R0,[SP, #+20]
   \      0x1E8   0xF8D4 0x00B8      LDR      R0,[R4, #+184]
   \      0x1EC   0x9004             STR      R0,[SP, #+16]
   \      0x1EE   0xF8D4 0x00B4      LDR      R0,[R4, #+180]
   \      0x1F2   0x9003             STR      R0,[SP, #+12]
   \      0x1F4   0xF8D4 0x00B0      LDR      R0,[R4, #+176]
   \      0x1F8   0x9002             STR      R0,[SP, #+8]
   \      0x1FA   0xF8D4 0x00AC      LDR      R0,[R4, #+172]
   \      0x1FE   0x9001             STR      R0,[SP, #+4]
   \      0x200   0xF8D4 0x00A8      LDR      R0,[R4, #+168]
   \      0x204   0x9000             STR      R0,[SP, #+0]
   \      0x206   0x0033             MOVS     R3,R6
   \      0x208   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \      0x20C   0x9906             LDR      R1,[SP, #+24]
   \      0x20E   0x9807             LDR      R0,[SP, #+28]
   \      0x210   0x.... 0x....      BL       snprintf
   \      0x214   0x0007             MOVS     R7,R0
   1814              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x216   0x2F00             CMP      R7,#+0
   \      0x218   0xD402             BMI.N    ??mbedtls_x509_crt_info_20
   \      0x21A   0x9806             LDR      R0,[SP, #+24]
   \      0x21C   0x4287             CMP      R7,R0
   \      0x21E   0xD302             BCC.N    ??mbedtls_x509_crt_info_21
   \                     ??mbedtls_x509_crt_info_20: (+1)
   \      0x220   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x224   0xE181             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_21: (+1)
   \      0x226   0x9806             LDR      R0,[SP, #+24]
   \      0x228   0x1BC0             SUBS     R0,R0,R7
   \      0x22A   0x9006             STR      R0,[SP, #+24]
   \      0x22C   0x9807             LDR      R0,[SP, #+28]
   \      0x22E   0x4438             ADD      R0,R0,R7
   \      0x230   0x9007             STR      R0,[SP, #+28]
   1815          
   1816              ret = mbedtls_snprintf(p, n, "\n%ssigned using      : ", prefix);
   \      0x232   0x0033             MOVS     R3,R6
   \      0x234   0x.... 0x....      LDR.W    R2,??DataTable21_2
   \      0x238   0x9906             LDR      R1,[SP, #+24]
   \      0x23A   0x9807             LDR      R0,[SP, #+28]
   \      0x23C   0x.... 0x....      BL       snprintf
   \      0x240   0x4681             MOV      R9,R0
   1817              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x242   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x246   0xD402             BMI.N    ??mbedtls_x509_crt_info_22
   \      0x248   0x9806             LDR      R0,[SP, #+24]
   \      0x24A   0x4581             CMP      R9,R0
   \      0x24C   0xD302             BCC.N    ??mbedtls_x509_crt_info_23
   \                     ??mbedtls_x509_crt_info_22: (+1)
   \      0x24E   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x252   0xE16A             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_23: (+1)
   \      0x254   0x9806             LDR      R0,[SP, #+24]
   \      0x256   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x25A   0x9006             STR      R0,[SP, #+24]
   \      0x25C   0x9807             LDR      R0,[SP, #+28]
   \      0x25E   0x4448             ADD      R0,R0,R9
   \      0x260   0x9007             STR      R0,[SP, #+28]
   1818          
   1819              ret = mbedtls_x509_sig_alg_gets(p, n, &crt->sig_oid, crt->sig_pk,
   1820                                              crt->sig_md, crt->sig_opts);
   \      0x262   0xF8D4 0x0224      LDR      R0,[R4, #+548]
   \      0x266   0x9001             STR      R0,[SP, #+4]
   \      0x268   0xF894 0x0220      LDRB     R0,[R4, #+544]
   \      0x26C   0x9000             STR      R0,[SP, #+0]
   \      0x26E   0xF894 0x3221      LDRB     R3,[R4, #+545]
   \      0x272   0xF114 0x022C      ADDS     R2,R4,#+44
   \      0x276   0x9906             LDR      R1,[SP, #+24]
   \      0x278   0x9807             LDR      R0,[SP, #+28]
   \      0x27A   0x.... 0x....      BL       mbedtls_x509_sig_alg_gets
   \      0x27E   0x0007             MOVS     R7,R0
   1821              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x280   0x2F00             CMP      R7,#+0
   \      0x282   0xD402             BMI.N    ??mbedtls_x509_crt_info_24
   \      0x284   0x9806             LDR      R0,[SP, #+24]
   \      0x286   0x4287             CMP      R7,R0
   \      0x288   0xD302             BCC.N    ??mbedtls_x509_crt_info_25
   \                     ??mbedtls_x509_crt_info_24: (+1)
   \      0x28A   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x28E   0xE14C             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_25: (+1)
   \      0x290   0x9806             LDR      R0,[SP, #+24]
   \      0x292   0x1BC0             SUBS     R0,R0,R7
   \      0x294   0x9006             STR      R0,[SP, #+24]
   \      0x296   0x9807             LDR      R0,[SP, #+28]
   \      0x298   0x4438             ADD      R0,R0,R7
   \      0x29A   0x9007             STR      R0,[SP, #+28]
   1822          
   1823              /* Key size */
   1824              if ((ret = mbedtls_x509_key_size_helper(key_size_str, BEFORE_COLON,
   1825                                                      mbedtls_pk_get_name(&crt->pk))) != 0) {
   \      0x29C   0xF114 0x00CC      ADDS     R0,R4,#+204
   \      0x2A0   0x.... 0x....      BL       mbedtls_pk_get_name
   \      0x2A4   0x0002             MOVS     R2,R0
   \      0x2A6   0x2112             MOVS     R1,#+18
   \      0x2A8   0xA808             ADD      R0,SP,#+32
   \      0x2AA   0x.... 0x....      BL       mbedtls_x509_key_size_helper
   \      0x2AE   0x4681             MOV      R9,R0
   \      0x2B0   0x2800             CMP      R0,#+0
   \      0x2B2   0xD001             BEQ.N    ??mbedtls_x509_crt_info_26
   1826                  return ret;
   \      0x2B4   0x4648             MOV      R0,R9
   \      0x2B6   0xE138             B.N      ??mbedtls_x509_crt_info_3
   1827              }
   1828          
   1829              ret = mbedtls_snprintf(p, n, "\n%s%-" BC "s: %d bits", prefix, key_size_str,
   1830                                     (int) mbedtls_pk_get_bitlen(&crt->pk));
   \                     ??mbedtls_x509_crt_info_26: (+1)
   \      0x2B8   0xF114 0x00CC      ADDS     R0,R4,#+204
   \      0x2BC   0x.... 0x....      BL       mbedtls_pk_get_bitlen
   \      0x2C0   0x9001             STR      R0,[SP, #+4]
   \      0x2C2   0xA808             ADD      R0,SP,#+32
   \      0x2C4   0x9000             STR      R0,[SP, #+0]
   \      0x2C6   0x0033             MOVS     R3,R6
   \      0x2C8   0x.... 0x....      LDR.W    R2,??DataTable21_3
   \      0x2CC   0x9906             LDR      R1,[SP, #+24]
   \      0x2CE   0x9807             LDR      R0,[SP, #+28]
   \      0x2D0   0x.... 0x....      BL       snprintf
   \      0x2D4   0x0007             MOVS     R7,R0
   1831              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x2D6   0x2F00             CMP      R7,#+0
   \      0x2D8   0xD402             BMI.N    ??mbedtls_x509_crt_info_27
   \      0x2DA   0x9806             LDR      R0,[SP, #+24]
   \      0x2DC   0x4287             CMP      R7,R0
   \      0x2DE   0xD302             BCC.N    ??mbedtls_x509_crt_info_28
   \                     ??mbedtls_x509_crt_info_27: (+1)
   \      0x2E0   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x2E4   0xE121             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_28: (+1)
   \      0x2E6   0x9806             LDR      R0,[SP, #+24]
   \      0x2E8   0x1BC0             SUBS     R0,R0,R7
   \      0x2EA   0x9006             STR      R0,[SP, #+24]
   \      0x2EC   0x9807             LDR      R0,[SP, #+28]
   \      0x2EE   0x4438             ADD      R0,R0,R7
   \      0x2F0   0x9007             STR      R0,[SP, #+28]
   1832          
   1833              /*
   1834               * Optional extensions
   1835               */
   1836          
   1837              if (crt->ext_types & MBEDTLS_X509_EXT_BASIC_CONSTRAINTS) {
   \      0x2F2   0xF8D4 0x01F0      LDR      R0,[R4, #+496]
   \      0x2F6   0x05C0             LSLS     R0,R0,#+23
   \      0x2F8   0xD53B             BPL.N    ??mbedtls_x509_crt_info_29
   1838                  ret = mbedtls_snprintf(p, n, "\n%sbasic constraints : CA=%s", prefix,
   1839                                         crt->ca_istrue ? "true" : "false");
   \      0x2FA   0xF8D4 0x01F4      LDR      R0,[R4, #+500]
   \      0x2FE   0x2800             CMP      R0,#+0
   \      0x300   0xD002             BEQ.N    ??mbedtls_x509_crt_info_30
   \      0x302   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \      0x306   0xE001             B.N      ??mbedtls_x509_crt_info_31
   \                     ??mbedtls_x509_crt_info_30: (+1)
   \      0x308   0x.... 0x....      LDR.W    R0,??DataTable21_6
   \                     ??mbedtls_x509_crt_info_31: (+1)
   \      0x30C   0x9000             STR      R0,[SP, #+0]
   \      0x30E   0x0033             MOVS     R3,R6
   \      0x310   0x.... 0x....      LDR.W    R2,??DataTable21_7
   \      0x314   0x9906             LDR      R1,[SP, #+24]
   \      0x316   0x9807             LDR      R0,[SP, #+28]
   \      0x318   0x.... 0x....      BL       snprintf
   \      0x31C   0x0007             MOVS     R7,R0
   1840                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x31E   0x2F00             CMP      R7,#+0
   \      0x320   0xD402             BMI.N    ??mbedtls_x509_crt_info_32
   \      0x322   0x9806             LDR      R0,[SP, #+24]
   \      0x324   0x4287             CMP      R7,R0
   \      0x326   0xD302             BCC.N    ??mbedtls_x509_crt_info_33
   \                     ??mbedtls_x509_crt_info_32: (+1)
   \      0x328   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x32C   0xE0FD             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_33: (+1)
   \      0x32E   0x9806             LDR      R0,[SP, #+24]
   \      0x330   0x1BC0             SUBS     R0,R0,R7
   \      0x332   0x9006             STR      R0,[SP, #+24]
   \      0x334   0x9807             LDR      R0,[SP, #+28]
   \      0x336   0x4438             ADD      R0,R0,R7
   \      0x338   0x9007             STR      R0,[SP, #+28]
   1841          
   1842                  if (crt->max_pathlen > 0) {
   \      0x33A   0xF8D4 0x01F8      LDR      R0,[R4, #+504]
   \      0x33E   0x2801             CMP      R0,#+1
   \      0x340   0xDB17             BLT.N    ??mbedtls_x509_crt_info_29
   1843                      ret = mbedtls_snprintf(p, n, ", max_pathlen=%d", crt->max_pathlen - 1);
   \      0x342   0xF8D4 0x31F8      LDR      R3,[R4, #+504]
   \      0x346   0x1E5B             SUBS     R3,R3,#+1
   \      0x348   0x.... 0x....      LDR.W    R2,??DataTable21_8
   \      0x34C   0x9906             LDR      R1,[SP, #+24]
   \      0x34E   0x9807             LDR      R0,[SP, #+28]
   \      0x350   0x.... 0x....      BL       snprintf
   \      0x354   0x0007             MOVS     R7,R0
   1844                      MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x356   0x2F00             CMP      R7,#+0
   \      0x358   0xD402             BMI.N    ??mbedtls_x509_crt_info_34
   \      0x35A   0x9806             LDR      R0,[SP, #+24]
   \      0x35C   0x4287             CMP      R7,R0
   \      0x35E   0xD302             BCC.N    ??mbedtls_x509_crt_info_35
   \                     ??mbedtls_x509_crt_info_34: (+1)
   \      0x360   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x364   0xE0E1             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_35: (+1)
   \      0x366   0x9806             LDR      R0,[SP, #+24]
   \      0x368   0x1BC0             SUBS     R0,R0,R7
   \      0x36A   0x9006             STR      R0,[SP, #+24]
   \      0x36C   0x9807             LDR      R0,[SP, #+28]
   \      0x36E   0x4438             ADD      R0,R0,R7
   \      0x370   0x9007             STR      R0,[SP, #+28]
   1845                  }
   1846              }
   1847          
   1848              if (crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME) {
   \                     ??mbedtls_x509_crt_info_29: (+1)
   \      0x372   0xF894 0x01F0      LDRB     R0,[R4, #+496]
   \      0x376   0x0680             LSLS     R0,R0,#+26
   \      0x378   0xD523             BPL.N    ??mbedtls_x509_crt_info_36
   1849                  ret = mbedtls_snprintf(p, n, "\n%ssubject alt name  :", prefix);
   \      0x37A   0x0033             MOVS     R3,R6
   \      0x37C   0x.... 0x....      LDR.W    R2,??DataTable21_9
   \      0x380   0x9906             LDR      R1,[SP, #+24]
   \      0x382   0x9807             LDR      R0,[SP, #+28]
   \      0x384   0x.... 0x....      BL       snprintf
   \      0x388   0x4681             MOV      R9,R0
   1850                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x38A   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x38E   0xD402             BMI.N    ??mbedtls_x509_crt_info_37
   \      0x390   0x9806             LDR      R0,[SP, #+24]
   \      0x392   0x4581             CMP      R9,R0
   \      0x394   0xD302             BCC.N    ??mbedtls_x509_crt_info_38
   \                     ??mbedtls_x509_crt_info_37: (+1)
   \      0x396   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x39A   0xE0C6             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_38: (+1)
   \      0x39C   0x9806             LDR      R0,[SP, #+24]
   \      0x39E   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x3A2   0x9006             STR      R0,[SP, #+24]
   \      0x3A4   0x9807             LDR      R0,[SP, #+28]
   \      0x3A6   0x4448             ADD      R0,R0,R9
   \      0x3A8   0x9007             STR      R0,[SP, #+28]
   1851          
   1852                  if ((ret = mbedtls_x509_info_subject_alt_name(&p, &n,
   1853                                                                &crt->subject_alt_names,
   1854                                                                prefix)) != 0) {
   \      0x3AA   0x0033             MOVS     R3,R6
   \      0x3AC   0xF514 0x72C8      ADDS     R2,R4,#+400
   \      0x3B0   0xA906             ADD      R1,SP,#+24
   \      0x3B2   0xA807             ADD      R0,SP,#+28
   \      0x3B4   0x.... 0x....      BL       mbedtls_x509_info_subject_alt_name
   \      0x3B8   0x0007             MOVS     R7,R0
   \      0x3BA   0x2800             CMP      R0,#+0
   \      0x3BC   0xD001             BEQ.N    ??mbedtls_x509_crt_info_36
   1855                      return ret;
   \      0x3BE   0x0038             MOVS     R0,R7
   \      0x3C0   0xE0B3             B.N      ??mbedtls_x509_crt_info_3
   1856                  }
   1857              }
   1858          
   1859              if (crt->ext_types & MBEDTLS_X509_EXT_NS_CERT_TYPE) {
   \                     ??mbedtls_x509_crt_info_36: (+1)
   \      0x3C2   0xF8D4 0x01F0      LDR      R0,[R4, #+496]
   \      0x3C6   0x03C0             LSLS     R0,R0,#+15
   \      0x3C8   0xD522             BPL.N    ??mbedtls_x509_crt_info_39
   1860                  ret = mbedtls_snprintf(p, n, "\n%scert. type        : ", prefix);
   \      0x3CA   0x0033             MOVS     R3,R6
   \      0x3CC   0x.... 0x....      LDR.W    R2,??DataTable21_10
   \      0x3D0   0x9906             LDR      R1,[SP, #+24]
   \      0x3D2   0x9807             LDR      R0,[SP, #+28]
   \      0x3D4   0x.... 0x....      BL       snprintf
   \      0x3D8   0x4681             MOV      R9,R0
   1861                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x3DA   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x3DE   0xD402             BMI.N    ??mbedtls_x509_crt_info_40
   \      0x3E0   0x9806             LDR      R0,[SP, #+24]
   \      0x3E2   0x4581             CMP      R9,R0
   \      0x3E4   0xD302             BCC.N    ??mbedtls_x509_crt_info_41
   \                     ??mbedtls_x509_crt_info_40: (+1)
   \      0x3E6   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x3EA   0xE09E             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_41: (+1)
   \      0x3EC   0x9806             LDR      R0,[SP, #+24]
   \      0x3EE   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x3F2   0x9006             STR      R0,[SP, #+24]
   \      0x3F4   0x9807             LDR      R0,[SP, #+28]
   \      0x3F6   0x4448             ADD      R0,R0,R9
   \      0x3F8   0x9007             STR      R0,[SP, #+28]
   1862          
   1863                  if ((ret = mbedtls_x509_info_cert_type(&p, &n, crt->ns_cert_type)) != 0) {
   \      0x3FA   0xF894 0x2210      LDRB     R2,[R4, #+528]
   \      0x3FE   0xA906             ADD      R1,SP,#+24
   \      0x400   0xA807             ADD      R0,SP,#+28
   \      0x402   0x.... 0x....      BL       mbedtls_x509_info_cert_type
   \      0x406   0x0007             MOVS     R7,R0
   \      0x408   0x2800             CMP      R0,#+0
   \      0x40A   0xD001             BEQ.N    ??mbedtls_x509_crt_info_39
   1864                      return ret;
   \      0x40C   0x0038             MOVS     R0,R7
   \      0x40E   0xE08C             B.N      ??mbedtls_x509_crt_info_3
   1865                  }
   1866              }
   1867          
   1868              if (crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE) {
   \                     ??mbedtls_x509_crt_info_39: (+1)
   \      0x410   0xF894 0x01F0      LDRB     R0,[R4, #+496]
   \      0x414   0x0740             LSLS     R0,R0,#+29
   \      0x416   0xD522             BPL.N    ??mbedtls_x509_crt_info_42
   1869                  ret = mbedtls_snprintf(p, n, "\n%skey usage         : ", prefix);
   \      0x418   0x0033             MOVS     R3,R6
   \      0x41A   0x.... 0x....      LDR.W    R2,??DataTable22
   \      0x41E   0x9906             LDR      R1,[SP, #+24]
   \      0x420   0x9807             LDR      R0,[SP, #+28]
   \      0x422   0x.... 0x....      BL       snprintf
   \      0x426   0x4681             MOV      R9,R0
   1870                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x428   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x42C   0xD402             BMI.N    ??mbedtls_x509_crt_info_43
   \      0x42E   0x9806             LDR      R0,[SP, #+24]
   \      0x430   0x4581             CMP      R9,R0
   \      0x432   0xD302             BCC.N    ??mbedtls_x509_crt_info_44
   \                     ??mbedtls_x509_crt_info_43: (+1)
   \      0x434   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x438   0xE077             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_44: (+1)
   \      0x43A   0x9806             LDR      R0,[SP, #+24]
   \      0x43C   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x440   0x9006             STR      R0,[SP, #+24]
   \      0x442   0x9807             LDR      R0,[SP, #+28]
   \      0x444   0x4448             ADD      R0,R0,R9
   \      0x446   0x9007             STR      R0,[SP, #+28]
   1871          
   1872                  if ((ret = mbedtls_x509_info_key_usage(&p, &n, crt->key_usage)) != 0) {
   \      0x448   0xF8D4 0x21FC      LDR      R2,[R4, #+508]
   \      0x44C   0xA906             ADD      R1,SP,#+24
   \      0x44E   0xA807             ADD      R0,SP,#+28
   \      0x450   0x.... 0x....      BL       mbedtls_x509_info_key_usage
   \      0x454   0x0007             MOVS     R7,R0
   \      0x456   0x2800             CMP      R0,#+0
   \      0x458   0xD001             BEQ.N    ??mbedtls_x509_crt_info_42
   1873                      return ret;
   \      0x45A   0x0038             MOVS     R0,R7
   \      0x45C   0xE065             B.N      ??mbedtls_x509_crt_info_3
   1874                  }
   1875              }
   1876          
   1877              if (crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE) {
   \                     ??mbedtls_x509_crt_info_42: (+1)
   \      0x45E   0xF8D4 0x01F0      LDR      R0,[R4, #+496]
   \      0x462   0x0500             LSLS     R0,R0,#+20
   \      0x464   0xD522             BPL.N    ??mbedtls_x509_crt_info_45
   1878                  ret = mbedtls_snprintf(p, n, "\n%sext key usage     : ", prefix);
   \      0x466   0x0033             MOVS     R3,R6
   \      0x468   0x.... 0x....      LDR.W    R2,??DataTable22_1
   \      0x46C   0x9906             LDR      R1,[SP, #+24]
   \      0x46E   0x9807             LDR      R0,[SP, #+28]
   \      0x470   0x.... 0x....      BL       snprintf
   \      0x474   0x4681             MOV      R9,R0
   1879                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x476   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x47A   0xD402             BMI.N    ??mbedtls_x509_crt_info_46
   \      0x47C   0x9806             LDR      R0,[SP, #+24]
   \      0x47E   0x4581             CMP      R9,R0
   \      0x480   0xD302             BCC.N    ??mbedtls_x509_crt_info_47
   \                     ??mbedtls_x509_crt_info_46: (+1)
   \      0x482   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x486   0xE050             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_47: (+1)
   \      0x488   0x9806             LDR      R0,[SP, #+24]
   \      0x48A   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x48E   0x9006             STR      R0,[SP, #+24]
   \      0x490   0x9807             LDR      R0,[SP, #+28]
   \      0x492   0x4448             ADD      R0,R0,R9
   \      0x494   0x9007             STR      R0,[SP, #+28]
   1880          
   1881                  if ((ret = x509_info_ext_key_usage(&p, &n,
   1882                                                     &crt->ext_key_usage)) != 0) {
   \      0x496   0xF514 0x7200      ADDS     R2,R4,#+512
   \      0x49A   0xA906             ADD      R1,SP,#+24
   \      0x49C   0xA807             ADD      R0,SP,#+28
   \      0x49E   0x.... 0x....      BL       x509_info_ext_key_usage
   \      0x4A2   0x0007             MOVS     R7,R0
   \      0x4A4   0x2800             CMP      R0,#+0
   \      0x4A6   0xD001             BEQ.N    ??mbedtls_x509_crt_info_45
   1883                      return ret;
   \      0x4A8   0x0038             MOVS     R0,R7
   \      0x4AA   0xE03E             B.N      ??mbedtls_x509_crt_info_3
   1884                  }
   1885              }
   1886          
   1887              if (crt->ext_types & MBEDTLS_OID_X509_EXT_CERTIFICATE_POLICIES) {
   \                     ??mbedtls_x509_crt_info_45: (+1)
   \      0x4AC   0xF894 0x01F0      LDRB     R0,[R4, #+496]
   \      0x4B0   0x0700             LSLS     R0,R0,#+28
   \      0x4B2   0xD522             BPL.N    ??mbedtls_x509_crt_info_48
   1888                  ret = mbedtls_snprintf(p, n, "\n%scertificate policies : ", prefix);
   \      0x4B4   0x0033             MOVS     R3,R6
   \      0x4B6   0x.... 0x....      LDR.W    R2,??DataTable22_2
   \      0x4BA   0x9906             LDR      R1,[SP, #+24]
   \      0x4BC   0x9807             LDR      R0,[SP, #+28]
   \      0x4BE   0x.... 0x....      BL       snprintf
   \      0x4C2   0x4681             MOV      R9,R0
   1889                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x4C4   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x4C8   0xD402             BMI.N    ??mbedtls_x509_crt_info_49
   \      0x4CA   0x9806             LDR      R0,[SP, #+24]
   \      0x4CC   0x4581             CMP      R9,R0
   \      0x4CE   0xD302             BCC.N    ??mbedtls_x509_crt_info_50
   \                     ??mbedtls_x509_crt_info_49: (+1)
   \      0x4D0   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x4D4   0xE029             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_50: (+1)
   \      0x4D6   0x9806             LDR      R0,[SP, #+24]
   \      0x4D8   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x4DC   0x9006             STR      R0,[SP, #+24]
   \      0x4DE   0x9807             LDR      R0,[SP, #+28]
   \      0x4E0   0x4448             ADD      R0,R0,R9
   \      0x4E2   0x9007             STR      R0,[SP, #+28]
   1890          
   1891                  if ((ret = x509_info_cert_policies(&p, &n,
   1892                                                     &crt->certificate_policies)) != 0) {
   \      0x4E4   0xF514 0x72F0      ADDS     R2,R4,#+480
   \      0x4E8   0xA906             ADD      R1,SP,#+24
   \      0x4EA   0xA807             ADD      R0,SP,#+28
   \      0x4EC   0x.... 0x....      BL       x509_info_cert_policies
   \      0x4F0   0x0007             MOVS     R7,R0
   \      0x4F2   0x2800             CMP      R0,#+0
   \      0x4F4   0xD001             BEQ.N    ??mbedtls_x509_crt_info_48
   1893                      return ret;
   \      0x4F6   0x0038             MOVS     R0,R7
   \      0x4F8   0xE017             B.N      ??mbedtls_x509_crt_info_3
   1894                  }
   1895              }
   1896          
   1897              ret = mbedtls_snprintf(p, n, "\n");
   \                     ??mbedtls_x509_crt_info_48: (+1)
   \      0x4FA   0x....             ADR.N    R2,??DataTable19
   \      0x4FC   0x9906             LDR      R1,[SP, #+24]
   \      0x4FE   0x9807             LDR      R0,[SP, #+28]
   \      0x500   0x.... 0x....      BL       snprintf
   \      0x504   0x0001             MOVS     R1,R0
   1898              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x506   0x2900             CMP      R1,#+0
   \      0x508   0xD402             BMI.N    ??mbedtls_x509_crt_info_51
   \      0x50A   0x9806             LDR      R0,[SP, #+24]
   \      0x50C   0x4281             CMP      R1,R0
   \      0x50E   0xD302             BCC.N    ??mbedtls_x509_crt_info_52
   \                     ??mbedtls_x509_crt_info_51: (+1)
   \      0x510   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x514   0xE009             B.N      ??mbedtls_x509_crt_info_3
   \                     ??mbedtls_x509_crt_info_52: (+1)
   \      0x516   0x9806             LDR      R0,[SP, #+24]
   \      0x518   0x1A40             SUBS     R0,R0,R1
   \      0x51A   0x9006             STR      R0,[SP, #+24]
   \      0x51C   0x9807             LDR      R0,[SP, #+28]
   \      0x51E   0x4408             ADD      R0,R0,R1
   \      0x520   0x9007             STR      R0,[SP, #+28]
   1899          
   1900              return (int) (size - n);
   \      0x522   0x9806             LDR      R0,[SP, #+24]
   \      0x524   0xEBB8 0x0800      SUBS     R8,R8,R0
   \      0x528   0x4640             MOV      R0,R8
   \                     ??mbedtls_x509_crt_info_3: (+1)
   \      0x52A   0xB00D             ADD      SP,SP,#+52
   \      0x52C   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1901          }
   1902          
   1903          struct x509_crt_verify_string {
   1904              int code;
   1905              const char *string;
   1906          };
   1907          
   1908          #define X509_CRT_ERROR_INFO(err, err_str, info) { err, info },

   \                                 In section .rodata, align 4
   1909          static const struct x509_crt_verify_string x509_crt_verify_strings[] = {
   \                     x509_crt_verify_strings:
   \        0x0   0x0000'0001        DC32 1, ?_0, 2, ?_1, 4, ?_2, 8, ?_3, 16, ?_4, 32, ?_5, 64, ?_6, 128
   \              0x....'....  
   \              0x0000'0002  
   \              0x....'....  
   \              0x0000'0004  
   \              0x....'....  
   \              0x0000'0008  
   \              0x....'....  
   \              0x0000'0010  
   \              0x....'....  
   \              0x0000'0020  
   \              0x....'....  
   \              0x0000'0040  
   \              0x....'....  
   \              0x0000'0080
   \       0x3C   0x....'....        DC32 ?_7, 256, ?_8, 512, ?_9, 1'024, ?_10, 2'048, ?_11, 4'096, ?_12
   \              0x0000'0100  
   \              0x....'....  
   \              0x0000'0200  
   \              0x....'....  
   \              0x0000'0400  
   \              0x....'....  
   \              0x0000'0800  
   \              0x....'....  
   \              0x0000'1000  
   \              0x....'....
   \       0x68   0x0000'2000        DC32 8'192, ?_13, 16'384, ?_14, 32'768, ?_15, 65'536, ?_16, 131'072
   \              0x....'....  
   \              0x0000'4000  
   \              0x....'....  
   \              0x0000'8000  
   \              0x....'....  
   \              0x0001'0000  
   \              0x....'....  
   \              0x0002'0000
   \       0x8C   0x....'....        DC32 ?_17, 262'144, ?_18, 524'288, ?_19, 0, 0x0
   \              0x0004'0000  
   \              0x....'....  
   \              0x0008'0000  
   \              0x....'....  
   \              0x0000'0000  
   \              0x0000'0000
   1910              MBEDTLS_X509_CRT_ERROR_INFO_LIST
   1911              { 0, NULL }
   1912          };
   1913          #undef X509_CRT_ERROR_INFO
   1914          

   \                                 In section .text, align 2, keep-with-next
   1915          int mbedtls_x509_crt_verify_info(char *buf, size_t size, const char *prefix,
   1916                                           uint32_t flags)
   1917          {
   \                     mbedtls_x509_crt_verify_info: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001C             MOVS     R4,R3
   1918              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
   1919              const struct x509_crt_verify_string *cur;
   1920              char *p = buf;
   \       0x10   0x46D8             MOV      R8,R11
   1921              size_t n = size;
   \       0x12   0x46A9             MOV      R9,R5
   1922          
   1923              for (cur = x509_crt_verify_strings; cur->string != NULL; cur++) {
   \       0x14   0x.... 0x....      LDR.W    R10,??DataTable23
   \                     ??mbedtls_x509_crt_verify_info_0: (+1)
   \       0x18   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD01E             BEQ.N    ??mbedtls_x509_crt_verify_info_1
   1924                  if ((flags & cur->code) == 0) {
   \       0x20   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x24   0x4204             TST      R4,R0
   \       0x26   0xD017             BEQ.N    ??mbedtls_x509_crt_verify_info_2
   1925                      continue;
   1926                  }
   1927          
   1928                  ret = mbedtls_snprintf(p, n, "%s%s\n", prefix, cur->string);
   \                     ??mbedtls_x509_crt_verify_info_3: (+1)
   \       0x28   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \       0x2E   0x0033             MOVS     R3,R6
   \       0x30   0x.... 0x....      LDR.W    R2,??DataTable24
   \       0x34   0x4649             MOV      R1,R9
   \       0x36   0x4640             MOV      R0,R8
   \       0x38   0x.... 0x....      BL       snprintf
   \       0x3C   0x0007             MOVS     R7,R0
   1929                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x3E   0x2F00             CMP      R7,#+0
   \       0x40   0xD401             BMI.N    ??mbedtls_x509_crt_verify_info_4
   \       0x42   0x454F             CMP      R7,R9
   \       0x44   0xD302             BCC.N    ??mbedtls_x509_crt_verify_info_5
   \                     ??mbedtls_x509_crt_verify_info_4: (+1)
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x4A   0xE01F             B.N      ??mbedtls_x509_crt_verify_info_6
   \                     ??mbedtls_x509_crt_verify_info_5: (+1)
   \       0x4C   0xEBB9 0x0907      SUBS     R9,R9,R7
   \       0x50   0x44B8             ADD      R8,R8,R7
   1930                  flags ^= cur->code;
   \       0x52   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x56   0x4044             EORS     R4,R0,R4
   1931              }
   \                     ??mbedtls_x509_crt_verify_info_2: (+1)
   \       0x58   0xF11A 0x0A08      ADDS     R10,R10,#+8
   \       0x5C   0xE7DC             B.N      ??mbedtls_x509_crt_verify_info_0
   1932          
   1933              if (flags != 0) {
   \                     ??mbedtls_x509_crt_verify_info_1: (+1)
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xD011             BEQ.N    ??mbedtls_x509_crt_verify_info_7
   1934                  ret = mbedtls_snprintf(p, n, "%sUnknown reason "
   1935                                               "(this should not happen)\n", prefix);
   \       0x62   0x0033             MOVS     R3,R6
   \       0x64   0x.... 0x....      LDR.W    R2,??DataTable24_1
   \       0x68   0x4649             MOV      R1,R9
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0x.... 0x....      BL       snprintf
   \       0x70   0x0007             MOVS     R7,R0
   1936                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x72   0x2F00             CMP      R7,#+0
   \       0x74   0xD401             BMI.N    ??mbedtls_x509_crt_verify_info_8
   \       0x76   0x454F             CMP      R7,R9
   \       0x78   0xD302             BCC.N    ??mbedtls_x509_crt_verify_info_9
   \                     ??mbedtls_x509_crt_verify_info_8: (+1)
   \       0x7A   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x7E   0xE005             B.N      ??mbedtls_x509_crt_verify_info_6
   \                     ??mbedtls_x509_crt_verify_info_9: (+1)
   \       0x80   0xEBB9 0x0907      SUBS     R9,R9,R7
   \       0x84   0x44B8             ADD      R8,R8,R7
   1937              }
   1938          
   1939              return (int) (size - n);
   \                     ??mbedtls_x509_crt_verify_info_7: (+1)
   \       0x86   0xEBB5 0x0509      SUBS     R5,R5,R9
   \       0x8A   0x0028             MOVS     R0,R5
   \                     ??mbedtls_x509_crt_verify_info_6: (+1)
   \       0x8C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1940          }
   1941          #endif /* MBEDTLS_X509_REMOVE_INFO */
   1942          

   \                                 In section .text, align 2, keep-with-next
   1943          int mbedtls_x509_crt_check_key_usage(const mbedtls_x509_crt *crt,
   1944                                               unsigned int usage)
   1945          {
   \                     mbedtls_x509_crt_check_key_usage: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0002             MOVS     R2,R0
   1946              unsigned int usage_must, usage_may;
   1947              unsigned int may_mask = MBEDTLS_X509_KU_ENCIPHER_ONLY
   1948                                      | MBEDTLS_X509_KU_DECIPHER_ONLY;
   \        0x4   0xF248 0x0301      MOVW     R3,#+32769
   1949          
   1950              if ((crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE) == 0) {
   \        0x8   0xF892 0x01F0      LDRB     R0,[R2, #+496]
   \        0xC   0x0740             LSLS     R0,R0,#+29
   \        0xE   0xD401             BMI.N    ??mbedtls_x509_crt_check_key_usage_0
   1951                  return 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE016             B.N      ??mbedtls_x509_crt_check_key_usage_1
   1952              }
   1953          
   1954              usage_must = usage & ~may_mask;
   \                     ??mbedtls_x509_crt_check_key_usage_0: (+1)
   \       0x14   0xEA31 0x0403      BICS     R4,R1,R3
   1955          
   1956              if (((crt->key_usage & ~may_mask) & usage_must) != usage_must) {
   \       0x18   0xF8D2 0x01FC      LDR      R0,[R2, #+508]
   \       0x1C   0x4398             BICS     R0,R0,R3
   \       0x1E   0x4020             ANDS     R0,R4,R0
   \       0x20   0x42A0             CMP      R0,R4
   \       0x22   0xD002             BEQ.N    ??mbedtls_x509_crt_check_key_usage_2
   1957                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \       0x28   0xE00B             B.N      ??mbedtls_x509_crt_check_key_usage_1
   1958              }
   1959          
   1960              usage_may = usage & may_mask;
   \                     ??mbedtls_x509_crt_check_key_usage_2: (+1)
   \       0x2A   0xEA13 0x0501      ANDS     R5,R3,R1
   1961          
   1962              if (((crt->key_usage & may_mask) | usage_may) != usage_may) {
   \       0x2E   0xF8D2 0x01FC      LDR      R0,[R2, #+508]
   \       0x32   0x4018             ANDS     R0,R3,R0
   \       0x34   0x4328             ORRS     R0,R5,R0
   \       0x36   0x42A8             CMP      R0,R5
   \       0x38   0xD002             BEQ.N    ??mbedtls_x509_crt_check_key_usage_3
   1963                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \       0x3E   0xE000             B.N      ??mbedtls_x509_crt_check_key_usage_1
   1964              }
   1965          
   1966              return 0;
   \                     ??mbedtls_x509_crt_check_key_usage_3: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_crt_check_key_usage_1: (+1)
   \       0x42   0xBC30             POP      {R4,R5}
   \       0x44   0x4770             BX       LR
   1967          }
   1968          

   \                                 In section .text, align 2, keep-with-next
   1969          int mbedtls_x509_crt_check_extended_key_usage(const mbedtls_x509_crt *crt,
   1970                                                        const char *usage_oid,
   1971                                                        size_t usage_len)
   1972          {
   \                     mbedtls_x509_crt_check_extended_key_usage: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   1973              const mbedtls_x509_sequence *cur;
   1974          
   1975              /* Extension is not mandatory, absent means no restriction */
   1976              if ((crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE) == 0) {
   \        0xA   0xF8D5 0x01F0      LDR      R0,[R5, #+496]
   \        0xE   0x0500             LSLS     R0,R0,#+20
   \       0x10   0xD401             BMI.N    ??mbedtls_x509_crt_check_extended_key_usage_0
   1977                  return 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE02C             B.N      ??mbedtls_x509_crt_check_extended_key_usage_1
   1978              }
   1979          
   1980              /*
   1981               * Look for the requested usage (or wildcard ANY) in our list
   1982               */
   1983              for (cur = &crt->ext_key_usage; cur != NULL; cur = cur->next) {
   \                     ??mbedtls_x509_crt_check_extended_key_usage_0: (+1)
   \       0x16   0xF515 0x7400      ADDS     R4,R5,#+512
   \                     ??mbedtls_x509_crt_check_extended_key_usage_2: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD026             BEQ.N    ??mbedtls_x509_crt_check_extended_key_usage_3
   1984                  const mbedtls_x509_buf *cur_oid = &cur->buf;
   \       0x1E   0x46A0             MOV      R8,R4
   1985          
   1986                  if (cur_oid->len == usage_len &&
   1987                      memcmp(cur_oid->p, usage_oid, usage_len) == 0) {
   \       0x20   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x24   0x42B8             CMP      R0,R7
   \       0x26   0xD109             BNE.N    ??mbedtls_x509_crt_check_extended_key_usage_4
   \       0x28   0x003A             MOVS     R2,R7
   \       0x2A   0x0031             MOVS     R1,R6
   \       0x2C   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x30   0x.... 0x....      BL       memcmp
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD101             BNE.N    ??mbedtls_x509_crt_check_extended_key_usage_4
   1988                      return 0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE019             B.N      ??mbedtls_x509_crt_check_extended_key_usage_1
   1989                  }
   1990          
   1991                  if (MBEDTLS_OID_CMP(MBEDTLS_OID_ANY_EXTENDED_KEY_USAGE, cur_oid) == 0) {
   \                     ??mbedtls_x509_crt_check_extended_key_usage_4: (+1)
   \       0x3C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x40   0x2804             CMP      R0,#+4
   \       0x42   0xD109             BNE.N    ??mbedtls_x509_crt_check_extended_key_usage_5
   \       0x44   0xF8D8 0x2004      LDR      R2,[R8, #+4]
   \       0x48   0xF8D8 0x1008      LDR      R1,[R8, #+8]
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \       0x50   0x.... 0x....      BL       memcmp
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD001             BEQ.N    ??mbedtls_x509_crt_check_extended_key_usage_6
   \                     ??mbedtls_x509_crt_check_extended_key_usage_5: (+1)
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xE000             B.N      ??mbedtls_x509_crt_check_extended_key_usage_7
   \                     ??mbedtls_x509_crt_check_extended_key_usage_6: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_crt_check_extended_key_usage_7: (+1)
   \       0x5E   0xB2C0             UXTB     R0,R0
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD101             BNE.N    ??mbedtls_x509_crt_check_extended_key_usage_8
   1992                      return 0;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE003             B.N      ??mbedtls_x509_crt_check_extended_key_usage_1
   1993                  }
   1994              }
   \                     ??mbedtls_x509_crt_check_extended_key_usage_8: (+1)
   \       0x68   0x68E4             LDR      R4,[R4, #+12]
   \       0x6A   0xE7D6             B.N      ??mbedtls_x509_crt_check_extended_key_usage_2
   1995          
   1996              return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \                     ??mbedtls_x509_crt_check_extended_key_usage_3: (+1)
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \                     ??mbedtls_x509_crt_check_extended_key_usage_1: (+1)
   \       0x70   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1997          }
   1998          
   1999          #if defined(MBEDTLS_X509_CRL_PARSE_C)
   2000          /*
   2001           * Return 1 if the certificate is revoked, or 0 otherwise.
   2002           */

   \                                 In section .text, align 2, keep-with-next
   2003          int mbedtls_x509_crt_is_revoked(const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl)
   2004          {
   \                     mbedtls_x509_crt_is_revoked: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   2005              const mbedtls_x509_crl_entry *cur = &crl->entry;
   \        0x6   0xF116 0x0484      ADDS     R4,R6,#+132
   2006          
   2007              while (cur != NULL && cur->serial.len != 0) {
   \                     ??mbedtls_x509_crt_is_revoked_0: (+1)
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD011             BEQ.N    ??mbedtls_x509_crt_is_revoked_1
   \        0xE   0x6920             LDR      R0,[R4, #+16]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD00E             BEQ.N    ??mbedtls_x509_crt_is_revoked_1
   2008                  if (crt->serial.len == cur->serial.len &&
   2009                      memcmp(crt->serial.p, cur->serial.p, crt->serial.len) == 0) {
   \       0x14   0x6A69             LDR      R1,[R5, #+36]
   \       0x16   0x6920             LDR      R0,[R4, #+16]
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0xD108             BNE.N    ??mbedtls_x509_crt_is_revoked_2
   \       0x1C   0x6A6A             LDR      R2,[R5, #+36]
   \       0x1E   0x6961             LDR      R1,[R4, #+20]
   \       0x20   0x6AA8             LDR      R0,[R5, #+40]
   \       0x22   0x.... 0x....      BL       memcmp
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD101             BNE.N    ??mbedtls_x509_crt_is_revoked_2
   2010                      return 1;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE002             B.N      ??mbedtls_x509_crt_is_revoked_3
   2011                  }
   2012          
   2013                  cur = cur->next;
   \                     ??mbedtls_x509_crt_is_revoked_2: (+1)
   \       0x2E   0x6BE4             LDR      R4,[R4, #+60]
   \       0x30   0xE7EB             B.N      ??mbedtls_x509_crt_is_revoked_0
   2014              }
   2015          
   2016              return 0;
   \                     ??mbedtls_x509_crt_is_revoked_1: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_crt_is_revoked_3: (+1)
   \       0x34   0xBD70             POP      {R4-R6,PC}
   2017          }
   2018          
   2019          /*
   2020           * Check that the given certificate is not revoked according to the CRL.
   2021           * Skip validation if no CRL for the given CA is present.
   2022           */

   \                                 In section .text, align 2, keep-with-next
   2023          static int x509_crt_verifycrl(mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,
   2024                                        mbedtls_x509_crl *crl_list,
   2025                                        const mbedtls_x509_crt_profile *profile,
   2026                                        const mbedtls_x509_time *now)
   2027          {
   \                     x509_crt_verifycrl: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0x4698             MOV      R8,R3
   2028              int flags = 0;
   \        0xE   0xF05F 0x0900      MOVS     R9,#+0
   2029              unsigned char hash[MBEDTLS_MD_MAX_SIZE];
   2030          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2031              psa_algorithm_t psa_algorithm;
   2032          #else
   2033              const mbedtls_md_info_t *md_info;
   2034          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2035              size_t hash_length;
   2036          
   2037              if (ca == NULL) {
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??x509_crt_verifycrl_0
   2038                  return flags;
   \       0x16   0x4648             MOV      R0,R9
   \       0x18   0xE06D             B.N      ??x509_crt_verifycrl_1
   2039              }
   2040          
   2041              while (crl_list != NULL) {
   \                     ??x509_crt_verifycrl_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD06A             BEQ.N    ??x509_crt_verifycrl_2
   2042                  if (crl_list->version == 0 ||
   2043                      x509_name_cmp(&crl_list->issuer, &ca->subject) != 0) {
   \       0x1E   0x69A0             LDR      R0,[R4, #+24]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD007             BEQ.N    ??x509_crt_verifycrl_3
   \       0x24   0xF115 0x0170      ADDS     R1,R5,#+112
   \       0x28   0xF114 0x0034      ADDS     R0,R4,#+52
   \       0x2C   0x.... 0x....      BL       x509_name_cmp
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD002             BEQ.N    ??x509_crt_verifycrl_4
   2044                      crl_list = crl_list->next;
   \                     ??x509_crt_verifycrl_3: (+1)
   \       0x34   0xF8D4 0x40F0      LDR      R4,[R4, #+240]
   2045                      continue;
   \       0x38   0xE7EF             B.N      ??x509_crt_verifycrl_0
   2046                  }
   2047          
   2048                  /*
   2049                   * Check if the CA is configured to sign CRLs
   2050                   */
   2051                  if (mbedtls_x509_crt_check_key_usage(ca,
   2052                                                       MBEDTLS_X509_KU_CRL_SIGN) != 0) {
   \                     ??x509_crt_verifycrl_4: (+1)
   \       0x3A   0x2102             MOVS     R1,#+2
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x.... 0x....      BL       mbedtls_x509_crt_check_key_usage
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD002             BEQ.N    ??x509_crt_verifycrl_5
   2053                      flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
   \       0x46   0xF059 0x0910      ORRS     R9,R9,#0x10
   2054                      break;
   \       0x4A   0xE053             B.N      ??x509_crt_verifycrl_2
   2055                  }
   2056          
   2057                  /*
   2058                   * Check if CRL is correctly signed by the trusted CA
   2059                   */
   2060                  if (x509_profile_check_md_alg(profile, crl_list->sig_md) != 0) {
   \                     ??x509_crt_verifycrl_5: (+1)
   \       0x4C   0xF894 0x10E8      LDRB     R1,[R4, #+232]
   \       0x50   0x4640             MOV      R0,R8
   \       0x52   0x.... 0x....      BL       x509_profile_check_md_alg
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD001             BEQ.N    ??x509_crt_verifycrl_6
   2061                      flags |= MBEDTLS_X509_BADCRL_BAD_MD;
   \       0x5A   0xF459 0x3900      ORRS     R9,R9,#0x20000
   2062                  }
   2063          
   2064                  if (x509_profile_check_pk_alg(profile, crl_list->sig_pk) != 0) {
   \                     ??x509_crt_verifycrl_6: (+1)
   \       0x5E   0xF894 0x10E9      LDRB     R1,[R4, #+233]
   \       0x62   0x4640             MOV      R0,R8
   \       0x64   0x.... 0x....      BL       x509_profile_check_pk_alg
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD001             BEQ.N    ??x509_crt_verifycrl_7
   2065                      flags |= MBEDTLS_X509_BADCRL_BAD_PK;
   \       0x6C   0xF459 0x2980      ORRS     R9,R9,#0x40000
   2066                  }
   2067          
   2068          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2069                  psa_algorithm = mbedtls_md_psa_alg_from_type(crl_list->sig_md);
   \                     ??x509_crt_verifycrl_7: (+1)
   \       0x70   0xF894 0x00E8      LDRB     R0,[R4, #+232]
   \       0x74   0x.... 0x....      BL       mbedtls_md_psa_alg_from_type
   \       0x78   0x0006             MOVS     R6,R0
   2070                  if (psa_hash_compute(psa_algorithm,
   2071                                       crl_list->tbs.p,
   2072                                       crl_list->tbs.len,
   2073                                       hash,
   2074                                       sizeof(hash),
   2075                                       &hash_length) != PSA_SUCCESS) {
   \       0x7A   0xA804             ADD      R0,SP,#+16
   \       0x7C   0x9001             STR      R0,[SP, #+4]
   \       0x7E   0x2020             MOVS     R0,#+32
   \       0x80   0x9000             STR      R0,[SP, #+0]
   \       0x82   0xAB05             ADD      R3,SP,#+20
   \       0x84   0x6922             LDR      R2,[R4, #+16]
   \       0x86   0x6961             LDR      R1,[R4, #+20]
   \       0x88   0x0030             MOVS     R0,R6
   \       0x8A   0x.... 0x....      BL       psa_hash_compute
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD002             BEQ.N    ??x509_crt_verifycrl_8
   2076                      /* Note: this can't happen except after an internal error */
   2077                      flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
   \       0x92   0xF059 0x0910      ORRS     R9,R9,#0x10
   2078                      break;
   \       0x96   0xE02D             B.N      ??x509_crt_verifycrl_2
   2079                  }
   2080          #else
   2081                  md_info = mbedtls_md_info_from_type(crl_list->sig_md);
   2082                  hash_length = mbedtls_md_get_size(md_info);
   2083                  if (mbedtls_md(md_info,
   2084                                 crl_list->tbs.p,
   2085                                 crl_list->tbs.len,
   2086                                 hash) != 0) {
   2087                      /* Note: this can't happen except after an internal error */
   2088                      flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
   2089                      break;
   2090                  }
   2091          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2092          
   2093                  if (x509_profile_check_key(profile, &ca->pk) != 0) {
   \                     ??x509_crt_verifycrl_8: (+1)
   \       0x98   0xF115 0x01CC      ADDS     R1,R5,#+204
   \       0x9C   0x4640             MOV      R0,R8
   \       0x9E   0x.... 0x....      BL       x509_profile_check_key
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD001             BEQ.N    ??x509_crt_verifycrl_9
   2094                      flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
   \       0xA6   0xF459 0x3980      ORRS     R9,R9,#0x10000
   2095                  }
   2096          
   2097                  if (mbedtls_pk_verify_ext(crl_list->sig_pk, crl_list->sig_opts, &ca->pk,
   2098                                            crl_list->sig_md, hash, hash_length,
   2099                                            crl_list->sig.p, crl_list->sig.len) != 0) {
   \                     ??x509_crt_verifycrl_9: (+1)
   \       0xAA   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \       0xAE   0x9003             STR      R0,[SP, #+12]
   \       0xB0   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \       0xB4   0x9002             STR      R0,[SP, #+8]
   \       0xB6   0x9804             LDR      R0,[SP, #+16]
   \       0xB8   0x9001             STR      R0,[SP, #+4]
   \       0xBA   0xA805             ADD      R0,SP,#+20
   \       0xBC   0x9000             STR      R0,[SP, #+0]
   \       0xBE   0xF894 0x30E8      LDRB     R3,[R4, #+232]
   \       0xC2   0xF115 0x02CC      ADDS     R2,R5,#+204
   \       0xC6   0xF8D4 0x10EC      LDR      R1,[R4, #+236]
   \       0xCA   0xF894 0x00E9      LDRB     R0,[R4, #+233]
   \       0xCE   0x.... 0x....      BL       mbedtls_pk_verify_ext
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD002             BEQ.N    ??x509_crt_verifycrl_10
   2100                      flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
   \       0xD6   0xF059 0x0910      ORRS     R9,R9,#0x10
   2101                      break;
   \       0xDA   0xE00B             B.N      ??x509_crt_verifycrl_2
   2102                  }
   2103          
   2104          #if defined(MBEDTLS_HAVE_TIME_DATE)
   2105                  /*
   2106                   * Check for validity of CRL (Do not drop out)
   2107                   */
   2108                  if (mbedtls_x509_time_cmp(&crl_list->next_update, now) < 0) {
   2109                      flags |= MBEDTLS_X509_BADCRL_EXPIRED;
   2110                  }
   2111          
   2112                  if (mbedtls_x509_time_cmp(&crl_list->this_update, now) > 0) {
   2113                      flags |= MBEDTLS_X509_BADCRL_FUTURE;
   2114                  }
   2115          #else
   2116                  ((void) now);
   2117          #endif
   2118          
   2119                  /*
   2120                   * Check if certificate is revoked
   2121                   */
   2122                  if (mbedtls_x509_crt_is_revoked(crt, crl_list)) {
   \                     ??x509_crt_verifycrl_10: (+1)
   \       0xDC   0x0021             MOVS     R1,R4
   \       0xDE   0x0038             MOVS     R0,R7
   \       0xE0   0x.... 0x....      BL       mbedtls_x509_crt_is_revoked
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD002             BEQ.N    ??x509_crt_verifycrl_11
   2123                      flags |= MBEDTLS_X509_BADCERT_REVOKED;
   \       0xE8   0xF059 0x0902      ORRS     R9,R9,#0x2
   2124                      break;
   \       0xEC   0xE002             B.N      ??x509_crt_verifycrl_2
   2125                  }
   2126          
   2127                  crl_list = crl_list->next;
   \                     ??x509_crt_verifycrl_11: (+1)
   \       0xEE   0xF8D4 0x40F0      LDR      R4,[R4, #+240]
   \       0xF2   0xE792             B.N      ??x509_crt_verifycrl_0
   2128              }
   2129          
   2130              return flags;
   \                     ??x509_crt_verifycrl_2: (+1)
   \       0xF4   0x4648             MOV      R0,R9
   \                     ??x509_crt_verifycrl_1: (+1)
   \       0xF6   0xB00D             ADD      SP,SP,#+52
   \       0xF8   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2131          }
   2132          #endif /* MBEDTLS_X509_CRL_PARSE_C */
   2133          
   2134          /*
   2135           * Check the signature of a certificate by its parent
   2136           */

   \                                 In section .text, align 2, keep-with-next
   2137          static int x509_crt_check_signature(const mbedtls_x509_crt *child,
   2138                                              mbedtls_x509_crt *parent,
   2139                                              mbedtls_x509_crt_restart_ctx *rs_ctx)
   2140          {
   \                     x509_crt_check_signature: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   2141              size_t hash_len;
   2142              unsigned char hash[MBEDTLS_MD_MAX_SIZE];
   2143          #if !defined(MBEDTLS_USE_PSA_CRYPTO)
   2144              const mbedtls_md_info_t *md_info;
   2145              md_info = mbedtls_md_info_from_type(child->sig_md);
   2146              hash_len = mbedtls_md_get_size(md_info);
   2147          
   2148              /* Note: hash errors can happen only after an internal error */
   2149              if (mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash) != 0) {
   2150                  return -1;
   2151              }
   2152          #else
   2153              psa_algorithm_t hash_alg = mbedtls_md_psa_alg_from_type(child->sig_md);
   \        0xC   0xF895 0x0220      LDRB     R0,[R5, #+544]
   \       0x10   0x.... 0x....      BL       mbedtls_md_psa_alg_from_type
   \       0x14   0x4680             MOV      R8,R0
   2154              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x0996      MVNS     R9,#+150
   2155          
   2156              status = psa_hash_compute(hash_alg,
   2157                                        child->tbs.p,
   2158                                        child->tbs.len,
   2159                                        hash,
   2160                                        sizeof(hash),
   2161                                        &hash_len);
   \       0x1A   0xA804             ADD      R0,SP,#+16
   \       0x1C   0x9001             STR      R0,[SP, #+4]
   \       0x1E   0x2020             MOVS     R0,#+32
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0xAB05             ADD      R3,SP,#+20
   \       0x24   0x696A             LDR      R2,[R5, #+20]
   \       0x26   0x69A9             LDR      R1,[R5, #+24]
   \       0x28   0x4640             MOV      R0,R8
   \       0x2A   0x.... 0x....      BL       psa_hash_compute
   \       0x2E   0x0004             MOVS     R4,R0
   2162              if (status != PSA_SUCCESS) {
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD002             BEQ.N    ??x509_crt_check_signature_0
   2163                  return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0x34   0xF07F 0x006F      MVNS     R0,#+111
   \       0x38   0xE01E             B.N      ??x509_crt_check_signature_1
   2164              }
   2165          
   2166          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2167              /* Skip expensive computation on obvious mismatch */
   2168              if (!mbedtls_pk_can_do(&parent->pk, child->sig_pk)) {
   \                     ??x509_crt_check_signature_0: (+1)
   \       0x3A   0xF895 0x1221      LDRB     R1,[R5, #+545]
   \       0x3E   0xF116 0x00CC      ADDS     R0,R6,#+204
   \       0x42   0x.... 0x....      BL       mbedtls_pk_can_do
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD102             BNE.N    ??x509_crt_check_signature_2
   2169                  return -1;
   \       0x4A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x4E   0xE013             B.N      ??x509_crt_check_signature_1
   2170              }
   2171          
   2172          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2173              if (rs_ctx != NULL && child->sig_pk == MBEDTLS_PK_ECDSA) {
   2174                  return mbedtls_pk_verify_restartable(&parent->pk,
   2175                                                       child->sig_md, hash, hash_len,
   2176                                                       child->sig.p, child->sig.len, &rs_ctx->pk);
   2177              }
   2178          #else
   2179              (void) rs_ctx;
   2180          #endif
   2181          
   2182              return mbedtls_pk_verify_ext(child->sig_pk, child->sig_opts, &parent->pk,
   2183                                           child->sig_md, hash, hash_len,
   2184                                           child->sig.p, child->sig.len);
   \                     ??x509_crt_check_signature_2: (+1)
   \       0x50   0xF8D5 0x0218      LDR      R0,[R5, #+536]
   \       0x54   0x9003             STR      R0,[SP, #+12]
   \       0x56   0xF8D5 0x021C      LDR      R0,[R5, #+540]
   \       0x5A   0x9002             STR      R0,[SP, #+8]
   \       0x5C   0x9804             LDR      R0,[SP, #+16]
   \       0x5E   0x9001             STR      R0,[SP, #+4]
   \       0x60   0xA805             ADD      R0,SP,#+20
   \       0x62   0x9000             STR      R0,[SP, #+0]
   \       0x64   0xF895 0x3220      LDRB     R3,[R5, #+544]
   \       0x68   0xF116 0x02CC      ADDS     R2,R6,#+204
   \       0x6C   0xF8D5 0x1224      LDR      R1,[R5, #+548]
   \       0x70   0xF895 0x0221      LDRB     R0,[R5, #+545]
   \       0x74   0x.... 0x....      BL       mbedtls_pk_verify_ext
   \                     ??x509_crt_check_signature_1: (+1)
   \       0x78   0xB00D             ADD      SP,SP,#+52
   \       0x7A   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2185          }
   2186          
   2187          /*
   2188           * Check if 'parent' is a suitable parent (signing CA) for 'child'.
   2189           * Return 0 if yes, -1 if not.
   2190           *
   2191           * top means parent is a locally-trusted certificate
   2192           */

   \                                 In section .text, align 2, keep-with-next
   2193          static int x509_crt_check_parent(const mbedtls_x509_crt *child,
   2194                                           const mbedtls_x509_crt *parent,
   2195                                           int top)
   2196          {
   \                     x509_crt_check_parent: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0015             MOVS     R5,R2
   2197              int need_ca_bit;
   2198          
   2199              /* Parent must be the issuer */
   2200              if (x509_name_cmp(&child->issuer, &parent->subject) != 0) {
   \        0x8   0xF117 0x0170      ADDS     R1,R7,#+112
   \        0xC   0xF116 0x0050      ADDS     R0,R6,#+80
   \       0x10   0x.... 0x....      BL       x509_name_cmp
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??x509_crt_check_parent_0
   2201                  return -1;
   \       0x18   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1C   0xE01C             B.N      ??x509_crt_check_parent_1
   2202              }
   2203          
   2204              /* Parent must have the basicConstraints CA bit set as a general rule */
   2205              need_ca_bit = 1;
   \                     ??x509_crt_check_parent_0: (+1)
   \       0x1E   0x2401             MOVS     R4,#+1
   2206          
   2207              /* Exception: v1/v2 certificates that are locally trusted. */
   2208              if (top && parent->version < 3) {
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD004             BEQ.N    ??x509_crt_check_parent_2
   \       0x24   0x69F8             LDR      R0,[R7, #+28]
   \       0x26   0x2803             CMP      R0,#+3
   \       0x28   0xDA01             BGE.N    ??x509_crt_check_parent_2
   2209                  need_ca_bit = 0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x0004             MOVS     R4,R0
   2210              }
   2211          
   2212              if (need_ca_bit && !parent->ca_istrue) {
   \                     ??x509_crt_check_parent_2: (+1)
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD006             BEQ.N    ??x509_crt_check_parent_3
   \       0x32   0xF8D7 0x01F4      LDR      R0,[R7, #+500]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD102             BNE.N    ??x509_crt_check_parent_3
   2213                  return -1;
   \       0x3A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x3E   0xE00B             B.N      ??x509_crt_check_parent_1
   2214              }
   2215          
   2216              if (need_ca_bit &&
   2217                  mbedtls_x509_crt_check_key_usage(parent, MBEDTLS_X509_KU_KEY_CERT_SIGN) != 0) {
   \                     ??x509_crt_check_parent_3: (+1)
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD008             BEQ.N    ??x509_crt_check_parent_4
   \       0x44   0x2104             MOVS     R1,#+4
   \       0x46   0x0038             MOVS     R0,R7
   \       0x48   0x.... 0x....      BL       mbedtls_x509_crt_check_key_usage
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD002             BEQ.N    ??x509_crt_check_parent_4
   2218                  return -1;
   \       0x50   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x54   0xE000             B.N      ??x509_crt_check_parent_1
   2219              }
   2220          
   2221              return 0;
   \                     ??x509_crt_check_parent_4: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??x509_crt_check_parent_1: (+1)
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}
   2222          }
   2223          
   2224          /*
   2225           * Find a suitable parent for child in candidates, or return NULL.
   2226           *
   2227           * Here suitable is defined as:
   2228           *  1. subject name matches child's issuer
   2229           *  2. if necessary, the CA bit is set and key usage allows signing certs
   2230           *  3. for trusted roots, the signature is correct
   2231           *     (for intermediates, the signature is checked and the result reported)
   2232           *  4. pathlen constraints are satisfied
   2233           *
   2234           * If there's a suitable candidate which is also time-valid, return the first
   2235           * such. Otherwise, return the first suitable candidate (or NULL if there is
   2236           * none).
   2237           *
   2238           * The rationale for this rule is that someone could have a list of trusted
   2239           * roots with two versions on the same root with different validity periods.
   2240           * (At least one user reported having such a list and wanted it to just work.)
   2241           * The reason we don't just require time-validity is that generally there is
   2242           * only one version, and if it's expired we want the flags to state that
   2243           * rather than NOT_TRUSTED, as would be the case if we required it here.
   2244           *
   2245           * The rationale for rule 3 (signature for trusted roots) is that users might
   2246           * have two versions of the same CA with different keys in their list, and the
   2247           * way we select the correct one is by checking the signature (as we don't
   2248           * rely on key identifier extensions). (This is one way users might choose to
   2249           * handle key rollover, another relies on self-issued certs, see [SIRO].)
   2250           *
   2251           * Arguments:
   2252           *  - [in] child: certificate for which we're looking for a parent
   2253           *  - [in] candidates: chained list of potential parents
   2254           *  - [out] r_parent: parent found (or NULL)
   2255           *  - [out] r_signature_is_good: 1 if child signature by parent is valid, or 0
   2256           *  - [in] top: 1 if candidates consists of trusted roots, ie we're at the top
   2257           *         of the chain, 0 otherwise
   2258           *  - [in] path_cnt: number of intermediates seen so far
   2259           *  - [in] self_cnt: number of self-signed intermediates seen so far
   2260           *         (will never be greater than path_cnt)
   2261           *  - [in-out] rs_ctx: context for restarting operations
   2262           *
   2263           * Return value:
   2264           *  - 0 on success
   2265           *  - MBEDTLS_ERR_ECP_IN_PROGRESS otherwise
   2266           */

   \                                 In section .text, align 2, keep-with-next
   2267          static int x509_crt_find_parent_in(
   2268              mbedtls_x509_crt *child,
   2269              mbedtls_x509_crt *candidates,
   2270              mbedtls_x509_crt **r_parent,
   2271              int *r_signature_is_good,
   2272              int top,
   2273              unsigned path_cnt,
   2274              unsigned self_cnt,
   2275              mbedtls_x509_crt_restart_ctx *rs_ctx,
   2276              const mbedtls_x509_time *now)
   2277          {
   \                     x509_crt_find_parent_in: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB082             SUB      SP,SP,#+8
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x9D0E             LDR      R5,[SP, #+56]
   \        0xA   0xF8DD 0x803C      LDR      R8,[SP, #+60]
   \        0xE   0xF8DD 0x9040      LDR      R9,[SP, #+64]
   \       0x12   0xF8DD 0xA044      LDR      R10,[SP, #+68]
   2278              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x16   0xF07F 0x066D      MVNS     R6,#+109
   2279              mbedtls_x509_crt *parent, *fallback_parent;
   2280              int signature_is_good = 0, fallback_signature_is_good;
   \       0x1A   0x2700             MOVS     R7,#+0
   2281          
   2282          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2283              /* did we have something in progress? */
   2284              if (rs_ctx != NULL && rs_ctx->parent != NULL) {
   2285                  /* restore saved state */
   2286                  parent = rs_ctx->parent;
   2287                  fallback_parent = rs_ctx->fallback_parent;
   2288                  fallback_signature_is_good = rs_ctx->fallback_signature_is_good;
   2289          
   2290                  /* clear saved state */
   2291                  rs_ctx->parent = NULL;
   2292                  rs_ctx->fallback_parent = NULL;
   2293                  rs_ctx->fallback_signature_is_good = 0;
   2294          
   2295                  /* resume where we left */
   2296                  goto check_signature;
   2297              }
   2298          #endif
   2299          
   2300              fallback_parent = NULL;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x9001             STR      R0,[SP, #+4]
   2301              fallback_signature_is_good = 0;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x9000             STR      R0,[SP, #+0]
   2302          
   2303              for (parent = candidates; parent != NULL; parent = parent->next) {
   \       0x24   0x9C02             LDR      R4,[SP, #+8]
   \                     ??x509_crt_find_parent_in_0: (+1)
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD029             BEQ.N    ??x509_crt_find_parent_in_1
   2304                  /* basic parenting skills (name, CA bit, key usage) */
   2305                  if (x509_crt_check_parent(child, parent, top) != 0) {
   \       0x2A   0x002A             MOVS     R2,R5
   \       0x2C   0x0021             MOVS     R1,R4
   \       0x2E   0x4658             MOV      R0,R11
   \       0x30   0x.... 0x....      BL       x509_crt_check_parent
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD11F             BNE.N    ??x509_crt_find_parent_in_2
   2306                      continue;
   2307                  }
   2308          
   2309                  /* +1 because stored max_pathlen is 1 higher that the actual value */
   2310                  if (parent->max_pathlen > 0 &&
   2311                      (size_t) parent->max_pathlen < 1 + path_cnt - self_cnt) {
   \                     ??x509_crt_find_parent_in_3: (+1)
   \       0x38   0xF8D4 0x01F8      LDR      R0,[R4, #+504]
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xDB07             BLT.N    ??x509_crt_find_parent_in_4
   \       0x40   0xF8D4 0x11F8      LDR      R1,[R4, #+504]
   \       0x44   0xF118 0x0001      ADDS     R0,R8,#+1
   \       0x48   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0x4C   0x4281             CMP      R1,R0
   \       0x4E   0xD313             BCC.N    ??x509_crt_find_parent_in_2
   2312                      continue;
   2313                  }
   2314          
   2315                  /* Signature */
   2316          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2317          check_signature:
   2318          #endif
   2319                  ret = x509_crt_check_signature(child, parent, rs_ctx);
   \                     ??x509_crt_find_parent_in_4: (+1)
   \       0x50   0x4652             MOV      R2,R10
   \       0x52   0x0021             MOVS     R1,R4
   \       0x54   0x4658             MOV      R0,R11
   \       0x56   0x.... 0x....      BL       x509_crt_check_signature
   \       0x5A   0x0006             MOVS     R6,R0
   2320          
   2321          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2322                  if (rs_ctx != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2323                      /* save state */
   2324                      rs_ctx->parent = parent;
   2325                      rs_ctx->fallback_parent = fallback_parent;
   2326                      rs_ctx->fallback_signature_is_good = fallback_signature_is_good;
   2327          
   2328                      return ret;
   2329                  }
   2330          #else
   2331                  (void) ret;
   2332          #endif
   2333          
   2334                  signature_is_good = ret == 0;
   \       0x5C   0x2E00             CMP      R6,#+0
   \       0x5E   0xD101             BNE.N    ??x509_crt_find_parent_in_5
   \       0x60   0x2701             MOVS     R7,#+1
   \       0x62   0xE000             B.N      ??x509_crt_find_parent_in_6
   \                     ??x509_crt_find_parent_in_5: (+1)
   \       0x64   0x2700             MOVS     R7,#+0
   2335                  if (top && !signature_is_good) {
   \                     ??x509_crt_find_parent_in_6: (+1)
   \       0x66   0x2D00             CMP      R5,#+0
   \       0x68   0xD001             BEQ.N    ??x509_crt_find_parent_in_7
   \       0x6A   0x2F00             CMP      R7,#+0
   \       0x6C   0xD004             BEQ.N    ??x509_crt_find_parent_in_2
   2336                      continue;
   2337                  }
   2338          
   2339          #if defined(MBEDTLS_HAVE_TIME_DATE)
   2340                  /* optional time check */
   2341                  if (mbedtls_x509_time_cmp(&parent->valid_to, now) < 0 ||    /* past */
   2342                      mbedtls_x509_time_cmp(&parent->valid_from, now) > 0) {  /* future */
   2343                      if (fallback_parent == NULL) {
   2344                          fallback_parent = parent;
   2345                          fallback_signature_is_good = signature_is_good;
   2346                      }
   2347          
   2348                      continue;
   2349                  }
   2350          #else
   2351                  ((void) now);
   2352          #endif
   2353          
   2354                  *r_parent = parent;
   \                     ??x509_crt_find_parent_in_7: (+1)
   \       0x6E   0x9803             LDR      R0,[SP, #+12]
   \       0x70   0x6004             STR      R4,[R0, #+0]
   2355                  *r_signature_is_good = signature_is_good;
   \       0x72   0x9804             LDR      R0,[SP, #+16]
   \       0x74   0x6007             STR      R7,[R0, #+0]
   2356          
   2357                  break;
   \       0x76   0xE002             B.N      ??x509_crt_find_parent_in_1
   2358              }
   \                     ??x509_crt_find_parent_in_2: (+1)
   \       0x78   0xF8D4 0x4228      LDR      R4,[R4, #+552]
   \       0x7C   0xE7D3             B.N      ??x509_crt_find_parent_in_0
   2359          
   2360              if (parent == NULL) {
   \                     ??x509_crt_find_parent_in_1: (+1)
   \       0x7E   0x2C00             CMP      R4,#+0
   \       0x80   0xD105             BNE.N    ??x509_crt_find_parent_in_8
   2361                  *r_parent = fallback_parent;
   \       0x82   0x9901             LDR      R1,[SP, #+4]
   \       0x84   0x9803             LDR      R0,[SP, #+12]
   \       0x86   0x6001             STR      R1,[R0, #+0]
   2362                  *r_signature_is_good = fallback_signature_is_good;
   \       0x88   0x9900             LDR      R1,[SP, #+0]
   \       0x8A   0x9804             LDR      R0,[SP, #+16]
   \       0x8C   0x6001             STR      R1,[R0, #+0]
   2363              }
   2364          
   2365              return 0;
   \                     ??x509_crt_find_parent_in_8: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xB005             ADD      SP,SP,#+20
   \       0x92   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2366          }
   2367          
   2368          /*
   2369           * Find a parent in trusted CAs or the provided chain, or return NULL.
   2370           *
   2371           * Searches in trusted CAs first, and return the first suitable parent found
   2372           * (see find_parent_in() for definition of suitable).
   2373           *
   2374           * Arguments:
   2375           *  - [in] child: certificate for which we're looking for a parent, followed
   2376           *         by a chain of possible intermediates
   2377           *  - [in] trust_ca: list of locally trusted certificates
   2378           *  - [out] parent: parent found (or NULL)
   2379           *  - [out] parent_is_trusted: 1 if returned `parent` is trusted, or 0
   2380           *  - [out] signature_is_good: 1 if child signature by parent is valid, or 0
   2381           *  - [in] path_cnt: number of links in the chain so far (EE -> ... -> child)
   2382           *  - [in] self_cnt: number of self-signed certs in the chain so far
   2383           *         (will always be no greater than path_cnt)
   2384           *  - [in-out] rs_ctx: context for restarting operations
   2385           *
   2386           * Return value:
   2387           *  - 0 on success
   2388           *  - MBEDTLS_ERR_ECP_IN_PROGRESS otherwise
   2389           */

   \                                 In section .text, align 2, keep-with-next
   2390          static int x509_crt_find_parent(
   2391              mbedtls_x509_crt *child,
   2392              mbedtls_x509_crt *trust_ca,
   2393              mbedtls_x509_crt **parent,
   2394              int *parent_is_trusted,
   2395              int *signature_is_good,
   2396              unsigned path_cnt,
   2397              unsigned self_cnt,
   2398              mbedtls_x509_crt_restart_ctx *rs_ctx,
   2399              const mbedtls_x509_time *now)
   2400          {
   \                     x509_crt_find_parent: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0xF8DD 0x8038      LDR      R8,[SP, #+56]
   2401              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x096D      MVNS     R9,#+109
   2402              mbedtls_x509_crt *search_list;
   2403          
   2404              *parent_is_trusted = 1;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x6038             STR      R0,[R7, #+0]
   2405          
   2406          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2407              /* restore then clear saved state if we have some stored */
   2408              if (rs_ctx != NULL && rs_ctx->parent_is_trusted != -1) {
   2409                  *parent_is_trusted = rs_ctx->parent_is_trusted;
   2410                  rs_ctx->parent_is_trusted = -1;
   2411              }
   2412          #endif
   2413          
   2414              while (1) {
   2415                  search_list = *parent_is_trusted ? trust_ca : child->next;
   \                     ??x509_crt_find_parent_0: (+1)
   \       0x1A   0x6838             LDR      R0,[R7, #+0]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD001             BEQ.N    ??x509_crt_find_parent_1
   \       0x20   0x002C             MOVS     R4,R5
   \       0x22   0xE001             B.N      ??x509_crt_find_parent_2
   \                     ??x509_crt_find_parent_1: (+1)
   \       0x24   0xF8DA 0x4228      LDR      R4,[R10, #+552]
   2416          
   2417                  ret = x509_crt_find_parent_in(child, search_list,
   2418                                                parent, signature_is_good,
   2419                                                *parent_is_trusted,
   2420                                                path_cnt, self_cnt, rs_ctx, now);
   \                     ??x509_crt_find_parent_2: (+1)
   \       0x28   0x9812             LDR      R0,[SP, #+72]
   \       0x2A   0x9004             STR      R0,[SP, #+16]
   \       0x2C   0x9811             LDR      R0,[SP, #+68]
   \       0x2E   0x9003             STR      R0,[SP, #+12]
   \       0x30   0x9810             LDR      R0,[SP, #+64]
   \       0x32   0x9002             STR      R0,[SP, #+8]
   \       0x34   0x980F             LDR      R0,[SP, #+60]
   \       0x36   0x9001             STR      R0,[SP, #+4]
   \       0x38   0x6838             LDR      R0,[R7, #+0]
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0x4643             MOV      R3,R8
   \       0x3E   0x0032             MOVS     R2,R6
   \       0x40   0x0021             MOVS     R1,R4
   \       0x42   0x4650             MOV      R0,R10
   \       0x44   0x.... 0x....      BL       x509_crt_find_parent_in
   \       0x48   0x4681             MOV      R9,R0
   2421          
   2422          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2423                  if (rs_ctx != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2424                      /* save state */
   2425                      rs_ctx->parent_is_trusted = *parent_is_trusted;
   2426                      return ret;
   2427                  }
   2428          #else
   2429                  (void) ret;
   2430          #endif
   2431          
   2432                  /* stop here if found or already in second iteration */
   2433                  if (*parent != NULL || *parent_is_trusted == 0) {
   \       0x4A   0x6830             LDR      R0,[R6, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD102             BNE.N    ??x509_crt_find_parent_3
   \       0x50   0x6838             LDR      R0,[R7, #+0]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD103             BNE.N    ??x509_crt_find_parent_4
   2434                      break;
   2435                  }
   2436          
   2437                  /* prepare second iteration */
   2438                  *parent_is_trusted = 0;
   2439              }
   2440          
   2441              /* extra precaution against mistakes in the caller */
   2442              if (*parent == NULL) {
   \                     ??x509_crt_find_parent_3: (+1)
   \       0x56   0x6830             LDR      R0,[R6, #+0]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD108             BNE.N    ??x509_crt_find_parent_5
   \       0x5C   0xE002             B.N      ??x509_crt_find_parent_6
   \                     ??x509_crt_find_parent_4: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x6038             STR      R0,[R7, #+0]
   \       0x62   0xE7DA             B.N      ??x509_crt_find_parent_0
   2443                  *parent_is_trusted = 0;
   \                     ??x509_crt_find_parent_6: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x6038             STR      R0,[R7, #+0]
   2444                  *signature_is_good = 0;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xF8C8 0x0000      STR      R0,[R8, #+0]
   2445              }
   2446          
   2447              return 0;
   \                     ??x509_crt_find_parent_5: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xB006             ADD      SP,SP,#+24
   \       0x72   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2448          }
   2449          
   2450          /*
   2451           * Check if an end-entity certificate is locally trusted
   2452           *
   2453           * Currently we require such certificates to be self-signed (actually only
   2454           * check for self-issued as self-signatures are not checked)
   2455           */

   \                                 In section .text, align 2, keep-with-next
   2456          static int x509_crt_check_ee_locally_trusted(
   2457              mbedtls_x509_crt *crt,
   2458              mbedtls_x509_crt *trust_ca)
   2459          {
   \                     x509_crt_check_ee_locally_trusted: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   2460              mbedtls_x509_crt *cur;
   2461          
   2462              /* must be self-issued */
   2463              if (x509_name_cmp(&crt->issuer, &crt->subject) != 0) {
   \        0x6   0xF115 0x0170      ADDS     R1,R5,#+112
   \        0xA   0xF115 0x0050      ADDS     R0,R5,#+80
   \        0xE   0x.... 0x....      BL       x509_name_cmp
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD002             BEQ.N    ??x509_crt_check_ee_locally_trusted_0
   2464                  return -1;
   \       0x16   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1A   0xE014             B.N      ??x509_crt_check_ee_locally_trusted_1
   2465              }
   2466          
   2467              /* look for an exact match with trusted cert */
   2468              for (cur = trust_ca; cur != NULL; cur = cur->next) {
   \                     ??x509_crt_check_ee_locally_trusted_0: (+1)
   \       0x1C   0x0034             MOVS     R4,R6
   \                     ??x509_crt_check_ee_locally_trusted_2: (+1)
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD00F             BEQ.N    ??x509_crt_check_ee_locally_trusted_3
   2469                  if (crt->raw.len == cur->raw.len &&
   2470                      memcmp(crt->raw.p, cur->raw.p, crt->raw.len) == 0) {
   \       0x22   0x68A9             LDR      R1,[R5, #+8]
   \       0x24   0x68A0             LDR      R0,[R4, #+8]
   \       0x26   0x4281             CMP      R1,R0
   \       0x28   0xD108             BNE.N    ??x509_crt_check_ee_locally_trusted_4
   \       0x2A   0x68AA             LDR      R2,[R5, #+8]
   \       0x2C   0x68E1             LDR      R1,[R4, #+12]
   \       0x2E   0x68E8             LDR      R0,[R5, #+12]
   \       0x30   0x.... 0x....      BL       memcmp
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD101             BNE.N    ??x509_crt_check_ee_locally_trusted_4
   2471                      return 0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE004             B.N      ??x509_crt_check_ee_locally_trusted_1
   2472                  }
   2473              }
   \                     ??x509_crt_check_ee_locally_trusted_4: (+1)
   \       0x3C   0xF8D4 0x4228      LDR      R4,[R4, #+552]
   \       0x40   0xE7ED             B.N      ??x509_crt_check_ee_locally_trusted_2
   2474          
   2475              /* too bad */
   2476              return -1;
   \                     ??x509_crt_check_ee_locally_trusted_3: (+1)
   \       0x42   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_crt_check_ee_locally_trusted_1: (+1)
   \       0x46   0xBD70             POP      {R4-R6,PC}
   2477          }
   2478          
   2479          /*
   2480           * Build and verify a certificate chain
   2481           *
   2482           * Given a peer-provided list of certificates EE, C1, ..., Cn and
   2483           * a list of trusted certs R1, ... Rp, try to build and verify a chain
   2484           *      EE, Ci1, ... Ciq [, Rj]
   2485           * such that every cert in the chain is a child of the next one,
   2486           * jumping to a trusted root as early as possible.
   2487           *
   2488           * Verify that chain and return it with flags for all issues found.
   2489           *
   2490           * Special cases:
   2491           * - EE == Rj -> return a one-element list containing it
   2492           * - EE, Ci1, ..., Ciq cannot be continued with a trusted root
   2493           *   -> return that chain with NOT_TRUSTED set on Ciq
   2494           *
   2495           * Tests for (aspects of) this function should include at least:
   2496           * - trusted EE
   2497           * - EE -> trusted root
   2498           * - EE -> intermediate CA -> trusted root
   2499           * - if relevant: EE untrusted
   2500           * - if relevant: EE -> intermediate, untrusted
   2501           * with the aspect under test checked at each relevant level (EE, int, root).
   2502           * For some aspects longer chains are required, but usually length 2 is
   2503           * enough (but length 1 is not in general).
   2504           *
   2505           * Arguments:
   2506           *  - [in] crt: the cert list EE, C1, ..., Cn
   2507           *  - [in] trust_ca: the trusted list R1, ..., Rp
   2508           *  - [in] ca_crl, profile: as in verify_with_profile()
   2509           *  - [out] ver_chain: the built and verified chain
   2510           *      Only valid when return value is 0, may contain garbage otherwise!
   2511           *      Restart note: need not be the same when calling again to resume.
   2512           *  - [in-out] rs_ctx: context for restarting operations
   2513           *
   2514           * Return value:
   2515           *  - non-zero if the chain could not be fully built and examined
   2516           *  - 0 is the chain was successfully built and examined,
   2517           *      even if it was found to be invalid
   2518           */

   \                                 In section .text, align 2, keep-with-next
   2519          static int x509_crt_verify_chain(
   2520              mbedtls_x509_crt *crt,
   2521              mbedtls_x509_crt *trust_ca,
   2522              mbedtls_x509_crl *ca_crl,
   2523              mbedtls_x509_crt_ca_cb_t f_ca_cb,
   2524              void *p_ca_cb,
   2525              const mbedtls_x509_crt_profile *profile,
   2526              mbedtls_x509_crt_verify_chain *ver_chain,
   2527              mbedtls_x509_crt_restart_ctx *rs_ctx)
   2528          {
   \                     x509_crt_verify_chain: (+1)
   \        0x0   0xE92D 0x4FFD      PUSH     {R0,R2-R11,LR}
   \        0x4   0xB090             SUB      SP,SP,#+64
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x9E1D             LDR      R6,[SP, #+116]
   \        0xA   0x9F1E             LDR      R7,[SP, #+120]
   2529              /* Don't initialize any of those variables here, so that the compiler can
   2530               * catch potential issues with jumping ahead when restarting */
   2531              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x006D      MVNS     R0,#+109
   \       0x10   0x9009             STR      R0,[SP, #+36]
   2532              uint32_t *flags;
   2533              mbedtls_x509_crt_verify_chain_item *cur;
   2534              mbedtls_x509_crt *child;
   2535              mbedtls_x509_crt *parent;
   2536              int parent_is_trusted;
   2537              int child_is_trusted;
   2538              int signature_is_good;
   2539              unsigned self_cnt;
   2540              mbedtls_x509_crt *cur_trust_ca = NULL;
   \       0x12   0xF05F 0x0800      MOVS     R8,#+0
   2541              mbedtls_x509_time now;
   2542          
   2543          #if defined(MBEDTLS_HAVE_TIME_DATE)
   2544              if (mbedtls_x509_time_gmtime(mbedtls_time(NULL), &now) != 0) {
   2545                  return MBEDTLS_ERR_X509_FATAL_ERROR;
   2546              }
   2547          #endif
   2548          
   2549          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2550              /* resume if we had an operation in progress */
   2551              if (rs_ctx != NULL && rs_ctx->in_progress == x509_crt_rs_find_parent) {
   2552                  /* restore saved state */
   2553                  *ver_chain = rs_ctx->ver_chain; /* struct copy */
   2554                  self_cnt = rs_ctx->self_cnt;
   2555          
   2556                  /* restore derived state */
   2557                  cur = &ver_chain->items[ver_chain->len - 1];
   2558                  child = cur->crt;
   2559                  flags = &cur->flags;
   2560          
   2561                  goto find_parent;
   2562              }
   2563          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   2564          
   2565              child = crt;
   \       0x16   0xF8DD 0xB040      LDR      R11,[SP, #+64]
   2566              self_cnt = 0;
   \       0x1A   0xF05F 0x0900      MOVS     R9,#+0
   2567              parent_is_trusted = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x9006             STR      R0,[SP, #+24]
   2568              child_is_trusted = 0;
   \       0x22   0x2400             MOVS     R4,#+0
   2569          
   2570              while (1) {
   2571                  /* Add certificate to the verification chain */
   2572                  cur = &ver_chain->items[ver_chain->len];
   \                     ??x509_crt_verify_chain_0: (+1)
   \       0x24   0x6D38             LDR      R0,[R7, #+80]
   \       0x26   0xEB07 0x00C0      ADD      R0,R7,R0, LSL #+3
   \       0x2A   0x9007             STR      R0,[SP, #+28]
   2573                  cur->crt = child;
   \       0x2C   0x9807             LDR      R0,[SP, #+28]
   \       0x2E   0xF8C0 0xB000      STR      R11,[R0, #+0]
   2574                  cur->flags = 0;
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x9807             LDR      R0,[SP, #+28]
   \       0x36   0x6041             STR      R1,[R0, #+4]
   2575                  ver_chain->len++;
   \       0x38   0x6D38             LDR      R0,[R7, #+80]
   \       0x3A   0x1C40             ADDS     R0,R0,#+1
   \       0x3C   0x6538             STR      R0,[R7, #+80]
   2576                  flags = &cur->flags;
   \       0x3E   0x9807             LDR      R0,[SP, #+28]
   \       0x40   0x1D00             ADDS     R0,R0,#+4
   \       0x42   0x4682             MOV      R10,R0
   2577          
   2578          #if defined(MBEDTLS_HAVE_TIME_DATE)
   2579                  /* Check time-validity (all certificates) */
   2580                  if (mbedtls_x509_time_cmp(&child->valid_to, &now) < 0) {
   2581                      *flags |= MBEDTLS_X509_BADCERT_EXPIRED;
   2582                  }
   2583          
   2584                  if (mbedtls_x509_time_cmp(&child->valid_from, &now) > 0) {
   2585                      *flags |= MBEDTLS_X509_BADCERT_FUTURE;
   2586                  }
   2587          #endif
   2588          
   2589                  /* Stop here for trusted roots (but not for trusted EE certs) */
   2590                  if (child_is_trusted) {
   \       0x44   0x2C00             CMP      R4,#+0
   \       0x46   0xD001             BEQ.N    ??x509_crt_verify_chain_1
   2591                      return 0;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xE085             B.N      ??x509_crt_verify_chain_2
   2592                  }
   2593          
   2594                  /* Check signature algorithm: MD & PK algs */
   2595                  if (x509_profile_check_md_alg(profile, child->sig_md) != 0) {
   \                     ??x509_crt_verify_chain_1: (+1)
   \       0x4C   0xF89B 0x1220      LDRB     R1,[R11, #+544]
   \       0x50   0x0030             MOVS     R0,R6
   \       0x52   0x.... 0x....      BL       x509_profile_check_md_alg
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD005             BEQ.N    ??x509_crt_verify_chain_3
   2596                      *flags |= MBEDTLS_X509_BADCERT_BAD_MD;
   \       0x5A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x5E   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \       0x62   0xF8CA 0x0000      STR      R0,[R10, #+0]
   2597                  }
   2598          
   2599                  if (x509_profile_check_pk_alg(profile, child->sig_pk) != 0) {
   \                     ??x509_crt_verify_chain_3: (+1)
   \       0x66   0xF89B 0x1221      LDRB     R1,[R11, #+545]
   \       0x6A   0x0030             MOVS     R0,R6
   \       0x6C   0x.... 0x....      BL       x509_profile_check_pk_alg
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD005             BEQ.N    ??x509_crt_verify_chain_4
   2600                      *flags |= MBEDTLS_X509_BADCERT_BAD_PK;
   \       0x74   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x78   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x7C   0xF8CA 0x0000      STR      R0,[R10, #+0]
   2601                  }
   2602          
   2603                  /* Special case: EE certs that are locally trusted */
   2604                  if (ver_chain->len == 1 &&
   2605                      x509_crt_check_ee_locally_trusted(child, trust_ca) == 0) {
   \                     ??x509_crt_verify_chain_4: (+1)
   \       0x80   0x6D38             LDR      R0,[R7, #+80]
   \       0x82   0x2801             CMP      R0,#+1
   \       0x84   0xD107             BNE.N    ??x509_crt_verify_chain_5
   \       0x86   0x0029             MOVS     R1,R5
   \       0x88   0x4658             MOV      R0,R11
   \       0x8A   0x.... 0x....      BL       x509_crt_check_ee_locally_trusted
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD101             BNE.N    ??x509_crt_verify_chain_5
   2606                      return 0;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xE060             B.N      ??x509_crt_verify_chain_2
   2607                  }
   2608          
   2609          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2610          find_parent:
   2611          #endif
   2612          
   2613                  /* Obtain list of potential trusted signers from CA callback,
   2614                   * or use statically provided list. */
   2615          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
   2616                  if (f_ca_cb != NULL) {
   2617                      mbedtls_x509_crt_free(ver_chain->trust_ca_cb_result);
   2618                      mbedtls_free(ver_chain->trust_ca_cb_result);
   2619                      ver_chain->trust_ca_cb_result = NULL;
   2620          
   2621                      ret = f_ca_cb(p_ca_cb, child, &ver_chain->trust_ca_cb_result);
   2622                      if (ret != 0) {
   2623                          return MBEDTLS_ERR_X509_FATAL_ERROR;
   2624                      }
   2625          
   2626                      cur_trust_ca = ver_chain->trust_ca_cb_result;
   2627                  } else
   2628          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
   2629                  {
   2630                      ((void) f_ca_cb);
   2631                      ((void) p_ca_cb);
   2632                      cur_trust_ca = trust_ca;
   \                     ??x509_crt_verify_chain_5: (+1)
   \       0x96   0x46A8             MOV      R8,R5
   2633                  }
   2634          
   2635                  /* Look for a parent in trusted CAs or up the chain */
   2636                  ret = x509_crt_find_parent(child, cur_trust_ca, &parent,
   2637                                             &parent_is_trusted, &signature_is_good,
   2638                                             ver_chain->len - 1, self_cnt, rs_ctx,
   2639                                             &now);
   \       0x98   0xA80A             ADD      R0,SP,#+40
   \       0x9A   0x9004             STR      R0,[SP, #+16]
   \       0x9C   0x981F             LDR      R0,[SP, #+124]
   \       0x9E   0x9003             STR      R0,[SP, #+12]
   \       0xA0   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0xA4   0x6D38             LDR      R0,[R7, #+80]
   \       0xA6   0x1E40             SUBS     R0,R0,#+1
   \       0xA8   0x9001             STR      R0,[SP, #+4]
   \       0xAA   0xA808             ADD      R0,SP,#+32
   \       0xAC   0x9000             STR      R0,[SP, #+0]
   \       0xAE   0xAB06             ADD      R3,SP,#+24
   \       0xB0   0xAA05             ADD      R2,SP,#+20
   \       0xB2   0x4641             MOV      R1,R8
   \       0xB4   0x4658             MOV      R0,R11
   \       0xB6   0x.... 0x....      BL       x509_crt_find_parent
   \       0xBA   0x9009             STR      R0,[SP, #+36]
   2640          
   2641          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2642                  if (rs_ctx != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2643                      /* save state */
   2644                      rs_ctx->in_progress = x509_crt_rs_find_parent;
   2645                      rs_ctx->self_cnt = self_cnt;
   2646                      rs_ctx->ver_chain = *ver_chain; /* struct copy */
   2647          
   2648                      return ret;
   2649                  }
   2650          #else
   2651                  (void) ret;
   2652          #endif
   2653          
   2654                  /* No parent? We're done here */
   2655                  if (parent == NULL) {
   \       0xBC   0x9805             LDR      R0,[SP, #+20]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD107             BNE.N    ??x509_crt_verify_chain_6
   2656                      *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
   \       0xC2   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xC6   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xCA   0xF8CA 0x0000      STR      R0,[R10, #+0]
   2657                      return 0;
   \       0xCE   0x2000             MOVS     R0,#+0
   \       0xD0   0xE042             B.N      ??x509_crt_verify_chain_2
   2658                  }
   2659          
   2660                  /* Count intermediate self-issued (not necessarily self-signed) certs.
   2661                   * These can occur with some strategies for key rollover, see [SIRO],
   2662                   * and should be excluded from max_pathlen checks. */
   2663                  if (ver_chain->len != 1 &&
   2664                      x509_name_cmp(&child->issuer, &child->subject) == 0) {
   \                     ??x509_crt_verify_chain_6: (+1)
   \       0xD2   0x6D38             LDR      R0,[R7, #+80]
   \       0xD4   0x2801             CMP      R0,#+1
   \       0xD6   0xD009             BEQ.N    ??x509_crt_verify_chain_7
   \       0xD8   0xF11B 0x0170      ADDS     R1,R11,#+112
   \       0xDC   0xF11B 0x0050      ADDS     R0,R11,#+80
   \       0xE0   0x.... 0x....      BL       x509_name_cmp
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD101             BNE.N    ??x509_crt_verify_chain_7
   2665                      self_cnt++;
   \       0xE8   0xF119 0x0901      ADDS     R9,R9,#+1
   2666                  }
   2667          
   2668                  /* path_cnt is 0 for the first intermediate CA,
   2669                   * and if parent is trusted it's not an intermediate CA */
   2670                  if (!parent_is_trusted &&
   2671                      ver_chain->len > MBEDTLS_X509_MAX_INTERMEDIATE_CA) {
   \                     ??x509_crt_verify_chain_7: (+1)
   \       0xEC   0x9806             LDR      R0,[SP, #+24]
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD105             BNE.N    ??x509_crt_verify_chain_8
   \       0xF2   0x6D38             LDR      R0,[R7, #+80]
   \       0xF4   0x2809             CMP      R0,#+9
   \       0xF6   0xD302             BCC.N    ??x509_crt_verify_chain_8
   2672                      /* return immediately to avoid overflow the chain array */
   2673                      return MBEDTLS_ERR_X509_FATAL_ERROR;
   \       0xF8   0x.... 0x....      LDR.W    R0,??DataTable24_5
   \       0xFC   0xE02C             B.N      ??x509_crt_verify_chain_2
   2674                  }
   2675          
   2676                  /* signature was checked while searching parent */
   2677                  if (!signature_is_good) {
   \                     ??x509_crt_verify_chain_8: (+1)
   \       0xFE   0x9808             LDR      R0,[SP, #+32]
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD105             BNE.N    ??x509_crt_verify_chain_9
   2678                      *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
   \      0x104   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x108   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x10C   0xF8CA 0x0000      STR      R0,[R10, #+0]
   2679                  }
   2680          
   2681                  /* check size of signing key */
   2682                  if (x509_profile_check_key(profile, &parent->pk) != 0) {
   \                     ??x509_crt_verify_chain_9: (+1)
   \      0x110   0x9805             LDR      R0,[SP, #+20]
   \      0x112   0xF110 0x01CC      ADDS     R1,R0,#+204
   \      0x116   0x0030             MOVS     R0,R6
   \      0x118   0x.... 0x....      BL       x509_profile_check_key
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD005             BEQ.N    ??x509_crt_verify_chain_10
   2683                      *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
   \      0x120   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x124   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \      0x128   0xF8CA 0x0000      STR      R0,[R10, #+0]
   2684                  }
   2685          
   2686          #if defined(MBEDTLS_X509_CRL_PARSE_C)
   2687                  /* Check trusted CA's CRL for the given crt */
   2688                  *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile, &now);
   \                     ??x509_crt_verify_chain_10: (+1)
   \      0x12C   0xA80A             ADD      R0,SP,#+40
   \      0x12E   0x9000             STR      R0,[SP, #+0]
   \      0x130   0x0033             MOVS     R3,R6
   \      0x132   0x9A11             LDR      R2,[SP, #+68]
   \      0x134   0x9905             LDR      R1,[SP, #+20]
   \      0x136   0x4658             MOV      R0,R11
   \      0x138   0x.... 0x....      BL       x509_crt_verifycrl
   \      0x13C   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \      0x140   0x4308             ORRS     R0,R0,R1
   \      0x142   0xF8CA 0x0000      STR      R0,[R10, #+0]
   2689          #else
   2690                  (void) ca_crl;
   2691          #endif
   2692          
   2693                  /* prepare for next iteration */
   2694                  child = parent;
   \      0x146   0x9805             LDR      R0,[SP, #+20]
   \      0x148   0x4683             MOV      R11,R0
   2695                  parent = NULL;
   \      0x14A   0x2000             MOVS     R0,#+0
   \      0x14C   0x9005             STR      R0,[SP, #+20]
   2696                  child_is_trusted = parent_is_trusted;
   \      0x14E   0x9806             LDR      R0,[SP, #+24]
   \      0x150   0x0004             MOVS     R4,R0
   2697                  signature_is_good = 0;
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0x9008             STR      R0,[SP, #+32]
   \      0x156   0xE765             B.N      ??x509_crt_verify_chain_0
   2698              }
   \                     ??x509_crt_verify_chain_2: (+1)
   \      0x158   0xB013             ADD      SP,SP,#+76
   \      0x15A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2699          }
   2700          
   2701          #ifdef _WIN32
   2702          #ifdef _MSC_VER
   2703          #pragma comment(lib, "ws2_32.lib")
   2704          #include <winsock2.h>
   2705          #include <ws2tcpip.h>
   2706          #elif (defined(__MINGW32__) || defined(__MINGW64__)) && _WIN32_WINNT >= 0x0600
   2707          #include <winsock2.h>
   2708          #include <ws2tcpip.h>
   2709          #else
   2710          /* inet_pton() is not supported, fallback to software version */
   2711          #define MBEDTLS_TEST_SW_INET_PTON
   2712          #endif
   2713          #elif defined(__sun)
   2714          /* Solaris requires -lsocket -lnsl for inet_pton() */
   2715          #elif defined(__has_include)
   2716          #if __has_include(<sys/socket.h>)
   2717          #include <sys/socket.h>
   2718          #endif
   2719          #if __has_include(<arpa/inet.h>)
   2720          #include <arpa/inet.h>
   2721          #endif
   2722          #endif
   2723          
   2724          /* Use whether or not AF_INET6 is defined to indicate whether or not to use
   2725           * the platform inet_pton() or a local implementation (below).  The local
   2726           * implementation may be used even in cases where the platform provides
   2727           * inet_pton(), e.g. when there are different includes required and/or the
   2728           * platform implementation requires dependencies on additional libraries.
   2729           * Specifically, Windows requires custom includes and additional link
   2730           * dependencies, and Solaris requires additional link dependencies.
   2731           * Also, as a coarse heuristic, use the local implementation if the compiler
   2732           * does not support __has_include(), or if the definition of AF_INET6 is not
   2733           * provided by headers included (or not) via __has_include() above.
   2734           * MBEDTLS_TEST_SW_INET_PTON is a bypass define to force testing of this code //no-check-names
   2735           * despite having a platform that has inet_pton. */
   2736          #if !defined(AF_INET6) || defined(MBEDTLS_TEST_SW_INET_PTON) //no-check-names
   2737          /* Definition located further below to possibly reduce compiler inlining */
   2738          static int x509_inet_pton_ipv4(const char *src, void *dst);
   2739          
   2740          #define li_cton(c, n) \
   2741              (((n) = (c) - '0') <= 9 || (((n) = ((c)&0xdf) - 'A') <= 5 ? ((n) += 10) : 0))
   2742          

   \                                 In section .text, align 2, keep-with-next
   2743          static int x509_inet_pton_ipv6(const char *src, void *dst)
   2744          {
   \                     x509_inet_pton_ipv6: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x4689             MOV      R9,R1
   2745              const unsigned char *p = (const unsigned char *) src;
   \        0x8   0x9F06             LDR      R7,[SP, #+24]
   2746              int nonzero_groups = 0, num_digits, zero_group_start = -1;
   \        0xA   0x2600             MOVS     R6,#+0
   \        0xC   0xF05F 0x34FF      MOVS     R4,#+4294967295
   2747              uint16_t addr[8];
   2748              do {
   2749                  /* note: allows excess leading 0's, e.g. 1:0002:3:... */
   2750                  uint16_t group = num_digits = 0;
   \                     ??x509_inet_pton_ipv6_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x0005             MOVS     R5,R0
   \       0x14   0x46A8             MOV      R8,R5
   2751                  for (uint8_t digit; num_digits < 4; num_digits++) {
   \                     ??x509_inet_pton_ipv6_1: (+1)
   \       0x16   0x2D04             CMP      R5,#+4
   \       0x18   0xDA25             BGE.N    ??x509_inet_pton_ipv6_2
   2752                      if (li_cton(*p, digit) == 0) {
   \       0x1A   0x7838             LDRB     R0,[R7, #+0]
   \       0x1C   0x3830             SUBS     R0,R0,#+48
   \       0x1E   0x0001             MOVS     R1,R0
   \       0x20   0x0008             MOVS     R0,R1
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x280A             CMP      R0,#+10
   \       0x26   0xDB0F             BLT.N    ??x509_inet_pton_ipv6_3
   \       0x28   0x7838             LDRB     R0,[R7, #+0]
   \       0x2A   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \       0x2E   0xF1B0 0x0141      SUBS     R1,R0,#+65
   \       0x32   0x0008             MOVS     R0,R1
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x2806             CMP      R0,#+6
   \       0x38   0xDA03             BGE.N    ??x509_inet_pton_ipv6_4
   \       0x3A   0x310A             ADDS     R1,R1,#+10
   \       0x3C   0x0008             MOVS     R0,R1
   \       0x3E   0xB2C0             UXTB     R0,R0
   \       0x40   0xE000             B.N      ??x509_inet_pton_ipv6_5
   \                     ??x509_inet_pton_ipv6_4: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \                     ??x509_inet_pton_ipv6_5: (+1)
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD001             BEQ.N    ??x509_inet_pton_ipv6_6
   \                     ??x509_inet_pton_ipv6_3: (+1)
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xE000             B.N      ??x509_inet_pton_ipv6_7
   \                     ??x509_inet_pton_ipv6_6: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??x509_inet_pton_ipv6_7: (+1)
   \       0x4E   0xB2C0             UXTB     R0,R0
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD008             BEQ.N    ??x509_inet_pton_ipv6_2
   2753                          break;
   2754                      }
   2755                      group = (group << 4) | digit;
   \                     ??x509_inet_pton_ipv6_8: (+1)
   \       0x54   0x4640             MOV      R0,R8
   \       0x56   0x4688             MOV      R8,R1
   \       0x58   0xFA5F 0xF888      UXTB     R8,R8
   \       0x5C   0xEA58 0x1800      ORRS     R8,R8,R0, LSL #+4
   2756                      p++;
   \       0x60   0x1C7F             ADDS     R7,R7,#+1
   2757                  }
   \       0x62   0x1C6D             ADDS     R5,R5,#+1
   \       0x64   0xE7D7             B.N      ??x509_inet_pton_ipv6_1
   2758                  if (num_digits != 0) {
   \                     ??x509_inet_pton_ipv6_2: (+1)
   \       0x66   0x2D00             CMP      R5,#+0
   \       0x68   0xD048             BEQ.N    ??x509_inet_pton_ipv6_9
   2759                      MBEDTLS_PUT_UINT16_BE(group, addr, nonzero_groups);
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable24_6
   \       0x6E   0x7800             LDRB     R0,[R0, #+0]
   \       0x70   0x2801             CMP      R0,#+1
   \       0x72   0xD107             BNE.N    ??x509_inet_pton_ipv6_10
   \       0x74   0x4641             MOV      R1,R8
   \       0x76   0xB289             UXTH     R1,R1
   \       0x78   0xA802             ADD      R0,SP,#+8
   \       0x7A   0xEB00 0x0046      ADD      R0,R0,R6, LSL #+1
   \       0x7E   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x82   0xE00A             B.N      ??x509_inet_pton_ipv6_11
   \                     ??x509_inet_pton_ipv6_10: (+1)
   \       0x84   0x4640             MOV      R0,R8
   \       0x86   0xB280             UXTH     R0,R0
   \       0x88   0x.... 0x....      BL       mbedtls_bswap16
   \       0x8C   0x0001             MOVS     R1,R0
   \       0x8E   0xB289             UXTH     R1,R1
   \       0x90   0xA802             ADD      R0,SP,#+8
   \       0x92   0xEB00 0x0046      ADD      R0,R0,R6, LSL #+1
   \       0x96   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   2760                      nonzero_groups++;
   \                     ??x509_inet_pton_ipv6_11: (+1)
   \       0x9A   0x1C76             ADDS     R6,R6,#+1
   2761                      if (*p == '\0') {
   \       0x9C   0x7838             LDRB     R0,[R7, #+0]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD048             BEQ.N    ??x509_inet_pton_ipv6_12
   2762                          break;
   2763                      } else if (*p == '.') {
   \                     ??x509_inet_pton_ipv6_13: (+1)
   \       0xA2   0x7838             LDRB     R0,[R7, #+0]
   \       0xA4   0x282E             CMP      R0,#+46
   \       0xA6   0xD123             BNE.N    ??x509_inet_pton_ipv6_14
   2764                          /* Don't accept IPv4 too early or late */
   2765                          if ((nonzero_groups == 0 && zero_group_start == -1) ||
   2766                              nonzero_groups >= 7) {
   \       0xA8   0x2E00             CMP      R6,#+0
   \       0xAA   0xD102             BNE.N    ??x509_inet_pton_ipv6_15
   \       0xAC   0xF114 0x0F01      CMN      R4,#+1
   \       0xB0   0xD001             BEQ.N    ??x509_inet_pton_ipv6_16
   \                     ??x509_inet_pton_ipv6_15: (+1)
   \       0xB2   0x2E07             CMP      R6,#+7
   \       0xB4   0xDB00             BLT.N    ??x509_inet_pton_ipv6_17
   2767                              break;
   \                     ??x509_inet_pton_ipv6_16: (+1)
   \       0xB6   0xE03D             B.N      ??x509_inet_pton_ipv6_12
   2768                          }
   2769          
   2770                          /* Walk back to prior ':', then parse as IPv4-mapped */
   2771                          int steps = 4;
   \                     ??x509_inet_pton_ipv6_17: (+1)
   \       0xB8   0xF05F 0x0A04      MOVS     R10,#+4
   2772                          do {
   2773                              p--;
   \                     ??x509_inet_pton_ipv6_18: (+1)
   \       0xBC   0x1E7F             SUBS     R7,R7,#+1
   2774                              steps--;
   \       0xBE   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   2775                          } while (*p != ':' && steps > 0);
   \       0xC2   0x7838             LDRB     R0,[R7, #+0]
   \       0xC4   0x283A             CMP      R0,#+58
   \       0xC6   0xD002             BEQ.N    ??x509_inet_pton_ipv6_19
   \       0xC8   0xF1BA 0x0F01      CMP      R10,#+1
   \       0xCC   0xDAF6             BGE.N    ??x509_inet_pton_ipv6_18
   2776          
   2777                          if (*p != ':') {
   \                     ??x509_inet_pton_ipv6_19: (+1)
   \       0xCE   0x7838             LDRB     R0,[R7, #+0]
   \       0xD0   0x283A             CMP      R0,#+58
   \       0xD2   0xD12F             BNE.N    ??x509_inet_pton_ipv6_12
   2778                              break;
   2779                          }
   2780                          p++;
   \                     ??x509_inet_pton_ipv6_20: (+1)
   \       0xD4   0x1C7F             ADDS     R7,R7,#+1
   2781                          nonzero_groups--;
   \       0xD6   0x1E76             SUBS     R6,R6,#+1
   2782                          if (x509_inet_pton_ipv4((const char *) p,
   2783                                                  addr + nonzero_groups) != 0) {
   \       0xD8   0xA802             ADD      R0,SP,#+8
   \       0xDA   0xEB00 0x0146      ADD      R1,R0,R6, LSL #+1
   \       0xDE   0x0038             MOVS     R0,R7
   \       0xE0   0x.... 0x....      BL       x509_inet_pton_ipv4
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD125             BNE.N    ??x509_inet_pton_ipv6_12
   2784                              break;
   2785                          }
   2786          
   2787                          nonzero_groups += 2;
   \                     ??x509_inet_pton_ipv6_21: (+1)
   \       0xE8   0x1CB6             ADDS     R6,R6,#+2
   2788                          p = (const unsigned char *) "";
   \       0xEA   0x....             ADR.N    R0,??DataTable21_5
   \       0xEC   0x0007             MOVS     R7,R0
   2789                          break;
   \       0xEE   0xE021             B.N      ??x509_inet_pton_ipv6_12
   2790                      } else if (*p != ':') {
   \                     ??x509_inet_pton_ipv6_14: (+1)
   \       0xF0   0x7838             LDRB     R0,[R7, #+0]
   \       0xF2   0x283A             CMP      R0,#+58
   \       0xF4   0xD01A             BEQ.N    ??x509_inet_pton_ipv6_22
   2791                          return -1;
   \       0xF6   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0xFA   0xE060             B.N      ??x509_inet_pton_ipv6_23
   2792                      }
   2793                  } else {
   2794                      /* Don't accept a second zero group or an invalid delimiter */
   2795                      if (zero_group_start != -1 || *p != ':') {
   \                     ??x509_inet_pton_ipv6_9: (+1)
   \       0xFC   0xF114 0x0F01      CMN      R4,#+1
   \      0x100   0xD102             BNE.N    ??x509_inet_pton_ipv6_24
   \      0x102   0x7838             LDRB     R0,[R7, #+0]
   \      0x104   0x283A             CMP      R0,#+58
   \      0x106   0xD002             BEQ.N    ??x509_inet_pton_ipv6_25
   2796                          return -1;
   \                     ??x509_inet_pton_ipv6_24: (+1)
   \      0x108   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x10C   0xE057             B.N      ??x509_inet_pton_ipv6_23
   2797                      }
   2798                      zero_group_start = nonzero_groups;
   \                     ??x509_inet_pton_ipv6_25: (+1)
   \      0x10E   0x0034             MOVS     R4,R6
   2799          
   2800                      /* Accept a zero group at start, but it has to be a double colon */
   2801                      if (zero_group_start == 0 && *++p != ':') {
   \      0x110   0x2C00             CMP      R4,#+0
   \      0x112   0xD106             BNE.N    ??x509_inet_pton_ipv6_26
   \      0x114   0x1C7F             ADDS     R7,R7,#+1
   \      0x116   0x7838             LDRB     R0,[R7, #+0]
   \      0x118   0x283A             CMP      R0,#+58
   \      0x11A   0xD002             BEQ.N    ??x509_inet_pton_ipv6_26
   2802                          return -1;
   \      0x11C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x120   0xE04D             B.N      ??x509_inet_pton_ipv6_23
   2803                      }
   2804          
   2805                      if (p[1] == '\0') {
   \                     ??x509_inet_pton_ipv6_26: (+1)
   \      0x122   0x7878             LDRB     R0,[R7, #+1]
   \      0x124   0x2800             CMP      R0,#+0
   \      0x126   0xD101             BNE.N    ??x509_inet_pton_ipv6_22
   2806                          ++p;
   \      0x128   0x1C7F             ADDS     R7,R7,#+1
   2807                          break;
   \      0x12A   0xE003             B.N      ??x509_inet_pton_ipv6_12
   2808                      }
   2809                  }
   2810                  ++p;
   \                     ??x509_inet_pton_ipv6_22: (+1)
   \      0x12C   0x1C7F             ADDS     R7,R7,#+1
   2811              } while (nonzero_groups < 8);
   \      0x12E   0x2E08             CMP      R6,#+8
   \      0x130   0xF6FF 0xAF6E      BLT.W    ??x509_inet_pton_ipv6_0
   2812          
   2813              if (*p != '\0') {
   \                     ??x509_inet_pton_ipv6_12: (+1)
   \      0x134   0x7838             LDRB     R0,[R7, #+0]
   \      0x136   0x2800             CMP      R0,#+0
   \      0x138   0xD002             BEQ.N    ??x509_inet_pton_ipv6_27
   2814                  return -1;
   \      0x13A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x13E   0xE03E             B.N      ??x509_inet_pton_ipv6_23
   2815              }
   2816          
   2817              if (zero_group_start != -1) {
   \                     ??x509_inet_pton_ipv6_27: (+1)
   \      0x140   0xF114 0x0F01      CMN      R4,#+1
   \      0x144   0xD02B             BEQ.N    ??x509_inet_pton_ipv6_28
   2818                  if (nonzero_groups > 6) {
   \      0x146   0x2E07             CMP      R6,#+7
   \      0x148   0xDB02             BLT.N    ??x509_inet_pton_ipv6_29
   2819                      return -1;
   \      0x14A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x14E   0xE036             B.N      ??x509_inet_pton_ipv6_23
   2820                  }
   2821                  int zero_groups = 8 - nonzero_groups;
   \                     ??x509_inet_pton_ipv6_29: (+1)
   \      0x150   0xF1D6 0x0008      RSBS     R0,R6,#+8
   \      0x154   0x9000             STR      R0,[SP, #+0]
   2822                  int groups_after_zero = nonzero_groups - zero_group_start;
   \      0x156   0xEBB6 0x0804      SUBS     R8,R6,R4
   2823          
   2824                  /* Move the non-zero part to after the zeroes */
   2825                  if (groups_after_zero) {
   \      0x15A   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x15E   0xD010             BEQ.N    ??x509_inet_pton_ipv6_30
   2826                      memmove(addr + zero_group_start + zero_groups,
   2827                              addr + zero_group_start,
   2828                              groups_after_zero * sizeof(*addr));
   \      0x160   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \      0x164   0x9001             STR      R0,[SP, #+4]
   \      0x166   0xA802             ADD      R0,SP,#+8
   \      0x168   0xEB00 0x0B44      ADD      R11,R0,R4, LSL #+1
   \      0x16C   0xA802             ADD      R0,SP,#+8
   \      0x16E   0xEB00 0x0144      ADD      R1,R0,R4, LSL #+1
   \      0x172   0x9800             LDR      R0,[SP, #+0]
   \      0x174   0xEB01 0x0A40      ADD      R10,R1,R0, LSL #+1
   \      0x178   0x9A01             LDR      R2,[SP, #+4]
   \      0x17A   0x4659             MOV      R1,R11
   \      0x17C   0x4650             MOV      R0,R10
   \      0x17E   0x.... 0x....      BL       __aeabi_memmove
   2829                  }
   2830                  memset(addr + zero_group_start, 0, zero_groups * sizeof(*addr));
   \                     ??x509_inet_pton_ipv6_30: (+1)
   \      0x182   0x9800             LDR      R0,[SP, #+0]
   \      0x184   0x0040             LSLS     R0,R0,#+1
   \      0x186   0x9001             STR      R0,[SP, #+4]
   \      0x188   0xF05F 0x0B00      MOVS     R11,#+0
   \      0x18C   0xA802             ADD      R0,SP,#+8
   \      0x18E   0xEB00 0x0A44      ADD      R10,R0,R4, LSL #+1
   \      0x192   0x465A             MOV      R2,R11
   \      0x194   0x9901             LDR      R1,[SP, #+4]
   \      0x196   0x4650             MOV      R0,R10
   \      0x198   0x.... 0x....      BL       __aeabi_memset
   2831              } else {
   \      0x19C   0xE004             B.N      ??x509_inet_pton_ipv6_31
   2832                  if (nonzero_groups != 8) {
   \                     ??x509_inet_pton_ipv6_28: (+1)
   \      0x19E   0x2E08             CMP      R6,#+8
   \      0x1A0   0xD002             BEQ.N    ??x509_inet_pton_ipv6_31
   2833                      return -1;
   \      0x1A2   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x1A6   0xE00A             B.N      ??x509_inet_pton_ipv6_23
   2834                  }
   2835              }
   2836              memcpy(dst, addr, sizeof(addr));
   \                     ??x509_inet_pton_ipv6_31: (+1)
   \      0x1A8   0xF05F 0x0810      MOVS     R8,#+16
   \      0x1AC   0xF10D 0x0B08      ADD      R11,SP,#+8
   \      0x1B0   0x46CA             MOV      R10,R9
   \      0x1B2   0x4642             MOV      R2,R8
   \      0x1B4   0x4659             MOV      R1,R11
   \      0x1B6   0x4650             MOV      R0,R10
   \      0x1B8   0x.... 0x....      BL       __aeabi_memcpy
   2837              return 0;
   \      0x1BC   0x2000             MOVS     R0,#+0
   \                     ??x509_inet_pton_ipv6_23: (+1)
   \      0x1BE   0xB007             ADD      SP,SP,#+28
   \      0x1C0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2838          }
   2839          

   \                                 In section .text, align 2, keep-with-next
   2840          static int x509_inet_pton_ipv4(const char *src, void *dst)
   2841          {
   \                     x509_inet_pton_ipv4: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0004             MOVS     R4,R0
   2842              const unsigned char *p = (const unsigned char *) src;
   \        0x4   0x46A4             MOV      R12,R4
   2843              uint8_t *res = (uint8_t *) dst;
   \        0x6   0x000D             MOVS     R5,R1
   2844              uint8_t digit, num_digits = 0;
   \        0x8   0x2600             MOVS     R6,#+0
   2845              uint8_t num_octets = 0;
   \        0xA   0x2700             MOVS     R7,#+0
   2846              uint16_t octet;
   2847          
   2848              do {
   2849                  octet = num_digits = 0;
   \                     ??x509_inet_pton_ipv4_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x0006             MOVS     R6,R0
   \       0x10   0x0030             MOVS     R0,R6
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0x0003             MOVS     R3,R0
   2850                  do {
   2851                      digit = *p - '0';
   \                     ??x509_inet_pton_ipv4_1: (+1)
   \       0x16   0xF89C 0x0000      LDRB     R0,[R12, #+0]
   \       0x1A   0x3830             SUBS     R0,R0,#+48
   \       0x1C   0x0002             MOVS     R2,R0
   2852                      if (digit > 9) {
   \       0x1E   0x0010             MOVS     R0,R2
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x280A             CMP      R0,#+10
   \       0x24   0xDA16             BGE.N    ??x509_inet_pton_ipv4_2
   2853                          break;
   2854                      }
   2855          
   2856                      /* Don't allow leading zeroes. These might mean octal format,
   2857                       * which this implementation does not support. */
   2858                      if (octet == 0 && num_digits > 0) {
   \                     ??x509_inet_pton_ipv4_3: (+1)
   \       0x26   0x0018             MOVS     R0,R3
   \       0x28   0xB280             UXTH     R0,R0
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD106             BNE.N    ??x509_inet_pton_ipv4_4
   \       0x2E   0x0030             MOVS     R0,R6
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD002             BEQ.N    ??x509_inet_pton_ipv4_4
   2859                          return -1;
   \       0x36   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x3A   0xE033             B.N      ??x509_inet_pton_ipv4_5
   2860                      }
   2861          
   2862                      octet = octet * 10 + digit;
   \                     ??x509_inet_pton_ipv4_4: (+1)
   \       0x3C   0xB29B             UXTH     R3,R3
   \       0x3E   0x200A             MOVS     R0,#+10
   \       0x40   0x4343             MULS     R3,R0,R3
   \       0x42   0xFA53 0xF382      UXTAB    R3,R3,R2
   2863                      num_digits++;
   \       0x46   0x1C76             ADDS     R6,R6,#+1
   2864                      p++;
   \       0x48   0xF11C 0x0C01      ADDS     R12,R12,#+1
   2865                  } while (num_digits < 3);
   \       0x4C   0x0030             MOVS     R0,R6
   \       0x4E   0xB2C0             UXTB     R0,R0
   \       0x50   0x2803             CMP      R0,#+3
   \       0x52   0xDBE0             BLT.N    ??x509_inet_pton_ipv4_1
   2866          
   2867                  if (octet >= 256 || num_digits > 3 || num_digits == 0) {
   \                     ??x509_inet_pton_ipv4_2: (+1)
   \       0x54   0x0018             MOVS     R0,R3
   \       0x56   0xB280             UXTH     R0,R0
   \       0x58   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x5C   0xDA07             BGE.N    ??x509_inet_pton_ipv4_6
   \       0x5E   0x0030             MOVS     R0,R6
   \       0x60   0xB2C0             UXTB     R0,R0
   \       0x62   0x2804             CMP      R0,#+4
   \       0x64   0xDA03             BGE.N    ??x509_inet_pton_ipv4_6
   \       0x66   0x0030             MOVS     R0,R6
   \       0x68   0xB2C0             UXTB     R0,R0
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD102             BNE.N    ??x509_inet_pton_ipv4_7
   2868                      return -1;
   \                     ??x509_inet_pton_ipv4_6: (+1)
   \       0x6E   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x72   0xE017             B.N      ??x509_inet_pton_ipv4_5
   2869                  }
   2870                  *res++ = (uint8_t) octet;
   \                     ??x509_inet_pton_ipv4_7: (+1)
   \       0x74   0x702B             STRB     R3,[R5, #+0]
   \       0x76   0x1C6D             ADDS     R5,R5,#+1
   2871                  num_octets++;
   \       0x78   0x1C7F             ADDS     R7,R7,#+1
   2872              } while (num_octets < 4 && *p++ == '.');
   \       0x7A   0x0038             MOVS     R0,R7
   \       0x7C   0xB2C0             UXTB     R0,R0
   \       0x7E   0x2804             CMP      R0,#+4
   \       0x80   0xDA05             BGE.N    ??x509_inet_pton_ipv4_8
   \       0x82   0x4660             MOV      R0,R12
   \       0x84   0xF110 0x0C01      ADDS     R12,R0,#+1
   \       0x88   0x7800             LDRB     R0,[R0, #+0]
   \       0x8A   0x282E             CMP      R0,#+46
   \       0x8C   0xD0BE             BEQ.N    ??x509_inet_pton_ipv4_0
   2873              return num_octets == 4 && *p == '\0' ? 0 : -1;
   \                     ??x509_inet_pton_ipv4_8: (+1)
   \       0x8E   0xB2FF             UXTB     R7,R7
   \       0x90   0x2F04             CMP      R7,#+4
   \       0x92   0xD105             BNE.N    ??x509_inet_pton_ipv4_9
   \       0x94   0xF89C 0x0000      LDRB     R0,[R12, #+0]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD101             BNE.N    ??x509_inet_pton_ipv4_9
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0xE001             B.N      ??x509_inet_pton_ipv4_10
   \                     ??x509_inet_pton_ipv4_9: (+1)
   \       0xA0   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_inet_pton_ipv4_10: (+1)
   \                     ??x509_inet_pton_ipv4_5: (+1)
   \       0xA4   0xBCF0             POP      {R4-R7}
   \       0xA6   0x4770             BX       LR
   2874          }
   2875          
   2876          #else
   2877          
   2878          static int x509_inet_pton_ipv6(const char *src, void *dst)
   2879          {
   2880              return inet_pton(AF_INET6, src, dst) == 1 ? 0 : -1;
   2881          }
   2882          
   2883          static int x509_inet_pton_ipv4(const char *src, void *dst)
   2884          {
   2885              return inet_pton(AF_INET, src, dst) == 1 ? 0 : -1;
   2886          }
   2887          
   2888          #endif /* !AF_INET6 || MBEDTLS_TEST_SW_INET_PTON */ //no-check-names
   2889          

   \                                 In section .text, align 2, keep-with-next
   2890          size_t mbedtls_x509_crt_parse_cn_inet_pton(const char *cn, void *dst)
   2891          {
   \                     mbedtls_x509_crt_parse_cn_inet_pton: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   2892              return strchr(cn, ':') == NULL
   2893                      ? x509_inet_pton_ipv4(cn, dst) == 0 ? 4 : 0
   2894                      : x509_inet_pton_ipv6(cn, dst) == 0 ? 16 : 0;
   \        0x6   0x213A             MOVS     R1,#+58
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       strchr
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD109             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_0
   \       0x12   0x0021             MOVS     R1,R4
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0x.... 0x....      BL       x509_inet_pton_ipv4
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD101             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_1
   \       0x1E   0x2004             MOVS     R0,#+4
   \       0x20   0xE00A             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_2
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_1: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xE008             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_2
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_0: (+1)
   \       0x26   0x0021             MOVS     R1,R4
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0x.... 0x....      BL       x509_inet_pton_ipv6
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD101             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_3
   \       0x32   0x2010             MOVS     R0,#+16
   \       0x34   0xE000             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_2
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_3: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_2: (+1)
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
   2895          }
   2896          
   2897          /*
   2898           * Check for CN match
   2899           */

   \                                 In section .text, align 2, keep-with-next
   2900          static int x509_crt_check_cn(const mbedtls_x509_buf *name,
   2901                                       const char *cn, size_t cn_len)
   2902          {
   \                     x509_crt_check_cn: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   2903              /* try exact match */
   2904              if (name->len == cn_len &&
   2905                  x509_memcasecmp(cn, name->p, cn_len) == 0) {
   \        0x8   0x6860             LDR      R0,[R4, #+4]
   \        0xA   0x42B0             CMP      R0,R6
   \        0xC   0xD108             BNE.N    ??x509_crt_check_cn_0
   \        0xE   0x0032             MOVS     R2,R6
   \       0x10   0x68A1             LDR      R1,[R4, #+8]
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       x509_memcasecmp
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??x509_crt_check_cn_0
   2906                  return 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xE009             B.N      ??x509_crt_check_cn_1
   2907              }
   2908          
   2909              /* try wildcard match */
   2910              if (x509_check_wildcard(cn, name) == 0) {
   \                     ??x509_crt_check_cn_0: (+1)
   \       0x20   0x0021             MOVS     R1,R4
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       x509_check_wildcard
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD101             BNE.N    ??x509_crt_check_cn_2
   2911                  return 0;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xE001             B.N      ??x509_crt_check_cn_1
   2912              }
   2913          
   2914              return -1;
   \                     ??x509_crt_check_cn_2: (+1)
   \       0x30   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_crt_check_cn_1: (+1)
   \       0x34   0xBD70             POP      {R4-R6,PC}
   2915          }
   2916          

   \                                 In section .text, align 2, keep-with-next
   2917          static int x509_crt_check_san_ip(const mbedtls_x509_sequence *san,
   2918                                           const char *cn, size_t cn_len)
   2919          {
   \                     x509_crt_check_san_ip: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0014             MOVS     R4,R2
   2920              uint32_t ip[4];
   2921              cn_len = mbedtls_x509_crt_parse_cn_inet_pton(cn, ip);
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0x.... 0x....      BL       mbedtls_x509_crt_parse_cn_inet_pton
   \       0x12   0x0005             MOVS     R5,R0
   2922              if (cn_len == 0) {
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD102             BNE.N    ??x509_crt_check_san_ip_0
   2923                  return -1;
   \       0x18   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1C   0xE01A             B.N      ??x509_crt_check_san_ip_1
   2924              }
   2925          
   2926              for (const mbedtls_x509_sequence *cur = san; cur != NULL; cur = cur->next) {
   \                     ??x509_crt_check_san_ip_0: (+1)
   \       0x1E   0x0034             MOVS     R4,R6
   \                     ??x509_crt_check_san_ip_2: (+1)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD015             BEQ.N    ??x509_crt_check_san_ip_3
   2927                  const unsigned char san_type = (unsigned char) cur->buf.tag &
   2928                                                 MBEDTLS_ASN1_TAG_VALUE_MASK;
   \       0x24   0xF894 0x8000      LDRB     R8,[R4, #+0]
   \       0x28   0xF018 0x081F      ANDS     R8,R8,#0x1F
   2929                  if (san_type == MBEDTLS_X509_SAN_IP_ADDRESS &&
   2930                      cur->buf.len == cn_len && memcmp(cur->buf.p, ip, cn_len) == 0) {
   \       0x2C   0x4640             MOV      R0,R8
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2807             CMP      R0,#+7
   \       0x32   0xD10B             BNE.N    ??x509_crt_check_san_ip_4
   \       0x34   0x6860             LDR      R0,[R4, #+4]
   \       0x36   0x42A8             CMP      R0,R5
   \       0x38   0xD108             BNE.N    ??x509_crt_check_san_ip_4
   \       0x3A   0x002A             MOVS     R2,R5
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x68A0             LDR      R0,[R4, #+8]
   \       0x40   0x.... 0x....      BL       memcmp
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD101             BNE.N    ??x509_crt_check_san_ip_4
   2931                      return 0;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xE003             B.N      ??x509_crt_check_san_ip_1
   2932                  }
   2933              }
   \                     ??x509_crt_check_san_ip_4: (+1)
   \       0x4C   0x68E4             LDR      R4,[R4, #+12]
   \       0x4E   0xE7E7             B.N      ??x509_crt_check_san_ip_2
   2934          
   2935              return -1;
   \                     ??x509_crt_check_san_ip_3: (+1)
   \       0x50   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_crt_check_san_ip_1: (+1)
   \       0x54   0xB004             ADD      SP,SP,#+16
   \       0x56   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2936          }
   2937          

   \                                 In section .text, align 2, keep-with-next
   2938          static int x509_crt_check_san_uri(const mbedtls_x509_sequence *san,
   2939                                            const char *cn, size_t cn_len)
   2940          {
   \                     x509_crt_check_san_uri: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   2941              for (const mbedtls_x509_sequence *cur = san; cur != NULL; cur = cur->next) {
   \        0xA   0x002C             MOVS     R4,R5
   \                     ??x509_crt_check_san_uri_0: (+1)
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD015             BEQ.N    ??x509_crt_check_san_uri_1
   2942                  const unsigned char san_type = (unsigned char) cur->buf.tag &
   2943                                                 MBEDTLS_ASN1_TAG_VALUE_MASK;
   \       0x10   0xF894 0x8000      LDRB     R8,[R4, #+0]
   \       0x14   0xF018 0x081F      ANDS     R8,R8,#0x1F
   2944                  if (san_type == MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER &&
   2945                      cur->buf.len == cn_len && memcmp(cur->buf.p, cn, cn_len) == 0) {
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2806             CMP      R0,#+6
   \       0x1E   0xD10B             BNE.N    ??x509_crt_check_san_uri_2
   \       0x20   0x6860             LDR      R0,[R4, #+4]
   \       0x22   0x42B8             CMP      R0,R7
   \       0x24   0xD108             BNE.N    ??x509_crt_check_san_uri_2
   \       0x26   0x003A             MOVS     R2,R7
   \       0x28   0x0031             MOVS     R1,R6
   \       0x2A   0x68A0             LDR      R0,[R4, #+8]
   \       0x2C   0x.... 0x....      BL       memcmp
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD101             BNE.N    ??x509_crt_check_san_uri_2
   2946                      return 0;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xE003             B.N      ??x509_crt_check_san_uri_3
   2947                  }
   2948              }
   \                     ??x509_crt_check_san_uri_2: (+1)
   \       0x38   0x68E4             LDR      R4,[R4, #+12]
   \       0x3A   0xE7E7             B.N      ??x509_crt_check_san_uri_0
   2949          
   2950              return -1;
   \                     ??x509_crt_check_san_uri_1: (+1)
   \       0x3C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_crt_check_san_uri_3: (+1)
   \       0x40   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2951          }
   2952          
   2953          /*
   2954           * Check for SAN match, see RFC 5280 Section 4.2.1.6
   2955           */

   \                                 In section .text, align 2, keep-with-next
   2956          static int x509_crt_check_san(const mbedtls_x509_sequence *san,
   2957                                        const char *cn, size_t cn_len)
   2958          {
   \                     x509_crt_check_san: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4691             MOV      R9,R2
   2959              int san_ip = 0;
   \        0xA   0x2500             MOVS     R5,#+0
   2960              int san_uri = 0;
   \        0xC   0x2600             MOVS     R6,#+0
   2961              /* Prioritize DNS name over other subtypes due to popularity */
   2962              for (const mbedtls_x509_sequence *cur = san; cur != NULL; cur = cur->next) {
   \        0xE   0x003C             MOVS     R4,R7
   \                     ??x509_crt_check_san_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD01C             BEQ.N    ??x509_crt_check_san_1
   2963                  switch ((unsigned char) cur->buf.tag & MBEDTLS_ASN1_TAG_VALUE_MASK) {
   \       0x14   0x7820             LDRB     R0,[R4, #+0]
   \       0x16   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2802             CMP      R0,#+2
   \       0x1E   0xD004             BEQ.N    ??x509_crt_check_san_2
   \       0x20   0x2806             CMP      R0,#+6
   \       0x22   0xD00F             BEQ.N    ??x509_crt_check_san_3
   \       0x24   0x2807             CMP      R0,#+7
   \       0x26   0xD00A             BEQ.N    ??x509_crt_check_san_4
   \       0x28   0xE00F             B.N      ??x509_crt_check_san_5
   2964                      case MBEDTLS_X509_SAN_DNS_NAME:
   2965                          if (x509_crt_check_cn(&cur->buf, cn, cn_len) == 0) {
   \                     ??x509_crt_check_san_2: (+1)
   \       0x2A   0x464A             MOV      R2,R9
   \       0x2C   0x4641             MOV      R1,R8
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       x509_crt_check_cn
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD101             BNE.N    ??x509_crt_check_san_6
   2966                              return 0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE020             B.N      ??x509_crt_check_san_7
   2967                          }
   2968                          break;
   \                     ??x509_crt_check_san_6: (+1)
   \       0x3C   0xE005             B.N      ??x509_crt_check_san_8
   2969                      case MBEDTLS_X509_SAN_IP_ADDRESS:
   2970                          san_ip = 1;
   \                     ??x509_crt_check_san_4: (+1)
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x0005             MOVS     R5,R0
   2971                          break;
   \       0x42   0xE002             B.N      ??x509_crt_check_san_8
   2972                      case MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER:
   2973                          san_uri = 1;
   \                     ??x509_crt_check_san_3: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x0006             MOVS     R6,R0
   2974                          break;
   \       0x48   0xE7FF             B.N      ??x509_crt_check_san_8
   2975                      /* (We may handle other types here later.) */
   2976                      default: /* Unrecognized type */
   2977                          break;
   2978                  }
   2979              }
   \                     ??x509_crt_check_san_5: (+1)
   \                     ??x509_crt_check_san_8: (+1)
   \       0x4A   0x68E4             LDR      R4,[R4, #+12]
   \       0x4C   0xE7E0             B.N      ??x509_crt_check_san_0
   2980              if (san_ip) {
   \                     ??x509_crt_check_san_1: (+1)
   \       0x4E   0x2D00             CMP      R5,#+0
   \       0x50   0xD008             BEQ.N    ??x509_crt_check_san_9
   2981                  if (x509_crt_check_san_ip(san, cn, cn_len) == 0) {
   \       0x52   0x464A             MOV      R2,R9
   \       0x54   0x4641             MOV      R1,R8
   \       0x56   0x0038             MOVS     R0,R7
   \       0x58   0x.... 0x....      BL       x509_crt_check_san_ip
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD101             BNE.N    ??x509_crt_check_san_9
   2982                      return 0;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xE00C             B.N      ??x509_crt_check_san_7
   2983                  }
   2984              }
   2985              if (san_uri) {
   \                     ??x509_crt_check_san_9: (+1)
   \       0x64   0x2E00             CMP      R6,#+0
   \       0x66   0xD008             BEQ.N    ??x509_crt_check_san_10
   2986                  if (x509_crt_check_san_uri(san, cn, cn_len) == 0) {
   \       0x68   0x464A             MOV      R2,R9
   \       0x6A   0x4641             MOV      R1,R8
   \       0x6C   0x0038             MOVS     R0,R7
   \       0x6E   0x.... 0x....      BL       x509_crt_check_san_uri
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD101             BNE.N    ??x509_crt_check_san_10
   2987                      return 0;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xE001             B.N      ??x509_crt_check_san_7
   2988                  }
   2989              }
   2990          
   2991              return -1;
   \                     ??x509_crt_check_san_10: (+1)
   \       0x7A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??x509_crt_check_san_7: (+1)
   \       0x7E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2992          }
   2993          
   2994          /*
   2995           * Verify the requested CN - only call this if cn is not NULL!
   2996           */

   \                                 In section .text, align 2, keep-with-next
   2997          static void x509_crt_verify_name(const mbedtls_x509_crt *crt,
   2998                                           const char *cn,
   2999                                           uint32_t *flags)
   3000          {
   \                     x509_crt_verify_name: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   3001              const mbedtls_x509_name *name;
   3002              size_t cn_len = strlen(cn);
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x.... 0x....      BL       strlen
   \       0x10   0x4680             MOV      R8,R0
   3003          
   3004              if (crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME) {
   \       0x12   0xF895 0x01F0      LDRB     R0,[R5, #+496]
   \       0x16   0x0680             LSLS     R0,R0,#+26
   \       0x18   0xD508             BPL.N    ??x509_crt_verify_name_0
   3005                  if (x509_crt_check_san(&crt->subject_alt_names, cn, cn_len) == 0) {
   \       0x1A   0x4642             MOV      R2,R8
   \       0x1C   0x0031             MOVS     R1,R6
   \       0x1E   0xF515 0x70C8      ADDS     R0,R5,#+400
   \       0x22   0x.... 0x....      BL       x509_crt_check_san
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD11F             BNE.N    ??x509_crt_verify_name_1
   3006                      return;
   \       0x2A   0xE022             B.N      ??x509_crt_verify_name_2
   3007                  }
   3008              } else {
   3009                  for (name = &crt->subject; name != NULL; name = name->next) {
   \                     ??x509_crt_verify_name_0: (+1)
   \       0x2C   0xF115 0x0070      ADDS     R0,R5,#+112
   \       0x30   0x0004             MOVS     R4,R0
   \                     ??x509_crt_verify_name_3: (+1)
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD019             BEQ.N    ??x509_crt_verify_name_1
   3010                      if (MBEDTLS_OID_CMP(MBEDTLS_OID_AT_CN, &name->oid) == 0 &&
   3011                          x509_crt_check_cn(&name->val, cn, cn_len) == 0) {
   \       0x36   0x6860             LDR      R0,[R4, #+4]
   \       0x38   0x2803             CMP      R0,#+3
   \       0x3A   0xD106             BNE.N    ??x509_crt_verify_name_4
   \       0x3C   0x6862             LDR      R2,[R4, #+4]
   \       0x3E   0x68A1             LDR      R1,[R4, #+8]
   \       0x40   0x....             ADR.N    R0,??DataTable24_4
   \       0x42   0x.... 0x....      BL       memcmp
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD001             BEQ.N    ??x509_crt_verify_name_5
   \                     ??x509_crt_verify_name_4: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xE000             B.N      ??x509_crt_verify_name_6
   \                     ??x509_crt_verify_name_5: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??x509_crt_verify_name_6: (+1)
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD107             BNE.N    ??x509_crt_verify_name_7
   \       0x56   0x4642             MOV      R2,R8
   \       0x58   0x0031             MOVS     R1,R6
   \       0x5A   0xF114 0x000C      ADDS     R0,R4,#+12
   \       0x5E   0x.... 0x....      BL       x509_crt_check_cn
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD005             BEQ.N    ??x509_crt_verify_name_2
   3012                          return;
   3013                      }
   3014                  }
   \                     ??x509_crt_verify_name_7: (+1)
   \       0x66   0x69A4             LDR      R4,[R4, #+24]
   \       0x68   0xE7E3             B.N      ??x509_crt_verify_name_3
   3015          
   3016              }
   3017          
   3018              *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
   \                     ??x509_crt_verify_name_1: (+1)
   \       0x6A   0x6838             LDR      R0,[R7, #+0]
   \       0x6C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x70   0x6038             STR      R0,[R7, #+0]
   3019          }
   \                     ??x509_crt_verify_name_2: (+1)
   \       0x72   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3020          
   3021          /*
   3022           * Merge the flags for all certs in the chain, after calling callback
   3023           */

   \                                 In section .text, align 2, keep-with-next
   3024          static int x509_crt_merge_flags_with_cb(
   3025              uint32_t *flags,
   3026              const mbedtls_x509_crt_verify_chain *ver_chain,
   3027              int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3028              void *p_vrfy)
   3029          {
   \                     x509_crt_merge_flags_with_cb: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   3030              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x096D      MVNS     R9,#+109
   3031              unsigned i;
   3032              uint32_t cur_flags;
   3033              const mbedtls_x509_crt_verify_chain_item *cur;
   3034          
   3035              for (i = ver_chain->len; i != 0; --i) {
   \       0x10   0x6D34             LDR      R4,[R6, #+80]
   \                     ??x509_crt_merge_flags_with_cb_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD01A             BEQ.N    ??x509_crt_merge_flags_with_cb_1
   3036                  cur = &ver_chain->items[i-1];
   \       0x16   0xEB06 0x00C4      ADD      R0,R6,R4, LSL #+3
   \       0x1A   0x3808             SUBS     R0,R0,#+8
   \       0x1C   0x4682             MOV      R10,R0
   3037                  cur_flags = cur->flags;
   \       0x1E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x22   0x9000             STR      R0,[SP, #+0]
   3038          
   3039                  if (NULL != f_vrfy) {
   \       0x24   0x0038             MOVS     R0,R7
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD00A             BEQ.N    ??x509_crt_merge_flags_with_cb_2
   3040                      if ((ret = f_vrfy(p_vrfy, cur->crt, (int) i-1, &cur_flags)) != 0) {
   \       0x2A   0x466B             MOV      R3,SP
   \       0x2C   0x1E62             SUBS     R2,R4,#+1
   \       0x2E   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \       0x32   0x4640             MOV      R0,R8
   \       0x34   0x47B8             BLX      R7
   \       0x36   0x4681             MOV      R9,R0
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??x509_crt_merge_flags_with_cb_2
   3041                          return ret;
   \       0x3C   0x4648             MOV      R0,R9
   \       0x3E   0xE006             B.N      ??x509_crt_merge_flags_with_cb_3
   3042                      }
   3043                  }
   3044          
   3045                  *flags |= cur_flags;
   \                     ??x509_crt_merge_flags_with_cb_2: (+1)
   \       0x40   0x6829             LDR      R1,[R5, #+0]
   \       0x42   0x9800             LDR      R0,[SP, #+0]
   \       0x44   0x4301             ORRS     R1,R0,R1
   \       0x46   0x6029             STR      R1,[R5, #+0]
   3046              }
   \       0x48   0x1E64             SUBS     R4,R4,#+1
   \       0x4A   0xE7E2             B.N      ??x509_crt_merge_flags_with_cb_0
   3047          
   3048              return 0;
   \                     ??x509_crt_merge_flags_with_cb_1: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??x509_crt_merge_flags_with_cb_3: (+1)
   \       0x4E   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   3049          }
   3050          
   3051          /*
   3052           * Verify the certificate validity, with profile, restartable version
   3053           *
   3054           * This function:
   3055           *  - checks the requested CN (if any)
   3056           *  - checks the type and size of the EE cert's key,
   3057           *    as that isn't done as part of chain building/verification currently
   3058           *  - builds and verifies the chain
   3059           *  - then calls the callback and merges the flags
   3060           *
   3061           * The parameters pairs `trust_ca`, `ca_crl` and `f_ca_cb`, `p_ca_cb`
   3062           * are mutually exclusive: If `f_ca_cb != NULL`, it will be used by the
   3063           * verification routine to search for trusted signers, and CRLs will
   3064           * be disabled. Otherwise, `trust_ca` will be used as the static list
   3065           * of trusted signers, and `ca_crl` will be use as the static list
   3066           * of CRLs.
   3067           */

   \                                 In section .text, align 2, keep-with-next
   3068          static int x509_crt_verify_restartable_ca_cb(mbedtls_x509_crt *crt,
   3069                                                       mbedtls_x509_crt *trust_ca,
   3070                                                       mbedtls_x509_crl *ca_crl,
   3071                                                       mbedtls_x509_crt_ca_cb_t f_ca_cb,
   3072                                                       void *p_ca_cb,
   3073                                                       const mbedtls_x509_crt_profile *profile,
   3074                                                       const char *cn, uint32_t *flags,
   3075                                                       int (*f_vrfy)(void *,
   3076                                                                     mbedtls_x509_crt *,
   3077                                                                     int,
   3078                                                                     uint32_t *),
   3079                                                       void *p_vrfy,
   3080                                                       mbedtls_x509_crt_restart_ctx *rs_ctx)
   3081          {
   \                     x509_crt_verify_restartable_ca_cb: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB09C             SUB      SP,SP,#+112
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x001F             MOVS     R7,R3
   \        0xA   0x9D29             LDR      R5,[SP, #+164]
   \        0xC   0x9E2A             LDR      R6,[SP, #+168]
   \        0xE   0xF8DD 0xB0AC      LDR      R11,[SP, #+172]
   \       0x12   0xF8DD 0x80B0      LDR      R8,[SP, #+176]
   \       0x16   0xF8DD 0x90B4      LDR      R9,[SP, #+180]
   3082              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x1A   0xF07F 0x006D      MVNS     R0,#+109
   \       0x1E   0x9006             STR      R0,[SP, #+24]
   3083              mbedtls_pk_type_t pk_type;
   3084              mbedtls_x509_crt_verify_chain ver_chain;
   3085              uint32_t ee_flags;
   3086          
   3087              *flags = 0;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xF8CB 0x0000      STR      R0,[R11, #+0]
   3088              ee_flags = 0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x9005             STR      R0,[SP, #+20]
   3089              x509_crt_verify_chain_reset(&ver_chain);
   \       0x2A   0xA807             ADD      R0,SP,#+28
   \       0x2C   0x.... 0x....      BL       x509_crt_verify_chain_reset
   3090          
   3091              if (profile == NULL) {
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xD101             BNE.N    ??x509_crt_verify_restartable_ca_cb_0
   3092                  ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \       0x34   0x....             LDR.N    R4,??DataTable24_2
   3093                  goto exit;
   \       0x36   0xE03D             B.N      ??x509_crt_verify_restartable_ca_cb_1
   3094              }
   3095          
   3096              /* check name if requested */
   3097              if (cn != NULL) {
   \                     ??x509_crt_verify_restartable_ca_cb_0: (+1)
   \       0x38   0x2E00             CMP      R6,#+0
   \       0x3A   0xD004             BEQ.N    ??x509_crt_verify_restartable_ca_cb_2
   3098                  x509_crt_verify_name(crt, cn, &ee_flags);
   \       0x3C   0xAA05             ADD      R2,SP,#+20
   \       0x3E   0x0031             MOVS     R1,R6
   \       0x40   0x4650             MOV      R0,R10
   \       0x42   0x.... 0x....      BL       x509_crt_verify_name
   3099              }
   3100          
   3101              /* Check the type and size of the key */
   3102              pk_type = mbedtls_pk_get_type(&crt->pk);
   \                     ??x509_crt_verify_restartable_ca_cb_2: (+1)
   \       0x46   0xF11A 0x00CC      ADDS     R0,R10,#+204
   \       0x4A   0x.... 0x....      BL       mbedtls_pk_get_type
   \       0x4E   0xF88D 0x0010      STRB     R0,[SP, #+16]
   3103          
   3104              if (x509_profile_check_pk_alg(profile, pk_type) != 0) {
   \       0x52   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0x.... 0x....      BL       x509_profile_check_pk_alg
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD003             BEQ.N    ??x509_crt_verify_restartable_ca_cb_3
   3105                  ee_flags |= MBEDTLS_X509_BADCERT_BAD_PK;
   \       0x60   0x9805             LDR      R0,[SP, #+20]
   \       0x62   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x66   0x9005             STR      R0,[SP, #+20]
   3106              }
   3107          
   3108              if (x509_profile_check_key(profile, &crt->pk) != 0) {
   \                     ??x509_crt_verify_restartable_ca_cb_3: (+1)
   \       0x68   0xF11A 0x01CC      ADDS     R1,R10,#+204
   \       0x6C   0x0028             MOVS     R0,R5
   \       0x6E   0x.... 0x....      BL       x509_profile_check_key
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD003             BEQ.N    ??x509_crt_verify_restartable_ca_cb_4
   3109                  ee_flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
   \       0x76   0x9805             LDR      R0,[SP, #+20]
   \       0x78   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x7C   0x9005             STR      R0,[SP, #+20]
   3110              }
   3111          
   3112              /* Check the chain */
   3113              ret = x509_crt_verify_chain(crt, trust_ca, ca_crl,
   3114                                          f_ca_cb, p_ca_cb, profile,
   3115                                          &ver_chain, rs_ctx);
   \                     ??x509_crt_verify_restartable_ca_cb_4: (+1)
   \       0x7E   0x982E             LDR      R0,[SP, #+184]
   \       0x80   0x9003             STR      R0,[SP, #+12]
   \       0x82   0xA807             ADD      R0,SP,#+28
   \       0x84   0x9002             STR      R0,[SP, #+8]
   \       0x86   0x9501             STR      R5,[SP, #+4]
   \       0x88   0x9828             LDR      R0,[SP, #+160]
   \       0x8A   0x9000             STR      R0,[SP, #+0]
   \       0x8C   0x003B             MOVS     R3,R7
   \       0x8E   0x9A1E             LDR      R2,[SP, #+120]
   \       0x90   0x991D             LDR      R1,[SP, #+116]
   \       0x92   0x4650             MOV      R0,R10
   \       0x94   0x.... 0x....      BL       x509_crt_verify_chain
   \       0x98   0x0004             MOVS     R4,R0
   3116          
   3117              if (ret != 0) {
   \       0x9A   0x2C00             CMP      R4,#+0
   \       0x9C   0xD10A             BNE.N    ??x509_crt_verify_restartable_ca_cb_1
   3118                  goto exit;
   3119              }
   3120          
   3121              /* Merge end-entity flags */
   3122              ver_chain.items[0].flags |= ee_flags;
   \                     ??x509_crt_verify_restartable_ca_cb_5: (+1)
   \       0x9E   0x9908             LDR      R1,[SP, #+32]
   \       0xA0   0x9805             LDR      R0,[SP, #+20]
   \       0xA2   0x4301             ORRS     R1,R0,R1
   \       0xA4   0x9108             STR      R1,[SP, #+32]
   3123          
   3124              /* Build final flags, calling callback on the way if any */
   3125              ret = x509_crt_merge_flags_with_cb(flags, &ver_chain, f_vrfy, p_vrfy);
   \       0xA6   0x464B             MOV      R3,R9
   \       0xA8   0x4642             MOV      R2,R8
   \       0xAA   0xA907             ADD      R1,SP,#+28
   \       0xAC   0x4658             MOV      R0,R11
   \       0xAE   0x.... 0x....      BL       x509_crt_merge_flags_with_cb
   \       0xB2   0x0004             MOVS     R4,R0
   3126          
   3127          exit:
   3128          
   3129          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
   3130              mbedtls_x509_crt_free(ver_chain.trust_ca_cb_result);
   3131              mbedtls_free(ver_chain.trust_ca_cb_result);
   3132              ver_chain.trust_ca_cb_result = NULL;
   3133          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
   3134          
   3135          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   3136              if (rs_ctx != NULL && ret != MBEDTLS_ERR_ECP_IN_PROGRESS) {
   3137                  mbedtls_x509_crt_restart_free(rs_ctx);
   3138              }
   3139          #endif
   3140          
   3141              /* prevent misuse of the vrfy callback - VERIFY_FAILED would be ignored by
   3142               * the SSL module for authmode optional, but non-zero return from the
   3143               * callback means a fatal error so it shouldn't be ignored */
   3144              if (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {
   \                     ??x509_crt_verify_restartable_ca_cb_1: (+1)
   \       0xB4   0x....             LDR.N    R0,??DataTable24_7
   \       0xB6   0x4284             CMP      R4,R0
   \       0xB8   0xD101             BNE.N    ??x509_crt_verify_restartable_ca_cb_6
   3145                  ret = MBEDTLS_ERR_X509_FATAL_ERROR;
   \       0xBA   0x....             LDR.N    R1,??DataTable24_5
   \       0xBC   0x000C             MOVS     R4,R1
   3146              }
   3147          
   3148              if (ret != 0) {
   \                     ??x509_crt_verify_restartable_ca_cb_6: (+1)
   \       0xBE   0x2C00             CMP      R4,#+0
   \       0xC0   0xD005             BEQ.N    ??x509_crt_verify_restartable_ca_cb_7
   3149                  *flags = (uint32_t) -1;
   \       0xC2   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0xC6   0xF8CB 0x0000      STR      R0,[R11, #+0]
   3150                  return ret;
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0xE004             B.N      ??x509_crt_verify_restartable_ca_cb_8
   3151              }
   3152          
   3153              if (*flags != 0) {
   \                     ??x509_crt_verify_restartable_ca_cb_7: (+1)
   \       0xCE   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \       0xD2   0x2900             CMP      R1,#+0
   \       0xD4   0xD100             BNE.N    ??x509_crt_verify_restartable_ca_cb_8
   3154                  return MBEDTLS_ERR_X509_CERT_VERIFY_FAILED;
   3155              }
   3156          
   3157              return 0;
   \                     ??x509_crt_verify_restartable_ca_cb_9: (+1)
   \       0xD6   0x2000             MOVS     R0,#+0
   \                     ??x509_crt_verify_restartable_ca_cb_8: (+1)
   \       0xD8   0xB01F             ADD      SP,SP,#+124
   \       0xDA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3158          }
   3159          
   3160          
   3161          /*
   3162           * Verify the certificate validity (default profile, not restartable)
   3163           */

   \                                 In section .text, align 2, keep-with-next
   3164          int mbedtls_x509_crt_verify(mbedtls_x509_crt *crt,
   3165                                      mbedtls_x509_crt *trust_ca,
   3166                                      mbedtls_x509_crl *ca_crl,
   3167                                      const char *cn, uint32_t *flags,
   3168                                      int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3169                                      void *p_vrfy)
   3170          {
   \                     mbedtls_x509_crt_verify: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3171              return x509_crt_verify_restartable_ca_cb(crt, trust_ca, ca_crl,
   3172                                                       NULL, NULL,
   3173                                                       &mbedtls_x509_crt_profile_default,
   3174                                                       cn, flags,
   3175                                                       f_vrfy, p_vrfy, NULL);
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9006             STR      R0,[SP, #+24]
   \       0x10   0x980E             LDR      R0,[SP, #+56]
   \       0x12   0x9005             STR      R0,[SP, #+20]
   \       0x14   0x980D             LDR      R0,[SP, #+52]
   \       0x16   0x9004             STR      R0,[SP, #+16]
   \       0x18   0x980C             LDR      R0,[SP, #+48]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   \       0x1C   0x9702             STR      R7,[SP, #+8]
   \       0x1E   0x....             LDR.N    R0,??DataTable24_8
   \       0x20   0x9001             STR      R0,[SP, #+4]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9000             STR      R0,[SP, #+0]
   \       0x26   0x2300             MOVS     R3,#+0
   \       0x28   0x0032             MOVS     R2,R6
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       x509_crt_verify_restartable_ca_cb
   \       0x32   0xB007             ADD      SP,SP,#+28
   \       0x34   0xBDF0             POP      {R4-R7,PC}
   3176          }
   3177          
   3178          /*
   3179           * Verify the certificate validity (user-chosen profile, not restartable)
   3180           */

   \                                 In section .text, align 2, keep-with-next
   3181          int mbedtls_x509_crt_verify_with_profile(mbedtls_x509_crt *crt,
   3182                                                   mbedtls_x509_crt *trust_ca,
   3183                                                   mbedtls_x509_crl *ca_crl,
   3184                                                   const mbedtls_x509_crt_profile *profile,
   3185                                                   const char *cn, uint32_t *flags,
   3186                                                   int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3187                                                   void *p_vrfy)
   3188          {
   \                     mbedtls_x509_crt_verify_with_profile: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3189              return x509_crt_verify_restartable_ca_cb(crt, trust_ca, ca_crl,
   3190                                                       NULL, NULL,
   3191                                                       profile, cn, flags,
   3192                                                       f_vrfy, p_vrfy, NULL);
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9006             STR      R0,[SP, #+24]
   \       0x10   0x980F             LDR      R0,[SP, #+60]
   \       0x12   0x9005             STR      R0,[SP, #+20]
   \       0x14   0x980E             LDR      R0,[SP, #+56]
   \       0x16   0x9004             STR      R0,[SP, #+16]
   \       0x18   0x980D             LDR      R0,[SP, #+52]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   \       0x1C   0x980C             LDR      R0,[SP, #+48]
   \       0x1E   0x9002             STR      R0,[SP, #+8]
   \       0x20   0x9701             STR      R7,[SP, #+4]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9000             STR      R0,[SP, #+0]
   \       0x26   0x2300             MOVS     R3,#+0
   \       0x28   0x0032             MOVS     R2,R6
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       x509_crt_verify_restartable_ca_cb
   \       0x32   0xB007             ADD      SP,SP,#+28
   \       0x34   0xBDF0             POP      {R4-R7,PC}
   3193          }
   3194          
   3195          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
   3196          /*
   3197           * Verify the certificate validity (user-chosen profile, CA callback,
   3198           *                                  not restartable).
   3199           */
   3200          int mbedtls_x509_crt_verify_with_ca_cb(mbedtls_x509_crt *crt,
   3201                                                 mbedtls_x509_crt_ca_cb_t f_ca_cb,
   3202                                                 void *p_ca_cb,
   3203                                                 const mbedtls_x509_crt_profile *profile,
   3204                                                 const char *cn, uint32_t *flags,
   3205                                                 int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3206                                                 void *p_vrfy)
   3207          {
   3208              return x509_crt_verify_restartable_ca_cb(crt, NULL, NULL,
   3209                                                       f_ca_cb, p_ca_cb,
   3210                                                       profile, cn, flags,
   3211                                                       f_vrfy, p_vrfy, NULL);
   3212          }
   3213          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
   3214          

   \                                 In section .text, align 2, keep-with-next
   3215          int mbedtls_x509_crt_verify_restartable(mbedtls_x509_crt *crt,
   3216                                                  mbedtls_x509_crt *trust_ca,
   3217                                                  mbedtls_x509_crl *ca_crl,
   3218                                                  const mbedtls_x509_crt_profile *profile,
   3219                                                  const char *cn, uint32_t *flags,
   3220                                                  int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3221                                                  void *p_vrfy,
   3222                                                  mbedtls_x509_crt_restart_ctx *rs_ctx)
   3223          {
   \                     mbedtls_x509_crt_verify_restartable: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3224              return x509_crt_verify_restartable_ca_cb(crt, trust_ca, ca_crl,
   3225                                                       NULL, NULL,
   3226                                                       profile, cn, flags,
   3227                                                       f_vrfy, p_vrfy, rs_ctx);
   \        0xC   0x9810             LDR      R0,[SP, #+64]
   \        0xE   0x9006             STR      R0,[SP, #+24]
   \       0x10   0x980F             LDR      R0,[SP, #+60]
   \       0x12   0x9005             STR      R0,[SP, #+20]
   \       0x14   0x980E             LDR      R0,[SP, #+56]
   \       0x16   0x9004             STR      R0,[SP, #+16]
   \       0x18   0x980D             LDR      R0,[SP, #+52]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   \       0x1C   0x980C             LDR      R0,[SP, #+48]
   \       0x1E   0x9002             STR      R0,[SP, #+8]
   \       0x20   0x9701             STR      R7,[SP, #+4]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9000             STR      R0,[SP, #+0]
   \       0x26   0x2300             MOVS     R3,#+0
   \       0x28   0x0032             MOVS     R2,R6
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       x509_crt_verify_restartable_ca_cb
   \       0x32   0xB007             ADD      SP,SP,#+28
   \       0x34   0xBDF0             POP      {R4-R7,PC}
   3228          }
   3229          
   3230          
   3231          /*
   3232           * Initialize a certificate chain
   3233           */

   \                                 In section .text, align 2, keep-with-next
   3234          void mbedtls_x509_crt_init(mbedtls_x509_crt *crt)
   3235          {
   \                     mbedtls_x509_crt_init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   3236              memset(crt, 0, sizeof(mbedtls_x509_crt));
   \        0x4   0xF44F 0x740B      MOV      R4,#+556
   \        0x8   0x2500             MOVS     R5,#+0
   \        0xA   0x003E             MOVS     R6,R7
   \        0xC   0x002A             MOVS     R2,R5
   \        0xE   0x0021             MOVS     R1,R4
   \       0x10   0x0030             MOVS     R0,R6
   \       0x12   0x.... 0x....      BL       __aeabi_memset
   3237          }
   \       0x16   0xBDF1             POP      {R0,R4-R7,PC}
   3238          
   3239          /*
   3240           * Unallocate all certificate data
   3241           */

   \                                 In section .text, align 2, keep-with-next
   3242          void mbedtls_x509_crt_free(mbedtls_x509_crt *crt)
   3243          {
   \                     mbedtls_x509_crt_free: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   3244              mbedtls_x509_crt *cert_cur = crt;
   \        0x4   0x0034             MOVS     R4,R6
   3245              mbedtls_x509_crt *cert_prv;
   3246          
   3247              while (cert_cur != NULL) {
   \                     ??mbedtls_x509_crt_free_0: (+1)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD032             BEQ.N    ??mbedtls_x509_crt_free_1
   3248                  mbedtls_pk_free(&cert_cur->pk);
   \        0xA   0xF114 0x00CC      ADDS     R0,R4,#+204
   \        0xE   0x.... 0x....      BL       mbedtls_pk_free
   3249          
   3250          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
   3251                  mbedtls_free(cert_cur->sig_opts);
   3252          #endif
   3253          
   3254                  mbedtls_asn1_free_named_data_list_shallow(cert_cur->issuer.next);
   \       0x12   0x6EA0             LDR      R0,[R4, #+104]
   \       0x14   0x.... 0x....      BL       mbedtls_asn1_free_named_data_list_shallow
   3255                  mbedtls_asn1_free_named_data_list_shallow(cert_cur->subject.next);
   \       0x18   0xF8D4 0x0088      LDR      R0,[R4, #+136]
   \       0x1C   0x.... 0x....      BL       mbedtls_asn1_free_named_data_list_shallow
   3256                  mbedtls_asn1_sequence_free(cert_cur->ext_key_usage.next);
   \       0x20   0xF8D4 0x020C      LDR      R0,[R4, #+524]
   \       0x24   0x.... 0x....      BL       mbedtls_asn1_sequence_free
   3257                  mbedtls_asn1_sequence_free(cert_cur->subject_alt_names.next);
   \       0x28   0xF8D4 0x019C      LDR      R0,[R4, #+412]
   \       0x2C   0x.... 0x....      BL       mbedtls_asn1_sequence_free
   3258                  mbedtls_asn1_sequence_free(cert_cur->certificate_policies.next);
   \       0x30   0xF8D4 0x01EC      LDR      R0,[R4, #+492]
   \       0x34   0x.... 0x....      BL       mbedtls_asn1_sequence_free
   3259                  mbedtls_asn1_sequence_free(cert_cur->authority_key_id.authorityCertIssuer.next);
   \       0x38   0xF8D4 0x01C4      LDR      R0,[R4, #+452]
   \       0x3C   0x.... 0x....      BL       mbedtls_asn1_sequence_free
   3260          
   3261                  if (cert_cur->raw.p != NULL && cert_cur->own_buffer) {
   \       0x40   0x68E0             LDR      R0,[R4, #+12]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD006             BEQ.N    ??mbedtls_x509_crt_free_2
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD003             BEQ.N    ??mbedtls_x509_crt_free_2
   3262                      mbedtls_zeroize_and_free(cert_cur->raw.p, cert_cur->raw.len);
   \       0x4C   0x68A1             LDR      R1,[R4, #+8]
   \       0x4E   0x68E0             LDR      R0,[R4, #+12]
   \       0x50   0x.... 0x....      BL       mbedtls_zeroize_and_free
   3263                  }
   3264          
   3265                  cert_prv = cert_cur;
   \                     ??mbedtls_x509_crt_free_2: (+1)
   \       0x54   0x0025             MOVS     R5,R4
   3266                  cert_cur = cert_cur->next;
   \       0x56   0xF8D4 0x4228      LDR      R4,[R4, #+552]
   3267          
   3268                  mbedtls_platform_zeroize(cert_prv, sizeof(mbedtls_x509_crt));
   \       0x5A   0xF44F 0x710B      MOV      R1,#+556
   \       0x5E   0x0028             MOVS     R0,R5
   \       0x60   0x.... 0x....      BL       mbedtls_platform_zeroize
   3269                  if (cert_prv != crt) {
   \       0x64   0x42B5             CMP      R5,R6
   \       0x66   0xD0CE             BEQ.N    ??mbedtls_x509_crt_free_0
   3270                      mbedtls_free(cert_prv);
   \       0x68   0x0028             MOVS     R0,R5
   \       0x6A   0x.... 0x....      BL       sl_free
   \       0x6E   0xE7CA             B.N      ??mbedtls_x509_crt_free_0
   3271                  }
   3272              }
   3273          }
   \                     ??mbedtls_x509_crt_free_1: (+1)
   \       0x70   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0xFFFF'DE80        DC32     0xffffde80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0xFFFF'DE00        DC32     0xffffde00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0xFFFF'DC00        DC32     0xffffdc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0xFFFF'DB00        DC32     0xffffdb00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0xFFFF'DA9A        DC32     0xffffda9a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0xFFFF'DF80        DC32     0xffffdf80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x00 0x00          DC8      "",0x0,0x0,0x0 
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0x3F 0x3F          DC8      "???"          
   \              0x3F 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0x2C 0x20          DC8      0x2C, 0x20, 0x00, 0x00
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0xFFFF'D800        DC32     0xffffd800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0xFFFF'DE80        DC32     0xffffde80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0xFFFF'D780        DC32     0xffffd780

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0xFFFF'DA80        DC32     0xffffda80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x0A 0x00          DC8      "\n",0x0,0x0   
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0xFFFF'D980        DC32     0xffffd980

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0x....'....        DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \        0x0   0x....'....        DC32     ?_26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0xFFFF'D880        DC32     0xffffd880

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0xFFFF'D680        DC32     0xffffd680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x....'....        DC32     ?_28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \        0x0   0x....'....        DC32     ?_29

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \        0x0   0x....'....        DC32     ?_30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \        0x0   0x....'....        DC32     ?_31

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \        0x0   0x....'....        DC32     ?_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x....'....        DC32     ?_33

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0x....'....        DC32     ?_34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \        0x0   0x....'....        DC32     ?_35

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \        0x0   0x....'....        DC32     ?_36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \        0x0   0x....'....        DC32     ?_38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \        0x0   0x00 0x00          DC8      "",0x0,0x0,0x0 
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \        0x0   0x....'....        DC32     ?_39

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \        0x0   0x....'....        DC32     ?_37

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \        0x0   0x....'....        DC32     ?_40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \        0x0   0x....'....        DC32     ?_41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \        0x0   0x....'....        DC32     ?_42

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     ?_43

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x....'....        DC32     ?_44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x....'....        DC32     ?_45

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x....'....        DC32     x509_crt_verify_strings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     ?_47

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x....'....        DC32     ?_48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \        0x0   0xFFFF'D800        DC32     0xffffd800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \        0x0   0x....'....        DC32     ?_49

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \        0x0   0x55 0x04          DC8      "U\004\003"    
   \              0x03 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \        0x0   0xFFFF'D000        DC32     0xffffd000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \        0x0   0x....'....        DC32     mbedtls_byte_order_detector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \        0x0   0xFFFF'D900        DC32     0xffffd900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \        0x0   0x....'....        DC32     mbedtls_x509_crt_profile_default

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x54 0x68          DC8 "The certificate validity has expired"
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x69    
   \              0x74 0x79    
   \              0x20 0x68    
   \              0x61 0x73    
   \              0x20 0x65    
   \              0x78 0x70    
   \              0x69 0x72    
   \              0x65 0x64    
   \              0x00
   \       0x25                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x54 0x68          DC8 "The certificate has been revoked (is on a CRL)"
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x68 0x61    
   \              0x73 0x20    
   \              0x62 0x65    
   \              0x65 0x6E    
   \              0x20 0x72    
   \              0x65 0x76    
   \              0x6F 0x6B    
   \              0x65 0x64    
   \              0x20 0x28    
   \              0x69 0x73    
   \              0x20 0x6F    
   \              0x6E 0x20    
   \              0x61 0x20    
   \              0x43 0x52    
   \              0x4C 0x29    
   \              0x00
   \       0x2F                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x43 0x6F          DC8 0x43, 0x6F, 0x6D, 0x6D, 0x6F, 0x6E, 0x20, 0x4E
   \              0x6D 0x6D    
   \              0x6F 0x6E    
   \              0x20 0x4E
   \       0x18   0x61 0x6D          DC8 0x61, 0x6D, 0x65, 0x20, 0x28, 0x43, 0x4E, 0x29
   \              0x65 0x20    
   \              0x28 0x43    
   \              0x4E 0x29
   \       0x20   0x20 0x64          DC8 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F
   \              0x6F 0x65    
   \              0x73 0x20    
   \              0x6E 0x6F
   \       0x28   0x74 0x20          DC8 0x74, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20
   \              0x6D 0x61    
   \              0x74 0x63    
   \              0x68 0x20
   \       0x30   0x77 0x69          DC8 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65
   \              0x74 0x68    
   \              0x20 0x74    
   \              0x68 0x65
   \       0x38   0x20 0x65          DC8 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65
   \              0x78 0x70    
   \              0x65 0x63    
   \              0x74 0x65
   \       0x40   0x64 0x20          DC8 0x64, 0x20, 0x43, 0x4E, 0
   \              0x43 0x4E    
   \              0x00
   \       0x45                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x63
   \       0x18   0x6F 0x72          DC8 0x6F, 0x72, 0x72, 0x65, 0x63, 0x74, 0x6C, 0x79
   \              0x72 0x65    
   \              0x63 0x74    
   \              0x6C 0x79
   \       0x20   0x20 0x73          DC8 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x20
   \       0x28   0x62 0x79          DC8 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x74
   \       0x30   0x72 0x75          DC8 0x72, 0x75, 0x73, 0x74, 0x65, 0x64, 0x20, 0x43
   \              0x73 0x74    
   \              0x65 0x64    
   \              0x20 0x43
   \       0x38   0x41 0x00          DC8 0x41, 0
   \       0x3A                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x54 0x68          DC8 "The CRL is not correctly signed by the trusted CA"
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20    
   \              0x69 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x63    
   \              0x6F 0x72    
   \              0x72 0x65    
   \              0x63 0x74    
   \              0x6C 0x79    
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x62 0x79    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x74    
   \              0x72 0x75    
   \              0x73 0x74    
   \              0x65 0x64    
   \              0x20 0x43    
   \              0x41 0x00
   \       0x32                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x54 0x68          DC8 "The CRL is expired"
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20    
   \              0x69 0x73    
   \              0x20 0x65    
   \              0x78 0x70    
   \              0x69 0x72    
   \              0x65 0x64    
   \              0x00
   \       0x13                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x43 0x65          DC8 "Certificate was missing"
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x77 0x61    
   \              0x73 0x20    
   \              0x6D 0x69    
   \              0x73 0x73    
   \              0x69 0x6E    
   \              0x67 0x00

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x43 0x65          DC8 "Certificate verification was skipped"
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x76 0x65    
   \              0x72 0x69    
   \              0x66 0x69    
   \              0x63 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x77    
   \              0x61 0x73    
   \              0x20 0x73    
   \              0x6B 0x69    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x00
   \       0x25                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x4F 0x74          DC8 "Other reason (can be used by verify callback)"
   \              0x68 0x65    
   \              0x72 0x20    
   \              0x72 0x65    
   \              0x61 0x73    
   \              0x6F 0x6E    
   \              0x20 0x28    
   \              0x63 0x61    
   \              0x6E 0x20    
   \              0x62 0x65    
   \              0x20 0x75    
   \              0x73 0x65    
   \              0x64 0x20    
   \              0x62 0x79    
   \              0x20 0x76    
   \              0x65 0x72    
   \              0x69 0x66    
   \              0x79 0x20    
   \              0x63 0x61    
   \              0x6C 0x6C    
   \              0x62 0x61    
   \              0x63 0x6B    
   \              0x29 0x00
   \       0x2E                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x54 0x68          DC8 "The certificate validity starts in the future"
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x69    
   \              0x74 0x79    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x73 0x20    
   \              0x69 0x6E    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x66    
   \              0x75 0x74    
   \              0x75 0x72    
   \              0x65 0x00
   \       0x2E                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x54 0x68          DC8 "The CRL is from the future"
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20    
   \              0x69 0x73    
   \              0x20 0x66    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x74 0x68    
   \              0x65 0x20    
   \              0x66 0x75    
   \              0x74 0x75    
   \              0x72 0x65    
   \              0x00
   \       0x1B                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x55 0x73          DC8 "Usage does not match the keyUsage extension"
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x64 0x6F    
   \              0x65 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x6D    
   \              0x61 0x74    
   \              0x63 0x68    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x6B    
   \              0x65 0x79    
   \              0x55 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x65 0x78    
   \              0x74 0x65    
   \              0x6E 0x73    
   \              0x69 0x6F    
   \              0x6E 0x00

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x55 0x73          DC8 0x55, 0x73, 0x61, 0x67, 0x65, 0x20, 0x64, 0x6F
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x64 0x6F
   \        0x8   0x65 0x73          DC8 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x6D
   \       0x10   0x61 0x74          DC8 0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65
   \              0x63 0x68    
   \              0x20 0x74    
   \              0x68 0x65
   \       0x18   0x20 0x65          DC8 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x64, 0x65
   \              0x78 0x74    
   \              0x65 0x6E    
   \              0x64 0x65
   \       0x20   0x64 0x4B          DC8 0x64, 0x4B, 0x65, 0x79, 0x55, 0x73, 0x61, 0x67
   \              0x65 0x79    
   \              0x55 0x73    
   \              0x61 0x67
   \       0x28   0x65 0x20          DC8 0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73
   \              0x65 0x78    
   \              0x74 0x65    
   \              0x6E 0x73
   \       0x30   0x69 0x6F          DC8 0x69, 0x6F, 0x6E, 0
   \              0x6E 0x00

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x55 0x73          DC8 "Usage does not match the nsCertType extension"
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x64 0x6F    
   \              0x65 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x6D    
   \              0x61 0x74    
   \              0x63 0x68    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x6E    
   \              0x73 0x43    
   \              0x65 0x72    
   \              0x74 0x54    
   \              0x79 0x70    
   \              0x65 0x20    
   \              0x65 0x78    
   \              0x74 0x65    
   \              0x6E 0x73    
   \              0x69 0x6F    
   \              0x6E 0x00
   \       0x2E                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x18   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x20   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x28   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x68
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x68
   \       0x30   0x61 0x73          DC8 0x61, 0x73, 0x68, 0x2E, 0
   \              0x68 0x2E    
   \              0x00
   \       0x35                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x18   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x20   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x28   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x50
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x50
   \       0x30   0x4B 0x20          DC8 0x4B, 0x20, 0x61, 0x6C, 0x67, 0x20, 0x28, 0x65
   \              0x61 0x6C    
   \              0x67 0x20    
   \              0x28 0x65
   \       0x38   0x67 0x20          DC8 0x67, 0x20, 0x52, 0x53, 0x41, 0x20, 0x76, 0x73
   \              0x52 0x53    
   \              0x41 0x20    
   \              0x76 0x73
   \       0x40   0x20 0x45          DC8 0x20, 0x45, 0x43, 0x44, 0x53, 0x41, 0x29, 0x2E
   \              0x43 0x44    
   \              0x53 0x41    
   \              0x29 0x2E
   \       0x48   0x00               DC8 0
   \       0x49                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x18   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x20   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x28   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6B
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x6B
   \       0x30   0x65 0x79          DC8 0x65, 0x79, 0x20, 0x28, 0x65, 0x67, 0x20, 0x62
   \              0x20 0x28    
   \              0x65 0x67    
   \              0x20 0x62
   \       0x38   0x61 0x64          DC8 0x61, 0x64, 0x20, 0x63, 0x75, 0x72, 0x76, 0x65
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x76 0x65
   \       0x40   0x2C 0x20          DC8 0x2C, 0x20, 0x52, 0x53, 0x41, 0x20, 0x74, 0x6F
   \              0x52 0x53    
   \              0x41 0x20    
   \              0x74 0x6F
   \       0x48   0x6F 0x20          DC8 0x6F, 0x20, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x29
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x29
   \       0x50   0x2E 0x00          DC8 0x2E, 0
   \       0x52                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x54 0x68          DC8 "The CRL is signed with an unacceptable hash."
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20    
   \              0x69 0x73    
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61    
   \              0x6E 0x20    
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65    
   \              0x70 0x74    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x68    
   \              0x61 0x73    
   \              0x68 0x2E    
   \              0x00
   \       0x2D                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x43, 0x52, 0x4C, 0x20
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20
   \        0x8   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x10   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x18   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x20   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x50
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x50
   \       0x28   0x4B 0x20          DC8 0x4B, 0x20, 0x61, 0x6C, 0x67, 0x20, 0x28, 0x65
   \              0x61 0x6C    
   \              0x67 0x20    
   \              0x28 0x65
   \       0x30   0x67 0x20          DC8 0x67, 0x20, 0x52, 0x53, 0x41, 0x20, 0x76, 0x73
   \              0x52 0x53    
   \              0x41 0x20    
   \              0x76 0x73
   \       0x38   0x20 0x45          DC8 0x20, 0x45, 0x43, 0x44, 0x53, 0x41, 0x29, 0x2E
   \              0x43 0x44    
   \              0x53 0x41    
   \              0x29 0x2E
   \       0x40   0x00               DC8 0
   \       0x41                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x43, 0x52, 0x4C, 0x20
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20
   \        0x8   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x10   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x18   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x20   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6B
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x6B
   \       0x28   0x65 0x79          DC8 0x65, 0x79, 0x20, 0x28, 0x65, 0x67, 0x20, 0x62
   \              0x20 0x28    
   \              0x65 0x67    
   \              0x20 0x62
   \       0x30   0x61 0x64          DC8 0x61, 0x64, 0x20, 0x63, 0x75, 0x72, 0x76, 0x65
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x76 0x65
   \       0x38   0x2C 0x20          DC8 0x2C, 0x20, 0x52, 0x53, 0x41, 0x20, 0x74, 0x6F
   \              0x52 0x53    
   \              0x41 0x20    
   \              0x74 0x6F
   \       0x40   0x6F 0x20          DC8 0x6F, 0x20, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x29
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x29
   \       0x48   0x2E 0x00          DC8 0x2E, 0
   \       0x4A                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x75
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x75
   \       0x40   0x74 0x69          DC8 0x74, 0x69, 0x6C, 0x5C, 0x74, 0x68, 0x69, 0x72
   \              0x6C 0x5C    
   \              0x74 0x68    
   \              0x69 0x72
   \       0x48   0x64 0x5F          DC8 0x64, 0x5F, 0x70, 0x61, 0x72, 0x74, 0x79, 0x5C
   \              0x70 0x61    
   \              0x72 0x74    
   \              0x79 0x5C
   \       0x50   0x6D 0x62          DC8 0x6D, 0x62, 0x65, 0x64, 0x74, 0x6C, 0x73, 0x5C
   \              0x65 0x64    
   \              0x74 0x6C    
   \              0x73 0x5C
   \       0x58   0x6C 0x69          DC8 0x6C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x5C
   \              0x62 0x72    
   \              0x61 0x72    
   \              0x79 0x5C
   \       0x60   0x78 0x35          DC8 0x78, 0x35, 0x30, 0x39, 0x5F, 0x63, 0x72, 0x74
   \              0x30 0x39    
   \              0x5F 0x63    
   \              0x72 0x74
   \       0x68   0x2E 0x63          DC8 0x2E, 0x63, 0
   \              0x00
   \       0x6B                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x55 0x1D          DC8 0x55, 0x1D, 0x20, 0, 0
   \              0x20 0x00    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x2D 0x2D          DC8 "-----BEGIN CERTIFICATE-----"
   \              0x2D 0x2D    
   \              0x2D 0x42    
   \              0x45 0x47    
   \              0x49 0x4E    
   \              0x20 0x43    
   \              0x45 0x52    
   \              0x54 0x49    
   \              0x46 0x49    
   \              0x43 0x41    
   \              0x54 0x45    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x00

   \                                 In section .rodata, align 4
   \                     ?_23:
   \        0x0   0x2D 0x2D          DC8 "-----END CERTIFICATE-----"
   \              0x2D 0x2D    
   \              0x2D 0x45    
   \              0x4E 0x44    
   \              0x20 0x43    
   \              0x45 0x52    
   \              0x54 0x49    
   \              0x46 0x49    
   \              0x43 0x41    
   \              0x54 0x45    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x00
   \       0x1A                      DS8 2

   \                                 In section .rodata, align 1
   \        0x0   0x00               DC8 ""

   \                                 In section .rodata, align 4
   \        0x0   0x3F 0x3F          DC8 "???"
   \              0x3F 0x00

   \                                 In section .rodata, align 4
   \                     ?_26:
   \        0x0   0x25 0x73          DC8 "%s%s"
   \              0x25 0x73    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .rodata, align 4
   \        0x0   0x2C 0x20          DC8 ", "
   \              0x00
   \        0x3                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_28:
   \        0x0   0x0A 0x43          DC8 "\012Certificate is uninitialised!\012"
   \              0x65 0x72    
   \              0x74 0x69    
   \              0x66 0x69    
   \              0x63 0x61    
   \              0x74 0x65    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x75 0x6E    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x73 0x65    
   \              0x64 0x21    
   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_29:
   \        0x0   0x25 0x73          DC8 "%scert. version     : %d\012"
   \              0x63 0x65    
   \              0x72 0x74    
   \              0x2E 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x0A 0x00
   \       0x1A                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_30:
   \        0x0   0x25 0x73          DC8 "%sserial number     : "
   \              0x73 0x65    
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x6E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x3A 0x20    
   \              0x00
   \       0x17                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_31:
   \        0x0   0x0A 0x25          DC8 "\012%sissuer name       : "
   \              0x73 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x72 0x20    
   \              0x6E 0x61    
   \              0x6D 0x65    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .rodata, align 4
   \                     ?_32:
   \        0x0   0x0A 0x25          DC8 "\012%ssubject name      : "
   \              0x73 0x73    
   \              0x75 0x62    
   \              0x6A 0x65    
   \              0x63 0x74    
   \              0x20 0x6E    
   \              0x61 0x6D    
   \              0x65 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .rodata, align 4
   \                     ?_33:
   \        0x0   0x0A 0x25          DC8 0x0A, 0x25, 0x73, 0x69, 0x73, 0x73, 0x75, 0x65
   \              0x73 0x69    
   \              0x73 0x73    
   \              0x75 0x65
   \        0x8   0x64 0x20          DC8 0x64, 0x20, 0x20, 0x6F, 0x6E, 0x20, 0x20, 0x20
   \              0x20 0x6F    
   \              0x6E 0x20    
   \              0x20 0x20
   \       0x10   0x20 0x20          DC8 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x25
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x25
   \       0x18   0x30 0x34          DC8 0x30, 0x34, 0x64, 0x2D, 0x25, 0x30, 0x32, 0x64
   \              0x64 0x2D    
   \              0x25 0x30    
   \              0x32 0x64
   \       0x20   0x2D 0x25          DC8 0x2D, 0x25, 0x30, 0x32, 0x64, 0x20, 0x25, 0x30
   \              0x30 0x32    
   \              0x64 0x20    
   \              0x25 0x30
   \       0x28   0x32 0x64          DC8 0x32, 0x64, 0x3A, 0x25, 0x30, 0x32, 0x64, 0x3A
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x64 0x3A
   \       0x30   0x25 0x30          DC8 0x25, 0x30, 0x32, 0x64, 0
   \              0x32 0x64    
   \              0x00
   \       0x35                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_34:
   \        0x0   0x0A 0x25          DC8 0x0A, 0x25, 0x73, 0x65, 0x78, 0x70, 0x69, 0x72
   \              0x73 0x65    
   \              0x78 0x70    
   \              0x69 0x72
   \        0x8   0x65 0x73          DC8 0x65, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x20, 0x20
   \              0x20 0x6F    
   \              0x6E 0x20    
   \              0x20 0x20
   \       0x10   0x20 0x20          DC8 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x25
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x25
   \       0x18   0x30 0x34          DC8 0x30, 0x34, 0x64, 0x2D, 0x25, 0x30, 0x32, 0x64
   \              0x64 0x2D    
   \              0x25 0x30    
   \              0x32 0x64
   \       0x20   0x2D 0x25          DC8 0x2D, 0x25, 0x30, 0x32, 0x64, 0x20, 0x25, 0x30
   \              0x30 0x32    
   \              0x64 0x20    
   \              0x25 0x30
   \       0x28   0x32 0x64          DC8 0x32, 0x64, 0x3A, 0x25, 0x30, 0x32, 0x64, 0x3A
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x64 0x3A
   \       0x30   0x25 0x30          DC8 0x25, 0x30, 0x32, 0x64, 0
   \              0x32 0x64    
   \              0x00
   \       0x35                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_35:
   \        0x0   0x0A 0x25          DC8 "\012%ssigned using      : "
   \              0x73 0x73    
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x75 0x73    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .rodata, align 4
   \                     ?_36:
   \        0x0   0x0A 0x25          DC8 "\012%s%-18s: %d bits"
   \              0x73 0x25    
   \              0x2D 0x31    
   \              0x38 0x73    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x20 0x62    
   \              0x69 0x74    
   \              0x73 0x00
   \       0x12                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_37:
   \        0x0   0x0A 0x25          DC8 "\012%sbasic constraints : CA=%s"
   \              0x73 0x62    
   \              0x61 0x73    
   \              0x69 0x63    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x73 0x74    
   \              0x72 0x61    
   \              0x69 0x6E    
   \              0x74 0x73    
   \              0x20 0x3A    
   \              0x20 0x43    
   \              0x41 0x3D    
   \              0x25 0x73    
   \              0x00
   \       0x1D                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_38:
   \        0x0   0x74 0x72          DC8 "true"
   \              0x75 0x65    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_39:
   \        0x0   0x66 0x61          DC8 "false"
   \              0x6C 0x73    
   \              0x65 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_40:
   \        0x0   0x2C 0x20          DC8 ", max_pathlen=%d"
   \              0x6D 0x61    
   \              0x78 0x5F    
   \              0x70 0x61    
   \              0x74 0x68    
   \              0x6C 0x65    
   \              0x6E 0x3D    
   \              0x25 0x64    
   \              0x00
   \       0x11                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_41:
   \        0x0   0x0A 0x25          DC8 "\012%ssubject alt name  :"
   \              0x73 0x73    
   \              0x75 0x62    
   \              0x6A 0x65    
   \              0x63 0x74    
   \              0x20 0x61    
   \              0x6C 0x74    
   \              0x20 0x6E    
   \              0x61 0x6D    
   \              0x65 0x20    
   \              0x20 0x3A    
   \              0x00
   \       0x17                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_42:
   \        0x0   0x0A 0x25          DC8 "\012%scert. type        : "
   \              0x73 0x63    
   \              0x65 0x72    
   \              0x74 0x2E    
   \              0x20 0x74    
   \              0x79 0x70    
   \              0x65 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .rodata, align 4
   \                     ?_43:
   \        0x0   0x0A 0x25          DC8 "\012%skey usage         : "
   \              0x73 0x6B    
   \              0x65 0x79    
   \              0x20 0x75    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .rodata, align 4
   \                     ?_44:
   \        0x0   0x0A 0x25          DC8 "\012%sext key usage     : "
   \              0x73 0x65    
   \              0x78 0x74    
   \              0x20 0x6B    
   \              0x65 0x79    
   \              0x20 0x75    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .rodata, align 4
   \                     ?_45:
   \        0x0   0x0A 0x25          DC8 "\012%scertificate policies : "
   \              0x73 0x63    
   \              0x65 0x72    
   \              0x74 0x69    
   \              0x66 0x69    
   \              0x63 0x61    
   \              0x74 0x65    
   \              0x20 0x70    
   \              0x6F 0x6C    
   \              0x69 0x63    
   \              0x69 0x65    
   \              0x73 0x20    
   \              0x3A 0x20    
   \              0x00
   \       0x1B                      DS8 1

   \                                 In section .rodata, align 2
   \        0x0   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_47:
   \        0x0   0x25 0x73          DC8 "%s%s\012"
   \              0x25 0x73    
   \              0x0A 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_48:
   \        0x0   0x25 0x73          DC8 "%sUnknown reason (this should not happen)\012"
   \              0x55 0x6E    
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x72 0x65    
   \              0x61 0x73    
   \              0x6F 0x6E    
   \              0x20 0x28    
   \              0x74 0x68    
   \              0x69 0x73    
   \              0x20 0x73    
   \              0x68 0x6F    
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x68 0x61    
   \              0x70 0x70    
   \              0x65 0x6E    
   \              0x29 0x0A    
   \              0x00
   \       0x2B                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_49:
   \        0x0   0x55 0x1D          DC8 0x55, 0x1D, 0x25, 0, 0
   \              0x25 0x00    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .rodata, align 4
   \        0x0   0x55 0x04          DC8 "U\004\003"
   \              0x03 0x00
   3274          
   3275          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   3276          /*
   3277           * Initialize a restart context
   3278           */
   3279          void mbedtls_x509_crt_restart_init(mbedtls_x509_crt_restart_ctx *ctx)
   3280          {
   3281              mbedtls_pk_restart_init(&ctx->pk);
   3282          
   3283              ctx->parent = NULL;
   3284              ctx->fallback_parent = NULL;
   3285              ctx->fallback_signature_is_good = 0;
   3286          
   3287              ctx->parent_is_trusted = -1;
   3288          
   3289              ctx->in_progress = x509_crt_rs_none;
   3290              ctx->self_cnt = 0;
   3291              x509_crt_verify_chain_reset(&ctx->ver_chain);
   3292          }
   3293          
   3294          /*
   3295           * Free the components of a restart context
   3296           */
   3297          void mbedtls_x509_crt_restart_free(mbedtls_x509_crt_restart_ctx *ctx)
   3298          {
   3299              if (ctx == NULL) {
   3300                  return;
   3301              }
   3302          
   3303              mbedtls_pk_restart_free(&ctx->pk);
   3304              mbedtls_x509_crt_restart_init(ctx);
   3305          }
   3306          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   3307          
   3308          #endif /* MBEDTLS_X509_CRT_PARSE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_bswap16
       0   mbedtls_error_add
       0   mbedtls_md_psa_alg_from_type
      24   mbedtls_pk_ec_ro
        24   -> mbedtls_pk_get_type
     184   mbedtls_pk_get_group_id
       168   -> __aeabi_memclr4
       184   -> __aeabi_memcpy4
       168   -> mbedtls_ecc_group_of_psa
       168   -> mbedtls_pk_ec_ro
       168   -> mbedtls_pk_get_type
       168   -> psa_get_key_attributes
       168   -> psa_get_key_bits
       168   -> psa_get_key_type
       168   -> psa_reset_key_attributes
      24   mbedtls_put_unaligned_uint16
        24   -> __aeabi_memcpy
      24   mbedtls_x509_crt_check_extended_key_usage
        24   -> memcmp
       8   mbedtls_x509_crt_check_key_usage
      16   mbedtls_x509_crt_free
        16   -> mbedtls_asn1_free_named_data_list_shallow
        16   -> mbedtls_asn1_sequence_free
        16   -> mbedtls_pk_free
        16   -> mbedtls_platform_zeroize
        16   -> mbedtls_zeroize_and_free
        16   -> sl_free
      80   mbedtls_x509_crt_info
        80   -> mbedtls_pk_get_bitlen
        80   -> mbedtls_pk_get_name
        80   -> mbedtls_x509_dn_gets
        80   -> mbedtls_x509_info_cert_type
        80   -> mbedtls_x509_info_key_usage
        80   -> mbedtls_x509_info_subject_alt_name
        80   -> mbedtls_x509_key_size_helper
        80   -> mbedtls_x509_serial_gets
        80   -> mbedtls_x509_sig_alg_gets
        80   -> snprintf
        80   -> x509_info_cert_policies
        80   -> x509_info_ext_key_usage
      24   mbedtls_x509_crt_init
        24   -> __aeabi_memset
      16   mbedtls_x509_crt_is_revoked
        16   -> memcmp
      64   mbedtls_x509_crt_parse
        64   -> mbedtls_pem_free
        64   -> mbedtls_pem_init
        64   -> mbedtls_pem_read_buffer
        64   -> mbedtls_x509_crt_parse_der
        64   -> strstr
      16   mbedtls_x509_crt_parse_cn_inet_pton
        16   -> strchr
        16   -> x509_inet_pton_ipv4
        16   -> x509_inet_pton_ipv6
      24   mbedtls_x509_crt_parse_der
        24   -> mbedtls_x509_crt_parse_der_internal
      48   mbedtls_x509_crt_parse_der_internal
        48   -> mbedtls_x509_crt_init
        48   -> sl_calloc
        48   -> sl_free
        48   -> x509_crt_parse_der_core
      24   mbedtls_x509_crt_parse_der_nocopy
        24   -> mbedtls_x509_crt_parse_der_internal
      32   mbedtls_x509_crt_parse_der_with_ext_cb
        32   -> mbedtls_x509_crt_parse_der_internal
      48   mbedtls_x509_crt_verify
        48   -> x509_crt_verify_restartable_ca_cb
      40   mbedtls_x509_crt_verify_info
        40   -> snprintf
      48   mbedtls_x509_crt_verify_restartable
        48   -> x509_crt_verify_restartable_ca_cb
      48   mbedtls_x509_crt_verify_with_profile
        48   -> x509_crt_verify_restartable_ca_cb
       0   psa_get_key_bits
       0   psa_get_key_type
      24   x509_check_wildcard
        24   -> strlen
        24   -> x509_memcasecmp
      16   x509_crt_check_cn
        16   -> x509_check_wildcard
        16   -> x509_memcasecmp
      16   x509_crt_check_ee_locally_trusted
        16   -> memcmp
        16   -> x509_name_cmp
      24   x509_crt_check_parent
        24   -> mbedtls_x509_crt_check_key_usage
        24   -> x509_name_cmp
      32   x509_crt_check_san
        32   -> x509_crt_check_cn
        32   -> x509_crt_check_san_ip
        32   -> x509_crt_check_san_uri
      40   x509_crt_check_san_ip
        40   -> mbedtls_x509_crt_parse_cn_inet_pton
        40   -> memcmp
      24   x509_crt_check_san_uri
        24   -> memcmp
      80   x509_crt_check_signature
        80   -> mbedtls_md_psa_alg_from_type
        80   -> mbedtls_pk_can_do
        80   -> mbedtls_pk_verify_ext
        80   -> psa_hash_compute
      56   x509_crt_find_parent
        56   -> x509_crt_find_parent_in
      56   x509_crt_find_parent_in
        56   -> x509_crt_check_parent
        56   -> x509_crt_check_signature
      40   x509_crt_merge_flags_with_cb
        40   -- Indirect call
      96   x509_crt_parse_der_core
        96   -> __aeabi_memcpy
        96   -> __aeabi_memset
        96   -> mbedtls_asn1_get_tag
        96   -> mbedtls_error_add
        96   -> mbedtls_pk_parse_subpubkey
        96   -> mbedtls_x509_crt_free
        96   -> mbedtls_x509_get_alg
        96   -> mbedtls_x509_get_name
        96   -> mbedtls_x509_get_serial
        96   -> mbedtls_x509_get_sig
        96   -> mbedtls_x509_get_sig_alg
        96   -> memcmp
        96   -> sl_calloc
        96   -> x509_get_crt_ext
        96   -> x509_get_dates
        96   -> x509_get_uid
        96   -> x509_get_version
     112   x509_crt_verify_chain
       112   -> x509_crt_check_ee_locally_trusted
       112   -> x509_crt_find_parent
       112   -> x509_crt_verifycrl
       112   -> x509_name_cmp
       112   -> x509_profile_check_key
       112   -> x509_profile_check_md_alg
       112   -> x509_profile_check_pk_alg
       0   x509_crt_verify_chain_reset
      24   x509_crt_verify_name
        24   -> memcmp
        24   -> strlen
        24   -> x509_crt_check_cn
        24   -> x509_crt_check_san
     160   x509_crt_verify_restartable_ca_cb
       160   -> mbedtls_pk_get_type
       160   -> x509_crt_merge_flags_with_cb
       160   -> x509_crt_verify_chain
       160   -> x509_crt_verify_chain_reset
       160   -> x509_crt_verify_name
       160   -> x509_profile_check_key
       160   -> x509_profile_check_pk_alg
      80   x509_crt_verifycrl
        80   -> mbedtls_md_psa_alg_from_type
        80   -> mbedtls_pk_verify_ext
        80   -> mbedtls_x509_crt_check_key_usage
        80   -> mbedtls_x509_crt_is_revoked
        80   -> psa_hash_compute
        80   -> x509_name_cmp
        80   -> x509_profile_check_key
        80   -> x509_profile_check_md_alg
        80   -> x509_profile_check_pk_alg
      32   x509_get_authority_key_id
        32   -> mbedtls_asn1_get_tag
        32   -> mbedtls_error_add
        32   -> mbedtls_x509_get_subject_alt_name_ext
      32   x509_get_basic_constraints
        32   -> mbedtls_asn1_get_bool
        32   -> mbedtls_asn1_get_int
        32   -> mbedtls_asn1_get_tag
        32   -> mbedtls_error_add
      56   x509_get_certificate_policies
        56   -> mbedtls_asn1_get_tag
        56   -> mbedtls_error_add
        56   -> memcmp
        56   -> sl_calloc
      80   x509_get_crt_ext
        80   -- Indirect call
        80   -> mbedtls_asn1_get_bool
        80   -> mbedtls_asn1_get_tag
        80   -> mbedtls_error_add
        80   -> mbedtls_oid_get_x509_ext_type
        80   -> mbedtls_x509_get_ext
        80   -> mbedtls_x509_get_key_usage
        80   -> mbedtls_x509_get_ns_cert_type
        80   -> mbedtls_x509_get_subject_alt_name
        80   -> x509_get_authority_key_id
        80   -> x509_get_basic_constraints
        80   -> x509_get_certificate_policies
        80   -> x509_get_ext_key_usage
        80   -> x509_get_subject_key_id
      40   x509_get_dates
        40   -> mbedtls_asn1_get_tag
        40   -> mbedtls_error_add
        40   -> mbedtls_x509_get_time
      24   x509_get_ext_key_usage
        24   -> mbedtls_asn1_get_sequence_of
        24   -> mbedtls_error_add
      32   x509_get_subject_key_id
        32   -> mbedtls_asn1_get_tag
        32   -> mbedtls_error_add
      32   x509_get_uid
        32   -> mbedtls_asn1_get_tag
        32   -> mbedtls_error_add
      32   x509_get_version
        32   -> mbedtls_asn1_get_int
        32   -> mbedtls_asn1_get_tag
        32   -> mbedtls_error_add
      16   x509_inet_pton_ipv4
      64   x509_inet_pton_ipv6
        64   -> __aeabi_memcpy
        64   -> __aeabi_memmove
        64   -> __aeabi_memset
        64   -> mbedtls_bswap16
        64   -> mbedtls_put_unaligned_uint16
        64   -> x509_inet_pton_ipv4
      48   x509_info_cert_policies
        48   -> mbedtls_oid_get_certificate_policies
        48   -> snprintf
      48   x509_info_ext_key_usage
        48   -> mbedtls_oid_get_extended_key_usage
        48   -> snprintf
      16   x509_memcasecmp
      16   x509_name_cmp
        16   -> memcmp
        16   -> x509_string_cmp
      16   x509_profile_check_key
        16   -> mbedtls_pk_get_group_id
        16   -> mbedtls_pk_get_type
       0   x509_profile_check_md_alg
       0   x509_profile_check_pk_alg
      16   x509_string_cmp
        16   -> memcmp
        16   -> x509_memcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
      40  ?_0
      48  ?_1
      28  ?_10
      44  ?_11
      52  ?_12
      48  ?_13
      56  ?_14
      76  ?_15
      84  ?_16
      48  ?_17
      68  ?_18
      76  ?_19
      72  ?_2
     108  ?_20
       8  ?_21
      28  ?_22
      28  ?_23
       1  ?_24
       4  ?_25
       8  ?_26
       4  ?_27
      32  ?_28
      28  ?_29
      60  ?_3
      24  ?_30
      24  ?_31
      24  ?_32
      56  ?_33
      56  ?_34
      24  ?_35
      20  ?_36
      32  ?_37
       8  ?_38
       8  ?_39
      52  ?_4
      20  ?_40
      24  ?_41
      24  ?_42
      24  ?_43
      24  ?_44
      28  ?_45
       2  ?_46
       8  ?_47
      44  ?_48
       8  ?_49
      20  ?_5
       4  ?_50
      36  ?_51
      12  ?_52
      24  ?_6
      40  ?_7
      48  ?_8
      48  ?_9
      16  mbedtls_bswap16
       2  mbedtls_byte_order_detector
       4  mbedtls_error_add
       8  mbedtls_md_psa_alg_from_type
      28  mbedtls_pk_ec_ro
     126  mbedtls_pk_get_group_id
      22  mbedtls_put_unaligned_uint16
     116  mbedtls_x509_crt_check_extended_key_usage
      70  mbedtls_x509_crt_check_key_usage
     114  mbedtls_x509_crt_free
   1'328  mbedtls_x509_crt_info
      24  mbedtls_x509_crt_init
      54  mbedtls_x509_crt_is_revoked
     286  mbedtls_x509_crt_parse
      58  mbedtls_x509_crt_parse_cn_inet_pton
      30  mbedtls_x509_crt_parse_der
     170  mbedtls_x509_crt_parse_der_internal
      30  mbedtls_x509_crt_parse_der_nocopy
      32  mbedtls_x509_crt_parse_der_with_ext_cb
      16  mbedtls_x509_crt_profile_default
      16  mbedtls_x509_crt_profile_next
      16  mbedtls_x509_crt_profile_none
      16  mbedtls_x509_crt_profile_suiteb
      54  mbedtls_x509_crt_verify
     144  mbedtls_x509_crt_verify_info
      54  mbedtls_x509_crt_verify_restartable
      54  mbedtls_x509_crt_verify_with_profile
       4  psa_get_key_bits
       4  psa_get_key_type
     124  x509_check_wildcard
      54  x509_crt_check_cn
      72  x509_crt_check_ee_locally_trusted
      90  x509_crt_check_parent
     130  x509_crt_check_san
      90  x509_crt_check_san_ip
      68  x509_crt_check_san_uri
     126  x509_crt_check_signature
     118  x509_crt_find_parent
     150  x509_crt_find_parent_in
      82  x509_crt_merge_flags_with_cb
   1'024  x509_crt_parse_der_core
     350  x509_crt_verify_chain
      32  x509_crt_verify_chain_reset
     118  x509_crt_verify_name
     222  x509_crt_verify_restartable_ca_cb
     168  x509_crt_verify_strings
     252  x509_crt_verifycrl
     320  x509_get_authority_key_id
     264  x509_get_basic_constraints
     480  x509_get_certificate_policies
     772  x509_get_crt_ext
     136  x509_get_dates
      86  x509_get_ext_key_usage
     110  x509_get_subject_key_id
     100  x509_get_uid
     144  x509_get_version
     168  x509_inet_pton_ipv4
     452  x509_inet_pton_ipv6
     110  x509_info_cert_policies
     110  x509_info_ext_key_usage
      84  x509_memcasecmp
     110  x509_name_cmp
      86  x509_profile_check_key
      36  x509_profile_check_md_alg
      36  x509_profile_check_pk_alg
      96  x509_string_cmp

 
 2'049 bytes in section .rodata
 9'840 bytes in section .text
 
 9'818 bytes of CODE  memory (+ 22 bytes shared)
 2'049 bytes of CONST memory

Errors: none
Warnings: none
