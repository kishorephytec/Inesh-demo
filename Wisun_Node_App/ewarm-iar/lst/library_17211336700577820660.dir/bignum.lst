###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:40
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\bignum.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\bignum.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\bignum.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\bignum.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\bignum.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\bignum.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\bignum.c
      1          /*
      2           *  Multi-precision integer library
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           *  The following sources were referenced in the design of this Multi-precision
     22           *  Integer library:
     23           *
     24           *  [1] Handbook of Applied Cryptography - 1997
     25           *      Menezes, van Oorschot and Vanstone
     26           *
     27           *  [2] Multi-Precision Math
     28           *      Tom St Denis
     29           *      https://github.com/libtom/libtommath/blob/develop/tommath.pdf
     30           *
     31           *  [3] GNU Multi-Precision Arithmetic Library
     32           *      https://gmplib.org/manual/index.html
     33           *
     34           */
     35          
     36          #include "common.h"
     37          
     38          #if defined(MBEDTLS_BIGNUM_C)
     39          
     40          #include "mbedtls/bignum.h"
     41          #include "bignum_core.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_compiler_opaque(uint32_t)
   \                     mbedtls_ct_compiler_opaque: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable1
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0x4048             EORS     R0,R1,R0
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool(uint32_t)
   \                     mbedtls_ct_bool: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xA   0x0002             MOVS     R2,R0
   \        0xC   0x4251             RSBS     R1,R2,#+0
   \        0xE   0x0010             MOVS     R0,R2
   \       0x10   0x0840             LSRS     R0,R0,#+1
   \       0x12   0x4240             RSBS     R0,R0,#+0
   \       0x14   0x4308             ORRS     R0,R0,R1
   \       0x16   0x0FC0             LSRS     R0,R0,#+31
   \       0x18   0x4240             RSBS     R0,R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_if(uint32_t, uint32_t, uint32_t)
   \                     mbedtls_ct_if: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xE   0x43C0             MVNS     R0,R0
   \       0x10   0x4026             ANDS     R6,R4,R6
   \       0x12   0x4005             ANDS     R5,R5,R0
   \       0x14   0x432E             ORRS     R6,R5,R6
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_ne(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_ne: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0038             MOVS     R0,R7
   \        0x8   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0xC   0x0005             MOVS     R5,R0
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x14   0x0006             MOVS     R6,R0
   \       0x16   0x406E             EORS     R6,R6,R5
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp unsigned int mbedtls_ct_uint_if(uint32_t, unsigned int, unsigned int)
   \                     mbedtls_ct_uint_if: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x002A             MOVS     R2,R5
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0030             MOVS     R0,R6
   \        0xE   0x.... 0x....      BL       mbedtls_ct_if
   \       0x12   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_ct_size_if_else_0(uint32_t, size_t)
   \                     mbedtls_ct_size_if_else_0: (+1)
   \        0x0   0x4008             ANDS     R0,R1,R0
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp unsigned int mbedtls_ct_uint_if_else_0(uint32_t, unsigned int)
   \                     mbedtls_ct_uint_if_else_0: (+1)
   \        0x0   0x4008             ANDS     R0,R1,R0
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_mpi_uint_if_else_0(uint32_t, uint32_t)
   \                     mbedtls_ct_mpi_uint_if_else_0: (+1)
   \        0x0   0x4008             ANDS     R0,R1,R0
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_eq(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_eq: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0021             MOVS     R1,R4
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_ct_uint_ne
   \        0xE   0x43C0             MVNS     R0,R0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool_ne(uint32_t, uint32_t)
   \                     mbedtls_ct_bool_ne: (+1)
   \        0x0   0x4048             EORS     R0,R1,R0
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool_and(uint32_t, uint32_t)
   \                     mbedtls_ct_bool_and: (+1)
   \        0x0   0x4008             ANDS     R0,R1,R0
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool_or(uint32_t, uint32_t)
   \                     mbedtls_ct_bool_or: (+1)
   \        0x0   0x4308             ORRS     R0,R1,R0
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool_not(uint32_t)
   \                     mbedtls_ct_bool_not: (+1)
   \        0x0   0x43C0             MVNS     R0,R0
   \        0x2   0x4770             BX       LR
     42          #include "bn_mul.h"
     43          #include "mbedtls/platform_util.h"
     44          #include "mbedtls/error.h"
     45          #include "constant_time_internal.h"
     46          
     47          #include <limits.h>
     48          #include <string.h>
     49          
     50          #include "mbedtls/platform.h"
     51          
     52          #define MPI_VALIDATE_RET(cond)                                       \
     53              MBEDTLS_INTERNAL_VALIDATE_RET(cond, MBEDTLS_ERR_MPI_BAD_INPUT_DATA)
     54          #define MPI_VALIDATE(cond)                                           \
     55              MBEDTLS_INTERNAL_VALIDATE(cond)
     56          
     57          /*
     58           * Compare signed values in constant time
     59           */

   \                                 In section .text, align 2, keep-with-next
     60          int mbedtls_mpi_lt_mpi_ct(const mbedtls_mpi *X,
     61                                    const mbedtls_mpi *Y,
     62                                    unsigned *ret)
     63          {
   \                     mbedtls_mpi_lt_mpi_ct: (+1)
   \        0x0   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \        0x4   0xB083             SUB      SP,SP,#+12
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000C             MOVS     R4,R1
     64              mbedtls_ct_condition_t different_sign, X_is_negative, Y_is_negative, result;
     65          
     66              MPI_VALIDATE_RET(X != NULL);
     67              MPI_VALIDATE_RET(Y != NULL);
     68              MPI_VALIDATE_RET(ret != NULL);
     69          
     70              if (X->n != Y->n) {
   \        0xA   0xF8BA 0x1006      LDRH     R1,[R10, #+6]
   \        0xE   0x88E0             LDRH     R0,[R4, #+6]
   \       0x10   0x4281             CMP      R1,R0
   \       0x12   0xD002             BEQ.N    ??mbedtls_mpi_lt_mpi_ct_0
     71                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x14   0xF07F 0x0003      MVNS     R0,#+3
   \       0x18   0xE041             B.N      ??mbedtls_mpi_lt_mpi_ct_1
     72              }
     73          
     74              /*
     75               * Set N_is_negative to MBEDTLS_CT_FALSE if N >= 0, MBEDTLS_CT_TRUE if N < 0.
     76               * We know that N->s == 1 if N >= 0 and N->s == -1 if N < 0.
     77               */
     78              X_is_negative = mbedtls_ct_bool((X->s & 2) >> 1);
   \                     ??mbedtls_mpi_lt_mpi_ct_0: (+1)
   \       0x1A   0xF9BA 0x0004      LDRSH    R0,[R10, #+4]
   \       0x1E   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0x22   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x26   0x0005             MOVS     R5,R0
     79              Y_is_negative = mbedtls_ct_bool((Y->s & 2) >> 1);
   \       0x28   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0x2C   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0x30   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x34   0x9000             STR      R0,[SP, #+0]
     80          
     81              /*
     82               * If the signs are different, then the positive operand is the bigger.
     83               * That is if X is negative (X_is_negative == 1), then X < Y is true and it
     84               * is false if X is positive (X_is_negative == 0).
     85               */
     86              different_sign = mbedtls_ct_bool_ne(X_is_negative, Y_is_negative); // true if different sign
   \       0x36   0x9900             LDR      R1,[SP, #+0]
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       mbedtls_ct_bool_ne
   \       0x3E   0x0006             MOVS     R6,R0
     87              result = mbedtls_ct_bool_and(different_sign, X_is_negative);
   \       0x40   0x0029             MOVS     R1,R5
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0x.... 0x....      BL       mbedtls_ct_bool_and
   \       0x48   0x0007             MOVS     R7,R0
     88          
     89              /*
     90               * Assuming signs are the same, compare X and Y. We switch the comparison
     91               * order if they are negative so that we get the right result, regardles of
     92               * sign.
     93               */
     94          
     95              /* This array is used to conditionally swap the pointers in const time */
     96              void * const p[2] = { X->p, Y->p };
   \       0x4A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x4E   0x9001             STR      R0,[SP, #+4]
   \       0x50   0xF10D 0x0904      ADD      R9,SP,#+4
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0xF8C9 0x0004      STR      R0,[R9, #+4]
     97              size_t i = mbedtls_ct_size_if_else_0(X_is_negative, 1);
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0x.... 0x....      BL       mbedtls_ct_size_if_else_0
   \       0x62   0x4680             MOV      R8,R0
     98              mbedtls_ct_condition_t lt = mbedtls_mpi_core_lt_ct(p[i], p[i ^ 1], X->n);
   \       0x64   0xF8BA 0x2006      LDRH     R2,[R10, #+6]
   \       0x68   0xF098 0x0001      EORS     R0,R8,#0x1
   \       0x6C   0xF859 0x1020      LDR      R1,[R9, R0, LSL #+2]
   \       0x70   0xF859 0x0028      LDR      R0,[R9, R8, LSL #+2]
   \       0x74   0x.... 0x....      BL       mbedtls_mpi_core_lt_ct
   \       0x78   0x4681             MOV      R9,R0
     99          
    100              /*
    101               * Store in result iff the signs are the same (i.e., iff different_sign == false). If
    102               * the signs differ, result has already been set, so we don't change it.
    103               */
    104              result = mbedtls_ct_bool_or(result,
    105                                          mbedtls_ct_bool_and(mbedtls_ct_bool_not(different_sign), lt));
   \       0x7A   0x0030             MOVS     R0,R6
   \       0x7C   0x.... 0x....      BL       mbedtls_ct_bool_not
   \       0x80   0x4649             MOV      R1,R9
   \       0x82   0x.... 0x....      BL       mbedtls_ct_bool_and
   \       0x86   0x0001             MOVS     R1,R0
   \       0x88   0x0038             MOVS     R0,R7
   \       0x8A   0x.... 0x....      BL       mbedtls_ct_bool_or
   \       0x8E   0x4683             MOV      R11,R0
    106          
    107              *ret = mbedtls_ct_uint_if_else_0(result, 1);
   \       0x90   0x2101             MOVS     R1,#+1
   \       0x92   0x4658             MOV      R0,R11
   \       0x94   0x.... 0x....      BL       mbedtls_ct_uint_if_else_0
   \       0x98   0x9904             LDR      R1,[SP, #+16]
   \       0x9A   0x6008             STR      R0,[R1, #+0]
    108          
    109              return 0;
   \       0x9C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_mpi_lt_mpi_ct_1: (+1)
   \       0x9E   0xB005             ADD      SP,SP,#+20
   \       0xA0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    110          }
    111          
    112          /*
    113           * Conditionally assign X = Y, without leaking information
    114           * about whether the assignment was made or not.
    115           * (Leaking information about the respective sizes of X and Y is ok however.)
    116           */
    117          #if defined(_MSC_VER) && defined(_M_ARM64) && (_MSC_FULL_VER < 193131103)
    118          /*
    119           * MSVC miscompiles this function if it's inlined prior to Visual Studio 2022 version 17.1. See:
    120           * https://developercommunity.visualstudio.com/t/c-compiler-miscompiles-part-of-mbedtls-library-on/1646989
    121           */
    122          __declspec(noinline)
    123          #endif

   \                                 In section .text, align 2, keep-with-next
    124          int mbedtls_mpi_safe_cond_assign(mbedtls_mpi *X,
    125                                           const mbedtls_mpi *Y,
    126                                           unsigned char assign)
    127          {
   \                     mbedtls_mpi_safe_cond_assign: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    128              int ret = 0;
   \        0xA   0xF05F 0x0800      MOVS     R8,#+0
    129              MPI_VALIDATE_RET(X != NULL);
    130              MPI_VALIDATE_RET(Y != NULL);
    131          
    132              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, Y->n));
   \        0xE   0x88E9             LDRH     R1,[R5, #+6]
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x16   0x0007             MOVS     R7,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD127             BNE.N    ??mbedtls_mpi_safe_cond_assign_0
    133          
    134              {
    135                  mbedtls_ct_condition_t do_assign = mbedtls_ct_bool(assign);
   \                     ??mbedtls_mpi_safe_cond_assign_1: (+1)
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x24   0x4682             MOV      R10,R0
    136          
    137                  X->s = (int) mbedtls_ct_uint_if(do_assign, Y->s, X->s);
   \       0x26   0xF9B4 0x2004      LDRSH    R2,[R4, #+4]
   \       0x2A   0xF9B5 0x1004      LDRSH    R1,[R5, #+4]
   \       0x2E   0x4650             MOV      R0,R10
   \       0x30   0x.... 0x....      BL       mbedtls_ct_uint_if
   \       0x34   0x80A0             STRH     R0,[R4, #+4]
    138          
    139                  mbedtls_mpi_core_cond_assign(X->p, Y->p, Y->n, do_assign);
   \       0x36   0x4653             MOV      R3,R10
   \       0x38   0x88EA             LDRH     R2,[R5, #+6]
   \       0x3A   0x6829             LDR      R1,[R5, #+0]
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x.... 0x....      BL       mbedtls_mpi_core_cond_assign
    140          
    141                  mbedtls_ct_condition_t do_not_assign = mbedtls_ct_bool_not(do_assign);
   \       0x42   0x4650             MOV      R0,R10
   \       0x44   0x.... 0x....      BL       mbedtls_ct_bool_not
   \       0x48   0x4680             MOV      R8,R0
    142                  for (size_t i = Y->n; i < X->n; i++) {
   \       0x4A   0xF8B5 0x9006      LDRH     R9,[R5, #+6]
   \                     ??mbedtls_mpi_safe_cond_assign_2: (+1)
   \       0x4E   0x88E0             LDRH     R0,[R4, #+6]
   \       0x50   0x4581             CMP      R9,R0
   \       0x52   0xD20B             BCS.N    ??mbedtls_mpi_safe_cond_assign_0
    143                      X->p[i] = mbedtls_ct_mpi_uint_if_else_0(do_not_assign, X->p[i]);
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0xF850 0x1029      LDR      R1,[R0, R9, LSL #+2]
   \       0x5A   0x4640             MOV      R0,R8
   \       0x5C   0x.... 0x....      BL       mbedtls_ct_mpi_uint_if_else_0
   \       0x60   0x6821             LDR      R1,[R4, #+0]
   \       0x62   0xF841 0x0029      STR      R0,[R1, R9, LSL #+2]
    144                  }
   \       0x66   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x6A   0xE7F0             B.N      ??mbedtls_mpi_safe_cond_assign_2
    145              }
    146          
    147          cleanup:
    148              return ret;
   \                     ??mbedtls_mpi_safe_cond_assign_0: (+1)
   \       0x6C   0x0038             MOVS     R0,R7
   \       0x6E   0xE8BD 0x87F0      POP      {R4-R10,PC}
    149          }
    150          
    151          /*
    152           * Conditionally swap X and Y, without leaking information
    153           * about whether the swap was made or not.
    154           * Here it is not ok to simply swap the pointers, which would lead to
    155           * different memory access patterns when X and Y are used afterwards.
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          int mbedtls_mpi_safe_cond_swap(mbedtls_mpi *X,
    158                                         mbedtls_mpi *Y,
    159                                         unsigned char swap)
    160          {
   \                     mbedtls_mpi_safe_cond_swap: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    161              int ret = 0;
   \        0xA   0xF05F 0x0A00      MOVS     R10,#+0
    162              int s;
    163              MPI_VALIDATE_RET(X != NULL);
    164              MPI_VALIDATE_RET(Y != NULL);
    165          
    166              if (X == Y) {
   \        0xE   0x42AC             CMP      R4,R5
   \       0x10   0xD101             BNE.N    ??mbedtls_mpi_safe_cond_swap_0
    167                  return 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE02B             B.N      ??mbedtls_mpi_safe_cond_swap_1
    168              }
    169          
    170              mbedtls_ct_condition_t do_swap = mbedtls_ct_bool(swap);
   \                     ??mbedtls_mpi_safe_cond_swap_0: (+1)
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x1E   0x0007             MOVS     R7,R0
    171          
    172              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, Y->n));
   \       0x20   0x88E9             LDRH     R1,[R5, #+6]
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x28   0x4680             MOV      R8,R0
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD11E             BNE.N    ??mbedtls_mpi_safe_cond_swap_2
    173              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(Y, X->n));
   \                     ??mbedtls_mpi_safe_cond_swap_3: (+1)
   \       0x2E   0x88E1             LDRH     R1,[R4, #+6]
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x36   0x4680             MOV      R8,R0
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD117             BNE.N    ??mbedtls_mpi_safe_cond_swap_2
    174          
    175              s = X->s;
   \                     ??mbedtls_mpi_safe_cond_swap_4: (+1)
   \       0x3C   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0x40   0x4681             MOV      R9,R0
    176              X->s = (int) mbedtls_ct_uint_if(do_swap, Y->s, X->s);
   \       0x42   0xF9B4 0x2004      LDRSH    R2,[R4, #+4]
   \       0x46   0xF9B5 0x1004      LDRSH    R1,[R5, #+4]
   \       0x4A   0x0038             MOVS     R0,R7
   \       0x4C   0x.... 0x....      BL       mbedtls_ct_uint_if
   \       0x50   0x80A0             STRH     R0,[R4, #+4]
    177              Y->s = (int) mbedtls_ct_uint_if(do_swap, s, Y->s);
   \       0x52   0xF9B5 0x2004      LDRSH    R2,[R5, #+4]
   \       0x56   0x4649             MOV      R1,R9
   \       0x58   0x0038             MOVS     R0,R7
   \       0x5A   0x.... 0x....      BL       mbedtls_ct_uint_if
   \       0x5E   0x80A8             STRH     R0,[R5, #+4]
    178          
    179              mbedtls_mpi_core_cond_swap(X->p, Y->p, X->n, do_swap);
   \       0x60   0x003B             MOVS     R3,R7
   \       0x62   0x88E2             LDRH     R2,[R4, #+6]
   \       0x64   0x6829             LDR      R1,[R5, #+0]
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x.... 0x....      BL       mbedtls_mpi_core_cond_swap
    180          
    181          cleanup:
    182              return ret;
   \                     ??mbedtls_mpi_safe_cond_swap_2: (+1)
   \       0x6C   0x4640             MOV      R0,R8
   \                     ??mbedtls_mpi_safe_cond_swap_1: (+1)
   \       0x6E   0xE8BD 0x87F0      POP      {R4-R10,PC}
    183          }
    184          
    185          /* Implementation that should never be optimized out by the compiler */
    186          #define mbedtls_mpi_zeroize_and_free(v, n) mbedtls_zeroize_and_free(v, ciL * (n))
    187          
    188          /*
    189           * Initialize one MPI
    190           */

   \                                 In section .text, align 2, keep-with-next
    191          void mbedtls_mpi_init(mbedtls_mpi *X)
    192          {
    193              MPI_VALIDATE(X != NULL);
    194          
    195              X->s = 1;
   \                     mbedtls_mpi_init: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x8081             STRH     R1,[R0, #+4]
    196              X->n = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x80C1             STRH     R1,[R0, #+6]
    197              X->p = NULL;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6001             STR      R1,[R0, #+0]
    198          }
   \        0xC   0x4770             BX       LR
    199          
    200          /*
    201           * Unallocate one MPI
    202           */

   \                                 In section .text, align 2, keep-with-next
    203          void mbedtls_mpi_free(mbedtls_mpi *X)
    204          {
   \                     mbedtls_mpi_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    205              if (X == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD00D             BEQ.N    ??mbedtls_mpi_free_0
    206                  return;
    207              }
    208          
    209              if (X->p != NULL) {
   \                     ??mbedtls_mpi_free_1: (+1)
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD004             BEQ.N    ??mbedtls_mpi_free_2
    210                  mbedtls_mpi_zeroize_and_free(X->p, X->n);
   \        0xE   0x88E0             LDRH     R0,[R4, #+6]
   \       0x10   0x0081             LSLS     R1,R0,#+2
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x.... 0x....      BL       mbedtls_zeroize_and_free
    211              }
    212          
    213              X->s = 1;
   \                     ??mbedtls_mpi_free_2: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x80A0             STRH     R0,[R4, #+4]
    214              X->n = 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x80E0             STRH     R0,[R4, #+6]
    215              X->p = NULL;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6020             STR      R0,[R4, #+0]
    216          }
   \                     ??mbedtls_mpi_free_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
    217          
    218          /*
    219           * Enlarge to the specified number of limbs
    220           */

   \                                 In section .text, align 2, keep-with-next
    221          int mbedtls_mpi_grow(mbedtls_mpi *X, size_t nblimbs)
    222          {
   \                     mbedtls_mpi_grow: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
    223              mbedtls_mpi_uint *p;
    224              MPI_VALIDATE_RET(X != NULL);
    225          
    226              if (nblimbs > MBEDTLS_MPI_MAX_LIMBS) {
   \        0x8   0xF242 0x7011      MOVW     R0,#+10001
   \        0xC   0x4286             CMP      R6,R0
   \        0xE   0xD302             BCC.N    ??mbedtls_mpi_grow_0
    227                  return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   \       0x10   0xF07F 0x000F      MVNS     R0,#+15
   \       0x14   0xE021             B.N      ??mbedtls_mpi_grow_1
    228              }
    229          
    230              if (X->n < nblimbs) {
   \                     ??mbedtls_mpi_grow_0: (+1)
   \       0x16   0x88E8             LDRH     R0,[R5, #+6]
   \       0x18   0x42B0             CMP      R0,R6
   \       0x1A   0xD21D             BCS.N    ??mbedtls_mpi_grow_2
    231                  if ((p = (mbedtls_mpi_uint *) mbedtls_calloc(nblimbs, ciL)) == NULL) {
   \       0x1C   0x2104             MOVS     R1,#+4
   \       0x1E   0x0030             MOVS     R0,R6
   \       0x20   0x.... 0x....      BL       sl_calloc
   \       0x24   0x0004             MOVS     R4,R0
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD102             BNE.N    ??mbedtls_mpi_grow_3
    232                      return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   \       0x2A   0xF07F 0x000F      MVNS     R0,#+15
   \       0x2E   0xE014             B.N      ??mbedtls_mpi_grow_1
    233                  }
    234          
    235                  if (X->p != NULL) {
   \                     ??mbedtls_mpi_grow_3: (+1)
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD00E             BEQ.N    ??mbedtls_mpi_grow_4
    236                      memcpy(p, X->p, X->n * ciL);
   \       0x36   0x88E8             LDRH     R0,[R5, #+6]
   \       0x38   0x0087             LSLS     R7,R0,#+2
   \       0x3A   0xF8D5 0x8000      LDR      R8,[R5, #+0]
   \       0x3E   0x46A1             MOV      R9,R4
   \       0x40   0x003A             MOVS     R2,R7
   \       0x42   0x4641             MOV      R1,R8
   \       0x44   0x4648             MOV      R0,R9
   \       0x46   0x.... 0x....      BL       __aeabi_memcpy
    237                      mbedtls_mpi_zeroize_and_free(X->p, X->n);
   \       0x4A   0x88E8             LDRH     R0,[R5, #+6]
   \       0x4C   0x0081             LSLS     R1,R0,#+2
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x.... 0x....      BL       mbedtls_zeroize_and_free
    238                  }
    239          
    240                  /* nblimbs fits in n because we ensure that MBEDTLS_MPI_MAX_LIMBS
    241                   * fits, and we've checked that nblimbs <= MBEDTLS_MPI_MAX_LIMBS. */
    242                  X->n = (unsigned short) nblimbs;
   \                     ??mbedtls_mpi_grow_4: (+1)
   \       0x54   0x80EE             STRH     R6,[R5, #+6]
    243                  X->p = p;
   \       0x56   0x602C             STR      R4,[R5, #+0]
    244              }
    245          
    246              return 0;
   \                     ??mbedtls_mpi_grow_2: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_mpi_grow_1: (+1)
   \       0x5A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    247          }
    248          
    249          /*
    250           * Resize down as much as possible,
    251           * while keeping at least the specified number of limbs
    252           */

   \                                 In section .text, align 2, keep-with-next
    253          int mbedtls_mpi_shrink(mbedtls_mpi *X, size_t nblimbs)
    254          {
   \                     mbedtls_mpi_shrink: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
    255              mbedtls_mpi_uint *p;
    256              size_t i;
    257              MPI_VALIDATE_RET(X != NULL);
    258          
    259              if (nblimbs > MBEDTLS_MPI_MAX_LIMBS) {
   \        0x8   0xF242 0x7011      MOVW     R0,#+10001
   \        0xC   0x4287             CMP      R7,R0
   \        0xE   0xD302             BCC.N    ??mbedtls_mpi_shrink_0
    260                  return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   \       0x10   0xF07F 0x000F      MVNS     R0,#+15
   \       0x14   0xE035             B.N      ??mbedtls_mpi_shrink_1
    261              }
    262          
    263              /* Actually resize up if there are currently fewer than nblimbs limbs. */
    264              if (X->n <= nblimbs) {
   \                     ??mbedtls_mpi_shrink_0: (+1)
   \       0x16   0x88F0             LDRH     R0,[R6, #+6]
   \       0x18   0x4287             CMP      R7,R0
   \       0x1A   0xD304             BCC.N    ??mbedtls_mpi_shrink_2
    265                  return mbedtls_mpi_grow(X, nblimbs);
   \       0x1C   0x0039             MOVS     R1,R7
   \       0x1E   0x0030             MOVS     R0,R6
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x24   0xE02D             B.N      ??mbedtls_mpi_shrink_1
    266              }
    267              /* After this point, then X->n > nblimbs and in particular X->n > 0. */
    268          
    269              for (i = X->n - 1; i > 0; i--) {
   \                     ??mbedtls_mpi_shrink_2: (+1)
   \       0x26   0x88F4             LDRH     R4,[R6, #+6]
   \       0x28   0x1E64             SUBS     R4,R4,#+1
   \                     ??mbedtls_mpi_shrink_3: (+1)
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD006             BEQ.N    ??mbedtls_mpi_shrink_4
    270                  if (X->p[i] != 0) {
   \       0x2E   0x6830             LDR      R0,[R6, #+0]
   \       0x30   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD101             BNE.N    ??mbedtls_mpi_shrink_4
    271                      break;
    272                  }
    273              }
   \                     ??mbedtls_mpi_shrink_5: (+1)
   \       0x38   0x1E64             SUBS     R4,R4,#+1
   \       0x3A   0xE7F6             B.N      ??mbedtls_mpi_shrink_3
    274              i++;
   \                     ??mbedtls_mpi_shrink_4: (+1)
   \       0x3C   0x1C64             ADDS     R4,R4,#+1
    275          
    276              if (i < nblimbs) {
   \       0x3E   0x42BC             CMP      R4,R7
   \       0x40   0xD200             BCS.N    ??mbedtls_mpi_shrink_6
    277                  i = nblimbs;
   \       0x42   0x003C             MOVS     R4,R7
    278              }
    279          
    280              if ((p = (mbedtls_mpi_uint *) mbedtls_calloc(i, ciL)) == NULL) {
   \                     ??mbedtls_mpi_shrink_6: (+1)
   \       0x44   0x2104             MOVS     R1,#+4
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       sl_calloc
   \       0x4C   0x0005             MOVS     R5,R0
   \       0x4E   0x2D00             CMP      R5,#+0
   \       0x50   0xD102             BNE.N    ??mbedtls_mpi_shrink_7
    281                  return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   \       0x52   0xF07F 0x000F      MVNS     R0,#+15
   \       0x56   0xE014             B.N      ??mbedtls_mpi_shrink_1
    282              }
    283          
    284              if (X->p != NULL) {
   \                     ??mbedtls_mpi_shrink_7: (+1)
   \       0x58   0x6830             LDR      R0,[R6, #+0]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD00E             BEQ.N    ??mbedtls_mpi_shrink_8
    285                  memcpy(p, X->p, i * ciL);
   \       0x5E   0xEA5F 0x0884      LSLS     R8,R4,#+2
   \       0x62   0xF8D6 0x9000      LDR      R9,[R6, #+0]
   \       0x66   0x46AA             MOV      R10,R5
   \       0x68   0x4642             MOV      R2,R8
   \       0x6A   0x4649             MOV      R1,R9
   \       0x6C   0x4650             MOV      R0,R10
   \       0x6E   0x.... 0x....      BL       __aeabi_memcpy
    286                  mbedtls_mpi_zeroize_and_free(X->p, X->n);
   \       0x72   0x88F0             LDRH     R0,[R6, #+6]
   \       0x74   0x0081             LSLS     R1,R0,#+2
   \       0x76   0x6830             LDR      R0,[R6, #+0]
   \       0x78   0x.... 0x....      BL       mbedtls_zeroize_and_free
    287              }
    288          
    289              /* i fits in n because we ensure that MBEDTLS_MPI_MAX_LIMBS
    290               * fits, and we've checked that i <= nblimbs <= MBEDTLS_MPI_MAX_LIMBS. */
    291              X->n = (unsigned short) i;
   \                     ??mbedtls_mpi_shrink_8: (+1)
   \       0x7C   0x80F4             STRH     R4,[R6, #+6]
    292              X->p = p;
   \       0x7E   0x6035             STR      R5,[R6, #+0]
    293          
    294              return 0;
   \       0x80   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_mpi_shrink_1: (+1)
   \       0x82   0xE8BD 0x87F0      POP      {R4-R10,PC}
    295          }
    296          
    297          /* Resize X to have exactly n limbs and set it to 0. */

   \                                 In section .text, align 2, keep-with-next
    298          static int mbedtls_mpi_resize_clear(mbedtls_mpi *X, size_t limbs)
    299          {
   \                     mbedtls_mpi_resize_clear: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
    300              if (limbs == 0) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD104             BNE.N    ??mbedtls_mpi_resize_clear_0
    301                  mbedtls_mpi_free(X);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_free
    302                  return 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE016             B.N      ??mbedtls_mpi_resize_clear_1
    303              } else if (X->n == limbs) {
   \                     ??mbedtls_mpi_resize_clear_0: (+1)
   \       0x16   0x88E8             LDRH     R0,[R5, #+6]
   \       0x18   0x42A0             CMP      R0,R4
   \       0x1A   0xD10C             BNE.N    ??mbedtls_mpi_resize_clear_2
    304                  memset(X->p, 0, limbs * ciL);
   \       0x1C   0x00A6             LSLS     R6,R4,#+2
   \       0x1E   0x2700             MOVS     R7,#+0
   \       0x20   0xF8D5 0x8000      LDR      R8,[R5, #+0]
   \       0x24   0x003A             MOVS     R2,R7
   \       0x26   0x0031             MOVS     R1,R6
   \       0x28   0x4640             MOV      R0,R8
   \       0x2A   0x.... 0x....      BL       __aeabi_memset
    305                  X->s = 1;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x80A8             STRH     R0,[R5, #+4]
    306                  return 0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE006             B.N      ??mbedtls_mpi_resize_clear_1
    307              } else {
    308                  mbedtls_mpi_free(X);
   \                     ??mbedtls_mpi_resize_clear_2: (+1)
   \       0x36   0x0028             MOVS     R0,R5
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_free
    309                  return mbedtls_mpi_grow(X, limbs);
   \       0x3C   0x0021             MOVS     R1,R4
   \       0x3E   0x0028             MOVS     R0,R5
   \       0x40   0x.... 0x....      BL       mbedtls_mpi_grow
   \                     ??mbedtls_mpi_resize_clear_1: (+1)
   \       0x44   0xE8BD 0x81F0      POP      {R4-R8,PC}
    310              }
    311          }
    312          
    313          /*
    314           * Copy the contents of Y into X.
    315           *
    316           * This function is not constant-time. Leading zeros in Y may be removed.
    317           *
    318           * Ensure that X does not shrink. This is not guaranteed by the public API,
    319           * but some code in the bignum module relies on this property, for example
    320           * in mbedtls_mpi_exp_mod().
    321           */

   \                                 In section .text, align 2, keep-with-next
    322          int mbedtls_mpi_copy(mbedtls_mpi *X, const mbedtls_mpi *Y)
    323          {
   \                     mbedtls_mpi_copy: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
    324              int ret = 0;
   \        0x8   0x2500             MOVS     R5,#+0
    325              size_t i;
    326              MPI_VALIDATE_RET(X != NULL);
    327              MPI_VALIDATE_RET(Y != NULL);
    328          
    329              if (X == Y) {
   \        0xA   0x42A6             CMP      R6,R4
   \        0xC   0xD101             BNE.N    ??mbedtls_mpi_copy_0
    330                  return 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE048             B.N      ??mbedtls_mpi_copy_1
    331              }
    332          
    333              if (Y->n == 0) {
   \                     ??mbedtls_mpi_copy_0: (+1)
   \       0x12   0x88E0             LDRH     R0,[R4, #+6]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD111             BNE.N    ??mbedtls_mpi_copy_2
    334                  if (X->n != 0) {
   \       0x18   0x88F0             LDRH     R0,[R6, #+6]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD00C             BEQ.N    ??mbedtls_mpi_copy_3
    335                      X->s = 1;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x80B0             STRH     R0,[R6, #+4]
    336                      memset(X->p, 0, X->n * ciL);
   \       0x22   0x88F0             LDRH     R0,[R6, #+6]
   \       0x24   0xEA5F 0x0980      LSLS     R9,R0,#+2
   \       0x28   0x2700             MOVS     R7,#+0
   \       0x2A   0xF8D6 0x8000      LDR      R8,[R6, #+0]
   \       0x2E   0x003A             MOVS     R2,R7
   \       0x30   0x4649             MOV      R1,R9
   \       0x32   0x4640             MOV      R0,R8
   \       0x34   0x.... 0x....      BL       __aeabi_memset
    337                  }
    338                  return 0;
   \                     ??mbedtls_mpi_copy_3: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE033             B.N      ??mbedtls_mpi_copy_1
    339              }
    340          
    341              for (i = Y->n - 1; i > 0; i--) {
   \                     ??mbedtls_mpi_copy_2: (+1)
   \       0x3C   0x88E0             LDRH     R0,[R4, #+6]
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \                     ??mbedtls_mpi_copy_4: (+1)
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD006             BEQ.N    ??mbedtls_mpi_copy_5
    342                  if (Y->p[i] != 0) {
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \       0x4A   0x2900             CMP      R1,#+0
   \       0x4C   0xD101             BNE.N    ??mbedtls_mpi_copy_5
    343                      break;
    344                  }
    345              }
   \                     ??mbedtls_mpi_copy_6: (+1)
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0xE7F6             B.N      ??mbedtls_mpi_copy_4
    346              i++;
   \                     ??mbedtls_mpi_copy_5: (+1)
   \       0x52   0x1C40             ADDS     R0,R0,#+1
   \       0x54   0x0007             MOVS     R7,R0
    347          
    348              X->s = Y->s;
   \       0x56   0x88A0             LDRH     R0,[R4, #+4]
   \       0x58   0x80B0             STRH     R0,[R6, #+4]
    349          
    350              if (X->n < i) {
   \       0x5A   0x88F0             LDRH     R0,[R6, #+6]
   \       0x5C   0x42B8             CMP      R0,R7
   \       0x5E   0xD207             BCS.N    ??mbedtls_mpi_copy_7
    351                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, i));
   \       0x60   0x0039             MOVS     R1,R7
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x68   0x0005             MOVS     R5,R0
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD119             BNE.N    ??mbedtls_mpi_copy_8
   \                     ??mbedtls_mpi_copy_9: (+1)
   \       0x6E   0xE00D             B.N      ??mbedtls_mpi_copy_10
    352              } else {
    353                  memset(X->p + i, 0, (X->n - i) * ciL);
   \                     ??mbedtls_mpi_copy_7: (+1)
   \       0x70   0x88F0             LDRH     R0,[R6, #+6]
   \       0x72   0x1BC0             SUBS     R0,R0,R7
   \       0x74   0xEA5F 0x0880      LSLS     R8,R0,#+2
   \       0x78   0xF05F 0x0900      MOVS     R9,#+0
   \       0x7C   0x6830             LDR      R0,[R6, #+0]
   \       0x7E   0xEB00 0x0A87      ADD      R10,R0,R7, LSL #+2
   \       0x82   0x464A             MOV      R2,R9
   \       0x84   0x4641             MOV      R1,R8
   \       0x86   0x4650             MOV      R0,R10
   \       0x88   0x.... 0x....      BL       __aeabi_memset
    354              }
    355          
    356              memcpy(X->p, Y->p, i * ciL);
   \                     ??mbedtls_mpi_copy_10: (+1)
   \       0x8C   0xEA5F 0x0A87      LSLS     R10,R7,#+2
   \       0x90   0xF8D4 0x8000      LDR      R8,[R4, #+0]
   \       0x94   0xF8D6 0x9000      LDR      R9,[R6, #+0]
   \       0x98   0x4652             MOV      R2,R10
   \       0x9A   0x4641             MOV      R1,R8
   \       0x9C   0x4648             MOV      R0,R9
   \       0x9E   0x.... 0x....      BL       __aeabi_memcpy
    357          
    358          cleanup:
    359          
    360              return ret;
   \                     ??mbedtls_mpi_copy_8: (+1)
   \       0xA2   0x0028             MOVS     R0,R5
   \                     ??mbedtls_mpi_copy_1: (+1)
   \       0xA4   0xE8BD 0x87F0      POP      {R4-R10,PC}
    361          }
    362          
    363          /*
    364           * Swap the contents of X and Y
    365           */

   \                                 In section .text, align 2, keep-with-next
    366          void mbedtls_mpi_swap(mbedtls_mpi *X, mbedtls_mpi *Y)
    367          {
   \                     mbedtls_mpi_swap: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    368              mbedtls_mpi T;
    369              MPI_VALIDATE(X != NULL);
    370              MPI_VALIDATE(Y != NULL);
    371          
    372              memcpy(&T,  X, sizeof(mbedtls_mpi));
   \        0x8   0x2608             MOVS     R6,#+8
   \        0xA   0x9400             STR      R4,[SP, #+0]
   \        0xC   0xAF01             ADD      R7,SP,#+4
   \        0xE   0x0032             MOVS     R2,R6
   \       0x10   0x9900             LDR      R1,[SP, #+0]
   \       0x12   0x0038             MOVS     R0,R7
   \       0x14   0x.... 0x....      BL       __aeabi_memcpy
    373              memcpy(X,  Y, sizeof(mbedtls_mpi));
   \       0x18   0xF05F 0x0B08      MOVS     R11,#+8
   \       0x1C   0x002F             MOVS     R7,R5
   \       0x1E   0x46A0             MOV      R8,R4
   \       0x20   0x465A             MOV      R2,R11
   \       0x22   0x0039             MOVS     R1,R7
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x.... 0x....      BL       __aeabi_memcpy
    374              memcpy(Y, &T, sizeof(mbedtls_mpi));
   \       0x2A   0xF05F 0x0808      MOVS     R8,#+8
   \       0x2E   0xF10D 0x0904      ADD      R9,SP,#+4
   \       0x32   0x46AA             MOV      R10,R5
   \       0x34   0x4642             MOV      R2,R8
   \       0x36   0x4649             MOV      R1,R9
   \       0x38   0x4650             MOV      R0,R10
   \       0x3A   0x.... 0x....      BL       __aeabi_memcpy
    375          }
   \       0x3E   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    376          

   \                                 In section .text, align 2, keep-with-next
    377          static inline mbedtls_mpi_uint mpi_sint_abs(mbedtls_mpi_sint z)
    378          {
    379              if (z >= 0) {
   \                     mpi_sint_abs: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD500             BPL.N    ??mpi_sint_abs_0
    380                  return z;
    381              }
    382              /* Take care to handle the most negative value (-2^(biL-1)) correctly.
    383               * A naive -z would have undefined behavior.
    384               * Write this in a way that makes popular compilers happy (GCC, Clang,
    385               * MSVC). */
    386              return (mbedtls_mpi_uint) 0 - (mbedtls_mpi_uint) z;
   \                     ??mpi_sint_abs_1: (+1)
   \        0x4   0x4240             RSBS     R0,R0,#+0
   \                     ??mpi_sint_abs_0: (+1)
   \        0x6   0x4770             BX       LR
    387          }
    388          
    389          /* Convert x to a sign, i.e. to 1, if x is positive, or -1, if x is negative.
    390           * This looks awkward but generates smaller code than (x < 0 ? -1 : 1) */
    391          #define TO_SIGN(x) ((mbedtls_mpi_sint) (((mbedtls_mpi_uint) x) >> (biL - 1)) * -2 + 1)
    392          
    393          /*
    394           * Set value from integer
    395           */

   \                                 In section .text, align 2, keep-with-next
    396          int mbedtls_mpi_lset(mbedtls_mpi *X, mbedtls_mpi_sint z)
    397          {
   \                     mbedtls_mpi_lset: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    398              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x076D      MVNS     R7,#+109
    399              MPI_VALIDATE_RET(X != NULL);
    400          
    401              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, 1));
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x14   0x0006             MOVS     R6,R0
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD116             BNE.N    ??mbedtls_mpi_lset_0
    402              memset(X->p, 0, X->n * ciL);
   \                     ??mbedtls_mpi_lset_1: (+1)
   \       0x1A   0x88E0             LDRH     R0,[R4, #+6]
   \       0x1C   0x0087             LSLS     R7,R0,#+2
   \       0x1E   0xF05F 0x0800      MOVS     R8,#+0
   \       0x22   0xF8D4 0x9000      LDR      R9,[R4, #+0]
   \       0x26   0x4642             MOV      R2,R8
   \       0x28   0x0039             MOVS     R1,R7
   \       0x2A   0x4648             MOV      R0,R9
   \       0x2C   0x.... 0x....      BL       __aeabi_memset
    403          
    404              X->p[0] = mpi_sint_abs(z);
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x.... 0x....      BL       mpi_sint_abs
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x6008             STR      R0,[R1, #+0]
    405              X->s    = TO_SIGN(z);
   \       0x3A   0x0029             MOVS     R1,R5
   \       0x3C   0x0FC9             LSRS     R1,R1,#+31
   \       0x3E   0xF07F 0x0001      MVNS     R0,#+1
   \       0x42   0x4341             MULS     R1,R0,R1
   \       0x44   0x1C49             ADDS     R1,R1,#+1
   \       0x46   0x80A1             STRH     R1,[R4, #+4]
    406          
    407          cleanup:
    408          
    409              return ret;
   \                     ??mbedtls_mpi_lset_0: (+1)
   \       0x48   0x0030             MOVS     R0,R6
   \       0x4A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    410          }
    411          
    412          /*
    413           * Get a specific bit
    414           */

   \                                 In section .text, align 2, keep-with-next
    415          int mbedtls_mpi_get_bit(const mbedtls_mpi *X, size_t pos)
    416          {
   \                     mbedtls_mpi_get_bit: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    417              MPI_VALIDATE_RET(X != NULL);
    418          
    419              if (X->n * biL <= pos) {
   \        0x2   0x88D0             LDRH     R0,[R2, #+6]
   \        0x4   0xEBB1 0x1F40      CMP      R1,R0, LSL #+5
   \        0x8   0xD301             BCC.N    ??mbedtls_mpi_get_bit_0
    420                  return 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE009             B.N      ??mbedtls_mpi_get_bit_1
    421              }
    422          
    423              return (X->p[pos / biL] >> (pos % biL)) & 0x01;
   \                     ??mbedtls_mpi_get_bit_0: (+1)
   \        0xE   0x6812             LDR      R2,[R2, #+0]
   \       0x10   0x0008             MOVS     R0,R1
   \       0x12   0x0940             LSRS     R0,R0,#+5
   \       0x14   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \       0x18   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x1C   0x40C8             LSRS     R0,R0,R1
   \       0x1E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \                     ??mbedtls_mpi_get_bit_1: (+1)
   \       0x22   0x4770             BX       LR
    424          }
    425          
    426          /*
    427           * Set a bit to a specific value of 0 or 1
    428           */

   \                                 In section .text, align 2, keep-with-next
    429          int mbedtls_mpi_set_bit(mbedtls_mpi *X, size_t pos, unsigned char val)
    430          {
   \                     mbedtls_mpi_set_bit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    431              int ret = 0;
   \        0xA   0x2700             MOVS     R7,#+0
    432              size_t off = pos / biL;
   \        0xC   0x46A8             MOV      R8,R5
   \        0xE   0xEA5F 0x1858      LSRS     R8,R8,#+5
    433              size_t idx = pos % biL;
   \       0x12   0xF015 0x091F      ANDS     R9,R5,#0x1F
    434              MPI_VALIDATE_RET(X != NULL);
    435          
    436              if (val != 0 && val != 1) {
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD006             BEQ.N    ??mbedtls_mpi_set_bit_0
   \       0x1E   0x0030             MOVS     R0,R6
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD002             BEQ.N    ??mbedtls_mpi_set_bit_0
    437                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x26   0xF07F 0x0003      MVNS     R0,#+3
   \       0x2A   0xE027             B.N      ??mbedtls_mpi_set_bit_1
    438              }
    439          
    440              if (X->n * biL <= pos) {
   \                     ??mbedtls_mpi_set_bit_0: (+1)
   \       0x2C   0x88E0             LDRH     R0,[R4, #+6]
   \       0x2E   0xEBB5 0x1F40      CMP      R5,R0, LSL #+5
   \       0x32   0xD30D             BCC.N    ??mbedtls_mpi_set_bit_2
    441                  if (val == 0) {
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD101             BNE.N    ??mbedtls_mpi_set_bit_3
    442                      return 0;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xE01D             B.N      ??mbedtls_mpi_set_bit_1
    443                  }
    444          
    445                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, off + 1));
   \                     ??mbedtls_mpi_set_bit_3: (+1)
   \       0x40   0xF118 0x0101      ADDS     R1,R8,#+1
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x4A   0x0007             MOVS     R7,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD114             BNE.N    ??mbedtls_mpi_set_bit_4
    446              }
    447          
    448              X->p[off] &= ~((mbedtls_mpi_uint) 0x01 << idx);
   \                     ??mbedtls_mpi_set_bit_5: (+1)
   \                     ??mbedtls_mpi_set_bit_2: (+1)
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \       0x56   0x2101             MOVS     R1,#+1
   \       0x58   0xFA11 0xF109      LSLS     R1,R1,R9
   \       0x5C   0x4388             BICS     R0,R0,R1
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0xF841 0x0028      STR      R0,[R1, R8, LSL #+2]
    449              X->p[off] |= (mbedtls_mpi_uint) val << idx;
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \       0x6A   0x0031             MOVS     R1,R6
   \       0x6C   0xB2C9             UXTB     R1,R1
   \       0x6E   0xFA11 0xF109      LSLS     R1,R1,R9
   \       0x72   0x4308             ORRS     R0,R1,R0
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0xF841 0x0028      STR      R0,[R1, R8, LSL #+2]
    450          
    451          cleanup:
    452          
    453              return ret;
   \                     ??mbedtls_mpi_set_bit_4: (+1)
   \       0x7A   0x0038             MOVS     R0,R7
   \                     ??mbedtls_mpi_set_bit_1: (+1)
   \       0x7C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    454          }
    455          
    456          /*
    457           * Return the number of less significant zero-bits
    458           */

   \                                 In section .text, align 2, keep-with-next
    459          size_t mbedtls_mpi_lsb(const mbedtls_mpi *X)
    460          {
   \                     mbedtls_mpi_lsb: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    461              size_t i;
    462              MBEDTLS_INTERNAL_VALIDATE_RET(X != NULL, 0);
    463          
    464          #if defined(__has_builtin)
    465          #if (MBEDTLS_MPI_UINT_MAX == UINT_MAX) && __has_builtin(__builtin_ctz)
    466              #define mbedtls_mpi_uint_ctz __builtin_ctz
    467          #elif (MBEDTLS_MPI_UINT_MAX == ULONG_MAX) && __has_builtin(__builtin_ctzl)
    468              #define mbedtls_mpi_uint_ctz __builtin_ctzl
    469          #elif (MBEDTLS_MPI_UINT_MAX == ULLONG_MAX) && __has_builtin(__builtin_ctzll)
    470              #define mbedtls_mpi_uint_ctz __builtin_ctzll
    471          #endif
    472          #endif
    473          
    474          #if defined(mbedtls_mpi_uint_ctz)
    475              for (i = 0; i < X->n; i++) {
   \        0x2   0x2200             MOVS     R2,#+0
   \                     ??mbedtls_mpi_lsb_0: (+1)
   \        0x4   0x88C8             LDRH     R0,[R1, #+6]
   \        0x6   0x4282             CMP      R2,R0
   \        0x8   0xD210             BCS.N    ??mbedtls_mpi_lsb_1
    476                  if (X->p[i] != 0) {
   \        0xA   0x6808             LDR      R0,[R1, #+0]
   \        0xC   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD009             BEQ.N    ??mbedtls_mpi_lsb_2
    477                      return i * biL + mbedtls_mpi_uint_ctz(X->p[i]);
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \       0x1A   0xFA90 0xF0A0      RBIT     R0,R0
   \       0x1E   0xFAB0 0xF080      CLZ      R0,R0
   \       0x22   0xEB10 0x1042      ADDS     R0,R0,R2, LSL #+5
   \       0x26   0xE002             B.N      ??mbedtls_mpi_lsb_3
    478                  }
    479              }
   \                     ??mbedtls_mpi_lsb_2: (+1)
   \       0x28   0x1C52             ADDS     R2,R2,#+1
   \       0x2A   0xE7EB             B.N      ??mbedtls_mpi_lsb_0
    480          #else
    481              size_t count = 0;
    482              for (i = 0; i < X->n; i++) {
    483                  for (size_t j = 0; j < biL; j++, count++) {
    484                      if (((X->p[i] >> j) & 1) != 0) {
    485                          return count;
    486                      }
    487                  }
    488              }
    489          #endif
    490          
    491              return 0;
   \                     ??mbedtls_mpi_lsb_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_mpi_lsb_3: (+1)
   \       0x2E   0x4770             BX       LR
    492          }
    493          
    494          /*
    495           * Return the number of bits
    496           */

   \                                 In section .text, align 2, keep-with-next
    497          size_t mbedtls_mpi_bitlen(const mbedtls_mpi *X)
    498          {
   \                     mbedtls_mpi_bitlen: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    499              return mbedtls_mpi_core_bitlen(X->p, X->n);
   \        0x4   0x88E1             LDRH     R1,[R4, #+6]
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x.... 0x....      BL       mbedtls_mpi_core_bitlen
   \        0xC   0xBD10             POP      {R4,PC}
    500          }
    501          
    502          /*
    503           * Return the total size in bytes
    504           */

   \                                 In section .text, align 2, keep-with-next
    505          size_t mbedtls_mpi_size(const mbedtls_mpi *X)
    506          {
   \                     mbedtls_mpi_size: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    507              return (mbedtls_mpi_bitlen(X) + 7) >> 3;
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \        0xA   0x1DC0             ADDS     R0,R0,#+7
   \        0xC   0x08C0             LSRS     R0,R0,#+3
   \        0xE   0xBD10             POP      {R4,PC}
    508          }
    509          
    510          /*
    511           * Convert an ASCII character to digit value
    512           */

   \                                 In section .text, align 2, keep-with-next
    513          static int mpi_get_digit(mbedtls_mpi_uint *d, int radix, char c)
    514          {
   \                     mpi_get_digit: (+1)
   \        0x0   0x0003             MOVS     R3,R0
    515              *d = 255;
   \        0x2   0x20FF             MOVS     R0,#+255
   \        0x4   0x6018             STR      R0,[R3, #+0]
    516          
    517              if (c >= 0x30 && c <= 0x39) {
   \        0x6   0x0010             MOVS     R0,R2
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x2830             CMP      R0,#+48
   \        0xC   0xDB07             BLT.N    ??mpi_get_digit_0
   \        0xE   0x0010             MOVS     R0,R2
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x283A             CMP      R0,#+58
   \       0x14   0xDA03             BGE.N    ??mpi_get_digit_0
    518                  *d = c - 0x30;
   \       0x16   0x0010             MOVS     R0,R2
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x3830             SUBS     R0,R0,#+48
   \       0x1C   0x6018             STR      R0,[R3, #+0]
    519              }
    520              if (c >= 0x41 && c <= 0x46) {
   \                     ??mpi_get_digit_0: (+1)
   \       0x1E   0x0010             MOVS     R0,R2
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2841             CMP      R0,#+65
   \       0x24   0xDB07             BLT.N    ??mpi_get_digit_1
   \       0x26   0x0010             MOVS     R0,R2
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x2847             CMP      R0,#+71
   \       0x2C   0xDA03             BGE.N    ??mpi_get_digit_1
    521                  *d = c - 0x37;
   \       0x2E   0x0010             MOVS     R0,R2
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x3837             SUBS     R0,R0,#+55
   \       0x34   0x6018             STR      R0,[R3, #+0]
    522              }
    523              if (c >= 0x61 && c <= 0x66) {
   \                     ??mpi_get_digit_1: (+1)
   \       0x36   0x0010             MOVS     R0,R2
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0x2861             CMP      R0,#+97
   \       0x3C   0xDB07             BLT.N    ??mpi_get_digit_2
   \       0x3E   0x0010             MOVS     R0,R2
   \       0x40   0xB2C0             UXTB     R0,R0
   \       0x42   0x2867             CMP      R0,#+103
   \       0x44   0xDA03             BGE.N    ??mpi_get_digit_2
    524                  *d = c - 0x57;
   \       0x46   0x0010             MOVS     R0,R2
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0x3857             SUBS     R0,R0,#+87
   \       0x4C   0x6018             STR      R0,[R3, #+0]
    525              }
    526          
    527              if (*d >= (mbedtls_mpi_uint) radix) {
   \                     ??mpi_get_digit_2: (+1)
   \       0x4E   0x6818             LDR      R0,[R3, #+0]
   \       0x50   0x4288             CMP      R0,R1
   \       0x52   0xD302             BCC.N    ??mpi_get_digit_3
    528                  return MBEDTLS_ERR_MPI_INVALID_CHARACTER;
   \       0x54   0xF07F 0x0005      MVNS     R0,#+5
   \       0x58   0xE000             B.N      ??mpi_get_digit_4
    529              }
    530          
    531              return 0;
   \                     ??mpi_get_digit_3: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \                     ??mpi_get_digit_4: (+1)
   \       0x5C   0x4770             BX       LR
    532          }
    533          
    534          /*
    535           * Import from an ASCII string
    536           */

   \                                 In section .text, align 2, keep-with-next
    537          int mbedtls_mpi_read_string(mbedtls_mpi *X, int radix, const char *s)
    538          {
   \                     mbedtls_mpi_read_string: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x4690             MOV      R8,R2
    539              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x006D      MVNS     R0,#+109
   \       0x10   0x9004             STR      R0,[SP, #+16]
    540              size_t i, j, slen, n;
    541              int sign = 1;
   \       0x12   0x2701             MOVS     R7,#+1
    542              mbedtls_mpi_uint d;
    543              mbedtls_mpi T;
    544              MPI_VALIDATE_RET(X != NULL);
    545              MPI_VALIDATE_RET(s != NULL);
    546          
    547              if (radix < 2 || radix > 16) {
   \       0x14   0x2E02             CMP      R6,#+2
   \       0x16   0xDB01             BLT.N    ??mbedtls_mpi_read_string_0
   \       0x18   0x2E11             CMP      R6,#+17
   \       0x1A   0xDB02             BLT.N    ??mbedtls_mpi_read_string_1
    548                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \                     ??mbedtls_mpi_read_string_0: (+1)
   \       0x1C   0xF07F 0x0003      MVNS     R0,#+3
   \       0x20   0xE096             B.N      ??mbedtls_mpi_read_string_2
    549              }
    550          
    551              mbedtls_mpi_init(&T);
   \                     ??mbedtls_mpi_read_string_1: (+1)
   \       0x22   0xA802             ADD      R0,SP,#+8
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_init
    552          
    553              if (s[0] == 0) {
   \       0x28   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD104             BNE.N    ??mbedtls_mpi_read_string_3
    554                  mbedtls_mpi_free(X);
   \       0x30   0x4658             MOV      R0,R11
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_free
    555                  return 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE08A             B.N      ??mbedtls_mpi_read_string_2
    556              }
    557          
    558              if (s[0] == '-') {
   \                     ??mbedtls_mpi_read_string_3: (+1)
   \       0x3A   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x3E   0x282D             CMP      R0,#+45
   \       0x40   0xD104             BNE.N    ??mbedtls_mpi_read_string_4
    559                  ++s;
   \       0x42   0xF118 0x0801      ADDS     R8,R8,#+1
    560                  sign = -1;
   \       0x46   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x4A   0x0007             MOVS     R7,R0
    561              }
    562          
    563              slen = strlen(s);
   \                     ??mbedtls_mpi_read_string_4: (+1)
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0x.... 0x....      BL       strlen
   \       0x52   0x4681             MOV      R9,R0
    564          
    565              if (radix == 16) {
   \       0x54   0x2E10             CMP      R6,#+16
   \       0x56   0xD146             BNE.N    ??mbedtls_mpi_read_string_5
    566                  if (slen > SIZE_MAX >> 2) {
   \       0x58   0xF1B9 0x4F80      CMP      R9,#+1073741824
   \       0x5C   0xD302             BCC.N    ??mbedtls_mpi_read_string_6
    567                      return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x5E   0xF07F 0x0003      MVNS     R0,#+3
   \       0x62   0xE075             B.N      ??mbedtls_mpi_read_string_2
    568                  }
    569          
    570                  n = BITS_TO_LIMBS(slen << 2);
   \                     ??mbedtls_mpi_read_string_6: (+1)
   \       0x64   0xEA5F 0x0089      LSLS     R0,R9,#+2
   \       0x68   0xF010 0x0F1F      TST      R0,#0x1F
   \       0x6C   0xD001             BEQ.N    ??mbedtls_mpi_read_string_7
   \       0x6E   0x2101             MOVS     R1,#+1
   \       0x70   0xE000             B.N      ??mbedtls_mpi_read_string_8
   \                     ??mbedtls_mpi_read_string_7: (+1)
   \       0x72   0x2100             MOVS     R1,#+0
   \                     ??mbedtls_mpi_read_string_8: (+1)
   \       0x74   0xEA5F 0x0089      LSLS     R0,R9,#+2
   \       0x78   0x0940             LSRS     R0,R0,#+5
   \       0x7A   0xFA50 0xF081      UXTAB    R0,R0,R1
   \       0x7E   0x9001             STR      R0,[SP, #+4]
    571          
    572                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, n));
   \       0x80   0x9901             LDR      R1,[SP, #+4]
   \       0x82   0x4658             MOV      R0,R11
   \       0x84   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x88   0x4682             MOV      R10,R0
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD15C             BNE.N    ??mbedtls_mpi_read_string_9
    573                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, 0));
   \                     ??mbedtls_mpi_read_string_10: (+1)
   \       0x8E   0x2100             MOVS     R1,#+0
   \       0x90   0x4658             MOV      R0,R11
   \       0x92   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x96   0x4682             MOV      R10,R0
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD155             BNE.N    ??mbedtls_mpi_read_string_9
    574          
    575                  for (i = slen, j = 0; i > 0; i--, j++) {
   \                     ??mbedtls_mpi_read_string_11: (+1)
   \       0x9C   0x464C             MOV      R4,R9
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x0005             MOVS     R5,R0
   \                     ??mbedtls_mpi_read_string_12: (+1)
   \       0xA2   0x2C00             CMP      R4,#+0
   \       0xA4   0xD045             BEQ.N    ??mbedtls_mpi_read_string_13
    576                      MBEDTLS_MPI_CHK(mpi_get_digit(&d, radix, s[i - 1]));
   \       0xA6   0xEB08 0x0004      ADD      R0,R8,R4
   \       0xAA   0xF810 0x2C01      LDRB     R2,[R0, #-1]
   \       0xAE   0x0031             MOVS     R1,R6
   \       0xB0   0x4668             MOV      R0,SP
   \       0xB2   0x.... 0x....      BL       mpi_get_digit
   \       0xB6   0x4682             MOV      R10,R0
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD145             BNE.N    ??mbedtls_mpi_read_string_9
    577                      X->p[j / (2 * ciL)] |= d << ((j % (2 * ciL)) << 2);
   \                     ??mbedtls_mpi_read_string_14: (+1)
   \       0xBC   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \       0xC0   0x0028             MOVS     R0,R5
   \       0xC2   0x08C0             LSRS     R0,R0,#+3
   \       0xC4   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0xC8   0x9A00             LDR      R2,[SP, #+0]
   \       0xCA   0x00A9             LSLS     R1,R5,#+2
   \       0xCC   0xF011 0x011C      ANDS     R1,R1,#0x1C
   \       0xD0   0x408A             LSLS     R2,R2,R1
   \       0xD2   0x4310             ORRS     R0,R2,R0
   \       0xD4   0xF8DB 0x2000      LDR      R2,[R11, #+0]
   \       0xD8   0x0029             MOVS     R1,R5
   \       0xDA   0x08C9             LSRS     R1,R1,#+3
   \       0xDC   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    578                  }
   \       0xE0   0x1E64             SUBS     R4,R4,#+1
   \       0xE2   0x1C6D             ADDS     R5,R5,#+1
   \       0xE4   0xE7DD             B.N      ??mbedtls_mpi_read_string_12
    579              } else {
    580                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, 0));
   \                     ??mbedtls_mpi_read_string_5: (+1)
   \       0xE6   0x2100             MOVS     R1,#+0
   \       0xE8   0x4658             MOV      R0,R11
   \       0xEA   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xEE   0x4682             MOV      R10,R0
   \       0xF0   0x2800             CMP      R0,#+0
   \       0xF2   0xD129             BNE.N    ??mbedtls_mpi_read_string_9
    581          
    582                  for (i = 0; i < slen; i++) {
   \                     ??mbedtls_mpi_read_string_15: (+1)
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x0004             MOVS     R4,R0
   \                     ??mbedtls_mpi_read_string_16: (+1)
   \       0xF8   0x454C             CMP      R4,R9
   \       0xFA   0xD21A             BCS.N    ??mbedtls_mpi_read_string_13
    583                      MBEDTLS_MPI_CHK(mpi_get_digit(&d, radix, s[i]));
   \       0xFC   0xF818 0x2004      LDRB     R2,[R8, R4]
   \      0x100   0x0031             MOVS     R1,R6
   \      0x102   0x4668             MOV      R0,SP
   \      0x104   0x.... 0x....      BL       mpi_get_digit
   \      0x108   0x4682             MOV      R10,R0
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD11C             BNE.N    ??mbedtls_mpi_read_string_9
    584                      MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T, X, radix));
   \                     ??mbedtls_mpi_read_string_17: (+1)
   \      0x10E   0x0032             MOVS     R2,R6
   \      0x110   0x4659             MOV      R1,R11
   \      0x112   0xA802             ADD      R0,SP,#+8
   \      0x114   0x.... 0x....      BL       mbedtls_mpi_mul_int
   \      0x118   0x4682             MOV      R10,R0
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD114             BNE.N    ??mbedtls_mpi_read_string_9
    585                      MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(X, &T, d));
   \                     ??mbedtls_mpi_read_string_18: (+1)
   \      0x11E   0x9A00             LDR      R2,[SP, #+0]
   \      0x120   0xA902             ADD      R1,SP,#+8
   \      0x122   0x4658             MOV      R0,R11
   \      0x124   0x.... 0x....      BL       mbedtls_mpi_add_int
   \      0x128   0x4682             MOV      R10,R0
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD10C             BNE.N    ??mbedtls_mpi_read_string_9
    586                  }
   \                     ??mbedtls_mpi_read_string_19: (+1)
   \      0x12E   0x1C64             ADDS     R4,R4,#+1
   \      0x130   0xE7E2             B.N      ??mbedtls_mpi_read_string_16
    587              }
    588          
    589              if (sign < 0 && mbedtls_mpi_bitlen(X) != 0) {
   \                     ??mbedtls_mpi_read_string_13: (+1)
   \      0x132   0x2F00             CMP      R7,#+0
   \      0x134   0xD508             BPL.N    ??mbedtls_mpi_read_string_9
   \      0x136   0x4658             MOV      R0,R11
   \      0x138   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \      0x13C   0x2800             CMP      R0,#+0
   \      0x13E   0xD003             BEQ.N    ??mbedtls_mpi_read_string_9
    590                  X->s = -1;
   \      0x140   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x144   0xF8AB 0x0004      STRH     R0,[R11, #+4]
    591              }
    592          
    593          cleanup:
    594          
    595              mbedtls_mpi_free(&T);
   \                     ??mbedtls_mpi_read_string_9: (+1)
   \      0x148   0xA802             ADD      R0,SP,#+8
   \      0x14A   0x.... 0x....      BL       mbedtls_mpi_free
    596          
    597              return ret;
   \      0x14E   0x4650             MOV      R0,R10
   \                     ??mbedtls_mpi_read_string_2: (+1)
   \      0x150   0xB005             ADD      SP,SP,#+20
   \      0x152   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    598          }
    599          
    600          /*
    601           * Helper to write the digits high-order first.
    602           */

   \                                 In section .text, align 2, keep-with-next
    603          static int mpi_write_hlp(mbedtls_mpi *X, int radix,
    604                                   char **p, const size_t buflen)
    605          {
   \                     mpi_write_hlp: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
    606              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
    607              mbedtls_mpi_uint r;
    608              size_t length = 0;
   \       0x10   0xF05F 0x0800      MOVS     R8,#+0
    609              char *p_end = *p + buflen;
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0xEB00 0x0906      ADD      R9,R0,R6
    610          
    611              do {
    612                  if (length >= buflen) {
   \                     ??mpi_write_hlp_0: (+1)
   \       0x1A   0x45B0             CMP      R8,R6
   \       0x1C   0xD302             BCC.N    ??mpi_write_hlp_1
    613                      return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
   \       0x1E   0xF07F 0x0007      MVNS     R0,#+7
   \       0x22   0xE037             B.N      ??mpi_write_hlp_2
    614                  }
    615          
    616                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_int(&r, X, radix));
   \                     ??mpi_write_hlp_1: (+1)
   \       0x24   0x0022             MOVS     R2,R4
   \       0x26   0x4651             MOV      R1,R10
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_mod_int
   \       0x2E   0x0007             MOVS     R7,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD12E             BNE.N    ??mpi_write_hlp_3
    617                  MBEDTLS_MPI_CHK(mbedtls_mpi_div_int(X, NULL, X, radix));
   \                     ??mpi_write_hlp_4: (+1)
   \       0x34   0x0023             MOVS     R3,R4
   \       0x36   0x4652             MOV      R2,R10
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0x4650             MOV      R0,R10
   \       0x3C   0x.... 0x....      BL       mbedtls_mpi_div_int
   \       0x40   0x0007             MOVS     R7,R0
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD125             BNE.N    ??mpi_write_hlp_3
    618                  /*
    619                   * Write the residue in the current position, as an ASCII character.
    620                   */
    621                  if (r < 0xA) {
   \                     ??mpi_write_hlp_5: (+1)
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0x280A             CMP      R0,#+10
   \       0x4A   0xD206             BCS.N    ??mpi_write_hlp_6
    622                      *(--p_end) = (char) ('0' + r);
   \       0x4C   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \       0x50   0x9800             LDR      R0,[SP, #+0]
   \       0x52   0x3030             ADDS     R0,R0,#+48
   \       0x54   0xF889 0x0000      STRB     R0,[R9, #+0]
   \       0x58   0xE005             B.N      ??mpi_write_hlp_7
    623                  } else {
    624                      *(--p_end) = (char) ('A' + (r - 0xA));
   \                     ??mpi_write_hlp_6: (+1)
   \       0x5A   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \       0x5E   0x9800             LDR      R0,[SP, #+0]
   \       0x60   0x3037             ADDS     R0,R0,#+55
   \       0x62   0xF889 0x0000      STRB     R0,[R9, #+0]
    625                  }
    626          
    627                  length++;
   \                     ??mpi_write_hlp_7: (+1)
   \       0x66   0xF118 0x0801      ADDS     R8,R8,#+1
    628              } while (mbedtls_mpi_cmp_int(X, 0) != 0);
   \       0x6A   0x2100             MOVS     R1,#+0
   \       0x6C   0x4650             MOV      R0,R10
   \       0x6E   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD1D1             BNE.N    ??mpi_write_hlp_0
    629          
    630              memmove(*p, p_end, length);
   \       0x76   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x7A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x7E   0xF8D5 0xB000      LDR      R11,[R5, #+0]
   \       0x82   0x9A02             LDR      R2,[SP, #+8]
   \       0x84   0x9901             LDR      R1,[SP, #+4]
   \       0x86   0x4658             MOV      R0,R11
   \       0x88   0x.... 0x....      BL       __aeabi_memmove
    631              *p += length;
   \       0x8C   0x6828             LDR      R0,[R5, #+0]
   \       0x8E   0x4440             ADD      R0,R0,R8
   \       0x90   0x6028             STR      R0,[R5, #+0]
    632          
    633          cleanup:
    634          
    635              return ret;
   \                     ??mpi_write_hlp_3: (+1)
   \       0x92   0x0038             MOVS     R0,R7
   \                     ??mpi_write_hlp_2: (+1)
   \       0x94   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    636          }
    637          
    638          /*
    639           * Export into an ASCII string
    640           */

   \                                 In section .text, align 2, keep-with-next
    641          int mbedtls_mpi_write_string(const mbedtls_mpi *X, int radix,
    642                                       char *buf, size_t buflen, size_t *olen)
    643          {
   \                     mbedtls_mpi_write_string: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0C             LDR      R7,[SP, #+48]
    644              int ret = 0;
   \        0xE   0xF05F 0x0800      MOVS     R8,#+0
    645              size_t n;
    646              char *p;
    647              mbedtls_mpi T;
    648              MPI_VALIDATE_RET(X    != NULL);
    649              MPI_VALIDATE_RET(olen != NULL);
    650              MPI_VALIDATE_RET(buflen == 0 || buf != NULL);
    651          
    652              if (radix < 2 || radix > 16) {
   \       0x12   0x2C02             CMP      R4,#+2
   \       0x14   0xDB01             BLT.N    ??mbedtls_mpi_write_string_0
   \       0x16   0x2C11             CMP      R4,#+17
   \       0x18   0xDB02             BLT.N    ??mbedtls_mpi_write_string_1
    653                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \                     ??mbedtls_mpi_write_string_0: (+1)
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE09A             B.N      ??mbedtls_mpi_write_string_2
    654              }
    655          
    656              n = mbedtls_mpi_bitlen(X);   /* Number of bits necessary to present `n`. */
   \                     ??mbedtls_mpi_write_string_1: (+1)
   \       0x20   0x4650             MOV      R0,R10
   \       0x22   0x.... 0x....      BL       mbedtls_mpi_bitlen
    657              if (radix >=  4) {
   \       0x26   0x2C04             CMP      R4,#+4
   \       0x28   0xDB00             BLT.N    ??mbedtls_mpi_write_string_3
    658                  n >>= 1;                 /* Number of 4-adic digits necessary to present
   \       0x2A   0x0840             LSRS     R0,R0,#+1
    659                                            * `n`. If radix > 4, this might be a strict
    660                                            * overapproximation of the number of
    661                                            * radix-adic digits needed to present `n`. */
    662              }
    663              if (radix >= 16) {
   \                     ??mbedtls_mpi_write_string_3: (+1)
   \       0x2C   0x2C10             CMP      R4,#+16
   \       0x2E   0xDB00             BLT.N    ??mbedtls_mpi_write_string_4
    664                  n >>= 1;                 /* Number of hexadecimal digits necessary to
   \       0x30   0x0840             LSRS     R0,R0,#+1
    665                                            * present `n`. */
    666          
    667              }
    668              n += 1; /* Terminating null byte */
   \                     ??mbedtls_mpi_write_string_4: (+1)
   \       0x32   0x1C40             ADDS     R0,R0,#+1
    669              n += 1; /* Compensate for the divisions above, which round down `n`
   \       0x34   0x1C40             ADDS     R0,R0,#+1
    670                       * in case it's not even. */
    671              n += 1; /* Potential '-'-sign. */
   \       0x36   0x1C40             ADDS     R0,R0,#+1
    672              n += (n & 1);   /* Make n even to have enough space for hexadecimal writing,
   \       0x38   0xF010 0x0101      ANDS     R1,R0,#0x1
   \       0x3C   0x1808             ADDS     R0,R1,R0
   \       0x3E   0x4681             MOV      R9,R0
    673                               * which always uses an even number of hex-digits. */
    674          
    675              if (buflen < n) {
   \       0x40   0x454E             CMP      R6,R9
   \       0x42   0xD204             BCS.N    ??mbedtls_mpi_write_string_5
    676                  *olen = n;
   \       0x44   0xF8C7 0x9000      STR      R9,[R7, #+0]
    677                  return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
   \       0x48   0xF07F 0x0007      MVNS     R0,#+7
   \       0x4C   0xE083             B.N      ??mbedtls_mpi_write_string_2
    678              }
    679          
    680              p = buf;
   \                     ??mbedtls_mpi_write_string_5: (+1)
   \       0x4E   0x9500             STR      R5,[SP, #+0]
    681              mbedtls_mpi_init(&T);
   \       0x50   0xA801             ADD      R0,SP,#+4
   \       0x52   0x.... 0x....      BL       mbedtls_mpi_init
    682          
    683              if (X->s == -1) {
   \       0x56   0xF9BA 0x0004      LDRSH    R0,[R10, #+4]
   \       0x5A   0xF110 0x0F01      CMN      R0,#+1
   \       0x5E   0xD106             BNE.N    ??mbedtls_mpi_write_string_6
    684                  *p++ = '-';
   \       0x60   0x212D             MOVS     R1,#+45
   \       0x62   0x9800             LDR      R0,[SP, #+0]
   \       0x64   0x7001             STRB     R1,[R0, #+0]
   \       0x66   0x9800             LDR      R0,[SP, #+0]
   \       0x68   0x1C40             ADDS     R0,R0,#+1
   \       0x6A   0x9000             STR      R0,[SP, #+0]
    685                  buflen--;
   \       0x6C   0x1E76             SUBS     R6,R6,#+1
    686              }
    687          
    688              if (radix == 16) {
   \                     ??mbedtls_mpi_write_string_6: (+1)
   \       0x6E   0x2C10             CMP      R4,#+16
   \       0x70   0xD14C             BNE.N    ??mbedtls_mpi_write_string_7
    689                  int c;
    690                  size_t i, j, k;
    691          
    692                  for (i = X->n, k = 0; i > 0; i--) {
   \       0x72   0xF8BA 0x3006      LDRH     R3,[R10, #+6]
   \       0x76   0x2200             MOVS     R2,#+0
   \                     ??mbedtls_mpi_write_string_8: (+1)
   \       0x78   0x2B00             CMP      R3,#+0
   \       0x7A   0xD05F             BEQ.N    ??mbedtls_mpi_write_string_9
    693                      for (j = ciL; j > 0; j--) {
   \       0x7C   0xF05F 0x0C04      MOVS     R12,#+4
   \       0x80   0x4661             MOV      R1,R12
   \                     ??mbedtls_mpi_write_string_10: (+1)
   \       0x82   0x2900             CMP      R1,#+0
   \       0x84   0xD040             BEQ.N    ??mbedtls_mpi_write_string_11
    694                          c = (X->p[i - 1] >> ((j - 1) << 3)) & 0xFF;
   \       0x86   0xF8DA 0xC000      LDR      R12,[R10, #+0]
   \       0x8A   0xEB0C 0x0C83      ADD      R12,R12,R3, LSL #+2
   \       0x8E   0xF85C 0xEC04      LDR      LR,[R12, #-4]
   \       0x92   0xF111 0x0CFF      ADDS     R12,R1,#+255
   \       0x96   0xEA5F 0x0CCC      LSLS     R12,R12,#+3
   \       0x9A   0xFA3E 0xFE0C      LSRS     LR,LR,R12
   \       0x9E   0xF00E 0x0EFF      AND      LR,LR,#0xFF
   \       0xA2   0x4670             MOV      R0,LR
    695          
    696                          if (c == 0 && k == 0 && (i + j) != 2) {
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD106             BNE.N    ??mbedtls_mpi_write_string_12
   \       0xA8   0x2A00             CMP      R2,#+0
   \       0xAA   0xD104             BNE.N    ??mbedtls_mpi_write_string_12
   \       0xAC   0xEB11 0x0C03      ADDS     R12,R1,R3
   \       0xB0   0xF1BC 0x0F02      CMP      R12,#+2
   \       0xB4   0xD126             BNE.N    ??mbedtls_mpi_write_string_13
    697                              continue;
    698                          }
    699          
    700                          *(p++) = "0123456789ABCDEF" [c / 16];
   \                     ??mbedtls_mpi_write_string_12: (+1)
   \       0xB6   0x.... 0x....      LDR.W    R11,??DataTable1_1
   \       0xBA   0xF05F 0x0C10      MOVS     R12,#+16
   \       0xBE   0xFB90 0xFCFC      SDIV     R12,R0,R12
   \       0xC2   0xF81B 0xC00C      LDRB     R12,[R11, R12]
   \       0xC6   0xF8DD 0xE000      LDR      LR,[SP, #+0]
   \       0xCA   0xF88E 0xC000      STRB     R12,[LR, #+0]
   \       0xCE   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0xD2   0xF11C 0x0E01      ADDS     LR,R12,#+1
   \       0xD6   0xF8CD 0xE000      STR      LR,[SP, #+0]
    701                          *(p++) = "0123456789ABCDEF" [c % 16];
   \       0xDA   0xF05F 0x0E10      MOVS     LR,#+16
   \       0xDE   0xFB90 0xFCFE      SDIV     R12,R0,LR
   \       0xE2   0xFB0E 0x0E1C      MLS      LR,LR,R12,R0
   \       0xE6   0xF81B 0xE00E      LDRB     LR,[R11, LR]
   \       0xEA   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0xEE   0xF88C 0xE000      STRB     LR,[R12, #+0]
   \       0xF2   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0xF6   0xF11C 0x0E01      ADDS     LR,R12,#+1
   \       0xFA   0xF8CD 0xE000      STR      LR,[SP, #+0]
    702                          k = 1;
   \       0xFE   0xF05F 0x0C01      MOVS     R12,#+1
   \      0x102   0x4662             MOV      R2,R12
    703                      }
   \                     ??mbedtls_mpi_write_string_13: (+1)
   \      0x104   0x1E49             SUBS     R1,R1,#+1
   \      0x106   0xE7BC             B.N      ??mbedtls_mpi_write_string_10
    704                  }
   \                     ??mbedtls_mpi_write_string_11: (+1)
   \      0x108   0x1E5B             SUBS     R3,R3,#+1
   \      0x10A   0xE7B5             B.N      ??mbedtls_mpi_write_string_8
    705              } else {
    706                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&T, X));
   \                     ??mbedtls_mpi_write_string_7: (+1)
   \      0x10C   0x4651             MOV      R1,R10
   \      0x10E   0xA801             ADD      R0,SP,#+4
   \      0x110   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x114   0x4680             MOV      R8,R0
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD119             BNE.N    ??mbedtls_mpi_write_string_14
    707          
    708                  if (T.s == -1) {
   \                     ??mbedtls_mpi_write_string_15: (+1)
   \      0x11A   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \      0x11E   0xF110 0x0F01      CMN      R0,#+1
   \      0x122   0xD102             BNE.N    ??mbedtls_mpi_write_string_16
    709                      T.s = 1;
   \      0x124   0x2001             MOVS     R0,#+1
   \      0x126   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    710                  }
    711          
    712                  MBEDTLS_MPI_CHK(mpi_write_hlp(&T, radix, &p, buflen));
   \                     ??mbedtls_mpi_write_string_16: (+1)
   \      0x12A   0x0033             MOVS     R3,R6
   \      0x12C   0x466A             MOV      R2,SP
   \      0x12E   0x0021             MOVS     R1,R4
   \      0x130   0xA801             ADD      R0,SP,#+4
   \      0x132   0x.... 0x....      BL       mpi_write_hlp
   \      0x136   0x4680             MOV      R8,R0
   \      0x138   0x2800             CMP      R0,#+0
   \      0x13A   0xD108             BNE.N    ??mbedtls_mpi_write_string_14
    713              }
    714          
    715              *p++ = '\0';
   \                     ??mbedtls_mpi_write_string_17: (+1)
   \                     ??mbedtls_mpi_write_string_9: (+1)
   \      0x13C   0x2100             MOVS     R1,#+0
   \      0x13E   0x9800             LDR      R0,[SP, #+0]
   \      0x140   0x7001             STRB     R1,[R0, #+0]
   \      0x142   0x9800             LDR      R0,[SP, #+0]
   \      0x144   0x1C40             ADDS     R0,R0,#+1
   \      0x146   0x9000             STR      R0,[SP, #+0]
    716              *olen = p - buf;
   \      0x148   0x9800             LDR      R0,[SP, #+0]
   \      0x14A   0x1B40             SUBS     R0,R0,R5
   \      0x14C   0x6038             STR      R0,[R7, #+0]
    717          
    718          cleanup:
    719          
    720              mbedtls_mpi_free(&T);
   \                     ??mbedtls_mpi_write_string_14: (+1)
   \      0x14E   0xA801             ADD      R0,SP,#+4
   \      0x150   0x.... 0x....      BL       mbedtls_mpi_free
    721          
    722              return ret;
   \      0x154   0x4640             MOV      R0,R8
   \                     ??mbedtls_mpi_write_string_2: (+1)
   \      0x156   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    723          }
    724          
    725          #if defined(MBEDTLS_FS_IO)
    726          /*
    727           * Read X from an opened file
    728           */
    729          int mbedtls_mpi_read_file(mbedtls_mpi *X, int radix, FILE *fin)
    730          {
    731              mbedtls_mpi_uint d;
    732              size_t slen;
    733              char *p;
    734              /*
    735               * Buffer should have space for (short) label and decimal formatted MPI,
    736               * newline characters and '\0'
    737               */
    738              char s[MBEDTLS_MPI_RW_BUFFER_SIZE];
    739          
    740              MPI_VALIDATE_RET(X   != NULL);
    741              MPI_VALIDATE_RET(fin != NULL);
    742          
    743              if (radix < 2 || radix > 16) {
    744                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
    745              }
    746          
    747              memset(s, 0, sizeof(s));
    748              if (fgets(s, sizeof(s) - 1, fin) == NULL) {
    749                  return MBEDTLS_ERR_MPI_FILE_IO_ERROR;
    750              }
    751          
    752              slen = strlen(s);
    753              if (slen == sizeof(s) - 2) {
    754                  return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
    755              }
    756          
    757              if (slen > 0 && s[slen - 1] == '\n') {
    758                  slen--; s[slen] = '\0';
    759              }
    760              if (slen > 0 && s[slen - 1] == '\r') {
    761                  slen--; s[slen] = '\0';
    762              }
    763          
    764              p = s + slen;
    765              while (p-- > s) {
    766                  if (mpi_get_digit(&d, radix, *p) != 0) {
    767                      break;
    768                  }
    769              }
    770          
    771              return mbedtls_mpi_read_string(X, radix, p + 1);
    772          }
    773          
    774          /*
    775           * Write X into an opened file (or stdout if fout == NULL)
    776           */
    777          int mbedtls_mpi_write_file(const char *p, const mbedtls_mpi *X, int radix, FILE *fout)
    778          {
    779              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    780              size_t n, slen, plen;
    781              /*
    782               * Buffer should have space for (short) label and decimal formatted MPI,
    783               * newline characters and '\0'
    784               */
    785              char s[MBEDTLS_MPI_RW_BUFFER_SIZE];
    786              MPI_VALIDATE_RET(X != NULL);
    787          
    788              if (radix < 2 || radix > 16) {
    789                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
    790              }
    791          
    792              memset(s, 0, sizeof(s));
    793          
    794              MBEDTLS_MPI_CHK(mbedtls_mpi_write_string(X, radix, s, sizeof(s) - 2, &n));
    795          
    796              if (p == NULL) {
    797                  p = "";
    798              }
    799          
    800              plen = strlen(p);
    801              slen = strlen(s);
    802              s[slen++] = '\r';
    803              s[slen++] = '\n';
    804          
    805              if (fout != NULL) {
    806                  if (fwrite(p, 1, plen, fout) != plen ||
    807                      fwrite(s, 1, slen, fout) != slen) {
    808                      return MBEDTLS_ERR_MPI_FILE_IO_ERROR;
    809                  }
    810              } else {
    811                  mbedtls_printf("%s%s", p, s);
    812              }
    813          
    814          cleanup:
    815          
    816              return ret;
    817          }
    818          #endif /* MBEDTLS_FS_IO */
    819          
    820          /*
    821           * Import X from unsigned binary data, little endian
    822           *
    823           * This function is guaranteed to return an MPI with exactly the necessary
    824           * number of limbs (in particular, it does not skip 0s in the input).
    825           */

   \                                 In section .text, align 2, keep-with-next
    826          int mbedtls_mpi_read_binary_le(mbedtls_mpi *X,
    827                                         const unsigned char *buf, size_t buflen)
    828          {
   \                     mbedtls_mpi_read_binary_le: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    829              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x096D      MVNS     R9,#+109
    830              const size_t limbs = CHARS_TO_LIMBS(buflen);
   \        0xE   0xF016 0x0F03      TST      R6,#0x3
   \       0x12   0xD001             BEQ.N    ??mbedtls_mpi_read_binary_le_0
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0xE000             B.N      ??mbedtls_mpi_read_binary_le_1
   \                     ??mbedtls_mpi_read_binary_le_0: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \                     ??mbedtls_mpi_read_binary_le_1: (+1)
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x0880             LSRS     R0,R0,#+2
   \       0x1E   0xFA50 0xF781      UXTAB    R7,R0,R1
    831          
    832              /* Ensure that target MPI has exactly the necessary number of limbs */
    833              MBEDTLS_MPI_CHK(mbedtls_mpi_resize_clear(X, limbs));
   \       0x22   0x0039             MOVS     R1,R7
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_resize_clear
   \       0x2A   0x4680             MOV      R8,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD108             BNE.N    ??mbedtls_mpi_read_binary_le_2
    834          
    835              MBEDTLS_MPI_CHK(mbedtls_mpi_core_read_le(X->p, X->n, buf, buflen));
   \                     ??mbedtls_mpi_read_binary_le_3: (+1)
   \       0x30   0x0033             MOVS     R3,R6
   \       0x32   0x002A             MOVS     R2,R5
   \       0x34   0x88E1             LDRH     R1,[R4, #+6]
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_core_read_le
   \       0x3C   0x4680             MOV      R8,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD1FF             BNE.N    ??mbedtls_mpi_read_binary_le_2
    836          
    837          cleanup:
    838          
    839              /*
    840               * This function is also used to import keys. However, wiping the buffers
    841               * upon failure is not necessary because failure only can happen before any
    842               * input is copied.
    843               */
    844              return ret;
   \                     ??mbedtls_mpi_read_binary_le_4: (+1)
   \                     ??mbedtls_mpi_read_binary_le_2: (+1)
   \       0x42   0x4640             MOV      R0,R8
   \       0x44   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    845          }
    846          
    847          /*
    848           * Import X from unsigned binary data, big endian
    849           *
    850           * This function is guaranteed to return an MPI with exactly the necessary
    851           * number of limbs (in particular, it does not skip 0s in the input).
    852           */

   \                                 In section .text, align 2, keep-with-next
    853          int mbedtls_mpi_read_binary(mbedtls_mpi *X, const unsigned char *buf, size_t buflen)
    854          {
   \                     mbedtls_mpi_read_binary: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    855              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x096D      MVNS     R9,#+109
    856              const size_t limbs = CHARS_TO_LIMBS(buflen);
   \        0xE   0xF016 0x0F03      TST      R6,#0x3
   \       0x12   0xD001             BEQ.N    ??mbedtls_mpi_read_binary_0
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0xE000             B.N      ??mbedtls_mpi_read_binary_1
   \                     ??mbedtls_mpi_read_binary_0: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \                     ??mbedtls_mpi_read_binary_1: (+1)
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x0880             LSRS     R0,R0,#+2
   \       0x1E   0xFA50 0xF781      UXTAB    R7,R0,R1
    857          
    858              MPI_VALIDATE_RET(X != NULL);
    859              MPI_VALIDATE_RET(buflen == 0 || buf != NULL);
    860          
    861              /* Ensure that target MPI has exactly the necessary number of limbs */
    862              MBEDTLS_MPI_CHK(mbedtls_mpi_resize_clear(X, limbs));
   \       0x22   0x0039             MOVS     R1,R7
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_resize_clear
   \       0x2A   0x4680             MOV      R8,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD108             BNE.N    ??mbedtls_mpi_read_binary_2
    863          
    864              MBEDTLS_MPI_CHK(mbedtls_mpi_core_read_be(X->p, X->n, buf, buflen));
   \                     ??mbedtls_mpi_read_binary_3: (+1)
   \       0x30   0x0033             MOVS     R3,R6
   \       0x32   0x002A             MOVS     R2,R5
   \       0x34   0x88E1             LDRH     R1,[R4, #+6]
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_core_read_be
   \       0x3C   0x4680             MOV      R8,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD1FF             BNE.N    ??mbedtls_mpi_read_binary_2
    865          
    866          cleanup:
    867          
    868              /*
    869               * This function is also used to import keys. However, wiping the buffers
    870               * upon failure is not necessary because failure only can happen before any
    871               * input is copied.
    872               */
    873              return ret;
   \                     ??mbedtls_mpi_read_binary_4: (+1)
   \                     ??mbedtls_mpi_read_binary_2: (+1)
   \       0x42   0x4640             MOV      R0,R8
   \       0x44   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    874          }
    875          
    876          /*
    877           * Export X into unsigned binary data, little endian
    878           */

   \                                 In section .text, align 2, keep-with-next
    879          int mbedtls_mpi_write_binary_le(const mbedtls_mpi *X,
    880                                          unsigned char *buf, size_t buflen)
    881          {
   \                     mbedtls_mpi_write_binary_le: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
    882              return mbedtls_mpi_core_write_le(X->p, X->n, buf, buflen);
   \        0x8   0x002B             MOVS     R3,R5
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x88F1             LDRH     R1,[R6, #+6]
   \        0xE   0x6830             LDR      R0,[R6, #+0]
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_core_write_le
   \       0x14   0xBD70             POP      {R4-R6,PC}
    883          }
    884          
    885          /*
    886           * Export X into unsigned binary data, big endian
    887           */

   \                                 In section .text, align 2, keep-with-next
    888          int mbedtls_mpi_write_binary(const mbedtls_mpi *X,
    889                                       unsigned char *buf, size_t buflen)
    890          {
   \                     mbedtls_mpi_write_binary: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
    891              return mbedtls_mpi_core_write_be(X->p, X->n, buf, buflen);
   \        0x8   0x002B             MOVS     R3,R5
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x88F1             LDRH     R1,[R6, #+6]
   \        0xE   0x6830             LDR      R0,[R6, #+0]
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_core_write_be
   \       0x14   0xBD70             POP      {R4-R6,PC}
    892          }
    893          
    894          /*
    895           * Left-shift: X <<= count
    896           */

   \                                 In section .text, align 2, keep-with-next
    897          int mbedtls_mpi_shift_l(mbedtls_mpi *X, size_t count)
    898          {
   \                     mbedtls_mpi_shift_l: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    899              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x6   0xF07F 0x066D      MVNS     R6,#+109
    900              size_t i;
    901              MPI_VALIDATE_RET(X != NULL);
    902          
    903              i = mbedtls_mpi_bitlen(X) + count;
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0x10   0x0007             MOVS     R7,R0
   \       0x12   0x19EF             ADDS     R7,R5,R7
    904          
    905              if (X->n * biL < i) {
   \       0x14   0x88E0             LDRH     R0,[R4, #+6]
   \       0x16   0x0140             LSLS     R0,R0,#+5
   \       0x18   0x42B8             CMP      R0,R7
   \       0x1A   0xD20F             BCS.N    ??mbedtls_mpi_shift_l_0
    906                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, BITS_TO_LIMBS(i)));
   \       0x1C   0xF017 0x0F1F      TST      R7,#0x1F
   \       0x20   0xD001             BEQ.N    ??mbedtls_mpi_shift_l_1
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0xE000             B.N      ??mbedtls_mpi_shift_l_2
   \                     ??mbedtls_mpi_shift_l_1: (+1)
   \       0x26   0x2100             MOVS     R1,#+0
   \                     ??mbedtls_mpi_shift_l_2: (+1)
   \       0x28   0x0038             MOVS     R0,R7
   \       0x2A   0x0940             LSRS     R0,R0,#+5
   \       0x2C   0xFA50 0xF181      UXTAB    R1,R0,R1
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x36   0x0006             MOVS     R6,R0
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD106             BNE.N    ??mbedtls_mpi_shift_l_3
    907              }
    908          
    909              ret = 0;
   \                     ??mbedtls_mpi_shift_l_4: (+1)
   \                     ??mbedtls_mpi_shift_l_0: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x0006             MOVS     R6,R0
    910          
    911              mbedtls_mpi_core_shift_l(X->p, X->n, count);
   \       0x40   0x002A             MOVS     R2,R5
   \       0x42   0x88E1             LDRH     R1,[R4, #+6]
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x.... 0x....      BL       mbedtls_mpi_core_shift_l
    912          cleanup:
    913          
    914              return ret;
   \                     ??mbedtls_mpi_shift_l_3: (+1)
   \       0x4A   0x0030             MOVS     R0,R6
   \       0x4C   0xBDF2             POP      {R1,R4-R7,PC}
    915          }
    916          
    917          /*
    918           * Right-shift: X >>= count
    919           */

   \                                 In section .text, align 2, keep-with-next
    920          int mbedtls_mpi_shift_r(mbedtls_mpi *X, size_t count)
    921          {
   \                     mbedtls_mpi_shift_r: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    922              MPI_VALIDATE_RET(X != NULL);
    923              if (X->n != 0) {
   \        0x6   0x88E8             LDRH     R0,[R5, #+6]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ.N    ??mbedtls_mpi_shift_r_0
    924                  mbedtls_mpi_core_shift_r(X->p, X->n, count);
   \        0xC   0x0022             MOVS     R2,R4
   \        0xE   0x88E9             LDRH     R1,[R5, #+6]
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_core_shift_r
    925              }
    926              return 0;
   \                     ??mbedtls_mpi_shift_r_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xBD32             POP      {R1,R4,R5,PC}
    927          }
    928          
    929          /*
    930           * Compare unsigned values
    931           */

   \                                 In section .text, align 2, keep-with-next
    932          int mbedtls_mpi_cmp_abs(const mbedtls_mpi *X, const mbedtls_mpi *Y)
    933          {
   \                     mbedtls_mpi_cmp_abs: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000B             MOVS     R3,R1
    934              size_t i, j;
    935              MPI_VALIDATE_RET(X != NULL);
    936              MPI_VALIDATE_RET(Y != NULL);
    937          
    938              for (i = X->n; i > 0; i--) {
   \        0x6   0x88E1             LDRH     R1,[R4, #+6]
   \                     ??mbedtls_mpi_cmp_abs_0: (+1)
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD008             BEQ.N    ??mbedtls_mpi_cmp_abs_1
    939                  if (X->p[i - 1] != 0) {
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \       0x12   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??mbedtls_mpi_cmp_abs_1
    940                      break;
    941                  }
    942              }
   \                     ??mbedtls_mpi_cmp_abs_2: (+1)
   \       0x1A   0x1E49             SUBS     R1,R1,#+1
   \       0x1C   0xE7F4             B.N      ??mbedtls_mpi_cmp_abs_0
    943          
    944              for (j = Y->n; j > 0; j--) {
   \                     ??mbedtls_mpi_cmp_abs_1: (+1)
   \       0x1E   0x88DA             LDRH     R2,[R3, #+6]
   \                     ??mbedtls_mpi_cmp_abs_3: (+1)
   \       0x20   0x2A00             CMP      R2,#+0
   \       0x22   0xD008             BEQ.N    ??mbedtls_mpi_cmp_abs_4
    945                  if (Y->p[j - 1] != 0) {
   \       0x24   0x6818             LDR      R0,[R3, #+0]
   \       0x26   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \       0x2A   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD101             BNE.N    ??mbedtls_mpi_cmp_abs_4
    946                      break;
    947                  }
    948              }
   \                     ??mbedtls_mpi_cmp_abs_5: (+1)
   \       0x32   0x1E52             SUBS     R2,R2,#+1
   \       0x34   0xE7F4             B.N      ??mbedtls_mpi_cmp_abs_3
    949          
    950              /* If i == j == 0, i.e. abs(X) == abs(Y),
    951               * we end up returning 0 at the end of the function. */
    952          
    953              if (i > j) {
   \                     ??mbedtls_mpi_cmp_abs_4: (+1)
   \       0x36   0x428A             CMP      R2,R1
   \       0x38   0xD201             BCS.N    ??mbedtls_mpi_cmp_abs_6
    954                  return 1;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xE026             B.N      ??mbedtls_mpi_cmp_abs_7
    955              }
    956              if (j > i) {
   \                     ??mbedtls_mpi_cmp_abs_6: (+1)
   \       0x3E   0x4291             CMP      R1,R2
   \       0x40   0xD202             BCS.N    ??mbedtls_mpi_cmp_abs_8
    957                  return -1;
   \       0x42   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x46   0xE021             B.N      ??mbedtls_mpi_cmp_abs_7
    958              }
    959          
    960              for (; i > 0; i--) {
   \                     ??mbedtls_mpi_cmp_abs_8: (+1)
   \       0x48   0x2900             CMP      R1,#+0
   \       0x4A   0xD01E             BEQ.N    ??mbedtls_mpi_cmp_abs_9
    961                  if (X->p[i - 1] > Y->p[i - 1]) {
   \       0x4C   0x6818             LDR      R0,[R3, #+0]
   \       0x4E   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \       0x52   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x56   0x6825             LDR      R5,[R4, #+0]
   \       0x58   0xEB05 0x0581      ADD      R5,R5,R1, LSL #+2
   \       0x5C   0xF855 0x5C04      LDR      R5,[R5, #-4]
   \       0x60   0x42A8             CMP      R0,R5
   \       0x62   0xD201             BCS.N    ??mbedtls_mpi_cmp_abs_10
    962                      return 1;
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xE011             B.N      ??mbedtls_mpi_cmp_abs_7
    963                  }
    964                  if (X->p[i - 1] < Y->p[i - 1]) {
   \                     ??mbedtls_mpi_cmp_abs_10: (+1)
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \       0x6E   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x72   0x681D             LDR      R5,[R3, #+0]
   \       0x74   0xEB05 0x0581      ADD      R5,R5,R1, LSL #+2
   \       0x78   0xF855 0x5C04      LDR      R5,[R5, #-4]
   \       0x7C   0x42A8             CMP      R0,R5
   \       0x7E   0xD202             BCS.N    ??mbedtls_mpi_cmp_abs_11
    965                      return -1;
   \       0x80   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x84   0xE002             B.N      ??mbedtls_mpi_cmp_abs_7
    966                  }
    967              }
   \                     ??mbedtls_mpi_cmp_abs_11: (+1)
   \       0x86   0x1E49             SUBS     R1,R1,#+1
   \       0x88   0xE7DE             B.N      ??mbedtls_mpi_cmp_abs_8
    968          
    969              return 0;
   \                     ??mbedtls_mpi_cmp_abs_9: (+1)
   \       0x8A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_mpi_cmp_abs_7: (+1)
   \       0x8C   0xBC30             POP      {R4,R5}
   \       0x8E   0x4770             BX       LR
    970          }
    971          
    972          /*
    973           * Compare signed values
    974           */

   \                                 In section .text, align 2, keep-with-next
    975          int mbedtls_mpi_cmp_mpi(const mbedtls_mpi *X, const mbedtls_mpi *Y)
    976          {
   \                     mbedtls_mpi_cmp_mpi: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000B             MOVS     R3,R1
    977              size_t i, j;
    978              MPI_VALIDATE_RET(X != NULL);
    979              MPI_VALIDATE_RET(Y != NULL);
    980          
    981              for (i = X->n; i > 0; i--) {
   \        0x6   0x88E1             LDRH     R1,[R4, #+6]
   \                     ??mbedtls_mpi_cmp_mpi_0: (+1)
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD008             BEQ.N    ??mbedtls_mpi_cmp_mpi_1
    982                  if (X->p[i - 1] != 0) {
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \       0x12   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??mbedtls_mpi_cmp_mpi_1
    983                      break;
    984                  }
    985              }
   \                     ??mbedtls_mpi_cmp_mpi_2: (+1)
   \       0x1A   0x1E49             SUBS     R1,R1,#+1
   \       0x1C   0xE7F4             B.N      ??mbedtls_mpi_cmp_mpi_0
    986          
    987              for (j = Y->n; j > 0; j--) {
   \                     ??mbedtls_mpi_cmp_mpi_1: (+1)
   \       0x1E   0x88DA             LDRH     R2,[R3, #+6]
   \                     ??mbedtls_mpi_cmp_mpi_3: (+1)
   \       0x20   0x2A00             CMP      R2,#+0
   \       0x22   0xD008             BEQ.N    ??mbedtls_mpi_cmp_mpi_4
    988                  if (Y->p[j - 1] != 0) {
   \       0x24   0x6818             LDR      R0,[R3, #+0]
   \       0x26   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \       0x2A   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD101             BNE.N    ??mbedtls_mpi_cmp_mpi_4
    989                      break;
    990                  }
    991              }
   \                     ??mbedtls_mpi_cmp_mpi_5: (+1)
   \       0x32   0x1E52             SUBS     R2,R2,#+1
   \       0x34   0xE7F4             B.N      ??mbedtls_mpi_cmp_mpi_3
    992          
    993              if (i == 0 && j == 0) {
   \                     ??mbedtls_mpi_cmp_mpi_4: (+1)
   \       0x36   0xEA52 0x0001      ORRS     R0,R2,R1
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD101             BNE.N    ??mbedtls_mpi_cmp_mpi_6
    994                  return 0;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE043             B.N      ??mbedtls_mpi_cmp_mpi_7
    995              }
    996          
    997              if (i > j) {
   \                     ??mbedtls_mpi_cmp_mpi_6: (+1)
   \       0x42   0x428A             CMP      R2,R1
   \       0x44   0xD202             BCS.N    ??mbedtls_mpi_cmp_mpi_8
    998                  return X->s;
   \       0x46   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0x4A   0xE03E             B.N      ??mbedtls_mpi_cmp_mpi_7
    999              }
   1000              if (j > i) {
   \                     ??mbedtls_mpi_cmp_mpi_8: (+1)
   \       0x4C   0x4291             CMP      R1,R2
   \       0x4E   0xD203             BCS.N    ??mbedtls_mpi_cmp_mpi_9
   1001                  return -Y->s;
   \       0x50   0xF9B3 0x0004      LDRSH    R0,[R3, #+4]
   \       0x54   0x4240             RSBS     R0,R0,#+0
   \       0x56   0xE038             B.N      ??mbedtls_mpi_cmp_mpi_7
   1002              }
   1003          
   1004              if (X->s > 0 && Y->s < 0) {
   \                     ??mbedtls_mpi_cmp_mpi_9: (+1)
   \       0x58   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0x5C   0x2801             CMP      R0,#+1
   \       0x5E   0xDB05             BLT.N    ??mbedtls_mpi_cmp_mpi_10
   \       0x60   0xF9B3 0x0004      LDRSH    R0,[R3, #+4]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD501             BPL.N    ??mbedtls_mpi_cmp_mpi_10
   1005                  return 1;
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xE02E             B.N      ??mbedtls_mpi_cmp_mpi_7
   1006              }
   1007              if (Y->s > 0 && X->s < 0) {
   \                     ??mbedtls_mpi_cmp_mpi_10: (+1)
   \       0x6C   0xF9B3 0x0004      LDRSH    R0,[R3, #+4]
   \       0x70   0x2801             CMP      R0,#+1
   \       0x72   0xDB06             BLT.N    ??mbedtls_mpi_cmp_mpi_11
   \       0x74   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD502             BPL.N    ??mbedtls_mpi_cmp_mpi_11
   1008                  return -1;
   \       0x7C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x80   0xE023             B.N      ??mbedtls_mpi_cmp_mpi_7
   1009              }
   1010          
   1011              for (; i > 0; i--) {
   \                     ??mbedtls_mpi_cmp_mpi_11: (+1)
   \       0x82   0x2900             CMP      R1,#+0
   \       0x84   0xD020             BEQ.N    ??mbedtls_mpi_cmp_mpi_12
   1012                  if (X->p[i - 1] > Y->p[i - 1]) {
   \       0x86   0x6818             LDR      R0,[R3, #+0]
   \       0x88   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \       0x8C   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x90   0x6825             LDR      R5,[R4, #+0]
   \       0x92   0xEB05 0x0581      ADD      R5,R5,R1, LSL #+2
   \       0x96   0xF855 0x5C04      LDR      R5,[R5, #-4]
   \       0x9A   0x42A8             CMP      R0,R5
   \       0x9C   0xD202             BCS.N    ??mbedtls_mpi_cmp_mpi_13
   1013                      return X->s;
   \       0x9E   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0xA2   0xE012             B.N      ??mbedtls_mpi_cmp_mpi_7
   1014                  }
   1015                  if (X->p[i - 1] < Y->p[i - 1]) {
   \                     ??mbedtls_mpi_cmp_mpi_13: (+1)
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \       0xAA   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0xAE   0x681D             LDR      R5,[R3, #+0]
   \       0xB0   0xEB05 0x0581      ADD      R5,R5,R1, LSL #+2
   \       0xB4   0xF855 0x5C04      LDR      R5,[R5, #-4]
   \       0xB8   0x42A8             CMP      R0,R5
   \       0xBA   0xD203             BCS.N    ??mbedtls_mpi_cmp_mpi_14
   1016                      return -X->s;
   \       0xBC   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0xC0   0x4240             RSBS     R0,R0,#+0
   \       0xC2   0xE002             B.N      ??mbedtls_mpi_cmp_mpi_7
   1017                  }
   1018              }
   \                     ??mbedtls_mpi_cmp_mpi_14: (+1)
   \       0xC4   0x1E49             SUBS     R1,R1,#+1
   \       0xC6   0xE7DC             B.N      ??mbedtls_mpi_cmp_mpi_11
   1019          
   1020              return 0;
   \                     ??mbedtls_mpi_cmp_mpi_12: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_mpi_cmp_mpi_7: (+1)
   \       0xCA   0xBC30             POP      {R4,R5}
   \       0xCC   0x4770             BX       LR
   1021          }
   1022          
   1023          /*
   1024           * Compare signed values
   1025           */

   \                                 In section .text, align 2, keep-with-next
   1026          int mbedtls_mpi_cmp_int(const mbedtls_mpi *X, mbedtls_mpi_sint z)
   1027          {
   \                     mbedtls_mpi_cmp_int: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1028              mbedtls_mpi Y;
   1029              mbedtls_mpi_uint p[1];
   1030              MPI_VALIDATE_RET(X != NULL);
   1031          
   1032              *p  = mpi_sint_abs(z);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       mpi_sint_abs
   \        0xC   0x9000             STR      R0,[SP, #+0]
   1033              Y.s = TO_SIGN(z);
   \        0xE   0x0029             MOVS     R1,R5
   \       0x10   0x0FC9             LSRS     R1,R1,#+31
   \       0x12   0xF07F 0x0001      MVNS     R0,#+1
   \       0x16   0x4341             MULS     R1,R0,R1
   \       0x18   0x1C49             ADDS     R1,R1,#+1
   \       0x1A   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   1034              Y.n = 1;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1035              Y.p = p;
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x9001             STR      R0,[SP, #+4]
   1036          
   1037              return mbedtls_mpi_cmp_mpi(X, &Y);
   \       0x28   0xA901             ADD      R1,SP,#+4
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x30   0xBD3E             POP      {R1-R5,PC}
   1038          }
   1039          
   1040          /*
   1041           * Unsigned addition: X = |A| + |B|  (HAC 14.7)
   1042           */

   \                                 In section .text, align 2, keep-with-next
   1043          int mbedtls_mpi_add_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1044          {
   \                     mbedtls_mpi_add_abs: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   1045              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x096D      MVNS     R9,#+109
   1046              size_t j;
   1047              mbedtls_mpi_uint *p;
   1048              mbedtls_mpi_uint c;
   1049              MPI_VALIDATE_RET(X != NULL);
   1050              MPI_VALIDATE_RET(A != NULL);
   1051              MPI_VALIDATE_RET(B != NULL);
   1052          
   1053              if (X == B) {
   \        0xE   0x4546             CMP      R6,R8
   \       0x10   0xD102             BNE.N    ??mbedtls_mpi_add_abs_0
   1054                  const mbedtls_mpi *T = A; A = X; B = T;
   \       0x12   0x0038             MOVS     R0,R7
   \       0x14   0x0037             MOVS     R7,R6
   \       0x16   0x4680             MOV      R8,R0
   1055              }
   1056          
   1057              if (X != A) {
   \                     ??mbedtls_mpi_add_abs_0: (+1)
   \       0x18   0x42BE             CMP      R6,R7
   \       0x1A   0xD006             BEQ.N    ??mbedtls_mpi_add_abs_1
   1058                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A));
   \       0x1C   0x0039             MOVS     R1,R7
   \       0x1E   0x0030             MOVS     R0,R6
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x24   0x4681             MOV      R9,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD149             BNE.N    ??mbedtls_mpi_add_abs_2
   1059              }
   1060          
   1061              /*
   1062               * X must always be positive as a result of unsigned additions.
   1063               */
   1064              X->s = 1;
   \                     ??mbedtls_mpi_add_abs_3: (+1)
   \                     ??mbedtls_mpi_add_abs_1: (+1)
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0x80B0             STRH     R0,[R6, #+4]
   1065          
   1066              for (j = B->n; j > 0; j--) {
   \       0x2E   0xF8B8 0x0006      LDRH     R0,[R8, #+6]
   \       0x32   0x0004             MOVS     R4,R0
   \                     ??mbedtls_mpi_add_abs_4: (+1)
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD009             BEQ.N    ??mbedtls_mpi_add_abs_5
   1067                  if (B->p[j - 1] != 0) {
   \       0x38   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x3C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0x40   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD101             BNE.N    ??mbedtls_mpi_add_abs_5
   1068                      break;
   1069                  }
   1070              }
   \                     ??mbedtls_mpi_add_abs_6: (+1)
   \       0x48   0x1E64             SUBS     R4,R4,#+1
   \       0x4A   0xE7F3             B.N      ??mbedtls_mpi_add_abs_4
   1071          
   1072              /* Exit early to avoid undefined behavior on NULL+0 when X->n == 0
   1073               * and B is 0 (of any size). */
   1074              if (j == 0) {
   \                     ??mbedtls_mpi_add_abs_5: (+1)
   \       0x4C   0x2C00             CMP      R4,#+0
   \       0x4E   0xD101             BNE.N    ??mbedtls_mpi_add_abs_7
   1075                  return 0;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE035             B.N      ??mbedtls_mpi_add_abs_8
   1076              }
   1077          
   1078              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, j));
   \                     ??mbedtls_mpi_add_abs_7: (+1)
   \       0x54   0x0021             MOVS     R1,R4
   \       0x56   0x0030             MOVS     R0,R6
   \       0x58   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x5C   0x4681             MOV      R9,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD12D             BNE.N    ??mbedtls_mpi_add_abs_2
   1079          
   1080              /* j is the number of non-zero limbs of B. Add those to X. */
   1081          
   1082              p = X->p;
   \                     ??mbedtls_mpi_add_abs_9: (+1)
   \       0x62   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   1083          
   1084              c = mbedtls_mpi_core_add(p, p, B->p, j);
   \       0x66   0x0023             MOVS     R3,R4
   \       0x68   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x6C   0x4659             MOV      R1,R11
   \       0x6E   0x4658             MOV      R0,R11
   \       0x70   0x.... 0x....      BL       mbedtls_mpi_core_add
   \       0x74   0x0005             MOVS     R5,R0
   1085          
   1086              p += j;
   \       0x76   0xEB0B 0x0084      ADD      R0,R11,R4, LSL #+2
   \       0x7A   0x4682             MOV      R10,R0
   1087          
   1088              /* Now propagate any carry */
   1089          
   1090              while (c != 0) {
   \                     ??mbedtls_mpi_add_abs_10: (+1)
   \       0x7C   0x2D00             CMP      R5,#+0
   \       0x7E   0xD01E             BEQ.N    ??mbedtls_mpi_add_abs_2
   1091                  if (j >= X->n) {
   \       0x80   0x88F0             LDRH     R0,[R6, #+6]
   \       0x82   0x4284             CMP      R4,R0
   \       0x84   0xD30A             BCC.N    ??mbedtls_mpi_add_abs_11
   1092                      MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, j + 1));
   \       0x86   0x1C61             ADDS     R1,R4,#+1
   \       0x88   0x0030             MOVS     R0,R6
   \       0x8A   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x8E   0x4681             MOV      R9,R0
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD114             BNE.N    ??mbedtls_mpi_add_abs_2
   1093                      p = X->p + j;
   \                     ??mbedtls_mpi_add_abs_12: (+1)
   \       0x94   0x6830             LDR      R0,[R6, #+0]
   \       0x96   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0x9A   0x4682             MOV      R10,R0
   1094                  }
   1095          
   1096                  *p += c; c = (*p < c); j++; p++;
   \                     ??mbedtls_mpi_add_abs_11: (+1)
   \       0x9C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xA0   0x1828             ADDS     R0,R5,R0
   \       0xA2   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \       0xA6   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xAA   0x42A8             CMP      R0,R5
   \       0xAC   0xD201             BCS.N    ??mbedtls_mpi_add_abs_13
   \       0xAE   0x2501             MOVS     R5,#+1
   \       0xB0   0xE000             B.N      ??mbedtls_mpi_add_abs_14
   \                     ??mbedtls_mpi_add_abs_13: (+1)
   \       0xB2   0x2500             MOVS     R5,#+0
   \                     ??mbedtls_mpi_add_abs_14: (+1)
   \       0xB4   0xB2ED             UXTB     R5,R5
   \       0xB6   0x1C64             ADDS     R4,R4,#+1
   \       0xB8   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \       0xBC   0xE7DE             B.N      ??mbedtls_mpi_add_abs_10
   1097              }
   1098          
   1099          cleanup:
   1100          
   1101              return ret;
   \                     ??mbedtls_mpi_add_abs_2: (+1)
   \       0xBE   0x4648             MOV      R0,R9
   \                     ??mbedtls_mpi_add_abs_8: (+1)
   \       0xC0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1102          }
   1103          
   1104          /*
   1105           * Unsigned subtraction: X = |A| - |B|  (HAC 14.9, 14.10)
   1106           */

   \                                 In section .text, align 2, keep-with-next
   1107          int mbedtls_mpi_sub_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1108          {
   \                     mbedtls_mpi_sub_abs: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1109              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x096D      MVNS     R9,#+109
   1110              size_t n;
   1111              mbedtls_mpi_uint carry;
   1112              MPI_VALIDATE_RET(X != NULL);
   1113              MPI_VALIDATE_RET(A != NULL);
   1114              MPI_VALIDATE_RET(B != NULL);
   1115          
   1116              for (n = B->n; n > 0; n--) {
   \        0xE   0x88F4             LDRH     R4,[R6, #+6]
   \                     ??mbedtls_mpi_sub_abs_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD008             BEQ.N    ??mbedtls_mpi_sub_abs_1
   1117                  if (B->p[n - 1] != 0) {
   \       0x14   0x6830             LDR      R0,[R6, #+0]
   \       0x16   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0x1A   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??mbedtls_mpi_sub_abs_1
   1118                      break;
   1119                  }
   1120              }
   \                     ??mbedtls_mpi_sub_abs_2: (+1)
   \       0x22   0x1E64             SUBS     R4,R4,#+1
   \       0x24   0xE7F4             B.N      ??mbedtls_mpi_sub_abs_0
   1121              if (n > A->n) {
   \                     ??mbedtls_mpi_sub_abs_1: (+1)
   \       0x26   0x88E8             LDRH     R0,[R5, #+6]
   \       0x28   0x42A0             CMP      R0,R4
   \       0x2A   0xD202             BCS.N    ??mbedtls_mpi_sub_abs_3
   1122                  /* B >= (2^ciL)^n > A */
   1123                  ret = MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   \       0x2C   0xF07F 0x0809      MVNS     R8,#+9
   1124                  goto cleanup;
   \       0x30   0xE04D             B.N      ??mbedtls_mpi_sub_abs_4
   1125              }
   1126          
   1127              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, A->n));
   \                     ??mbedtls_mpi_sub_abs_3: (+1)
   \       0x32   0x88E9             LDRH     R1,[R5, #+6]
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x3A   0x4680             MOV      R8,R0
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD146             BNE.N    ??mbedtls_mpi_sub_abs_4
   1128          
   1129              /* Set the high limbs of X to match A. Don't touch the lower limbs
   1130               * because X might be aliased to B, and we must not overwrite the
   1131               * significant digits of B. */
   1132              if (A->n > n && A != X) {
   \                     ??mbedtls_mpi_sub_abs_5: (+1)
   \       0x40   0x88E8             LDRH     R0,[R5, #+6]
   \       0x42   0x4284             CMP      R4,R0
   \       0x44   0xD210             BCS.N    ??mbedtls_mpi_sub_abs_6
   \       0x46   0x42BD             CMP      R5,R7
   \       0x48   0xD00E             BEQ.N    ??mbedtls_mpi_sub_abs_6
   1133                  memcpy(X->p + n, A->p + n, (A->n - n) * ciL);
   \       0x4A   0x88E8             LDRH     R0,[R5, #+6]
   \       0x4C   0x1B00             SUBS     R0,R0,R4
   \       0x4E   0xEA5F 0x0B80      LSLS     R11,R0,#+2
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0xEB00 0x0984      ADD      R9,R0,R4, LSL #+2
   \       0x58   0x6838             LDR      R0,[R7, #+0]
   \       0x5A   0xEB00 0x0A84      ADD      R10,R0,R4, LSL #+2
   \       0x5E   0x465A             MOV      R2,R11
   \       0x60   0x4649             MOV      R1,R9
   \       0x62   0x4650             MOV      R0,R10
   \       0x64   0x.... 0x....      BL       __aeabi_memcpy
   1134              }
   1135              if (X->n > A->n) {
   \                     ??mbedtls_mpi_sub_abs_6: (+1)
   \       0x68   0x88E9             LDRH     R1,[R5, #+6]
   \       0x6A   0x88F8             LDRH     R0,[R7, #+6]
   \       0x6C   0x4281             CMP      R1,R0
   \       0x6E   0xD20F             BCS.N    ??mbedtls_mpi_sub_abs_7
   1136                  memset(X->p + A->n, 0, (X->n - A->n) * ciL);
   \       0x70   0x88F9             LDRH     R1,[R7, #+6]
   \       0x72   0x88E8             LDRH     R0,[R5, #+6]
   \       0x74   0x1A09             SUBS     R1,R1,R0
   \       0x76   0xEA5F 0x0B81      LSLS     R11,R1,#+2
   \       0x7A   0xF05F 0x0900      MOVS     R9,#+0
   \       0x7E   0x6839             LDR      R1,[R7, #+0]
   \       0x80   0x88E8             LDRH     R0,[R5, #+6]
   \       0x82   0xEB01 0x0A80      ADD      R10,R1,R0, LSL #+2
   \       0x86   0x464A             MOV      R2,R9
   \       0x88   0x4659             MOV      R1,R11
   \       0x8A   0x4650             MOV      R0,R10
   \       0x8C   0x.... 0x....      BL       __aeabi_memset
   1137              }
   1138          
   1139              carry = mbedtls_mpi_core_sub(X->p, A->p, B->p, n);
   \                     ??mbedtls_mpi_sub_abs_7: (+1)
   \       0x90   0x0023             MOVS     R3,R4
   \       0x92   0x6832             LDR      R2,[R6, #+0]
   \       0x94   0x6829             LDR      R1,[R5, #+0]
   \       0x96   0x6838             LDR      R0,[R7, #+0]
   \       0x98   0x.... 0x....      BL       mbedtls_mpi_core_sub
   \       0x9C   0x9000             STR      R0,[SP, #+0]
   1140              if (carry != 0) {
   \       0x9E   0x9800             LDR      R0,[SP, #+0]
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD012             BEQ.N    ??mbedtls_mpi_sub_abs_8
   1141                  /* Propagate the carry through the rest of X. */
   1142                  carry = mbedtls_mpi_core_sub_int(X->p + n, X->p + n, carry, X->n - n);
   \       0xA4   0x88FB             LDRH     R3,[R7, #+6]
   \       0xA6   0x1B1B             SUBS     R3,R3,R4
   \       0xA8   0x9A00             LDR      R2,[SP, #+0]
   \       0xAA   0x6838             LDR      R0,[R7, #+0]
   \       0xAC   0xEB00 0x0184      ADD      R1,R0,R4, LSL #+2
   \       0xB0   0x6838             LDR      R0,[R7, #+0]
   \       0xB2   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0xB6   0x.... 0x....      BL       mbedtls_mpi_core_sub_int
   \       0xBA   0x9000             STR      R0,[SP, #+0]
   1143          
   1144                  /* If we have further carry/borrow, the result is negative. */
   1145                  if (carry != 0) {
   \       0xBC   0x9800             LDR      R0,[SP, #+0]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD003             BEQ.N    ??mbedtls_mpi_sub_abs_8
   1146                      ret = MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   \       0xC2   0xF07F 0x0009      MVNS     R0,#+9
   \       0xC6   0x4680             MOV      R8,R0
   1147                      goto cleanup;
   \       0xC8   0xE001             B.N      ??mbedtls_mpi_sub_abs_4
   1148                  }
   1149              }
   1150          
   1151              /* X should always be positive as a result of unsigned subtractions. */
   1152              X->s = 1;
   \                     ??mbedtls_mpi_sub_abs_8: (+1)
   \       0xCA   0x2001             MOVS     R0,#+1
   \       0xCC   0x80B8             STRH     R0,[R7, #+4]
   1153          
   1154          cleanup:
   1155              return ret;
   \                     ??mbedtls_mpi_sub_abs_4: (+1)
   \       0xCE   0x4640             MOV      R0,R8
   \       0xD0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1156          }
   1157          
   1158          /* Common function for signed addition and subtraction.
   1159           * Calculate A + B * flip_B where flip_B is 1 or -1.
   1160           */

   \                                 In section .text, align 2, keep-with-next
   1161          static int add_sub_mpi(mbedtls_mpi *X,
   1162                                 const mbedtls_mpi *A, const mbedtls_mpi *B,
   1163                                 int flip_B)
   1164          {
   \                     add_sub_mpi: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1165              int ret, s;
   1166              MPI_VALIDATE_RET(X != NULL);
   1167              MPI_VALIDATE_RET(A != NULL);
   1168              MPI_VALIDATE_RET(B != NULL);
   1169          
   1170              s = A->s;
   \        0xC   0xF9B4 0x7004      LDRSH    R7,[R4, #+4]
   1171              if (A->s * B->s * flip_B < 0) {
   \       0x10   0xF9B4 0x1004      LDRSH    R1,[R4, #+4]
   \       0x14   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \       0x18   0xFB11 0xF000      SMULBB   R0,R1,R0
   \       0x1C   0x4370             MULS     R0,R6,R0
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD524             BPL.N    ??add_sub_mpi_0
   1172                  int cmp = mbedtls_mpi_cmp_abs(A, B);
   \       0x22   0x0029             MOVS     R1,R5
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_cmp_abs
   \       0x2A   0x4681             MOV      R9,R0
   1173                  if (cmp >= 0) {
   \       0x2C   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x30   0xD410             BMI.N    ??add_sub_mpi_1
   1174                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(X, A, B));
   \       0x32   0x002A             MOVS     R2,R5
   \       0x34   0x0021             MOVS     R1,R4
   \       0x36   0x4640             MOV      R0,R8
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x3C   0x0001             MOVS     R1,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD11E             BNE.N    ??add_sub_mpi_2
   1175                      /* If |A| = |B|, the result is 0 and we must set the sign bit
   1176                       * to +1 regardless of which of A or B was negative. Otherwise,
   1177                       * since |A| > |B|, the sign is the sign of A. */
   1178                      X->s = cmp == 0 ? 1 : s;
   \                     ??add_sub_mpi_3: (+1)
   \       0x42   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x46   0xD101             BNE.N    ??add_sub_mpi_4
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xE000             B.N      ??add_sub_mpi_5
   \                     ??add_sub_mpi_4: (+1)
   \       0x4C   0x0038             MOVS     R0,R7
   \                     ??add_sub_mpi_5: (+1)
   \       0x4E   0xF8A8 0x0004      STRH     R0,[R8, #+4]
   \       0x52   0xE015             B.N      ??add_sub_mpi_2
   1179                  } else {
   1180                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(X, B, A));
   \                     ??add_sub_mpi_1: (+1)
   \       0x54   0x0022             MOVS     R2,R4
   \       0x56   0x0029             MOVS     R1,R5
   \       0x58   0x4640             MOV      R0,R8
   \       0x5A   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x5E   0x0001             MOVS     R1,R0
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD10D             BNE.N    ??add_sub_mpi_2
   1181                      /* Since |A| < |B|, the sign is the opposite of A. */
   1182                      X->s = -s;
   \                     ??add_sub_mpi_6: (+1)
   \       0x64   0x4278             RSBS     R0,R7,#+0
   \       0x66   0xF8A8 0x0004      STRH     R0,[R8, #+4]
   \       0x6A   0xE009             B.N      ??add_sub_mpi_2
   1183                  }
   1184              } else {
   1185                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_abs(X, A, B));
   \                     ??add_sub_mpi_0: (+1)
   \       0x6C   0x002A             MOVS     R2,R5
   \       0x6E   0x0021             MOVS     R1,R4
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x.... 0x....      BL       mbedtls_mpi_add_abs
   \       0x76   0x0001             MOVS     R1,R0
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD101             BNE.N    ??add_sub_mpi_2
   1186                  X->s = s;
   \                     ??add_sub_mpi_7: (+1)
   \       0x7C   0xF8A8 0x7004      STRH     R7,[R8, #+4]
   1187              }
   1188          
   1189          cleanup:
   1190          
   1191              return ret;
   \                     ??add_sub_mpi_2: (+1)
   \       0x80   0x0008             MOVS     R0,R1
   \       0x82   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1192          }
   1193          
   1194          /*
   1195           * Signed addition: X = A + B
   1196           */

   \                                 In section .text, align 2, keep-with-next
   1197          int mbedtls_mpi_add_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1198          {
   \                     mbedtls_mpi_add_mpi: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   1199              return add_sub_mpi(X, A, B, 1);
   \        0x8   0x2301             MOVS     R3,#+1
   \        0xA   0x002A             MOVS     R2,R5
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       add_sub_mpi
   \       0x14   0xBD70             POP      {R4-R6,PC}
   1200          }
   1201          
   1202          /*
   1203           * Signed subtraction: X = A - B
   1204           */

   \                                 In section .text, align 2, keep-with-next
   1205          int mbedtls_mpi_sub_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1206          {
   \                     mbedtls_mpi_sub_mpi: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   1207              return add_sub_mpi(X, A, B, -1);
   \        0x8   0xF05F 0x33FF      MOVS     R3,#+4294967295
   \        0xC   0x002A             MOVS     R2,R5
   \        0xE   0x0021             MOVS     R1,R4
   \       0x10   0x0030             MOVS     R0,R6
   \       0x12   0x.... 0x....      BL       add_sub_mpi
   \       0x16   0xBD70             POP      {R4-R6,PC}
   1208          }
   1209          
   1210          /*
   1211           * Signed addition: X = A + b
   1212           */

   \                                 In section .text, align 2, keep-with-next
   1213          int mbedtls_mpi_add_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b)
   1214          {
   \                     mbedtls_mpi_add_int: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   1215              mbedtls_mpi B;
   1216              mbedtls_mpi_uint p[1];
   1217              MPI_VALIDATE_RET(X != NULL);
   1218              MPI_VALIDATE_RET(A != NULL);
   1219          
   1220              p[0] = mpi_sint_abs(b);
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       mpi_sint_abs
   \        0xE   0x9000             STR      R0,[SP, #+0]
   1221              B.s = TO_SIGN(b);
   \       0x10   0x0029             MOVS     R1,R5
   \       0x12   0x0FC9             LSRS     R1,R1,#+31
   \       0x14   0xF07F 0x0001      MVNS     R0,#+1
   \       0x18   0x4341             MULS     R1,R0,R1
   \       0x1A   0x1C49             ADDS     R1,R1,#+1
   \       0x1C   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   1222              B.n = 1;
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1223              B.p = p;
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x9001             STR      R0,[SP, #+4]
   1224          
   1225              return mbedtls_mpi_add_mpi(X, A, &B);
   \       0x2A   0xAA01             ADD      R2,SP,#+4
   \       0x2C   0x0021             MOVS     R1,R4
   \       0x2E   0x0030             MOVS     R0,R6
   \       0x30   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x34   0xB004             ADD      SP,SP,#+16
   \       0x36   0xBD70             POP      {R4-R6,PC}
   1226          }
   1227          
   1228          /*
   1229           * Signed subtraction: X = A - b
   1230           */

   \                                 In section .text, align 2, keep-with-next
   1231          int mbedtls_mpi_sub_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b)
   1232          {
   \                     mbedtls_mpi_sub_int: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   1233              mbedtls_mpi B;
   1234              mbedtls_mpi_uint p[1];
   1235              MPI_VALIDATE_RET(X != NULL);
   1236              MPI_VALIDATE_RET(A != NULL);
   1237          
   1238              p[0] = mpi_sint_abs(b);
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       mpi_sint_abs
   \        0xE   0x9000             STR      R0,[SP, #+0]
   1239              B.s = TO_SIGN(b);
   \       0x10   0x0029             MOVS     R1,R5
   \       0x12   0x0FC9             LSRS     R1,R1,#+31
   \       0x14   0xF07F 0x0001      MVNS     R0,#+1
   \       0x18   0x4341             MULS     R1,R0,R1
   \       0x1A   0x1C49             ADDS     R1,R1,#+1
   \       0x1C   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   1240              B.n = 1;
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1241              B.p = p;
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x9001             STR      R0,[SP, #+4]
   1242          
   1243              return mbedtls_mpi_sub_mpi(X, A, &B);
   \       0x2A   0xAA01             ADD      R2,SP,#+4
   \       0x2C   0x0021             MOVS     R1,R4
   \       0x2E   0x0030             MOVS     R0,R6
   \       0x30   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x34   0xB004             ADD      SP,SP,#+16
   \       0x36   0xBD70             POP      {R4-R6,PC}
   1244          }
   1245          
   1246          /*
   1247           * Baseline multiplication: X = A * B  (HAC 14.12)
   1248           */

   \                                 In section .text, align 2, keep-with-next
   1249          int mbedtls_mpi_mul_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1250          {
   \                     mbedtls_mpi_mul_mpi: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000F             MOVS     R7,R1
   \        0xA   0x4690             MOV      R8,R2
   1251              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x096D      MVNS     R9,#+109
   1252              size_t i, j;
   1253              mbedtls_mpi TA, TB;
   1254              int result_is_zero = 0;
   \       0x10   0x2600             MOVS     R6,#+0
   1255              MPI_VALIDATE_RET(X != NULL);
   1256              MPI_VALIDATE_RET(A != NULL);
   1257              MPI_VALIDATE_RET(B != NULL);
   1258          
   1259              mbedtls_mpi_init(&TA);
   \       0x12   0xA803             ADD      R0,SP,#+12
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_init
   1260              mbedtls_mpi_init(&TB);
   \       0x18   0xA801             ADD      R0,SP,#+4
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_init
   1261          
   1262              if (X == A) {
   \       0x1E   0x45BA             CMP      R10,R7
   \       0x20   0xD108             BNE.N    ??mbedtls_mpi_mul_mpi_0
   1263                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TA, A)); A = &TA;
   \       0x22   0x0039             MOVS     R1,R7
   \       0x24   0xA803             ADD      R0,SP,#+12
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x2A   0x4681             MOV      R9,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD154             BNE.N    ??mbedtls_mpi_mul_mpi_1
   \                     ??mbedtls_mpi_mul_mpi_2: (+1)
   \       0x30   0xA803             ADD      R0,SP,#+12
   \       0x32   0x0007             MOVS     R7,R0
   1264              }
   1265              if (X == B) {
   \                     ??mbedtls_mpi_mul_mpi_0: (+1)
   \       0x34   0x45C2             CMP      R10,R8
   \       0x36   0xD108             BNE.N    ??mbedtls_mpi_mul_mpi_3
   1266                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, B)); B = &TB;
   \       0x38   0x4641             MOV      R1,R8
   \       0x3A   0xA801             ADD      R0,SP,#+4
   \       0x3C   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x40   0x4681             MOV      R9,R0
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD149             BNE.N    ??mbedtls_mpi_mul_mpi_1
   \                     ??mbedtls_mpi_mul_mpi_4: (+1)
   \       0x46   0xA801             ADD      R0,SP,#+4
   \       0x48   0x4680             MOV      R8,R0
   1267              }
   1268          
   1269              for (i = A->n; i > 0; i--) {
   \                     ??mbedtls_mpi_mul_mpi_3: (+1)
   \       0x4A   0x88F8             LDRH     R0,[R7, #+6]
   \       0x4C   0x0005             MOVS     R5,R0
   \                     ??mbedtls_mpi_mul_mpi_5: (+1)
   \       0x4E   0x2D00             CMP      R5,#+0
   \       0x50   0xD008             BEQ.N    ??mbedtls_mpi_mul_mpi_6
   1270                  if (A->p[i - 1] != 0) {
   \       0x52   0x6838             LDR      R0,[R7, #+0]
   \       0x54   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \       0x58   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD101             BNE.N    ??mbedtls_mpi_mul_mpi_6
   1271                      break;
   1272                  }
   1273              }
   \                     ??mbedtls_mpi_mul_mpi_7: (+1)
   \       0x60   0x1E6D             SUBS     R5,R5,#+1
   \       0x62   0xE7F4             B.N      ??mbedtls_mpi_mul_mpi_5
   1274              if (i == 0) {
   \                     ??mbedtls_mpi_mul_mpi_6: (+1)
   \       0x64   0x2D00             CMP      R5,#+0
   \       0x66   0xD101             BNE.N    ??mbedtls_mpi_mul_mpi_8
   1275                  result_is_zero = 1;
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0x0006             MOVS     R6,R0
   1276              }
   1277          
   1278              for (j = B->n; j > 0; j--) {
   \                     ??mbedtls_mpi_mul_mpi_8: (+1)
   \       0x6C   0xF8B8 0x0006      LDRH     R0,[R8, #+6]
   \       0x70   0x0004             MOVS     R4,R0
   \                     ??mbedtls_mpi_mul_mpi_9: (+1)
   \       0x72   0x2C00             CMP      R4,#+0
   \       0x74   0xD009             BEQ.N    ??mbedtls_mpi_mul_mpi_10
   1279                  if (B->p[j - 1] != 0) {
   \       0x76   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x7A   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0x7E   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD101             BNE.N    ??mbedtls_mpi_mul_mpi_10
   1280                      break;
   1281                  }
   1282              }
   \                     ??mbedtls_mpi_mul_mpi_11: (+1)
   \       0x86   0x1E64             SUBS     R4,R4,#+1
   \       0x88   0xE7F3             B.N      ??mbedtls_mpi_mul_mpi_9
   1283              if (j == 0) {
   \                     ??mbedtls_mpi_mul_mpi_10: (+1)
   \       0x8A   0x2C00             CMP      R4,#+0
   \       0x8C   0xD101             BNE.N    ??mbedtls_mpi_mul_mpi_12
   1284                  result_is_zero = 1;
   \       0x8E   0x2001             MOVS     R0,#+1
   \       0x90   0x0006             MOVS     R6,R0
   1285              }
   1286          
   1287              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, i + j));
   \                     ??mbedtls_mpi_mul_mpi_12: (+1)
   \       0x92   0x1961             ADDS     R1,R4,R5
   \       0x94   0x4650             MOV      R0,R10
   \       0x96   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x9A   0x4681             MOV      R9,R0
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD11C             BNE.N    ??mbedtls_mpi_mul_mpi_1
   1288              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, 0));
   \                     ??mbedtls_mpi_mul_mpi_13: (+1)
   \       0xA0   0x2100             MOVS     R1,#+0
   \       0xA2   0x4650             MOV      R0,R10
   \       0xA4   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xA8   0x4681             MOV      R9,R0
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD115             BNE.N    ??mbedtls_mpi_mul_mpi_1
   1289          
   1290              mbedtls_mpi_core_mul(X->p, A->p, i, B->p, j);
   \                     ??mbedtls_mpi_mul_mpi_14: (+1)
   \       0xAE   0x9400             STR      R4,[SP, #+0]
   \       0xB0   0xF8D8 0x3000      LDR      R3,[R8, #+0]
   \       0xB4   0x002A             MOVS     R2,R5
   \       0xB6   0x6839             LDR      R1,[R7, #+0]
   \       0xB8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xBC   0x.... 0x....      BL       mbedtls_mpi_core_mul
   1291          
   1292              /* If the result is 0, we don't shortcut the operation, which reduces
   1293               * but does not eliminate side channels leaking the zero-ness. We do
   1294               * need to take care to set the sign bit properly since the library does
   1295               * not fully support an MPI object with a value of 0 and s == -1. */
   1296              if (result_is_zero) {
   \       0xC0   0x2E00             CMP      R6,#+0
   \       0xC2   0xD003             BEQ.N    ??mbedtls_mpi_mul_mpi_15
   1297                  X->s = 1;
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0xF8AA 0x0004      STRH     R0,[R10, #+4]
   \       0xCA   0xE006             B.N      ??mbedtls_mpi_mul_mpi_1
   1298              } else {
   1299                  X->s = A->s * B->s;
   \                     ??mbedtls_mpi_mul_mpi_15: (+1)
   \       0xCC   0x88B9             LDRH     R1,[R7, #+4]
   \       0xCE   0xF8B8 0x0004      LDRH     R0,[R8, #+4]
   \       0xD2   0xFB11 0xF000      SMULBB   R0,R1,R0
   \       0xD6   0xF8AA 0x0004      STRH     R0,[R10, #+4]
   1300              }
   1301          
   1302          cleanup:
   1303          
   1304              mbedtls_mpi_free(&TB); mbedtls_mpi_free(&TA);
   \                     ??mbedtls_mpi_mul_mpi_1: (+1)
   \       0xDA   0xA801             ADD      R0,SP,#+4
   \       0xDC   0x.... 0x....      BL       mbedtls_mpi_free
   \       0xE0   0xA803             ADD      R0,SP,#+12
   \       0xE2   0x.... 0x....      BL       mbedtls_mpi_free
   1305          
   1306              return ret;
   \       0xE6   0x4648             MOV      R0,R9
   \       0xE8   0xB006             ADD      SP,SP,#+24
   \       0xEA   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1307          }
   1308          
   1309          /*
   1310           * Baseline multiplication: X = A * b
   1311           */

   \                                 In section .text, align 2, keep-with-next
   1312          int mbedtls_mpi_mul_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_uint b)
   1313          {
   \                     mbedtls_mpi_mul_int: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0015             MOVS     R5,R2
   1314              MPI_VALIDATE_RET(X != NULL);
   1315              MPI_VALIDATE_RET(A != NULL);
   1316          
   1317              size_t n = A->n;
   \        0xA   0x88FC             LDRH     R4,[R7, #+6]
   1318              while (n > 0 && A->p[n - 1] == 0) {
   \                     ??mbedtls_mpi_mul_int_0: (+1)
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD008             BEQ.N    ??mbedtls_mpi_mul_int_1
   \       0x10   0x6838             LDR      R0,[R7, #+0]
   \       0x12   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0x16   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD101             BNE.N    ??mbedtls_mpi_mul_int_1
   1319                  --n;
   \       0x1E   0x1E64             SUBS     R4,R4,#+1
   \       0x20   0xE7F4             B.N      ??mbedtls_mpi_mul_int_0
   1320              }
   1321          
   1322              /* The general method below doesn't work if b==0. */
   1323              if (b == 0 || n == 0) {
   \                     ??mbedtls_mpi_mul_int_1: (+1)
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD001             BEQ.N    ??mbedtls_mpi_mul_int_2
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD104             BNE.N    ??mbedtls_mpi_mul_int_3
   1324                  return mbedtls_mpi_lset(X, 0);
   \                     ??mbedtls_mpi_mul_int_2: (+1)
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x0030             MOVS     R0,R6
   \       0x2E   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x32   0xE018             B.N      ??mbedtls_mpi_mul_int_4
   1325              }
   1326          
   1327              /* Calculate A*b as A + A*(b-1) to take advantage of mbedtls_mpi_core_mla */
   1328              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_mpi_mul_int_3: (+1)
   \       0x34   0xF07F 0x096D      MVNS     R9,#+109
   1329              /* In general, A * b requires 1 limb more than b. If
   1330               * A->p[n - 1] * b / b == A->p[n - 1], then A * b fits in the same
   1331               * number of limbs as A and the call to grow() is not required since
   1332               * copy() will take care of the growth if needed. However, experimentally,
   1333               * making the call to grow() unconditional causes slightly fewer
   1334               * calls to calloc() in ECP code, presumably because it reuses the
   1335               * same mpi for a while and this way the mpi is more likely to directly
   1336               * grow to its final size.
   1337               *
   1338               * Note that calculating A*b as 0 + A*b doesn't work as-is because
   1339               * A,X can be the same. */
   1340              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, n + 1));
   \       0x38   0x1C61             ADDS     R1,R4,#+1
   \       0x3A   0x0030             MOVS     R0,R6
   \       0x3C   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x40   0x4680             MOV      R8,R0
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD10E             BNE.N    ??mbedtls_mpi_mul_int_5
   1341              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A));
   \                     ??mbedtls_mpi_mul_int_6: (+1)
   \       0x46   0x0039             MOVS     R1,R7
   \       0x48   0x0030             MOVS     R0,R6
   \       0x4A   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x4E   0x4680             MOV      R8,R0
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD107             BNE.N    ??mbedtls_mpi_mul_int_5
   1342              mbedtls_mpi_core_mla(X->p, X->n, A->p, n, b - 1);
   \                     ??mbedtls_mpi_mul_int_7: (+1)
   \       0x54   0x1E68             SUBS     R0,R5,#+1
   \       0x56   0x9000             STR      R0,[SP, #+0]
   \       0x58   0x0023             MOVS     R3,R4
   \       0x5A   0x683A             LDR      R2,[R7, #+0]
   \       0x5C   0x88F1             LDRH     R1,[R6, #+6]
   \       0x5E   0x6830             LDR      R0,[R6, #+0]
   \       0x60   0x.... 0x....      BL       mbedtls_mpi_core_mla
   1343          
   1344          cleanup:
   1345              return ret;
   \                     ??mbedtls_mpi_mul_int_5: (+1)
   \       0x64   0x4640             MOV      R0,R8
   \                     ??mbedtls_mpi_mul_int_4: (+1)
   \       0x66   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1346          }
   1347          
   1348          /*
   1349           * Unsigned integer divide - double mbedtls_mpi_uint dividend, u1/u0, and
   1350           * mbedtls_mpi_uint divisor, d
   1351           */

   \                                 In section .text, align 2, keep-with-next
   1352          static mbedtls_mpi_uint mbedtls_int_div_int(mbedtls_mpi_uint u1,
   1353                                                      mbedtls_mpi_uint u0,
   1354                                                      mbedtls_mpi_uint d,
   1355                                                      mbedtls_mpi_uint *r)
   1356          {
   \                     mbedtls_int_div_int: (+1)
   \        0x0   0xE92D 0x4DFC      PUSH     {R2-R8,R10,R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001C             MOVS     R4,R3
   1357          #if defined(MBEDTLS_HAVE_UDBL)
   1358              mbedtls_t_udbl dividend, quotient;
   1359          #else
   1360              const mbedtls_mpi_uint radix = (mbedtls_mpi_uint) 1 << biH;
   1361              const mbedtls_mpi_uint uint_halfword_mask = ((mbedtls_mpi_uint) 1 << biH) - 1;
   1362              mbedtls_mpi_uint d0, d1, q0, q1, rAX, r0, quotient;
   1363              mbedtls_mpi_uint u0_msw, u0_lsw;
   1364              size_t s;
   1365          #endif
   1366          
   1367              /*
   1368               * Check for overflow
   1369               */
   1370              if (0 == d || u1 >= d) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD001             BEQ.N    ??mbedtls_int_div_int_0
   \       0x10   0x45B0             CMP      R8,R6
   \       0x12   0xD307             BCC.N    ??mbedtls_int_div_int_1
   1371                  if (r != NULL) {
   \                     ??mbedtls_int_div_int_0: (+1)
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD002             BEQ.N    ??mbedtls_int_div_int_2
   1372                      *r = ~(mbedtls_mpi_uint) 0u;
   \       0x18   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1C   0x6020             STR      R0,[R4, #+0]
   1373                  }
   1374          
   1375                  return ~(mbedtls_mpi_uint) 0u;
   \                     ??mbedtls_int_div_int_2: (+1)
   \       0x1E   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x22   0xE02B             B.N      ??mbedtls_int_div_int_3
   1376              }
   1377          
   1378          #if defined(MBEDTLS_HAVE_UDBL)
   1379              dividend  = (mbedtls_t_udbl) u1 << biL;
   \                     ??mbedtls_int_div_int_1: (+1)
   \       0x24   0x4642             MOV      R2,R8
   \       0x26   0x2300             MOVS     R3,#+0
   \       0x28   0x0013             MOVS     R3,R2
   \       0x2A   0x2200             MOVS     R2,#+0
   1380              dividend |= (mbedtls_t_udbl) u0;
   \       0x2C   0x0028             MOVS     R0,R5
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x4310             ORRS     R0,R2,R0
   \       0x32   0x4319             ORRS     R1,R3,R1
   \       0x34   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   1381              quotient = dividend / d;
   \       0x38   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \       0x3C   0x0032             MOVS     R2,R6
   \       0x3E   0x2300             MOVS     R3,#+0
   \       0x40   0x.... 0x....      BL       __aeabi_uldivmod
   1382              if (quotient > ((mbedtls_t_udbl) 1 << biL) - 1) {
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x2301             MOVS     R3,#+1
   \       0x48   0x4299             CMP      R1,R3
   \       0x4A   0xD307             BCC.N    ??mbedtls_int_div_int_4
   \       0x4C   0xD801             BHI.N    ??mbedtls_int_div_int_5
   \       0x4E   0x4290             CMP      R0,R2
   \       0x50   0xD304             BCC.N    ??mbedtls_int_div_int_4
   1383                  quotient = ((mbedtls_t_udbl) 1 << biL) - 1;
   \                     ??mbedtls_int_div_int_5: (+1)
   \       0x52   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x56   0x2300             MOVS     R3,#+0
   \       0x58   0x0010             MOVS     R0,R2
   \       0x5A   0x0019             MOVS     R1,R3
   1384              }
   1385          
   1386              if (r != NULL) {
   \                     ??mbedtls_int_div_int_4: (+1)
   \       0x5C   0x2C00             CMP      R4,#+0
   \       0x5E   0xD00D             BEQ.N    ??mbedtls_int_div_int_6
   1387                  *r = (mbedtls_mpi_uint) (dividend - (quotient * d));
   \       0x60   0xE9DD 0xAB00      LDRD     R10,R11,[SP, #+0]
   \       0x64   0x2700             MOVS     R7,#+0
   \       0x66   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \       0x6A   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \       0x6E   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \       0x72   0xEBBA 0x0202      SUBS     R2,R10,R2
   \       0x76   0xEB7B 0x0303      SBCS     R3,R11,R3
   \       0x7A   0x6022             STR      R2,[R4, #+0]
   1388              }
   1389          
   1390              return (mbedtls_mpi_uint) quotient;
   \                     ??mbedtls_int_div_int_6: (+1)
   \                     ??mbedtls_int_div_int_3: (+1)
   \       0x7C   0xE8BD 0x8DF6      POP      {R1,R2,R4-R8,R10,R11,PC}
   1391          #else
   1392          
   1393              /*
   1394               * Algorithm D, Section 4.3.1 - The Art of Computer Programming
   1395               *   Vol. 2 - Seminumerical Algorithms, Knuth
   1396               */
   1397          
   1398              /*
   1399               * Normalize the divisor, d, and dividend, u0, u1
   1400               */
   1401              s = mbedtls_mpi_core_clz(d);
   1402              d = d << s;
   1403          
   1404              u1 = u1 << s;
   1405              u1 |= (u0 >> (biL - s)) & (-(mbedtls_mpi_sint) s >> (biL - 1));
   1406              u0 =  u0 << s;
   1407          
   1408              d1 = d >> biH;
   1409              d0 = d & uint_halfword_mask;
   1410          
   1411              u0_msw = u0 >> biH;
   1412              u0_lsw = u0 & uint_halfword_mask;
   1413          
   1414              /*
   1415               * Find the first quotient and remainder
   1416               */
   1417              q1 = u1 / d1;
   1418              r0 = u1 - d1 * q1;
   1419          
   1420              while (q1 >= radix || (q1 * d0 > radix * r0 + u0_msw)) {
   1421                  q1 -= 1;
   1422                  r0 += d1;
   1423          
   1424                  if (r0 >= radix) {
   1425                      break;
   1426                  }
   1427              }
   1428          
   1429              rAX = (u1 * radix) + (u0_msw - q1 * d);
   1430              q0 = rAX / d1;
   1431              r0 = rAX - q0 * d1;
   1432          
   1433              while (q0 >= radix || (q0 * d0 > radix * r0 + u0_lsw)) {
   1434                  q0 -= 1;
   1435                  r0 += d1;
   1436          
   1437                  if (r0 >= radix) {
   1438                      break;
   1439                  }
   1440              }
   1441          
   1442              if (r != NULL) {
   1443                  *r = (rAX * radix + u0_lsw - q0 * d) >> s;
   1444              }
   1445          
   1446              quotient = q1 * radix + q0;
   1447          
   1448              return quotient;
   1449          #endif
   1450          }
   1451          
   1452          /*
   1453           * Division by mbedtls_mpi: A = Q * B + R  (HAC 14.20)
   1454           */

   \                                 In section .text, align 2, keep-with-next
   1455          int mbedtls_mpi_div_mpi(mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A,
   1456                                  const mbedtls_mpi *B)
   1457          {
   \                     mbedtls_mpi_div_mpi: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08E             SUB      SP,SP,#+56
   \        0x6   0x0006             MOVS     R6,R0
   \        0x8   0x000F             MOVS     R7,R1
   \        0xA   0x4693             MOV      R11,R2
   \        0xC   0x4699             MOV      R9,R3
   1458              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0A6D      MVNS     R10,#+109
   1459              size_t i, n, t, k;
   1460              mbedtls_mpi X, Y, Z, T1, T2;
   1461              mbedtls_mpi_uint TP2[3];
   1462              MPI_VALIDATE_RET(A != NULL);
   1463              MPI_VALIDATE_RET(B != NULL);
   1464          
   1465              if (mbedtls_mpi_cmp_int(B, 0) == 0) {
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x4648             MOV      R0,R9
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??mbedtls_mpi_div_mpi_0
   1466                  return MBEDTLS_ERR_MPI_DIVISION_BY_ZERO;
   \       0x1E   0xF07F 0x000B      MVNS     R0,#+11
   \       0x22   0xE1C8             B.N      ??mbedtls_mpi_div_mpi_1
   1467              }
   1468          
   1469              mbedtls_mpi_init(&X); mbedtls_mpi_init(&Y); mbedtls_mpi_init(&Z);
   \                     ??mbedtls_mpi_div_mpi_0: (+1)
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x2A   0xA802             ADD      R0,SP,#+8
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x30   0xA804             ADD      R0,SP,#+16
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_init
   1470              mbedtls_mpi_init(&T1);
   \       0x36   0xA806             ADD      R0,SP,#+24
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_init
   1471              /*
   1472               * Avoid dynamic memory allocations for constant-size T2.
   1473               *
   1474               * T2 is used for comparison only and the 3 limbs are assigned explicitly,
   1475               * so nobody increase the size of the MPI and we're safe to use an on-stack
   1476               * buffer.
   1477               */
   1478              T2.s = 1;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xF8AD 0x0028      STRH     R0,[SP, #+40]
   1479              T2.n = sizeof(TP2) / sizeof(*TP2);
   \       0x42   0x2003             MOVS     R0,#+3
   \       0x44   0xF8AD 0x002A      STRH     R0,[SP, #+42]
   1480              T2.p = TP2;
   \       0x48   0xA80B             ADD      R0,SP,#+44
   \       0x4A   0x9009             STR      R0,[SP, #+36]
   1481          
   1482              if (mbedtls_mpi_cmp_abs(A, B) < 0) {
   \       0x4C   0x4649             MOV      R1,R9
   \       0x4E   0x4658             MOV      R0,R11
   \       0x50   0x.... 0x....      BL       mbedtls_mpi_cmp_abs
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD515             BPL.N    ??mbedtls_mpi_div_mpi_2
   1483                  if (Q != NULL) {
   \       0x58   0x2E00             CMP      R6,#+0
   \       0x5A   0xD007             BEQ.N    ??mbedtls_mpi_div_mpi_3
   1484                      MBEDTLS_MPI_CHK(mbedtls_mpi_lset(Q, 0));
   \       0x5C   0x2100             MOVS     R1,#+0
   \       0x5E   0x0030             MOVS     R0,R6
   \       0x60   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x64   0x4682             MOV      R10,R0
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xF040 0x8194      BNE.W    ??mbedtls_mpi_div_mpi_4
   1485                  }
   1486                  if (R != NULL) {
   \                     ??mbedtls_mpi_div_mpi_5: (+1)
   \                     ??mbedtls_mpi_div_mpi_3: (+1)
   \       0x6C   0x2F00             CMP      R7,#+0
   \       0x6E   0xD007             BEQ.N    ??mbedtls_mpi_div_mpi_6
   1487                      MBEDTLS_MPI_CHK(mbedtls_mpi_copy(R, A));
   \       0x70   0x4659             MOV      R1,R11
   \       0x72   0x0038             MOVS     R0,R7
   \       0x74   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x78   0x4682             MOV      R10,R0
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xF040 0x818A      BNE.W    ??mbedtls_mpi_div_mpi_4
   1488                  }
   1489                  return 0;
   \                     ??mbedtls_mpi_div_mpi_7: (+1)
   \                     ??mbedtls_mpi_div_mpi_6: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xE198             B.N      ??mbedtls_mpi_div_mpi_1
   1490              }
   1491          
   1492              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&X, A));
   \                     ??mbedtls_mpi_div_mpi_2: (+1)
   \       0x84   0x4659             MOV      R1,R11
   \       0x86   0x4668             MOV      R0,SP
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x8C   0x4682             MOV      R10,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xF040 0x8180      BNE.W    ??mbedtls_mpi_div_mpi_4
   1493              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Y, B));
   \                     ??mbedtls_mpi_div_mpi_8: (+1)
   \       0x94   0x4649             MOV      R1,R9
   \       0x96   0xA802             ADD      R0,SP,#+8
   \       0x98   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x9C   0x4682             MOV      R10,R0
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xF040 0x8178      BNE.W    ??mbedtls_mpi_div_mpi_4
   1494              X.s = Y.s = 1;
   \                     ??mbedtls_mpi_div_mpi_9: (+1)
   \       0xA4   0x2001             MOVS     R0,#+1
   \       0xA6   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   \       0xAA   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \       0xAE   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1495          
   1496              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&Z, A->n + 2));
   \       0xB2   0xF8BB 0x1006      LDRH     R1,[R11, #+6]
   \       0xB6   0x1C89             ADDS     R1,R1,#+2
   \       0xB8   0xA804             ADD      R0,SP,#+16
   \       0xBA   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0xBE   0x4682             MOV      R10,R0
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xF040 0x8167      BNE.W    ??mbedtls_mpi_div_mpi_4
   1497              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&Z,  0));
   \                     ??mbedtls_mpi_div_mpi_10: (+1)
   \       0xC6   0x2100             MOVS     R1,#+0
   \       0xC8   0xA804             ADD      R0,SP,#+16
   \       0xCA   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xCE   0x4682             MOV      R10,R0
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xF040 0x815F      BNE.W    ??mbedtls_mpi_div_mpi_4
   1498              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&T1, A->n + 2));
   \                     ??mbedtls_mpi_div_mpi_11: (+1)
   \       0xD6   0xF8BB 0x1006      LDRH     R1,[R11, #+6]
   \       0xDA   0x1C89             ADDS     R1,R1,#+2
   \       0xDC   0xA806             ADD      R0,SP,#+24
   \       0xDE   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0xE2   0x4682             MOV      R10,R0
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xF040 0x8155      BNE.W    ??mbedtls_mpi_div_mpi_4
   1499          
   1500              k = mbedtls_mpi_bitlen(&Y) % biL;
   \                     ??mbedtls_mpi_div_mpi_12: (+1)
   \       0xEA   0xA802             ADD      R0,SP,#+8
   \       0xEC   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0xF0   0xF010 0x001F      ANDS     R0,R0,#0x1F
   1501              if (k < biL - 1) {
   \       0xF4   0x281F             CMP      R0,#+31
   \       0xF6   0xD213             BCS.N    ??mbedtls_mpi_div_mpi_13
   1502                  k = biL - 1 - k;
   \       0xF8   0x4680             MOV      R8,R0
   \       0xFA   0xF1D8 0x081F      RSBS     R8,R8,#+31
   1503                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&X, k));
   \       0xFE   0x4641             MOV      R1,R8
   \      0x100   0x4668             MOV      R0,SP
   \      0x102   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x106   0x4682             MOV      R10,R0
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xF040 0x8143      BNE.W    ??mbedtls_mpi_div_mpi_4
   1504                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&Y, k));
   \                     ??mbedtls_mpi_div_mpi_14: (+1)
   \      0x10E   0x4641             MOV      R1,R8
   \      0x110   0xA802             ADD      R0,SP,#+8
   \      0x112   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x116   0x4682             MOV      R10,R0
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xF040 0x813B      BNE.W    ??mbedtls_mpi_div_mpi_4
   \                     ??mbedtls_mpi_div_mpi_15: (+1)
   \      0x11E   0xE001             B.N      ??mbedtls_mpi_div_mpi_16
   1505              } else {
   1506                  k = 0;
   \                     ??mbedtls_mpi_div_mpi_13: (+1)
   \      0x120   0xF05F 0x0800      MOVS     R8,#+0
   1507              }
   1508          
   1509              n = X.n - 1;
   \                     ??mbedtls_mpi_div_mpi_16: (+1)
   \      0x124   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x128   0x1E40             SUBS     R0,R0,#+1
   \      0x12A   0x9008             STR      R0,[SP, #+32]
   1510              t = Y.n - 1;
   \      0x12C   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \      0x130   0x1E40             SUBS     R0,R0,#+1
   \      0x132   0x0004             MOVS     R4,R0
   1511              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&Y, biL * (n - t)));
   \      0x134   0x9808             LDR      R0,[SP, #+32]
   \      0x136   0x1B00             SUBS     R0,R0,R4
   \      0x138   0x0141             LSLS     R1,R0,#+5
   \      0x13A   0xA802             ADD      R0,SP,#+8
   \      0x13C   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x140   0x4682             MOV      R10,R0
   \      0x142   0x2800             CMP      R0,#+0
   \      0x144   0xF040 0x8126      BNE.W    ??mbedtls_mpi_div_mpi_4
   1512          
   1513              while (mbedtls_mpi_cmp_mpi(&X, &Y) >= 0) {
   \                     ??mbedtls_mpi_div_mpi_17: (+1)
   \                     ??mbedtls_mpi_div_mpi_18: (+1)
   \      0x148   0xA902             ADD      R1,SP,#+8
   \      0x14A   0x4668             MOV      R0,SP
   \      0x14C   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD414             BMI.N    ??mbedtls_mpi_div_mpi_19
   1514                  Z.p[n - t]++;
   \      0x154   0x9904             LDR      R1,[SP, #+16]
   \      0x156   0x9808             LDR      R0,[SP, #+32]
   \      0x158   0x1B00             SUBS     R0,R0,R4
   \      0x15A   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \      0x15E   0x1C52             ADDS     R2,R2,#+1
   \      0x160   0x9904             LDR      R1,[SP, #+16]
   \      0x162   0x9808             LDR      R0,[SP, #+32]
   \      0x164   0x1B00             SUBS     R0,R0,R4
   \      0x166   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   1515                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&X, &X, &Y));
   \      0x16A   0xAA02             ADD      R2,SP,#+8
   \      0x16C   0x4669             MOV      R1,SP
   \      0x16E   0x4668             MOV      R0,SP
   \      0x170   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x174   0x4682             MOV      R10,R0
   \      0x176   0x2800             CMP      R0,#+0
   \      0x178   0xF040 0x810C      BNE.W    ??mbedtls_mpi_div_mpi_4
   \                     ??mbedtls_mpi_div_mpi_20: (+1)
   \      0x17C   0xE7E4             B.N      ??mbedtls_mpi_div_mpi_18
   1516              }
   1517              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&Y, biL * (n - t)));
   \                     ??mbedtls_mpi_div_mpi_19: (+1)
   \      0x17E   0x9808             LDR      R0,[SP, #+32]
   \      0x180   0x1B00             SUBS     R0,R0,R4
   \      0x182   0x0141             LSLS     R1,R0,#+5
   \      0x184   0xA802             ADD      R0,SP,#+8
   \      0x186   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x18A   0x4682             MOV      R10,R0
   \      0x18C   0x2800             CMP      R0,#+0
   \      0x18E   0xF040 0x8101      BNE.W    ??mbedtls_mpi_div_mpi_4
   1518          
   1519              for (i = n; i > t; i--) {
   \                     ??mbedtls_mpi_div_mpi_21: (+1)
   \      0x192   0x9808             LDR      R0,[SP, #+32]
   \      0x194   0x0005             MOVS     R5,R0
   \                     ??mbedtls_mpi_div_mpi_22: (+1)
   \      0x196   0x42AC             CMP      R4,R5
   \      0x198   0xF080 0x80D0      BCS.W    ??mbedtls_mpi_div_mpi_23
   1520                  if (X.p[i] >= Y.p[t]) {
   \      0x19C   0x9800             LDR      R0,[SP, #+0]
   \      0x19E   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \      0x1A2   0x9902             LDR      R1,[SP, #+8]
   \      0x1A4   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \      0x1A8   0x4288             CMP      R0,R1
   \      0x1AA   0xD308             BCC.N    ??mbedtls_mpi_div_mpi_24
   1521                      Z.p[i - t - 1] = ~(mbedtls_mpi_uint) 0u;
   \      0x1AC   0x9904             LDR      R1,[SP, #+16]
   \      0x1AE   0x1B28             SUBS     R0,R5,R4
   \      0x1B0   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \      0x1B4   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x1B8   0xF841 0x0C04      STR      R0,[R1, #-4]
   \      0x1BC   0xE013             B.N      ??mbedtls_mpi_div_mpi_25
   1522                  } else {
   1523                      Z.p[i - t - 1] = mbedtls_int_div_int(X.p[i], X.p[i - 1],
   1524                                                           Y.p[t], NULL);
   \                     ??mbedtls_mpi_div_mpi_24: (+1)
   \      0x1BE   0x2300             MOVS     R3,#+0
   \      0x1C0   0x9802             LDR      R0,[SP, #+8]
   \      0x1C2   0xF850 0x2024      LDR      R2,[R0, R4, LSL #+2]
   \      0x1C6   0x9800             LDR      R0,[SP, #+0]
   \      0x1C8   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \      0x1CC   0xF850 0x1C04      LDR      R1,[R0, #-4]
   \      0x1D0   0x9800             LDR      R0,[SP, #+0]
   \      0x1D2   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \      0x1D6   0x.... 0x....      BL       mbedtls_int_div_int
   \      0x1DA   0x9904             LDR      R1,[SP, #+16]
   \      0x1DC   0x1B2A             SUBS     R2,R5,R4
   \      0x1DE   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \      0x1E2   0xF841 0x0C04      STR      R0,[R1, #-4]
   1525                  }
   1526          
   1527                  T2.p[0] = (i < 2) ? 0 : X.p[i - 2];
   \                     ??mbedtls_mpi_div_mpi_25: (+1)
   \      0x1E6   0x2D02             CMP      R5,#+2
   \      0x1E8   0xD201             BCS.N    ??mbedtls_mpi_div_mpi_26
   \      0x1EA   0x2000             MOVS     R0,#+0
   \      0x1EC   0xE004             B.N      ??mbedtls_mpi_div_mpi_27
   \                     ??mbedtls_mpi_div_mpi_26: (+1)
   \      0x1EE   0x9800             LDR      R0,[SP, #+0]
   \      0x1F0   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \      0x1F4   0xF850 0x0C08      LDR      R0,[R0, #-8]
   \                     ??mbedtls_mpi_div_mpi_27: (+1)
   \      0x1F8   0x9909             LDR      R1,[SP, #+36]
   \      0x1FA   0x6008             STR      R0,[R1, #+0]
   1528                  T2.p[1] = (i < 1) ? 0 : X.p[i - 1];
   \      0x1FC   0x2D00             CMP      R5,#+0
   \      0x1FE   0xD101             BNE.N    ??mbedtls_mpi_div_mpi_28
   \      0x200   0x2100             MOVS     R1,#+0
   \      0x202   0xE004             B.N      ??mbedtls_mpi_div_mpi_29
   \                     ??mbedtls_mpi_div_mpi_28: (+1)
   \      0x204   0x9800             LDR      R0,[SP, #+0]
   \      0x206   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \      0x20A   0xF850 0x1C04      LDR      R1,[R0, #-4]
   \                     ??mbedtls_mpi_div_mpi_29: (+1)
   \      0x20E   0x9809             LDR      R0,[SP, #+36]
   \      0x210   0x6041             STR      R1,[R0, #+4]
   1529                  T2.p[2] = X.p[i];
   \      0x212   0x9800             LDR      R0,[SP, #+0]
   \      0x214   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \      0x218   0x9809             LDR      R0,[SP, #+36]
   \      0x21A   0x6081             STR      R1,[R0, #+8]
   1530          
   1531                  Z.p[i - t - 1]++;
   \      0x21C   0x9904             LDR      R1,[SP, #+16]
   \      0x21E   0x1B28             SUBS     R0,R5,R4
   \      0x220   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \      0x224   0x9A04             LDR      R2,[SP, #+16]
   \      0x226   0x1B29             SUBS     R1,R5,R4
   \      0x228   0xEB02 0x0181      ADD      R1,R2,R1, LSL #+2
   \      0x22C   0xF851 0x1C04      LDR      R1,[R1, #-4]
   \      0x230   0x1C49             ADDS     R1,R1,#+1
   \      0x232   0xF840 0x1C04      STR      R1,[R0, #-4]
   1532                  do {
   1533                      Z.p[i - t - 1]--;
   \                     ??mbedtls_mpi_div_mpi_30: (+1)
   \      0x236   0x9904             LDR      R1,[SP, #+16]
   \      0x238   0x1B28             SUBS     R0,R5,R4
   \      0x23A   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \      0x23E   0x9904             LDR      R1,[SP, #+16]
   \      0x240   0x1B2A             SUBS     R2,R5,R4
   \      0x242   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \      0x246   0xF851 0x1C04      LDR      R1,[R1, #-4]
   \      0x24A   0x1E49             SUBS     R1,R1,#+1
   \      0x24C   0xF840 0x1C04      STR      R1,[R0, #-4]
   1534          
   1535                      MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&T1, 0));
   \      0x250   0x2100             MOVS     R1,#+0
   \      0x252   0xA806             ADD      R0,SP,#+24
   \      0x254   0x.... 0x....      BL       mbedtls_mpi_lset
   \      0x258   0x4682             MOV      R10,R0
   \      0x25A   0x2800             CMP      R0,#+0
   \      0x25C   0xF040 0x809A      BNE.W    ??mbedtls_mpi_div_mpi_4
   1536                      T1.p[0] = (t < 1) ? 0 : Y.p[t - 1];
   \                     ??mbedtls_mpi_div_mpi_31: (+1)
   \      0x260   0x2C00             CMP      R4,#+0
   \      0x262   0xD101             BNE.N    ??mbedtls_mpi_div_mpi_32
   \      0x264   0x2100             MOVS     R1,#+0
   \      0x266   0xE004             B.N      ??mbedtls_mpi_div_mpi_33
   \                     ??mbedtls_mpi_div_mpi_32: (+1)
   \      0x268   0x9802             LDR      R0,[SP, #+8]
   \      0x26A   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \      0x26E   0xF850 0x1C04      LDR      R1,[R0, #-4]
   \                     ??mbedtls_mpi_div_mpi_33: (+1)
   \      0x272   0x9806             LDR      R0,[SP, #+24]
   \      0x274   0x6001             STR      R1,[R0, #+0]
   1537                      T1.p[1] = Y.p[t];
   \      0x276   0x9802             LDR      R0,[SP, #+8]
   \      0x278   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \      0x27C   0x9806             LDR      R0,[SP, #+24]
   \      0x27E   0x6041             STR      R1,[R0, #+4]
   1538                      MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T1, &T1, Z.p[i - t - 1]));
   \      0x280   0x9904             LDR      R1,[SP, #+16]
   \      0x282   0x1B28             SUBS     R0,R5,R4
   \      0x284   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \      0x288   0xF850 0x2C04      LDR      R2,[R0, #-4]
   \      0x28C   0xA906             ADD      R1,SP,#+24
   \      0x28E   0xA806             ADD      R0,SP,#+24
   \      0x290   0x.... 0x....      BL       mbedtls_mpi_mul_int
   \      0x294   0x4682             MOV      R10,R0
   \      0x296   0x2800             CMP      R0,#+0
   \      0x298   0xD17C             BNE.N    ??mbedtls_mpi_div_mpi_4
   1539                  } while (mbedtls_mpi_cmp_mpi(&T1, &T2) > 0);
   \                     ??mbedtls_mpi_div_mpi_34: (+1)
   \      0x29A   0xA909             ADD      R1,SP,#+36
   \      0x29C   0xA806             ADD      R0,SP,#+24
   \      0x29E   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x2A2   0x2801             CMP      R0,#+1
   \      0x2A4   0xDAC7             BGE.N    ??mbedtls_mpi_div_mpi_30
   1540          
   1541                  MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T1, &Y, Z.p[i - t - 1]));
   \      0x2A6   0x9904             LDR      R1,[SP, #+16]
   \      0x2A8   0x1B28             SUBS     R0,R5,R4
   \      0x2AA   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \      0x2AE   0xF850 0x2C04      LDR      R2,[R0, #-4]
   \      0x2B2   0xA902             ADD      R1,SP,#+8
   \      0x2B4   0xA806             ADD      R0,SP,#+24
   \      0x2B6   0x.... 0x....      BL       mbedtls_mpi_mul_int
   \      0x2BA   0x4682             MOV      R10,R0
   \      0x2BC   0x2800             CMP      R0,#+0
   \      0x2BE   0xD169             BNE.N    ??mbedtls_mpi_div_mpi_4
   1542                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&T1,  biL * (i - t - 1)));
   \                     ??mbedtls_mpi_div_mpi_35: (+1)
   \      0x2C0   0x1B28             SUBS     R0,R5,R4
   \      0x2C2   0x1E40             SUBS     R0,R0,#+1
   \      0x2C4   0x0141             LSLS     R1,R0,#+5
   \      0x2C6   0xA806             ADD      R0,SP,#+24
   \      0x2C8   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x2CC   0x4682             MOV      R10,R0
   \      0x2CE   0x2800             CMP      R0,#+0
   \      0x2D0   0xD160             BNE.N    ??mbedtls_mpi_div_mpi_4
   1543                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&X, &X, &T1));
   \                     ??mbedtls_mpi_div_mpi_36: (+1)
   \      0x2D2   0xAA06             ADD      R2,SP,#+24
   \      0x2D4   0x4669             MOV      R1,SP
   \      0x2D6   0x4668             MOV      R0,SP
   \      0x2D8   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x2DC   0x4682             MOV      R10,R0
   \      0x2DE   0x2800             CMP      R0,#+0
   \      0x2E0   0xD158             BNE.N    ??mbedtls_mpi_div_mpi_4
   1544          
   1545                  if (mbedtls_mpi_cmp_int(&X, 0) < 0) {
   \                     ??mbedtls_mpi_div_mpi_37: (+1)
   \      0x2E2   0x2100             MOVS     R1,#+0
   \      0x2E4   0x4668             MOV      R0,SP
   \      0x2E6   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x2EA   0x2800             CMP      R0,#+0
   \      0x2EC   0xD524             BPL.N    ??mbedtls_mpi_div_mpi_38
   1546                      MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&T1, &Y));
   \      0x2EE   0xA902             ADD      R1,SP,#+8
   \      0x2F0   0xA806             ADD      R0,SP,#+24
   \      0x2F2   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x2F6   0x4682             MOV      R10,R0
   \      0x2F8   0x2800             CMP      R0,#+0
   \      0x2FA   0xD14B             BNE.N    ??mbedtls_mpi_div_mpi_4
   1547                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&T1, biL * (i - t - 1)));
   \                     ??mbedtls_mpi_div_mpi_39: (+1)
   \      0x2FC   0x1B28             SUBS     R0,R5,R4
   \      0x2FE   0x1E40             SUBS     R0,R0,#+1
   \      0x300   0x0141             LSLS     R1,R0,#+5
   \      0x302   0xA806             ADD      R0,SP,#+24
   \      0x304   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x308   0x4682             MOV      R10,R0
   \      0x30A   0x2800             CMP      R0,#+0
   \      0x30C   0xD142             BNE.N    ??mbedtls_mpi_div_mpi_4
   1548                      MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&X, &X, &T1));
   \                     ??mbedtls_mpi_div_mpi_40: (+1)
   \      0x30E   0xAA06             ADD      R2,SP,#+24
   \      0x310   0x4669             MOV      R1,SP
   \      0x312   0x4668             MOV      R0,SP
   \      0x314   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \      0x318   0x4682             MOV      R10,R0
   \      0x31A   0x2800             CMP      R0,#+0
   \      0x31C   0xD13A             BNE.N    ??mbedtls_mpi_div_mpi_4
   1549                      Z.p[i - t - 1]--;
   \                     ??mbedtls_mpi_div_mpi_41: (+1)
   \      0x31E   0x9904             LDR      R1,[SP, #+16]
   \      0x320   0x1B28             SUBS     R0,R5,R4
   \      0x322   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \      0x326   0x9A04             LDR      R2,[SP, #+16]
   \      0x328   0x1B29             SUBS     R1,R5,R4
   \      0x32A   0xEB02 0x0181      ADD      R1,R2,R1, LSL #+2
   \      0x32E   0xF851 0x1C04      LDR      R1,[R1, #-4]
   \      0x332   0x1E49             SUBS     R1,R1,#+1
   \      0x334   0xF840 0x1C04      STR      R1,[R0, #-4]
   1550                  }
   1551              }
   \                     ??mbedtls_mpi_div_mpi_38: (+1)
   \      0x338   0x1E6D             SUBS     R5,R5,#+1
   \      0x33A   0xE72C             B.N      ??mbedtls_mpi_div_mpi_22
   1552          
   1553              if (Q != NULL) {
   \                     ??mbedtls_mpi_div_mpi_23: (+1)
   \      0x33C   0x2E00             CMP      R6,#+0
   \      0x33E   0xD00D             BEQ.N    ??mbedtls_mpi_div_mpi_42
   1554                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(Q, &Z));
   \      0x340   0xA904             ADD      R1,SP,#+16
   \      0x342   0x0030             MOVS     R0,R6
   \      0x344   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x348   0x4682             MOV      R10,R0
   \      0x34A   0x2800             CMP      R0,#+0
   \      0x34C   0xD122             BNE.N    ??mbedtls_mpi_div_mpi_4
   1555                  Q->s = A->s * B->s;
   \                     ??mbedtls_mpi_div_mpi_43: (+1)
   \      0x34E   0xF8BB 0x1004      LDRH     R1,[R11, #+4]
   \      0x352   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \      0x356   0xFB11 0xF000      SMULBB   R0,R1,R0
   \      0x35A   0x80B0             STRH     R0,[R6, #+4]
   1556              }
   1557          
   1558              if (R != NULL) {
   \                     ??mbedtls_mpi_div_mpi_42: (+1)
   \      0x35C   0x2F00             CMP      R7,#+0
   \      0x35E   0xD019             BEQ.N    ??mbedtls_mpi_div_mpi_4
   1559                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&X, k));
   \      0x360   0x4641             MOV      R1,R8
   \      0x362   0x4668             MOV      R0,SP
   \      0x364   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x368   0x4682             MOV      R10,R0
   \      0x36A   0x2800             CMP      R0,#+0
   \      0x36C   0xD112             BNE.N    ??mbedtls_mpi_div_mpi_4
   1560                  X.s = A->s;
   \                     ??mbedtls_mpi_div_mpi_44: (+1)
   \      0x36E   0xF8BB 0x0004      LDRH     R0,[R11, #+4]
   \      0x372   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1561                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(R, &X));
   \      0x376   0x4669             MOV      R1,SP
   \      0x378   0x0038             MOVS     R0,R7
   \      0x37A   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x37E   0x4682             MOV      R10,R0
   \      0x380   0x2800             CMP      R0,#+0
   \      0x382   0xD107             BNE.N    ??mbedtls_mpi_div_mpi_4
   1562          
   1563                  if (mbedtls_mpi_cmp_int(R, 0) == 0) {
   \                     ??mbedtls_mpi_div_mpi_45: (+1)
   \      0x384   0x2100             MOVS     R1,#+0
   \      0x386   0x0038             MOVS     R0,R7
   \      0x388   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x38C   0x2800             CMP      R0,#+0
   \      0x38E   0xD101             BNE.N    ??mbedtls_mpi_div_mpi_4
   1564                      R->s = 1;
   \      0x390   0x2001             MOVS     R0,#+1
   \      0x392   0x80B8             STRH     R0,[R7, #+4]
   1565                  }
   1566              }
   1567          
   1568          cleanup:
   1569          
   1570              mbedtls_mpi_free(&X); mbedtls_mpi_free(&Y); mbedtls_mpi_free(&Z);
   \                     ??mbedtls_mpi_div_mpi_4: (+1)
   \      0x394   0x4668             MOV      R0,SP
   \      0x396   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x39A   0xA802             ADD      R0,SP,#+8
   \      0x39C   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x3A0   0xA804             ADD      R0,SP,#+16
   \      0x3A2   0x.... 0x....      BL       mbedtls_mpi_free
   1571              mbedtls_mpi_free(&T1);
   \      0x3A6   0xA806             ADD      R0,SP,#+24
   \      0x3A8   0x.... 0x....      BL       mbedtls_mpi_free
   1572              mbedtls_platform_zeroize(TP2, sizeof(TP2));
   \      0x3AC   0x210C             MOVS     R1,#+12
   \      0x3AE   0xA80B             ADD      R0,SP,#+44
   \      0x3B0   0x.... 0x....      BL       mbedtls_platform_zeroize
   1573          
   1574              return ret;
   \      0x3B4   0x4650             MOV      R0,R10
   \                     ??mbedtls_mpi_div_mpi_1: (+1)
   \      0x3B6   0xB00F             ADD      SP,SP,#+60
   \      0x3B8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1575          }
   1576          
   1577          /*
   1578           * Division by int: A = Q * b + R
   1579           */

   \                                 In section .text, align 2, keep-with-next
   1580          int mbedtls_mpi_div_int(mbedtls_mpi *Q, mbedtls_mpi *R,
   1581                                  const mbedtls_mpi *A,
   1582                                  mbedtls_mpi_sint b)
   1583          {
   \                     mbedtls_mpi_div_int: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001E             MOVS     R6,R3
   1584              mbedtls_mpi B;
   1585              mbedtls_mpi_uint p[1];
   1586              MPI_VALIDATE_RET(A != NULL);
   1587          
   1588              p[0] = mpi_sint_abs(b);
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x.... 0x....      BL       mpi_sint_abs
   \       0x10   0x9000             STR      R0,[SP, #+0]
   1589              B.s = TO_SIGN(b);
   \       0x12   0x0031             MOVS     R1,R6
   \       0x14   0x0FC9             LSRS     R1,R1,#+31
   \       0x16   0xF07F 0x0001      MVNS     R0,#+1
   \       0x1A   0x4341             MULS     R1,R0,R1
   \       0x1C   0x1C49             ADDS     R1,R1,#+1
   \       0x1E   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   1590              B.n = 1;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1591              B.p = p;
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x9001             STR      R0,[SP, #+4]
   1592          
   1593              return mbedtls_mpi_div_mpi(Q, R, A, &B);
   \       0x2C   0xAB01             ADD      R3,SP,#+4
   \       0x2E   0x002A             MOVS     R2,R5
   \       0x30   0x0021             MOVS     R1,R4
   \       0x32   0x0038             MOVS     R0,R7
   \       0x34   0x.... 0x....      BL       mbedtls_mpi_div_mpi
   \       0x38   0xBDFE             POP      {R1-R7,PC}
   1594          }
   1595          
   1596          /*
   1597           * Modulo: R = A mod B
   1598           */

   \                                 In section .text, align 2, keep-with-next
   1599          int mbedtls_mpi_mod_mpi(mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1600          {
   \                     mbedtls_mpi_mod_mpi: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1601              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x086D      MVNS     R8,#+109
   1602              MPI_VALIDATE_RET(R != NULL);
   1603              MPI_VALIDATE_RET(A != NULL);
   1604              MPI_VALIDATE_RET(B != NULL);
   1605          
   1606              if (mbedtls_mpi_cmp_int(B, 0) < 0) {
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x0030             MOVS     R0,R6
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD502             BPL.N    ??mbedtls_mpi_mod_mpi_0
   1607                  return MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   \       0x1A   0xF07F 0x0009      MVNS     R0,#+9
   \       0x1E   0xE027             B.N      ??mbedtls_mpi_mod_mpi_1
   1608              }
   1609          
   1610              MBEDTLS_MPI_CHK(mbedtls_mpi_div_mpi(NULL, R, A, B));
   \                     ??mbedtls_mpi_mod_mpi_0: (+1)
   \       0x20   0x0033             MOVS     R3,R6
   \       0x22   0x002A             MOVS     R2,R5
   \       0x24   0x0021             MOVS     R1,R4
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_div_mpi
   \       0x2C   0x0007             MOVS     R7,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD11D             BNE.N    ??mbedtls_mpi_mod_mpi_2
   1611          
   1612              while (mbedtls_mpi_cmp_int(R, 0) < 0) {
   \                     ??mbedtls_mpi_mod_mpi_3: (+1)
   \                     ??mbedtls_mpi_mod_mpi_4: (+1)
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD508             BPL.N    ??mbedtls_mpi_mod_mpi_5
   1613                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(R, R, B));
   \       0x3E   0x0032             MOVS     R2,R6
   \       0x40   0x0021             MOVS     R1,R4
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x48   0x0007             MOVS     R7,R0
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD10F             BNE.N    ??mbedtls_mpi_mod_mpi_2
   \                     ??mbedtls_mpi_mod_mpi_6: (+1)
   \       0x4E   0xE7F0             B.N      ??mbedtls_mpi_mod_mpi_4
   1614              }
   1615          
   1616              while (mbedtls_mpi_cmp_mpi(R, B) >= 0) {
   \                     ??mbedtls_mpi_mod_mpi_5: (+1)
   \       0x50   0x0031             MOVS     R1,R6
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD408             BMI.N    ??mbedtls_mpi_mod_mpi_2
   1617                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(R, R, B));
   \       0x5C   0x0032             MOVS     R2,R6
   \       0x5E   0x0021             MOVS     R1,R4
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x66   0x0007             MOVS     R7,R0
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD100             BNE.N    ??mbedtls_mpi_mod_mpi_2
   \                     ??mbedtls_mpi_mod_mpi_7: (+1)
   \       0x6C   0xE7F0             B.N      ??mbedtls_mpi_mod_mpi_5
   1618              }
   1619          
   1620          cleanup:
   1621          
   1622              return ret;
   \                     ??mbedtls_mpi_mod_mpi_2: (+1)
   \       0x6E   0x0038             MOVS     R0,R7
   \                     ??mbedtls_mpi_mod_mpi_1: (+1)
   \       0x70   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1623          }
   1624          
   1625          /*
   1626           * Modulo: r = A mod b
   1627           */

   \                                 In section .text, align 2, keep-with-next
   1628          int mbedtls_mpi_mod_int(mbedtls_mpi_uint *r, const mbedtls_mpi *A, mbedtls_mpi_sint b)
   1629          {
   \                     mbedtls_mpi_mod_int: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000B             MOVS     R3,R1
   1630              size_t i;
   1631              mbedtls_mpi_uint x, y, z;
   1632              MPI_VALIDATE_RET(r != NULL);
   1633              MPI_VALIDATE_RET(A != NULL);
   1634          
   1635              if (b == 0) {
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD102             BNE.N    ??mbedtls_mpi_mod_int_0
   1636                  return MBEDTLS_ERR_MPI_DIVISION_BY_ZERO;
   \        0xA   0xF07F 0x000B      MVNS     R0,#+11
   \        0xE   0xE03E             B.N      ??mbedtls_mpi_mod_int_1
   1637              }
   1638          
   1639              if (b < 0) {
   \                     ??mbedtls_mpi_mod_int_0: (+1)
   \       0x10   0x2A00             CMP      R2,#+0
   \       0x12   0xD502             BPL.N    ??mbedtls_mpi_mod_int_2
   1640                  return MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   \       0x14   0xF07F 0x0009      MVNS     R0,#+9
   \       0x18   0xE039             B.N      ??mbedtls_mpi_mod_int_1
   1641              }
   1642          
   1643              /*
   1644               * handle trivial cases
   1645               */
   1646              if (b == 1 || A->n == 0) {
   \                     ??mbedtls_mpi_mod_int_2: (+1)
   \       0x1A   0x2A01             CMP      R2,#+1
   \       0x1C   0xD002             BEQ.N    ??mbedtls_mpi_mod_int_3
   \       0x1E   0x88D8             LDRH     R0,[R3, #+6]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD103             BNE.N    ??mbedtls_mpi_mod_int_4
   1647                  *r = 0;
   \                     ??mbedtls_mpi_mod_int_3: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6028             STR      R0,[R5, #+0]
   1648                  return 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE030             B.N      ??mbedtls_mpi_mod_int_1
   1649              }
   1650          
   1651              if (b == 2) {
   \                     ??mbedtls_mpi_mod_int_4: (+1)
   \       0x2C   0x2A02             CMP      R2,#+2
   \       0x2E   0xD106             BNE.N    ??mbedtls_mpi_mod_int_5
   1652                  *r = A->p[0] & 1;
   \       0x30   0x6818             LDR      R0,[R3, #+0]
   \       0x32   0x7800             LDRB     R0,[R0, #+0]
   \       0x34   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x38   0x6028             STR      R0,[R5, #+0]
   1653                  return 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xE027             B.N      ??mbedtls_mpi_mod_int_1
   1654              }
   1655          
   1656              /*
   1657               * general case
   1658               */
   1659              for (i = A->n, y = 0; i > 0; i--) {
   \                     ??mbedtls_mpi_mod_int_5: (+1)
   \       0x3E   0x88D9             LDRH     R1,[R3, #+6]
   \       0x40   0x2400             MOVS     R4,#+0
   \                     ??mbedtls_mpi_mod_int_6: (+1)
   \       0x42   0x2900             CMP      R1,#+0
   \       0x44   0xD01A             BEQ.N    ??mbedtls_mpi_mod_int_7
   1660                  x  = A->p[i - 1];
   \       0x46   0x6818             LDR      R0,[R3, #+0]
   \       0x48   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \       0x4C   0xF850 0xEC04      LDR      LR,[R0, #-4]
   1661                  y  = (y << biH) | (x >> biH);
   \       0x50   0x4670             MOV      R0,LR
   \       0x52   0x0C00             LSRS     R0,R0,#+16
   \       0x54   0xEA50 0x4004      ORRS     R0,R0,R4, LSL #+16
   1662                  z  = y / b;
   \       0x58   0xFBB0 0xFCF2      UDIV     R12,R0,R2
   1663                  y -= z * b;
   \       0x5C   0xFB02 0x001C      MLS      R0,R2,R12,R0
   1664          
   1665                  x <<= biH;
   \       0x60   0xEA5F 0x4E0E      LSLS     LR,LR,#+16
   \       0x64   0x4676             MOV      R6,LR
   1666                  y  = (y << biH) | (x >> biH);
   \       0x66   0x0034             MOVS     R4,R6
   \       0x68   0x0C24             LSRS     R4,R4,#+16
   \       0x6A   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
   1667                  z  = y / b;
   \       0x6E   0xFBB4 0xF0F2      UDIV     R0,R4,R2
   \       0x72   0x0007             MOVS     R7,R0
   1668                  y -= z * b;
   \       0x74   0xFB02 0x4417      MLS      R4,R2,R7,R4
   1669              }
   \       0x78   0x1E49             SUBS     R1,R1,#+1
   \       0x7A   0xE7E2             B.N      ??mbedtls_mpi_mod_int_6
   1670          
   1671              /*
   1672               * If A is negative, then the current y represents a negative value.
   1673               * Flipping it to the positive side.
   1674               */
   1675              if (A->s < 0 && y != 0) {
   \                     ??mbedtls_mpi_mod_int_7: (+1)
   \       0x7C   0xF9B3 0x0004      LDRSH    R0,[R3, #+4]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD502             BPL.N    ??mbedtls_mpi_mod_int_8
   \       0x84   0x2C00             CMP      R4,#+0
   \       0x86   0xD000             BEQ.N    ??mbedtls_mpi_mod_int_8
   1676                  y = b - y;
   \       0x88   0x1B14             SUBS     R4,R2,R4
   1677              }
   1678          
   1679              *r = y;
   \                     ??mbedtls_mpi_mod_int_8: (+1)
   \       0x8A   0x602C             STR      R4,[R5, #+0]
   1680          
   1681              return 0;
   \       0x8C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_mpi_mod_int_1: (+1)
   \       0x8E   0xBDF0             POP      {R4-R7,PC}
   1682          }
   1683          

   \                                 In section .text, align 2, keep-with-next
   1684          static void mpi_montg_init(mbedtls_mpi_uint *mm, const mbedtls_mpi *N)
   1685          {
   \                     mpi_montg_init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1686              *mm = mbedtls_mpi_core_montmul_init(N->p);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x.... 0x....      BL       mbedtls_mpi_core_montmul_init
   \        0xC   0x6028             STR      R0,[R5, #+0]
   1687          }
   \        0xE   0xBD31             POP      {R0,R4,R5,PC}
   1688          
   1689          /** Montgomery multiplication: A = A * B * R^-1 mod N  (HAC 14.36)
   1690           *
   1691           * \param[in,out]   A   One of the numbers to multiply.
   1692           *                      It must have at least as many limbs as N
   1693           *                      (A->n >= N->n), and any limbs beyond n are ignored.
   1694           *                      On successful completion, A contains the result of
   1695           *                      the multiplication A * B * R^-1 mod N where
   1696           *                      R = (2^ciL)^n.
   1697           * \param[in]       B   One of the numbers to multiply.
   1698           *                      It must be nonzero and must not have more limbs than N
   1699           *                      (B->n <= N->n).
   1700           * \param[in]       N   The modulus. \p N must be odd.
   1701           * \param           mm  The value calculated by `mpi_montg_init(&mm, N)`.
   1702           *                      This is -N^-1 mod 2^ciL.
   1703           * \param[in,out]   T   A bignum for temporary storage.
   1704           *                      It must be at least twice the limb size of N plus 1
   1705           *                      (T->n >= 2 * N->n + 1).
   1706           *                      Its initial content is unused and
   1707           *                      its final content is indeterminate.
   1708           *                      It does not get reallocated.
   1709           */

   \                                 In section .text, align 2, keep-with-next
   1710          static void mpi_montmul(mbedtls_mpi *A, const mbedtls_mpi *B,
   1711                                  const mbedtls_mpi *N, mbedtls_mpi_uint mm,
   1712                                  mbedtls_mpi *T)
   1713          {
   \                     mpi_montmul: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1714              mbedtls_mpi_core_montmul(A->p, A->p, B->p, B->n, N->p, N->n, mm, T->p);
   \       0x10   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x14   0x9003             STR      R0,[SP, #+12]
   \       0x16   0x9702             STR      R7,[SP, #+8]
   \       0x18   0x88F0             LDRH     R0,[R6, #+6]
   \       0x1A   0x9001             STR      R0,[SP, #+4]
   \       0x1C   0x6830             LDR      R0,[R6, #+0]
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   \       0x20   0x88EB             LDRH     R3,[R5, #+6]
   \       0x22   0x682A             LDR      R2,[R5, #+0]
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_core_montmul
   1715          }
   \       0x2C   0xE8BD 0x81FF      POP      {R0-R8,PC}
   1716          
   1717          /*
   1718           * Montgomery reduction: A = A * R^-1 mod N
   1719           *
   1720           * See mpi_montmul() regarding constraints and guarantees on the parameters.
   1721           */

   \                                 In section .text, align 2, keep-with-next
   1722          static void mpi_montred(mbedtls_mpi *A, const mbedtls_mpi *N,
   1723                                  mbedtls_mpi_uint mm, mbedtls_mpi *T)
   1724          {
   \                     mpi_montred: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1725              mbedtls_mpi_uint z = 1;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x9001             STR      R0,[SP, #+4]
   1726              mbedtls_mpi U;
   1727              U.n = 1;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   1728              U.s = 1;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   1729              U.p = &z;
   \       0x1C   0xA801             ADD      R0,SP,#+4
   \       0x1E   0x9002             STR      R0,[SP, #+8]
   1730          
   1731              mpi_montmul(A, &U, N, mm, T);
   \       0x20   0x9600             STR      R6,[SP, #+0]
   \       0x22   0x002B             MOVS     R3,R5
   \       0x24   0x0022             MOVS     R2,R4
   \       0x26   0xA902             ADD      R1,SP,#+8
   \       0x28   0x0038             MOVS     R0,R7
   \       0x2A   0x.... 0x....      BL       mpi_montmul
   1732          }
   \       0x2E   0xB005             ADD      SP,SP,#+20
   \       0x30   0xBDF0             POP      {R4-R7,PC}
   1733          
   1734          /**
   1735           * Select an MPI from a table without leaking the index.
   1736           *
   1737           * This is functionally equivalent to mbedtls_mpi_copy(R, T[idx]) except it
   1738           * reads the entire table in order to avoid leaking the value of idx to an
   1739           * attacker able to observe memory access patterns.
   1740           *
   1741           * \param[out] R        Where to write the selected MPI.
   1742           * \param[in] T         The table to read from.
   1743           * \param[in] T_size    The number of elements in the table.
   1744           * \param[in] idx       The index of the element to select;
   1745           *                      this must satisfy 0 <= idx < T_size.
   1746           *
   1747           * \return \c 0 on success, or a negative error code.
   1748           */

   \                                 In section .text, align 2, keep-with-next
   1749          static int mpi_select(mbedtls_mpi *R, const mbedtls_mpi *T, size_t T_size, size_t idx)
   1750          {
   \                     mpi_select: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1751              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
   1752          
   1753              for (size_t i = 0; i < T_size; i++) {
   \       0x10   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??mpi_select_0: (+1)
   \       0x14   0x45A8             CMP      R8,R5
   \       0x16   0xD210             BCS.N    ??mpi_select_1
   1754                  MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign(R, &T[i],
   1755                                                               (unsigned char) mbedtls_ct_uint_eq(i, idx)));
   \       0x18   0x0031             MOVS     R1,R6
   \       0x1A   0x4640             MOV      R0,R8
   \       0x1C   0x.... 0x....      BL       mbedtls_ct_uint_eq
   \       0x20   0x0002             MOVS     R2,R0
   \       0x22   0xB2D2             UXTB     R2,R2
   \       0x24   0xEB04 0x01C8      ADD      R1,R4,R8, LSL #+3
   \       0x28   0x4648             MOV      R0,R9
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x2E   0x0007             MOVS     R7,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD102             BNE.N    ??mpi_select_1
   1756              }
   \                     ??mpi_select_2: (+1)
   \       0x34   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x38   0xE7EC             B.N      ??mpi_select_0
   1757          cleanup:
   1758              return ret;
   \                     ??mpi_select_1: (+1)
   \       0x3A   0x0038             MOVS     R0,R7
   \       0x3C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1759          }
   1760          
   1761          /*
   1762           * Sliding-window exponentiation: X = A^E mod N  (HAC 14.85)
   1763           */

   \                                 In section .text, align 2, keep-with-next
   1764          int mbedtls_mpi_exp_mod(mbedtls_mpi *X, const mbedtls_mpi *A,
   1765                                  const mbedtls_mpi *E, const mbedtls_mpi *N,
   1766                                  mbedtls_mpi *prec_RR)
   1767          {
   \                     mbedtls_mpi_exp_mod: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB09A             SUB      SP,SP,#+104
   \        0x6   0x001D             MOVS     R5,R3
   1768              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xF07F 0x0B6D      MVNS     R11,#+109
   1769              size_t window_bitsize;
   1770              size_t i, j, nblimbs;
   1771              size_t bufsize, nbits;
   1772              size_t exponent_bits_in_window = 0;
   \        0xC   0x2600             MOVS     R6,#+0
   1773              mbedtls_mpi_uint ei, mm, state;
   1774              mbedtls_mpi RR, T, W[(size_t) 1 << MBEDTLS_MPI_WINDOW_SIZE], WW, Apos;
   1775              int neg;
   1776          
   1777              MPI_VALIDATE_RET(X != NULL);
   1778              MPI_VALIDATE_RET(A != NULL);
   1779              MPI_VALIDATE_RET(E != NULL);
   1780              MPI_VALIDATE_RET(N != NULL);
   1781          
   1782              if (mbedtls_mpi_cmp_int(N, 0) <= 0 || (N->p[0] & 1) == 0) {
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xDB03             BLT.N    ??mbedtls_mpi_exp_mod_0
   \       0x1A   0x6828             LDR      R0,[R5, #+0]
   \       0x1C   0x7800             LDRB     R0,[R0, #+0]
   \       0x1E   0x07C0             LSLS     R0,R0,#+31
   \       0x20   0xD402             BMI.N    ??mbedtls_mpi_exp_mod_1
   1783                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \                     ??mbedtls_mpi_exp_mod_0: (+1)
   \       0x22   0xF07F 0x0003      MVNS     R0,#+3
   \       0x26   0xE273             B.N      ??mbedtls_mpi_exp_mod_2
   1784              }
   1785          
   1786              if (mbedtls_mpi_cmp_int(E, 0) < 0) {
   \                     ??mbedtls_mpi_exp_mod_1: (+1)
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x981C             LDR      R0,[SP, #+112]
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD502             BPL.N    ??mbedtls_mpi_exp_mod_3
   1787                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x34   0xF07F 0x0003      MVNS     R0,#+3
   \       0x38   0xE26A             B.N      ??mbedtls_mpi_exp_mod_2
   1788              }
   1789          
   1790              if (mbedtls_mpi_bitlen(E) > MBEDTLS_MPI_MAX_BITS ||
   1791                  mbedtls_mpi_bitlen(N) > MBEDTLS_MPI_MAX_BITS) {
   \                     ??mbedtls_mpi_exp_mod_3: (+1)
   \       0x3A   0xF240 0x1701      MOVW     R7,#+257
   \       0x3E   0x981C             LDR      R0,[SP, #+112]
   \       0x40   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0x44   0x42B8             CMP      R0,R7
   \       0x46   0xD204             BCS.N    ??mbedtls_mpi_exp_mod_4
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0x4E   0x42B8             CMP      R0,R7
   \       0x50   0xD302             BCC.N    ??mbedtls_mpi_exp_mod_5
   1792                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \                     ??mbedtls_mpi_exp_mod_4: (+1)
   \       0x52   0xF07F 0x0003      MVNS     R0,#+3
   \       0x56   0xE25B             B.N      ??mbedtls_mpi_exp_mod_2
   1793              }
   1794          
   1795              /*
   1796               * Init temps and window size
   1797               */
   1798              mpi_montg_init(&mm, N);
   \                     ??mbedtls_mpi_exp_mod_5: (+1)
   \       0x58   0x0029             MOVS     R1,R5
   \       0x5A   0xA801             ADD      R0,SP,#+4
   \       0x5C   0x.... 0x....      BL       mpi_montg_init
   1799              mbedtls_mpi_init(&RR); mbedtls_mpi_init(&T);
   \       0x60   0xA80B             ADD      R0,SP,#+44
   \       0x62   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x66   0xA804             ADD      R0,SP,#+16
   \       0x68   0x.... 0x....      BL       mbedtls_mpi_init
   1800              mbedtls_mpi_init(&Apos);
   \       0x6C   0xA817             ADD      R0,SP,#+92
   \       0x6E   0x.... 0x....      BL       mbedtls_mpi_init
   1801              mbedtls_mpi_init(&WW);
   \       0x72   0xA808             ADD      R0,SP,#+32
   \       0x74   0x.... 0x....      BL       mbedtls_mpi_init
   1802              memset(W, 0, sizeof(W));
   \       0x78   0xF05F 0x0820      MOVS     R8,#+32
   \       0x7C   0xF05F 0x0900      MOVS     R9,#+0
   \       0x80   0xAF0F             ADD      R7,SP,#+60
   \       0x82   0x464A             MOV      R2,R9
   \       0x84   0x4641             MOV      R1,R8
   \       0x86   0x0038             MOVS     R0,R7
   \       0x88   0x.... 0x....      BL       __aeabi_memset
   1803          
   1804              i = mbedtls_mpi_bitlen(E);
   \       0x8C   0x981C             LDR      R0,[SP, #+112]
   \       0x8E   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0x92   0x0007             MOVS     R7,R0
   1805          
   1806              window_bitsize = (i > 671) ? 6 : (i > 239) ? 5 :
   1807                               (i >  79) ? 4 : (i >  23) ? 3 : 1;
   \       0x94   0xF5B7 0x7F28      CMP      R7,#+672
   \       0x98   0xD301             BCC.N    ??mbedtls_mpi_exp_mod_6
   \       0x9A   0x2006             MOVS     R0,#+6
   \       0x9C   0xE00C             B.N      ??mbedtls_mpi_exp_mod_7
   \                     ??mbedtls_mpi_exp_mod_6: (+1)
   \       0x9E   0x2FF0             CMP      R7,#+240
   \       0xA0   0xD301             BCC.N    ??mbedtls_mpi_exp_mod_8
   \       0xA2   0x2005             MOVS     R0,#+5
   \       0xA4   0xE008             B.N      ??mbedtls_mpi_exp_mod_7
   \                     ??mbedtls_mpi_exp_mod_8: (+1)
   \       0xA6   0x2F50             CMP      R7,#+80
   \       0xA8   0xD301             BCC.N    ??mbedtls_mpi_exp_mod_9
   \       0xAA   0x2004             MOVS     R0,#+4
   \       0xAC   0xE004             B.N      ??mbedtls_mpi_exp_mod_7
   \                     ??mbedtls_mpi_exp_mod_9: (+1)
   \       0xAE   0x2F18             CMP      R7,#+24
   \       0xB0   0xD301             BCC.N    ??mbedtls_mpi_exp_mod_10
   \       0xB2   0x2003             MOVS     R0,#+3
   \       0xB4   0xE000             B.N      ??mbedtls_mpi_exp_mod_7
   \                     ??mbedtls_mpi_exp_mod_10: (+1)
   \       0xB6   0x2001             MOVS     R0,#+1
   \                     ??mbedtls_mpi_exp_mod_7: (+1)
   \       0xB8   0x9003             STR      R0,[SP, #+12]
   1808          
   1809          #if (MBEDTLS_MPI_WINDOW_SIZE < 6)
   1810              if (window_bitsize > MBEDTLS_MPI_WINDOW_SIZE) {
   \       0xBA   0x9803             LDR      R0,[SP, #+12]
   \       0xBC   0x2803             CMP      R0,#+3
   \       0xBE   0xD301             BCC.N    ??mbedtls_mpi_exp_mod_11
   1811                  window_bitsize = MBEDTLS_MPI_WINDOW_SIZE;
   \       0xC0   0x2002             MOVS     R0,#+2
   \       0xC2   0x9003             STR      R0,[SP, #+12]
   1812              }
   1813          #endif
   1814          
   1815              const size_t w_table_used_size = (size_t) 1 << window_bitsize;
   \                     ??mbedtls_mpi_exp_mod_11: (+1)
   \       0xC4   0xF05F 0x0A01      MOVS     R10,#+1
   \       0xC8   0x9803             LDR      R0,[SP, #+12]
   \       0xCA   0xFA1A 0xFA00      LSLS     R10,R10,R0
   1816          
   1817              /*
   1818               * This function is not constant-trace: its memory accesses depend on the
   1819               * exponent value. To defend against timing attacks, callers (such as RSA
   1820               * and DHM) should use exponent blinding. However this is not enough if the
   1821               * adversary can find the exponent in a single trace, so this function
   1822               * takes extra precautions against adversaries who can observe memory
   1823               * access patterns.
   1824               *
   1825               * This function performs a series of multiplications by table elements and
   1826               * squarings, and we want the prevent the adversary from finding out which
   1827               * table element was used, and from distinguishing between multiplications
   1828               * and squarings. Firstly, when multiplying by an element of the window
   1829               * W[i], we do a constant-trace table lookup to obfuscate i. This leaves
   1830               * squarings as having a different memory access patterns from other
   1831               * multiplications. So secondly, we put the accumulator in the table as
   1832               * well, and also do a constant-trace table lookup to multiply by the
   1833               * accumulator which is W[x_index].
   1834               *
   1835               * This way, all multiplications take the form of a lookup-and-multiply.
   1836               * The number of lookup-and-multiply operations inside each iteration of
   1837               * the main loop still depends on the bits of the exponent, but since the
   1838               * other operations in the loop don't have an easily recognizable memory
   1839               * trace, an adversary is unlikely to be able to observe the exact
   1840               * patterns.
   1841               *
   1842               * An adversary may still be able to recover the exponent if they can
   1843               * observe both memory accesses and branches. However, branch prediction
   1844               * exploitation typically requires many traces of execution over the same
   1845               * data, which is defeated by randomized blinding.
   1846               */
   1847              const size_t x_index = 0;
   \       0xCE   0xF05F 0x0800      MOVS     R8,#+0
   1848              mbedtls_mpi_init(&W[x_index]);
   \       0xD2   0xA80F             ADD      R0,SP,#+60
   \       0xD4   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \       0xD8   0x.... 0x....      BL       mbedtls_mpi_init
   1849          
   1850              j = N->n + 1;
   \       0xDC   0x88E8             LDRH     R0,[R5, #+6]
   \       0xDE   0x1C40             ADDS     R0,R0,#+1
   \       0xE0   0x9002             STR      R0,[SP, #+8]
   1851              /* All W[i] including the accumulator must have at least N->n limbs for
   1852               * the mpi_montmul() and mpi_montred() calls later. Here we ensure that
   1853               * W[1] and the accumulator W[x_index] are large enough. later we'll grow
   1854               * other W[i] to the same length. They must not be shrunk midway through
   1855               * this function!
   1856               */
   1857              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[x_index], j));
   \       0xE2   0x9902             LDR      R1,[SP, #+8]
   \       0xE4   0xA80F             ADD      R0,SP,#+60
   \       0xE6   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \       0xEA   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0xEE   0x4681             MOV      R9,R0
   \       0xF0   0x2800             CMP      R0,#+0
   \       0xF2   0xF040 0x81E4      BNE.W    ??mbedtls_mpi_exp_mod_12
   1858              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[1],  j));
   \                     ??mbedtls_mpi_exp_mod_13: (+1)
   \       0xF6   0x9902             LDR      R1,[SP, #+8]
   \       0xF8   0xA811             ADD      R0,SP,#+68
   \       0xFA   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0xFE   0x4681             MOV      R9,R0
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xF040 0x81DC      BNE.W    ??mbedtls_mpi_exp_mod_12
   1859              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&T, j * 2));
   \                     ??mbedtls_mpi_exp_mod_14: (+1)
   \      0x106   0x9802             LDR      R0,[SP, #+8]
   \      0x108   0x0041             LSLS     R1,R0,#+1
   \      0x10A   0xA804             ADD      R0,SP,#+16
   \      0x10C   0x.... 0x....      BL       mbedtls_mpi_grow
   \      0x110   0x4681             MOV      R9,R0
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xF040 0x81D3      BNE.W    ??mbedtls_mpi_exp_mod_12
   1860          
   1861              /*
   1862               * Compensate for negative A (and correct at the end)
   1863               */
   1864              neg = (A->s == -1);
   \                     ??mbedtls_mpi_exp_mod_15: (+1)
   \      0x118   0x981B             LDR      R0,[SP, #+108]
   \      0x11A   0xF9B0 0x0004      LDRSH    R0,[R0, #+4]
   \      0x11E   0xF110 0x0F01      CMN      R0,#+1
   \      0x122   0xD102             BNE.N    ??mbedtls_mpi_exp_mod_16
   \      0x124   0x2001             MOVS     R0,#+1
   \      0x126   0x900D             STR      R0,[SP, #+52]
   \      0x128   0xE001             B.N      ??mbedtls_mpi_exp_mod_17
   \                     ??mbedtls_mpi_exp_mod_16: (+1)
   \      0x12A   0x2000             MOVS     R0,#+0
   \      0x12C   0x900D             STR      R0,[SP, #+52]
   1865              if (neg) {
   \                     ??mbedtls_mpi_exp_mod_17: (+1)
   \      0x12E   0x980D             LDR      R0,[SP, #+52]
   \      0x130   0x2800             CMP      R0,#+0
   \      0x132   0xD00C             BEQ.N    ??mbedtls_mpi_exp_mod_18
   1866                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Apos, A));
   \      0x134   0x991B             LDR      R1,[SP, #+108]
   \      0x136   0xA817             ADD      R0,SP,#+92
   \      0x138   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x13C   0x4681             MOV      R9,R0
   \      0x13E   0x2800             CMP      R0,#+0
   \      0x140   0xF040 0x81BD      BNE.W    ??mbedtls_mpi_exp_mod_12
   1867                  Apos.s = 1;
   \                     ??mbedtls_mpi_exp_mod_19: (+1)
   \      0x144   0x2001             MOVS     R0,#+1
   \      0x146   0xF8AD 0x0060      STRH     R0,[SP, #+96]
   1868                  A = &Apos;
   \      0x14A   0xA817             ADD      R0,SP,#+92
   \      0x14C   0x901B             STR      R0,[SP, #+108]
   1869              }
   1870          
   1871              /*
   1872               * If 1st call, pre-compute R^2 mod N
   1873               */
   1874              if (prec_RR == NULL || prec_RR->p == NULL) {
   \                     ??mbedtls_mpi_exp_mod_18: (+1)
   \      0x14E   0x9826             LDR      R0,[SP, #+152]
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD003             BEQ.N    ??mbedtls_mpi_exp_mod_20
   \      0x154   0x9826             LDR      R0,[SP, #+152]
   \      0x156   0x6800             LDR      R0,[R0, #+0]
   \      0x158   0x2800             CMP      R0,#+0
   \      0x15A   0xD129             BNE.N    ??mbedtls_mpi_exp_mod_21
   1875                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&RR, 1));
   \                     ??mbedtls_mpi_exp_mod_20: (+1)
   \      0x15C   0x2101             MOVS     R1,#+1
   \      0x15E   0xA80B             ADD      R0,SP,#+44
   \      0x160   0x.... 0x....      BL       mbedtls_mpi_lset
   \      0x164   0x4681             MOV      R9,R0
   \      0x166   0x2800             CMP      R0,#+0
   \      0x168   0xF040 0x81A9      BNE.W    ??mbedtls_mpi_exp_mod_12
   1876                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&RR, N->n * 2 * biL));
   \                     ??mbedtls_mpi_exp_mod_22: (+1)
   \      0x16C   0x88E9             LDRH     R1,[R5, #+6]
   \      0x16E   0x2040             MOVS     R0,#+64
   \      0x170   0x4341             MULS     R1,R0,R1
   \      0x172   0xA80B             ADD      R0,SP,#+44
   \      0x174   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x178   0x4681             MOV      R9,R0
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xF040 0x819F      BNE.W    ??mbedtls_mpi_exp_mod_12
   1877                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&RR, &RR, N));
   \                     ??mbedtls_mpi_exp_mod_23: (+1)
   \      0x180   0x002A             MOVS     R2,R5
   \      0x182   0xA90B             ADD      R1,SP,#+44
   \      0x184   0xA80B             ADD      R0,SP,#+44
   \      0x186   0x.... 0x....      BL       mbedtls_mpi_mod_mpi
   \      0x18A   0x4681             MOV      R9,R0
   \      0x18C   0x2800             CMP      R0,#+0
   \      0x18E   0xF040 0x8196      BNE.W    ??mbedtls_mpi_exp_mod_12
   1878          
   1879                  if (prec_RR != NULL) {
   \                     ??mbedtls_mpi_exp_mod_24: (+1)
   \      0x192   0x9826             LDR      R0,[SP, #+152]
   \      0x194   0x2800             CMP      R0,#+0
   \      0x196   0xD016             BEQ.N    ??mbedtls_mpi_exp_mod_25
   1880                      memcpy(prec_RR, &RR, sizeof(mbedtls_mpi));
   \      0x198   0x2008             MOVS     R0,#+8
   \      0x19A   0x9019             STR      R0,[SP, #+100]
   \      0x19C   0xA80B             ADD      R0,SP,#+44
   \      0x19E   0x9000             STR      R0,[SP, #+0]
   \      0x1A0   0xF8DD 0xB098      LDR      R11,[SP, #+152]
   \      0x1A4   0x9A19             LDR      R2,[SP, #+100]
   \      0x1A6   0x9900             LDR      R1,[SP, #+0]
   \      0x1A8   0x4658             MOV      R0,R11
   \      0x1AA   0x.... 0x....      BL       __aeabi_memcpy
   1881                  }
   1882              } else {
   \      0x1AE   0xE00A             B.N      ??mbedtls_mpi_exp_mod_25
   1883                  memcpy(&RR, prec_RR, sizeof(mbedtls_mpi));
   \                     ??mbedtls_mpi_exp_mod_21: (+1)
   \      0x1B0   0x2008             MOVS     R0,#+8
   \      0x1B2   0x9019             STR      R0,[SP, #+100]
   \      0x1B4   0x9826             LDR      R0,[SP, #+152]
   \      0x1B6   0x9000             STR      R0,[SP, #+0]
   \      0x1B8   0xF10D 0x0B2C      ADD      R11,SP,#+44
   \      0x1BC   0x9A19             LDR      R2,[SP, #+100]
   \      0x1BE   0x9900             LDR      R1,[SP, #+0]
   \      0x1C0   0x4658             MOV      R0,R11
   \      0x1C2   0x.... 0x....      BL       __aeabi_memcpy
   1884              }
   1885          
   1886              /*
   1887               * W[1] = A * R^2 * R^-1 mod N = A * R mod N
   1888               */
   1889              if (mbedtls_mpi_cmp_mpi(A, N) >= 0) {
   \                     ??mbedtls_mpi_exp_mod_25: (+1)
   \      0x1C6   0x0029             MOVS     R1,R5
   \      0x1C8   0x981B             LDR      R0,[SP, #+108]
   \      0x1CA   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x1CE   0x2800             CMP      R0,#+0
   \      0x1D0   0xD412             BMI.N    ??mbedtls_mpi_exp_mod_26
   1890                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&W[1], A, N));
   \      0x1D2   0x002A             MOVS     R2,R5
   \      0x1D4   0x991B             LDR      R1,[SP, #+108]
   \      0x1D6   0xA811             ADD      R0,SP,#+68
   \      0x1D8   0x.... 0x....      BL       mbedtls_mpi_mod_mpi
   \      0x1DC   0x4681             MOV      R9,R0
   \      0x1DE   0x2800             CMP      R0,#+0
   \      0x1E0   0xF040 0x816D      BNE.W    ??mbedtls_mpi_exp_mod_12
   1891                  /* This should be a no-op because W[1] is already that large before
   1892                   * mbedtls_mpi_mod_mpi(), but it's necessary to avoid an overflow
   1893                   * in mpi_montmul() below, so let's make sure. */
   1894                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[1], N->n + 1));
   \                     ??mbedtls_mpi_exp_mod_27: (+1)
   \      0x1E4   0x88E9             LDRH     R1,[R5, #+6]
   \      0x1E6   0x1C49             ADDS     R1,R1,#+1
   \      0x1E8   0xA811             ADD      R0,SP,#+68
   \      0x1EA   0x.... 0x....      BL       mbedtls_mpi_grow
   \      0x1EE   0x4681             MOV      R9,R0
   \      0x1F0   0x2800             CMP      R0,#+0
   \      0x1F2   0xF040 0x8164      BNE.W    ??mbedtls_mpi_exp_mod_12
   \                     ??mbedtls_mpi_exp_mod_28: (+1)
   \      0x1F6   0xE007             B.N      ??mbedtls_mpi_exp_mod_29
   1895              } else {
   1896                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[1], A));
   \                     ??mbedtls_mpi_exp_mod_26: (+1)
   \      0x1F8   0x991B             LDR      R1,[SP, #+108]
   \      0x1FA   0xA811             ADD      R0,SP,#+68
   \      0x1FC   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x200   0x4681             MOV      R9,R0
   \      0x202   0x2800             CMP      R0,#+0
   \      0x204   0xF040 0x815B      BNE.W    ??mbedtls_mpi_exp_mod_12
   1897              }
   1898          
   1899              /* Note that this is safe because W[1] always has at least N->n limbs
   1900               * (it grew above and was preserved by mbedtls_mpi_copy()). */
   1901              mpi_montmul(&W[1], &RR, N, mm, &T);
   \                     ??mbedtls_mpi_exp_mod_30: (+1)
   \                     ??mbedtls_mpi_exp_mod_29: (+1)
   \      0x208   0xA804             ADD      R0,SP,#+16
   \      0x20A   0x9000             STR      R0,[SP, #+0]
   \      0x20C   0x9B01             LDR      R3,[SP, #+4]
   \      0x20E   0x002A             MOVS     R2,R5
   \      0x210   0xA90B             ADD      R1,SP,#+44
   \      0x212   0xA811             ADD      R0,SP,#+68
   \      0x214   0x.... 0x....      BL       mpi_montmul
   1902          
   1903              /*
   1904               * W[x_index] = R^2 * R^-1 mod N = R mod N
   1905               */
   1906              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[x_index], &RR));
   \      0x218   0xA90B             ADD      R1,SP,#+44
   \      0x21A   0xA80F             ADD      R0,SP,#+60
   \      0x21C   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x220   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x224   0x4681             MOV      R9,R0
   \      0x226   0x2800             CMP      R0,#+0
   \      0x228   0xF040 0x8149      BNE.W    ??mbedtls_mpi_exp_mod_12
   1907              mpi_montred(&W[x_index], N, mm, &T);
   \                     ??mbedtls_mpi_exp_mod_31: (+1)
   \      0x22C   0xAB04             ADD      R3,SP,#+16
   \      0x22E   0x9A01             LDR      R2,[SP, #+4]
   \      0x230   0x0029             MOVS     R1,R5
   \      0x232   0xA80F             ADD      R0,SP,#+60
   \      0x234   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x238   0x.... 0x....      BL       mpi_montred
   1908          
   1909          
   1910              if (window_bitsize > 1) {
   \      0x23C   0x9803             LDR      R0,[SP, #+12]
   \      0x23E   0x2802             CMP      R0,#+2
   \      0x240   0xD359             BCC.N    ??mbedtls_mpi_exp_mod_32
   1911                  /*
   1912                   * W[i] = W[1] ^ i
   1913                   *
   1914                   * The first bit of the sliding window is always 1 and therefore we
   1915                   * only need to store the second half of the table.
   1916                   *
   1917                   * (There are two special elements in the table: W[0] for the
   1918                   * accumulator/result and W[1] for A in Montgomery form. Both of these
   1919                   * are already set at this point.)
   1920                   */
   1921                  j = w_table_used_size / 2;
   \      0x242   0x4650             MOV      R0,R10
   \      0x244   0x0840             LSRS     R0,R0,#+1
   \      0x246   0x9002             STR      R0,[SP, #+8]
   1922          
   1923                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[j], N->n + 1));
   \      0x248   0x88E9             LDRH     R1,[R5, #+6]
   \      0x24A   0x1C49             ADDS     R1,R1,#+1
   \      0x24C   0xAA0F             ADD      R2,SP,#+60
   \      0x24E   0x9802             LDR      R0,[SP, #+8]
   \      0x250   0xEB02 0x00C0      ADD      R0,R2,R0, LSL #+3
   \      0x254   0x.... 0x....      BL       mbedtls_mpi_grow
   \      0x258   0x4681             MOV      R9,R0
   \      0x25A   0x2800             CMP      R0,#+0
   \      0x25C   0xF040 0x812F      BNE.W    ??mbedtls_mpi_exp_mod_12
   1924                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[j], &W[1]));
   \                     ??mbedtls_mpi_exp_mod_33: (+1)
   \      0x260   0xA911             ADD      R1,SP,#+68
   \      0x262   0xA80F             ADD      R0,SP,#+60
   \      0x264   0x9A02             LDR      R2,[SP, #+8]
   \      0x266   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \      0x26A   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x26E   0x4681             MOV      R9,R0
   \      0x270   0x2800             CMP      R0,#+0
   \      0x272   0xF040 0x8124      BNE.W    ??mbedtls_mpi_exp_mod_12
   1925          
   1926                  for (i = 0; i < window_bitsize - 1; i++) {
   \                     ??mbedtls_mpi_exp_mod_34: (+1)
   \      0x276   0xF05F 0x0B00      MOVS     R11,#+0
   \                     ??mbedtls_mpi_exp_mod_35: (+1)
   \      0x27A   0x9803             LDR      R0,[SP, #+12]
   \      0x27C   0x1E40             SUBS     R0,R0,#+1
   \      0x27E   0x4583             CMP      R11,R0
   \      0x280   0xD210             BCS.N    ??mbedtls_mpi_exp_mod_36
   1927                      mpi_montmul(&W[j], &W[j], N, mm, &T);
   \      0x282   0xA804             ADD      R0,SP,#+16
   \      0x284   0x9000             STR      R0,[SP, #+0]
   \      0x286   0x9B01             LDR      R3,[SP, #+4]
   \      0x288   0x002A             MOVS     R2,R5
   \      0x28A   0xA90F             ADD      R1,SP,#+60
   \      0x28C   0x9802             LDR      R0,[SP, #+8]
   \      0x28E   0xEB01 0x01C0      ADD      R1,R1,R0, LSL #+3
   \      0x292   0xA80F             ADD      R0,SP,#+60
   \      0x294   0x9F02             LDR      R7,[SP, #+8]
   \      0x296   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \      0x29A   0x.... 0x....      BL       mpi_montmul
   1928                  }
   \      0x29E   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \      0x2A2   0xE7EA             B.N      ??mbedtls_mpi_exp_mod_35
   1929          
   1930                  /*
   1931                   * W[i] = W[i - 1] * W[1]
   1932                   */
   1933                  for (i = j + 1; i < w_table_used_size; i++) {
   \                     ??mbedtls_mpi_exp_mod_36: (+1)
   \      0x2A4   0x9F02             LDR      R7,[SP, #+8]
   \      0x2A6   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mbedtls_mpi_exp_mod_37: (+1)
   \      0x2A8   0x4557             CMP      R7,R10
   \      0x2AA   0xD224             BCS.N    ??mbedtls_mpi_exp_mod_32
   1934                      MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[i], N->n + 1));
   \      0x2AC   0x88E9             LDRH     R1,[R5, #+6]
   \      0x2AE   0x1C49             ADDS     R1,R1,#+1
   \      0x2B0   0xA80F             ADD      R0,SP,#+60
   \      0x2B2   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \      0x2B6   0x.... 0x....      BL       mbedtls_mpi_grow
   \      0x2BA   0x4681             MOV      R9,R0
   \      0x2BC   0x2800             CMP      R0,#+0
   \      0x2BE   0xF040 0x80FE      BNE.W    ??mbedtls_mpi_exp_mod_12
   1935                      MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[i], &W[i - 1]));
   \                     ??mbedtls_mpi_exp_mod_38: (+1)
   \      0x2C2   0xA80F             ADD      R0,SP,#+60
   \      0x2C4   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \      0x2C8   0xF1B0 0x0108      SUBS     R1,R0,#+8
   \      0x2CC   0xA80F             ADD      R0,SP,#+60
   \      0x2CE   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \      0x2D2   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x2D6   0x4681             MOV      R9,R0
   \      0x2D8   0x2800             CMP      R0,#+0
   \      0x2DA   0xF040 0x80F0      BNE.W    ??mbedtls_mpi_exp_mod_12
   1936          
   1937                      mpi_montmul(&W[i], &W[1], N, mm, &T);
   \                     ??mbedtls_mpi_exp_mod_39: (+1)
   \      0x2DE   0xA804             ADD      R0,SP,#+16
   \      0x2E0   0x9000             STR      R0,[SP, #+0]
   \      0x2E2   0x9B01             LDR      R3,[SP, #+4]
   \      0x2E4   0x002A             MOVS     R2,R5
   \      0x2E6   0xA911             ADD      R1,SP,#+68
   \      0x2E8   0xA80F             ADD      R0,SP,#+60
   \      0x2EA   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \      0x2EE   0x.... 0x....      BL       mpi_montmul
   1938                  }
   \      0x2F2   0x1C7F             ADDS     R7,R7,#+1
   \      0x2F4   0xE7D8             B.N      ??mbedtls_mpi_exp_mod_37
   1939              }
   1940          
   1941              nblimbs = E->n;
   \                     ??mbedtls_mpi_exp_mod_32: (+1)
   \      0x2F6   0x981C             LDR      R0,[SP, #+112]
   \      0x2F8   0x88C0             LDRH     R0,[R0, #+6]
   \      0x2FA   0x900A             STR      R0,[SP, #+40]
   1942              bufsize = 0;
   \      0x2FC   0x2000             MOVS     R0,#+0
   \      0x2FE   0x9007             STR      R0,[SP, #+28]
   1943              nbits   = 0;
   \      0x300   0x2000             MOVS     R0,#+0
   \      0x302   0x0004             MOVS     R4,R0
   1944              state   = 0;
   \      0x304   0x2000             MOVS     R0,#+0
   \      0x306   0x9006             STR      R0,[SP, #+24]
   1945          
   1946              while (1) {
   1947                  if (bufsize == 0) {
   \                     ??mbedtls_mpi_exp_mod_40: (+1)
   \      0x308   0x9807             LDR      R0,[SP, #+28]
   \      0x30A   0x2800             CMP      R0,#+0
   \      0x30C   0xD10A             BNE.N    ??mbedtls_mpi_exp_mod_41
   1948                      if (nblimbs == 0) {
   \      0x30E   0x980A             LDR      R0,[SP, #+40]
   \      0x310   0x2800             CMP      R0,#+0
   \      0x312   0xD102             BNE.N    ??mbedtls_mpi_exp_mod_42
   1949                          break;
   1950                      }
   1951          
   1952                      nblimbs--;
   1953          
   1954                      bufsize = sizeof(mbedtls_mpi_uint) << 3;
   1955                  }
   1956          
   1957                  bufsize--;
   1958          
   1959                  ei = (E->p[nblimbs] >> bufsize) & 1;
   1960          
   1961                  /*
   1962                   * skip leading 0s
   1963                   */
   1964                  if (ei == 0 && state == 0) {
   1965                      continue;
   1966                  }
   1967          
   1968                  if (ei == 0 && state == 1) {
   1969                      /*
   1970                       * out of window, square W[x_index]
   1971                       */
   1972                      MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, x_index));
   1973                      mpi_montmul(&W[x_index], &WW, N, mm, &T);
   1974                      continue;
   1975                  }
   1976          
   1977                  /*
   1978                   * add ei to current window
   1979                   */
   1980                  state = 2;
   1981          
   1982                  nbits++;
   1983                  exponent_bits_in_window |= (ei << (window_bitsize - nbits));
   1984          
   1985                  if (nbits == window_bitsize) {
   1986                      /*
   1987                       * W[x_index] = W[x_index]^window_bitsize R^-1 mod N
   1988                       */
   1989                      for (i = 0; i < window_bitsize; i++) {
   1990                          MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size,
   1991                                                     x_index));
   1992                          mpi_montmul(&W[x_index], &WW, N, mm, &T);
   1993                      }
   1994          
   1995                      /*
   1996                       * W[x_index] = W[x_index] * W[exponent_bits_in_window] R^-1 mod N
   1997                       */
   1998                      MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size,
   1999                                                 exponent_bits_in_window));
   2000                      mpi_montmul(&W[x_index], &WW, N, mm, &T);
   2001          
   2002                      state--;
   2003                      nbits = 0;
   2004                      exponent_bits_in_window = 0;
   2005                  }
   2006              }
   2007          
   2008              /*
   2009               * process the remaining bits
   2010               */
   2011              for (i = 0; i < nbits; i++) {
   \      0x314   0x2000             MOVS     R0,#+0
   \      0x316   0x0007             MOVS     R7,R0
   \      0x318   0xE072             B.N      ??mbedtls_mpi_exp_mod_43
   \                     ??mbedtls_mpi_exp_mod_42: (+1)
   \      0x31A   0x980A             LDR      R0,[SP, #+40]
   \      0x31C   0x1E40             SUBS     R0,R0,#+1
   \      0x31E   0x900A             STR      R0,[SP, #+40]
   \      0x320   0x2020             MOVS     R0,#+32
   \      0x322   0x9007             STR      R0,[SP, #+28]
   \                     ??mbedtls_mpi_exp_mod_41: (+1)
   \      0x324   0x9807             LDR      R0,[SP, #+28]
   \      0x326   0x1E40             SUBS     R0,R0,#+1
   \      0x328   0x9007             STR      R0,[SP, #+28]
   \      0x32A   0x981C             LDR      R0,[SP, #+112]
   \      0x32C   0x6801             LDR      R1,[R0, #+0]
   \      0x32E   0x980A             LDR      R0,[SP, #+40]
   \      0x330   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \      0x334   0x9907             LDR      R1,[SP, #+28]
   \      0x336   0x40C8             LSRS     R0,R0,R1
   \      0x338   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x33C   0x900E             STR      R0,[SP, #+56]
   \      0x33E   0x980E             LDR      R0,[SP, #+56]
   \      0x340   0x9906             LDR      R1,[SP, #+24]
   \      0x342   0x4308             ORRS     R0,R1,R0
   \      0x344   0x2800             CMP      R0,#+0
   \      0x346   0xD0DF             BEQ.N    ??mbedtls_mpi_exp_mod_40
   \                     ??mbedtls_mpi_exp_mod_44: (+1)
   \      0x348   0x980E             LDR      R0,[SP, #+56]
   \      0x34A   0x2800             CMP      R0,#+0
   \      0x34C   0xD117             BNE.N    ??mbedtls_mpi_exp_mod_45
   \      0x34E   0x9806             LDR      R0,[SP, #+24]
   \      0x350   0x2801             CMP      R0,#+1
   \      0x352   0xD114             BNE.N    ??mbedtls_mpi_exp_mod_45
   \      0x354   0x4643             MOV      R3,R8
   \      0x356   0x4652             MOV      R2,R10
   \      0x358   0xA90F             ADD      R1,SP,#+60
   \      0x35A   0xA808             ADD      R0,SP,#+32
   \      0x35C   0x.... 0x....      BL       mpi_select
   \      0x360   0x4681             MOV      R9,R0
   \      0x362   0x2800             CMP      R0,#+0
   \      0x364   0xF040 0x80AB      BNE.W    ??mbedtls_mpi_exp_mod_12
   \                     ??mbedtls_mpi_exp_mod_46: (+1)
   \      0x368   0xA804             ADD      R0,SP,#+16
   \      0x36A   0x9000             STR      R0,[SP, #+0]
   \      0x36C   0x9B01             LDR      R3,[SP, #+4]
   \      0x36E   0x002A             MOVS     R2,R5
   \      0x370   0xA908             ADD      R1,SP,#+32
   \      0x372   0xA80F             ADD      R0,SP,#+60
   \      0x374   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x378   0x.... 0x....      BL       mpi_montmul
   \      0x37C   0xE7C4             B.N      ??mbedtls_mpi_exp_mod_40
   \                     ??mbedtls_mpi_exp_mod_45: (+1)
   \      0x37E   0x2002             MOVS     R0,#+2
   \      0x380   0x9006             STR      R0,[SP, #+24]
   \      0x382   0x1C64             ADDS     R4,R4,#+1
   \      0x384   0x980E             LDR      R0,[SP, #+56]
   \      0x386   0x9903             LDR      R1,[SP, #+12]
   \      0x388   0x1B09             SUBS     R1,R1,R4
   \      0x38A   0x4088             LSLS     R0,R0,R1
   \      0x38C   0x4306             ORRS     R6,R0,R6
   \      0x38E   0x9803             LDR      R0,[SP, #+12]
   \      0x390   0x4284             CMP      R4,R0
   \      0x392   0xD1B9             BNE.N    ??mbedtls_mpi_exp_mod_40
   \      0x394   0x2000             MOVS     R0,#+0
   \      0x396   0x0007             MOVS     R7,R0
   \                     ??mbedtls_mpi_exp_mod_47: (+1)
   \      0x398   0x9803             LDR      R0,[SP, #+12]
   \      0x39A   0x4287             CMP      R7,R0
   \      0x39C   0xD215             BCS.N    ??mbedtls_mpi_exp_mod_48
   \      0x39E   0x4643             MOV      R3,R8
   \      0x3A0   0x4652             MOV      R2,R10
   \      0x3A2   0xA90F             ADD      R1,SP,#+60
   \      0x3A4   0xA808             ADD      R0,SP,#+32
   \      0x3A6   0x.... 0x....      BL       mpi_select
   \      0x3AA   0x4681             MOV      R9,R0
   \      0x3AC   0x2800             CMP      R0,#+0
   \      0x3AE   0xF040 0x8086      BNE.W    ??mbedtls_mpi_exp_mod_12
   \                     ??mbedtls_mpi_exp_mod_49: (+1)
   \      0x3B2   0xA804             ADD      R0,SP,#+16
   \      0x3B4   0x9000             STR      R0,[SP, #+0]
   \      0x3B6   0x9B01             LDR      R3,[SP, #+4]
   \      0x3B8   0x002A             MOVS     R2,R5
   \      0x3BA   0xA908             ADD      R1,SP,#+32
   \      0x3BC   0xA80F             ADD      R0,SP,#+60
   \      0x3BE   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x3C2   0x.... 0x....      BL       mpi_montmul
   \      0x3C6   0x1C7F             ADDS     R7,R7,#+1
   \      0x3C8   0xE7E6             B.N      ??mbedtls_mpi_exp_mod_47
   \                     ??mbedtls_mpi_exp_mod_48: (+1)
   \      0x3CA   0x0033             MOVS     R3,R6
   \      0x3CC   0x4652             MOV      R2,R10
   \      0x3CE   0xA90F             ADD      R1,SP,#+60
   \      0x3D0   0xA808             ADD      R0,SP,#+32
   \      0x3D2   0x.... 0x....      BL       mpi_select
   \      0x3D6   0x4681             MOV      R9,R0
   \      0x3D8   0x2800             CMP      R0,#+0
   \      0x3DA   0xD170             BNE.N    ??mbedtls_mpi_exp_mod_12
   \                     ??mbedtls_mpi_exp_mod_50: (+1)
   \      0x3DC   0xA804             ADD      R0,SP,#+16
   \      0x3DE   0x9000             STR      R0,[SP, #+0]
   \      0x3E0   0x9B01             LDR      R3,[SP, #+4]
   \      0x3E2   0x002A             MOVS     R2,R5
   \      0x3E4   0xA908             ADD      R1,SP,#+32
   \      0x3E6   0xA80F             ADD      R0,SP,#+60
   \      0x3E8   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x3EC   0x.... 0x....      BL       mpi_montmul
   \      0x3F0   0x9806             LDR      R0,[SP, #+24]
   \      0x3F2   0x1E40             SUBS     R0,R0,#+1
   \      0x3F4   0x9006             STR      R0,[SP, #+24]
   \      0x3F6   0x2000             MOVS     R0,#+0
   \      0x3F8   0x0004             MOVS     R4,R0
   \      0x3FA   0x2000             MOVS     R0,#+0
   \      0x3FC   0x0006             MOVS     R6,R0
   \      0x3FE   0xE783             B.N      ??mbedtls_mpi_exp_mod_40
   \                     ??mbedtls_mpi_exp_mod_43: (+1)
   \      0x400   0x42A7             CMP      R7,R4
   \      0x402   0xD22D             BCS.N    ??mbedtls_mpi_exp_mod_51
   2012                  MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, x_index));
   \      0x404   0x4643             MOV      R3,R8
   \      0x406   0x4652             MOV      R2,R10
   \      0x408   0xA90F             ADD      R1,SP,#+60
   \      0x40A   0xA808             ADD      R0,SP,#+32
   \      0x40C   0x.... 0x....      BL       mpi_select
   \      0x410   0x4681             MOV      R9,R0
   \      0x412   0x2800             CMP      R0,#+0
   \      0x414   0xD153             BNE.N    ??mbedtls_mpi_exp_mod_12
   2013                  mpi_montmul(&W[x_index], &WW, N, mm, &T);
   \                     ??mbedtls_mpi_exp_mod_52: (+1)
   \      0x416   0xA804             ADD      R0,SP,#+16
   \      0x418   0x9000             STR      R0,[SP, #+0]
   \      0x41A   0x9B01             LDR      R3,[SP, #+4]
   \      0x41C   0x002A             MOVS     R2,R5
   \      0x41E   0xA908             ADD      R1,SP,#+32
   \      0x420   0xA80F             ADD      R0,SP,#+60
   \      0x422   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x426   0x.... 0x....      BL       mpi_montmul
   2014          
   2015                  exponent_bits_in_window <<= 1;
   \      0x42A   0x0076             LSLS     R6,R6,#+1
   2016          
   2017                  if ((exponent_bits_in_window & ((size_t) 1 << window_bitsize)) != 0) {
   \      0x42C   0x9903             LDR      R1,[SP, #+12]
   \      0x42E   0x0030             MOVS     R0,R6
   \      0x430   0x40C8             LSRS     R0,R0,R1
   \      0x432   0x07C0             LSLS     R0,R0,#+31
   \      0x434   0xD512             BPL.N    ??mbedtls_mpi_exp_mod_53
   2018                      MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, 1));
   \      0x436   0x2301             MOVS     R3,#+1
   \      0x438   0x4652             MOV      R2,R10
   \      0x43A   0xA90F             ADD      R1,SP,#+60
   \      0x43C   0xA808             ADD      R0,SP,#+32
   \      0x43E   0x.... 0x....      BL       mpi_select
   \      0x442   0x4681             MOV      R9,R0
   \      0x444   0x2800             CMP      R0,#+0
   \      0x446   0xD13A             BNE.N    ??mbedtls_mpi_exp_mod_12
   2019                      mpi_montmul(&W[x_index], &WW, N, mm, &T);
   \                     ??mbedtls_mpi_exp_mod_54: (+1)
   \      0x448   0xA804             ADD      R0,SP,#+16
   \      0x44A   0x9000             STR      R0,[SP, #+0]
   \      0x44C   0x9B01             LDR      R3,[SP, #+4]
   \      0x44E   0x002A             MOVS     R2,R5
   \      0x450   0xA908             ADD      R1,SP,#+32
   \      0x452   0xA80F             ADD      R0,SP,#+60
   \      0x454   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x458   0x.... 0x....      BL       mpi_montmul
   2020                  }
   2021              }
   \                     ??mbedtls_mpi_exp_mod_53: (+1)
   \      0x45C   0x1C7F             ADDS     R7,R7,#+1
   \      0x45E   0xE7CF             B.N      ??mbedtls_mpi_exp_mod_43
   2022          
   2023              /*
   2024               * W[x_index] = A^E * R * R^-1 mod N = A^E mod N
   2025               */
   2026              mpi_montred(&W[x_index], N, mm, &T);
   \                     ??mbedtls_mpi_exp_mod_51: (+1)
   \      0x460   0xAB04             ADD      R3,SP,#+16
   \      0x462   0x9A01             LDR      R2,[SP, #+4]
   \      0x464   0x0029             MOVS     R1,R5
   \      0x466   0xA80F             ADD      R0,SP,#+60
   \      0x468   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x46C   0x.... 0x....      BL       mpi_montred
   2027          
   2028              if (neg && E->n != 0 && (E->p[0] & 1) != 0) {
   \      0x470   0x980D             LDR      R0,[SP, #+52]
   \      0x472   0x2800             CMP      R0,#+0
   \      0x474   0xD01A             BEQ.N    ??mbedtls_mpi_exp_mod_55
   \      0x476   0x981C             LDR      R0,[SP, #+112]
   \      0x478   0x88C0             LDRH     R0,[R0, #+6]
   \      0x47A   0x2800             CMP      R0,#+0
   \      0x47C   0xD016             BEQ.N    ??mbedtls_mpi_exp_mod_55
   \      0x47E   0x981C             LDR      R0,[SP, #+112]
   \      0x480   0x6800             LDR      R0,[R0, #+0]
   \      0x482   0x7800             LDRB     R0,[R0, #+0]
   \      0x484   0x07C0             LSLS     R0,R0,#+31
   \      0x486   0xD511             BPL.N    ??mbedtls_mpi_exp_mod_55
   2029                  W[x_index].s = -1;
   \      0x488   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x48C   0xA90F             ADD      R1,SP,#+60
   \      0x48E   0xEB01 0x01C8      ADD      R1,R1,R8, LSL #+3
   \      0x492   0x8088             STRH     R0,[R1, #+4]
   2030                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&W[x_index], N, &W[x_index]));
   \      0x494   0xA80F             ADD      R0,SP,#+60
   \      0x496   0xEB00 0x02C8      ADD      R2,R0,R8, LSL #+3
   \      0x49A   0x0029             MOVS     R1,R5
   \      0x49C   0xA80F             ADD      R0,SP,#+60
   \      0x49E   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x4A2   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \      0x4A6   0x4681             MOV      R9,R0
   \      0x4A8   0x2800             CMP      R0,#+0
   \      0x4AA   0xD108             BNE.N    ??mbedtls_mpi_exp_mod_12
   2031              }
   2032          
   2033              /*
   2034               * Load the result in the output variable.
   2035               */
   2036              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, &W[x_index]));
   \                     ??mbedtls_mpi_exp_mod_56: (+1)
   \                     ??mbedtls_mpi_exp_mod_55: (+1)
   \      0x4AC   0xA80F             ADD      R0,SP,#+60
   \      0x4AE   0xEB00 0x01C8      ADD      R1,R0,R8, LSL #+3
   \      0x4B2   0x981A             LDR      R0,[SP, #+104]
   \      0x4B4   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x4B8   0x4681             MOV      R9,R0
   \      0x4BA   0x2800             CMP      R0,#+0
   \      0x4BC   0xD1FF             BNE.N    ??mbedtls_mpi_exp_mod_12
   2037          
   2038          cleanup:
   2039          
   2040              /* The first bit of the sliding window is always 1 and therefore the first
   2041               * half of the table was unused. */
   2042              for (i = w_table_used_size/2; i < w_table_used_size; i++) {
   \                     ??mbedtls_mpi_exp_mod_57: (+1)
   \                     ??mbedtls_mpi_exp_mod_12: (+1)
   \      0x4BE   0x46D3             MOV      R11,R10
   \      0x4C0   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \                     ??mbedtls_mpi_exp_mod_58: (+1)
   \      0x4C4   0x45D3             CMP      R11,R10
   \      0x4C6   0xD207             BCS.N    ??mbedtls_mpi_exp_mod_59
   2043                  mbedtls_mpi_free(&W[i]);
   \      0x4C8   0xA80F             ADD      R0,SP,#+60
   \      0x4CA   0xEB00 0x00CB      ADD      R0,R0,R11, LSL #+3
   \      0x4CE   0x.... 0x....      BL       mbedtls_mpi_free
   2044              }
   \      0x4D2   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \      0x4D6   0xE7F5             B.N      ??mbedtls_mpi_exp_mod_58
   2045          
   2046              mbedtls_mpi_free(&W[x_index]);
   \                     ??mbedtls_mpi_exp_mod_59: (+1)
   \      0x4D8   0xA80F             ADD      R0,SP,#+60
   \      0x4DA   0xEB00 0x00C8      ADD      R0,R0,R8, LSL #+3
   \      0x4DE   0x.... 0x....      BL       mbedtls_mpi_free
   2047              mbedtls_mpi_free(&W[1]);
   \      0x4E2   0xA811             ADD      R0,SP,#+68
   \      0x4E4   0x.... 0x....      BL       mbedtls_mpi_free
   2048              mbedtls_mpi_free(&T);
   \      0x4E8   0xA804             ADD      R0,SP,#+16
   \      0x4EA   0x.... 0x....      BL       mbedtls_mpi_free
   2049              mbedtls_mpi_free(&Apos);
   \      0x4EE   0xA817             ADD      R0,SP,#+92
   \      0x4F0   0x.... 0x....      BL       mbedtls_mpi_free
   2050              mbedtls_mpi_free(&WW);
   \      0x4F4   0xA808             ADD      R0,SP,#+32
   \      0x4F6   0x.... 0x....      BL       mbedtls_mpi_free
   2051          
   2052              if (prec_RR == NULL || prec_RR->p == NULL) {
   \      0x4FA   0x9826             LDR      R0,[SP, #+152]
   \      0x4FC   0x2800             CMP      R0,#+0
   \      0x4FE   0xD003             BEQ.N    ??mbedtls_mpi_exp_mod_60
   \      0x500   0x9826             LDR      R0,[SP, #+152]
   \      0x502   0x6800             LDR      R0,[R0, #+0]
   \      0x504   0x2800             CMP      R0,#+0
   \      0x506   0xD102             BNE.N    ??mbedtls_mpi_exp_mod_61
   2053                  mbedtls_mpi_free(&RR);
   \                     ??mbedtls_mpi_exp_mod_60: (+1)
   \      0x508   0xA80B             ADD      R0,SP,#+44
   \      0x50A   0x.... 0x....      BL       mbedtls_mpi_free
   2054              }
   2055          
   2056              return ret;
   \                     ??mbedtls_mpi_exp_mod_61: (+1)
   \      0x50E   0x4648             MOV      R0,R9
   \                     ??mbedtls_mpi_exp_mod_2: (+1)
   \      0x510   0xB01D             ADD      SP,SP,#+116
   \      0x512   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2057          }
   2058          
   2059          /*
   2060           * Greatest common divisor: G = gcd(A, B)  (HAC 14.54)
   2061           */

   \                                 In section .text, align 2, keep-with-next
   2062          int mbedtls_mpi_gcd(mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B)
   2063          {
   \                     mbedtls_mpi_gcd: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   2064              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0A6D      MVNS     R10,#+109
   2065              size_t lz, lzt;
   2066              mbedtls_mpi TA, TB;
   2067          
   2068              MPI_VALIDATE_RET(G != NULL);
   2069              MPI_VALIDATE_RET(A != NULL);
   2070              MPI_VALIDATE_RET(B != NULL);
   2071          
   2072              mbedtls_mpi_init(&TA); mbedtls_mpi_init(&TB);
   \        0xE   0xA802             ADD      R0,SP,#+8
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_init
   2073          
   2074              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TA, A));
   \       0x1A   0x0031             MOVS     R1,R6
   \       0x1C   0xA802             ADD      R0,SP,#+8
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x22   0x4680             MOV      R8,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD174             BNE.N    ??mbedtls_mpi_gcd_0
   2075              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, B));
   \                     ??mbedtls_mpi_gcd_1: (+1)
   \       0x28   0x0039             MOVS     R1,R7
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x30   0x4680             MOV      R8,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD16D             BNE.N    ??mbedtls_mpi_gcd_0
   2076          
   2077              lz = mbedtls_mpi_lsb(&TA);
   \                     ??mbedtls_mpi_gcd_2: (+1)
   \       0x36   0xA802             ADD      R0,SP,#+8
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_lsb
   \       0x3C   0x4681             MOV      R9,R0
   2078              lzt = mbedtls_mpi_lsb(&TB);
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0x.... 0x....      BL       mbedtls_mpi_lsb
   \       0x44   0x0004             MOVS     R4,R0
   2079          
   2080              /* The loop below gives the correct result when A==0 but not when B==0.
   2081               * So have a special case for B==0. Leverage the fact that we just
   2082               * calculated the lsb and lsb(B)==0 iff B is odd or 0 to make the test
   2083               * slightly more efficient than cmp_int(). */
   2084              if (lzt == 0 && mbedtls_mpi_get_bit(&TB, 0) == 0) {
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD10B             BNE.N    ??mbedtls_mpi_gcd_3
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x4668             MOV      R0,SP
   \       0x4E   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD105             BNE.N    ??mbedtls_mpi_gcd_3
   2085                  ret = mbedtls_mpi_copy(G, A);
   \       0x56   0x0031             MOVS     R1,R6
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x5E   0x4680             MOV      R8,R0
   2086                  goto cleanup;
   \       0x60   0xE057             B.N      ??mbedtls_mpi_gcd_0
   2087              }
   2088          
   2089              if (lzt < lz) {
   \                     ??mbedtls_mpi_gcd_3: (+1)
   \       0x62   0x454C             CMP      R4,R9
   \       0x64   0xD200             BCS.N    ??mbedtls_mpi_gcd_4
   2090                  lz = lzt;
   \       0x66   0x46A1             MOV      R9,R4
   2091              }
   2092          
   2093              TA.s = TB.s = 1;
   \                     ??mbedtls_mpi_gcd_4: (+1)
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x6E   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \       0x72   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   2094          
   2095              /* We mostly follow the procedure described in HAC 14.54, but with some
   2096               * minor differences:
   2097               * - Sequences of multiplications or divisions by 2 are grouped into a
   2098               *   single shift operation.
   2099               * - The procedure in HAC assumes that 0 < TB <= TA.
   2100               *     - The condition TB <= TA is not actually necessary for correctness.
   2101               *       TA and TB have symmetric roles except for the loop termination
   2102               *       condition, and the shifts at the beginning of the loop body
   2103               *       remove any significance from the ordering of TA vs TB before
   2104               *       the shifts.
   2105               *     - If TA = 0, the loop goes through 0 iterations and the result is
   2106               *       correctly TB.
   2107               *     - The case TB = 0 was short-circuited above.
   2108               *
   2109               * For the correctness proof below, decompose the original values of
   2110               * A and B as
   2111               *   A = sa * 2^a * A' with A'=0 or A' odd, and sa = +-1
   2112               *   B = sb * 2^b * B' with B'=0 or B' odd, and sb = +-1
   2113               * Then gcd(A, B) = 2^{min(a,b)} * gcd(A',B'),
   2114               * and gcd(A',B') is odd or 0.
   2115               *
   2116               * At the beginning, we have TA = |A| and TB = |B| so gcd(A,B) = gcd(TA,TB).
   2117               * The code maintains the following invariant:
   2118               *     gcd(A,B) = 2^k * gcd(TA,TB) for some k   (I)
   2119               */
   2120          
   2121              /* Proof that the loop terminates:
   2122               * At each iteration, either the right-shift by 1 is made on a nonzero
   2123               * value and the nonnegative integer bitlen(TA) + bitlen(TB) decreases
   2124               * by at least 1, or the right-shift by 1 is made on zero and then
   2125               * TA becomes 0 which ends the loop (TB cannot be 0 if it is right-shifted
   2126               * since in that case TB is calculated from TB-TA with the condition TB>TA).
   2127               */
   2128              while (mbedtls_mpi_cmp_int(&TA, 0) != 0) {
   \                     ??mbedtls_mpi_gcd_5: (+1)
   \       0x76   0x2100             MOVS     R1,#+0
   \       0x78   0xA802             ADD      R0,SP,#+8
   \       0x7A   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD039             BEQ.N    ??mbedtls_mpi_gcd_6
   2129                  /* Divisions by 2 preserve the invariant (I). */
   2130                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TA, mbedtls_mpi_lsb(&TA)));
   \       0x82   0xA802             ADD      R0,SP,#+8
   \       0x84   0x.... 0x....      BL       mbedtls_mpi_lsb
   \       0x88   0x0001             MOVS     R1,R0
   \       0x8A   0xA802             ADD      R0,SP,#+8
   \       0x8C   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \       0x90   0x4680             MOV      R8,R0
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD13D             BNE.N    ??mbedtls_mpi_gcd_0
   2131                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TB, mbedtls_mpi_lsb(&TB)));
   \                     ??mbedtls_mpi_gcd_7: (+1)
   \       0x96   0x4668             MOV      R0,SP
   \       0x98   0x.... 0x....      BL       mbedtls_mpi_lsb
   \       0x9C   0x0001             MOVS     R1,R0
   \       0x9E   0x4668             MOV      R0,SP
   \       0xA0   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \       0xA4   0x4680             MOV      R8,R0
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD133             BNE.N    ??mbedtls_mpi_gcd_0
   2132          
   2133                  /* Set either TA or TB to |TA-TB|/2. Since TA and TB are both odd,
   2134                   * TA-TB is even so the division by 2 has an integer result.
   2135                   * Invariant (I) is preserved since any odd divisor of both TA and TB
   2136                   * also divides |TA-TB|/2, and any odd divisor of both TA and |TA-TB|/2
   2137                   * also divides TB, and any odd divisor of both TB and |TA-TB|/2 also
   2138                   * divides TA.
   2139                   */
   2140                  if (mbedtls_mpi_cmp_mpi(&TA, &TB) >= 0) {
   \                     ??mbedtls_mpi_gcd_8: (+1)
   \       0xAA   0x4669             MOV      R1,SP
   \       0xAC   0xA802             ADD      R0,SP,#+8
   \       0xAE   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD40F             BMI.N    ??mbedtls_mpi_gcd_9
   2141                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(&TA, &TA, &TB));
   \       0xB6   0x466A             MOV      R2,SP
   \       0xB8   0xA902             ADD      R1,SP,#+8
   \       0xBA   0xA802             ADD      R0,SP,#+8
   \       0xBC   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0xC0   0x4680             MOV      R8,R0
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD125             BNE.N    ??mbedtls_mpi_gcd_0
   2142                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TA, 1));
   \                     ??mbedtls_mpi_gcd_10: (+1)
   \       0xC6   0x2101             MOVS     R1,#+1
   \       0xC8   0xA802             ADD      R0,SP,#+8
   \       0xCA   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \       0xCE   0x4680             MOV      R8,R0
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xD11E             BNE.N    ??mbedtls_mpi_gcd_0
   \                     ??mbedtls_mpi_gcd_11: (+1)
   \       0xD4   0xE7CF             B.N      ??mbedtls_mpi_gcd_5
   2143                  } else {
   2144                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(&TB, &TB, &TA));
   \                     ??mbedtls_mpi_gcd_9: (+1)
   \       0xD6   0xAA02             ADD      R2,SP,#+8
   \       0xD8   0x4669             MOV      R1,SP
   \       0xDA   0x4668             MOV      R0,SP
   \       0xDC   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0xE0   0x4680             MOV      R8,R0
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD115             BNE.N    ??mbedtls_mpi_gcd_0
   2145                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TB, 1));
   \                     ??mbedtls_mpi_gcd_12: (+1)
   \       0xE6   0x2101             MOVS     R1,#+1
   \       0xE8   0x4668             MOV      R0,SP
   \       0xEA   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \       0xEE   0x4680             MOV      R8,R0
   \       0xF0   0x2800             CMP      R0,#+0
   \       0xF2   0xD10E             BNE.N    ??mbedtls_mpi_gcd_0
   \                     ??mbedtls_mpi_gcd_13: (+1)
   \       0xF4   0xE7BF             B.N      ??mbedtls_mpi_gcd_5
   2146                  }
   2147                  /* Note that one of TA or TB is still odd. */
   2148              }
   2149          
   2150              /* By invariant (I), gcd(A,B) = 2^k * gcd(TA,TB) for some k.
   2151               * At the loop exit, TA = 0, so gcd(TA,TB) = TB.
   2152               * - If there was at least one loop iteration, then one of TA or TB is odd,
   2153               *   and TA = 0, so TB is odd and gcd(TA,TB) = gcd(A',B'). In this case,
   2154               *   lz = min(a,b) so gcd(A,B) = 2^lz * TB.
   2155               * - If there was no loop iteration, then A was 0, and gcd(A,B) = B.
   2156               *   In this case, lz = 0 and B = TB so gcd(A,B) = B = 2^lz * TB as well.
   2157               */
   2158          
   2159              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&TB, lz));
   \                     ??mbedtls_mpi_gcd_6: (+1)
   \       0xF6   0x4649             MOV      R1,R9
   \       0xF8   0x4668             MOV      R0,SP
   \       0xFA   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \       0xFE   0x4680             MOV      R8,R0
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD106             BNE.N    ??mbedtls_mpi_gcd_0
   2160              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(G, &TB));
   \                     ??mbedtls_mpi_gcd_14: (+1)
   \      0x104   0x4669             MOV      R1,SP
   \      0x106   0x0028             MOVS     R0,R5
   \      0x108   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x10C   0x4680             MOV      R8,R0
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD1FF             BNE.N    ??mbedtls_mpi_gcd_0
   2161          
   2162          cleanup:
   2163          
   2164              mbedtls_mpi_free(&TA); mbedtls_mpi_free(&TB);
   \                     ??mbedtls_mpi_gcd_15: (+1)
   \                     ??mbedtls_mpi_gcd_0: (+1)
   \      0x112   0xA802             ADD      R0,SP,#+8
   \      0x114   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x118   0x4668             MOV      R0,SP
   \      0x11A   0x.... 0x....      BL       mbedtls_mpi_free
   2165          
   2166              return ret;
   \      0x11E   0x4640             MOV      R0,R8
   \      0x120   0xB004             ADD      SP,SP,#+16
   \      0x122   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2167          }
   2168          
   2169          /*
   2170           * Fill X with size bytes of random.
   2171           * The bytes returned from the RNG are used in a specific order which
   2172           * is suitable for deterministic ECDSA (see the specification of
   2173           * mbedtls_mpi_random() and the implementation in mbedtls_mpi_fill_random()).
   2174           */

   \                                 In section .text, align 2, keep-with-next
   2175          int mbedtls_mpi_fill_random(mbedtls_mpi *X, size_t size,
   2176                                      int (*f_rng)(void *, unsigned char *, size_t),
   2177                                      void *p_rng)
   2178          {
   \                     mbedtls_mpi_fill_random: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   2179              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x076D      MVNS     R7,#+109
   2180              const size_t limbs = CHARS_TO_LIMBS(size);
   \       0x10   0xF014 0x0F03      TST      R4,#0x3
   \       0x14   0xD001             BEQ.N    ??mbedtls_mpi_fill_random_0
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0xE000             B.N      ??mbedtls_mpi_fill_random_1
   \                     ??mbedtls_mpi_fill_random_0: (+1)
   \       0x1A   0x2100             MOVS     R1,#+0
   \                     ??mbedtls_mpi_fill_random_1: (+1)
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x0880             LSRS     R0,R0,#+2
   \       0x20   0xFA50 0xF881      UXTAB    R8,R0,R1
   2181          
   2182              MPI_VALIDATE_RET(X     != NULL);
   2183              MPI_VALIDATE_RET(f_rng != NULL);
   2184          
   2185              /* Ensure that target MPI has exactly the necessary number of limbs */
   2186              MBEDTLS_MPI_CHK(mbedtls_mpi_resize_clear(X, limbs));
   \       0x24   0x4641             MOV      R1,R8
   \       0x26   0x4650             MOV      R0,R10
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_resize_clear
   \       0x2C   0x4681             MOV      R9,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD10D             BNE.N    ??mbedtls_mpi_fill_random_2
   2187              if (size == 0) {
   \                     ??mbedtls_mpi_fill_random_3: (+1)
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD101             BNE.N    ??mbedtls_mpi_fill_random_4
   2188                  return 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE00A             B.N      ??mbedtls_mpi_fill_random_5
   2189              }
   2190          
   2191              ret = mbedtls_mpi_core_fill_random(X->p, X->n, size, f_rng, p_rng);
   \                     ??mbedtls_mpi_fill_random_4: (+1)
   \       0x3A   0x9600             STR      R6,[SP, #+0]
   \       0x3C   0x002B             MOVS     R3,R5
   \       0x3E   0x0022             MOVS     R2,R4
   \       0x40   0xF8BA 0x1006      LDRH     R1,[R10, #+6]
   \       0x44   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x48   0x.... 0x....      BL       mbedtls_mpi_core_fill_random
   \       0x4C   0x4681             MOV      R9,R0
   2192          
   2193          cleanup:
   2194              return ret;
   \                     ??mbedtls_mpi_fill_random_2: (+1)
   \       0x4E   0x4648             MOV      R0,R9
   \                     ??mbedtls_mpi_fill_random_5: (+1)
   \       0x50   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   2195          }
   2196          

   \                                 In section .text, align 2, keep-with-next
   2197          int mbedtls_mpi_random(mbedtls_mpi *X,
   2198                                 mbedtls_mpi_sint min,
   2199                                 const mbedtls_mpi *N,
   2200                                 int (*f_rng)(void *, unsigned char *, size_t),
   2201                                 void *p_rng)
   2202          {
   \                     mbedtls_mpi_random: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   2203              if (min < 0) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD502             BPL.N    ??mbedtls_mpi_random_0
   2204                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x10   0xF07F 0x0003      MVNS     R0,#+3
   \       0x14   0xE01B             B.N      ??mbedtls_mpi_random_1
   2205              }
   2206              if (mbedtls_mpi_cmp_int(N, min) <= 0) {
   \                     ??mbedtls_mpi_random_0: (+1)
   \       0x16   0x0031             MOVS     R1,R6
   \       0x18   0x0038             MOVS     R0,R7
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xDA02             BGE.N    ??mbedtls_mpi_random_2
   2207                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x22   0xF07F 0x0003      MVNS     R0,#+3
   \       0x26   0xE012             B.N      ??mbedtls_mpi_random_1
   2208              }
   2209          
   2210              /* Ensure that target MPI has exactly the same number of limbs
   2211               * as the upper bound, even if the upper bound has leading zeros.
   2212               * This is necessary for mbedtls_mpi_core_random. */
   2213              int ret = mbedtls_mpi_resize_clear(X, N->n);
   \                     ??mbedtls_mpi_random_2: (+1)
   \       0x28   0x88F9             LDRH     R1,[R7, #+6]
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_resize_clear
   \       0x30   0x0004             MOVS     R4,R0
   2214              if (ret != 0) {
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD001             BEQ.N    ??mbedtls_mpi_random_3
   2215                  return ret;
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0xE009             B.N      ??mbedtls_mpi_random_1
   2216              }
   2217          
   2218              return mbedtls_mpi_core_random(X->p, min, N->p, X->n, f_rng, p_rng);
   \                     ??mbedtls_mpi_random_3: (+1)
   \       0x3A   0x9808             LDR      R0,[SP, #+32]
   \       0x3C   0x9001             STR      R0,[SP, #+4]
   \       0x3E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x42   0x88EB             LDRH     R3,[R5, #+6]
   \       0x44   0x683A             LDR      R2,[R7, #+0]
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x.... 0x....      BL       mbedtls_mpi_core_random
   \                     ??mbedtls_mpi_random_1: (+1)
   \       0x4E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   2219          }
   2220          
   2221          /*
   2222           * Modular inverse: X = A^-1 mod N  (HAC 14.61 / 14.64)
   2223           */

   \                                 In section .text, align 2, keep-with-next
   2224          int mbedtls_mpi_inv_mod(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N)
   2225          {
   \                     mbedtls_mpi_inv_mod: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   2226              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF07F 0x086D      MVNS     R8,#+109
   2227              mbedtls_mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
   2228              MPI_VALIDATE_RET(X != NULL);
   2229              MPI_VALIDATE_RET(A != NULL);
   2230              MPI_VALIDATE_RET(N != NULL);
   2231          
   2232              if (mbedtls_mpi_cmp_int(N, 1) <= 0) {
   \       0x10   0x2101             MOVS     R1,#+1
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xDA02             BGE.N    ??mbedtls_mpi_inv_mod_0
   2233                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x1C   0xF07F 0x0003      MVNS     R0,#+3
   \       0x20   0xE157             B.N      ??mbedtls_mpi_inv_mod_1
   2234              }
   2235          
   2236              mbedtls_mpi_init(&TA); mbedtls_mpi_init(&TU); mbedtls_mpi_init(&U1); mbedtls_mpi_init(&U2);
   \                     ??mbedtls_mpi_inv_mod_0: (+1)
   \       0x22   0xA80C             ADD      R0,SP,#+48
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x28   0xA808             ADD      R0,SP,#+32
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x2E   0xA806             ADD      R0,SP,#+24
   \       0x30   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x34   0xA804             ADD      R0,SP,#+16
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_init
   2237              mbedtls_mpi_init(&G); mbedtls_mpi_init(&TB); mbedtls_mpi_init(&TV);
   \       0x3A   0xA810             ADD      R0,SP,#+64
   \       0x3C   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x40   0xA80E             ADD      R0,SP,#+56
   \       0x42   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x46   0xA80A             ADD      R0,SP,#+40
   \       0x48   0x.... 0x....      BL       mbedtls_mpi_init
   2238              mbedtls_mpi_init(&V1); mbedtls_mpi_init(&V2);
   \       0x4C   0x4668             MOV      R0,SP
   \       0x4E   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x52   0xA802             ADD      R0,SP,#+8
   \       0x54   0x.... 0x....      BL       mbedtls_mpi_init
   2239          
   2240              MBEDTLS_MPI_CHK(mbedtls_mpi_gcd(&G, A, N));
   \       0x58   0x002A             MOVS     R2,R5
   \       0x5A   0x0021             MOVS     R1,R4
   \       0x5C   0xA810             ADD      R0,SP,#+64
   \       0x5E   0x.... 0x....      BL       mbedtls_mpi_gcd
   \       0x62   0x0006             MOVS     R6,R0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xF040 0x8118      BNE.W    ??mbedtls_mpi_inv_mod_2
   2241          
   2242              if (mbedtls_mpi_cmp_int(&G, 1) != 0) {
   \                     ??mbedtls_mpi_inv_mod_3: (+1)
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0xA810             ADD      R0,SP,#+64
   \       0x6E   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD003             BEQ.N    ??mbedtls_mpi_inv_mod_4
   2243                  ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   \       0x76   0xF07F 0x000D      MVNS     R0,#+13
   \       0x7A   0x0006             MOVS     R6,R0
   2244                  goto cleanup;
   \       0x7C   0xE10D             B.N      ??mbedtls_mpi_inv_mod_2
   2245              }
   2246          
   2247              MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&TA, A, N));
   \                     ??mbedtls_mpi_inv_mod_4: (+1)
   \       0x7E   0x002A             MOVS     R2,R5
   \       0x80   0x0021             MOVS     R1,R4
   \       0x82   0xA80C             ADD      R0,SP,#+48
   \       0x84   0x.... 0x....      BL       mbedtls_mpi_mod_mpi
   \       0x88   0x0006             MOVS     R6,R0
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xF040 0x8105      BNE.W    ??mbedtls_mpi_inv_mod_2
   2248              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TU, &TA));
   \                     ??mbedtls_mpi_inv_mod_5: (+1)
   \       0x90   0xA90C             ADD      R1,SP,#+48
   \       0x92   0xA808             ADD      R0,SP,#+32
   \       0x94   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x98   0x0006             MOVS     R6,R0
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xF040 0x80FD      BNE.W    ??mbedtls_mpi_inv_mod_2
   2249              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, N));
   \                     ??mbedtls_mpi_inv_mod_6: (+1)
   \       0xA0   0x0029             MOVS     R1,R5
   \       0xA2   0xA80E             ADD      R0,SP,#+56
   \       0xA4   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0xA8   0x0006             MOVS     R6,R0
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xF040 0x80F5      BNE.W    ??mbedtls_mpi_inv_mod_2
   2250              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TV, N));
   \                     ??mbedtls_mpi_inv_mod_7: (+1)
   \       0xB0   0x0029             MOVS     R1,R5
   \       0xB2   0xA80A             ADD      R0,SP,#+40
   \       0xB4   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0xB8   0x0006             MOVS     R6,R0
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xF040 0x80ED      BNE.W    ??mbedtls_mpi_inv_mod_2
   2251          
   2252              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&U1, 1));
   \                     ??mbedtls_mpi_inv_mod_8: (+1)
   \       0xC0   0x2101             MOVS     R1,#+1
   \       0xC2   0xA806             ADD      R0,SP,#+24
   \       0xC4   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xC8   0x0006             MOVS     R6,R0
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xF040 0x80E5      BNE.W    ??mbedtls_mpi_inv_mod_2
   2253              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&U2, 0));
   \                     ??mbedtls_mpi_inv_mod_9: (+1)
   \       0xD0   0x2100             MOVS     R1,#+0
   \       0xD2   0xA804             ADD      R0,SP,#+16
   \       0xD4   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xD8   0x0006             MOVS     R6,R0
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xF040 0x80DD      BNE.W    ??mbedtls_mpi_inv_mod_2
   2254              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&V1, 0));
   \                     ??mbedtls_mpi_inv_mod_10: (+1)
   \       0xE0   0x2100             MOVS     R1,#+0
   \       0xE2   0x4668             MOV      R0,SP
   \       0xE4   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xE8   0x0006             MOVS     R6,R0
   \       0xEA   0x2800             CMP      R0,#+0
   \       0xEC   0xF040 0x80D5      BNE.W    ??mbedtls_mpi_inv_mod_2
   2255              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&V2, 1));
   \                     ??mbedtls_mpi_inv_mod_11: (+1)
   \       0xF0   0x2101             MOVS     R1,#+1
   \       0xF2   0xA802             ADD      R0,SP,#+8
   \       0xF4   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xF8   0x0006             MOVS     R6,R0
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xF040 0x80CD      BNE.W    ??mbedtls_mpi_inv_mod_2
   2256          
   2257              do {
   2258                  while ((TU.p[0] & 1) == 0) {
   \                     ??mbedtls_mpi_inv_mod_12: (+1)
   \                     ??mbedtls_mpi_inv_mod_13: (+1)
   \      0x100   0x9808             LDR      R0,[SP, #+32]
   \      0x102   0x7800             LDRB     R0,[R0, #+0]
   \      0x104   0x07C0             LSLS     R0,R0,#+31
   \      0x106   0xD432             BMI.N    ??mbedtls_mpi_inv_mod_14
   2259                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TU, 1));
   \      0x108   0x2101             MOVS     R1,#+1
   \      0x10A   0xA808             ADD      R0,SP,#+32
   \      0x10C   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x110   0x0006             MOVS     R6,R0
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xF040 0x80C1      BNE.W    ??mbedtls_mpi_inv_mod_2
   2260          
   2261                      if ((U1.p[0] & 1) != 0 || (U2.p[0] & 1) != 0) {
   \                     ??mbedtls_mpi_inv_mod_15: (+1)
   \      0x118   0x9806             LDR      R0,[SP, #+24]
   \      0x11A   0x7800             LDRB     R0,[R0, #+0]
   \      0x11C   0x07C0             LSLS     R0,R0,#+31
   \      0x11E   0xD403             BMI.N    ??mbedtls_mpi_inv_mod_16
   \      0x120   0x9804             LDR      R0,[SP, #+16]
   \      0x122   0x7800             LDRB     R0,[R0, #+0]
   \      0x124   0x07C0             LSLS     R0,R0,#+31
   \      0x126   0xD511             BPL.N    ??mbedtls_mpi_inv_mod_17
   2262                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&U1, &U1, &TB));
   \                     ??mbedtls_mpi_inv_mod_16: (+1)
   \      0x128   0xAA0E             ADD      R2,SP,#+56
   \      0x12A   0xA906             ADD      R1,SP,#+24
   \      0x12C   0xA806             ADD      R0,SP,#+24
   \      0x12E   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \      0x132   0x0006             MOVS     R6,R0
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xF040 0x80B0      BNE.W    ??mbedtls_mpi_inv_mod_2
   2263                          MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U2, &U2, &TA));
   \                     ??mbedtls_mpi_inv_mod_18: (+1)
   \      0x13A   0xAA0C             ADD      R2,SP,#+48
   \      0x13C   0xA904             ADD      R1,SP,#+16
   \      0x13E   0xA804             ADD      R0,SP,#+16
   \      0x140   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x144   0x0006             MOVS     R6,R0
   \      0x146   0x2800             CMP      R0,#+0
   \      0x148   0xF040 0x80A7      BNE.W    ??mbedtls_mpi_inv_mod_2
   2264                      }
   2265          
   2266                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&U1, 1));
   \                     ??mbedtls_mpi_inv_mod_19: (+1)
   \                     ??mbedtls_mpi_inv_mod_17: (+1)
   \      0x14C   0x2101             MOVS     R1,#+1
   \      0x14E   0xA806             ADD      R0,SP,#+24
   \      0x150   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x154   0x0006             MOVS     R6,R0
   \      0x156   0x2800             CMP      R0,#+0
   \      0x158   0xF040 0x809F      BNE.W    ??mbedtls_mpi_inv_mod_2
   2267                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&U2, 1));
   \                     ??mbedtls_mpi_inv_mod_20: (+1)
   \      0x15C   0x2101             MOVS     R1,#+1
   \      0x15E   0xA804             ADD      R0,SP,#+16
   \      0x160   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x164   0x0006             MOVS     R6,R0
   \      0x166   0x2800             CMP      R0,#+0
   \      0x168   0xF040 0x8097      BNE.W    ??mbedtls_mpi_inv_mod_2
   \                     ??mbedtls_mpi_inv_mod_21: (+1)
   \      0x16C   0xE7C8             B.N      ??mbedtls_mpi_inv_mod_13
   2268                  }
   2269          
   2270                  while ((TV.p[0] & 1) == 0) {
   \                     ??mbedtls_mpi_inv_mod_14: (+1)
   \      0x16E   0x980A             LDR      R0,[SP, #+40]
   \      0x170   0x7800             LDRB     R0,[R0, #+0]
   \      0x172   0x07C0             LSLS     R0,R0,#+31
   \      0x174   0xD42E             BMI.N    ??mbedtls_mpi_inv_mod_22
   2271                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TV, 1));
   \      0x176   0x2101             MOVS     R1,#+1
   \      0x178   0xA80A             ADD      R0,SP,#+40
   \      0x17A   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x17E   0x0006             MOVS     R6,R0
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xF040 0x808A      BNE.W    ??mbedtls_mpi_inv_mod_2
   2272          
   2273                      if ((V1.p[0] & 1) != 0 || (V2.p[0] & 1) != 0) {
   \                     ??mbedtls_mpi_inv_mod_23: (+1)
   \      0x186   0x9800             LDR      R0,[SP, #+0]
   \      0x188   0x7800             LDRB     R0,[R0, #+0]
   \      0x18A   0x07C0             LSLS     R0,R0,#+31
   \      0x18C   0xD403             BMI.N    ??mbedtls_mpi_inv_mod_24
   \      0x18E   0x9802             LDR      R0,[SP, #+8]
   \      0x190   0x7800             LDRB     R0,[R0, #+0]
   \      0x192   0x07C0             LSLS     R0,R0,#+31
   \      0x194   0xD50F             BPL.N    ??mbedtls_mpi_inv_mod_25
   2274                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&V1, &V1, &TB));
   \                     ??mbedtls_mpi_inv_mod_24: (+1)
   \      0x196   0xAA0E             ADD      R2,SP,#+56
   \      0x198   0x4669             MOV      R1,SP
   \      0x19A   0x4668             MOV      R0,SP
   \      0x19C   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \      0x1A0   0x0006             MOVS     R6,R0
   \      0x1A2   0x2800             CMP      R0,#+0
   \      0x1A4   0xD179             BNE.N    ??mbedtls_mpi_inv_mod_2
   2275                          MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V2, &V2, &TA));
   \                     ??mbedtls_mpi_inv_mod_26: (+1)
   \      0x1A6   0xAA0C             ADD      R2,SP,#+48
   \      0x1A8   0xA902             ADD      R1,SP,#+8
   \      0x1AA   0xA802             ADD      R0,SP,#+8
   \      0x1AC   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x1B0   0x0006             MOVS     R6,R0
   \      0x1B2   0x2800             CMP      R0,#+0
   \      0x1B4   0xD171             BNE.N    ??mbedtls_mpi_inv_mod_2
   2276                      }
   2277          
   2278                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&V1, 1));
   \                     ??mbedtls_mpi_inv_mod_27: (+1)
   \                     ??mbedtls_mpi_inv_mod_25: (+1)
   \      0x1B6   0x2101             MOVS     R1,#+1
   \      0x1B8   0x4668             MOV      R0,SP
   \      0x1BA   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x1BE   0x0006             MOVS     R6,R0
   \      0x1C0   0x2800             CMP      R0,#+0
   \      0x1C2   0xD16A             BNE.N    ??mbedtls_mpi_inv_mod_2
   2279                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&V2, 1));
   \                     ??mbedtls_mpi_inv_mod_28: (+1)
   \      0x1C4   0x2101             MOVS     R1,#+1
   \      0x1C6   0xA802             ADD      R0,SP,#+8
   \      0x1C8   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x1CC   0x0006             MOVS     R6,R0
   \      0x1CE   0x2800             CMP      R0,#+0
   \      0x1D0   0xD163             BNE.N    ??mbedtls_mpi_inv_mod_2
   \                     ??mbedtls_mpi_inv_mod_29: (+1)
   \      0x1D2   0xE7CC             B.N      ??mbedtls_mpi_inv_mod_14
   2280                  }
   2281          
   2282                  if (mbedtls_mpi_cmp_mpi(&TU, &TV) >= 0) {
   \                     ??mbedtls_mpi_inv_mod_22: (+1)
   \      0x1D4   0xA90A             ADD      R1,SP,#+40
   \      0x1D6   0xA808             ADD      R0,SP,#+32
   \      0x1D8   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x1DC   0x2800             CMP      R0,#+0
   \      0x1DE   0xD418             BMI.N    ??mbedtls_mpi_inv_mod_30
   2283                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&TU, &TU, &TV));
   \      0x1E0   0xAA0A             ADD      R2,SP,#+40
   \      0x1E2   0xA908             ADD      R1,SP,#+32
   \      0x1E4   0xA808             ADD      R0,SP,#+32
   \      0x1E6   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x1EA   0x0006             MOVS     R6,R0
   \      0x1EC   0x2800             CMP      R0,#+0
   \      0x1EE   0xD154             BNE.N    ??mbedtls_mpi_inv_mod_2
   2284                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U1, &U1, &V1));
   \                     ??mbedtls_mpi_inv_mod_31: (+1)
   \      0x1F0   0x466A             MOV      R2,SP
   \      0x1F2   0xA906             ADD      R1,SP,#+24
   \      0x1F4   0xA806             ADD      R0,SP,#+24
   \      0x1F6   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x1FA   0x0006             MOVS     R6,R0
   \      0x1FC   0x2800             CMP      R0,#+0
   \      0x1FE   0xD14C             BNE.N    ??mbedtls_mpi_inv_mod_2
   2285                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U2, &U2, &V2));
   \                     ??mbedtls_mpi_inv_mod_32: (+1)
   \      0x200   0xAA02             ADD      R2,SP,#+8
   \      0x202   0xA904             ADD      R1,SP,#+16
   \      0x204   0xA804             ADD      R0,SP,#+16
   \      0x206   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x20A   0x0006             MOVS     R6,R0
   \      0x20C   0x2800             CMP      R0,#+0
   \      0x20E   0xD144             BNE.N    ??mbedtls_mpi_inv_mod_2
   \                     ??mbedtls_mpi_inv_mod_33: (+1)
   \      0x210   0xE017             B.N      ??mbedtls_mpi_inv_mod_34
   2286                  } else {
   2287                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&TV, &TV, &TU));
   \                     ??mbedtls_mpi_inv_mod_30: (+1)
   \      0x212   0xAA08             ADD      R2,SP,#+32
   \      0x214   0xA90A             ADD      R1,SP,#+40
   \      0x216   0xA80A             ADD      R0,SP,#+40
   \      0x218   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x21C   0x0006             MOVS     R6,R0
   \      0x21E   0x2800             CMP      R0,#+0
   \      0x220   0xD13B             BNE.N    ??mbedtls_mpi_inv_mod_2
   2288                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V1, &V1, &U1));
   \                     ??mbedtls_mpi_inv_mod_35: (+1)
   \      0x222   0xAA06             ADD      R2,SP,#+24
   \      0x224   0x4669             MOV      R1,SP
   \      0x226   0x4668             MOV      R0,SP
   \      0x228   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x22C   0x0006             MOVS     R6,R0
   \      0x22E   0x2800             CMP      R0,#+0
   \      0x230   0xD133             BNE.N    ??mbedtls_mpi_inv_mod_2
   2289                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V2, &V2, &U2));
   \                     ??mbedtls_mpi_inv_mod_36: (+1)
   \      0x232   0xAA04             ADD      R2,SP,#+16
   \      0x234   0xA902             ADD      R1,SP,#+8
   \      0x236   0xA802             ADD      R0,SP,#+8
   \      0x238   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x23C   0x0006             MOVS     R6,R0
   \      0x23E   0x2800             CMP      R0,#+0
   \      0x240   0xD12B             BNE.N    ??mbedtls_mpi_inv_mod_2
   2290                  }
   2291              } while (mbedtls_mpi_cmp_int(&TU, 0) != 0);
   \                     ??mbedtls_mpi_inv_mod_37: (+1)
   \                     ??mbedtls_mpi_inv_mod_34: (+1)
   \      0x242   0x2100             MOVS     R1,#+0
   \      0x244   0xA808             ADD      R0,SP,#+32
   \      0x246   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x24A   0x2800             CMP      R0,#+0
   \      0x24C   0xF47F 0xAF58      BNE.W    ??mbedtls_mpi_inv_mod_13
   2292          
   2293              while (mbedtls_mpi_cmp_int(&V1, 0) < 0) {
   \                     ??mbedtls_mpi_inv_mod_38: (+1)
   \      0x250   0x2100             MOVS     R1,#+0
   \      0x252   0x4668             MOV      R0,SP
   \      0x254   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x258   0x2800             CMP      R0,#+0
   \      0x25A   0xD508             BPL.N    ??mbedtls_mpi_inv_mod_39
   2294                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&V1, &V1, N));
   \      0x25C   0x002A             MOVS     R2,R5
   \      0x25E   0x4669             MOV      R1,SP
   \      0x260   0x4668             MOV      R0,SP
   \      0x262   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \      0x266   0x0006             MOVS     R6,R0
   \      0x268   0x2800             CMP      R0,#+0
   \      0x26A   0xD116             BNE.N    ??mbedtls_mpi_inv_mod_2
   \                     ??mbedtls_mpi_inv_mod_40: (+1)
   \      0x26C   0xE7F0             B.N      ??mbedtls_mpi_inv_mod_38
   2295              }
   2296          
   2297              while (mbedtls_mpi_cmp_mpi(&V1, N) >= 0) {
   \                     ??mbedtls_mpi_inv_mod_39: (+1)
   \      0x26E   0x0029             MOVS     R1,R5
   \      0x270   0x4668             MOV      R0,SP
   \      0x272   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x276   0x2800             CMP      R0,#+0
   \      0x278   0xD408             BMI.N    ??mbedtls_mpi_inv_mod_41
   2298                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V1, &V1, N));
   \      0x27A   0x002A             MOVS     R2,R5
   \      0x27C   0x4669             MOV      R1,SP
   \      0x27E   0x4668             MOV      R0,SP
   \      0x280   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x284   0x0006             MOVS     R6,R0
   \      0x286   0x2800             CMP      R0,#+0
   \      0x288   0xD107             BNE.N    ??mbedtls_mpi_inv_mod_2
   \                     ??mbedtls_mpi_inv_mod_42: (+1)
   \      0x28A   0xE7F0             B.N      ??mbedtls_mpi_inv_mod_39
   2299              }
   2300          
   2301              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, &V1));
   \                     ??mbedtls_mpi_inv_mod_41: (+1)
   \      0x28C   0x4669             MOV      R1,SP
   \      0x28E   0x0038             MOVS     R0,R7
   \      0x290   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x294   0x0006             MOVS     R6,R0
   \      0x296   0x2800             CMP      R0,#+0
   \      0x298   0xD1FF             BNE.N    ??mbedtls_mpi_inv_mod_2
   2302          
   2303          cleanup:
   2304          
   2305              mbedtls_mpi_free(&TA); mbedtls_mpi_free(&TU); mbedtls_mpi_free(&U1); mbedtls_mpi_free(&U2);
   \                     ??mbedtls_mpi_inv_mod_43: (+1)
   \                     ??mbedtls_mpi_inv_mod_2: (+1)
   \      0x29A   0xA80C             ADD      R0,SP,#+48
   \      0x29C   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x2A0   0xA808             ADD      R0,SP,#+32
   \      0x2A2   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x2A6   0xA806             ADD      R0,SP,#+24
   \      0x2A8   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x2AC   0xA804             ADD      R0,SP,#+16
   \      0x2AE   0x.... 0x....      BL       mbedtls_mpi_free
   2306              mbedtls_mpi_free(&G); mbedtls_mpi_free(&TB); mbedtls_mpi_free(&TV);
   \      0x2B2   0xA810             ADD      R0,SP,#+64
   \      0x2B4   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x2B8   0xA80E             ADD      R0,SP,#+56
   \      0x2BA   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x2BE   0xA80A             ADD      R0,SP,#+40
   \      0x2C0   0x.... 0x....      BL       mbedtls_mpi_free
   2307              mbedtls_mpi_free(&V1); mbedtls_mpi_free(&V2);
   \      0x2C4   0x4668             MOV      R0,SP
   \      0x2C6   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x2CA   0xA802             ADD      R0,SP,#+8
   \      0x2CC   0x.... 0x....      BL       mbedtls_mpi_free
   2308          
   2309              return ret;
   \      0x2D0   0x0030             MOVS     R0,R6
   \                     ??mbedtls_mpi_inv_mod_1: (+1)
   \      0x2D2   0xB012             ADD      SP,SP,#+72
   \      0x2D4   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2310          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     mbedtls_ct_zero

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x30 0x31          DC8 "0123456789ABCDEF"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x00
   \       0x11                      DS8 3
   2311          
   2312          #if defined(MBEDTLS_GENPRIME)
   2313          
   2314          /* Gaps between primes, starting at 3. https://oeis.org/A001223 */
   2315          static const unsigned char small_prime_gaps[] = {
   2316              2, 2, 4, 2, 4, 2, 4, 6,
   2317              2, 6, 4, 2, 4, 6, 6, 2,
   2318              6, 4, 2, 6, 4, 6, 8, 4,
   2319              2, 4, 2, 4, 14, 4, 6, 2,
   2320              10, 2, 6, 6, 4, 6, 6, 2,
   2321              10, 2, 4, 2, 12, 12, 4, 2,
   2322              4, 6, 2, 10, 6, 6, 6, 2,
   2323              6, 4, 2, 10, 14, 4, 2, 4,
   2324              14, 6, 10, 2, 4, 6, 8, 6,
   2325              6, 4, 6, 8, 4, 8, 10, 2,
   2326              10, 2, 6, 4, 6, 8, 4, 2,
   2327              4, 12, 8, 4, 8, 4, 6, 12,
   2328              2, 18, 6, 10, 6, 6, 2, 6,
   2329              10, 6, 6, 2, 6, 6, 4, 2,
   2330              12, 10, 2, 4, 6, 6, 2, 12,
   2331              4, 6, 8, 10, 8, 10, 8, 6,
   2332              6, 4, 8, 6, 4, 8, 4, 14,
   2333              10, 12, 2, 10, 2, 4, 2, 10,
   2334              14, 4, 2, 4, 14, 4, 2, 4,
   2335              20, 4, 8, 10, 8, 4, 6, 6,
   2336              14, 4, 6, 6, 8, 6, /*reaches 997*/
   2337              0 /* the last entry is effectively unused */
   2338          };
   2339          
   2340          /*
   2341           * Small divisors test (X must be positive)
   2342           *
   2343           * Return values:
   2344           * 0: no small factor (possible prime, more tests needed)
   2345           * 1: certain prime
   2346           * MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: certain non-prime
   2347           * other negative: error
   2348           */
   2349          static int mpi_check_small_factors(const mbedtls_mpi *X)
   2350          {
   2351              int ret = 0;
   2352              size_t i;
   2353              mbedtls_mpi_uint r;
   2354              unsigned p = 3; /* The first odd prime */
   2355          
   2356              if ((X->p[0] & 1) == 0) {
   2357                  return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2358              }
   2359          
   2360              for (i = 0; i < sizeof(small_prime_gaps); p += small_prime_gaps[i], i++) {
   2361                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_int(&r, X, p));
   2362                  if (r == 0) {
   2363                      if (mbedtls_mpi_cmp_int(X, p) == 0) {
   2364                          return 1;
   2365                      } else {
   2366                          return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2367                      }
   2368                  }
   2369              }
   2370          
   2371          cleanup:
   2372              return ret;
   2373          }
   2374          
   2375          /*
   2376           * Miller-Rabin pseudo-primality test  (HAC 4.24)
   2377           */
   2378          static int mpi_miller_rabin(const mbedtls_mpi *X, size_t rounds,
   2379                                      int (*f_rng)(void *, unsigned char *, size_t),
   2380                                      void *p_rng)
   2381          {
   2382              int ret, count;
   2383              size_t i, j, k, s;
   2384              mbedtls_mpi W, R, T, A, RR;
   2385          
   2386              MPI_VALIDATE_RET(X     != NULL);
   2387              MPI_VALIDATE_RET(f_rng != NULL);
   2388          
   2389              mbedtls_mpi_init(&W); mbedtls_mpi_init(&R);
   2390              mbedtls_mpi_init(&T); mbedtls_mpi_init(&A);
   2391              mbedtls_mpi_init(&RR);
   2392          
   2393              /*
   2394               * W = |X| - 1
   2395               * R = W >> lsb( W )
   2396               */
   2397              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int(&W, X, 1));
   2398              s = mbedtls_mpi_lsb(&W);
   2399              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&R, &W));
   2400              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&R, s));
   2401          
   2402              for (i = 0; i < rounds; i++) {
   2403                  /*
   2404                   * pick a random A, 1 < A < |X| - 1
   2405                   */
   2406                  count = 0;
   2407                  do {
   2408                      MBEDTLS_MPI_CHK(mbedtls_mpi_fill_random(&A, X->n * ciL, f_rng, p_rng));
   2409          
   2410                      j = mbedtls_mpi_bitlen(&A);
   2411                      k = mbedtls_mpi_bitlen(&W);
   2412                      if (j > k) {
   2413                          A.p[A.n - 1] &= ((mbedtls_mpi_uint) 1 << (k - (A.n - 1) * biL - 1)) - 1;
   2414                      }
   2415          
   2416                      if (count++ > 30) {
   2417                          ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2418                          goto cleanup;
   2419                      }
   2420          
   2421                  } while (mbedtls_mpi_cmp_mpi(&A, &W) >= 0 ||
   2422                           mbedtls_mpi_cmp_int(&A, 1)  <= 0);
   2423          
   2424                  /*
   2425                   * A = A^R mod |X|
   2426                   */
   2427                  MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(&A, &A, &R, X, &RR));
   2428          
   2429                  if (mbedtls_mpi_cmp_mpi(&A, &W) == 0 ||
   2430                      mbedtls_mpi_cmp_int(&A,  1) == 0) {
   2431                      continue;
   2432                  }
   2433          
   2434                  j = 1;
   2435                  while (j < s && mbedtls_mpi_cmp_mpi(&A, &W) != 0) {
   2436                      /*
   2437                       * A = A * A mod |X|
   2438                       */
   2439                      MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&T, &A, &A));
   2440                      MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&A, &T, X));
   2441          
   2442                      if (mbedtls_mpi_cmp_int(&A, 1) == 0) {
   2443                          break;
   2444                      }
   2445          
   2446                      j++;
   2447                  }
   2448          
   2449                  /*
   2450                   * not prime if A != |X| - 1 or A == 1
   2451                   */
   2452                  if (mbedtls_mpi_cmp_mpi(&A, &W) != 0 ||
   2453                      mbedtls_mpi_cmp_int(&A,  1) == 0) {
   2454                      ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2455                      break;
   2456                  }
   2457              }
   2458          
   2459          cleanup:
   2460              mbedtls_mpi_free(&W); mbedtls_mpi_free(&R);
   2461              mbedtls_mpi_free(&T); mbedtls_mpi_free(&A);
   2462              mbedtls_mpi_free(&RR);
   2463          
   2464              return ret;
   2465          }
   2466          
   2467          /*
   2468           * Pseudo-primality test: small factors, then Miller-Rabin
   2469           */
   2470          int mbedtls_mpi_is_prime_ext(const mbedtls_mpi *X, int rounds,
   2471                                       int (*f_rng)(void *, unsigned char *, size_t),
   2472                                       void *p_rng)
   2473          {
   2474              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2475              mbedtls_mpi XX;
   2476              MPI_VALIDATE_RET(X     != NULL);
   2477              MPI_VALIDATE_RET(f_rng != NULL);
   2478          
   2479              XX.s = 1;
   2480              XX.n = X->n;
   2481              XX.p = X->p;
   2482          
   2483              if (mbedtls_mpi_cmp_int(&XX, 0) == 0 ||
   2484                  mbedtls_mpi_cmp_int(&XX, 1) == 0) {
   2485                  return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2486              }
   2487          
   2488              if (mbedtls_mpi_cmp_int(&XX, 2) == 0) {
   2489                  return 0;
   2490              }
   2491          
   2492              if ((ret = mpi_check_small_factors(&XX)) != 0) {
   2493                  if (ret == 1) {
   2494                      return 0;
   2495                  }
   2496          
   2497                  return ret;
   2498              }
   2499          
   2500              return mpi_miller_rabin(&XX, rounds, f_rng, p_rng);
   2501          }
   2502          
   2503          /*
   2504           * Prime number generation
   2505           *
   2506           * To generate an RSA key in a way recommended by FIPS 186-4, both primes must
   2507           * be either 1024 bits or 1536 bits long, and flags must contain
   2508           * MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR.
   2509           */
   2510          int mbedtls_mpi_gen_prime(mbedtls_mpi *X, size_t nbits, int flags,
   2511                                    int (*f_rng)(void *, unsigned char *, size_t),
   2512                                    void *p_rng)
   2513          {
   2514          #ifdef MBEDTLS_HAVE_INT64
   2515          // ceil(2^63.5)
   2516          #define CEIL_MAXUINT_DIV_SQRT2 0xb504f333f9de6485ULL
   2517          #else
   2518          // ceil(2^31.5)
   2519          #define CEIL_MAXUINT_DIV_SQRT2 0xb504f334U
   2520          #endif
   2521              int ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2522              size_t k, n;
   2523              int rounds;
   2524              mbedtls_mpi_uint r;
   2525              mbedtls_mpi Y;
   2526          
   2527              MPI_VALIDATE_RET(X     != NULL);
   2528              MPI_VALIDATE_RET(f_rng != NULL);
   2529          
   2530              if (nbits < 3 || nbits > MBEDTLS_MPI_MAX_BITS) {
   2531                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   2532              }
   2533          
   2534              mbedtls_mpi_init(&Y);
   2535          
   2536              n = BITS_TO_LIMBS(nbits);
   2537          
   2538              if ((flags & MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR) == 0) {
   2539                  /*
   2540                   * 2^-80 error probability, number of rounds chosen per HAC, table 4.4
   2541                   */
   2542                  rounds = ((nbits >= 1300) ?  2 : (nbits >=  850) ?  3 :
   2543                            (nbits >=  650) ?  4 : (nbits >=  350) ?  8 :
   2544                            (nbits >=  250) ? 12 : (nbits >=  150) ? 18 : 27);
   2545              } else {
   2546                  /*
   2547                   * 2^-100 error probability, number of rounds computed based on HAC,
   2548                   * fact 4.48
   2549                   */
   2550                  rounds = ((nbits >= 1450) ?  4 : (nbits >=  1150) ?  5 :
   2551                            (nbits >= 1000) ?  6 : (nbits >=   850) ?  7 :
   2552                            (nbits >=  750) ?  8 : (nbits >=   500) ? 13 :
   2553                            (nbits >=  250) ? 28 : (nbits >=   150) ? 40 : 51);
   2554              }
   2555          
   2556              while (1) {
   2557                  MBEDTLS_MPI_CHK(mbedtls_mpi_fill_random(X, n * ciL, f_rng, p_rng));
   2558                  /* make sure generated number is at least (nbits-1)+0.5 bits (FIPS 186-4 §B.3.3 steps 4.4, 5.5) */
   2559                  if (X->p[n-1] < CEIL_MAXUINT_DIV_SQRT2) {
   2560                      continue;
   2561                  }
   2562          
   2563                  k = n * biL;
   2564                  if (k > nbits) {
   2565                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(X, k - nbits));
   2566                  }
   2567                  X->p[0] |= 1;
   2568          
   2569                  if ((flags & MBEDTLS_MPI_GEN_PRIME_FLAG_DH) == 0) {
   2570                      ret = mbedtls_mpi_is_prime_ext(X, rounds, f_rng, p_rng);
   2571          
   2572                      if (ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) {
   2573                          goto cleanup;
   2574                      }
   2575                  } else {
   2576                      /*
   2577                       * A necessary condition for Y and X = 2Y + 1 to be prime
   2578                       * is X = 2 mod 3 (which is equivalent to Y = 2 mod 3).
   2579                       * Make sure it is satisfied, while keeping X = 3 mod 4
   2580                       */
   2581          
   2582                      X->p[0] |= 2;
   2583          
   2584                      MBEDTLS_MPI_CHK(mbedtls_mpi_mod_int(&r, X, 3));
   2585                      if (r == 0) {
   2586                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(X, X, 8));
   2587                      } else if (r == 1) {
   2588                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(X, X, 4));
   2589                      }
   2590          
   2591                      /* Set Y = (X-1) / 2, which is X / 2 because X is odd */
   2592                      MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Y, X));
   2593                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&Y, 1));
   2594          
   2595                      while (1) {
   2596                          /*
   2597                           * First, check small factors for X and Y
   2598                           * before doing Miller-Rabin on any of them
   2599                           */
   2600                          if ((ret = mpi_check_small_factors(X)) == 0 &&
   2601                              (ret = mpi_check_small_factors(&Y)) == 0 &&
   2602                              (ret = mpi_miller_rabin(X, rounds, f_rng, p_rng))
   2603                              == 0 &&
   2604                              (ret = mpi_miller_rabin(&Y, rounds, f_rng, p_rng))
   2605                              == 0) {
   2606                              goto cleanup;
   2607                          }
   2608          
   2609                          if (ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) {
   2610                              goto cleanup;
   2611                          }
   2612          
   2613                          /*
   2614                           * Next candidates. We want to preserve Y = (X-1) / 2 and
   2615                           * Y = 1 mod 2 and Y = 2 mod 3 (eq X = 3 mod 4 and X = 2 mod 3)
   2616                           * so up Y by 6 and X by 12.
   2617                           */
   2618                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(X,  X, 12));
   2619                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&Y, &Y, 6));
   2620                      }
   2621                  }
   2622              }
   2623          
   2624          cleanup:
   2625          
   2626              mbedtls_mpi_free(&Y);
   2627          
   2628              return ret;
   2629          }
   2630          
   2631          #endif /* MBEDTLS_GENPRIME */
   2632          
   2633          #if defined(MBEDTLS_SELF_TEST)
   2634          
   2635          #define GCD_PAIR_COUNT  3
   2636          
   2637          static const int gcd_pairs[GCD_PAIR_COUNT][3] =
   2638          {
   2639              { 693, 609, 21 },
   2640              { 1764, 868, 28 },
   2641              { 768454923, 542167814, 1 }
   2642          };
   2643          
   2644          /*
   2645           * Checkup routine
   2646           */
   2647          int mbedtls_mpi_self_test(int verbose)
   2648          {
   2649              int ret, i;
   2650              mbedtls_mpi A, E, N, X, Y, U, V;
   2651          
   2652              mbedtls_mpi_init(&A); mbedtls_mpi_init(&E); mbedtls_mpi_init(&N); mbedtls_mpi_init(&X);
   2653              mbedtls_mpi_init(&Y); mbedtls_mpi_init(&U); mbedtls_mpi_init(&V);
   2654          
   2655              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&A, 16,
   2656                                                      "EFE021C2645FD1DC586E69184AF4A31E" \
   2657                                                      "D5F53E93B5F123FA41680867BA110131" \
   2658                                                      "944FE7952E2517337780CB0DB80E61AA" \
   2659                                                      "E7C8DDC6C5C6AADEB34EB38A2F40D5E6"));
   2660          
   2661              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&E, 16,
   2662                                                      "B2E7EFD37075B9F03FF989C7C5051C20" \
   2663                                                      "34D2A323810251127E7BF8625A4F49A5" \
   2664                                                      "F3E27F4DA8BD59C47D6DAABA4C8127BD" \
   2665                                                      "5B5C25763222FEFCCFC38B832366C29E"));
   2666          
   2667              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&N, 16,
   2668                                                      "0066A198186C18C10B2F5ED9B522752A" \
   2669                                                      "9830B69916E535C8F047518A889A43A5" \
   2670                                                      "94B6BED27A168D31D4A52F88925AA8F5"));
   2671          
   2672              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&X, &A, &N));
   2673          
   2674              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&U, 16,
   2675                                                      "602AB7ECA597A3D6B56FF9829A5E8B85" \
   2676                                                      "9E857EA95A03512E2BAE7391688D264A" \
   2677                                                      "A5663B0341DB9CCFD2C4C5F421FEC814" \
   2678                                                      "8001B72E848A38CAE1C65F78E56ABDEF" \
   2679                                                      "E12D3C039B8A02D6BE593F0BBBDA56F1" \
   2680                                                      "ECF677152EF804370C1A305CAF3B5BF1" \
   2681                                                      "30879B56C61DE584A0F53A2447A51E"));
   2682          
   2683              if (verbose != 0) {
   2684                  mbedtls_printf("  MPI test #1 (mul_mpi): ");
   2685              }
   2686          
   2687              if (mbedtls_mpi_cmp_mpi(&X, &U) != 0) {
   2688                  if (verbose != 0) {
   2689                      mbedtls_printf("failed\n");
   2690                  }
   2691          
   2692                  ret = 1;
   2693                  goto cleanup;
   2694              }
   2695          
   2696              if (verbose != 0) {
   2697                  mbedtls_printf("passed\n");
   2698              }
   2699          
   2700              MBEDTLS_MPI_CHK(mbedtls_mpi_div_mpi(&X, &Y, &A, &N));
   2701          
   2702              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&U, 16,
   2703                                                      "256567336059E52CAE22925474705F39A94"));
   2704          
   2705              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&V, 16,
   2706                                                      "6613F26162223DF488E9CD48CC132C7A" \
   2707                                                      "0AC93C701B001B092E4E5B9F73BCD27B" \
   2708                                                      "9EE50D0657C77F374E903CDFA4C642"));
   2709          
   2710              if (verbose != 0) {
   2711                  mbedtls_printf("  MPI test #2 (div_mpi): ");
   2712              }
   2713          
   2714              if (mbedtls_mpi_cmp_mpi(&X, &U) != 0 ||
   2715                  mbedtls_mpi_cmp_mpi(&Y, &V) != 0) {
   2716                  if (verbose != 0) {
   2717                      mbedtls_printf("failed\n");
   2718                  }
   2719          
   2720                  ret = 1;
   2721                  goto cleanup;
   2722              }
   2723          
   2724              if (verbose != 0) {
   2725                  mbedtls_printf("passed\n");
   2726              }
   2727          
   2728              MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(&X, &A, &E, &N, NULL));
   2729          
   2730              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&U, 16,
   2731                                                      "36E139AEA55215609D2816998ED020BB" \
   2732                                                      "BD96C37890F65171D948E9BC7CBAA4D9" \
   2733                                                      "325D24D6A3C12710F10A09FA08AB87"));
   2734          
   2735              if (verbose != 0) {
   2736                  mbedtls_printf("  MPI test #3 (exp_mod): ");
   2737              }
   2738          
   2739              if (mbedtls_mpi_cmp_mpi(&X, &U) != 0) {
   2740                  if (verbose != 0) {
   2741                      mbedtls_printf("failed\n");
   2742                  }
   2743          
   2744                  ret = 1;
   2745                  goto cleanup;
   2746              }
   2747          
   2748              if (verbose != 0) {
   2749                  mbedtls_printf("passed\n");
   2750              }
   2751          
   2752              MBEDTLS_MPI_CHK(mbedtls_mpi_inv_mod(&X, &A, &N));
   2753          
   2754              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&U, 16,
   2755                                                      "003A0AAEDD7E784FC07D8F9EC6E3BFD5" \
   2756                                                      "C3DBA76456363A10869622EAC2DD84EC" \
   2757                                                      "C5B8A74DAC4D09E03B5E0BE779F2DF61"));
   2758          
   2759              if (verbose != 0) {
   2760                  mbedtls_printf("  MPI test #4 (inv_mod): ");
   2761              }
   2762          
   2763              if (mbedtls_mpi_cmp_mpi(&X, &U) != 0) {
   2764                  if (verbose != 0) {
   2765                      mbedtls_printf("failed\n");
   2766                  }
   2767          
   2768                  ret = 1;
   2769                  goto cleanup;
   2770              }
   2771          
   2772              if (verbose != 0) {
   2773                  mbedtls_printf("passed\n");
   2774              }
   2775          
   2776              if (verbose != 0) {
   2777                  mbedtls_printf("  MPI test #5 (simple gcd): ");
   2778              }
   2779          
   2780              for (i = 0; i < GCD_PAIR_COUNT; i++) {
   2781                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&X, gcd_pairs[i][0]));
   2782                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&Y, gcd_pairs[i][1]));
   2783          
   2784                  MBEDTLS_MPI_CHK(mbedtls_mpi_gcd(&A, &X, &Y));
   2785          
   2786                  if (mbedtls_mpi_cmp_int(&A, gcd_pairs[i][2]) != 0) {
   2787                      if (verbose != 0) {
   2788                          mbedtls_printf("failed at %d\n", i);
   2789                      }
   2790          
   2791                      ret = 1;
   2792                      goto cleanup;
   2793                  }
   2794              }
   2795          
   2796              if (verbose != 0) {
   2797                  mbedtls_printf("passed\n");
   2798              }
   2799          
   2800          cleanup:
   2801          
   2802              if (ret != 0 && verbose != 0) {
   2803                  mbedtls_printf("Unexpected error, return code = %08X\n", (unsigned int) ret);
   2804              }
   2805          
   2806              mbedtls_mpi_free(&A); mbedtls_mpi_free(&E); mbedtls_mpi_free(&N); mbedtls_mpi_free(&X);
   2807              mbedtls_mpi_free(&Y); mbedtls_mpi_free(&U); mbedtls_mpi_free(&V);
   2808          
   2809              if (verbose != 0) {
   2810                  mbedtls_printf("\n");
   2811              }
   2812          
   2813              return ret;
   2814          }
   2815          
   2816          #endif /* MBEDTLS_SELF_TEST */
   2817          
   2818          #endif /* MBEDTLS_BIGNUM_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   add_sub_mpi
        32   -> mbedtls_mpi_add_abs
        32   -> mbedtls_mpi_cmp_abs
        32   -> mbedtls_mpi_sub_abs
       8   mbedtls_ct_bool
         8   -> mbedtls_ct_compiler_opaque
       0   mbedtls_ct_bool_and
       0   mbedtls_ct_bool_ne
       0   mbedtls_ct_bool_not
       0   mbedtls_ct_bool_or
       0   mbedtls_ct_compiler_opaque
      16   mbedtls_ct_if
        16   -> mbedtls_ct_compiler_opaque
       0   mbedtls_ct_mpi_uint_if_else_0
       0   mbedtls_ct_size_if_else_0
      16   mbedtls_ct_uint_eq
        16   -> mbedtls_ct_uint_ne
      16   mbedtls_ct_uint_if
        16   -> mbedtls_ct_if
       0   mbedtls_ct_uint_if_else_0
      24   mbedtls_ct_uint_ne
        24   -> mbedtls_ct_bool
        24   -> mbedtls_ct_compiler_opaque
      40   mbedtls_int_div_int
        40 __aeabi_uldivmod
      40   mbedtls_mpi_add_abs
        40   -> mbedtls_mpi_copy
        40   -> mbedtls_mpi_core_add
        40   -> mbedtls_mpi_grow
      32   mbedtls_mpi_add_int
        32   -> mbedtls_mpi_add_mpi
        32   -> mpi_sint_abs
      16   mbedtls_mpi_add_mpi
        16   -> add_sub_mpi
       8   mbedtls_mpi_bitlen
         8   -> mbedtls_mpi_core_bitlen
       8   mbedtls_mpi_cmp_abs
      24   mbedtls_mpi_cmp_int
        24   -> mbedtls_mpi_cmp_mpi
        24   -> mpi_sint_abs
       8   mbedtls_mpi_cmp_mpi
      32   mbedtls_mpi_copy
        32   -> __aeabi_memcpy
        32   -> __aeabi_memset
        32   -> mbedtls_mpi_grow
      32   mbedtls_mpi_div_int
        32   -> mbedtls_mpi_div_mpi
        32   -> mpi_sint_abs
      96   mbedtls_mpi_div_mpi
        96   -> mbedtls_int_div_int
        96   -> mbedtls_mpi_add_mpi
        96   -> mbedtls_mpi_bitlen
        96   -> mbedtls_mpi_cmp_abs
        96   -> mbedtls_mpi_cmp_int
        96   -> mbedtls_mpi_cmp_mpi
        96   -> mbedtls_mpi_copy
        96   -> mbedtls_mpi_free
        96   -> mbedtls_mpi_grow
        96   -> mbedtls_mpi_init
        96   -> mbedtls_mpi_lset
        96   -> mbedtls_mpi_mul_int
        96   -> mbedtls_mpi_shift_l
        96   -> mbedtls_mpi_shift_r
        96   -> mbedtls_mpi_sub_mpi
        96   -> mbedtls_platform_zeroize
     152   mbedtls_mpi_exp_mod
       152   -> __aeabi_memcpy
       152   -> __aeabi_memset
       152   -> mbedtls_mpi_add_mpi
       152   -> mbedtls_mpi_bitlen
       152   -> mbedtls_mpi_cmp_int
       152   -> mbedtls_mpi_cmp_mpi
       152   -> mbedtls_mpi_copy
       152   -> mbedtls_mpi_free
       152   -> mbedtls_mpi_grow
       152   -> mbedtls_mpi_init
       152   -> mbedtls_mpi_lset
       152   -> mbedtls_mpi_mod_mpi
       152   -> mbedtls_mpi_shift_l
       152   -> mpi_montg_init
       152   -> mpi_montmul
       152   -> mpi_montred
       152   -> mpi_select
      40   mbedtls_mpi_fill_random
        40   -> mbedtls_mpi_core_fill_random
        40   -> mbedtls_mpi_resize_clear
       8   mbedtls_mpi_free
         8   -> mbedtls_zeroize_and_free
      48   mbedtls_mpi_gcd
        48   -> mbedtls_mpi_cmp_int
        48   -> mbedtls_mpi_cmp_mpi
        48   -> mbedtls_mpi_copy
        48   -> mbedtls_mpi_free
        48   -> mbedtls_mpi_get_bit
        48   -> mbedtls_mpi_init
        48   -> mbedtls_mpi_lsb
        48   -> mbedtls_mpi_shift_l
        48   -> mbedtls_mpi_shift_r
        48   -> mbedtls_mpi_sub_abs
       0   mbedtls_mpi_get_bit
      32   mbedtls_mpi_grow
        32   -> __aeabi_memcpy
        32   -> mbedtls_zeroize_and_free
        32   -> sl_calloc
       0   mbedtls_mpi_init
      96   mbedtls_mpi_inv_mod
        96   -> mbedtls_mpi_add_mpi
        96   -> mbedtls_mpi_cmp_int
        96   -> mbedtls_mpi_cmp_mpi
        96   -> mbedtls_mpi_copy
        96   -> mbedtls_mpi_free
        96   -> mbedtls_mpi_gcd
        96   -> mbedtls_mpi_init
        96   -> mbedtls_mpi_lset
        96   -> mbedtls_mpi_mod_mpi
        96   -> mbedtls_mpi_shift_r
        96   -> mbedtls_mpi_sub_mpi
       0   mbedtls_mpi_lsb
      32   mbedtls_mpi_lset
        32   -> __aeabi_memset
        32   -> mbedtls_mpi_grow
        32   -> mpi_sint_abs
      56   mbedtls_mpi_lt_mpi_ct
        56   -> mbedtls_ct_bool
        56   -> mbedtls_ct_bool_and
        56   -> mbedtls_ct_bool_ne
        56   -> mbedtls_ct_bool_not
        56   -> mbedtls_ct_bool_or
        56   -> mbedtls_ct_size_if_else_0
        56   -> mbedtls_ct_uint_if_else_0
        56   -> mbedtls_mpi_core_lt_ct
      20   mbedtls_mpi_mod_int
      24   mbedtls_mpi_mod_mpi
        24   -> mbedtls_mpi_add_mpi
        24   -> mbedtls_mpi_cmp_int
        24   -> mbedtls_mpi_cmp_mpi
        24   -> mbedtls_mpi_div_mpi
        24   -> mbedtls_mpi_sub_mpi
      32   mbedtls_mpi_mul_int
        32   -> mbedtls_mpi_copy
        32   -> mbedtls_mpi_core_mla
        32   -> mbedtls_mpi_grow
        32   -> mbedtls_mpi_lset
      56   mbedtls_mpi_mul_mpi
        56   -> mbedtls_mpi_copy
        56   -> mbedtls_mpi_core_mul
        56   -> mbedtls_mpi_free
        56   -> mbedtls_mpi_grow
        56   -> mbedtls_mpi_init
        56   -> mbedtls_mpi_lset
      32   mbedtls_mpi_random
        32   -> mbedtls_mpi_cmp_int
        32   -> mbedtls_mpi_core_random
        32   -> mbedtls_mpi_resize_clear
      32   mbedtls_mpi_read_binary
        32   -> mbedtls_mpi_core_read_be
        32   -> mbedtls_mpi_resize_clear
      32   mbedtls_mpi_read_binary_le
        32   -> mbedtls_mpi_core_read_le
        32   -> mbedtls_mpi_resize_clear
      56   mbedtls_mpi_read_string
        56   -> mbedtls_mpi_add_int
        56   -> mbedtls_mpi_bitlen
        56   -> mbedtls_mpi_free
        56   -> mbedtls_mpi_grow
        56   -> mbedtls_mpi_init
        56   -> mbedtls_mpi_lset
        56   -> mbedtls_mpi_mul_int
        56   -> mpi_get_digit
        56   -> strlen
      24   mbedtls_mpi_resize_clear
        24   -> __aeabi_memset
        24   -> mbedtls_mpi_free
        24   -> mbedtls_mpi_grow
      32   mbedtls_mpi_safe_cond_assign
        32   -> mbedtls_ct_bool
        32   -> mbedtls_ct_bool_not
        32   -> mbedtls_ct_mpi_uint_if_else_0
        32   -> mbedtls_ct_uint_if
        32   -> mbedtls_mpi_core_cond_assign
        32   -> mbedtls_mpi_grow
      32   mbedtls_mpi_safe_cond_swap
        32   -> mbedtls_ct_bool
        32   -> mbedtls_ct_uint_if
        32   -> mbedtls_mpi_core_cond_swap
        32   -> mbedtls_mpi_grow
      32   mbedtls_mpi_set_bit
        32   -> mbedtls_mpi_grow
      24   mbedtls_mpi_shift_l
        24   -> mbedtls_mpi_bitlen
        24   -> mbedtls_mpi_core_shift_l
        24   -> mbedtls_mpi_grow
      16   mbedtls_mpi_shift_r
        16   -> mbedtls_mpi_core_shift_r
      32   mbedtls_mpi_shrink
        32   -> __aeabi_memcpy
        32   -> mbedtls_mpi_grow
        32   -> mbedtls_zeroize_and_free
        32   -> sl_calloc
       8   mbedtls_mpi_size
         8   -> mbedtls_mpi_bitlen
      40   mbedtls_mpi_sub_abs
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> mbedtls_mpi_core_sub
        40   -> mbedtls_mpi_core_sub_int
        40   -> mbedtls_mpi_grow
      32   mbedtls_mpi_sub_int
        32   -> mbedtls_mpi_sub_mpi
        32   -> mpi_sint_abs
      16   mbedtls_mpi_sub_mpi
        16   -> add_sub_mpi
      48   mbedtls_mpi_swap
        48   -> __aeabi_memcpy
      16   mbedtls_mpi_write_binary
        16   -> mbedtls_mpi_core_write_be
      16   mbedtls_mpi_write_binary_le
        16   -> mbedtls_mpi_core_write_le
      48   mbedtls_mpi_write_string
        48   -> mbedtls_mpi_bitlen
        48   -> mbedtls_mpi_copy
        48   -> mbedtls_mpi_free
        48   -> mbedtls_mpi_init
        48   -> mpi_write_hlp
       0   mpi_get_digit
      16   mpi_montg_init
        16   -> mbedtls_mpi_core_montmul_init
      40   mpi_montmul
        40   -> mbedtls_mpi_core_montmul
      40   mpi_montred
        40   -> mpi_montmul
      32   mpi_select
        32   -> mbedtls_ct_uint_eq
        32   -> mbedtls_mpi_safe_cond_assign
       0   mpi_sint_abs
      48   mpi_write_hlp
        48   -> __aeabi_memmove
        48   -> mbedtls_mpi_cmp_int
        48   -> mbedtls_mpi_div_int
        48   -> mbedtls_mpi_mod_int


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      20  ?_0
     134  add_sub_mpi
      28  mbedtls_ct_bool
       4  mbedtls_ct_bool_and
       4  mbedtls_ct_bool_ne
       4  mbedtls_ct_bool_not
       4  mbedtls_ct_bool_or
      10  mbedtls_ct_compiler_opaque
      26  mbedtls_ct_if
       4  mbedtls_ct_mpi_uint_if_else_0
       4  mbedtls_ct_size_if_else_0
      18  mbedtls_ct_uint_eq
      20  mbedtls_ct_uint_if
       4  mbedtls_ct_uint_if_else_0
      32  mbedtls_ct_uint_ne
     128  mbedtls_int_div_int
     196  mbedtls_mpi_add_abs
      56  mbedtls_mpi_add_int
      22  mbedtls_mpi_add_mpi
      14  mbedtls_mpi_bitlen
     144  mbedtls_mpi_cmp_abs
      50  mbedtls_mpi_cmp_int
     206  mbedtls_mpi_cmp_mpi
     168  mbedtls_mpi_copy
      58  mbedtls_mpi_div_int
     956  mbedtls_mpi_div_mpi
   1'302  mbedtls_mpi_exp_mod
      84  mbedtls_mpi_fill_random
      38  mbedtls_mpi_free
     294  mbedtls_mpi_gcd
      36  mbedtls_mpi_get_bit
      94  mbedtls_mpi_grow
      14  mbedtls_mpi_init
     728  mbedtls_mpi_inv_mod
      48  mbedtls_mpi_lsb
      78  mbedtls_mpi_lset
     164  mbedtls_mpi_lt_mpi_ct
     144  mbedtls_mpi_mod_int
     116  mbedtls_mpi_mod_mpi
     106  mbedtls_mpi_mul_int
     238  mbedtls_mpi_mul_mpi
      82  mbedtls_mpi_random
      72  mbedtls_mpi_read_binary
      72  mbedtls_mpi_read_binary_le
     342  mbedtls_mpi_read_string
      72  mbedtls_mpi_resize_clear
     114  mbedtls_mpi_safe_cond_assign
     114  mbedtls_mpi_safe_cond_swap
     128  mbedtls_mpi_set_bit
      78  mbedtls_mpi_shift_l
      26  mbedtls_mpi_shift_r
     134  mbedtls_mpi_shrink
      16  mbedtls_mpi_size
     212  mbedtls_mpi_sub_abs
      56  mbedtls_mpi_sub_int
      24  mbedtls_mpi_sub_mpi
      66  mbedtls_mpi_swap
      22  mbedtls_mpi_write_binary
      22  mbedtls_mpi_write_binary_le
     346  mbedtls_mpi_write_string
      94  mpi_get_digit
      16  mpi_montg_init
      48  mpi_montmul
      50  mpi_montred
      64  mpi_select
       8  mpi_sint_abs
     152  mpi_write_hlp

 
    20 bytes in section .rodata
 8'216 bytes in section .text
 
 8'216 bytes of CODE  memory
    20 bytes of CONST memory

Errors: none
Warnings: none
