###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:56
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_client.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ssl_client.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_client.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ssl_client.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\library_17211336700577820660.dir\ssl_client.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\library_17211336700577820660.dir\ssl_client.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_client.c
      1          /*
      2           *  TLS 1.2 and 1.3 client-side functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of Mbed TLS ( https://tls.mbed.org )
     20           */
     21          
     22          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x2402             MOVS     R4,#+2
   \        0x6   0x466D             MOV      R5,SP
   \        0x8   0x003E             MOVS     R6,R7
   \        0xA   0x0022             MOVS     R2,R4
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy
   \       0x14   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t mbedtls_bswap16(uint16_t)
   \                     mbedtls_bswap16: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x0A00             LSRS     R0,R0,#+8
   \        0x8   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x4770             BX       LR

   \                                 In section .rodata, align 2
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     23          
     24          #if defined(MBEDTLS_SSL_CLI_C)
     25          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
     26          
     27          #include <string.h>
     28          
     29          #include "mbedtls/debug.h"
     30          #include "mbedtls/error.h"
     31          #include "mbedtls/platform.h"
     32          
     33          #include "ssl_client.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_chk_buf_ptr(uint8_t const *, uint8_t const *, size_t)
   \                     mbedtls_ssl_chk_buf_ptr: (+1)
   \        0x0   0x4281             CMP      R1,R0
   \        0x2   0xD302             BCC.N    ??mbedtls_ssl_chk_buf_ptr_0
   \        0x4   0x1A08             SUBS     R0,R1,R0
   \        0x6   0x4290             CMP      R0,R2
   \        0x8   0xD201             BCS.N    ??mbedtls_ssl_chk_buf_ptr_1
   \                     ??mbedtls_ssl_chk_buf_ptr_0: (+1)
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??mbedtls_ssl_chk_buf_ptr_2
   \                     ??mbedtls_ssl_chk_buf_ptr_1: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_chk_buf_ptr_2: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void mbedtls_ssl_handshake_set_state(mbedtls_ssl_context *, mbedtls_ssl_states)
   \                     mbedtls_ssl_handshake_set_state: (+1)
   \        0x0   0x000A             MOVS     R2,R1
   \        0x2   0xB2D2             UXTB     R2,R2
   \        0x4   0x6042             STR      R2,[R0, #+4]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void const *mbedtls_ssl_get_groups(mbedtls_ssl_context const *)
   \                     mbedtls_ssl_get_groups: (+1)
   \        0x0   0x6B81             LDR      R1,[R0, #+56]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD006             BEQ.N    ??mbedtls_ssl_get_groups_0
   \        0x6   0x6B81             LDR      R1,[R0, #+56]
   \        0x8   0x6C49             LDR      R1,[R1, #+68]
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD002             BEQ.N    ??mbedtls_ssl_get_groups_0
   \        0xE   0x6B80             LDR      R0,[R0, #+56]
   \       0x10   0x6C40             LDR      R0,[R0, #+68]
   \       0x12   0xE001             B.N      ??mbedtls_ssl_get_groups_1
   \                     ??mbedtls_ssl_get_groups_0: (+1)
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x6D00             LDR      R0,[R0, #+80]
   \                     ??mbedtls_ssl_get_groups_1: (+1)
   \       0x18   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_tls12_named_group_is_ecdhe(uint16_t)
   \                     mbedtls_ssl_tls12_named_group_is_ecdhe: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB289             UXTH     R1,R1
   \        0x4   0x291D             CMP      R1,#+29
   \        0x6   0xD02E             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \        0x8   0x0001             MOVS     R1,R0
   \        0xA   0xB289             UXTH     R1,R1
   \        0xC   0x291A             CMP      R1,#+26
   \        0xE   0xD02A             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x10   0x0001             MOVS     R1,R0
   \       0x12   0xB289             UXTH     R1,R1
   \       0x14   0x291B             CMP      R1,#+27
   \       0x16   0xD026             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x18   0x0001             MOVS     R1,R0
   \       0x1A   0xB289             UXTH     R1,R1
   \       0x1C   0x291C             CMP      R1,#+28
   \       0x1E   0xD022             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x20   0x0001             MOVS     R1,R0
   \       0x22   0xB289             UXTH     R1,R1
   \       0x24   0x291E             CMP      R1,#+30
   \       0x26   0xD01E             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x28   0x0001             MOVS     R1,R0
   \       0x2A   0xB289             UXTH     R1,R1
   \       0x2C   0x2912             CMP      R1,#+18
   \       0x2E   0xD01A             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x30   0x0001             MOVS     R1,R0
   \       0x32   0xB289             UXTH     R1,R1
   \       0x34   0x2913             CMP      R1,#+19
   \       0x36   0xD016             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x38   0x0001             MOVS     R1,R0
   \       0x3A   0xB289             UXTH     R1,R1
   \       0x3C   0x2914             CMP      R1,#+20
   \       0x3E   0xD012             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x40   0x0001             MOVS     R1,R0
   \       0x42   0xB289             UXTH     R1,R1
   \       0x44   0x2915             CMP      R1,#+21
   \       0x46   0xD00E             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x48   0x0001             MOVS     R1,R0
   \       0x4A   0xB289             UXTH     R1,R1
   \       0x4C   0x2916             CMP      R1,#+22
   \       0x4E   0xD00A             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x50   0x0001             MOVS     R1,R0
   \       0x52   0xB289             UXTH     R1,R1
   \       0x54   0x2917             CMP      R1,#+23
   \       0x56   0xD006             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x58   0x0001             MOVS     R1,R0
   \       0x5A   0xB289             UXTH     R1,R1
   \       0x5C   0x2918             CMP      R1,#+24
   \       0x5E   0xD002             BEQ.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_0
   \       0x60   0xB280             UXTH     R0,R0
   \       0x62   0x2819             CMP      R0,#+25
   \       0x64   0xD101             BNE.N    ??mbedtls_ssl_tls12_named_group_is_ecdhe_1
   \                     ??mbedtls_ssl_tls12_named_group_is_ecdhe_0: (+1)
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0xE000             B.N      ??mbedtls_ssl_tls12_named_group_is_ecdhe_2
   \                     ??mbedtls_ssl_tls12_named_group_is_ecdhe_1: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_tls12_named_group_is_ecdhe_2: (+1)
   \       0x6C   0xB2C0             UXTB     R0,R0
   \       0x6E   0x4770             BX       LR

      return 0;
      ^
"D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\ssl_misc.h",2433  Warning[Pe111]: 
          statement is unreachable
     34          #include "ssl_misc.h"
     35          #include "ssl_tls13_keys.h"
     36          #include "ssl_debug_helpers.h"
     37          
     38          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
     39          MBEDTLS_CHECK_RETURN_CRITICAL
     40          static int ssl_write_hostname_ext(mbedtls_ssl_context *ssl,
     41                                            unsigned char *buf,
     42                                            const unsigned char *end,
     43                                            size_t *olen)
     44          {
     45              unsigned char *p = buf;
     46              size_t hostname_len;
     47          
     48              *olen = 0;
     49          
     50              if (ssl->hostname == NULL) {
     51                  return 0;
     52              }
     53          
     54              MBEDTLS_SSL_DEBUG_MSG(3,
     55                                    ("client hello, adding server name extension: %s",
     56                                     ssl->hostname));
     57          
     58              hostname_len = strlen(ssl->hostname);
     59          
     60              MBEDTLS_SSL_CHK_BUF_PTR(p, end, hostname_len + 9);
     61          
     62              /*
     63               * Sect. 3, RFC 6066 (TLS Extensions Definitions)
     64               *
     65               * In order to provide any of the server names, clients MAY include an
     66               * extension of type "server_name" in the (extended) client hello. The
     67               * "extension_data" field of this extension SHALL contain
     68               * "ServerNameList" where:
     69               *
     70               * struct {
     71               *     NameType name_type;
     72               *     select (name_type) {
     73               *         case host_name: HostName;
     74               *     } name;
     75               * } ServerName;
     76               *
     77               * enum {
     78               *     host_name(0), (255)
     79               * } NameType;
     80               *
     81               * opaque HostName<1..2^16-1>;
     82               *
     83               * struct {
     84               *     ServerName server_name_list<1..2^16-1>
     85               * } ServerNameList;
     86               *
     87               */
     88              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_SERVERNAME, p, 0);
     89              p += 2;
     90          
     91              MBEDTLS_PUT_UINT16_BE(hostname_len + 5, p, 0);
     92              p += 2;
     93          
     94              MBEDTLS_PUT_UINT16_BE(hostname_len + 3, p, 0);
     95              p += 2;
     96          
     97              *p++ = MBEDTLS_BYTE_0(MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME);
     98          
     99              MBEDTLS_PUT_UINT16_BE(hostname_len, p, 0);
    100              p += 2;
    101          
    102              memcpy(p, ssl->hostname, hostname_len);
    103          
    104              *olen = hostname_len + 9;
    105          
    106          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    107              mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_SERVERNAME);
    108          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
    109              return 0;
    110          }
    111          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
    112          
    113          #if defined(MBEDTLS_SSL_ALPN)
    114          /*
    115           * ssl_write_alpn_ext()
    116           *
    117           * Structure of the application_layer_protocol_negotiation extension in
    118           * ClientHello:
    119           *
    120           * opaque ProtocolName<1..2^8-1>;
    121           *
    122           * struct {
    123           *     ProtocolName protocol_name_list<2..2^16-1>
    124           * } ProtocolNameList;
    125           *
    126           */
    127          MBEDTLS_CHECK_RETURN_CRITICAL
    128          static int ssl_write_alpn_ext(mbedtls_ssl_context *ssl,
    129                                        unsigned char *buf,
    130                                        const unsigned char *end,
    131                                        size_t *out_len)
    132          {
    133              unsigned char *p = buf;
    134          
    135              *out_len = 0;
    136          
    137              if (ssl->conf->alpn_list == NULL) {
    138                  return 0;
    139              }
    140          
    141              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, adding alpn extension"));
    142          
    143          
    144              /* Check we have enough space for the extension type (2 bytes), the
    145               * extension length (2 bytes) and the protocol_name_list length (2 bytes).
    146               */
    147              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 6);
    148              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_ALPN, p, 0);
    149              /* Skip writing extension and list length for now */
    150              p += 6;
    151          
    152              /*
    153               * opaque ProtocolName<1..2^8-1>;
    154               *
    155               * struct {
    156               *     ProtocolName protocol_name_list<2..2^16-1>
    157               * } ProtocolNameList;
    158               */
    159              for (const char **cur = ssl->conf->alpn_list; *cur != NULL; cur++) {
    160                  /*
    161                   * mbedtls_ssl_conf_set_alpn_protocols() checked that the length of
    162                   * protocol names is less than 255.
    163                   */
    164                  size_t protocol_name_len = strlen(*cur);
    165          
    166                  MBEDTLS_SSL_CHK_BUF_PTR(p, end, 1 + protocol_name_len);
    167                  *p++ = (unsigned char) protocol_name_len;
    168                  memcpy(p, *cur, protocol_name_len);
    169                  p += protocol_name_len;
    170              }
    171          
    172              *out_len = p - buf;
    173          
    174              /* List length = *out_len - 2 (ext_type) - 2 (ext_len) - 2 (list_len) */
    175              MBEDTLS_PUT_UINT16_BE(*out_len - 6, buf, 4);
    176          
    177              /* Extension length = *out_len - 2 (ext_type) - 2 (ext_len) */
    178              MBEDTLS_PUT_UINT16_BE(*out_len - 4, buf, 2);
    179          
    180          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    181              mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_ALPN);
    182          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
    183              return 0;
    184          }
    185          #endif /* MBEDTLS_SSL_ALPN */
    186          
    187          #if defined(MBEDTLS_SSL_TLS1_2_SOME_ECC) || \
    188              defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_EPHEMERAL_ENABLED)
    189          /*
    190           * Function for writing a supported groups (TLS 1.3) or supported elliptic
    191           * curves (TLS 1.2) extension.
    192           *
    193           * The "extension_data" field of a supported groups extension contains a
    194           * "NamedGroupList" value (TLS 1.3 RFC8446):
    195           *      enum {
    196           *          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
    197           *          x25519(0x001D), x448(0x001E),
    198           *          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
    199           *          ffdhe6144(0x0103), ffdhe8192(0x0104),
    200           *          ffdhe_private_use(0x01FC..0x01FF),
    201           *          ecdhe_private_use(0xFE00..0xFEFF),
    202           *          (0xFFFF)
    203           *      } NamedGroup;
    204           *      struct {
    205           *          NamedGroup named_group_list<2..2^16-1>;
    206           *      } NamedGroupList;
    207           *
    208           * The "extension_data" field of a supported elliptic curves extension contains
    209           * a "NamedCurveList" value (TLS 1.2 RFC 8422):
    210           * enum {
    211           *      deprecated(1..22),
    212           *      secp256r1 (23), secp384r1 (24), secp521r1 (25),
    213           *      x25519(29), x448(30),
    214           *      reserved (0xFE00..0xFEFF),
    215           *      deprecated(0xFF01..0xFF02),
    216           *      (0xFFFF)
    217           *  } NamedCurve;
    218           * struct {
    219           *      NamedCurve named_curve_list<2..2^16-1>
    220           *  } NamedCurveList;
    221           *
    222           * The TLS 1.3 supported groups extension was defined to be a compatible
    223           * generalization of the TLS 1.2 supported elliptic curves extension. They both
    224           * share the same extension identifier.
    225           *
    226           */
    227          #define SSL_WRITE_SUPPORTED_GROUPS_EXT_TLS1_2_FLAG 1
    228          #define SSL_WRITE_SUPPORTED_GROUPS_EXT_TLS1_3_FLAG 2
    229          
    230          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    231          static int ssl_write_supported_groups_ext(mbedtls_ssl_context *ssl,
    232                                                    unsigned char *buf,
    233                                                    const unsigned char *end,
    234                                                    int flags,
    235                                                    size_t *out_len)
    236          {
   \                     ssl_write_supported_groups_ext: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0xF8DD 0x9030      LDR      R9,[SP, #+48]
    237              unsigned char *p = buf;
   \       0x10   0x0034             MOVS     R4,R6
    238              unsigned char *named_group_list; /* Start of named_group_list */
    239              size_t named_group_list_len;     /* Length of named_group_list */
    240              const uint16_t *group_list = mbedtls_ssl_get_groups(ssl);
   \       0x12   0x4658             MOV      R0,R11
   \       0x14   0x.... 0x....      BL       mbedtls_ssl_get_groups
   \       0x18   0x0005             MOVS     R5,R0
    241          
    242              *out_len = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xF8C9 0x0000      STR      R0,[R9, #+0]
    243          
    244              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, adding supported_groups extension"));
    245          
    246              /* Check if we have space for header and length fields:
    247               * - extension_type            (2 bytes)
    248               * - extension_data_length     (2 bytes)
    249               * - named_group_list_length   (2 bytes)
    250               */
    251              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 6);
   \       0x20   0x2206             MOVS     R2,#+6
   \       0x22   0x0039             MOVS     R1,R7
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD002             BEQ.N    ??ssl_write_supported_groups_ext_0
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x32   0xE084             B.N      ??ssl_write_supported_groups_ext_1
    252              p += 6;
   \                     ??ssl_write_supported_groups_ext_0: (+1)
   \       0x34   0xF114 0x0A06      ADDS     R10,R4,#+6
    253          
    254              named_group_list = p;
   \       0x38   0xF8CD 0xA004      STR      R10,[SP, #+4]
    255          
    256              if (group_list == NULL) {
   \       0x3C   0x2D00             CMP      R5,#+0
   \       0x3E   0xD102             BNE.N    ??ssl_write_supported_groups_ext_2
    257                  return MBEDTLS_ERR_SSL_BAD_CONFIG;
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \       0x44   0xE07B             B.N      ??ssl_write_supported_groups_ext_1
    258              }
    259          
    260              for (; *group_list != 0; group_list++) {
   \                     ??ssl_write_supported_groups_ext_2: (+1)
   \       0x46   0x8828             LDRH     R0,[R5, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD031             BEQ.N    ??ssl_write_supported_groups_ext_3
    261                  int propose_group = 0;
   \       0x4C   0x2400             MOVS     R4,#+0
    262          
    263                  MBEDTLS_SSL_DEBUG_MSG(3, ("got supported group(%04x)", *group_list));
    264          
    265          #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_EPHEMERAL_ENABLED)
    266                  if (flags & SSL_WRITE_SUPPORTED_GROUPS_EXT_TLS1_3_FLAG) {
    267          #if defined(PSA_WANT_ALG_ECDH)
    268                      if (mbedtls_ssl_tls13_named_group_is_ecdhe(*group_list) &&
    269                          (mbedtls_ssl_get_ecp_group_id_from_tls_id(*group_list) !=
    270                           MBEDTLS_ECP_DP_NONE)) {
    271                          propose_group = 1;
    272                      }
    273          #endif
    274          #if defined(PSA_WANT_ALG_FFDH)
    275                      if (mbedtls_ssl_tls13_named_group_is_ffdh(*group_list)) {
    276                          propose_group = 1;
    277                      }
    278          #endif
    279                  }
    280          #endif /* MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_EPHEMERAL_ENABLED */
    281          
    282          #if defined(MBEDTLS_SSL_TLS1_2_SOME_ECC)
    283                  if ((flags & SSL_WRITE_SUPPORTED_GROUPS_EXT_TLS1_2_FLAG) &&
    284                      mbedtls_ssl_tls12_named_group_is_ecdhe(*group_list) &&
    285                      (mbedtls_ssl_get_ecp_group_id_from_tls_id(*group_list) !=
    286                       MBEDTLS_ECP_DP_NONE)) {
   \       0x4E   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \       0x52   0xD50B             BPL.N    ??ssl_write_supported_groups_ext_4
   \       0x54   0x8828             LDRH     R0,[R5, #+0]
   \       0x56   0x.... 0x....      BL       mbedtls_ssl_tls12_named_group_is_ecdhe
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD006             BEQ.N    ??ssl_write_supported_groups_ext_4
   \       0x5E   0x8828             LDRH     R0,[R5, #+0]
   \       0x60   0x.... 0x....      BL       mbedtls_ssl_get_ecp_group_id_from_tls_id
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD001             BEQ.N    ??ssl_write_supported_groups_ext_4
    287                      propose_group = 1;
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0x0004             MOVS     R4,R0
    288                  }
    289          #endif /* MBEDTLS_SSL_TLS1_2_SOME_ECC */
    290          
    291                  if (propose_group) {
   \                     ??ssl_write_supported_groups_ext_4: (+1)
   \       0x6C   0x2C00             CMP      R4,#+0
   \       0x6E   0xD01D             BEQ.N    ??ssl_write_supported_groups_ext_5
    292                      MBEDTLS_SSL_CHK_BUF_PTR(p, end, 2);
   \       0x70   0x2202             MOVS     R2,#+2
   \       0x72   0x0039             MOVS     R1,R7
   \       0x74   0x4650             MOV      R0,R10
   \       0x76   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD002             BEQ.N    ??ssl_write_supported_groups_ext_6
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x82   0xE05C             B.N      ??ssl_write_supported_groups_ext_1
    293                      MBEDTLS_PUT_UINT16_BE(*group_list, p, 0);
   \                     ??ssl_write_supported_groups_ext_6: (+1)
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \       0x88   0x7800             LDRB     R0,[R0, #+0]
   \       0x8A   0x2801             CMP      R0,#+1
   \       0x8C   0xD104             BNE.N    ??ssl_write_supported_groups_ext_7
   \       0x8E   0x8829             LDRH     R1,[R5, #+0]
   \       0x90   0x4650             MOV      R0,R10
   \       0x92   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x96   0xE007             B.N      ??ssl_write_supported_groups_ext_8
   \                     ??ssl_write_supported_groups_ext_7: (+1)
   \       0x98   0x8828             LDRH     R0,[R5, #+0]
   \       0x9A   0x.... 0x....      BL       mbedtls_bswap16
   \       0x9E   0x0001             MOVS     R1,R0
   \       0xA0   0xB289             UXTH     R1,R1
   \       0xA2   0x4650             MOV      R0,R10
   \       0xA4   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    294                      p += 2;
   \                     ??ssl_write_supported_groups_ext_8: (+1)
   \       0xA8   0xF11A 0x0A02      ADDS     R10,R10,#+2
    295                      MBEDTLS_SSL_DEBUG_MSG(3, ("NamedGroup: %s ( %x )",
    296                                                mbedtls_ssl_named_group_to_str(*group_list),
    297                                                *group_list));
    298                  }
    299              }
   \                     ??ssl_write_supported_groups_ext_5: (+1)
   \       0xAC   0x1CAD             ADDS     R5,R5,#+2
   \       0xAE   0xE7CA             B.N      ??ssl_write_supported_groups_ext_2
    300          
    301              /* Length of named_group_list */
    302              named_group_list_len = p - named_group_list;
   \                     ??ssl_write_supported_groups_ext_3: (+1)
   \       0xB0   0x9801             LDR      R0,[SP, #+4]
   \       0xB2   0xEBBA 0x0000      SUBS     R0,R10,R0
   \       0xB6   0x9000             STR      R0,[SP, #+0]
    303              if (named_group_list_len == 0) {
   \       0xB8   0x9800             LDR      R0,[SP, #+0]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD102             BNE.N    ??ssl_write_supported_groups_ext_9
    304                  MBEDTLS_SSL_DEBUG_MSG(1, ("No group available."));
    305                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0xBE   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \       0xC2   0xE03C             B.N      ??ssl_write_supported_groups_ext_1
    306              }
    307          
    308              /* Write extension_type */
    309              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_SUPPORTED_GROUPS, buf, 0);
   \                     ??ssl_write_supported_groups_ext_9: (+1)
   \       0xC4   0x.... 0x....      LDR.W    R4,??DataTable4_2
   \       0xC8   0x7820             LDRB     R0,[R4, #+0]
   \       0xCA   0x2801             CMP      R0,#+1
   \       0xCC   0xD104             BNE.N    ??ssl_write_supported_groups_ext_10
   \       0xCE   0x210A             MOVS     R1,#+10
   \       0xD0   0x0030             MOVS     R0,R6
   \       0xD2   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0xD6   0xE007             B.N      ??ssl_write_supported_groups_ext_11
   \                     ??ssl_write_supported_groups_ext_10: (+1)
   \       0xD8   0x200A             MOVS     R0,#+10
   \       0xDA   0x.... 0x....      BL       mbedtls_bswap16
   \       0xDE   0x0001             MOVS     R1,R0
   \       0xE0   0xB289             UXTH     R1,R1
   \       0xE2   0x0030             MOVS     R0,R6
   \       0xE4   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    310              /* Write extension_data_length */
    311              MBEDTLS_PUT_UINT16_BE(named_group_list_len + 2, buf, 2);
   \                     ??ssl_write_supported_groups_ext_11: (+1)
   \       0xE8   0x7820             LDRB     R0,[R4, #+0]
   \       0xEA   0x2801             CMP      R0,#+1
   \       0xEC   0xD106             BNE.N    ??ssl_write_supported_groups_ext_12
   \       0xEE   0x9900             LDR      R1,[SP, #+0]
   \       0xF0   0x1C89             ADDS     R1,R1,#+2
   \       0xF2   0xB289             UXTH     R1,R1
   \       0xF4   0x1CB0             ADDS     R0,R6,#+2
   \       0xF6   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0xFA   0xE009             B.N      ??ssl_write_supported_groups_ext_13
   \                     ??ssl_write_supported_groups_ext_12: (+1)
   \       0xFC   0x9800             LDR      R0,[SP, #+0]
   \       0xFE   0x1C80             ADDS     R0,R0,#+2
   \      0x100   0xB280             UXTH     R0,R0
   \      0x102   0x.... 0x....      BL       mbedtls_bswap16
   \      0x106   0x0001             MOVS     R1,R0
   \      0x108   0xB289             UXTH     R1,R1
   \      0x10A   0x1CB0             ADDS     R0,R6,#+2
   \      0x10C   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    312              /* Write length of named_group_list */
    313              MBEDTLS_PUT_UINT16_BE(named_group_list_len, buf, 4);
   \                     ??ssl_write_supported_groups_ext_13: (+1)
   \      0x110   0x7820             LDRB     R0,[R4, #+0]
   \      0x112   0x2801             CMP      R0,#+1
   \      0x114   0xD105             BNE.N    ??ssl_write_supported_groups_ext_14
   \      0x116   0x9900             LDR      R1,[SP, #+0]
   \      0x118   0xB289             UXTH     R1,R1
   \      0x11A   0x1D30             ADDS     R0,R6,#+4
   \      0x11C   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \      0x120   0xE008             B.N      ??ssl_write_supported_groups_ext_15
   \                     ??ssl_write_supported_groups_ext_14: (+1)
   \      0x122   0x9800             LDR      R0,[SP, #+0]
   \      0x124   0xB280             UXTH     R0,R0
   \      0x126   0x.... 0x....      BL       mbedtls_bswap16
   \      0x12A   0x0001             MOVS     R1,R0
   \      0x12C   0xB289             UXTH     R1,R1
   \      0x12E   0x1D30             ADDS     R0,R6,#+4
   \      0x130   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    314          
    315              MBEDTLS_SSL_DEBUG_BUF(3, "Supported groups extension",
    316                                    buf + 4, named_group_list_len + 2);
    317          
    318              *out_len = p - buf;
   \                     ??ssl_write_supported_groups_ext_15: (+1)
   \      0x134   0xEBBA 0x0006      SUBS     R0,R10,R6
   \      0x138   0xF8C9 0x0000      STR      R0,[R9, #+0]
    319          
    320          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    321              mbedtls_ssl_tls13_set_hs_sent_ext_mask(
    322                  ssl, MBEDTLS_TLS_EXT_SUPPORTED_GROUPS);
    323          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
    324          
    325              return 0;
   \      0x13C   0x2000             MOVS     R0,#+0
   \                     ??ssl_write_supported_groups_ext_1: (+1)
   \      0x13E   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    326          }
    327          #endif /* MBEDTLS_SSL_TLS1_2_SOME_ECC ||
    328                    MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_EPHEMERAL_ENABLED */
    329          
    330          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    331          static int ssl_write_client_hello_cipher_suites(
    332              mbedtls_ssl_context *ssl,
    333              unsigned char *buf,
    334              unsigned char *end,
    335              int *tls12_uses_ec,
    336              size_t *out_len)
    337          {
   \                     ssl_write_client_hello_cipher_suites: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9F0C             LDR      R7,[SP, #+48]
    338              unsigned char *p = buf;
   \        0xE   0x46A0             MOV      R8,R4
    339              const int *ciphersuite_list;
    340              unsigned char *cipher_suites; /* Start of the cipher_suites list */
    341              size_t cipher_suites_len;
    342          
    343              *tls12_uses_ec = 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x6030             STR      R0,[R6, #+0]
    344              *out_len = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6038             STR      R0,[R7, #+0]
    345          
    346              /*
    347               * Ciphersuite list
    348               *
    349               * This is a list of the symmetric cipher options supported by
    350               * the client, specifically the record protection algorithm
    351               * ( including secret key length ) and a hash to be used with
    352               * HKDF, in descending order of client preference.
    353               */
    354              ciphersuite_list = ssl->conf->ciphersuite_list;
   \       0x18   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x9001             STR      R0,[SP, #+4]
    355          
    356              /* Check there is space for the cipher suite list length (2 bytes). */
    357              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 2);
   \       0x20   0x2202             MOVS     R2,#+2
   \       0x22   0x0029             MOVS     R1,R5
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD002             BEQ.N    ??ssl_write_client_hello_cipher_suites_0
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x32   0xE083             B.N      ??ssl_write_client_hello_cipher_suites_1
    358              p += 2;
   \                     ??ssl_write_client_hello_cipher_suites_0: (+1)
   \       0x34   0xF118 0x0802      ADDS     R8,R8,#+2
    359          
    360              /* Write cipher_suites
    361               * CipherSuite cipher_suites<2..2^16-2>;
    362               */
    363              cipher_suites = p;
   \       0x38   0xF8CD 0x8008      STR      R8,[SP, #+8]
    364              for (size_t i = 0; ciphersuite_list[i] != 0; i++) {
   \       0x3C   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??ssl_write_client_hello_cipher_suites_2: (+1)
   \       0x40   0x9801             LDR      R0,[SP, #+4]
   \       0x42   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD03C             BEQ.N    ??ssl_write_client_hello_cipher_suites_3
    365                  int cipher_suite = ciphersuite_list[i];
   \       0x4A   0x9801             LDR      R0,[SP, #+4]
   \       0x4C   0xF850 0xA029      LDR      R10,[R0, R9, LSL #+2]
    366                  const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
    367          
    368                  ciphersuite_info = mbedtls_ssl_ciphersuite_from_id(cipher_suite);
   \       0x50   0x4650             MOV      R0,R10
   \       0x52   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_from_id
   \       0x56   0x9000             STR      R0,[SP, #+0]
    369          
    370                  if (mbedtls_ssl_validate_ciphersuite(ssl, ciphersuite_info,
    371                                                       ssl->handshake->min_tls_version,
    372                                                       ssl->tls_version) != 0) {
   \       0x58   0xF9BB 0x3008      LDRSH    R3,[R11, #+8]
   \       0x5C   0xF8DB 0x0038      LDR      R0,[R11, #+56]
   \       0x60   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \       0x64   0x9900             LDR      R1,[SP, #+0]
   \       0x66   0x4658             MOV      R0,R11
   \       0x68   0x.... 0x....      BL       mbedtls_ssl_validate_ciphersuite
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD126             BNE.N    ??ssl_write_client_hello_cipher_suites_4
    373                      continue;
    374                  }
    375          
    376          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
    377                  (defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
    378                  defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
    379                  defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED))
    380                  *tls12_uses_ec |= mbedtls_ssl_ciphersuite_uses_ec(ciphersuite_info);
   \                     ??ssl_write_client_hello_cipher_suites_5: (+1)
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   \       0x72   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_uses_ec
   \       0x76   0x6831             LDR      R1,[R6, #+0]
   \       0x78   0x4308             ORRS     R0,R0,R1
   \       0x7A   0x6030             STR      R0,[R6, #+0]
    381          #endif
    382          
    383                  MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, add ciphersuite: %04x, %s",
    384                                            (unsigned int) cipher_suite,
    385                                            ciphersuite_info->name));
    386          
    387                  /* Check there is space for the cipher suite identifier (2 bytes). */
    388                  MBEDTLS_SSL_CHK_BUF_PTR(p, end, 2);
   \       0x7C   0x2202             MOVS     R2,#+2
   \       0x7E   0x0029             MOVS     R1,R5
   \       0x80   0x4640             MOV      R0,R8
   \       0x82   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD002             BEQ.N    ??ssl_write_client_hello_cipher_suites_6
   \       0x8A   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x8E   0xE055             B.N      ??ssl_write_client_hello_cipher_suites_1
    389                  MBEDTLS_PUT_UINT16_BE(cipher_suite, p, 0);
   \                     ??ssl_write_client_hello_cipher_suites_6: (+1)
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \       0x94   0x7800             LDRB     R0,[R0, #+0]
   \       0x96   0x2801             CMP      R0,#+1
   \       0x98   0xD106             BNE.N    ??ssl_write_client_hello_cipher_suites_7
   \       0x9A   0x4650             MOV      R0,R10
   \       0x9C   0x0001             MOVS     R1,R0
   \       0x9E   0xB289             UXTH     R1,R1
   \       0xA0   0x4640             MOV      R0,R8
   \       0xA2   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0xA6   0xE008             B.N      ??ssl_write_client_hello_cipher_suites_8
   \                     ??ssl_write_client_hello_cipher_suites_7: (+1)
   \       0xA8   0x4650             MOV      R0,R10
   \       0xAA   0xB280             UXTH     R0,R0
   \       0xAC   0x.... 0x....      BL       mbedtls_bswap16
   \       0xB0   0x0001             MOVS     R1,R0
   \       0xB2   0xB289             UXTH     R1,R1
   \       0xB4   0x4640             MOV      R0,R8
   \       0xB6   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    390                  p += 2;
   \                     ??ssl_write_client_hello_cipher_suites_8: (+1)
   \       0xBA   0xF118 0x0802      ADDS     R8,R8,#+2
    391              }
   \                     ??ssl_write_client_hello_cipher_suites_4: (+1)
   \       0xBE   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0xC2   0xE7BD             B.N      ??ssl_write_client_hello_cipher_suites_2
    392          
    393              /*
    394               * Add TLS_EMPTY_RENEGOTIATION_INFO_SCSV
    395               */
    396              int renegotiating = 0;
   \                     ??ssl_write_client_hello_cipher_suites_3: (+1)
   \       0xC4   0xF05F 0x0900      MOVS     R9,#+0
    397          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    398              renegotiating = (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE);
    399          #endif
    400              if (!renegotiating) {
   \       0xC8   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xCC   0xD11B             BNE.N    ??ssl_write_client_hello_cipher_suites_9
    401                  MBEDTLS_SSL_DEBUG_MSG(3, ("adding EMPTY_RENEGOTIATION_INFO_SCSV"));
    402                  MBEDTLS_SSL_CHK_BUF_PTR(p, end, 2);
   \       0xCE   0x2202             MOVS     R2,#+2
   \       0xD0   0x0029             MOVS     R1,R5
   \       0xD2   0x4640             MOV      R0,R8
   \       0xD4   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD001             BEQ.N    ??ssl_write_client_hello_cipher_suites_10
   \       0xDC   0x....             LDR.N    R0,??DataTable4
   \       0xDE   0xE02D             B.N      ??ssl_write_client_hello_cipher_suites_1
    403                  MBEDTLS_PUT_UINT16_BE(MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO, p, 0);
   \                     ??ssl_write_client_hello_cipher_suites_10: (+1)
   \       0xE0   0x....             LDR.N    R0,??DataTable4_2
   \       0xE2   0x7800             LDRB     R0,[R0, #+0]
   \       0xE4   0x2801             CMP      R0,#+1
   \       0xE6   0xD104             BNE.N    ??ssl_write_client_hello_cipher_suites_11
   \       0xE8   0x21FF             MOVS     R1,#+255
   \       0xEA   0x4640             MOV      R0,R8
   \       0xEC   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0xF0   0xE007             B.N      ??ssl_write_client_hello_cipher_suites_12
   \                     ??ssl_write_client_hello_cipher_suites_11: (+1)
   \       0xF2   0x20FF             MOVS     R0,#+255
   \       0xF4   0x.... 0x....      BL       mbedtls_bswap16
   \       0xF8   0x0001             MOVS     R1,R0
   \       0xFA   0xB289             UXTH     R1,R1
   \       0xFC   0x4640             MOV      R0,R8
   \       0xFE   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    404                  p += 2;
   \                     ??ssl_write_client_hello_cipher_suites_12: (+1)
   \      0x102   0xF118 0x0802      ADDS     R8,R8,#+2
    405              }
    406          
    407              /* Write the cipher_suites length in number of bytes */
    408              cipher_suites_len = p - cipher_suites;
   \                     ??ssl_write_client_hello_cipher_suites_9: (+1)
   \      0x106   0xF8DD 0xA008      LDR      R10,[SP, #+8]
   \      0x10A   0xEBB8 0x0A0A      SUBS     R10,R8,R10
    409              MBEDTLS_PUT_UINT16_BE(cipher_suites_len, buf, 0);
   \      0x10E   0x....             LDR.N    R0,??DataTable4_2
   \      0x110   0x7800             LDRB     R0,[R0, #+0]
   \      0x112   0x2801             CMP      R0,#+1
   \      0x114   0xD105             BNE.N    ??ssl_write_client_hello_cipher_suites_13
   \      0x116   0x4651             MOV      R1,R10
   \      0x118   0xB289             UXTH     R1,R1
   \      0x11A   0x0020             MOVS     R0,R4
   \      0x11C   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \      0x120   0xE008             B.N      ??ssl_write_client_hello_cipher_suites_14
   \                     ??ssl_write_client_hello_cipher_suites_13: (+1)
   \      0x122   0x4650             MOV      R0,R10
   \      0x124   0xB280             UXTH     R0,R0
   \      0x126   0x.... 0x....      BL       mbedtls_bswap16
   \      0x12A   0x0001             MOVS     R1,R0
   \      0x12C   0xB289             UXTH     R1,R1
   \      0x12E   0x0020             MOVS     R0,R4
   \      0x130   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    410              MBEDTLS_SSL_DEBUG_MSG(3,
    411                                    ("client hello, got %" MBEDTLS_PRINTF_SIZET " cipher suites",
    412                                     cipher_suites_len/2));
    413          
    414              /* Output the total length of cipher_suites field. */
    415              *out_len = p - buf;
   \                     ??ssl_write_client_hello_cipher_suites_14: (+1)
   \      0x134   0xEBB8 0x0004      SUBS     R0,R8,R4
   \      0x138   0x6038             STR      R0,[R7, #+0]
    416          
    417              return 0;
   \      0x13A   0x2000             MOVS     R0,#+0
   \                     ??ssl_write_client_hello_cipher_suites_1: (+1)
   \      0x13C   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    418          }
    419          
    420          /*
    421           * Structure of the TLS 1.3 ClientHello message:
    422           *
    423           *    struct {
    424           *        ProtocolVersion legacy_version = 0x0303;    // TLS v1.2
    425           *        Random random;
    426           *        opaque legacy_session_id<0..32>;
    427           *        CipherSuite cipher_suites<2..2^16-2>;
    428           *        opaque legacy_compression_methods<1..2^8-1>;
    429           *        Extension extensions<8..2^16-1>;
    430           *    } ClientHello;
    431           *
    432           * Structure of the (D)TLS 1.2 ClientHello message:
    433           *
    434           * struct {
    435           *     ProtocolVersion client_version;
    436           *     Random random;
    437           *     SessionID session_id;
    438           *     opaque cookie<0..2^8-1>; // DTLS 1.2 ONLY
    439           *     CipherSuite cipher_suites<2..2^16-2>;
    440           *     CompressionMethod compression_methods<1..2^8-1>;
    441           *     select (extensions_present) {
    442           *         case false:
    443           *             struct {};
    444           *         case true:
    445           *             Extension extensions<0..2^16-1>;
    446           *     };
    447           * } ClientHello;
    448           */
    449          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    450          static int ssl_write_client_hello_body(mbedtls_ssl_context *ssl,
    451                                                 unsigned char *buf,
    452                                                 unsigned char *end,
    453                                                 size_t *out_len,
    454                                                 size_t *binders_len)
    455          {
   \                     ssl_write_client_hello_body: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
    456              int ret;
    457              mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   \        0xC   0xF8DB 0x0038      LDR      R0,[R11, #+56]
   \       0x10   0x9004             STR      R0,[SP, #+16]
    458              unsigned char *p = buf;
   \       0x12   0x9C06             LDR      R4,[SP, #+24]
    459              unsigned char *p_extensions_len; /* Pointer to extensions length */
    460              size_t output_len;               /* Length of buffer used by function */
    461              size_t extensions_len;           /* Length of the list of extensions*/
    462              int tls12_uses_ec = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9002             STR      R0,[SP, #+8]
    463          
    464              *out_len = 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    465              *binders_len = 0;
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x9810             LDR      R0,[SP, #+64]
   \       0x22   0x6001             STR      R1,[R0, #+0]
    466          
    467          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    468              unsigned char propose_tls12 =
    469                  (handshake->min_tls_version <= MBEDTLS_SSL_VERSION_TLS1_2)
    470                  &&
    471                  (MBEDTLS_SSL_VERSION_TLS1_2 <= ssl->tls_version);
   \       0x24   0x9804             LDR      R0,[SP, #+16]
   \       0x26   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \       0x2A   0xF5B0 0x7F41      CMP      R0,#+772
   \       0x2E   0xDA08             BGE.N    ??ssl_write_client_hello_body_0
   \       0x30   0xF9BB 0x1008      LDRSH    R1,[R11, #+8]
   \       0x34   0xF240 0x3003      MOVW     R0,#+771
   \       0x38   0x4281             CMP      R1,R0
   \       0x3A   0xDB02             BLT.N    ??ssl_write_client_hello_body_0
   \       0x3C   0xF05F 0x0901      MOVS     R9,#+1
   \       0x40   0xE001             B.N      ??ssl_write_client_hello_body_1
   \                     ??ssl_write_client_hello_body_0: (+1)
   \       0x42   0xF05F 0x0900      MOVS     R9,#+0
    472          #endif
    473          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    474              unsigned char propose_tls13 =
    475                  (handshake->min_tls_version <= MBEDTLS_SSL_VERSION_TLS1_3)
    476                  &&
    477                  (MBEDTLS_SSL_VERSION_TLS1_3 <= ssl->tls_version);
    478          #endif
    479          
    480              /*
    481               * Write client_version (TLS 1.2) or legacy_version (TLS 1.3)
    482               *
    483               * In all cases this is the TLS 1.2 version.
    484               */
    485              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 2);
   \                     ??ssl_write_client_hello_body_1: (+1)
   \       0x46   0x2202             MOVS     R2,#+2
   \       0x48   0x0039             MOVS     R1,R7
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD001             BEQ.N    ??ssl_write_client_hello_body_2
   \       0x54   0x....             LDR.N    R0,??DataTable4
   \       0x56   0xE0D4             B.N      ??ssl_write_client_hello_body_3
    486              mbedtls_ssl_write_version(p, ssl->conf->transport,
    487                                        MBEDTLS_SSL_VERSION_TLS1_2);
   \                     ??ssl_write_client_hello_body_2: (+1)
   \       0x58   0xF240 0x3203      MOVW     R2,#+771
   \       0x5C   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x60   0x7941             LDRB     R1,[R0, #+5]
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x.... 0x....      BL       mbedtls_ssl_write_version
    488              p += 2;
   \       0x68   0x1CA4             ADDS     R4,R4,#+2
    489          
    490              /* ...
    491               * Random random;
    492               * ...
    493               *
    494               * The random bytes have been prepared by ssl_prepare_client_hello() into
    495               * the handshake->randbytes buffer and are copied here into the output
    496               * buffer.
    497               */
    498              MBEDTLS_SSL_CHK_BUF_PTR(p, end, MBEDTLS_CLIENT_HELLO_RANDOM_LEN);
   \       0x6A   0x2220             MOVS     R2,#+32
   \       0x6C   0x0039             MOVS     R1,R7
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD001             BEQ.N    ??ssl_write_client_hello_body_4
   \       0x78   0x....             LDR.N    R0,??DataTable4
   \       0x7A   0xE0C2             B.N      ??ssl_write_client_hello_body_3
    499              memcpy(p, handshake->randbytes, MBEDTLS_CLIENT_HELLO_RANDOM_LEN);
   \                     ??ssl_write_client_hello_body_4: (+1)
   \       0x7C   0xF05F 0x0A20      MOVS     R10,#+32
   \       0x80   0x9804             LDR      R0,[SP, #+16]
   \       0x82   0xF510 0x75FC      ADDS     R5,R0,#+504
   \       0x86   0x0026             MOVS     R6,R4
   \       0x88   0x4652             MOV      R2,R10
   \       0x8A   0x0029             MOVS     R1,R5
   \       0x8C   0x0030             MOVS     R0,R6
   \       0x8E   0x.... 0x....      BL       __aeabi_memcpy
    500              MBEDTLS_SSL_DEBUG_BUF(3, "client hello, random bytes",
    501                                    p, MBEDTLS_CLIENT_HELLO_RANDOM_LEN);
    502              p += MBEDTLS_CLIENT_HELLO_RANDOM_LEN;
   \       0x92   0x3420             ADDS     R4,R4,#+32
    503          
    504              /* TLS 1.2:
    505               * ...
    506               * SessionID session_id;
    507               * ...
    508               * with
    509               * opaque SessionID<0..32>;
    510               *
    511               * TLS 1.3:
    512               * ...
    513               * opaque legacy_session_id<0..32>;
    514               * ...
    515               *
    516               * The (legacy) session identifier bytes have been prepared by
    517               * ssl_prepare_client_hello() into the ssl->session_negotiate->id buffer
    518               * and are copied here into the output buffer.
    519               */
    520              MBEDTLS_SSL_CHK_BUF_PTR(p, end, ssl->session_negotiate->id_len + 1);
   \       0x94   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \       0x98   0x6882             LDR      R2,[R0, #+8]
   \       0x9A   0x1C52             ADDS     R2,R2,#+1
   \       0x9C   0x0039             MOVS     R1,R7
   \       0x9E   0x0020             MOVS     R0,R4
   \       0xA0   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD001             BEQ.N    ??ssl_write_client_hello_body_5
   \       0xA8   0x....             LDR.N    R0,??DataTable4
   \       0xAA   0xE0AA             B.N      ??ssl_write_client_hello_body_3
    521              *p++ = (unsigned char) ssl->session_negotiate->id_len;
   \                     ??ssl_write_client_hello_body_5: (+1)
   \       0xAC   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \       0xB0   0x6880             LDR      R0,[R0, #+8]
   \       0xB2   0x7020             STRB     R0,[R4, #+0]
   \       0xB4   0xF114 0x0A01      ADDS     R10,R4,#+1
    522              memcpy(p, ssl->session_negotiate->id, ssl->session_negotiate->id_len);
   \       0xB8   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \       0xBC   0x6885             LDR      R5,[R0, #+8]
   \       0xBE   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \       0xC2   0xF110 0x060C      ADDS     R6,R0,#+12
   \       0xC6   0x4654             MOV      R4,R10
   \       0xC8   0x002A             MOVS     R2,R5
   \       0xCA   0x0031             MOVS     R1,R6
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0x.... 0x....      BL       __aeabi_memcpy
    523              p += ssl->session_negotiate->id_len;
   \       0xD2   0xF8DB 0x0034      LDR      R0,[R11, #+52]
   \       0xD6   0x6880             LDR      R0,[R0, #+8]
   \       0xD8   0x4482             ADD      R10,R10,R0
    524          
    525              MBEDTLS_SSL_DEBUG_BUF(3, "session id", ssl->session_negotiate->id,
    526                                    ssl->session_negotiate->id_len);
    527          
    528              /* DTLS 1.2 ONLY
    529               * ...
    530               * opaque cookie<0..2^8-1>;
    531               * ...
    532               */
    533          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && defined(MBEDTLS_SSL_PROTO_DTLS)
    534              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
    535          #if !defined(MBEDTLS_SSL_PROTO_TLS1_3)
    536                  uint8_t cookie_len = 0;
    537          #else
    538                  uint16_t cookie_len = 0;
    539          #endif /* !MBEDTLS_SSL_PROTO_TLS1_3 */
    540          
    541                  if (handshake->cookie != NULL) {
    542                      MBEDTLS_SSL_DEBUG_BUF(3, "client hello, cookie",
    543                                            handshake->cookie,
    544                                            handshake->cookie_len);
    545                      cookie_len = handshake->cookie_len;
    546                  }
    547          
    548                  MBEDTLS_SSL_CHK_BUF_PTR(p, end, cookie_len + 1);
    549                  *p++ = (unsigned char) cookie_len;
    550                  if (cookie_len > 0) {
    551                      memcpy(p, handshake->cookie, cookie_len);
    552                      p += cookie_len;
    553                  }
    554              }
    555          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 && MBEDTLS_SSL_PROTO_DTLS */
    556          
    557              /* Write cipher_suites */
    558              ret = ssl_write_client_hello_cipher_suites(ssl, p, end,
    559                                                         &tls12_uses_ec,
    560                                                         &output_len);
   \       0xDA   0xA801             ADD      R0,SP,#+4
   \       0xDC   0x9000             STR      R0,[SP, #+0]
   \       0xDE   0xAB02             ADD      R3,SP,#+8
   \       0xE0   0x003A             MOVS     R2,R7
   \       0xE2   0x4651             MOV      R1,R10
   \       0xE4   0x4658             MOV      R0,R11
   \       0xE6   0x.... 0x....      BL       ssl_write_client_hello_cipher_suites
   \       0xEA   0x0004             MOVS     R4,R0
    561              if (ret != 0) {
   \       0xEC   0x2C00             CMP      R4,#+0
   \       0xEE   0xD001             BEQ.N    ??ssl_write_client_hello_body_6
    562                  return ret;
   \       0xF0   0x0020             MOVS     R0,R4
   \       0xF2   0xE086             B.N      ??ssl_write_client_hello_body_3
    563              }
    564              p += output_len;
   \                     ??ssl_write_client_hello_body_6: (+1)
   \       0xF4   0x9801             LDR      R0,[SP, #+4]
   \       0xF6   0xEB0A 0x0500      ADD      R5,R10,R0
    565          
    566              /* Write legacy_compression_methods (TLS 1.3) or
    567               * compression_methods (TLS 1.2)
    568               *
    569               * For every TLS 1.3 ClientHello, this vector MUST contain exactly
    570               * one byte set to zero, which corresponds to the 'null' compression
    571               * method in prior versions of TLS.
    572               *
    573               * For TLS 1.2 ClientHello, for security reasons we do not support
    574               * compression anymore, thus also just the 'null' compression method.
    575               */
    576              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 2);
   \       0xFA   0x2202             MOVS     R2,#+2
   \       0xFC   0x0039             MOVS     R1,R7
   \       0xFE   0x0028             MOVS     R0,R5
   \      0x100   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD001             BEQ.N    ??ssl_write_client_hello_body_7
   \      0x108   0x....             LDR.N    R0,??DataTable4
   \      0x10A   0xE07A             B.N      ??ssl_write_client_hello_body_3
    577              *p++ = 1;
   \                     ??ssl_write_client_hello_body_7: (+1)
   \      0x10C   0x2001             MOVS     R0,#+1
   \      0x10E   0x7028             STRB     R0,[R5, #+0]
   \      0x110   0x1C69             ADDS     R1,R5,#+1
    578              *p++ = MBEDTLS_SSL_COMPRESS_NULL;
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0x7008             STRB     R0,[R1, #+0]
   \      0x116   0x1C4D             ADDS     R5,R1,#+1
    579          
    580              /* Write extensions */
    581          
    582          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    583              /* Keeping track of the included extensions */
    584              handshake->sent_extensions = MBEDTLS_SSL_EXT_MASK_NONE;
    585          #endif
    586          
    587              /* First write extensions, then the total length */
    588              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 2);
   \      0x118   0x2202             MOVS     R2,#+2
   \      0x11A   0x0039             MOVS     R1,R7
   \      0x11C   0x0028             MOVS     R0,R5
   \      0x11E   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xD001             BEQ.N    ??ssl_write_client_hello_body_8
   \      0x126   0x....             LDR.N    R0,??DataTable4
   \      0x128   0xE06B             B.N      ??ssl_write_client_hello_body_3
    589              p_extensions_len = p;
   \                     ??ssl_write_client_hello_body_8: (+1)
   \      0x12A   0x9503             STR      R5,[SP, #+12]
    590              p += 2;
   \      0x12C   0xF115 0x0A02      ADDS     R10,R5,#+2
    591          
    592          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    593              /* Write server name extension */
    594              ret = ssl_write_hostname_ext(ssl, p, end, &output_len);
    595              if (ret != 0) {
    596                  return ret;
    597              }
    598              p += output_len;
    599          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
    600          
    601          #if defined(MBEDTLS_SSL_ALPN)
    602              ret = ssl_write_alpn_ext(ssl, p, end, &output_len);
    603              if (ret != 0) {
    604                  return ret;
    605              }
    606              p += output_len;
    607          #endif /* MBEDTLS_SSL_ALPN */
    608          
    609          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    610              if (propose_tls13) {
    611                  ret = mbedtls_ssl_tls13_write_client_hello_exts(ssl, p, end,
    612                                                                  &output_len);
    613                  if (ret != 0) {
    614                      return ret;
    615                  }
    616                  p += output_len;
    617              }
    618          #endif
    619          
    620          #if defined(MBEDTLS_SSL_TLS1_2_SOME_ECC) || \
    621              defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_EPHEMERAL_ENABLED)
    622              {
    623                  int ssl_write_supported_groups_ext_flags = 0;
   \      0x130   0x2500             MOVS     R5,#+0
    624          
    625          #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_EPHEMERAL_ENABLED)
    626                  if (propose_tls13 && mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) {
    627                      ssl_write_supported_groups_ext_flags |=
    628                          SSL_WRITE_SUPPORTED_GROUPS_EXT_TLS1_3_FLAG;
    629                  }
    630          #endif
    631          #if defined(MBEDTLS_SSL_TLS1_2_SOME_ECC)
    632                  if (propose_tls12 && tls12_uses_ec) {
   \      0x132   0x4648             MOV      R0,R9
   \      0x134   0xB2C0             UXTB     R0,R0
   \      0x136   0x2800             CMP      R0,#+0
   \      0x138   0xD004             BEQ.N    ??ssl_write_client_hello_body_9
   \      0x13A   0x9802             LDR      R0,[SP, #+8]
   \      0x13C   0x2800             CMP      R0,#+0
   \      0x13E   0xD001             BEQ.N    ??ssl_write_client_hello_body_9
    633                      ssl_write_supported_groups_ext_flags |=
    634                          SSL_WRITE_SUPPORTED_GROUPS_EXT_TLS1_2_FLAG;
   \      0x140   0xF055 0x0501      ORRS     R5,R5,#0x1
    635                  }
    636          #endif
    637                  if (ssl_write_supported_groups_ext_flags != 0) {
   \                     ??ssl_write_client_hello_body_9: (+1)
   \      0x144   0x2D00             CMP      R5,#+0
   \      0x146   0xD00E             BEQ.N    ??ssl_write_client_hello_body_10
    638                      ret = ssl_write_supported_groups_ext(ssl, p, end,
    639                                                           ssl_write_supported_groups_ext_flags,
    640                                                           &output_len);
   \      0x148   0xA801             ADD      R0,SP,#+4
   \      0x14A   0x9000             STR      R0,[SP, #+0]
   \      0x14C   0x002B             MOVS     R3,R5
   \      0x14E   0x003A             MOVS     R2,R7
   \      0x150   0x4651             MOV      R1,R10
   \      0x152   0x4658             MOV      R0,R11
   \      0x154   0x.... 0x....      BL       ssl_write_supported_groups_ext
   \      0x158   0x0004             MOVS     R4,R0
    641                      if (ret != 0) {
   \      0x15A   0x2C00             CMP      R4,#+0
   \      0x15C   0xD001             BEQ.N    ??ssl_write_client_hello_body_11
    642                          return ret;
   \      0x15E   0x0020             MOVS     R0,R4
   \      0x160   0xE04F             B.N      ??ssl_write_client_hello_body_3
    643                      }
    644                      p += output_len;
   \                     ??ssl_write_client_hello_body_11: (+1)
   \      0x162   0x9801             LDR      R0,[SP, #+4]
   \      0x164   0x4482             ADD      R10,R10,R0
    645                  }
    646              }
    647          #endif /* MBEDTLS_SSL_TLS1_2_SOME_ECC ||
    648                    MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_EPHEMERAL_ENABLED */
    649          
    650          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
    651              int write_sig_alg_ext = 0;
   \                     ??ssl_write_client_hello_body_10: (+1)
   \      0x166   0x2000             MOVS     R0,#+0
    652          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    653              write_sig_alg_ext = write_sig_alg_ext ||
    654                                  (propose_tls13 && mbedtls_ssl_conf_tls13_ephemeral_enabled(ssl));
    655          #endif
    656          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    657              write_sig_alg_ext = write_sig_alg_ext || propose_tls12;
   \      0x168   0x2800             CMP      R0,#+0
   \      0x16A   0xD103             BNE.N    ??ssl_write_client_hello_body_12
   \      0x16C   0x4648             MOV      R0,R9
   \      0x16E   0xB2C0             UXTB     R0,R0
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xD001             BEQ.N    ??ssl_write_client_hello_body_13
   \                     ??ssl_write_client_hello_body_12: (+1)
   \      0x174   0x2501             MOVS     R5,#+1
   \      0x176   0xE000             B.N      ??ssl_write_client_hello_body_14
   \                     ??ssl_write_client_hello_body_13: (+1)
   \      0x178   0x2500             MOVS     R5,#+0
    658          #endif
    659          
    660              if (write_sig_alg_ext) {
   \                     ??ssl_write_client_hello_body_14: (+1)
   \      0x17A   0x2D00             CMP      R5,#+0
   \      0x17C   0xD00C             BEQ.N    ??ssl_write_client_hello_body_15
    661                  ret = mbedtls_ssl_write_sig_alg_ext(ssl, p, end, &output_len);
   \      0x17E   0xAB01             ADD      R3,SP,#+4
   \      0x180   0x003A             MOVS     R2,R7
   \      0x182   0x4651             MOV      R1,R10
   \      0x184   0x4658             MOV      R0,R11
   \      0x186   0x.... 0x....      BL       mbedtls_ssl_write_sig_alg_ext
   \      0x18A   0x0004             MOVS     R4,R0
    662                  if (ret != 0) {
   \      0x18C   0x2C00             CMP      R4,#+0
   \      0x18E   0xD001             BEQ.N    ??ssl_write_client_hello_body_16
    663                      return ret;
   \      0x190   0x0020             MOVS     R0,R4
   \      0x192   0xE036             B.N      ??ssl_write_client_hello_body_3
    664                  }
    665                  p += output_len;
   \                     ??ssl_write_client_hello_body_16: (+1)
   \      0x194   0x9801             LDR      R0,[SP, #+4]
   \      0x196   0x4482             ADD      R10,R10,R0
    666              }
    667          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
    668          
    669          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    670              if (propose_tls12) {
   \                     ??ssl_write_client_hello_body_15: (+1)
   \      0x198   0x4648             MOV      R0,R9
   \      0x19A   0xB2C0             UXTB     R0,R0
   \      0x19C   0x2800             CMP      R0,#+0
   \      0x19E   0xD00E             BEQ.N    ??ssl_write_client_hello_body_17
    671                  ret = mbedtls_ssl_tls12_write_client_hello_exts(ssl, p, end,
    672                                                                  tls12_uses_ec,
    673                                                                  &output_len);
   \      0x1A0   0xA801             ADD      R0,SP,#+4
   \      0x1A2   0x9000             STR      R0,[SP, #+0]
   \      0x1A4   0x9B02             LDR      R3,[SP, #+8]
   \      0x1A6   0x003A             MOVS     R2,R7
   \      0x1A8   0x4651             MOV      R1,R10
   \      0x1AA   0x4658             MOV      R0,R11
   \      0x1AC   0x.... 0x....      BL       mbedtls_ssl_tls12_write_client_hello_exts
   \      0x1B0   0x0004             MOVS     R4,R0
    674                  if (ret != 0) {
   \      0x1B2   0x2C00             CMP      R4,#+0
   \      0x1B4   0xD001             BEQ.N    ??ssl_write_client_hello_body_18
    675                      return ret;
   \      0x1B6   0x0020             MOVS     R0,R4
   \      0x1B8   0xE023             B.N      ??ssl_write_client_hello_body_3
    676                  }
    677                  p += output_len;
   \                     ??ssl_write_client_hello_body_18: (+1)
   \      0x1BA   0x9801             LDR      R0,[SP, #+4]
   \      0x1BC   0x4482             ADD      R10,R10,R0
    678              }
    679          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
    680          
    681          #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_PSK_ENABLED)
    682              /* The "pre_shared_key" extension (RFC 8446 Section 4.2.11)
    683               * MUST be the last extension in the ClientHello.
    684               */
    685              if (propose_tls13 && mbedtls_ssl_conf_tls13_some_psk_enabled(ssl)) {
    686                  ret = mbedtls_ssl_tls13_write_identities_of_pre_shared_key_ext(
    687                      ssl, p, end, &output_len, binders_len);
    688                  if (ret != 0) {
    689                      return ret;
    690                  }
    691                  p += output_len;
    692              }
    693          #endif /* MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_PSK_ENABLED */
    694          
    695              /* Write the length of the list of extensions. */
    696              extensions_len = p - p_extensions_len - 2;
   \                     ??ssl_write_client_hello_body_17: (+1)
   \      0x1BE   0x9E03             LDR      R6,[SP, #+12]
   \      0x1C0   0xEBBA 0x0606      SUBS     R6,R10,R6
   \      0x1C4   0x1EB6             SUBS     R6,R6,#+2
    697          
    698              if (extensions_len == 0) {
   \      0x1C6   0x2E00             CMP      R6,#+0
   \      0x1C8   0xD102             BNE.N    ??ssl_write_client_hello_body_19
    699                  p = p_extensions_len;
   \      0x1CA   0x9803             LDR      R0,[SP, #+12]
   \      0x1CC   0x4682             MOV      R10,R0
   \      0x1CE   0xE012             B.N      ??ssl_write_client_hello_body_20
    700              } else {
    701                  MBEDTLS_PUT_UINT16_BE(extensions_len, p_extensions_len, 0);
   \                     ??ssl_write_client_hello_body_19: (+1)
   \      0x1D0   0x....             LDR.N    R0,??DataTable4_2
   \      0x1D2   0x7800             LDRB     R0,[R0, #+0]
   \      0x1D4   0x2801             CMP      R0,#+1
   \      0x1D6   0xD105             BNE.N    ??ssl_write_client_hello_body_21
   \      0x1D8   0x0031             MOVS     R1,R6
   \      0x1DA   0xB289             UXTH     R1,R1
   \      0x1DC   0x9803             LDR      R0,[SP, #+12]
   \      0x1DE   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \      0x1E2   0xE008             B.N      ??ssl_write_client_hello_body_22
   \                     ??ssl_write_client_hello_body_21: (+1)
   \      0x1E4   0x0030             MOVS     R0,R6
   \      0x1E6   0xB280             UXTH     R0,R0
   \      0x1E8   0x.... 0x....      BL       mbedtls_bswap16
   \      0x1EC   0x0001             MOVS     R1,R0
   \      0x1EE   0xB289             UXTH     R1,R1
   \      0x1F0   0x9803             LDR      R0,[SP, #+12]
   \      0x1F2   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    702                  MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, total extension length: %" \
    703                                            MBEDTLS_PRINTF_SIZET, extensions_len));
    704                  MBEDTLS_SSL_DEBUG_BUF(3, "client hello extensions",
    705                                        p_extensions_len, extensions_len);
    706              }
    707          
    708          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
    709              MBEDTLS_SSL_PRINT_EXTS(
    710                  3, MBEDTLS_SSL_HS_CLIENT_HELLO, handshake->sent_extensions);
    711          #endif
    712          
    713              *out_len = p - buf;
   \                     ??ssl_write_client_hello_body_22: (+1)
   \                     ??ssl_write_client_hello_body_20: (+1)
   \      0x1F6   0x9806             LDR      R0,[SP, #+24]
   \      0x1F8   0xEBBA 0x0000      SUBS     R0,R10,R0
   \      0x1FC   0xF8C8 0x0000      STR      R0,[R8, #+0]
    714              return 0;
   \      0x200   0x2000             MOVS     R0,#+0
   \                     ??ssl_write_client_hello_body_3: (+1)
   \      0x202   0xB007             ADD      SP,SP,#+28
   \      0x204   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    715          }
    716          
    717          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    718          static int ssl_generate_random(mbedtls_ssl_context *ssl)
    719          {
   \                     ssl_generate_random: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    720              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0x4   0xF07F 0x056D      MVNS     R5,#+109
    721              unsigned char *randbytes = ssl->handshake->randbytes;
   \        0x8   0x6BA0             LDR      R0,[R4, #+56]
   \        0xA   0xF510 0x76FC      ADDS     R6,R0,#+504
    722              size_t gmt_unix_time_len = 0;
   \        0xE   0x2700             MOVS     R7,#+0
    723          
    724              /*
    725               * Generate the random bytes
    726               *
    727               * TLS 1.2 case:
    728               * struct {
    729               *     uint32 gmt_unix_time;
    730               *     opaque random_bytes[28];
    731               * } Random;
    732               *
    733               * TLS 1.3 case:
    734               * opaque Random[32];
    735               */
    736              if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_2) {
    737          #if defined(MBEDTLS_HAVE_TIME)
    738                  mbedtls_time_t gmt_unix_time = mbedtls_time(NULL);
    739                  MBEDTLS_PUT_UINT32_BE(gmt_unix_time, randbytes, 0);
    740                  gmt_unix_time_len = 4;
    741          
    742                  MBEDTLS_SSL_DEBUG_MSG(3,
    743                                        ("client hello, current time: %" MBEDTLS_PRINTF_LONGLONG,
    744                                         (long long) gmt_unix_time));
    745          #endif /* MBEDTLS_HAVE_TIME */
    746              }
    747          
    748              ret = ssl->conf->f_rng(ssl->conf->p_rng,
    749                                     randbytes + gmt_unix_time_len,
    750                                     MBEDTLS_CLIENT_HELLO_RANDOM_LEN - gmt_unix_time_len);
   \       0x10   0xF1D7 0x0220      RSBS     R2,R7,#+32
   \       0x14   0xEB06 0x0107      ADD      R1,R6,R7
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x69C0             LDR      R0,[R0, #+28]
   \       0x1C   0x6823             LDR      R3,[R4, #+0]
   \       0x1E   0x699B             LDR      R3,[R3, #+24]
   \       0x20   0x4798             BLX      R3
    751              return ret;
   \       0x22   0xBDF2             POP      {R1,R4-R7,PC}
    752          }
    753          
    754          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
    755          static int ssl_prepare_client_hello(mbedtls_ssl_context *ssl)
    756          {
   \                     ssl_prepare_client_hello: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
    757              int ret;
    758              size_t session_id_len;
    759              mbedtls_ssl_session *session_negotiate = ssl->session_negotiate;
   \        0x4   0x6B7D             LDR      R5,[R7, #+52]
    760          
    761              if (session_negotiate == NULL) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD101             BNE.N    ??ssl_prepare_client_hello_0
    762                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \        0xA   0x....             LDR.N    R0,??DataTable4_3
   \        0xC   0xE040             B.N      ??ssl_prepare_client_hello_1
    763              }
    764          
    765          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && \
    766              defined(MBEDTLS_SSL_SESSION_TICKETS) && \
    767              defined(MBEDTLS_HAVE_TIME)
    768          
    769              /* Check if a tls13 ticket has been configured. */
    770              if (ssl->handshake->resume != 0 &&
    771                  session_negotiate->tls_version == MBEDTLS_SSL_VERSION_TLS1_3 &&
    772                  session_negotiate->ticket != NULL) {
    773                  mbedtls_time_t now = mbedtls_time(NULL);
    774                  uint64_t age = (uint64_t) (now - session_negotiate->ticket_received);
    775                  if (session_negotiate->ticket_received > now ||
    776                      age > session_negotiate->ticket_lifetime) {
    777                      /* Without valid ticket, disable session resumption.*/
    778                      MBEDTLS_SSL_DEBUG_MSG(
    779                          3, ("Ticket expired, disable session resumption"));
    780                      ssl->handshake->resume = 0;
    781                  }
    782              }
    783          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 &&
    784                    MBEDTLS_SSL_SESSION_TICKETS &&
    785                    MBEDTLS_HAVE_TIME */
    786          
    787              if (ssl->conf->f_rng == NULL) {
   \                     ??ssl_prepare_client_hello_0: (+1)
   \        0xE   0x6838             LDR      R0,[R7, #+0]
   \       0x10   0x6980             LDR      R0,[R0, #+24]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??ssl_prepare_client_hello_2
    788                  MBEDTLS_SSL_DEBUG_MSG(1, ("no RNG provided"));
    789                  return MBEDTLS_ERR_SSL_NO_RNG;
   \       0x16   0x....             LDR.N    R0,??DataTable4_4
   \       0x18   0xE03A             B.N      ??ssl_prepare_client_hello_1
    790              }
    791          
    792              /* Bet on the highest configured version if we are not in a TLS 1.2
    793               * renegotiation or session resumption.
    794               */
    795          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    796              if (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE) {
    797                  ssl->handshake->min_tls_version = ssl->tls_version;
    798              } else
    799          #endif
    800              {
    801                  if (ssl->handshake->resume) {
   \                     ??ssl_prepare_client_hello_2: (+1)
   \       0x1A   0x6BB8             LDR      R0,[R7, #+56]
   \       0x1C   0x7800             LDRB     R0,[R0, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD005             BEQ.N    ??ssl_prepare_client_hello_3
    802                      ssl->tls_version = session_negotiate->tls_version;
   \       0x22   0x8868             LDRH     R0,[R5, #+2]
   \       0x24   0x8138             STRH     R0,[R7, #+8]
    803                      ssl->handshake->min_tls_version = ssl->tls_version;
   \       0x26   0x8939             LDRH     R1,[R7, #+8]
   \       0x28   0x6BB8             LDR      R0,[R7, #+56]
   \       0x2A   0x8041             STRH     R1,[R0, #+2]
   \       0x2C   0xE003             B.N      ??ssl_prepare_client_hello_4
    804                  } else {
    805                      ssl->handshake->min_tls_version = ssl->conf->min_tls_version;
   \                     ??ssl_prepare_client_hello_3: (+1)
   \       0x2E   0x6838             LDR      R0,[R7, #+0]
   \       0x30   0x8841             LDRH     R1,[R0, #+2]
   \       0x32   0x6BB8             LDR      R0,[R7, #+56]
   \       0x34   0x8041             STRH     R1,[R0, #+2]
    806                  }
    807              }
    808          
    809              /*
    810               * Generate the random bytes, except when responding to a verify request
    811               * where we MUST reuse the previously generated random bytes
    812               * (RFC 6347 4.2.1).
    813               */
    814          #if defined(MBEDTLS_SSL_PROTO_DTLS)
    815              if ((ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) ||
    816                  (ssl->handshake->cookie == NULL))
    817          #endif
    818              {
    819                  ret = ssl_generate_random(ssl);
   \                     ??ssl_prepare_client_hello_4: (+1)
   \       0x36   0x0038             MOVS     R0,R7
   \       0x38   0x.... 0x....      BL       ssl_generate_random
   \       0x3C   0x0004             MOVS     R4,R0
    820                  if (ret != 0) {
   \       0x3E   0x2C00             CMP      R4,#+0
   \       0x40   0xD001             BEQ.N    ??ssl_prepare_client_hello_5
    821                      MBEDTLS_SSL_DEBUG_RET(1, "Random bytes generation failed", ret);
    822                      return ret;
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0xE024             B.N      ??ssl_prepare_client_hello_1
    823                  }
    824              }
    825          
    826              /*
    827               * Prepare session identifier. At that point, the length of the session
    828               * identifier in the SSL context `ssl->session_negotiate->id_len` is equal
    829               * to zero, except in the case of a TLS 1.2 session renegotiation or
    830               * session resumption.
    831               */
    832              session_id_len = session_negotiate->id_len;
   \                     ??ssl_prepare_client_hello_5: (+1)
   \       0x46   0x68AE             LDR      R6,[R5, #+8]
    833          
    834          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    835              if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_2) {
   \       0x48   0xF9B7 0x1008      LDRSH    R1,[R7, #+8]
   \       0x4C   0xF240 0x3003      MOVW     R0,#+771
   \       0x50   0x4281             CMP      R1,R0
   \       0x52   0xD109             BNE.N    ??ssl_prepare_client_hello_6
    836                  if (session_id_len < 16 || session_id_len > 32 ||
    837          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    838                      ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE ||
    839          #endif
    840                      ssl->handshake->resume == 0) {
   \       0x54   0x2E10             CMP      R6,#+16
   \       0x56   0xD305             BCC.N    ??ssl_prepare_client_hello_7
   \       0x58   0x2E21             CMP      R6,#+33
   \       0x5A   0xD203             BCS.N    ??ssl_prepare_client_hello_7
   \       0x5C   0x6BB8             LDR      R0,[R7, #+56]
   \       0x5E   0x7800             LDRB     R0,[R0, #+0]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD101             BNE.N    ??ssl_prepare_client_hello_6
    841                      session_id_len = 0;
   \                     ??ssl_prepare_client_hello_7: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x0006             MOVS     R6,R0
    842                  }
    843          
    844          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    845                  /*
    846                   * RFC 5077 section 3.4: "When presenting a ticket, the client MAY
    847                   * generate and include a Session ID in the TLS ClientHello."
    848                   */
    849                  int renegotiating = 0;
    850          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    851                  if (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE) {
    852                      renegotiating = 1;
    853                  }
    854          #endif
    855                  if (!renegotiating) {
    856                      if ((session_negotiate->ticket != NULL) &&
    857                          (session_negotiate->ticket_len != 0)) {
    858                          session_id_len = 32;
    859                      }
    860                  }
    861          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
    862              }
    863          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
    864          
    865          #if defined(MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE)
    866              if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
    867                  /*
    868                   * Create a legacy session identifier for the purpose of middlebox
    869                   * compatibility only if one has not been created already, which is
    870                   * the case if we are here for the TLS 1.3 second ClientHello.
    871                   *
    872                   * Versions of TLS before TLS 1.3 supported a "session resumption"
    873                   * feature which has been merged with pre-shared keys in TLS 1.3
    874                   * version. A client which has a cached session ID set by a pre-TLS 1.3
    875                   * server SHOULD set this field to that value. In compatibility mode,
    876                   * this field MUST be non-empty, so a client not offering a pre-TLS 1.3
    877                   * session MUST generate a new 32-byte value. This value need not be
    878                   * random but SHOULD be unpredictable to avoid implementations fixating
    879                   * on a specific value (also known as ossification). Otherwise, it MUST
    880                   * be set as a zero-length vector ( i.e., a zero-valued single byte
    881                   * length field ).
    882                   */
    883                  session_id_len = 32;
    884              }
    885          #endif /* MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE */
    886          
    887              if (session_id_len != session_negotiate->id_len) {
   \                     ??ssl_prepare_client_hello_6: (+1)
   \       0x68   0x68A8             LDR      R0,[R5, #+8]
   \       0x6A   0x4286             CMP      R6,R0
   \       0x6C   0xD00F             BEQ.N    ??ssl_prepare_client_hello_8
    888                  session_negotiate->id_len = session_id_len;
   \       0x6E   0x60AE             STR      R6,[R5, #+8]
    889                  if (session_id_len > 0) {
   \       0x70   0x2E00             CMP      R6,#+0
   \       0x72   0xD00C             BEQ.N    ??ssl_prepare_client_hello_8
    890                      ret = ssl->conf->f_rng(ssl->conf->p_rng,
    891                                             session_negotiate->id,
    892                                             session_id_len);
   \       0x74   0x0032             MOVS     R2,R6
   \       0x76   0xF115 0x010C      ADDS     R1,R5,#+12
   \       0x7A   0x6838             LDR      R0,[R7, #+0]
   \       0x7C   0x69C0             LDR      R0,[R0, #+28]
   \       0x7E   0x683B             LDR      R3,[R7, #+0]
   \       0x80   0x699B             LDR      R3,[R3, #+24]
   \       0x82   0x4798             BLX      R3
   \       0x84   0x0004             MOVS     R4,R0
    893                      if (ret != 0) {
   \       0x86   0x2C00             CMP      R4,#+0
   \       0x88   0xD001             BEQ.N    ??ssl_prepare_client_hello_8
    894                          MBEDTLS_SSL_DEBUG_RET(1, "creating session id failed", ret);
    895                          return ret;
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0xE000             B.N      ??ssl_prepare_client_hello_1
    896                      }
    897                  }
    898              }
    899          
    900          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && \
    901              defined(MBEDTLS_SSL_SESSION_TICKETS) && \
    902              defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    903              if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_3  &&
    904                  ssl->handshake->resume) {
    905                  int hostname_mismatch = ssl->hostname != NULL ||
    906                                          session_negotiate->hostname != NULL;
    907                  if (ssl->hostname != NULL && session_negotiate->hostname != NULL) {
    908                      hostname_mismatch = strcmp(
    909                          ssl->hostname, session_negotiate->hostname) != 0;
    910                  }
    911          
    912                  if (hostname_mismatch) {
    913                      MBEDTLS_SSL_DEBUG_MSG(
    914                          1, ("Hostname mismatch the session ticket, "
    915                              "disable session resumption."));
    916                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    917                  }
    918              } else {
    919                  return mbedtls_ssl_session_set_hostname(session_negotiate,
    920                                                          ssl->hostname);
    921              }
    922          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 &&
    923                    MBEDTLS_SSL_SESSION_TICKETS &&
    924                    MBEDTLS_SSL_SERVER_NAME_INDICATION */
    925          
    926              return 0;
   \                     ??ssl_prepare_client_hello_8: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \                     ??ssl_prepare_client_hello_1: (+1)
   \       0x90   0xBDF2             POP      {R1,R4-R7,PC}
    927          }
    928          /*
    929           * Write ClientHello handshake message.
    930           * Handler for MBEDTLS_SSL_CLIENT_HELLO
    931           */

   \                                 In section .text, align 2, keep-with-next
    932          int mbedtls_ssl_write_client_hello(mbedtls_ssl_context *ssl)
    933          {
   \                     mbedtls_ssl_write_client_hello: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0007             MOVS     R7,R0
    934              int ret = 0;
   \        0x6   0x2500             MOVS     R5,#+0
    935              unsigned char *buf;
    936              size_t buf_len, msg_len, binders_len;
    937          
    938              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write client hello"));
    939          
    940              MBEDTLS_SSL_PROC_CHK(ssl_prepare_client_hello(ssl));
   \        0x8   0x0038             MOVS     R0,R7
   \        0xA   0x.... 0x....      BL       ssl_prepare_client_hello
   \        0xE   0x0004             MOVS     R4,R0
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD139             BNE.N    ??mbedtls_ssl_write_client_hello_0
    941          
    942              MBEDTLS_SSL_PROC_CHK(mbedtls_ssl_start_handshake_msg(
    943                                       ssl, MBEDTLS_SSL_HS_CLIENT_HELLO,
    944                                       &buf, &buf_len));
   \                     ??mbedtls_ssl_write_client_hello_1: (+1)
   \       0x14   0xAB03             ADD      R3,SP,#+12
   \       0x16   0xAA02             ADD      R2,SP,#+8
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x0038             MOVS     R0,R7
   \       0x1C   0x.... 0x....      BL       mbedtls_ssl_start_handshake_msg
   \       0x20   0x0004             MOVS     R4,R0
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD130             BNE.N    ??mbedtls_ssl_write_client_hello_0
    945          
    946              MBEDTLS_SSL_PROC_CHK(ssl_write_client_hello_body(ssl, buf,
    947                                                               buf + buf_len,
    948                                                               &msg_len,
    949                                                               &binders_len));
   \                     ??mbedtls_ssl_write_client_hello_2: (+1)
   \       0x26   0xA804             ADD      R0,SP,#+16
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0xAB01             ADD      R3,SP,#+4
   \       0x2C   0x9902             LDR      R1,[SP, #+8]
   \       0x2E   0x9803             LDR      R0,[SP, #+12]
   \       0x30   0xEB01 0x0200      ADD      R2,R1,R0
   \       0x34   0x9902             LDR      R1,[SP, #+8]
   \       0x36   0x0038             MOVS     R0,R7
   \       0x38   0x.... 0x....      BL       ssl_write_client_hello_body
   \       0x3C   0x0004             MOVS     R4,R0
   \       0x3E   0x2C00             CMP      R4,#+0
   \       0x40   0xD122             BNE.N    ??mbedtls_ssl_write_client_hello_0
    950          
    951          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && defined(MBEDTLS_SSL_PROTO_DTLS)
    952              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
    953                  ssl->out_msglen = msg_len + 4;
    954                  mbedtls_ssl_send_flight_completed(ssl);
    955          
    956                  /*
    957                   * The two functions below may try to send data on the network and
    958                   * can return with the MBEDTLS_ERR_SSL_WANT_READ error code when they
    959                   * fail to do so and the transmission has to be retried later. In that
    960                   * case as in fatal error cases, we return immediately. But we must have
    961                   * set the handshake state to the next state at that point to ensure
    962                   * that we will not write and send again a ClientHello when we
    963                   * eventually succeed in sending the pending data.
    964                   */
    965                  mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
    966          
    967                  if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
    968                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
    969                      return ret;
    970                  }
    971          
    972                  if ((ret = mbedtls_ssl_flight_transmit(ssl)) != 0) {
    973                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_flight_transmit", ret);
    974                      return ret;
    975                  }
    976              } else
    977          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 && MBEDTLS_SSL_PROTO_DTLS */
    978              {
    979          
    980                  ret = mbedtls_ssl_add_hs_hdr_to_checksum(ssl,
    981                                                           MBEDTLS_SSL_HS_CLIENT_HELLO,
    982                                                           msg_len);
   \                     ??mbedtls_ssl_write_client_hello_3: (+1)
   \       0x42   0x9A01             LDR      R2,[SP, #+4]
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0x0038             MOVS     R0,R7
   \       0x48   0x.... 0x....      BL       mbedtls_ssl_add_hs_hdr_to_checksum
   \       0x4C   0x0005             MOVS     R5,R0
    983                  if (ret != 0) {
   \       0x4E   0x2D00             CMP      R5,#+0
   \       0x50   0xD001             BEQ.N    ??mbedtls_ssl_write_client_hello_4
    984                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_add_hs_hdr_to_checksum", ret);
    985                      return ret;
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0xE019             B.N      ??mbedtls_ssl_write_client_hello_5
    986                  }
    987                  ret = ssl->handshake->update_checksum(ssl, buf, msg_len - binders_len);
   \                     ??mbedtls_ssl_write_client_hello_4: (+1)
   \       0x56   0x9A01             LDR      R2,[SP, #+4]
   \       0x58   0x9804             LDR      R0,[SP, #+16]
   \       0x5A   0x1A12             SUBS     R2,R2,R0
   \       0x5C   0x9902             LDR      R1,[SP, #+8]
   \       0x5E   0x0038             MOVS     R0,R7
   \       0x60   0x6BBB             LDR      R3,[R7, #+56]
   \       0x62   0x68DB             LDR      R3,[R3, #+12]
   \       0x64   0x4798             BLX      R3
   \       0x66   0x0006             MOVS     R6,R0
    988                  if (ret != 0) {
   \       0x68   0x2E00             CMP      R6,#+0
   \       0x6A   0xD001             BEQ.N    ??mbedtls_ssl_write_client_hello_6
    989                      MBEDTLS_SSL_DEBUG_RET(1, "update_checksum", ret);
    990                      return ret;
   \       0x6C   0x0030             MOVS     R0,R6
   \       0x6E   0xE00C             B.N      ??mbedtls_ssl_write_client_hello_5
    991                  }
    992          #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_PSK_ENABLED)
    993                  if (binders_len > 0) {
    994                      MBEDTLS_SSL_PROC_CHK(
    995                          mbedtls_ssl_tls13_write_binders_of_pre_shared_key_ext(
    996                              ssl, buf + msg_len - binders_len, buf + msg_len));
    997                      ret = ssl->handshake->update_checksum(ssl, buf + msg_len - binders_len,
    998                                                            binders_len);
    999                      if (ret != 0) {
   1000                          MBEDTLS_SSL_DEBUG_RET(1, "update_checksum", ret);
   1001                          return ret;
   1002                      }
   1003                  }
   1004          #endif /* MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_PSK_ENABLED */
   1005          
   1006                  MBEDTLS_SSL_PROC_CHK(mbedtls_ssl_finish_handshake_msg(ssl,
   1007                                                                        buf_len,
   1008                                                                        msg_len));
   \                     ??mbedtls_ssl_write_client_hello_6: (+1)
   \       0x70   0x9A01             LDR      R2,[SP, #+4]
   \       0x72   0x9903             LDR      R1,[SP, #+12]
   \       0x74   0x0038             MOVS     R0,R7
   \       0x76   0x.... 0x....      BL       mbedtls_ssl_finish_handshake_msg
   \       0x7A   0x0004             MOVS     R4,R0
   \       0x7C   0x2C00             CMP      R4,#+0
   \       0x7E   0xD103             BNE.N    ??mbedtls_ssl_write_client_hello_0
   1009          
   1010                  /*
   1011                   * Set next state. Note that if TLS 1.3 is proposed, this may be
   1012                   * overwritten by mbedtls_ssl_tls13_finalize_client_hello().
   1013                   */
   1014                  mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
   \                     ??mbedtls_ssl_write_client_hello_7: (+1)
   \       0x80   0x2102             MOVS     R1,#+2
   \       0x82   0x0038             MOVS     R0,R7
   \       0x84   0x.... 0x....      BL       mbedtls_ssl_handshake_set_state
   1015          
   1016          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   1017                  if (ssl->handshake->min_tls_version <=  MBEDTLS_SSL_VERSION_TLS1_3 &&
   1018                      MBEDTLS_SSL_VERSION_TLS1_3 <= ssl->tls_version) {
   1019                      ret = mbedtls_ssl_tls13_finalize_client_hello(ssl);
   1020                  }
   1021          #endif
   1022              }
   1023          
   1024          cleanup:
   1025          
   1026              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write client hello"));
   1027              return ret;
   \                     ??mbedtls_ssl_write_client_hello_0: (+1)
   \       0x88   0x0020             MOVS     R0,R4
   \                     ??mbedtls_ssl_write_client_hello_5: (+1)
   \       0x8A   0xB005             ADD      SP,SP,#+20
   \       0x8C   0xBDF0             POP      {R4-R7,PC}
   1028          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0xFFFF'9600        DC32     0xffff9600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0xFFFF'A180        DC32     0xffffa180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     mbedtls_byte_order_detector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0xFFFF'9400        DC32     0xffff9400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0xFFFF'8C00        DC32     0xffff8c00
   1029          
   1030          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 || MBEDTLS_SSL_PROTO_TLS1_2 */
   1031          #endif /* MBEDTLS_SSL_CLI_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_bswap16
      24   mbedtls_put_unaligned_uint16
        24   -> __aeabi_memcpy
       0   mbedtls_ssl_chk_buf_ptr
       0   mbedtls_ssl_get_groups
       0   mbedtls_ssl_handshake_set_state
       0   mbedtls_ssl_tls12_named_group_is_ecdhe
      40   mbedtls_ssl_write_client_hello
        40   -- Indirect call
        40   -> mbedtls_ssl_add_hs_hdr_to_checksum
        40   -> mbedtls_ssl_finish_handshake_msg
        40   -> mbedtls_ssl_handshake_set_state
        40   -> mbedtls_ssl_start_handshake_msg
        40   -> ssl_prepare_client_hello
        40   -> ssl_write_client_hello_body
      24   ssl_generate_random
        24   -- Indirect call
      24   ssl_prepare_client_hello
        24   -- Indirect call
        24   -> ssl_generate_random
      64   ssl_write_client_hello_body
        64   -> __aeabi_memcpy
        64   -> mbedtls_bswap16
        64   -> mbedtls_put_unaligned_uint16
        64   -> mbedtls_ssl_chk_buf_ptr
        64   -> mbedtls_ssl_tls12_write_client_hello_exts
        64   -> mbedtls_ssl_write_sig_alg_ext
        64   -> mbedtls_ssl_write_version
        64   -> ssl_write_client_hello_cipher_suites
        64   -> ssl_write_supported_groups_ext
      48   ssl_write_client_hello_cipher_suites
        48   -> mbedtls_bswap16
        48   -> mbedtls_put_unaligned_uint16
        48   -> mbedtls_ssl_chk_buf_ptr
        48   -> mbedtls_ssl_ciphersuite_from_id
        48   -> mbedtls_ssl_ciphersuite_uses_ec
        48   -> mbedtls_ssl_validate_ciphersuite
      48   ssl_write_supported_groups_ext
        48   -> mbedtls_bswap16
        48   -> mbedtls_put_unaligned_uint16
        48   -> mbedtls_ssl_chk_buf_ptr
        48   -> mbedtls_ssl_get_ecp_group_id_from_tls_id
        48   -> mbedtls_ssl_get_groups
        48   -> mbedtls_ssl_tls12_named_group_is_ecdhe


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
      16  mbedtls_bswap16
       2  mbedtls_byte_order_detector
      22  mbedtls_put_unaligned_uint16
      20  mbedtls_ssl_chk_buf_ptr
      26  mbedtls_ssl_get_groups
       8  mbedtls_ssl_handshake_set_state
     112  mbedtls_ssl_tls12_named_group_is_ecdhe
     142  mbedtls_ssl_write_client_hello
      36  ssl_generate_random
     146  ssl_prepare_client_hello
     520  ssl_write_client_hello_body
     320  ssl_write_client_hello_cipher_suites
     322  ssl_write_supported_groups_ext

 
     2 bytes in section .rodata
 1'710 bytes in section .text
 
 1'688 bytes of CODE  memory (+ 22 bytes shared)
     2 bytes of CONST memory

Errors: none
Warnings: 1
