###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:54:07
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\printf.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\printf_3531763822335253954.dir\printf.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\printf.c" -D
#        DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\printf_3531763822335253954.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\printf_3531763822335253954.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\printf_3531763822335253954.dir\printf.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\printf_3531763822335253954.dir\printf.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\printf_3531763822335253954.dir\printf.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\printf.c
      1          ///////////////////////////////////////////////////////////////////////////////
      2          // \author (c) Marco Paland (info@paland.com)
      3          //             2014-2019, PALANDesign Hannover, Germany
      4          //
      5          // \license The MIT License (MIT)
      6          //
      7          // Permission is hereby granted, free of charge, to any person obtaining a copy
      8          // of this software and associated documentation files (the "Software"), to deal
      9          // in the Software without restriction, including without limitation the rights
     10          // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     11          // copies of the Software, and to permit persons to whom the Software is
     12          // furnished to do so, subject to the following conditions:
     13          //
     14          // The above copyright notice and this permission notice shall be included in
     15          // all copies or substantial portions of the Software.
     16          //
     17          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     18          // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     19          // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     20          // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     21          // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     22          // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     23          // THE SOFTWARE.
     24          //
     25          // \brief Tiny printf, sprintf and (v)snprintf implementation, optimized for speed on
     26          //        embedded systems with a very limited resources. These routines are thread
     27          //        safe and reentrant!
     28          //        Use this instead of the bloated standard/newlib printf cause these use
     29          //        malloc for printf (and may not be thread safe).
     30          //
     31          ///////////////////////////////////////////////////////////////////////////////
     32          
     33          #include <stdbool.h>
     34          #include <stdint.h>
     35          
     36          #include "printf.h"
     37          
     38          // __copy__ attribute was introduced in GCC9
     39          #if defined(__GNUC__) && __GNUC__ >= 9
     40          #define __copy(symbol) __attribute__((__copy__(symbol)))
     41          #else
     42          #define __copy(symbol)
     43          #endif
     44          
     45          // define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the
     46          // printf_config.h header file
     47          // default: undefined
     48          #ifdef PRINTF_INCLUDE_CONFIG_H
     49          #include "printf_config.h"
     50          #endif
     51          
     52          
     53          // 'ntoa' conversion buffer size, this must be big enough to hold one converted
     54          // numeric number including padded zeros (dynamically created on stack)
     55          // default: 32 byte
     56          #ifndef PRINTF_NTOA_BUFFER_SIZE
     57          #define PRINTF_NTOA_BUFFER_SIZE    32U
     58          #endif
     59          
     60          // 'ftoa' conversion buffer size, this must be big enough to hold one converted
     61          // float number including padded zeros (dynamically created on stack)
     62          // default: 32 byte
     63          #ifndef PRINTF_FTOA_BUFFER_SIZE
     64          #define PRINTF_FTOA_BUFFER_SIZE    32U
     65          #endif
     66          
     67          // support for the floating point type (%f)
     68          // default: activated
     69          #ifndef PRINTF_DISABLE_SUPPORT_FLOAT
     70          #define PRINTF_SUPPORT_FLOAT
     71          #endif
     72          
     73          // support for exponential floating point notation (%e/%g)
     74          // default: activated
     75          #ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL
     76          #define PRINTF_SUPPORT_EXPONENTIAL
     77          #endif
     78          
     79          // define the default floating point precision
     80          // default: 6 digits
     81          #ifndef PRINTF_DEFAULT_FLOAT_PRECISION
     82          #define PRINTF_DEFAULT_FLOAT_PRECISION  6U
     83          #endif
     84          
     85          // define the largest float suitable to print with %f
     86          // default: 1e9
     87          #ifndef PRINTF_MAX_FLOAT
     88          #define PRINTF_MAX_FLOAT  1e9
     89          #endif
     90          
     91          // support for the long long types (%llu or %p)
     92          // default: activated
     93          #ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG
     94          #define PRINTF_SUPPORT_LONG_LONG
     95          #endif
     96          
     97          // support for the ptrdiff_t type (%t)
     98          // ptrdiff_t is normally defined in <stddef.h> as long or long long type
     99          // default: activated
    100          #ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T
    101          #define PRINTF_SUPPORT_PTRDIFF_T
    102          #endif
    103          
    104          ///////////////////////////////////////////////////////////////////////////////
    105          
    106          // internal flag definitions
    107          #define FLAGS_ZEROPAD   (1U <<  0U)
    108          #define FLAGS_LEFT      (1U <<  1U)
    109          #define FLAGS_PLUS      (1U <<  2U)
    110          #define FLAGS_SPACE     (1U <<  3U)
    111          #define FLAGS_HASH      (1U <<  4U)
    112          #define FLAGS_UPPERCASE (1U <<  5U)
    113          #define FLAGS_CHAR      (1U <<  6U)
    114          #define FLAGS_SHORT     (1U <<  7U)
    115          #define FLAGS_LONG      (1U <<  8U)
    116          #define FLAGS_LONG_LONG (1U <<  9U)
    117          #define FLAGS_PRECISION (1U << 10U)
    118          #define FLAGS_ADAPT_EXP (1U << 11U)
    119          
    120          
    121          // import float.h for DBL_MAX
    122          #if defined(PRINTF_SUPPORT_FLOAT)
    123          #include <float.h>
    124          #endif
    125          
    126          
    127          // output function type
    128          typedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);
    129          
    130          
    131          // wrapper (used as buffer) for output function type
    132          typedef struct {
    133            void  (*fct)(char character, void* arg);
    134            void* arg;
    135          } out_fct_wrap_type;
    136          
    137          
    138          // internal buffer output

   \                                 In section .text, align 2, keep-with-next
    139          static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
    140          {
    141            if (idx < maxlen) {
   \                     _out_buffer: (+1)
   \        0x0   0x429A             CMP      R2,R3
   \        0x2   0xD200             BCS.N    ??_out_buffer_0
    142              ((char*)buffer)[idx] = character;
   \        0x4   0x5488             STRB     R0,[R1, R2]
    143            }
    144          }
   \                     ??_out_buffer_0: (+1)
   \        0x6   0x4770             BX       LR
    145          
    146          
    147          // internal null output

   \                                 In section .text, align 2, keep-with-next
    148          static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
    149          {
    150            (void)character; (void)buffer; (void)idx; (void)maxlen;
    151          }
   \                     _out_null: (+1)
   \        0x0   0x4770             BX       LR
    152          
    153          
    154          // internal _putchar wrapper

   \                                 In section .text, align 2, keep-with-next
    155          static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
    156          {
   \                     _out_char: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001E             MOVS     R6,R3
    157            (void)buffer; (void)idx; (void)maxlen;
    158            if (character) {
   \        0xA   0x0038             MOVS     R0,R7
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD003             BEQ.N    ??_out_char_0
    159              _putchar(character);
   \       0x12   0x0038             MOVS     R0,R7
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x.... 0x....      BL       _putchar
    160            }
    161          }
   \                     ??_out_char_0: (+1)
   \       0x1A   0xBDF1             POP      {R0,R4-R7,PC}
    162          
    163          
    164          // internal output function wrapper

   \                                 In section .text, align 2, keep-with-next
    165          static inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)
    166          {
   \                     _out_fct: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
    167            (void)idx; (void)maxlen;
    168            if (character) {
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD004             BEQ.N    ??_out_fct_0
    169              // buffer is the output fct pointer
    170              ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
   \       0x12   0x6869             LDR      R1,[R5, #+4]
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x682A             LDR      R2,[R5, #+0]
   \       0x1A   0x4790             BLX      R2
    171            }
    172          }
   \                     ??_out_fct_0: (+1)
   \       0x1C   0xBDF1             POP      {R0,R4-R7,PC}
    173          
    174          
    175          // internal secure strlen
    176          // \return The length of the string (excluding the terminating 0) limited by 'maxsize'

   \                                 In section .text, align 2, keep-with-next
    177          static inline unsigned int _strnlen_s(const char* str, size_t maxsize)
    178          {
    179            const char* s;
    180            for (s = str; *s && maxsize--; ++s);
   \                     _strnlen_s: (+1)
   \        0x0   0x0003             MOVS     R3,R0
   \                     ??_strnlen_s_0: (+1)
   \        0x2   0x781A             LDRB     R2,[R3, #+0]
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD005             BEQ.N    ??_strnlen_s_1
   \        0x8   0x000A             MOVS     R2,R1
   \        0xA   0x1E51             SUBS     R1,R2,#+1
   \        0xC   0x2A00             CMP      R2,#+0
   \        0xE   0xD001             BEQ.N    ??_strnlen_s_1
   \       0x10   0x1C5B             ADDS     R3,R3,#+1
   \       0x12   0xE7F6             B.N      ??_strnlen_s_0
    181            return (unsigned int)(s - str);
   \                     ??_strnlen_s_1: (+1)
   \       0x14   0x1A18             SUBS     R0,R3,R0
   \       0x16   0x4770             BX       LR
    182          }
    183          
    184          
    185          // internal test if char is a digit (0-9)
    186          // \return true if char is a digit

   \                                 In section .text, align 2, keep-with-next
    187          static inline bool _is_digit(char ch)
    188          {
    189            return (ch >= '0') && (ch <= '9');
   \                     _is_digit: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2930             CMP      R1,#+48
   \        0x6   0xDB04             BLT.N    ??_is_digit_0
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x283A             CMP      R0,#+58
   \        0xC   0xDA01             BGE.N    ??_is_digit_0
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE000             B.N      ??_is_digit_1
   \                     ??_is_digit_0: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \                     ??_is_digit_1: (+1)
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x4770             BX       LR
    190          }
    191          
    192          
    193          // internal ASCII string to unsigned int conversion

   \                                 In section .text, align 2, keep-with-next
    194          static unsigned int _atoi(const char** str)
    195          {
   \                     _atoi: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    196            unsigned int i = 0U;
   \        0x4   0x2500             MOVS     R5,#+0
    197            while (_is_digit(**str)) {
   \                     ??_atoi_0: (+1)
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0x.... 0x....      BL       _is_digit
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD008             BEQ.N    ??_atoi_1
    198              i = i * 10U + (unsigned int)(*((*str)++) - '0');
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0x1C48             ADDS     R0,R1,#+1
   \       0x16   0x6020             STR      R0,[R4, #+0]
   \       0x18   0x200A             MOVS     R0,#+10
   \       0x1A   0x7809             LDRB     R1,[R1, #+0]
   \       0x1C   0x3930             SUBS     R1,R1,#+48
   \       0x1E   0xFB00 0x1505      MLA      R5,R0,R5,R1
   \       0x22   0xE7F0             B.N      ??_atoi_0
    199            }
    200            return i;
   \                     ??_atoi_1: (+1)
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
    201          }
    202          
    203          
    204          // output the specified string in reverse, taking care of any zero-padding

   \                                 In section .text, align 2, keep-with-next
    205          static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
    206          {
   \                     _out_rev: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0x9C0B             LDR      R4,[SP, #+44]
   \        0xE   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \       0x12   0xF8DD 0x9034      LDR      R9,[SP, #+52]
    207            const size_t start_idx = idx;
   \       0x16   0x9600             STR      R6,[SP, #+0]
    208          
    209            // pad spaces up to given width
    210            if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   \       0x18   0xF019 0x0F03      TST      R9,#0x3
   \       0x1C   0xD10B             BNE.N    ??_out_rev_0
    211              for (size_t i = len; i < width; i++) {
   \       0x1E   0x46A3             MOV      R11,R4
   \                     ??_out_rev_1: (+1)
   \       0x20   0x45C3             CMP      R11,R8
   \       0x22   0xD208             BCS.N    ??_out_rev_0
    212                out(' ', buffer, idx++, maxlen);
   \       0x24   0x003B             MOVS     R3,R7
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0x2020             MOVS     R0,#+32
   \       0x2C   0x47D0             BLX      R10
   \       0x2E   0x1C76             ADDS     R6,R6,#+1
    213              }
   \       0x30   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \       0x34   0xE7F4             B.N      ??_out_rev_1
    214            }
    215          
    216            // reverse string
    217            while (len) {
   \                     ??_out_rev_0: (+1)
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD008             BEQ.N    ??_out_rev_2
    218              out(buf[--len], buffer, idx++, maxlen);
   \       0x3A   0x1E64             SUBS     R4,R4,#+1
   \       0x3C   0x003B             MOVS     R3,R7
   \       0x3E   0x0032             MOVS     R2,R6
   \       0x40   0x0029             MOVS     R1,R5
   \       0x42   0x980A             LDR      R0,[SP, #+40]
   \       0x44   0x5D00             LDRB     R0,[R0, R4]
   \       0x46   0x47D0             BLX      R10
   \       0x48   0x1C76             ADDS     R6,R6,#+1
   \       0x4A   0xE7F4             B.N      ??_out_rev_0
    219            }
    220          
    221            // append pad spaces up to given width
    222            if (flags & FLAGS_LEFT) {
   \                     ??_out_rev_2: (+1)
   \       0x4C   0xEA5F 0x7089      LSLS     R0,R9,#+30
   \       0x50   0xD50A             BPL.N    ??_out_rev_3
    223              while (idx - start_idx < width) {
   \                     ??_out_rev_4: (+1)
   \       0x52   0x9800             LDR      R0,[SP, #+0]
   \       0x54   0x1A30             SUBS     R0,R6,R0
   \       0x56   0x4540             CMP      R0,R8
   \       0x58   0xD206             BCS.N    ??_out_rev_3
    224                out(' ', buffer, idx++, maxlen);
   \       0x5A   0x003B             MOVS     R3,R7
   \       0x5C   0x0032             MOVS     R2,R6
   \       0x5E   0x0029             MOVS     R1,R5
   \       0x60   0x2020             MOVS     R0,#+32
   \       0x62   0x47D0             BLX      R10
   \       0x64   0x1C76             ADDS     R6,R6,#+1
   \       0x66   0xE7F4             B.N      ??_out_rev_4
    225              }
    226            }
    227          
    228            return idx;
   \                     ??_out_rev_3: (+1)
   \       0x68   0x0030             MOVS     R0,R6
   \       0x6A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    229          }
    230          
    231          
    232          // internal itoa format

   \                                 In section .text, align 2, keep-with-next
    233          static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
    234          {
   \                     _ntoa_format: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x469B             MOV      R11,R3
   \        0x8   0x9F10             LDR      R7,[SP, #+64]
   \        0xA   0x9C11             LDR      R4,[SP, #+68]
   \        0xC   0x9E12             LDR      R6,[SP, #+72]
   \        0xE   0xF8DD 0x804C      LDR      R8,[SP, #+76]
   \       0x12   0xF8DD 0x9050      LDR      R9,[SP, #+80]
   \       0x16   0x9D15             LDR      R5,[SP, #+84]
   \       0x18   0xF8DD 0xA058      LDR      R10,[SP, #+88]
    235            // pad leading zeros
    236            if (!(flags & FLAGS_LEFT)) {
   \       0x1C   0xEA5F 0x708A      LSLS     R0,R10,#+30
   \       0x20   0xD41F             BMI.N    ??_ntoa_format_0
    237              if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD00A             BEQ.N    ??_ntoa_format_1
   \       0x26   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \       0x2A   0xD507             BPL.N    ??_ntoa_format_1
   \       0x2C   0x0030             MOVS     R0,R6
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD102             BNE.N    ??_ntoa_format_2
   \       0x34   0xF01A 0x0F0C      TST      R10,#0xC
   \       0x38   0xD000             BEQ.N    ??_ntoa_format_1
    238                width--;
   \                     ??_ntoa_format_2: (+1)
   \       0x3A   0x1E6D             SUBS     R5,R5,#+1
    239              }
    240              while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   \                     ??_ntoa_format_1: (+1)
   \       0x3C   0x454C             CMP      R4,R9
   \       0x3E   0xD205             BCS.N    ??_ntoa_format_3
   \       0x40   0x2C20             CMP      R4,#+32
   \       0x42   0xD203             BCS.N    ??_ntoa_format_3
    241                buf[len++] = '0';
   \       0x44   0x2030             MOVS     R0,#+48
   \       0x46   0x5538             STRB     R0,[R7, R4]
   \       0x48   0x1C64             ADDS     R4,R4,#+1
   \       0x4A   0xE7F7             B.N      ??_ntoa_format_1
    242              }
    243              while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   \                     ??_ntoa_format_3: (+1)
   \       0x4C   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \       0x50   0xD507             BPL.N    ??_ntoa_format_0
   \       0x52   0x42AC             CMP      R4,R5
   \       0x54   0xD205             BCS.N    ??_ntoa_format_0
   \       0x56   0x2C20             CMP      R4,#+32
   \       0x58   0xD203             BCS.N    ??_ntoa_format_0
    244                buf[len++] = '0';
   \       0x5A   0x2030             MOVS     R0,#+48
   \       0x5C   0x5538             STRB     R0,[R7, R4]
   \       0x5E   0x1C64             ADDS     R4,R4,#+1
   \       0x60   0xE7F4             B.N      ??_ntoa_format_3
    245              }
    246            }
    247          
    248            // handle hash
    249            if (flags & FLAGS_HASH) {
   \                     ??_ntoa_format_0: (+1)
   \       0x62   0xEA5F 0x60CA      LSLS     R0,R10,#+27
   \       0x66   0xD534             BPL.N    ??_ntoa_format_4
    250              if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
   \       0x68   0xEA5F 0x504A      LSLS     R0,R10,#+21
   \       0x6C   0xD40C             BMI.N    ??_ntoa_format_5
   \       0x6E   0x2C00             CMP      R4,#+0
   \       0x70   0xD00A             BEQ.N    ??_ntoa_format_5
   \       0x72   0x454C             CMP      R4,R9
   \       0x74   0xD001             BEQ.N    ??_ntoa_format_6
   \       0x76   0x42AC             CMP      R4,R5
   \       0x78   0xD106             BNE.N    ??_ntoa_format_5
    251                len--;
   \                     ??_ntoa_format_6: (+1)
   \       0x7A   0x1E64             SUBS     R4,R4,#+1
    252                if (len && (base == 16U)) {
   \       0x7C   0x2C00             CMP      R4,#+0
   \       0x7E   0xD003             BEQ.N    ??_ntoa_format_5
   \       0x80   0xF1B8 0x0F10      CMP      R8,#+16
   \       0x84   0xD100             BNE.N    ??_ntoa_format_5
    253                  len--;
   \       0x86   0x1E64             SUBS     R4,R4,#+1
    254                }
    255              }
    256              if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   \                     ??_ntoa_format_5: (+1)
   \       0x88   0xF1B8 0x0F10      CMP      R8,#+16
   \       0x8C   0xD108             BNE.N    ??_ntoa_format_7
   \       0x8E   0xEA5F 0x608A      LSLS     R0,R10,#+26
   \       0x92   0xD405             BMI.N    ??_ntoa_format_7
   \       0x94   0x2C20             CMP      R4,#+32
   \       0x96   0xD203             BCS.N    ??_ntoa_format_7
    257                buf[len++] = 'x';
   \       0x98   0x2078             MOVS     R0,#+120
   \       0x9A   0x5538             STRB     R0,[R7, R4]
   \       0x9C   0x1C64             ADDS     R4,R4,#+1
   \       0x9E   0xE013             B.N      ??_ntoa_format_8
    258              }
    259              else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   \                     ??_ntoa_format_7: (+1)
   \       0xA0   0xF1B8 0x0F10      CMP      R8,#+16
   \       0xA4   0xD108             BNE.N    ??_ntoa_format_9
   \       0xA6   0xEA5F 0x608A      LSLS     R0,R10,#+26
   \       0xAA   0xD505             BPL.N    ??_ntoa_format_9
   \       0xAC   0x2C20             CMP      R4,#+32
   \       0xAE   0xD203             BCS.N    ??_ntoa_format_9
    260                buf[len++] = 'X';
   \       0xB0   0x2058             MOVS     R0,#+88
   \       0xB2   0x5538             STRB     R0,[R7, R4]
   \       0xB4   0x1C64             ADDS     R4,R4,#+1
   \       0xB6   0xE007             B.N      ??_ntoa_format_8
    261              }
    262              else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   \                     ??_ntoa_format_9: (+1)
   \       0xB8   0xF1B8 0x0F02      CMP      R8,#+2
   \       0xBC   0xD104             BNE.N    ??_ntoa_format_8
   \       0xBE   0x2C20             CMP      R4,#+32
   \       0xC0   0xD202             BCS.N    ??_ntoa_format_8
    263                buf[len++] = 'b';
   \       0xC2   0x2062             MOVS     R0,#+98
   \       0xC4   0x5538             STRB     R0,[R7, R4]
   \       0xC6   0x1C64             ADDS     R4,R4,#+1
    264              }
    265              if (len < PRINTF_NTOA_BUFFER_SIZE) {
   \                     ??_ntoa_format_8: (+1)
   \       0xC8   0x2C20             CMP      R4,#+32
   \       0xCA   0xD202             BCS.N    ??_ntoa_format_4
    266                buf[len++] = '0';
   \       0xCC   0x2030             MOVS     R0,#+48
   \       0xCE   0x5538             STRB     R0,[R7, R4]
   \       0xD0   0x1C64             ADDS     R4,R4,#+1
    267              }
    268            }
    269          
    270            if (len < PRINTF_NTOA_BUFFER_SIZE) {
   \                     ??_ntoa_format_4: (+1)
   \       0xD2   0x2C20             CMP      R4,#+32
   \       0xD4   0xD214             BCS.N    ??_ntoa_format_10
    271              if (negative) {
   \       0xD6   0x0030             MOVS     R0,R6
   \       0xD8   0xB2C0             UXTB     R0,R0
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD003             BEQ.N    ??_ntoa_format_11
    272                buf[len++] = '-';
   \       0xDE   0x202D             MOVS     R0,#+45
   \       0xE0   0x5538             STRB     R0,[R7, R4]
   \       0xE2   0x1C64             ADDS     R4,R4,#+1
   \       0xE4   0xE00C             B.N      ??_ntoa_format_10
    273              }
    274              else if (flags & FLAGS_PLUS) {
   \                     ??_ntoa_format_11: (+1)
   \       0xE6   0xEA5F 0x704A      LSLS     R0,R10,#+29
   \       0xEA   0xD503             BPL.N    ??_ntoa_format_12
    275                buf[len++] = '+';  // ignore the space if the '+' exists
   \       0xEC   0x202B             MOVS     R0,#+43
   \       0xEE   0x5538             STRB     R0,[R7, R4]
   \       0xF0   0x1C64             ADDS     R4,R4,#+1
   \       0xF2   0xE005             B.N      ??_ntoa_format_10
    276              }
    277              else if (flags & FLAGS_SPACE) {
   \                     ??_ntoa_format_12: (+1)
   \       0xF4   0xEA5F 0x700A      LSLS     R0,R10,#+28
   \       0xF8   0xD502             BPL.N    ??_ntoa_format_10
    278                buf[len++] = ' ';
   \       0xFA   0x2020             MOVS     R0,#+32
   \       0xFC   0x5538             STRB     R0,[R7, R4]
   \       0xFE   0x1C64             ADDS     R4,R4,#+1
    279              }
    280            }
    281          
    282            return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
   \                     ??_ntoa_format_10: (+1)
   \      0x100   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \      0x104   0x9502             STR      R5,[SP, #+8]
   \      0x106   0x9401             STR      R4,[SP, #+4]
   \      0x108   0x9700             STR      R7,[SP, #+0]
   \      0x10A   0x465B             MOV      R3,R11
   \      0x10C   0x9A06             LDR      R2,[SP, #+24]
   \      0x10E   0x9905             LDR      R1,[SP, #+20]
   \      0x110   0x9804             LDR      R0,[SP, #+16]
   \      0x112   0x.... 0x....      BL       _out_rev
   \      0x116   0xB007             ADD      SP,SP,#+28
   \      0x118   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    283          }
    284          
    285          
    286          // internal itoa for 'long' type

   \                                 In section .text, align 2, keep-with-next
    287          static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
    288          {
   \                     _ntoa_long: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0x9C18             LDR      R4,[SP, #+96]
   \       0x10   0xF8DD 0x8068      LDR      R8,[SP, #+104]
   \       0x14   0xF8DD 0x9074      LDR      R9,[SP, #+116]
    289            char buf[PRINTF_NTOA_BUFFER_SIZE];
    290            size_t len = 0U;
   \       0x18   0xF05F 0x0A00      MOVS     R10,#+0
    291          
    292            // no hash for 0 values
    293            if (!value) {
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD101             BNE.N    ??_ntoa_long_0
    294              flags &= ~FLAGS_HASH;
   \       0x20   0xF039 0x0910      BICS     R9,R9,#0x10
    295            }
    296          
    297            // write if precision != 0 and value is != 0
    298            if (!(flags & FLAGS_PRECISION) || value) {
   \                     ??_ntoa_long_0: (+1)
   \       0x24   0xEA5F 0x5049      LSLS     R0,R9,#+21
   \       0x28   0xD501             BPL.N    ??_ntoa_long_1
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD01F             BEQ.N    ??_ntoa_long_2
    299              do {
    300                const char digit = (char)(value % base);
   \                     ??_ntoa_long_1: (+1)
   \       0x2E   0xFBB4 0xF0F8      UDIV     R0,R4,R8
   \       0x32   0xFB08 0x4010      MLS      R0,R8,R0,R4
    301                buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   \       0x36   0x4651             MOV      R1,R10
   \       0x38   0xF111 0x0A01      ADDS     R10,R1,#+1
   \       0x3C   0x0002             MOVS     R2,R0
   \       0x3E   0xB2D2             UXTB     R2,R2
   \       0x40   0x2A0A             CMP      R2,#+10
   \       0x42   0xDA02             BGE.N    ??_ntoa_long_3
   \       0x44   0xF110 0x0330      ADDS     R3,R0,#+48
   \       0x48   0xE008             B.N      ??_ntoa_long_4
   \                     ??_ntoa_long_3: (+1)
   \       0x4A   0xEA5F 0x6289      LSLS     R2,R9,#+26
   \       0x4E   0xD501             BPL.N    ??_ntoa_long_5
   \       0x50   0x2241             MOVS     R2,#+65
   \       0x52   0xE000             B.N      ??_ntoa_long_6
   \                     ??_ntoa_long_5: (+1)
   \       0x54   0x2261             MOVS     R2,#+97
   \                     ??_ntoa_long_6: (+1)
   \       0x56   0x1882             ADDS     R2,R0,R2
   \       0x58   0xF1B2 0x030A      SUBS     R3,R2,#+10
   \                     ??_ntoa_long_4: (+1)
   \       0x5C   0xAA07             ADD      R2,SP,#+28
   \       0x5E   0x5453             STRB     R3,[R2, R1]
    302                value /= base;
   \       0x60   0xFBB4 0xF4F8      UDIV     R4,R4,R8
    303              } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   \       0x64   0x2C00             CMP      R4,#+0
   \       0x66   0xD002             BEQ.N    ??_ntoa_long_2
   \       0x68   0xF1BA 0x0F20      CMP      R10,#+32
   \       0x6C   0xD3DF             BCC.N    ??_ntoa_long_1
    304            }
    305          
    306            return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   \                     ??_ntoa_long_2: (+1)
   \       0x6E   0xF8CD 0x9018      STR      R9,[SP, #+24]
   \       0x72   0x981C             LDR      R0,[SP, #+112]
   \       0x74   0x9005             STR      R0,[SP, #+20]
   \       0x76   0x981B             LDR      R0,[SP, #+108]
   \       0x78   0x9004             STR      R0,[SP, #+16]
   \       0x7A   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x7E   0xF89D 0x0064      LDRB     R0,[SP, #+100]
   \       0x82   0x9002             STR      R0,[SP, #+8]
   \       0x84   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0x88   0xA807             ADD      R0,SP,#+28
   \       0x8A   0x9000             STR      R0,[SP, #+0]
   \       0x8C   0x003B             MOVS     R3,R7
   \       0x8E   0x0032             MOVS     R2,R6
   \       0x90   0x0029             MOVS     R1,R5
   \       0x92   0x4658             MOV      R0,R11
   \       0x94   0x.... 0x....      BL       _ntoa_format
   \       0x98   0xB00F             ADD      SP,SP,#+60
   \       0x9A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    307          }
    308          
    309          
    310          // internal itoa for 'long long' type
    311          #if defined(PRINTF_SUPPORT_LONG_LONG)

   \                                 In section .text, align 2, keep-with-next
    312          static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
    313          {
   \                     _ntoa_long_long: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB090             SUB      SP,SP,#+64
   \        0x6   0x469A             MOV      R10,R3
   \        0x8   0xE9DD 0x451C      LDRD     R4,R5,[SP, #+112]
   \        0xC   0xE9DD 0x8920      LDRD     R8,R9,[SP, #+128]
   \       0x10   0x9F24             LDR      R7,[SP, #+144]
    314            char buf[PRINTF_NTOA_BUFFER_SIZE];
    315            size_t len = 0U;
   \       0x12   0x2600             MOVS     R6,#+0
    316          
    317            // no hash for 0 values
    318            if (!value) {
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD103             BNE.N    ??_ntoa_long_long_0
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD101             BNE.N    ??_ntoa_long_long_0
    319              flags &= ~FLAGS_HASH;
   \       0x1C   0xF037 0x0710      BICS     R7,R7,#0x10
    320            }
    321          
    322            // write if precision != 0 and value is != 0
    323            if (!(flags & FLAGS_PRECISION) || value) {
   \                     ??_ntoa_long_long_0: (+1)
   \       0x20   0x0578             LSLS     R0,R7,#+21
   \       0x22   0xD503             BPL.N    ??_ntoa_long_long_1
   \       0x24   0x2D00             CMP      R5,#+0
   \       0x26   0xD101             BNE.N    ??_ntoa_long_long_2
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD028             BEQ.N    ??_ntoa_long_long_3
    324              do {
    325                const char digit = (char)(value % base);
   \                     ??_ntoa_long_long_2: (+1)
   \                     ??_ntoa_long_long_1: (+1)
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x0029             MOVS     R1,R5
   \       0x30   0x4642             MOV      R2,R8
   \       0x32   0x464B             MOV      R3,R9
   \       0x34   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x38   0x4693             MOV      R11,R2
    326                buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   \       0x3A   0x0030             MOVS     R0,R6
   \       0x3C   0x1C46             ADDS     R6,R0,#+1
   \       0x3E   0x4659             MOV      R1,R11
   \       0x40   0xB2C9             UXTB     R1,R1
   \       0x42   0x290A             CMP      R1,#+10
   \       0x44   0xDA02             BGE.N    ??_ntoa_long_long_4
   \       0x46   0xF11B 0x0230      ADDS     R2,R11,#+48
   \       0x4A   0xE008             B.N      ??_ntoa_long_long_5
   \                     ??_ntoa_long_long_4: (+1)
   \       0x4C   0x06B9             LSLS     R1,R7,#+26
   \       0x4E   0xD501             BPL.N    ??_ntoa_long_long_6
   \       0x50   0x2141             MOVS     R1,#+65
   \       0x52   0xE000             B.N      ??_ntoa_long_long_7
   \                     ??_ntoa_long_long_6: (+1)
   \       0x54   0x2161             MOVS     R1,#+97
   \                     ??_ntoa_long_long_7: (+1)
   \       0x56   0xEB1B 0x0101      ADDS     R1,R11,R1
   \       0x5A   0xF1B1 0x020A      SUBS     R2,R1,#+10
   \                     ??_ntoa_long_long_5: (+1)
   \       0x5E   0xA907             ADD      R1,SP,#+28
   \       0x60   0x540A             STRB     R2,[R1, R0]
    327                value /= base;
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x0029             MOVS     R1,R5
   \       0x66   0x4642             MOV      R2,R8
   \       0x68   0x464B             MOV      R3,R9
   \       0x6A   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x6E   0x0004             MOVS     R4,R0
   \       0x70   0x000D             MOVS     R5,R1
    328              } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   \       0x72   0x2D00             CMP      R5,#+0
   \       0x74   0xD101             BNE.N    ??_ntoa_long_long_8
   \       0x76   0x2C00             CMP      R4,#+0
   \       0x78   0xD001             BEQ.N    ??_ntoa_long_long_3
   \                     ??_ntoa_long_long_8: (+1)
   \       0x7A   0x2E20             CMP      R6,#+32
   \       0x7C   0xD3D6             BCC.N    ??_ntoa_long_long_1
    329            }
    330          
    331            return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   \                     ??_ntoa_long_long_3: (+1)
   \       0x7E   0x9706             STR      R7,[SP, #+24]
   \       0x80   0x9823             LDR      R0,[SP, #+140]
   \       0x82   0x9005             STR      R0,[SP, #+20]
   \       0x84   0x9822             LDR      R0,[SP, #+136]
   \       0x86   0x9004             STR      R0,[SP, #+16]
   \       0x88   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x8C   0xF89D 0x0078      LDRB     R0,[SP, #+120]
   \       0x90   0x9002             STR      R0,[SP, #+8]
   \       0x92   0x9601             STR      R6,[SP, #+4]
   \       0x94   0xA807             ADD      R0,SP,#+28
   \       0x96   0x9000             STR      R0,[SP, #+0]
   \       0x98   0x4653             MOV      R3,R10
   \       0x9A   0x9A12             LDR      R2,[SP, #+72]
   \       0x9C   0x9911             LDR      R1,[SP, #+68]
   \       0x9E   0x9810             LDR      R0,[SP, #+64]
   \       0xA0   0x.... 0x....      BL       _ntoa_format
   \       0xA4   0xB013             ADD      SP,SP,#+76
   \       0xA6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    332          }
    333          #endif  // PRINTF_SUPPORT_LONG_LONG
    334          
    335          
    336          #if defined(PRINTF_SUPPORT_FLOAT)
    337          
    338          #if defined(PRINTF_SUPPORT_EXPONENTIAL)
    339          // forward declaration so that _ftoa can switch to exp notation for values > PRINTF_MAX_FLOAT
    340          static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);
    341          #endif
    342          
    343          
    344          // internal ftoa for fixed decimal floating point

   \                                 In section .text, align 4, keep-with-next
    345          static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
    346          {
   \                     _ftoa: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xED2D 0x8B08      VPUSH    {D8-D11}
   \        0x8   0xB08E             SUB      SP,SP,#+56
   \        0xA   0x469B             MOV      R11,R3
   \        0xC   0xEEB0 0x9A40      VMOV.F32 S18,S0
   \       0x10   0xEEF0 0x9A60      VMOV.F32 S19,S1
   \       0x14   0x9E22             LDR      R6,[SP, #+136]
   \       0x16   0xF8DD 0x808C      LDR      R8,[SP, #+140]
   \       0x1A   0xF8DD 0x9090      LDR      R9,[SP, #+144]
    347            char buf[PRINTF_FTOA_BUFFER_SIZE];
    348            size_t len  = 0U;
   \       0x1E   0x2700             MOVS     R7,#+0
    349            double diff = 0.0;
   \       0x20   0xED9F 0x....      VLDR.W   D8,??DataTable1_2
    350          
    351            // powers of 10
    352            static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };
    353          
    354            // test for special values
    355            if (value != value)
   \       0x24   0xEC51 0x0B19      VMOV     R0,R1,D9
   \       0x28   0xEC53 0x2B19      VMOV     R2,R3,D9
   \       0x2C   0x.... 0x....      BL       __aeabi_cdcmpeq
   \       0x30   0xD00E             BEQ.N    ??_ftoa_0
    356              return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
   \       0x32   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x36   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x3A   0x2003             MOVS     R0,#+3
   \       0x3C   0x9001             STR      R0,[SP, #+4]
   \       0x3E   0x....             ADR.N    R0,??DataTable1
   \       0x40   0x9000             STR      R0,[SP, #+0]
   \       0x42   0x465B             MOV      R3,R11
   \       0x44   0x9A18             LDR      R2,[SP, #+96]
   \       0x46   0x9917             LDR      R1,[SP, #+92]
   \       0x48   0x9816             LDR      R0,[SP, #+88]
   \       0x4A   0x.... 0x....      BL       _out_rev
   \       0x4E   0xE15C             B.N      ??_ftoa_1
    357            if (value < -DBL_MAX)
   \                     ??_ftoa_0: (+1)
   \       0x50   0xEC51 0x0B19      VMOV     R0,R1,D9
   \       0x54   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x58   0xF47F 0x1380      MVNS     R3,#+1048576
   \       0x5C   0x.... 0x....      BL       __aeabi_cdcmple
   \       0x60   0xD20F             BCS.N    ??_ftoa_2
    358              return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
   \       0x62   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0x66   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x6A   0x2004             MOVS     R0,#+4
   \       0x6C   0x9001             STR      R0,[SP, #+4]
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable2
   \       0x72   0x9000             STR      R0,[SP, #+0]
   \       0x74   0x465B             MOV      R3,R11
   \       0x76   0x9A18             LDR      R2,[SP, #+96]
   \       0x78   0x9917             LDR      R1,[SP, #+92]
   \       0x7A   0x9816             LDR      R0,[SP, #+88]
   \       0x7C   0x.... 0x....      BL       _out_rev
   \       0x80   0xE143             B.N      ??_ftoa_1
    359            if (value > DBL_MAX)
   \                     ??_ftoa_2: (+1)
   \       0x82   0xEC51 0x0B19      VMOV     R0,R1,D9
   \       0x86   0x2200             MOVS     R2,#+0
   \       0x88   0x.... 0x....      LDR.W    R3,??DataTable2_1
   \       0x8C   0x.... 0x....      BL       __aeabi_cdcmpeq
   \       0x90   0xD119             BNE.N    ??_ftoa_3
    360              return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
   \       0x92   0xEA5F 0x7049      LSLS     R0,R9,#+29
   \       0x96   0xD501             BPL.N    ??_ftoa_4
   \       0x98   0x2004             MOVS     R0,#+4
   \       0x9A   0xE000             B.N      ??_ftoa_5
   \                     ??_ftoa_4: (+1)
   \       0x9C   0x2003             MOVS     R0,#+3
   \                     ??_ftoa_5: (+1)
   \       0x9E   0xEA5F 0x7149      LSLS     R1,R9,#+29
   \       0xA2   0xD502             BPL.N    ??_ftoa_6
   \       0xA4   0x.... 0x....      LDR.W    R1,??DataTable2_2
   \       0xA8   0xE000             B.N      ??_ftoa_7
   \                     ??_ftoa_6: (+1)
   \       0xAA   0x....             ADR.N    R1,??DataTable1_1
   \                     ??_ftoa_7: (+1)
   \       0xAC   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \       0xB0   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0xB4   0x9001             STR      R0,[SP, #+4]
   \       0xB6   0x9100             STR      R1,[SP, #+0]
   \       0xB8   0x465B             MOV      R3,R11
   \       0xBA   0x9A18             LDR      R2,[SP, #+96]
   \       0xBC   0x9917             LDR      R1,[SP, #+92]
   \       0xBE   0x9816             LDR      R0,[SP, #+88]
   \       0xC0   0x.... 0x....      BL       _out_rev
   \       0xC4   0xE121             B.N      ??_ftoa_1
    361          
    362            // test for very large values
    363            // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
    364            if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
   \                     ??_ftoa_3: (+1)
   \       0xC6   0xEC51 0x0B19      VMOV     R0,R1,D9
   \       0xCA   0x2201             MOVS     R2,#+1
   \       0xCC   0x.... 0x....      LDR.W    R3,??DataTable2_3
   \       0xD0   0x.... 0x....      BL       __aeabi_cdrcmple
   \       0xD4   0xD907             BLS.N    ??_ftoa_8
   \       0xD6   0xEC51 0x0B19      VMOV     R0,R1,D9
   \       0xDA   0x2200             MOVS     R2,#+0
   \       0xDC   0x.... 0x....      LDR.W    R3,??DataTable2_4
   \       0xE0   0x.... 0x....      BL       __aeabi_cdcmple
   \       0xE4   0xD20F             BCS.N    ??_ftoa_9
    365          #if defined(PRINTF_SUPPORT_EXPONENTIAL)
    366              return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
   \                     ??_ftoa_8: (+1)
   \       0xE6   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0xEA   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0xEE   0x9600             STR      R6,[SP, #+0]
   \       0xF0   0xEEB0 0x0A49      VMOV.F32 S0,S18
   \       0xF4   0xEEF0 0x0A69      VMOV.F32 S1,S19
   \       0xF8   0x465B             MOV      R3,R11
   \       0xFA   0x9A18             LDR      R2,[SP, #+96]
   \       0xFC   0x9917             LDR      R1,[SP, #+92]
   \       0xFE   0x9816             LDR      R0,[SP, #+88]
   \      0x100   0x.... 0x....      BL       _etoa
   \      0x104   0xE101             B.N      ??_ftoa_1
    367          #else
    368              return 0U;
    369          #endif
    370            }
    371          
    372            // test for negative
    373            bool negative = false;
   \                     ??_ftoa_9: (+1)
   \      0x106   0x2000             MOVS     R0,#+0
   \      0x108   0xF88D 0x0010      STRB     R0,[SP, #+16]
    374            if (value < 0) {
   \      0x10C   0xEC51 0x0B19      VMOV     R0,R1,D9
   \      0x110   0x2200             MOVS     R2,#+0
   \      0x112   0x2300             MOVS     R3,#+0
   \      0x114   0x.... 0x....      BL       __aeabi_cdcmple
   \      0x118   0xD208             BCS.N    ??_ftoa_10
    375              negative = true;
   \      0x11A   0x2001             MOVS     R0,#+1
   \      0x11C   0xF88D 0x0010      STRB     R0,[SP, #+16]
    376              value = 0 - value;
   \      0x120   0xEC51 0x0B19      VMOV     R0,R1,D9
   \      0x124   0xF091 0x4100      EORS     R1,R1,#0x80000000
   \      0x128   0xEC41 0x0B19      VMOV     D9,R0,R1
    377            }
    378          
    379            // set default precision, if not set explicitly
    380            if (!(flags & FLAGS_PRECISION)) {
   \                     ??_ftoa_10: (+1)
   \      0x12C   0xEA5F 0x5049      LSLS     R0,R9,#+21
   \      0x130   0xD401             BMI.N    ??_ftoa_11
    381              prec = PRINTF_DEFAULT_FLOAT_PRECISION;
   \      0x132   0x2006             MOVS     R0,#+6
   \      0x134   0x0006             MOVS     R6,R0
    382            }
    383            // limit precision to 9, cause a prec >= 10 can lead to overflow errors
    384            while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   \                     ??_ftoa_11: (+1)
   \      0x136   0x2F20             CMP      R7,#+32
   \      0x138   0xD207             BCS.N    ??_ftoa_12
   \      0x13A   0x2E0A             CMP      R6,#+10
   \      0x13C   0xD305             BCC.N    ??_ftoa_12
    385              buf[len++] = '0';
   \      0x13E   0x2130             MOVS     R1,#+48
   \      0x140   0xA805             ADD      R0,SP,#+20
   \      0x142   0x55C1             STRB     R1,[R0, R7]
   \      0x144   0x1C7F             ADDS     R7,R7,#+1
    386              prec--;
   \      0x146   0x1E76             SUBS     R6,R6,#+1
   \      0x148   0xE7F5             B.N      ??_ftoa_11
    387            }
    388          
    389            int whole = (int)value;
   \                     ??_ftoa_12: (+1)
   \      0x14A   0xEC51 0x0B19      VMOV     R0,R1,D9
   \      0x14E   0x.... 0x....      BL       __aeabi_d2iz
   \      0x152   0x0005             MOVS     R5,R0
    390            double tmp = (value - whole) * pow10[prec];
   \      0x154   0x.... 0x....      LDR.W    R10,??DataTable2_5
   \      0x158   0x0028             MOVS     R0,R5
   \      0x15A   0x.... 0x....      BL       __aeabi_i2d
   \      0x15E   0x0002             MOVS     R2,R0
   \      0x160   0x000B             MOVS     R3,R1
   \      0x162   0xEC51 0x0B19      VMOV     R0,R1,D9
   \      0x166   0x.... 0x....      BL       __aeabi_dsub
   \      0x16A   0xEB0A 0x02C6      ADD      R2,R10,R6, LSL #+3
   \      0x16E   0xE9D2 0x2300      LDRD     R2,R3,[R2, #+0]
   \      0x172   0x.... 0x....      BL       __aeabi_dmul
   \      0x176   0xEC41 0x0B1A      VMOV     D10,R0,R1
    391            unsigned long frac = (unsigned long)tmp;
   \      0x17A   0xEC51 0x0B1A      VMOV     R0,R1,D10
   \      0x17E   0x.... 0x....      BL       __aeabi_d2uiz
   \      0x182   0x0004             MOVS     R4,R0
    392            diff = tmp - frac;
   \      0x184   0x0020             MOVS     R0,R4
   \      0x186   0x.... 0x....      BL       __aeabi_ui2d
   \      0x18A   0x0002             MOVS     R2,R0
   \      0x18C   0x000B             MOVS     R3,R1
   \      0x18E   0xEC51 0x0B1A      VMOV     R0,R1,D10
   \      0x192   0x.... 0x....      BL       __aeabi_dsub
   \      0x196   0xEC41 0x0B1B      VMOV     D11,R0,R1
    393          
    394            if (diff > 0.5) {
   \      0x19A   0xEC51 0x0B1B      VMOV     R0,R1,D11
   \      0x19E   0x2201             MOVS     R2,#+1
   \      0x1A0   0x.... 0x....      LDR.W    R3,??DataTable9
   \      0x1A4   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x1A8   0xD80E             BHI.N    ??_ftoa_13
    395              ++frac;
   \      0x1AA   0x1C64             ADDS     R4,R4,#+1
    396              // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    397              if (frac >= pow10[prec]) {
   \      0x1AC   0x0020             MOVS     R0,R4
   \      0x1AE   0x.... 0x....      BL       __aeabi_ui2d
   \      0x1B2   0xEB0A 0x02C6      ADD      R2,R10,R6, LSL #+3
   \      0x1B6   0xE9D2 0x2300      LDRD     R2,R3,[R2, #+0]
   \      0x1BA   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x1BE   0xD810             BHI.N    ??_ftoa_14
    398                frac = 0;
   \      0x1C0   0x2000             MOVS     R0,#+0
   \      0x1C2   0x0004             MOVS     R4,R0
    399                ++whole;
   \      0x1C4   0x1C6D             ADDS     R5,R5,#+1
   \      0x1C6   0xE00C             B.N      ??_ftoa_14
    400              }
    401            }
    402            else if (diff < 0.5) {
   \                     ??_ftoa_13: (+1)
   \      0x1C8   0xEC51 0x0B1B      VMOV     R0,R1,D11
   \      0x1CC   0x2200             MOVS     R2,#+0
   \      0x1CE   0x.... 0x....      LDR.W    R3,??DataTable9
   \      0x1D2   0x.... 0x....      BL       __aeabi_cdcmple
   \      0x1D6   0xD304             BCC.N    ??_ftoa_14
    403            }
    404            else if ((frac == 0U) || (frac & 1U)) {
   \                     ??_ftoa_15: (+1)
   \      0x1D8   0x2C00             CMP      R4,#+0
   \      0x1DA   0xD001             BEQ.N    ??_ftoa_16
   \      0x1DC   0x07E0             LSLS     R0,R4,#+31
   \      0x1DE   0xD500             BPL.N    ??_ftoa_14
    405              // if halfway, round up if odd OR if last digit is 0
    406              ++frac;
   \                     ??_ftoa_16: (+1)
   \      0x1E0   0x1C64             ADDS     R4,R4,#+1
    407            }
    408          
    409            if (prec == 0U) {
   \                     ??_ftoa_14: (+1)
   \      0x1E2   0x2E00             CMP      R6,#+0
   \      0x1E4   0xD11E             BNE.N    ??_ftoa_17
    410              diff = value - (double)whole;
   \      0x1E6   0x0028             MOVS     R0,R5
   \      0x1E8   0x.... 0x....      BL       __aeabi_i2d
   \      0x1EC   0x0002             MOVS     R2,R0
   \      0x1EE   0x000B             MOVS     R3,R1
   \      0x1F0   0xEC51 0x0B19      VMOV     R0,R1,D9
   \      0x1F4   0x.... 0x....      BL       __aeabi_dsub
   \      0x1F8   0xEC41 0x0B1B      VMOV     D11,R0,R1
    411              if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
   \      0x1FC   0xEC51 0x0B1B      VMOV     R0,R1,D11
   \      0x200   0x2200             MOVS     R2,#+0
   \      0x202   0x.... 0x....      LDR.W    R3,??DataTable9
   \      0x206   0x.... 0x....      BL       __aeabi_cdcmple
   \      0x20A   0xD207             BCS.N    ??_ftoa_18
   \      0x20C   0xEC51 0x0B1B      VMOV     R0,R1,D11
   \      0x210   0x2201             MOVS     R2,#+1
   \      0x212   0x.... 0x....      LDR.W    R3,??DataTable9
   \      0x216   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x21A   0xD826             BHI.N    ??_ftoa_19
   \                     ??_ftoa_18: (+1)
   \      0x21C   0x07E8             LSLS     R0,R5,#+31
   \      0x21E   0xD524             BPL.N    ??_ftoa_19
    412                // exactly 0.5 and ODD, then round up
    413                // 1.5 -> 2, but 2.5 -> 2
    414                ++whole;
   \      0x220   0x1C6D             ADDS     R5,R5,#+1
   \      0x222   0xE022             B.N      ??_ftoa_19
    415              }
    416            }
    417            else {
    418              unsigned int count = prec;
   \                     ??_ftoa_17: (+1)
   \      0x224   0x0031             MOVS     R1,R6
    419              // now do fractional part, as an unsigned number
    420              while (len < PRINTF_FTOA_BUFFER_SIZE) {
   \                     ??_ftoa_20: (+1)
   \      0x226   0x2F20             CMP      R7,#+32
   \      0x228   0xD20E             BCS.N    ??_ftoa_21
    421                --count;
   \      0x22A   0x1E49             SUBS     R1,R1,#+1
    422                buf[len++] = (char)(48U + (frac % 10U));
   \      0x22C   0x200A             MOVS     R0,#+10
   \      0x22E   0xFBB4 0xF2F0      UDIV     R2,R4,R0
   \      0x232   0xFB00 0x4012      MLS      R0,R0,R2,R4
   \      0x236   0x3030             ADDS     R0,R0,#+48
   \      0x238   0xAA05             ADD      R2,SP,#+20
   \      0x23A   0x55D0             STRB     R0,[R2, R7]
   \      0x23C   0x1C7F             ADDS     R7,R7,#+1
    423                if (!(frac /= 10U)) {
   \      0x23E   0x200A             MOVS     R0,#+10
   \      0x240   0xFBB4 0xF4F0      UDIV     R4,R4,R0
   \      0x244   0x2C00             CMP      R4,#+0
   \      0x246   0xD1EE             BNE.N    ??_ftoa_20
    424                  break;
    425                }
    426              }
    427              // add extra 0s
    428              while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   \                     ??_ftoa_21: (+1)
   \      0x248   0x2F20             CMP      R7,#+32
   \      0x24A   0xD208             BCS.N    ??_ftoa_22
   \      0x24C   0x0008             MOVS     R0,R1
   \      0x24E   0x1E41             SUBS     R1,R0,#+1
   \      0x250   0x2800             CMP      R0,#+0
   \      0x252   0xD004             BEQ.N    ??_ftoa_22
    429                buf[len++] = '0';
   \      0x254   0x2230             MOVS     R2,#+48
   \      0x256   0xA805             ADD      R0,SP,#+20
   \      0x258   0x55C2             STRB     R2,[R0, R7]
   \      0x25A   0x1C7F             ADDS     R7,R7,#+1
   \      0x25C   0xE7F4             B.N      ??_ftoa_21
    430              }
    431              if (len < PRINTF_FTOA_BUFFER_SIZE) {
   \                     ??_ftoa_22: (+1)
   \      0x25E   0x2F20             CMP      R7,#+32
   \      0x260   0xD203             BCS.N    ??_ftoa_19
    432                // add decimal
    433                buf[len++] = '.';
   \      0x262   0x222E             MOVS     R2,#+46
   \      0x264   0xA805             ADD      R0,SP,#+20
   \      0x266   0x55C2             STRB     R2,[R0, R7]
   \      0x268   0x1C7F             ADDS     R7,R7,#+1
    434              }
    435            }
    436          
    437            // do whole part, number is reversed
    438            while (len < PRINTF_FTOA_BUFFER_SIZE) {
   \                     ??_ftoa_19: (+1)
   \      0x26A   0x2F20             CMP      R7,#+32
   \      0x26C   0xD20D             BCS.N    ??_ftoa_23
    439              buf[len++] = (char)(48 + (whole % 10));
   \      0x26E   0x200A             MOVS     R0,#+10
   \      0x270   0xFB95 0xF1F0      SDIV     R1,R5,R0
   \      0x274   0xFB00 0x5011      MLS      R0,R0,R1,R5
   \      0x278   0x3030             ADDS     R0,R0,#+48
   \      0x27A   0xA905             ADD      R1,SP,#+20
   \      0x27C   0x55C8             STRB     R0,[R1, R7]
   \      0x27E   0x1C7F             ADDS     R7,R7,#+1
    440              if (!(whole /= 10)) {
   \      0x280   0x200A             MOVS     R0,#+10
   \      0x282   0xFB95 0xF5F0      SDIV     R5,R5,R0
   \      0x286   0x2D00             CMP      R5,#+0
   \      0x288   0xD1EF             BNE.N    ??_ftoa_19
    441                break;
    442              }
    443            }
    444          
    445            // pad leading zeros
    446            if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
   \                     ??_ftoa_23: (+1)
   \      0x28A   0xF019 0x0003      ANDS     R0,R9,#0x3
   \      0x28E   0x2801             CMP      R0,#+1
   \      0x290   0xD114             BNE.N    ??_ftoa_24
    447              if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
   \      0x292   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x296   0xD008             BEQ.N    ??_ftoa_25
   \      0x298   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \      0x29C   0x2800             CMP      R0,#+0
   \      0x29E   0xD102             BNE.N    ??_ftoa_26
   \      0x2A0   0xF019 0x0F0C      TST      R9,#0xC
   \      0x2A4   0xD001             BEQ.N    ??_ftoa_25
    448                width--;
   \                     ??_ftoa_26: (+1)
   \      0x2A6   0xF1B8 0x0801      SUBS     R8,R8,#+1
    449              }
    450              while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   \                     ??_ftoa_25: (+1)
   \      0x2AA   0x4547             CMP      R7,R8
   \      0x2AC   0xD206             BCS.N    ??_ftoa_24
   \      0x2AE   0x2F20             CMP      R7,#+32
   \      0x2B0   0xD204             BCS.N    ??_ftoa_24
    451                buf[len++] = '0';
   \      0x2B2   0x2130             MOVS     R1,#+48
   \      0x2B4   0xA805             ADD      R0,SP,#+20
   \      0x2B6   0x55C1             STRB     R1,[R0, R7]
   \      0x2B8   0x1C7F             ADDS     R7,R7,#+1
   \      0x2BA   0xE7F6             B.N      ??_ftoa_25
    452              }
    453            }
    454          
    455            if (len < PRINTF_FTOA_BUFFER_SIZE) {
   \                     ??_ftoa_24: (+1)
   \      0x2BC   0x2F20             CMP      R7,#+32
   \      0x2BE   0xD217             BCS.N    ??_ftoa_27
    456              if (negative) {
   \      0x2C0   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \      0x2C4   0x2800             CMP      R0,#+0
   \      0x2C6   0xD004             BEQ.N    ??_ftoa_28
    457                buf[len++] = '-';
   \      0x2C8   0x212D             MOVS     R1,#+45
   \      0x2CA   0xA805             ADD      R0,SP,#+20
   \      0x2CC   0x55C1             STRB     R1,[R0, R7]
   \      0x2CE   0x1C7F             ADDS     R7,R7,#+1
   \      0x2D0   0xE00E             B.N      ??_ftoa_27
    458              }
    459              else if (flags & FLAGS_PLUS) {
   \                     ??_ftoa_28: (+1)
   \      0x2D2   0xEA5F 0x7049      LSLS     R0,R9,#+29
   \      0x2D6   0xD504             BPL.N    ??_ftoa_29
    460                buf[len++] = '+';  // ignore the space if the '+' exists
   \      0x2D8   0x202B             MOVS     R0,#+43
   \      0x2DA   0xA905             ADD      R1,SP,#+20
   \      0x2DC   0x55C8             STRB     R0,[R1, R7]
   \      0x2DE   0x1C7F             ADDS     R7,R7,#+1
   \      0x2E0   0xE006             B.N      ??_ftoa_27
    461              }
    462              else if (flags & FLAGS_SPACE) {
   \                     ??_ftoa_29: (+1)
   \      0x2E2   0xEA5F 0x7009      LSLS     R0,R9,#+28
   \      0x2E6   0xD503             BPL.N    ??_ftoa_27
    463                buf[len++] = ' ';
   \      0x2E8   0x2120             MOVS     R1,#+32
   \      0x2EA   0xA805             ADD      R0,SP,#+20
   \      0x2EC   0x55C1             STRB     R1,[R0, R7]
   \      0x2EE   0x1C7F             ADDS     R7,R7,#+1
    464              }
    465            }
    466          
    467            return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
   \                     ??_ftoa_27: (+1)
   \      0x2F0   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \      0x2F4   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \      0x2F8   0x9701             STR      R7,[SP, #+4]
   \      0x2FA   0xA805             ADD      R0,SP,#+20
   \      0x2FC   0x9000             STR      R0,[SP, #+0]
   \      0x2FE   0x465B             MOV      R3,R11
   \      0x300   0x9A18             LDR      R2,[SP, #+96]
   \      0x302   0x9917             LDR      R1,[SP, #+92]
   \      0x304   0x9816             LDR      R0,[SP, #+88]
   \      0x306   0x.... 0x....      BL       _out_rev
   \                     ??_ftoa_1: (+1)
   \      0x30A   0xB00E             ADD      SP,SP,#+56
   \      0x30C   0xECBD 0x8B08      VPOP     {D8-D11}
   \      0x310   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    468          }

   \                                 In section .rodata, align 8
   \                     `_ftoa::pow10`:
   \        0x0   0x3FF0'0000'0      DC64 0x3ff0'0000'0000'0000, 0x4024'0000'0000'0000
   \              000'0000 0x40
   \              24'0000'0000'
   \              0000
   \       0x10   0x4059'0000'0      DC64 0x4059'0000'0000'0000, 0x408f'4000'0000'0000
   \              000'0000 0x40
   \              8F'4000'0000'
   \              0000
   \       0x20   0x40C3'8800'0      DC64 0x40c3'8800'0000'0000, 0x40f8'6a00'0000'0000
   \              000'0000 0x40
   \              F8'6A00'0000'
   \              0000
   \       0x30   0x412E'8480'0      DC64 0x412e'8480'0000'0000, 0x4163'12d0'0000'0000
   \              000'0000 0x41
   \              63'12D0'0000'
   \              0000
   \       0x40   0x4197'D784'0      DC64 0x4197'd784'0000'0000, 0x41cd'cd65'0000'0000
   \              000'0000 0x41
   \              CD'CD65'0000'
   \              0000
    469          
    470          
    471          #if defined(PRINTF_SUPPORT_EXPONENTIAL)
    472          // internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>

   \                                 In section .text, align 2, keep-with-next
    473          static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
    474          {
   \                     _etoa: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xED2D 0x8B06      VPUSH    {D8-D10}
   \        0x8   0xB08A             SUB      SP,SP,#+40
   \        0xA   0x4680             MOV      R8,R0
   \        0xC   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \       0x10   0xEEF0 0x8A60      VMOV.F32 S17,S1
   \       0x14   0x9D1C             LDR      R5,[SP, #+112]
   \       0x16   0x9F1E             LDR      R7,[SP, #+120]
    475            // check for NaN and special values
    476            if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
   \       0x18   0xEC51 0x0B18      VMOV     R0,R1,D8
   \       0x1C   0xEC53 0x2B18      VMOV     R2,R3,D8
   \       0x20   0x.... 0x....      BL       __aeabi_cdcmpeq
   \       0x24   0xD10F             BNE.N    ??_etoa_0
   \       0x26   0xEC51 0x0B18      VMOV     R0,R1,D8
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x....             LDR.N    R3,??DataTable2_1
   \       0x2E   0x.... 0x....      BL       __aeabi_cdcmpeq
   \       0x32   0xD008             BEQ.N    ??_etoa_0
   \       0x34   0xEC51 0x0B18      VMOV     R0,R1,D8
   \       0x38   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x3C   0xF47F 0x1380      MVNS     R3,#+1048576
   \       0x40   0x.... 0x....      BL       __aeabi_cdcmple
   \       0x44   0xD20E             BCS.N    ??_etoa_1
    477              return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
   \                     ??_etoa_0: (+1)
   \       0x46   0x9702             STR      R7,[SP, #+8]
   \       0x48   0x981D             LDR      R0,[SP, #+116]
   \       0x4A   0x9001             STR      R0,[SP, #+4]
   \       0x4C   0x9500             STR      R5,[SP, #+0]
   \       0x4E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \       0x52   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \       0x56   0x9B12             LDR      R3,[SP, #+72]
   \       0x58   0x9A11             LDR      R2,[SP, #+68]
   \       0x5A   0x9910             LDR      R1,[SP, #+64]
   \       0x5C   0x4640             MOV      R0,R8
   \       0x5E   0x.... 0x....      BL       _ftoa
   \       0x62   0xE188             B.N      ??_etoa_2
    478            }
    479          
    480            // determine the sign
    481            const bool negative = value < 0;
   \                     ??_etoa_1: (+1)
   \       0x64   0xEC51 0x0B18      VMOV     R0,R1,D8
   \       0x68   0x2200             MOVS     R2,#+0
   \       0x6A   0x2300             MOVS     R3,#+0
   \       0x6C   0x.... 0x....      BL       __aeabi_cdcmple
   \       0x70   0xD202             BCS.N    ??_etoa_3
   \       0x72   0xF05F 0x0A01      MOVS     R10,#+1
   \       0x76   0xE001             B.N      ??_etoa_4
   \                     ??_etoa_3: (+1)
   \       0x78   0xF05F 0x0A00      MOVS     R10,#+0
    482            if (negative) {
   \                     ??_etoa_4: (+1)
   \       0x7C   0x4650             MOV      R0,R10
   \       0x7E   0xB2C0             UXTB     R0,R0
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD005             BEQ.N    ??_etoa_5
    483              value = -value;
   \       0x84   0xEC51 0x0B18      VMOV     R0,R1,D8
   \       0x88   0xF091 0x4100      EORS     R1,R1,#0x80000000
   \       0x8C   0xEC41 0x0B18      VMOV     D8,R0,R1
    484            }
    485          
    486            // default precision
    487            if (!(flags & FLAGS_PRECISION)) {
   \                     ??_etoa_5: (+1)
   \       0x90   0x0578             LSLS     R0,R7,#+21
   \       0x92   0xD401             BMI.N    ??_etoa_6
    488              prec = PRINTF_DEFAULT_FLOAT_PRECISION;
   \       0x94   0x2006             MOVS     R0,#+6
   \       0x96   0x0005             MOVS     R5,R0
    489            }
    490          
    491            // determine the decimal exponent
    492            // based on the algorithm by David Gay (https://www.ampl.com/netlib/fp/dtoa.c)
    493            union {
    494              uint64_t U;
    495              double   F;
    496            } conv;
    497          
    498            conv.F = value;
   \                     ??_etoa_6: (+1)
   \       0x98   0xED8D 0x8B06      VSTR     D8,[SP, #+24]
    499            int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
   \       0x9C   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \       0xA0   0x0D08             LSRS     R0,R1,#+20
   \       0xA2   0x2100             MOVS     R1,#+0
   \       0xA4   0x0004             MOVS     R4,R0
   \       0xA6   0x0564             LSLS     R4,R4,#+21
   \       0xA8   0x0D64             LSRS     R4,R4,#+21
   \       0xAA   0xF2A4 0x34FF      SUBW     R4,R4,#+1023
    500            conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
   \       0xAE   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \       0xB2   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0xB6   0x.... 0x....      LDR.W    R3,??DataTable10
   \       0xBA   0x4010             ANDS     R0,R0,R2
   \       0xBC   0x4019             ANDS     R1,R1,R3
   \       0xBE   0x2200             MOVS     R2,#+0
   \       0xC0   0x.... 0x....      LDR.W    R3,??DataTable10_1
   \       0xC4   0x4310             ORRS     R0,R0,R2
   \       0xC6   0x4319             ORRS     R1,R1,R3
   \       0xC8   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
    501            // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
    502            int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0x.... 0x....      BL       __aeabi_i2d
   \       0xD2   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \       0xD6   0x.... 0x....      LDR.W    R3,??DataTable10_3
   \       0xDA   0x.... 0x....      BL       __aeabi_dmul
   \       0xDE   0x.... 0x....      LDR.W    R2,??DataTable10_4
   \       0xE2   0x.... 0x....      LDR.W    R3,??DataTable10_5
   \       0xE6   0x.... 0x....      BL       __aeabi_dadd
   \       0xEA   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \       0xEE   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \       0xF2   0x2200             MOVS     R2,#+0
   \       0xF4   0x.... 0x....      LDR.W    R3,??DataTable10_6
   \       0xF8   0x.... 0x....      BL       __aeabi_dadd
   \       0xFC   0x.... 0x....      LDR.W    R2,??DataTable10_7
   \      0x100   0x.... 0x....      LDR.W    R3,??DataTable10_8
   \      0x104   0x.... 0x....      BL       __aeabi_dmul
   \      0x108   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \      0x10C   0x.... 0x....      BL       __aeabi_dadd
   \      0x110   0x.... 0x....      BL       __aeabi_d2iz
   \      0x114   0x0006             MOVS     R6,R0
    503            // now we want to compute 10^expval but we want to be sure it won't overflow
    504            exp2 = (int)(expval * 3.321928094887362 + 0.5);
   \      0x116   0x0030             MOVS     R0,R6
   \      0x118   0x.... 0x....      BL       __aeabi_i2d
   \      0x11C   0x.... 0x....      LDR.W    R2,??DataTable10_9
   \      0x120   0x.... 0x....      LDR.W    R3,??DataTable10_10
   \      0x124   0x.... 0x....      BL       __aeabi_dmul
   \      0x128   0x2200             MOVS     R2,#+0
   \      0x12A   0x.... 0x....      LDR.W    R3,??DataTable9
   \      0x12E   0x.... 0x....      BL       __aeabi_dadd
   \      0x132   0x.... 0x....      BL       __aeabi_d2iz
   \      0x136   0x9008             STR      R0,[SP, #+32]
    505            const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
   \      0x138   0x0030             MOVS     R0,R6
   \      0x13A   0x.... 0x....      BL       __aeabi_i2d
   \      0x13E   0x.... 0x....      LDR.W    R2,??DataTable10_11
   \      0x142   0x.... 0x....      LDR.W    R3,??DataTable10_12
   \      0x146   0x.... 0x....      BL       __aeabi_dmul
   \      0x14A   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x14E   0x9808             LDR      R0,[SP, #+32]
   \      0x150   0x.... 0x....      BL       __aeabi_i2d
   \      0x154   0x.... 0x....      LDR.W    R2,??DataTable10_13
   \      0x158   0x.... 0x....      LDR.W    R3,??DataTable10_14
   \      0x15C   0x.... 0x....      BL       __aeabi_dmul
   \      0x160   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \      0x164   0x.... 0x....      BL       __aeabi_dadd
   \      0x168   0xEC41 0x0B1A      VMOV     D10,R0,R1
    506            const double z2 = z * z;
   \      0x16C   0xEC51 0x0B1A      VMOV     R0,R1,D10
   \      0x170   0xEC53 0x2B1A      VMOV     R2,R3,D10
   \      0x174   0x.... 0x....      BL       __aeabi_dmul
   \      0x178   0xEC41 0x0B19      VMOV     D9,R0,R1
    507            conv.U = (uint64_t)(exp2 + 1023) << 52U;
   \      0x17C   0x9808             LDR      R0,[SP, #+32]
   \      0x17E   0xF200 0x30FF      ADDW     R0,R0,#+1023
   \      0x182   0x17C1             ASRS     R1,R0,#+31
   \      0x184   0x0501             LSLS     R1,R0,#+20
   \      0x186   0x2000             MOVS     R0,#+0
   \      0x188   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
    508            // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
    509            conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
   \      0x18C   0xEC51 0x0B1A      VMOV     R0,R1,D10
   \      0x190   0x2200             MOVS     R2,#+0
   \      0x192   0xF05F 0x4380      MOVS     R3,#+1073741824
   \      0x196   0x.... 0x....      BL       __aeabi_dmul
   \      0x19A   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
   \      0x19E   0x2000             MOVS     R0,#+0
   \      0x1A0   0xF05F 0x4180      MOVS     R1,#+1073741824
   \      0x1A4   0xEC53 0x2B1A      VMOV     R2,R3,D10
   \      0x1A8   0x.... 0x....      BL       __aeabi_dsub
   \      0x1AC   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x1B0   0xEC51 0x0B19      VMOV     R0,R1,D9
   \      0x1B4   0x2200             MOVS     R2,#+0
   \      0x1B6   0x.... 0x....      LDR.W    R3,??DataTable10_15
   \      0x1BA   0x.... 0x....      BL       __aeabi_ddiv
   \      0x1BE   0x2200             MOVS     R2,#+0
   \      0x1C0   0x.... 0x....      LDR.W    R3,??DataTable10_16
   \      0x1C4   0x.... 0x....      BL       __aeabi_dadd
   \      0x1C8   0x0002             MOVS     R2,R0
   \      0x1CA   0x000B             MOVS     R3,R1
   \      0x1CC   0xEC51 0x0B19      VMOV     R0,R1,D9
   \      0x1D0   0x.... 0x....      BL       __aeabi_ddiv
   \      0x1D4   0x2200             MOVS     R2,#+0
   \      0x1D6   0x.... 0x....      LDR.W    R3,??DataTable10_17
   \      0x1DA   0x.... 0x....      BL       __aeabi_dadd
   \      0x1DE   0x0002             MOVS     R2,R0
   \      0x1E0   0x000B             MOVS     R3,R1
   \      0x1E2   0xEC51 0x0B19      VMOV     R0,R1,D9
   \      0x1E6   0x.... 0x....      BL       __aeabi_ddiv
   \      0x1EA   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \      0x1EE   0x.... 0x....      BL       __aeabi_dadd
   \      0x1F2   0x0002             MOVS     R2,R0
   \      0x1F4   0x000B             MOVS     R3,R1
   \      0x1F6   0xE9DD 0x0102      LDRD     R0,R1,[SP, #+8]
   \      0x1FA   0x.... 0x....      BL       __aeabi_ddiv
   \      0x1FE   0x2200             MOVS     R2,#+0
   \      0x200   0x.... 0x....      LDR.W    R3,??DataTable10_1
   \      0x204   0x.... 0x....      BL       __aeabi_dadd
   \      0x208   0xE9DD 0x2306      LDRD     R2,R3,[SP, #+24]
   \      0x20C   0x.... 0x....      BL       __aeabi_dmul
   \      0x210   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
    510            // correct for rounding errors
    511            if (value < conv.F) {
   \      0x214   0xEC51 0x0B18      VMOV     R0,R1,D8
   \      0x218   0xE9DD 0x2306      LDRD     R2,R3,[SP, #+24]
   \      0x21C   0x.... 0x....      BL       __aeabi_cdcmple
   \      0x220   0xD209             BCS.N    ??_etoa_7
    512              expval--;
   \      0x222   0x1E76             SUBS     R6,R6,#+1
    513              conv.F /= 10;
   \      0x224   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \      0x228   0x2200             MOVS     R2,#+0
   \      0x22A   0x.... 0x....      LDR.W    R3,??DataTable10_16
   \      0x22E   0x.... 0x....      BL       __aeabi_ddiv
   \      0x232   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
    514            }
    515          
    516            // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
    517            unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
   \                     ??_etoa_7: (+1)
   \      0x236   0x2E64             CMP      R6,#+100
   \      0x238   0xDA04             BGE.N    ??_etoa_8
   \      0x23A   0xF116 0x0F63      CMN      R6,#+99
   \      0x23E   0xDB01             BLT.N    ??_etoa_8
   \      0x240   0x2404             MOVS     R4,#+4
   \      0x242   0xE000             B.N      ??_etoa_9
   \                     ??_etoa_8: (+1)
   \      0x244   0x2405             MOVS     R4,#+5
    518          
    519            // in "%g" mode, "prec" is the number of *significant figures* not decimals
    520            if (flags & FLAGS_ADAPT_EXP) {
   \                     ??_etoa_9: (+1)
   \      0x246   0x0538             LSLS     R0,R7,#+20
   \      0x248   0xD523             BPL.N    ??_etoa_10
    521              // do we want to fall-back to "%f" mode?
    522              if ((value >= 1e-4) && (value < 1e6)) {
   \      0x24A   0xEC51 0x0B18      VMOV     R0,R1,D8
   \      0x24E   0x.... 0x....      LDR.W    R2,??DataTable10_18
   \      0x252   0x.... 0x....      LDR.W    R3,??DataTable10_19
   \      0x256   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x25A   0xD815             BHI.N    ??_etoa_11
   \      0x25C   0xEC51 0x0B18      VMOV     R0,R1,D8
   \      0x260   0x2200             MOVS     R2,#+0
   \      0x262   0x.... 0x....      LDR.W    R3,??DataTable10_20
   \      0x266   0x.... 0x....      BL       __aeabi_cdcmple
   \      0x26A   0xD20D             BCS.N    ??_etoa_11
    523                if ((int)prec > expval) {
   \      0x26C   0x42AE             CMP      R6,R5
   \      0x26E   0xDA02             BGE.N    ??_etoa_12
    524                  prec = (unsigned)((int)prec - expval - 1);
   \      0x270   0x1BAD             SUBS     R5,R5,R6
   \      0x272   0x1E6D             SUBS     R5,R5,#+1
   \      0x274   0xE001             B.N      ??_etoa_13
    525                }
    526                else {
    527                  prec = 0;
   \                     ??_etoa_12: (+1)
   \      0x276   0x2000             MOVS     R0,#+0
   \      0x278   0x0005             MOVS     R5,R0
    528                }
    529                flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
   \                     ??_etoa_13: (+1)
   \      0x27A   0xF457 0x6780      ORRS     R7,R7,#0x400
    530                // no characters in exponent
    531                minwidth = 0U;
   \      0x27E   0x2000             MOVS     R0,#+0
   \      0x280   0x0004             MOVS     R4,R0
    532                expval   = 0;
   \      0x282   0x2000             MOVS     R0,#+0
   \      0x284   0x0006             MOVS     R6,R0
   \      0x286   0xE004             B.N      ??_etoa_10
    533              }
    534              else {
    535                // we use one sigfig for the whole part
    536                if ((prec > 0) && (flags & FLAGS_PRECISION)) {
   \                     ??_etoa_11: (+1)
   \      0x288   0x2D00             CMP      R5,#+0
   \      0x28A   0xD002             BEQ.N    ??_etoa_10
   \      0x28C   0x0578             LSLS     R0,R7,#+21
   \      0x28E   0xD500             BPL.N    ??_etoa_10
    537                  --prec;
   \      0x290   0x1E6D             SUBS     R5,R5,#+1
    538                }
    539              }
    540            }
    541          
    542            // will everything fit?
    543            unsigned int fwidth = width;
   \                     ??_etoa_10: (+1)
   \      0x292   0x981D             LDR      R0,[SP, #+116]
    544            if (width > minwidth) {
   \      0x294   0x991D             LDR      R1,[SP, #+116]
   \      0x296   0x428C             CMP      R4,R1
   \      0x298   0xD202             BCS.N    ??_etoa_14
    545              // we didn't fall-back so subtract the characters required for the exponent
    546              fwidth -= minwidth;
   \      0x29A   0x1B00             SUBS     R0,R0,R4
   \      0x29C   0x4681             MOV      R9,R0
   \      0x29E   0xE001             B.N      ??_etoa_15
    547            } else {
    548              // not enough characters, so go back to default sizing
    549              fwidth = 0U;
   \                     ??_etoa_14: (+1)
   \      0x2A0   0xF05F 0x0900      MOVS     R9,#+0
    550            }
    551            if ((flags & FLAGS_LEFT) && minwidth) {
   \                     ??_etoa_15: (+1)
   \      0x2A4   0x07B8             LSLS     R0,R7,#+30
   \      0x2A6   0xD503             BPL.N    ??_etoa_16
   \      0x2A8   0x2C00             CMP      R4,#+0
   \      0x2AA   0xD001             BEQ.N    ??_etoa_16
    552              // if we're padding on the right, DON'T pad the floating part
    553              fwidth = 0U;
   \      0x2AC   0x2000             MOVS     R0,#+0
   \      0x2AE   0x4681             MOV      R9,R0
    554            }
    555          
    556            // rescale the float value
    557            if (expval) {
   \                     ??_etoa_16: (+1)
   \      0x2B0   0x2E00             CMP      R6,#+0
   \      0x2B2   0xD007             BEQ.N    ??_etoa_17
    558              value /= conv.F;
   \      0x2B4   0xEC51 0x0B18      VMOV     R0,R1,D8
   \      0x2B8   0xE9DD 0x2306      LDRD     R2,R3,[SP, #+24]
   \      0x2BC   0x.... 0x....      BL       __aeabi_ddiv
   \      0x2C0   0xEC41 0x0B18      VMOV     D8,R0,R1
    559            }
    560          
    561            // output the floating part
    562            const size_t start_idx = idx;
   \                     ??_etoa_17: (+1)
   \      0x2C4   0x9811             LDR      R0,[SP, #+68]
   \      0x2C6   0x9009             STR      R0,[SP, #+36]
    563            idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
   \      0x2C8   0x4650             MOV      R0,R10
   \      0x2CA   0xB2C0             UXTB     R0,R0
   \      0x2CC   0x2800             CMP      R0,#+0
   \      0x2CE   0xD006             BEQ.N    ??_etoa_18
   \      0x2D0   0xEC51 0x0B18      VMOV     R0,R1,D8
   \      0x2D4   0xF091 0x4100      EORS     R1,R1,#0x80000000
   \      0x2D8   0xEC41 0x0B10      VMOV     D0,R0,R1
   \      0x2DC   0xE003             B.N      ??_etoa_19
   \                     ??_etoa_18: (+1)
   \      0x2DE   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \      0x2E2   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \                     ??_etoa_19: (+1)
   \      0x2E6   0xF437 0x6000      BICS     R0,R7,#0x800
   \      0x2EA   0x9002             STR      R0,[SP, #+8]
   \      0x2EC   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \      0x2F0   0x9500             STR      R5,[SP, #+0]
   \      0x2F2   0x9B12             LDR      R3,[SP, #+72]
   \      0x2F4   0x9A11             LDR      R2,[SP, #+68]
   \      0x2F6   0x9910             LDR      R1,[SP, #+64]
   \      0x2F8   0x4640             MOV      R0,R8
   \      0x2FA   0x.... 0x....      BL       _ftoa
   \      0x2FE   0x4683             MOV      R11,R0
    564          
    565            // output the exponent part
    566            if (minwidth) {
   \      0x300   0x2C00             CMP      R4,#+0
   \      0x302   0xD037             BEQ.N    ??_etoa_20
    567              // output the exponential symbol
    568              out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
   \      0x304   0x465A             MOV      R2,R11
   \      0x306   0x1C50             ADDS     R0,R2,#+1
   \      0x308   0x9011             STR      R0,[SP, #+68]
   \      0x30A   0x06B8             LSLS     R0,R7,#+26
   \      0x30C   0xD501             BPL.N    ??_etoa_21
   \      0x30E   0x2045             MOVS     R0,#+69
   \      0x310   0xE000             B.N      ??_etoa_22
   \                     ??_etoa_21: (+1)
   \      0x312   0x2065             MOVS     R0,#+101
   \                     ??_etoa_22: (+1)
   \      0x314   0x9B12             LDR      R3,[SP, #+72]
   \      0x316   0x9910             LDR      R1,[SP, #+64]
   \      0x318   0xB2C0             UXTB     R0,R0
   \      0x31A   0x47C0             BLX      R8
    569              // output the exponent value
    570              idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
   \      0x31C   0x2E00             CMP      R6,#+0
   \      0x31E   0xD501             BPL.N    ??_etoa_23
   \      0x320   0x2001             MOVS     R0,#+1
   \      0x322   0xE000             B.N      ??_etoa_24
   \                     ??_etoa_23: (+1)
   \      0x324   0x2000             MOVS     R0,#+0
   \                     ??_etoa_24: (+1)
   \      0x326   0x2E00             CMP      R6,#+0
   \      0x328   0xD501             BPL.N    ??_etoa_25
   \      0x32A   0x4271             RSBS     R1,R6,#+0
   \      0x32C   0xE000             B.N      ??_etoa_26
   \                     ??_etoa_25: (+1)
   \      0x32E   0x0031             MOVS     R1,R6
   \                     ??_etoa_26: (+1)
   \      0x330   0x2205             MOVS     R2,#+5
   \      0x332   0x9205             STR      R2,[SP, #+20]
   \      0x334   0x1E62             SUBS     R2,R4,#+1
   \      0x336   0x9204             STR      R2,[SP, #+16]
   \      0x338   0x2200             MOVS     R2,#+0
   \      0x33A   0x9203             STR      R2,[SP, #+12]
   \      0x33C   0x220A             MOVS     R2,#+10
   \      0x33E   0x9202             STR      R2,[SP, #+8]
   \      0x340   0xB2C0             UXTB     R0,R0
   \      0x342   0x9001             STR      R0,[SP, #+4]
   \      0x344   0x9100             STR      R1,[SP, #+0]
   \      0x346   0x9B12             LDR      R3,[SP, #+72]
   \      0x348   0x9A11             LDR      R2,[SP, #+68]
   \      0x34A   0x9910             LDR      R1,[SP, #+64]
   \      0x34C   0x4640             MOV      R0,R8
   \      0x34E   0x.... 0x....      BL       _ntoa_long
   \      0x352   0x4683             MOV      R11,R0
    571              // might need to right-pad spaces
    572              if (flags & FLAGS_LEFT) {
   \      0x354   0x07B8             LSLS     R0,R7,#+30
   \      0x356   0xD50D             BPL.N    ??_etoa_20
    573                while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
   \                     ??_etoa_27: (+1)
   \      0x358   0x9909             LDR      R1,[SP, #+36]
   \      0x35A   0xEBBB 0x0101      SUBS     R1,R11,R1
   \      0x35E   0x981D             LDR      R0,[SP, #+116]
   \      0x360   0x4281             CMP      R1,R0
   \      0x362   0xD207             BCS.N    ??_etoa_20
   \      0x364   0x9B12             LDR      R3,[SP, #+72]
   \      0x366   0x465A             MOV      R2,R11
   \      0x368   0x9910             LDR      R1,[SP, #+64]
   \      0x36A   0x2020             MOVS     R0,#+32
   \      0x36C   0x47C0             BLX      R8
   \      0x36E   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \      0x372   0xE7F1             B.N      ??_etoa_27
    574              }
    575            }
    576            return idx;
   \                     ??_etoa_20: (+1)
   \      0x374   0x4658             MOV      R0,R11
   \                     ??_etoa_2: (+1)
   \      0x376   0xB00A             ADD      SP,SP,#+40
   \      0x378   0xECBD 0x8B06      VPOP     {D8-D10}
   \      0x37C   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    577          }
    578          #endif  // PRINTF_SUPPORT_EXPONENTIAL
    579          #endif  // PRINTF_SUPPORT_FLOAT
    580          
    581          
    582          // internal vsnprintf

   \                                 In section .text, align 2, keep-with-next
    583          static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
    584          {
   \                     _vsnprintf: (+1)
   \        0x0   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \        0x4   0xB090             SUB      SP,SP,#+64
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x9E1C             LDR      R6,[SP, #+112]
    585            unsigned int flags, width, precision, n;
    586            size_t idx = 0U;
   \        0xC   0x2500             MOVS     R5,#+0
    587          
    588            if (!buffer) {
   \        0xE   0x9811             LDR      R0,[SP, #+68]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??_vsnprintf_0
    589              // use null output function
    590              out = _out_null;
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable10_21
   \       0x18   0x0007             MOVS     R7,R0
    591            }
    592          
    593            while (*format)
   \                     ??_vsnprintf_0: (+1)
   \       0x1A   0x9812             LDR      R0,[SP, #+72]
   \       0x1C   0x7800             LDRB     R0,[R0, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xF000 0x8338      BEQ.W    ??_vsnprintf_1
    594            {
    595              // format specifier?  %[flags][width][.precision][length]
    596              if (*format != '%') {
   \       0x24   0x9812             LDR      R0,[SP, #+72]
   \       0x26   0x7800             LDRB     R0,[R0, #+0]
   \       0x28   0x2825             CMP      R0,#+37
   \       0x2A   0xD00A             BEQ.N    ??_vsnprintf_2
    597                // no
    598                out(*format, buffer, idx++, maxlen);
   \       0x2C   0x4653             MOV      R3,R10
   \       0x2E   0x002A             MOVS     R2,R5
   \       0x30   0x9911             LDR      R1,[SP, #+68]
   \       0x32   0x9812             LDR      R0,[SP, #+72]
   \       0x34   0x7800             LDRB     R0,[R0, #+0]
   \       0x36   0x47B8             BLX      R7
   \       0x38   0x1C6D             ADDS     R5,R5,#+1
    599                format++;
   \       0x3A   0x9812             LDR      R0,[SP, #+72]
   \       0x3C   0x1C40             ADDS     R0,R0,#+1
   \       0x3E   0x9012             STR      R0,[SP, #+72]
    600                continue;
   \       0x40   0xE7EB             B.N      ??_vsnprintf_0
    601              }
    602              else {
    603                // yes, evaluate it
    604                format++;
   \                     ??_vsnprintf_2: (+1)
   \       0x42   0x9812             LDR      R0,[SP, #+72]
   \       0x44   0x1C40             ADDS     R0,R0,#+1
   \       0x46   0x9012             STR      R0,[SP, #+72]
    605              }
    606          
    607              // evaluate flags
    608              flags = 0U;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x0004             MOVS     R4,R0
    609              do {
    610                switch (*format) {
   \                     ??_vsnprintf_3: (+1)
   \       0x4C   0x9812             LDR      R0,[SP, #+72]
   \       0x4E   0x7800             LDRB     R0,[R0, #+0]
   \       0x50   0x2820             CMP      R0,#+32
   \       0x52   0xD01F             BEQ.N    ??_vsnprintf_4
   \       0x54   0x2823             CMP      R0,#+35
   \       0x56   0xD025             BEQ.N    ??_vsnprintf_5
   \       0x58   0x282B             CMP      R0,#+43
   \       0x5A   0xD013             BEQ.N    ??_vsnprintf_6
   \       0x5C   0x282D             CMP      R0,#+45
   \       0x5E   0xD009             BEQ.N    ??_vsnprintf_7
   \       0x60   0x2830             CMP      R0,#+48
   \       0x62   0xD127             BNE.N    ??_vsnprintf_8
    611                  case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
   \                     ??_vsnprintf_9: (+1)
   \       0x64   0xF054 0x0401      ORRS     R4,R4,#0x1
   \       0x68   0x9812             LDR      R0,[SP, #+72]
   \       0x6A   0x1C40             ADDS     R0,R0,#+1
   \       0x6C   0x9012             STR      R0,[SP, #+72]
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0x900A             STR      R0,[SP, #+40]
   \       0x72   0xE021             B.N      ??_vsnprintf_10
    612                  case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
   \                     ??_vsnprintf_7: (+1)
   \       0x74   0xF054 0x0402      ORRS     R4,R4,#0x2
   \       0x78   0x9812             LDR      R0,[SP, #+72]
   \       0x7A   0x1C40             ADDS     R0,R0,#+1
   \       0x7C   0x9012             STR      R0,[SP, #+72]
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0x900A             STR      R0,[SP, #+40]
   \       0x82   0xE019             B.N      ??_vsnprintf_10
    613                  case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
   \                     ??_vsnprintf_6: (+1)
   \       0x84   0xF054 0x0404      ORRS     R4,R4,#0x4
   \       0x88   0x9812             LDR      R0,[SP, #+72]
   \       0x8A   0x1C40             ADDS     R0,R0,#+1
   \       0x8C   0x9012             STR      R0,[SP, #+72]
   \       0x8E   0x2001             MOVS     R0,#+1
   \       0x90   0x900A             STR      R0,[SP, #+40]
   \       0x92   0xE011             B.N      ??_vsnprintf_10
    614                  case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
   \                     ??_vsnprintf_4: (+1)
   \       0x94   0xF054 0x0408      ORRS     R4,R4,#0x8
   \       0x98   0x9812             LDR      R0,[SP, #+72]
   \       0x9A   0x1C40             ADDS     R0,R0,#+1
   \       0x9C   0x9012             STR      R0,[SP, #+72]
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0x900A             STR      R0,[SP, #+40]
   \       0xA2   0xE009             B.N      ??_vsnprintf_10
    615                  case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
   \                     ??_vsnprintf_5: (+1)
   \       0xA4   0xF054 0x0410      ORRS     R4,R4,#0x10
   \       0xA8   0x9812             LDR      R0,[SP, #+72]
   \       0xAA   0x1C40             ADDS     R0,R0,#+1
   \       0xAC   0x9012             STR      R0,[SP, #+72]
   \       0xAE   0x2001             MOVS     R0,#+1
   \       0xB0   0x900A             STR      R0,[SP, #+40]
   \       0xB2   0xE001             B.N      ??_vsnprintf_10
    616                  default :                                   n = 0U; break;
   \                     ??_vsnprintf_8: (+1)
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x900A             STR      R0,[SP, #+40]
    617                }
    618              } while (n);
   \                     ??_vsnprintf_10: (+1)
   \       0xB8   0x980A             LDR      R0,[SP, #+40]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD1C6             BNE.N    ??_vsnprintf_3
    619          
    620              // evaluate width field
    621              width = 0U;
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0x9009             STR      R0,[SP, #+36]
    622              if (_is_digit(*format)) {
   \       0xC2   0x9812             LDR      R0,[SP, #+72]
   \       0xC4   0x7800             LDRB     R0,[R0, #+0]
   \       0xC6   0x.... 0x....      BL       _is_digit
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD004             BEQ.N    ??_vsnprintf_11
    623                width = _atoi(&format);
   \       0xCE   0xA812             ADD      R0,SP,#+72
   \       0xD0   0x.... 0x....      BL       _atoi
   \       0xD4   0x9009             STR      R0,[SP, #+36]
   \       0xD6   0xE010             B.N      ??_vsnprintf_12
    624              }
    625              else if (*format == '*') {
   \                     ??_vsnprintf_11: (+1)
   \       0xD8   0x9812             LDR      R0,[SP, #+72]
   \       0xDA   0x7800             LDRB     R0,[R0, #+0]
   \       0xDC   0x282A             CMP      R0,#+42
   \       0xDE   0xD10C             BNE.N    ??_vsnprintf_12
    626                const int w = va_arg(va, int);
   \       0xE0   0x6830             LDR      R0,[R6, #+0]
   \       0xE2   0x1D36             ADDS     R6,R6,#+4
    627                if (w < 0) {
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD504             BPL.N    ??_vsnprintf_13
    628                  flags |= FLAGS_LEFT;    // reverse padding
   \       0xE8   0xF054 0x0402      ORRS     R4,R4,#0x2
    629                  width = (unsigned int)-w;
   \       0xEC   0x4241             RSBS     R1,R0,#+0
   \       0xEE   0x9109             STR      R1,[SP, #+36]
   \       0xF0   0xE000             B.N      ??_vsnprintf_14
    630                }
    631                else {
    632                  width = (unsigned int)w;
   \                     ??_vsnprintf_13: (+1)
   \       0xF2   0x9009             STR      R0,[SP, #+36]
    633                }
    634                format++;
   \                     ??_vsnprintf_14: (+1)
   \       0xF4   0x9912             LDR      R1,[SP, #+72]
   \       0xF6   0x1C49             ADDS     R1,R1,#+1
   \       0xF8   0x9112             STR      R1,[SP, #+72]
    635              }
    636          
    637              // evaluate precision field
    638              precision = 0U;
   \                     ??_vsnprintf_12: (+1)
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0x4680             MOV      R8,R0
    639              if (*format == '.') {
   \       0xFE   0x9812             LDR      R0,[SP, #+72]
   \      0x100   0x7800             LDRB     R0,[R0, #+0]
   \      0x102   0x282E             CMP      R0,#+46
   \      0x104   0xD11E             BNE.N    ??_vsnprintf_15
    640                flags |= FLAGS_PRECISION;
   \      0x106   0xF454 0x6480      ORRS     R4,R4,#0x400
    641                format++;
   \      0x10A   0x9812             LDR      R0,[SP, #+72]
   \      0x10C   0x1C40             ADDS     R0,R0,#+1
   \      0x10E   0x9012             STR      R0,[SP, #+72]
    642                if (_is_digit(*format)) {
   \      0x110   0x9812             LDR      R0,[SP, #+72]
   \      0x112   0x7800             LDRB     R0,[R0, #+0]
   \      0x114   0x.... 0x....      BL       _is_digit
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD004             BEQ.N    ??_vsnprintf_16
    643                  precision = _atoi(&format);
   \      0x11C   0xA812             ADD      R0,SP,#+72
   \      0x11E   0x.... 0x....      BL       _atoi
   \      0x122   0x4680             MOV      R8,R0
   \      0x124   0xE00E             B.N      ??_vsnprintf_15
    644                }
    645                else if (*format == '*') {
   \                     ??_vsnprintf_16: (+1)
   \      0x126   0x9812             LDR      R0,[SP, #+72]
   \      0x128   0x7800             LDRB     R0,[R0, #+0]
   \      0x12A   0x282A             CMP      R0,#+42
   \      0x12C   0xD10A             BNE.N    ??_vsnprintf_15
    646                  const int prec = (int)va_arg(va, int);
   \      0x12E   0x6830             LDR      R0,[R6, #+0]
   \      0x130   0x1D36             ADDS     R6,R6,#+4
    647                  precision = prec > 0 ? (unsigned int)prec : 0U;
   \      0x132   0x2801             CMP      R0,#+1
   \      0x134   0xDB01             BLT.N    ??_vsnprintf_17
   \      0x136   0x4680             MOV      R8,R0
   \      0x138   0xE001             B.N      ??_vsnprintf_18
   \                     ??_vsnprintf_17: (+1)
   \      0x13A   0xF05F 0x0800      MOVS     R8,#+0
    648                  format++;
   \                     ??_vsnprintf_18: (+1)
   \      0x13E   0x9912             LDR      R1,[SP, #+72]
   \      0x140   0x1C49             ADDS     R1,R1,#+1
   \      0x142   0x9112             STR      R1,[SP, #+72]
    649                }
    650              }
    651          
    652              // evaluate length field
    653              switch (*format) {
   \                     ??_vsnprintf_15: (+1)
   \      0x144   0x9812             LDR      R0,[SP, #+72]
   \      0x146   0x7800             LDRB     R0,[R0, #+0]
   \      0x148   0x2868             CMP      R0,#+104
   \      0x14A   0xD017             BEQ.N    ??_vsnprintf_19
   \      0x14C   0x286A             CMP      R0,#+106
   \      0x14E   0xD02A             BEQ.N    ??_vsnprintf_20
   \      0x150   0x286C             CMP      R0,#+108
   \      0x152   0xD004             BEQ.N    ??_vsnprintf_21
   \      0x154   0x2874             CMP      R0,#+116
   \      0x156   0xD020             BEQ.N    ??_vsnprintf_22
   \      0x158   0x287A             CMP      R0,#+122
   \      0x15A   0xD02A             BEQ.N    ??_vsnprintf_23
   \      0x15C   0xE02F             B.N      ??_vsnprintf_24
    654                case 'l' :
    655                  flags |= FLAGS_LONG;
   \                     ??_vsnprintf_21: (+1)
   \      0x15E   0xF454 0x7480      ORRS     R4,R4,#0x100
    656                  format++;
   \      0x162   0x9812             LDR      R0,[SP, #+72]
   \      0x164   0x1C40             ADDS     R0,R0,#+1
   \      0x166   0x9012             STR      R0,[SP, #+72]
    657                  if (*format == 'l') {
   \      0x168   0x9812             LDR      R0,[SP, #+72]
   \      0x16A   0x7800             LDRB     R0,[R0, #+0]
   \      0x16C   0x286C             CMP      R0,#+108
   \      0x16E   0xD104             BNE.N    ??_vsnprintf_25
    658                    flags |= FLAGS_LONG_LONG;
   \      0x170   0xF454 0x7400      ORRS     R4,R4,#0x200
    659                    format++;
   \      0x174   0x9812             LDR      R0,[SP, #+72]
   \      0x176   0x1C40             ADDS     R0,R0,#+1
   \      0x178   0x9012             STR      R0,[SP, #+72]
    660                  }
    661                  break;
   \                     ??_vsnprintf_25: (+1)
   \      0x17A   0xE020             B.N      ??_vsnprintf_26
    662                case 'h' :
    663                  flags |= FLAGS_SHORT;
   \                     ??_vsnprintf_19: (+1)
   \      0x17C   0xF054 0x0480      ORRS     R4,R4,#0x80
    664                  format++;
   \      0x180   0x9812             LDR      R0,[SP, #+72]
   \      0x182   0x1C40             ADDS     R0,R0,#+1
   \      0x184   0x9012             STR      R0,[SP, #+72]
    665                  if (*format == 'h') {
   \      0x186   0x9812             LDR      R0,[SP, #+72]
   \      0x188   0x7800             LDRB     R0,[R0, #+0]
   \      0x18A   0x2868             CMP      R0,#+104
   \      0x18C   0xD104             BNE.N    ??_vsnprintf_27
    666                    flags |= FLAGS_CHAR;
   \      0x18E   0xF054 0x0440      ORRS     R4,R4,#0x40
    667                    format++;
   \      0x192   0x9812             LDR      R0,[SP, #+72]
   \      0x194   0x1C40             ADDS     R0,R0,#+1
   \      0x196   0x9012             STR      R0,[SP, #+72]
    668                  }
    669                  break;
   \                     ??_vsnprintf_27: (+1)
   \      0x198   0xE011             B.N      ??_vsnprintf_26
    670          #if defined(PRINTF_SUPPORT_PTRDIFF_T)
    671                case 't' :
    672                  flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   \                     ??_vsnprintf_22: (+1)
   \      0x19A   0xF454 0x7480      ORRS     R4,R4,#0x100
    673                  format++;
   \      0x19E   0x9812             LDR      R0,[SP, #+72]
   \      0x1A0   0x1C40             ADDS     R0,R0,#+1
   \      0x1A2   0x9012             STR      R0,[SP, #+72]
    674                  break;
   \      0x1A4   0xE00B             B.N      ??_vsnprintf_26
    675          #endif
    676                case 'j' :
    677                  flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   \                     ??_vsnprintf_20: (+1)
   \      0x1A6   0xF454 0x7400      ORRS     R4,R4,#0x200
    678                  format++;
   \      0x1AA   0x9812             LDR      R0,[SP, #+72]
   \      0x1AC   0x1C40             ADDS     R0,R0,#+1
   \      0x1AE   0x9012             STR      R0,[SP, #+72]
    679                  break;
   \      0x1B0   0xE005             B.N      ??_vsnprintf_26
    680                case 'z' :
    681                  flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   \                     ??_vsnprintf_23: (+1)
   \      0x1B2   0xF454 0x7480      ORRS     R4,R4,#0x100
    682                  format++;
   \      0x1B6   0x9812             LDR      R0,[SP, #+72]
   \      0x1B8   0x1C40             ADDS     R0,R0,#+1
   \      0x1BA   0x9012             STR      R0,[SP, #+72]
    683                  break;
   \      0x1BC   0xE7FF             B.N      ??_vsnprintf_26
    684                default :
    685                  break;
    686              }
    687          
    688              // evaluate specifier
    689              switch (*format) {
   \                     ??_vsnprintf_24: (+1)
   \                     ??_vsnprintf_26: (+1)
   \      0x1BE   0x9812             LDR      R0,[SP, #+72]
   \      0x1C0   0x7800             LDRB     R0,[R0, #+0]
   \      0x1C2   0x2825             CMP      R0,#+37
   \      0x1C4   0xF000 0x8251      BEQ.W    ??_vsnprintf_28
   \      0x1C8   0x2845             CMP      R0,#+69
   \      0x1CA   0xF000 0x8173      BEQ.W    ??_vsnprintf_29
   \      0x1CE   0x2846             CMP      R0,#+70
   \      0x1D0   0xF000 0x8153      BEQ.W    ??_vsnprintf_30
   \      0x1D4   0x2847             CMP      R0,#+71
   \      0x1D6   0xF000 0x816D      BEQ.W    ??_vsnprintf_29
   \      0x1DA   0x2858             CMP      R0,#+88
   \      0x1DC   0xD01E             BEQ.N    ??_vsnprintf_31
   \      0x1DE   0x2862             CMP      R0,#+98
   \      0x1E0   0xD01C             BEQ.N    ??_vsnprintf_31
   \      0x1E2   0x2863             CMP      R0,#+99
   \      0x1E4   0xF000 0x8191      BEQ.W    ??_vsnprintf_32
   \      0x1E8   0x2864             CMP      R0,#+100
   \      0x1EA   0xD017             BEQ.N    ??_vsnprintf_31
   \      0x1EC   0x2865             CMP      R0,#+101
   \      0x1EE   0xF000 0x8161      BEQ.W    ??_vsnprintf_29
   \      0x1F2   0x2866             CMP      R0,#+102
   \      0x1F4   0xF000 0x8141      BEQ.W    ??_vsnprintf_30
   \      0x1F8   0x2867             CMP      R0,#+103
   \      0x1FA   0xF000 0x815B      BEQ.W    ??_vsnprintf_29
   \      0x1FE   0x2869             CMP      R0,#+105
   \      0x200   0xD00C             BEQ.N    ??_vsnprintf_31
   \      0x202   0x286F             CMP      R0,#+111
   \      0x204   0xD00A             BEQ.N    ??_vsnprintf_31
   \      0x206   0x2870             CMP      R0,#+112
   \      0x208   0xF000 0x81F5      BEQ.W    ??_vsnprintf_33
   \      0x20C   0x2873             CMP      R0,#+115
   \      0x20E   0xF000 0x81A8      BEQ.W    ??_vsnprintf_34
   \      0x212   0x2875             CMP      R0,#+117
   \      0x214   0xD002             BEQ.N    ??_vsnprintf_31
   \      0x216   0x2878             CMP      R0,#+120
   \      0x218   0xF040 0x8231      BNE.W    ??_vsnprintf_35
    690                case 'd' :
    691                case 'i' :
    692                case 'u' :
    693                case 'x' :
    694                case 'X' :
    695                case 'o' :
    696                case 'b' : {
    697                  // set the base
    698                  unsigned int base;
    699                  if (*format == 'x' || *format == 'X') {
   \                     ??_vsnprintf_31: (+1)
   \      0x21C   0x9812             LDR      R0,[SP, #+72]
   \      0x21E   0x7800             LDRB     R0,[R0, #+0]
   \      0x220   0x2878             CMP      R0,#+120
   \      0x222   0xD003             BEQ.N    ??_vsnprintf_36
   \      0x224   0x9812             LDR      R0,[SP, #+72]
   \      0x226   0x7800             LDRB     R0,[R0, #+0]
   \      0x228   0x2858             CMP      R0,#+88
   \      0x22A   0xD102             BNE.N    ??_vsnprintf_37
    700                    base = 16U;
   \                     ??_vsnprintf_36: (+1)
   \      0x22C   0xF05F 0x0910      MOVS     R9,#+16
   \      0x230   0xE011             B.N      ??_vsnprintf_38
    701                  }
    702                  else if (*format == 'o') {
   \                     ??_vsnprintf_37: (+1)
   \      0x232   0x9812             LDR      R0,[SP, #+72]
   \      0x234   0x7800             LDRB     R0,[R0, #+0]
   \      0x236   0x286F             CMP      R0,#+111
   \      0x238   0xD102             BNE.N    ??_vsnprintf_39
    703                    base =  8U;
   \      0x23A   0xF05F 0x0908      MOVS     R9,#+8
   \      0x23E   0xE00A             B.N      ??_vsnprintf_38
    704                  }
    705                  else if (*format == 'b') {
   \                     ??_vsnprintf_39: (+1)
   \      0x240   0x9812             LDR      R0,[SP, #+72]
   \      0x242   0x7800             LDRB     R0,[R0, #+0]
   \      0x244   0x2862             CMP      R0,#+98
   \      0x246   0xD102             BNE.N    ??_vsnprintf_40
    706                    base =  2U;
   \      0x248   0xF05F 0x0902      MOVS     R9,#+2
   \      0x24C   0xE003             B.N      ??_vsnprintf_38
    707                  }
    708                  else {
    709                    base = 10U;
   \                     ??_vsnprintf_40: (+1)
   \      0x24E   0xF05F 0x090A      MOVS     R9,#+10
    710                    flags &= ~FLAGS_HASH;   // no hash for dec format
   \      0x252   0xF034 0x0410      BICS     R4,R4,#0x10
    711                  }
    712                  // uppercase
    713                  if (*format == 'X') {
   \                     ??_vsnprintf_38: (+1)
   \      0x256   0x9812             LDR      R0,[SP, #+72]
   \      0x258   0x7800             LDRB     R0,[R0, #+0]
   \      0x25A   0x2858             CMP      R0,#+88
   \      0x25C   0xD101             BNE.N    ??_vsnprintf_41
    714                    flags |= FLAGS_UPPERCASE;
   \      0x25E   0xF054 0x0420      ORRS     R4,R4,#0x20
    715                  }
    716          
    717                  // no plus or space flag for u, x, X, o, b
    718                  if ((*format != 'i') && (*format != 'd')) {
   \                     ??_vsnprintf_41: (+1)
   \      0x262   0x9812             LDR      R0,[SP, #+72]
   \      0x264   0x7800             LDRB     R0,[R0, #+0]
   \      0x266   0x2869             CMP      R0,#+105
   \      0x268   0xD005             BEQ.N    ??_vsnprintf_42
   \      0x26A   0x9812             LDR      R0,[SP, #+72]
   \      0x26C   0x7800             LDRB     R0,[R0, #+0]
   \      0x26E   0x2864             CMP      R0,#+100
   \      0x270   0xD001             BEQ.N    ??_vsnprintf_42
    719                    flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
   \      0x272   0xF034 0x040C      BICS     R4,R4,#0xC
    720                  }
    721          
    722                  // ignore '0' flag when precision is given
    723                  if (flags & FLAGS_PRECISION) {
   \                     ??_vsnprintf_42: (+1)
   \      0x276   0x0560             LSLS     R0,R4,#+21
   \      0x278   0xD501             BPL.N    ??_vsnprintf_43
    724                    flags &= ~FLAGS_ZEROPAD;
   \      0x27A   0x0864             LSRS     R4,R4,#+1
   \      0x27C   0x0064             LSLS     R4,R4,#+1
    725                  }
    726          
    727                  // convert the integer
    728                  if ((*format == 'i') || (*format == 'd')) {
   \                     ??_vsnprintf_43: (+1)
   \      0x27E   0x9812             LDR      R0,[SP, #+72]
   \      0x280   0x7800             LDRB     R0,[R0, #+0]
   \      0x282   0x2869             CMP      R0,#+105
   \      0x284   0xD004             BEQ.N    ??_vsnprintf_44
   \      0x286   0x9812             LDR      R0,[SP, #+72]
   \      0x288   0x7800             LDRB     R0,[R0, #+0]
   \      0x28A   0x2864             CMP      R0,#+100
   \      0x28C   0xF040 0x8098      BNE.W    ??_vsnprintf_45
    729                    // signed
    730                    if (flags & FLAGS_LONG_LONG) {
   \                     ??_vsnprintf_44: (+1)
   \      0x290   0x05A0             LSLS     R0,R4,#+22
   \      0x292   0xD53F             BPL.N    ??_vsnprintf_46
    731          #if defined(PRINTF_SUPPORT_LONG_LONG)
    732                      const long long value = va_arg(va, long long);
   \      0x294   0x1DF2             ADDS     R2,R6,#+7
   \      0x296   0xF032 0x0207      BICS     R2,R2,#0x7
   \      0x29A   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \      0x29E   0xF112 0x0608      ADDS     R6,R2,#+8
   \      0x2A2   0xE9CD 0x010C      STRD     R0,R1,[SP, #+48]
    733                      idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   \      0x2A6   0xE9DD 0x010C      LDRD     R0,R1,[SP, #+48]
   \      0x2AA   0x2900             CMP      R1,#+0
   \      0x2AC   0xD502             BPL.N    ??_vsnprintf_47
   \      0x2AE   0xF05F 0x0C01      MOVS     R12,#+1
   \      0x2B2   0xE001             B.N      ??_vsnprintf_48
   \                     ??_vsnprintf_47: (+1)
   \      0x2B4   0xF05F 0x0C00      MOVS     R12,#+0
   \                     ??_vsnprintf_48: (+1)
   \      0x2B8   0xE9DD 0x230C      LDRD     R2,R3,[SP, #+48]
   \      0x2BC   0x2001             MOVS     R0,#+1
   \      0x2BE   0x2100             MOVS     R1,#+0
   \      0x2C0   0x428B             CMP      R3,R1
   \      0x2C2   0xDB07             BLT.N    ??_vsnprintf_49
   \      0x2C4   0xDC01             BGT.N    ??_vsnprintf_50
   \      0x2C6   0x4282             CMP      R2,R0
   \      0x2C8   0xD304             BCC.N    ??_vsnprintf_49
   \                     ??_vsnprintf_50: (+1)
   \      0x2CA   0xE9DD 0x010C      LDRD     R0,R1,[SP, #+48]
   \      0x2CE   0xE9CD 0x010E      STRD     R0,R1,[SP, #+56]
   \      0x2D2   0xE006             B.N      ??_vsnprintf_51
   \                     ??_vsnprintf_49: (+1)
   \      0x2D4   0xE9DD 0x010C      LDRD     R0,R1,[SP, #+48]
   \      0x2D8   0x4240             RSBS     R0,R0,#+0
   \      0x2DA   0xEB71 0x0141      SBCS     R1,R1,R1, LSL #+1
   \      0x2DE   0xE9CD 0x010E      STRD     R0,R1,[SP, #+56]
   \                     ??_vsnprintf_51: (+1)
   \      0x2E2   0x9408             STR      R4,[SP, #+32]
   \      0x2E4   0x9809             LDR      R0,[SP, #+36]
   \      0x2E6   0x9007             STR      R0,[SP, #+28]
   \      0x2E8   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \      0x2EC   0x4648             MOV      R0,R9
   \      0x2EE   0x2100             MOVS     R1,#+0
   \      0x2F0   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
   \      0x2F4   0xFA5F 0xFC8C      UXTB     R12,R12
   \      0x2F8   0xF8CD 0xC008      STR      R12,[SP, #+8]
   \      0x2FC   0xE9DD 0x010E      LDRD     R0,R1,[SP, #+56]
   \      0x300   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x304   0x4653             MOV      R3,R10
   \      0x306   0x002A             MOVS     R2,R5
   \      0x308   0x9911             LDR      R1,[SP, #+68]
   \      0x30A   0x0038             MOVS     R0,R7
   \      0x30C   0x.... 0x....      BL       _ntoa_long_long
   \      0x310   0x0005             MOVS     R5,R0
   \      0x312   0xE0AE             B.N      ??_vsnprintf_52
    734          #endif
    735                    }
    736                    else if (flags & FLAGS_LONG) {
   \                     ??_vsnprintf_46: (+1)
   \      0x314   0x05E0             LSLS     R0,R4,#+23
   \      0x316   0xD521             BPL.N    ??_vsnprintf_53
    737                      const long value = va_arg(va, long);
   \      0x318   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \      0x31C   0x1D36             ADDS     R6,R6,#+4
    738                      idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   \      0x31E   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x322   0xD501             BPL.N    ??_vsnprintf_54
   \      0x324   0x2201             MOVS     R2,#+1
   \      0x326   0xE000             B.N      ??_vsnprintf_55
   \                     ??_vsnprintf_54: (+1)
   \      0x328   0x2200             MOVS     R2,#+0
   \                     ??_vsnprintf_55: (+1)
   \      0x32A   0xF1BB 0x0F01      CMP      R11,#+1
   \      0x32E   0xDB01             BLT.N    ??_vsnprintf_56
   \      0x330   0x4658             MOV      R0,R11
   \      0x332   0xE001             B.N      ??_vsnprintf_57
   \                     ??_vsnprintf_56: (+1)
   \      0x334   0xF1DB 0x0000      RSBS     R0,R11,#+0
   \                     ??_vsnprintf_57: (+1)
   \      0x338   0x9405             STR      R4,[SP, #+20]
   \      0x33A   0x9909             LDR      R1,[SP, #+36]
   \      0x33C   0x9104             STR      R1,[SP, #+16]
   \      0x33E   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \      0x342   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \      0x346   0xB2D2             UXTB     R2,R2
   \      0x348   0x9201             STR      R2,[SP, #+4]
   \      0x34A   0x9000             STR      R0,[SP, #+0]
   \      0x34C   0x4653             MOV      R3,R10
   \      0x34E   0x002A             MOVS     R2,R5
   \      0x350   0x9911             LDR      R1,[SP, #+68]
   \      0x352   0x0038             MOVS     R0,R7
   \      0x354   0x.... 0x....      BL       _ntoa_long
   \      0x358   0x0005             MOVS     R5,R0
   \      0x35A   0xE08A             B.N      ??_vsnprintf_52
    739                    }
    740                    else {
    741                      const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
   \                     ??_vsnprintf_53: (+1)
   \      0x35C   0x0660             LSLS     R0,R4,#+25
   \      0x35E   0xD505             BPL.N    ??_vsnprintf_58
   \      0x360   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \      0x364   0x1D36             ADDS     R6,R6,#+4
   \      0x366   0xFA5F 0xFB8B      UXTB     R11,R11
   \      0x36A   0xE00A             B.N      ??_vsnprintf_59
   \                     ??_vsnprintf_58: (+1)
   \      0x36C   0x0620             LSLS     R0,R4,#+24
   \      0x36E   0xD505             BPL.N    ??_vsnprintf_60
   \      0x370   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \      0x374   0x1D36             ADDS     R6,R6,#+4
   \      0x376   0xFA0F 0xFB8B      SXTH     R11,R11
   \      0x37A   0xE002             B.N      ??_vsnprintf_59
   \                     ??_vsnprintf_60: (+1)
   \      0x37C   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \      0x380   0x1D36             ADDS     R6,R6,#+4
    742                      idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   \                     ??_vsnprintf_59: (+1)
   \      0x382   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x386   0xD501             BPL.N    ??_vsnprintf_61
   \      0x388   0x2001             MOVS     R0,#+1
   \      0x38A   0xE000             B.N      ??_vsnprintf_62
   \                     ??_vsnprintf_61: (+1)
   \      0x38C   0x2000             MOVS     R0,#+0
   \                     ??_vsnprintf_62: (+1)
   \      0x38E   0xF1BB 0x0F01      CMP      R11,#+1
   \      0x392   0xDB01             BLT.N    ??_vsnprintf_63
   \      0x394   0x4659             MOV      R1,R11
   \      0x396   0xE001             B.N      ??_vsnprintf_64
   \                     ??_vsnprintf_63: (+1)
   \      0x398   0xF1DB 0x0100      RSBS     R1,R11,#+0
   \                     ??_vsnprintf_64: (+1)
   \      0x39C   0x9405             STR      R4,[SP, #+20]
   \      0x39E   0x9A09             LDR      R2,[SP, #+36]
   \      0x3A0   0x9204             STR      R2,[SP, #+16]
   \      0x3A2   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \      0x3A6   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \      0x3AA   0xB2C0             UXTB     R0,R0
   \      0x3AC   0x9001             STR      R0,[SP, #+4]
   \      0x3AE   0x9100             STR      R1,[SP, #+0]
   \      0x3B0   0x4653             MOV      R3,R10
   \      0x3B2   0x002A             MOVS     R2,R5
   \      0x3B4   0x9911             LDR      R1,[SP, #+68]
   \      0x3B6   0x0038             MOVS     R0,R7
   \      0x3B8   0x.... 0x....      BL       _ntoa_long
   \      0x3BC   0x0005             MOVS     R5,R0
   \      0x3BE   0xE058             B.N      ??_vsnprintf_52
    743                    }
    744                  }
    745                  else {
    746                    // unsigned
    747                    if (flags & FLAGS_LONG_LONG) {
   \                     ??_vsnprintf_45: (+1)
   \      0x3C0   0x05A0             LSLS     R0,R4,#+22
   \      0x3C2   0xD51B             BPL.N    ??_vsnprintf_65
    748          #if defined(PRINTF_SUPPORT_LONG_LONG)
    749                      idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
   \      0x3C4   0x1DF0             ADDS     R0,R6,#+7
   \      0x3C6   0xF030 0x0007      BICS     R0,R0,#0x7
   \      0x3CA   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \      0x3CE   0xF110 0x0608      ADDS     R6,R0,#+8
   \      0x3D2   0x9408             STR      R4,[SP, #+32]
   \      0x3D4   0x9809             LDR      R0,[SP, #+36]
   \      0x3D6   0x9007             STR      R0,[SP, #+28]
   \      0x3D8   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \      0x3DC   0x4648             MOV      R0,R9
   \      0x3DE   0x2100             MOVS     R1,#+0
   \      0x3E0   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
   \      0x3E4   0x2000             MOVS     R0,#+0
   \      0x3E6   0x9002             STR      R0,[SP, #+8]
   \      0x3E8   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
   \      0x3EC   0x4653             MOV      R3,R10
   \      0x3EE   0x002A             MOVS     R2,R5
   \      0x3F0   0x9911             LDR      R1,[SP, #+68]
   \      0x3F2   0x0038             MOVS     R0,R7
   \      0x3F4   0x.... 0x....      BL       _ntoa_long_long
   \      0x3F8   0x0005             MOVS     R5,R0
   \      0x3FA   0xE03A             B.N      ??_vsnprintf_52
    750          #endif
    751                    }
    752                    else if (flags & FLAGS_LONG) {
   \                     ??_vsnprintf_65: (+1)
   \      0x3FC   0x05E0             LSLS     R0,R4,#+23
   \      0x3FE   0xD513             BPL.N    ??_vsnprintf_66
    753                      idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
   \      0x400   0x6830             LDR      R0,[R6, #+0]
   \      0x402   0x1D36             ADDS     R6,R6,#+4
   \      0x404   0x9405             STR      R4,[SP, #+20]
   \      0x406   0x9909             LDR      R1,[SP, #+36]
   \      0x408   0x9104             STR      R1,[SP, #+16]
   \      0x40A   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \      0x40E   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \      0x412   0x2100             MOVS     R1,#+0
   \      0x414   0x9101             STR      R1,[SP, #+4]
   \      0x416   0x9000             STR      R0,[SP, #+0]
   \      0x418   0x4653             MOV      R3,R10
   \      0x41A   0x002A             MOVS     R2,R5
   \      0x41C   0x9911             LDR      R1,[SP, #+68]
   \      0x41E   0x0038             MOVS     R0,R7
   \      0x420   0x.... 0x....      BL       _ntoa_long
   \      0x424   0x0005             MOVS     R5,R0
   \      0x426   0xE024             B.N      ??_vsnprintf_52
    754                    }
    755                    else {
    756                      const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
   \                     ??_vsnprintf_66: (+1)
   \      0x428   0x0660             LSLS     R0,R4,#+25
   \      0x42A   0xD505             BPL.N    ??_vsnprintf_67
   \      0x42C   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \      0x430   0x1D36             ADDS     R6,R6,#+4
   \      0x432   0xFA5F 0xFB8B      UXTB     R11,R11
   \      0x436   0xE00A             B.N      ??_vsnprintf_68
   \                     ??_vsnprintf_67: (+1)
   \      0x438   0x0620             LSLS     R0,R4,#+24
   \      0x43A   0xD505             BPL.N    ??_vsnprintf_69
   \      0x43C   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \      0x440   0x1D36             ADDS     R6,R6,#+4
   \      0x442   0xFA1F 0xFB8B      UXTH     R11,R11
   \      0x446   0xE002             B.N      ??_vsnprintf_68
   \                     ??_vsnprintf_69: (+1)
   \      0x448   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \      0x44C   0x1D36             ADDS     R6,R6,#+4
    757                      idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
   \                     ??_vsnprintf_68: (+1)
   \      0x44E   0x9405             STR      R4,[SP, #+20]
   \      0x450   0x9809             LDR      R0,[SP, #+36]
   \      0x452   0x9004             STR      R0,[SP, #+16]
   \      0x454   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \      0x458   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \      0x45C   0x2000             MOVS     R0,#+0
   \      0x45E   0x9001             STR      R0,[SP, #+4]
   \      0x460   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \      0x464   0x4653             MOV      R3,R10
   \      0x466   0x002A             MOVS     R2,R5
   \      0x468   0x9911             LDR      R1,[SP, #+68]
   \      0x46A   0x0038             MOVS     R0,R7
   \      0x46C   0x.... 0x....      BL       _ntoa_long
   \      0x470   0x0005             MOVS     R5,R0
    758                    }
    759                  }
    760                  format++;
   \                     ??_vsnprintf_52: (+1)
   \      0x472   0x9812             LDR      R0,[SP, #+72]
   \      0x474   0x1C40             ADDS     R0,R0,#+1
   \      0x476   0x9012             STR      R0,[SP, #+72]
    761                  break;
   \      0x478   0xE5CF             B.N      ??_vsnprintf_0
    762                }
    763          #if defined(PRINTF_SUPPORT_FLOAT)
    764                case 'f' :
    765                case 'F' :
    766                  if (*format == 'F') flags |= FLAGS_UPPERCASE;
   \                     ??_vsnprintf_30: (+1)
   \      0x47A   0x9812             LDR      R0,[SP, #+72]
   \      0x47C   0x7800             LDRB     R0,[R0, #+0]
   \      0x47E   0x2846             CMP      R0,#+70
   \      0x480   0xD101             BNE.N    ??_vsnprintf_70
   \      0x482   0xF054 0x0420      ORRS     R4,R4,#0x20
    767                  idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
   \                     ??_vsnprintf_70: (+1)
   \      0x486   0x1DF0             ADDS     R0,R6,#+7
   \      0x488   0xF030 0x0007      BICS     R0,R0,#0x7
   \      0x48C   0xED90 0x0B00      VLDR     D0,[R0, #0]
   \      0x490   0xF110 0x0608      ADDS     R6,R0,#+8
   \      0x494   0x9402             STR      R4,[SP, #+8]
   \      0x496   0x9809             LDR      R0,[SP, #+36]
   \      0x498   0x9001             STR      R0,[SP, #+4]
   \      0x49A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x49E   0x4653             MOV      R3,R10
   \      0x4A0   0x002A             MOVS     R2,R5
   \      0x4A2   0x9911             LDR      R1,[SP, #+68]
   \      0x4A4   0x0038             MOVS     R0,R7
   \      0x4A6   0x.... 0x....      BL       _ftoa
   \      0x4AA   0x0005             MOVS     R5,R0
    768                  format++;
   \      0x4AC   0x9812             LDR      R0,[SP, #+72]
   \      0x4AE   0x1C40             ADDS     R0,R0,#+1
   \      0x4B0   0x9012             STR      R0,[SP, #+72]
    769                  break;
   \      0x4B2   0xE5B2             B.N      ??_vsnprintf_0
    770          #if defined(PRINTF_SUPPORT_EXPONENTIAL)
    771                case 'e':
    772                case 'E':
    773                case 'g':
    774                case 'G':
    775                  if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
   \                     ??_vsnprintf_29: (+1)
   \      0x4B4   0x9812             LDR      R0,[SP, #+72]
   \      0x4B6   0x7800             LDRB     R0,[R0, #+0]
   \      0x4B8   0x2867             CMP      R0,#+103
   \      0x4BA   0xD003             BEQ.N    ??_vsnprintf_71
   \      0x4BC   0x9812             LDR      R0,[SP, #+72]
   \      0x4BE   0x7800             LDRB     R0,[R0, #+0]
   \      0x4C0   0x2847             CMP      R0,#+71
   \      0x4C2   0xD101             BNE.N    ??_vsnprintf_72
   \                     ??_vsnprintf_71: (+1)
   \      0x4C4   0xF454 0x6400      ORRS     R4,R4,#0x800
    776                  if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
   \                     ??_vsnprintf_72: (+1)
   \      0x4C8   0x9812             LDR      R0,[SP, #+72]
   \      0x4CA   0x7800             LDRB     R0,[R0, #+0]
   \      0x4CC   0x2845             CMP      R0,#+69
   \      0x4CE   0xD003             BEQ.N    ??_vsnprintf_73
   \      0x4D0   0x9812             LDR      R0,[SP, #+72]
   \      0x4D2   0x7800             LDRB     R0,[R0, #+0]
   \      0x4D4   0x2847             CMP      R0,#+71
   \      0x4D6   0xD101             BNE.N    ??_vsnprintf_74
   \                     ??_vsnprintf_73: (+1)
   \      0x4D8   0xF054 0x0420      ORRS     R4,R4,#0x20
    777                  idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
   \                     ??_vsnprintf_74: (+1)
   \      0x4DC   0x1DF0             ADDS     R0,R6,#+7
   \      0x4DE   0xF030 0x0007      BICS     R0,R0,#0x7
   \      0x4E2   0xED90 0x0B00      VLDR     D0,[R0, #0]
   \      0x4E6   0xF110 0x0608      ADDS     R6,R0,#+8
   \      0x4EA   0x9402             STR      R4,[SP, #+8]
   \      0x4EC   0x9809             LDR      R0,[SP, #+36]
   \      0x4EE   0x9001             STR      R0,[SP, #+4]
   \      0x4F0   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x4F4   0x4653             MOV      R3,R10
   \      0x4F6   0x002A             MOVS     R2,R5
   \      0x4F8   0x9911             LDR      R1,[SP, #+68]
   \      0x4FA   0x0038             MOVS     R0,R7
   \      0x4FC   0x.... 0x....      BL       _etoa
   \      0x500   0x0005             MOVS     R5,R0
    778                  format++;
   \      0x502   0x9812             LDR      R0,[SP, #+72]
   \      0x504   0x1C40             ADDS     R0,R0,#+1
   \      0x506   0x9012             STR      R0,[SP, #+72]
    779                  break;
   \      0x508   0xE587             B.N      ??_vsnprintf_0
    780          #endif  // PRINTF_SUPPORT_EXPONENTIAL
    781          #endif  // PRINTF_SUPPORT_FLOAT
    782                case 'c' : {
    783                  unsigned int l = 1U;
   \                     ??_vsnprintf_32: (+1)
   \      0x50A   0xF05F 0x0901      MOVS     R9,#+1
    784                  // pre padding
    785                  if (!(flags & FLAGS_LEFT)) {
   \      0x50E   0x07A0             LSLS     R0,R4,#+30
   \      0x510   0xD40C             BMI.N    ??_vsnprintf_75
    786                    while (l++ < width) {
   \                     ??_vsnprintf_76: (+1)
   \      0x512   0x4649             MOV      R1,R9
   \      0x514   0xF111 0x0901      ADDS     R9,R1,#+1
   \      0x518   0x9809             LDR      R0,[SP, #+36]
   \      0x51A   0x4281             CMP      R1,R0
   \      0x51C   0xD206             BCS.N    ??_vsnprintf_75
    787                      out(' ', buffer, idx++, maxlen);
   \      0x51E   0x4653             MOV      R3,R10
   \      0x520   0x002A             MOVS     R2,R5
   \      0x522   0x9911             LDR      R1,[SP, #+68]
   \      0x524   0x2020             MOVS     R0,#+32
   \      0x526   0x47B8             BLX      R7
   \      0x528   0x1C6D             ADDS     R5,R5,#+1
   \      0x52A   0xE7F2             B.N      ??_vsnprintf_76
    788                    }
    789                  }
    790                  // char output
    791                  out((char)va_arg(va, int), buffer, idx++, maxlen);
   \                     ??_vsnprintf_75: (+1)
   \      0x52C   0x6830             LDR      R0,[R6, #+0]
   \      0x52E   0x1D36             ADDS     R6,R6,#+4
   \      0x530   0x4653             MOV      R3,R10
   \      0x532   0x002A             MOVS     R2,R5
   \      0x534   0x9911             LDR      R1,[SP, #+68]
   \      0x536   0xB2C0             UXTB     R0,R0
   \      0x538   0x47B8             BLX      R7
   \      0x53A   0x1C6D             ADDS     R5,R5,#+1
    792                  // post padding
    793                  if (flags & FLAGS_LEFT) {
   \      0x53C   0x07A0             LSLS     R0,R4,#+30
   \      0x53E   0xD50C             BPL.N    ??_vsnprintf_77
    794                    while (l++ < width) {
   \                     ??_vsnprintf_78: (+1)
   \      0x540   0x4649             MOV      R1,R9
   \      0x542   0xF111 0x0901      ADDS     R9,R1,#+1
   \      0x546   0x9809             LDR      R0,[SP, #+36]
   \      0x548   0x4281             CMP      R1,R0
   \      0x54A   0xD206             BCS.N    ??_vsnprintf_77
    795                      out(' ', buffer, idx++, maxlen);
   \      0x54C   0x4653             MOV      R3,R10
   \      0x54E   0x002A             MOVS     R2,R5
   \      0x550   0x9911             LDR      R1,[SP, #+68]
   \      0x552   0x2020             MOVS     R0,#+32
   \      0x554   0x47B8             BLX      R7
   \      0x556   0x1C6D             ADDS     R5,R5,#+1
   \      0x558   0xE7F2             B.N      ??_vsnprintf_78
    796                    }
    797                  }
    798                  format++;
   \                     ??_vsnprintf_77: (+1)
   \      0x55A   0x9812             LDR      R0,[SP, #+72]
   \      0x55C   0x1C40             ADDS     R0,R0,#+1
   \      0x55E   0x9012             STR      R0,[SP, #+72]
    799                  break;
   \      0x560   0xE55B             B.N      ??_vsnprintf_0
    800                }
    801          
    802                case 's' : {
    803                  const char* p = va_arg(va, char*);
   \                     ??_vsnprintf_34: (+1)
   \      0x562   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \      0x566   0x1D36             ADDS     R6,R6,#+4
    804                  unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
   \      0x568   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x56C   0xD001             BEQ.N    ??_vsnprintf_79
   \      0x56E   0x4641             MOV      R1,R8
   \      0x570   0xE001             B.N      ??_vsnprintf_80
   \                     ??_vsnprintf_79: (+1)
   \      0x572   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \                     ??_vsnprintf_80: (+1)
   \      0x576   0x4658             MOV      R0,R11
   \      0x578   0x.... 0x....      BL       _strnlen_s
   \      0x57C   0x4681             MOV      R9,R0
    805                  // pre padding
    806                  if (flags & FLAGS_PRECISION) {
   \      0x57E   0x0560             LSLS     R0,R4,#+21
   \      0x580   0xD502             BPL.N    ??_vsnprintf_81
    807                    l = (l < precision ? l : precision);
   \      0x582   0x45C1             CMP      R9,R8
   \      0x584   0xD300             BCC.N    ??_vsnprintf_81
   \                     ??_vsnprintf_82: (+1)
   \      0x586   0x46C1             MOV      R9,R8
    808                  }
    809                  if (!(flags & FLAGS_LEFT)) {
   \                     ??_vsnprintf_81: (+1)
   \      0x588   0x07A0             LSLS     R0,R4,#+30
   \      0x58A   0xD40C             BMI.N    ??_vsnprintf_83
    810                    while (l++ < width) {
   \                     ??_vsnprintf_84: (+1)
   \      0x58C   0x4649             MOV      R1,R9
   \      0x58E   0xF111 0x0901      ADDS     R9,R1,#+1
   \      0x592   0x9809             LDR      R0,[SP, #+36]
   \      0x594   0x4281             CMP      R1,R0
   \      0x596   0xD206             BCS.N    ??_vsnprintf_83
    811                      out(' ', buffer, idx++, maxlen);
   \      0x598   0x4653             MOV      R3,R10
   \      0x59A   0x002A             MOVS     R2,R5
   \      0x59C   0x9911             LDR      R1,[SP, #+68]
   \      0x59E   0x2020             MOVS     R0,#+32
   \      0x5A0   0x47B8             BLX      R7
   \      0x5A2   0x1C6D             ADDS     R5,R5,#+1
   \      0x5A4   0xE7F2             B.N      ??_vsnprintf_84
    812                    }
    813                  }
    814                  // string output
    815                  while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   \                     ??_vsnprintf_83: (+1)
   \      0x5A6   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \      0x5AA   0x2800             CMP      R0,#+0
   \      0x5AC   0xD010             BEQ.N    ??_vsnprintf_85
   \      0x5AE   0x0560             LSLS     R0,R4,#+21
   \      0x5B0   0xD504             BPL.N    ??_vsnprintf_86
   \      0x5B2   0x4640             MOV      R0,R8
   \      0x5B4   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \      0x5B8   0x2800             CMP      R0,#+0
   \      0x5BA   0xD009             BEQ.N    ??_vsnprintf_85
    816                    out(*(p++), buffer, idx++, maxlen);
   \                     ??_vsnprintf_86: (+1)
   \      0x5BC   0x002A             MOVS     R2,R5
   \      0x5BE   0x1C55             ADDS     R5,R2,#+1
   \      0x5C0   0x4653             MOV      R3,R10
   \      0x5C2   0x9911             LDR      R1,[SP, #+68]
   \      0x5C4   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \      0x5C8   0x47B8             BLX      R7
   \      0x5CA   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \      0x5CE   0xE7EA             B.N      ??_vsnprintf_83
    817                  }
    818                  // post padding
    819                  if (flags & FLAGS_LEFT) {
   \                     ??_vsnprintf_85: (+1)
   \      0x5D0   0x07A0             LSLS     R0,R4,#+30
   \      0x5D2   0xD50C             BPL.N    ??_vsnprintf_87
    820                    while (l++ < width) {
   \                     ??_vsnprintf_88: (+1)
   \      0x5D4   0x4648             MOV      R0,R9
   \      0x5D6   0xF110 0x0901      ADDS     R9,R0,#+1
   \      0x5DA   0x9909             LDR      R1,[SP, #+36]
   \      0x5DC   0x4288             CMP      R0,R1
   \      0x5DE   0xD206             BCS.N    ??_vsnprintf_87
    821                      out(' ', buffer, idx++, maxlen);
   \      0x5E0   0x4653             MOV      R3,R10
   \      0x5E2   0x002A             MOVS     R2,R5
   \      0x5E4   0x9911             LDR      R1,[SP, #+68]
   \      0x5E6   0x2020             MOVS     R0,#+32
   \      0x5E8   0x47B8             BLX      R7
   \      0x5EA   0x1C6D             ADDS     R5,R5,#+1
   \      0x5EC   0xE7F2             B.N      ??_vsnprintf_88
    822                    }
    823                  }
    824                  format++;
   \                     ??_vsnprintf_87: (+1)
   \      0x5EE   0x9812             LDR      R0,[SP, #+72]
   \      0x5F0   0x1C40             ADDS     R0,R0,#+1
   \      0x5F2   0x9012             STR      R0,[SP, #+72]
    825                  break;
   \      0x5F4   0xE511             B.N      ??_vsnprintf_0
    826                }
    827          
    828                case 'p' : {
    829                  width = sizeof(void*) * 2U;
   \                     ??_vsnprintf_33: (+1)
   \      0x5F6   0x2008             MOVS     R0,#+8
   \      0x5F8   0x9009             STR      R0,[SP, #+36]
    830                  flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
   \      0x5FA   0xF054 0x0421      ORRS     R4,R4,#0x21
    831          #if defined(PRINTF_SUPPORT_LONG_LONG)
    832                  const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
   \      0x5FE   0xF05F 0x0900      MOVS     R9,#+0
    833                  if (is_ll) {
   \      0x602   0x4648             MOV      R0,R9
   \      0x604   0xB2C0             UXTB     R0,R0
   \      0x606   0x2800             CMP      R0,#+0
   \      0x608   0xD018             BEQ.N    ??_vsnprintf_89
    834                    idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
   \      0x60A   0x6832             LDR      R2,[R6, #+0]
   \      0x60C   0x1D36             ADDS     R6,R6,#+4
   \      0x60E   0x9408             STR      R4,[SP, #+32]
   \      0x610   0x9809             LDR      R0,[SP, #+36]
   \      0x612   0x9007             STR      R0,[SP, #+28]
   \      0x614   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \      0x618   0x2010             MOVS     R0,#+16
   \      0x61A   0x2100             MOVS     R1,#+0
   \      0x61C   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
   \      0x620   0x2000             MOVS     R0,#+0
   \      0x622   0x9002             STR      R0,[SP, #+8]
   \      0x624   0x0010             MOVS     R0,R2
   \      0x626   0x2100             MOVS     R1,#+0
   \      0x628   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x62C   0x4653             MOV      R3,R10
   \      0x62E   0x002A             MOVS     R2,R5
   \      0x630   0x9911             LDR      R1,[SP, #+68]
   \      0x632   0x0038             MOVS     R0,R7
   \      0x634   0x.... 0x....      BL       _ntoa_long_long
   \      0x638   0x0005             MOVS     R5,R0
   \      0x63A   0xE012             B.N      ??_vsnprintf_90
    835                  }
    836                  else {
    837          #endif
    838                    idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
   \                     ??_vsnprintf_89: (+1)
   \      0x63C   0x6830             LDR      R0,[R6, #+0]
   \      0x63E   0x1D36             ADDS     R6,R6,#+4
   \      0x640   0x9405             STR      R4,[SP, #+20]
   \      0x642   0x9909             LDR      R1,[SP, #+36]
   \      0x644   0x9104             STR      R1,[SP, #+16]
   \      0x646   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \      0x64A   0x2110             MOVS     R1,#+16
   \      0x64C   0x9102             STR      R1,[SP, #+8]
   \      0x64E   0x2100             MOVS     R1,#+0
   \      0x650   0x9101             STR      R1,[SP, #+4]
   \      0x652   0x9000             STR      R0,[SP, #+0]
   \      0x654   0x4653             MOV      R3,R10
   \      0x656   0x002A             MOVS     R2,R5
   \      0x658   0x9911             LDR      R1,[SP, #+68]
   \      0x65A   0x0038             MOVS     R0,R7
   \      0x65C   0x.... 0x....      BL       _ntoa_long
   \      0x660   0x0005             MOVS     R5,R0
    839          #if defined(PRINTF_SUPPORT_LONG_LONG)
    840                  }
    841          #endif
    842                  format++;
   \                     ??_vsnprintf_90: (+1)
   \      0x662   0x9812             LDR      R0,[SP, #+72]
   \      0x664   0x1C40             ADDS     R0,R0,#+1
   \      0x666   0x9012             STR      R0,[SP, #+72]
    843                  break;
   \      0x668   0xE4D7             B.N      ??_vsnprintf_0
    844                }
    845          
    846                case '%' :
    847                  out('%', buffer, idx++, maxlen);
   \                     ??_vsnprintf_28: (+1)
   \      0x66A   0x4653             MOV      R3,R10
   \      0x66C   0x002A             MOVS     R2,R5
   \      0x66E   0x9911             LDR      R1,[SP, #+68]
   \      0x670   0x2025             MOVS     R0,#+37
   \      0x672   0x47B8             BLX      R7
   \      0x674   0x1C6D             ADDS     R5,R5,#+1
    848                  format++;
   \      0x676   0x9812             LDR      R0,[SP, #+72]
   \      0x678   0x1C40             ADDS     R0,R0,#+1
   \      0x67A   0x9012             STR      R0,[SP, #+72]
    849                  break;
   \      0x67C   0xE4CD             B.N      ??_vsnprintf_0
    850          
    851                default :
    852                  out(*format, buffer, idx++, maxlen);
   \                     ??_vsnprintf_35: (+1)
   \      0x67E   0x4653             MOV      R3,R10
   \      0x680   0x002A             MOVS     R2,R5
   \      0x682   0x9911             LDR      R1,[SP, #+68]
   \      0x684   0x9812             LDR      R0,[SP, #+72]
   \      0x686   0x7800             LDRB     R0,[R0, #+0]
   \      0x688   0x47B8             BLX      R7
   \      0x68A   0x1C6D             ADDS     R5,R5,#+1
    853                  format++;
   \      0x68C   0x9812             LDR      R0,[SP, #+72]
   \      0x68E   0x1C40             ADDS     R0,R0,#+1
   \      0x690   0x9012             STR      R0,[SP, #+72]
    854                  break;
   \      0x692   0xE4C2             B.N      ??_vsnprintf_0
    855              }
    856            }
    857          
    858            // termination
    859            out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
   \                     ??_vsnprintf_1: (+1)
   \      0x694   0x4555             CMP      R5,R10
   \      0x696   0xD201             BCS.N    ??_vsnprintf_91
   \      0x698   0x002A             MOVS     R2,R5
   \      0x69A   0xE001             B.N      ??_vsnprintf_92
   \                     ??_vsnprintf_91: (+1)
   \      0x69C   0xF1BA 0x0201      SUBS     R2,R10,#+1
   \                     ??_vsnprintf_92: (+1)
   \      0x6A0   0x4653             MOV      R3,R10
   \      0x6A2   0x9911             LDR      R1,[SP, #+68]
   \      0x6A4   0x2000             MOVS     R0,#+0
   \      0x6A6   0x47B8             BLX      R7
    860          
    861            // return written chars without terminating \0
    862            return (int)idx;
   \      0x6A8   0x0028             MOVS     R0,R5
   \      0x6AA   0xB013             ADD      SP,SP,#+76
   \      0x6AC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    863          }
    864          
    865          
    866          ///////////////////////////////////////////////////////////////////////////////
    867          

   \                                 In section .text, align 2, keep-with-next
    868          int printf(const char* format, ...)
    869          {
   \                     printf: (+1)
   \        0x0   0xB40E             PUSH     {R1-R3}
   \        0x2   0xB53C             PUSH     {R2-R5,LR}
   \        0x4   0x0005             MOVS     R5,R0
    870            va_list va;
    871            va_start(va, format);
   \        0x6   0xAC05             ADD      R4,SP,#+20
    872            char buffer[1];
    873            const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
   \        0x8   0x9400             STR      R4,[SP, #+0]
   \        0xA   0x002B             MOVS     R3,R5
   \        0xC   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x10   0xA901             ADD      R1,SP,#+4
   \       0x12   0x....             LDR.N    R0,??DataTable10_22
   \       0x14   0x.... 0x....      BL       _vsnprintf
    874            va_end(va);
    875            return ret;
   \       0x18   0xBC36             POP      {R1,R2,R4,R5}
   \       0x1A   0xF85D 0xFB10      LDR      PC,[SP], #+16
    876          }
    877          
    878          

   \                                 In section .text, align 2, keep-with-next
    879          int sprintf(char* buffer, const char* format, ...)
    880          {
   \                     sprintf: (+1)
   \        0x0   0xB40C             PUSH     {R2,R3}
   \        0x2   0xB57C             PUSH     {R2-R6,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
    881            va_list va;
    882            va_start(va, format);
   \        0x8   0xAD06             ADD      R5,SP,#+24
    883            const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
   \        0xA   0x9500             STR      R5,[SP, #+0]
   \        0xC   0x0023             MOVS     R3,R4
   \        0xE   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x12   0x0031             MOVS     R1,R6
   \       0x14   0x....             LDR.N    R0,??DataTable10_23
   \       0x16   0x.... 0x....      BL       _vsnprintf
    884            va_end(va);
    885            return ret;
   \       0x1A   0xBC76             POP      {R1,R2,R4-R6}
   \       0x1C   0xF85D 0xFB0C      LDR      PC,[SP], #+12
    886          }
    887          
    888          

   \                                 In section .text, align 2, keep-with-next
    889          int snprintf(char* buffer, size_t count, const char* format, ...)
    890          {
   \                     snprintf: (+1)
   \        0x0   0xB408             PUSH     {R3}
   \        0x2   0xB5FC             PUSH     {R2-R7,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
    891            va_list va;
    892            va_start(va, format);
   \        0xA   0xAE07             ADD      R6,SP,#+28
    893            const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
   \        0xC   0x9600             STR      R6,[SP, #+0]
   \        0xE   0x002B             MOVS     R3,R5
   \       0x10   0x0022             MOVS     R2,R4
   \       0x12   0x0039             MOVS     R1,R7
   \       0x14   0x....             LDR.N    R0,??DataTable10_23
   \       0x16   0x.... 0x....      BL       _vsnprintf
    894            va_end(va);
    895            return ret;
   \       0x1A   0xBCF6             POP      {R1,R2,R4-R7}
   \       0x1C   0xF85D 0xFB08      LDR      PC,[SP], #+8
    896          }
    897          
    898          
    899          #if (defined(__GNUC__) && !defined(__clang__))
    900          int sniprintf (char *, size_t, const char *, ...) __copy(snprintf) __attribute__ ((__alias__("snprintf")));
    901          int puts(const char* s)
    902          {
    903            // handle calls to printf("..."); here
    904            while (*s) {
    905              _putchar(*s++);
    906            }
    907            // puts: Writes the C string pointed by str to the standard output(stdout) and appends a newline character('\n')
    908            _putchar('\n'); 
    909            return 0;
    910          }
    911          #endif
    912          
    913          

   \                                 In section .text, align 2, keep-with-next
    914          int vprintf(const char* format, va_list va)
    915          {
   \                     vprintf: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    916            char buffer[1];
    917            return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
   \        0x6   0x9400             STR      R4,[SP, #+0]
   \        0x8   0x002B             MOVS     R3,R5
   \        0xA   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \        0xE   0xA901             ADD      R1,SP,#+4
   \       0x10   0x....             LDR.N    R0,??DataTable10_22
   \       0x12   0x.... 0x....      BL       _vsnprintf
   \       0x16   0xBD3E             POP      {R1-R5,PC}
    918          }
    919          
    920          

   \                                 In section .text, align 2, keep-with-next
    921          int vsnprintf(char* buffer, size_t count, const char* format, va_list va)
    922          {
   \                     vsnprintf: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001E             MOVS     R6,R3
    923            return _vsnprintf(_out_buffer, buffer, count, format, va);
   \        0xA   0x9600             STR      R6,[SP, #+0]
   \        0xC   0x002B             MOVS     R3,R5
   \        0xE   0x0022             MOVS     R2,R4
   \       0x10   0x0039             MOVS     R1,R7
   \       0x12   0x....             LDR.N    R0,??DataTable10_23
   \       0x14   0x.... 0x....      BL       _vsnprintf
   \       0x18   0xBDF2             POP      {R1,R4-R7,PC}
    924          }
    925          
    926          

   \                                 In section .text, align 2, keep-with-next
    927          int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
    928          {
   \                     fctprintf: (+1)
   \        0x0   0xB408             PUSH     {R3}
   \        0x2   0xB5FF             PUSH     {R0-R7,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
    929            va_list va;
    930            va_start(va, format);
   \        0xA   0xAE09             ADD      R6,SP,#+36
    931            const out_fct_wrap_type out_fct_wrap = { out, arg };
   \        0xC   0x9701             STR      R7,[SP, #+4]
   \        0xE   0x9402             STR      R4,[SP, #+8]
    932            const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
   \       0x10   0x9600             STR      R6,[SP, #+0]
   \       0x12   0x002B             MOVS     R3,R5
   \       0x14   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x18   0xA901             ADD      R1,SP,#+4
   \       0x1A   0x....             LDR.N    R0,??DataTable10_24
   \       0x1C   0x.... 0x....      BL       _vsnprintf
    933            va_end(va);
    934            return ret;
   \       0x20   0xB004             ADD      SP,SP,#+16
   \       0x22   0xBCF0             POP      {R4-R7}
   \       0x24   0xF85D 0xFB08      LDR      PC,[SP], #+8
    935          }
    936          
    937          

   \                                 In section .text, align 2, keep-with-next
    938          int vfctprintf(void (*out)(char character, void* arg), void* arg, const char* format, va_list va)
    939          {
   \                     vfctprintf: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001E             MOVS     R6,R3
    940            const out_fct_wrap_type out_fct_wrap = { out, arg };
   \        0xA   0x9701             STR      R7,[SP, #+4]
   \        0xC   0x9402             STR      R4,[SP, #+8]
    941            const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
   \        0xE   0x9600             STR      R6,[SP, #+0]
   \       0x10   0x002B             MOVS     R3,R5
   \       0x12   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x16   0xA901             ADD      R1,SP,#+4
   \       0x18   0x....             LDR.N    R0,??DataTable10_24
   \       0x1A   0x.... 0x....      BL       _vsnprintf
    942            return ret;
   \       0x1E   0xBDFE             POP      {R1-R7,PC}
    943          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x6E 0x61          DC8      "nan"          
   \              0x6E 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x66 0x6E          DC8      "fni"          
   \              0x69 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x0000'0000        DC32     0x0,0x0        
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x7FF0'0000        DC32     0x7ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x41CD'CD65        DC32     0x41cdcd65

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0xC1CD'CD65        DC32     0xc1cdcd65

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x....'....        DC32     `_ftoa::pow10`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x3FE0'0000        DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x000F'FFFF        DC32     0xfffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x3FF0'0000        DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x509F'79FB        DC32     0x509f79fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x3FD3'4413        DC32     0x3fd34413

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x8B60'C8B3        DC32     0x8b60c8b3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0x3FC6'8A28        DC32     0x3fc68a28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0xBFF8'0000        DC32     0xbff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \        0x0   0x636F'4361        DC32     0x636f4361

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \        0x0   0x3FD2'87A7        DC32     0x3fd287a7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \        0x0   0x0979'A371        DC32     0x979a371

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \        0x0   0x400A'934F        DC32     0x400a934f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \        0x0   0xBBB5'5516        DC32     0xbbb55516

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \        0x0   0x4002'6BB1        DC32     0x40026bb1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \        0x0   0xFEFA'39EF        DC32     0xfefa39ef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \        0x0   0xBFE6'2E42        DC32     0xbfe62e42

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \        0x0   0x402C'0000        DC32     0x402c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \        0x0   0x4024'0000        DC32     0x40240000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \        0x0   0x4018'0000        DC32     0x40180000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \        0x0   0xEB1C'432D        DC32     0xeb1c432d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \        0x0   0x3F1A'36E2        DC32     0x3f1a36e2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \        0x0   0x412E'8480        DC32     0x412e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \        0x0   0x....'....        DC32     _out_null

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_22:
   \        0x0   0x....'....        DC32     _out_char

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_23:
   \        0x0   0x....'....        DC32     _out_buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_24:
   \        0x0   0x....'....        DC32     _out_fct

   \                                 In section .rodata, align 4
   \        0x0   0x6E 0x61          DC8 "nan"
   \              0x6E 0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x66 0x6E          DC8 "fni-"
   \              0x69 0x2D    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x66 0x6E          DC8 "fni+"
   \              0x69 0x2B    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .rodata, align 4
   \        0x0   0x66 0x6E          DC8 "fni"
   \              0x69 0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _atoi
        16   -> _is_digit
     112   _etoa
       112   -- Indirect call
       112   -> __aeabi_d2iz
       112   -> __aeabi_dadd
       112   -> __aeabi_ddiv
       112   -> __aeabi_dmul
       112   -> __aeabi_dsub
       112   -> __aeabi_i2d
       112   -> _ftoa
       112   -> _ntoa_long
       112 __aeabi_cdcmpeq
       112 __aeabi_cdcmple
       112 __aeabi_cdrcmple
     136   _ftoa
       136   -> __aeabi_d2iz
       136   -> __aeabi_d2uiz
       136   -> __aeabi_dmul
       136   -> __aeabi_dsub
       136   -> __aeabi_i2d
       136   -> __aeabi_ui2d
       136   -> _etoa
       136   -> _out_rev
       136 __aeabi_cdcmpeq
       136 __aeabi_cdcmple
       136 __aeabi_cdrcmple
       0   _is_digit
      64   _ntoa_format
        64   -> _out_rev
      96   _ntoa_long
        96   -> _ntoa_format
     112   _ntoa_long_long
       112   -> _ntoa_format
       112 __aeabi_uldivmod
       0   _out_buffer
      24   _out_char
        24   -> _putchar
      24   _out_fct
        24   -- Indirect call
       0   _out_null
      40   _out_rev
        40   -- Indirect call
       0   _strnlen_s
     112   _vsnprintf
       112   -- Indirect call
       112   -> _atoi
       112   -> _etoa
       112   -> _ftoa
       112   -> _is_digit
       112   -> _ntoa_long
       112   -> _ntoa_long_long
       112   -> _strnlen_s
      40   fctprintf
        40   -> _vsnprintf
      32   printf
        32   -> _vsnprintf
      32   snprintf
        32   -> _vsnprintf
      32   sprintf
        32   -> _vsnprintf
      32   vfctprintf
        32   -> _vsnprintf
      24   vprintf
        24   -> _vsnprintf
      24   vsnprintf
        24   -> _vsnprintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable1_1
       8  ??DataTable1_2
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable9
       4  ?_0
       8  ?_1
       8  ?_2
       4  ?_3
      40  _atoi
     896  _etoa
     788  _ftoa
      24  _is_digit
     284  _ntoa_format
     158  _ntoa_long
     170  _ntoa_long_long
       8  _out_buffer
      28  _out_char
      30  _out_fct
       2  _out_null
     110  _out_rev
      24  _strnlen_s
   1'712  _vsnprintf
      40  fctprintf
      80  pow10
      30  printf
      32  snprintf
      32  sprintf
      32  vfctprintf
      24  vprintf
      26  vsnprintf

 
   104 bytes in section .rodata
 4'634 bytes in section .text
 
 4'634 bytes of CODE  memory
   104 bytes of CONST memory

Errors: none
Warnings: none
