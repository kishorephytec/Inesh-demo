###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:54:06
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\SEGGER_RTT.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\SEGGER_17251983673601104989.dir\SEGGER_RTT.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\SEGGER_RTT.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\SEGGER_17251983673601104989.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\SEGGER_17251983673601104989.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\SEGGER_17251983673601104989.dir\SEGGER_RTT.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\SEGGER_17251983673601104989.dir\SEGGER_RTT.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\SEGGER_17251983673601104989.dir\SEGGER_RTT.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\SEGGER_RTT.c
      1          /*********************************************************************
      2          *                    SEGGER Microcontroller GmbH                     *
      3          *                        The Embedded Experts                        *
      4          **********************************************************************
      5          *                                                                    *
      6          *            (c) 1995 - 2023 SEGGER Microcontroller GmbH             *
      7          *                                                                    *
      8          *       www.segger.com     Support: support@segger.com               *
      9          *                                                                    *
     10          **********************************************************************
     11          *                                                                    *
     12          *       SEGGER SystemView * Real-time application analysis           *
     13          *                                                                    *
     14          **********************************************************************
     15          *                                                                    *
     16          * All rights reserved.                                               *
     17          *                                                                    *
     18          * SEGGER strongly recommends to not make any changes                 *
     19          * to or modify the source code of this software in order to stay     *
     20          * compatible with the SystemView and RTT protocol, and J-Link.       *
     21          *                                                                    *
     22          * Redistribution and use in source and binary forms, with or         *
     23          * without modification, are permitted provided that the following    *
     24          * condition is met:                                                  *
     25          *                                                                    *
     26          * o Redistributions of source code must retain the above copyright   *
     27          *   notice, this condition and the following disclaimer.             *
     28          *                                                                    *
     29          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
     30          * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
     31          * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
     32          * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
     33          * DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
     34          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
     35          * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
     36          * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
     37          * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
     38          * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
     39          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
     40          * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
     41          * DAMAGE.                                                            *
     42          *                                                                    *
     43          **********************************************************************
     44          *                                                                    *
     45          *       SystemView version: 3.52                                    *
     46          *                                                                    *
     47          **********************************************************************
     48          ---------------------------END-OF-HEADER------------------------------
     49          File    : SEGGER_RTT.c
     50          Purpose : Implementation of SEGGER real-time transfer (RTT) which
     51                    allows real-time communication on targets which support
     52                    debugger memory accesses while the CPU is running.
     53          Revision: $Rev: 29668 $
     54          
     55          Additional information:
     56                    Type "int" is assumed to be 32-bits in size
     57                    H->T    Host to target communication
     58                    T->H    Target to host communication
     59          
     60                    RTT channel 0 is always present and reserved for Terminal usage.
     61                    Name is fixed to "Terminal"
     62          
     63                    Effective buffer size: SizeOfBuffer - 1
     64          
     65                    WrOff == RdOff:       Buffer is empty
     66                    WrOff == (RdOff - 1): Buffer is full
     67                    WrOff >  RdOff:       Free space includes wrap-around
     68                    WrOff <  RdOff:       Used space includes wrap-around
     69                    (WrOff == (SizeOfBuffer - 1)) && (RdOff == 0):
     70                                          Buffer full and wrap-around after next byte
     71          
     72          
     73          ----------------------------------------------------------------------
     74          */
     75          
     76          #include "SEGGER_RTT.h"
     77          
     78          #include <string.h>                 // for memcpy
     79          
     80          /*********************************************************************
     81          *
     82          *       Configuration, default values
     83          *
     84          **********************************************************************
     85          */
     86          
     87          #if SEGGER_RTT_CPU_CACHE_LINE_SIZE
     88            #ifdef SEGGER_RTT_CB_ALIGN
     89              #error "Custom SEGGER_RTT_CB_ALIGN() is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
     90            #endif
     91            #ifdef SEGGER_RTT_BUFFER_ALIGN
     92              #error "Custom SEGGER_RTT_BUFFER_ALIGN() is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
     93            #endif
     94            #ifdef SEGGER_RTT_PUT_CB_SECTION
     95              #error "Custom SEGGER_RTT_PUT_CB_SECTION() is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
     96            #endif
     97            #ifdef SEGGER_RTT_PUT_BUFFER_SECTION
     98              #error "Custom SEGGER_RTT_PUT_BUFFER_SECTION() is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
     99            #endif
    100            #ifdef SEGGER_RTT_BUFFER_ALIGNMENT
    101              #error "Custom SEGGER_RTT_BUFFER_ALIGNMENT is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
    102            #endif
    103            #ifdef SEGGER_RTT_ALIGNMENT
    104              #error "Custom SEGGER_RTT_ALIGNMENT is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
    105            #endif
    106          #endif
    107          
    108          #ifndef   BUFFER_SIZE_UP
    109            #define BUFFER_SIZE_UP                                  1024  // Size of the buffer for terminal output of target, up to host
    110          #endif
    111          
    112          #ifndef   BUFFER_SIZE_DOWN
    113            #define BUFFER_SIZE_DOWN                                16    // Size of the buffer for terminal input to target from host (Usually keyboard input)
    114          #endif
    115          
    116          #ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
    117            #define SEGGER_RTT_MAX_NUM_UP_BUFFERS                    2    // Number of up-buffers (T->H) available on this target
    118          #endif
    119          
    120          #ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
    121            #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS                  2    // Number of down-buffers (H->T) available on this target
    122          #endif
    123          
    124          #ifndef SEGGER_RTT_BUFFER_SECTION
    125            #if defined(SEGGER_RTT_SECTION)
    126              #define SEGGER_RTT_BUFFER_SECTION SEGGER_RTT_SECTION
    127            #endif
    128          #endif
    129          
    130          #ifndef   SEGGER_RTT_ALIGNMENT
    131            #define SEGGER_RTT_ALIGNMENT                            SEGGER_RTT_CPU_CACHE_LINE_SIZE
    132          #endif
    133          
    134          #ifndef   SEGGER_RTT_BUFFER_ALIGNMENT
    135            #define SEGGER_RTT_BUFFER_ALIGNMENT                     SEGGER_RTT_CPU_CACHE_LINE_SIZE
    136          #endif
    137          
    138          #ifndef   SEGGER_RTT_MODE_DEFAULT
    139            #define SEGGER_RTT_MODE_DEFAULT                         SEGGER_RTT_MODE_NO_BLOCK_SKIP
    140          #endif
    141          
    142          #ifndef   SEGGER_RTT_LOCK
    143            #define SEGGER_RTT_LOCK()
    144          #endif
    145          
    146          #ifndef   SEGGER_RTT_UNLOCK
    147            #define SEGGER_RTT_UNLOCK()
    148          #endif
    149          
    150          #ifndef   STRLEN
    151            #define STRLEN(a)                                       strlen((a))
    152          #endif
    153          
    154          #ifndef   STRCPY
    155            #define STRCPY(pDest, pSrc)                             strcpy((pDest), (pSrc))
    156          #endif
    157          
    158          #ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
    159            #define SEGGER_RTT_MEMCPY_USE_BYTELOOP                  0
    160          #endif
    161          
    162          #ifndef   SEGGER_RTT_MEMCPY
    163            #ifdef  MEMCPY
    164              #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      MEMCPY((pDest), (pSrc), (NumBytes))
    165            #else
    166              #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      memcpy((pDest), (pSrc), (NumBytes))
    167            #endif
    168          #endif
    169          
    170          #ifndef   MIN
    171            #define MIN(a, b)                                       (((a) < (b)) ? (a) : (b))
    172          #endif
    173          
    174          #ifndef   MAX
    175            #define MAX(a, b)                                       (((a) > (b)) ? (a) : (b))
    176          #endif
    177          //
    178          // For some environments, NULL may not be defined until certain headers are included
    179          //
    180          #ifndef NULL
    181            #define NULL                                            0
    182          #endif
    183          
    184          /*********************************************************************
    185          *
    186          *       Defines, fixed
    187          *
    188          **********************************************************************
    189          */
    190          #if (defined __ICCARM__) || (defined __ICCRX__)
    191            #define RTT_PRAGMA(P) _Pragma(#P)
    192          #endif
    193          
    194          #if SEGGER_RTT_ALIGNMENT || SEGGER_RTT_BUFFER_ALIGNMENT
    195            #if ((defined __GNUC__) || (defined __clang__))
    196              #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
    197            #elif (defined __ICCARM__) || (defined __ICCRX__)
    198              #define PRAGMA(A) _Pragma(#A)
    199          #define SEGGER_RTT_ALIGN(Var, Alignment) RTT_PRAGMA(data_alignment=Alignment) \
    200                                            Var
    201            #elif (defined __CC_ARM)
    202              #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
    203            #else
    204              #error "Alignment not supported for this compiler."
    205            #endif
    206          #else
    207            #define SEGGER_RTT_ALIGN(Var, Alignment) Var
    208          #endif
    209          
    210          #if defined(SEGGER_RTT_SECTION) || defined (SEGGER_RTT_BUFFER_SECTION)
    211            #if ((defined __GNUC__) || (defined __clang__))
    212              #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section))) Var
    213            #elif (defined __ICCARM__) || (defined __ICCRX__)
    214          #define SEGGER_RTT_PUT_SECTION(Var, Section) RTT_PRAGMA(location=Section) \
    215                                                  Var
    216            #elif (defined __CC_ARM)
    217              #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section), zero_init))  Var
    218            #else
    219              #error "Section placement not supported for this compiler."
    220            #endif
    221          #else
    222            #define SEGGER_RTT_PUT_SECTION(Var, Section) Var
    223          #endif
    224          
    225          #if SEGGER_RTT_ALIGNMENT
    226            #define SEGGER_RTT_CB_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_ALIGNMENT)
    227          #else
    228            #define SEGGER_RTT_CB_ALIGN(Var)  Var
    229          #endif
    230          
    231          #if SEGGER_RTT_BUFFER_ALIGNMENT
    232            #define SEGGER_RTT_BUFFER_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_BUFFER_ALIGNMENT)
    233          #else
    234            #define SEGGER_RTT_BUFFER_ALIGN(Var)  Var
    235          #endif
    236          
    237          
    238          #if defined(SEGGER_RTT_SECTION)
    239            #define SEGGER_RTT_PUT_CB_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_SECTION)
    240          #else
    241            #define SEGGER_RTT_PUT_CB_SECTION(Var) Var
    242          #endif
    243          
    244          #if defined(SEGGER_RTT_BUFFER_SECTION)
    245            #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_BUFFER_SECTION)
    246          #else
    247            #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) Var
    248          #endif
    249          
    250          /*********************************************************************
    251          *
    252          *       Static const data
    253          *
    254          **********************************************************************
    255          */
    256          

   \                                 In section .rodata, align 4
    257          static const unsigned char _aTerminalId[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
   \                     _aTerminalId:
   \        0x0   0x30 0x31          DC8 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46
    258          
    259          /*********************************************************************
    260          *
    261          *       Static data
    262          *
    263          **********************************************************************
    264          */
    265          
    266          //
    267          // RTT Control Block and allocate buffers for channel 0
    268          //
    269          #if SEGGER_RTT_CPU_CACHE_LINE_SIZE
    270            #if ((defined __GNUC__) || (defined __clang__))
    271              SEGGER_RTT_CB _SEGGER_RTT                                                             __attribute__ ((aligned (SEGGER_RTT_CPU_CACHE_LINE_SIZE)));
    272              static char   _acUpBuffer  [SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(BUFFER_SIZE_UP)]   __attribute__ ((aligned (SEGGER_RTT_CPU_CACHE_LINE_SIZE)));
    273              static char   _acDownBuffer[SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(BUFFER_SIZE_DOWN)] __attribute__ ((aligned (SEGGER_RTT_CPU_CACHE_LINE_SIZE)));
    274            #elif (defined __ICCARM__)
    275              #pragma data_alignment=SEGGER_RTT_CPU_CACHE_LINE_SIZE
    276              SEGGER_RTT_CB _SEGGER_RTT;
    277              #pragma data_alignment=SEGGER_RTT_CPU_CACHE_LINE_SIZE
    278              static char   _acUpBuffer  [SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(BUFFER_SIZE_UP)];
    279              #pragma data_alignment=SEGGER_RTT_CPU_CACHE_LINE_SIZE
    280              static char   _acDownBuffer[SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(BUFFER_SIZE_DOWN)];
    281            #else
    282              #error "Don't know how to place _SEGGER_RTT, _acUpBuffer, _acDownBuffer cache-line aligned"
    283            #endif
    284          #else

   \                                 In section .bss, align 4
    285            SEGGER_RTT_PUT_CB_SECTION(SEGGER_RTT_CB_ALIGN(SEGGER_RTT_CB _SEGGER_RTT));
   \                     _SEGGER_RTT:
   \        0x0                      DS8 168

   \                                 In section .bss, align 4
    286            SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acUpBuffer  [BUFFER_SIZE_UP]));
   \                     _acUpBuffer:
   \        0x0                      DS8 1'024

   \                                 In section .bss, align 4
    287            SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acDownBuffer[BUFFER_SIZE_DOWN]));
   \                     _acDownBuffer:
   \        0x0                      DS8 1'024
    288          #endif
    289          

   \                                 In section .bss, align 1
    290          static unsigned char _ActiveTerminal;
   \                     _ActiveTerminal:
   \        0x0                      DS8 1
    291          
    292          /*********************************************************************
    293          *
    294          *       Static functions
    295          *
    296          **********************************************************************
    297          */
    298          
    299          /*********************************************************************
    300          *
    301          *       _DoInit()
    302          *
    303          *  Function description
    304          *    Initializes the control block an buffers.
    305          *
    306          *  Notes
    307          *    (1) May only be called via INIT() to avoid overriding settings.
    308          *        The only exception is SEGGER_RTT_Init(), to make an intentional override possible.
    309          */
    310            #define INIT()                                                                             \
    311              do {                                                                                     \
    312                volatile SEGGER_RTT_CB* pRTTCBInit;                                                    \
    313                pRTTCBInit = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF); \
    314                if (pRTTCBInit->acID[0] != 'S') {                                                      \
    315                  _DoInit();                                                                           \
    316                }                                                                                      \
    317              } while (0)
    318          

   \                                 In section .text, align 2, keep-with-next
    319          static void _DoInit(void) {
   \                     _DoInit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    320            volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
    321            static const char _aInitStr[] = "\0\0\0\0\0\0TTR REGGES";  // Init complete ID string to make sure that things also work if RTT is linked to a no-init memory area
    322            unsigned i;
    323            //
    324            // Initialize control block
    325            //
    326            p                     = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable24
    327            memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
   \        0x6   0x25A8             MOVS     R5,#+168
   \        0x8   0x2600             MOVS     R6,#+0
   \        0xA   0x0027             MOVS     R7,R4
   \        0xC   0x0032             MOVS     R2,R6
   \        0xE   0x0029             MOVS     R1,R5
   \       0x10   0x0038             MOVS     R0,R7
   \       0x12   0x.... 0x....      BL       __aeabi_memset
    328            p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   \       0x16   0x2003             MOVS     R0,#+3
   \       0x18   0x6120             STR      R0,[R4, #+16]
    329            p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   \       0x1A   0x2003             MOVS     R0,#+3
   \       0x1C   0x6160             STR      R0,[R4, #+20]
    330            //
    331            // Initialize up buffer 0
    332            //
    333            p->aUp[0].sName         = "Terminal";
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \       0x22   0x61A0             STR      R0,[R4, #+24]
    334            p->aUp[0].pBuffer       = _acUpBuffer;
   \       0x24   0x.... 0x....      LDR.W    R1,??DataTable24_2
   \       0x28   0x61E1             STR      R1,[R4, #+28]
    335            p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
   \       0x2A   0xF44F 0x6180      MOV      R1,#+1024
   \       0x2E   0x6221             STR      R1,[R4, #+32]
    336            p->aUp[0].RdOff         = 0u;
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x62A2             STR      R2,[R4, #+40]
    337            p->aUp[0].WrOff         = 0u;
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x6262             STR      R2,[R4, #+36]
    338            p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   \       0x38   0x2200             MOVS     R2,#+0
   \       0x3A   0x62E2             STR      R2,[R4, #+44]
    339            //
    340            // Initialize down buffer 0
    341            //
    342            p->aDown[0].sName         = "Terminal";
   \       0x3C   0x6620             STR      R0,[R4, #+96]
    343            p->aDown[0].pBuffer       = _acDownBuffer;
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \       0x42   0x6660             STR      R0,[R4, #+100]
    344            p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   \       0x44   0x66A1             STR      R1,[R4, #+104]
    345            p->aDown[0].RdOff         = 0u;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x6720             STR      R0,[R4, #+112]
    346            p->aDown[0].WrOff         = 0u;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x66E0             STR      R0,[R4, #+108]
    347            p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x6760             STR      R0,[R4, #+116]
    348            //
    349            // Finish initialization of the control block.
    350            // Copy Id string backwards to make sure that "SEGGER RTT" is not found in initializer memory (usually flash),
    351            // as this would cause J-Link to "find" the control block at a wrong address.
    352            //
    353            RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
    354            for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
   \       0x52   0x2000             MOVS     R0,#+0
   \                     ??_DoInit_0: (+1)
   \       0x54   0x2810             CMP      R0,#+16
   \       0x56   0xD207             BCS.N    ??_DoInit_1
    355              p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
   \       0x58   0x.... 0x....      LDR.W    R2,??DataTable26
   \       0x5C   0x4241             RSBS     R1,R0,#+0
   \       0x5E   0x4411             ADD      R1,R2,R1
   \       0x60   0x7BC9             LDRB     R1,[R1, #+15]
   \       0x62   0x5421             STRB     R1,[R4, R0]
    356            }
   \       0x64   0x1C40             ADDS     R0,R0,#+1
   \       0x66   0xE7F5             B.N      ??_DoInit_0
    357            RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
    358          }
   \                     ??_DoInit_1: (+1)
   \       0x68   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .rodata, align 4
   \                     `_DoInit::_aInitStr`:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0x54, 0x54
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x54 0x54
   \        0x8   0x52 0x20          DC8 0x52, 0x20, 0x52, 0x45, 0x47, 0x47, 0x45, 0x53
   \              0x52 0x45    
   \              0x47 0x47    
   \              0x45 0x53
   \       0x10   0x00               DC8 0
   \       0x11                      DS8 3
    359          
    360          /*********************************************************************
    361          *
    362          *       _WriteBlocking()
    363          *
    364          *  Function description
    365          *    Stores a specified number of characters in SEGGER RTT ring buffer
    366          *    and updates the associated write pointer which is periodically
    367          *    read by the host.
    368          *    The caller is responsible for managing the write chunk sizes as
    369          *    _WriteBlocking() will block until all data has been posted successfully.
    370          *
    371          *  Parameters
    372          *    pRing        Ring buffer to post to.
    373          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    374          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    375          *
    376          *  Return value
    377          *    >= 0 - Number of bytes written into buffer.
    378          */

   \                                 In section .text, align 2, keep-with-next
    379          static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
   \                     _WriteBlocking: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0014             MOVS     R4,R2
    380            unsigned NumBytesToWrite;
    381            unsigned NumBytesWritten;
    382            unsigned RdOff;
    383            unsigned WrOff;
    384            volatile char* pDst;
    385            //
    386            // Write data to buffer and handle wrap-around if necessary
    387            //
    388            NumBytesWritten = 0u;
   \        0xA   0xF05F 0x0800      MOVS     R8,#+0
    389            WrOff = pRing->WrOff;
   \        0xE   0xF8DA 0x900C      LDR      R9,[R10, #+12]
    390            do {
    391              RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
   \                     ??_WriteBlocking_0: (+1)
   \       0x12   0xF8DA 0x0010      LDR      R0,[R10, #+16]
   \       0x16   0x0007             MOVS     R7,R0
    392              if (RdOff > WrOff) {
   \       0x18   0x45B9             CMP      R9,R7
   \       0x1A   0xD203             BCS.N    ??_WriteBlocking_1
    393                NumBytesToWrite = RdOff - WrOff - 1u;
   \       0x1C   0xEBB7 0x0009      SUBS     R0,R7,R9
   \       0x20   0x1E40             SUBS     R0,R0,#+1
   \       0x22   0xE005             B.N      ??_WriteBlocking_2
    394              } else {
    395                NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
   \                     ??_WriteBlocking_1: (+1)
   \       0x24   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \       0x28   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0x2C   0x1838             ADDS     R0,R7,R0
   \       0x2E   0x1E40             SUBS     R0,R0,#+1
    396              }
    397              NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
   \                     ??_WriteBlocking_2: (+1)
   \       0x30   0xF8DA 0x1008      LDR      R1,[R10, #+8]
   \       0x34   0xEBB1 0x0109      SUBS     R1,R1,R9
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD201             BCS.N    ??_WriteBlocking_3
   \       0x3C   0x0006             MOVS     R6,R0
   \       0x3E   0xE003             B.N      ??_WriteBlocking_4
   \                     ??_WriteBlocking_3: (+1)
   \       0x40   0xF8DA 0x6008      LDR      R6,[R10, #+8]
   \       0x44   0xEBB6 0x0609      SUBS     R6,R6,R9
    398              NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
   \                     ??_WriteBlocking_4: (+1)
   \       0x48   0x42A6             CMP      R6,R4
   \       0x4A   0xD300             BCC.N    ??_WriteBlocking_5
   \                     ??_WriteBlocking_6: (+1)
   \       0x4C   0x0026             MOVS     R6,R4
    399              pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \                     ??_WriteBlocking_5: (+1)
   \       0x4E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x52   0x4448             ADD      R0,R0,R9
   \       0x54   0x9000             STR      R0,[SP, #+0]
    400          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    401              NumBytesWritten += NumBytesToWrite;
    402              NumBytes        -= NumBytesToWrite;
    403              WrOff           += NumBytesToWrite;
    404              while (NumBytesToWrite--) {
    405                *pDst++ = *pBuffer++;
    406              };
    407          #else
    408              SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
   \       0x56   0x9602             STR      R6,[SP, #+8]
   \       0x58   0x9501             STR      R5,[SP, #+4]
   \       0x5A   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \       0x5E   0x9A02             LDR      R2,[SP, #+8]
   \       0x60   0x9901             LDR      R1,[SP, #+4]
   \       0x62   0x4658             MOV      R0,R11
   \       0x64   0x.... 0x....      BL       __aeabi_memcpy
    409              NumBytesWritten += NumBytesToWrite;
   \       0x68   0xEB16 0x0808      ADDS     R8,R6,R8
    410              pBuffer         += NumBytesToWrite;
   \       0x6C   0x4435             ADD      R5,R5,R6
    411              NumBytes        -= NumBytesToWrite;
   \       0x6E   0x1BA4             SUBS     R4,R4,R6
    412              WrOff           += NumBytesToWrite;
   \       0x70   0xEB16 0x0909      ADDS     R9,R6,R9
    413          #endif
    414              if (WrOff == pRing->SizeOfBuffer) {
   \       0x74   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \       0x78   0x4581             CMP      R9,R0
   \       0x7A   0xD101             BNE.N    ??_WriteBlocking_7
    415                WrOff = 0u;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x4681             MOV      R9,R0
    416              }
    417              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    418              pRing->WrOff = WrOff;
   \                     ??_WriteBlocking_7: (+1)
   \       0x80   0xF8CA 0x900C      STR      R9,[R10, #+12]
    419            } while (NumBytes);
   \       0x84   0x2C00             CMP      R4,#+0
   \       0x86   0xD1C4             BNE.N    ??_WriteBlocking_0
    420            return NumBytesWritten;
   \       0x88   0x4640             MOV      R0,R8
   \       0x8A   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    421          }
    422          
    423          /*********************************************************************
    424          *
    425          *       _WriteNoCheck()
    426          *
    427          *  Function description
    428          *    Stores a specified number of characters in SEGGER RTT ring buffer
    429          *    and updates the associated write pointer which is periodically
    430          *    read by the host.
    431          *    It is callers responsibility to make sure data actually fits in buffer.
    432          *
    433          *  Parameters
    434          *    pRing        Ring buffer to post to.
    435          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    436          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    437          *
    438          *  Notes
    439          *    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
    440          */

   \                                 In section .text, align 2, keep-with-next
    441          static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
   \                     _WriteNoCheck: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
    442            unsigned NumBytesAtOnce;
    443            unsigned WrOff;
    444            unsigned Rem;
    445            volatile char* pDst;
    446          
    447            WrOff = pRing->WrOff;
   \        0xC   0xF8D8 0x600C      LDR      R6,[R8, #+12]
    448            Rem = pRing->SizeOfBuffer - WrOff;
   \       0x10   0xF8D8 0x7008      LDR      R7,[R8, #+8]
   \       0x14   0x1BBF             SUBS     R7,R7,R6
    449            if (Rem > NumBytes) {
   \       0x16   0x42BD             CMP      R5,R7
   \       0x18   0xD20F             BCS.N    ??_WriteNoCheck_0
    450              //
    451              // All data fits before wrap around
    452              //
    453              pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \       0x1A   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x1E   0xEB00 0x0906      ADD      R9,R0,R6
    454          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    455              WrOff += NumBytes;
    456              while (NumBytes--) {
    457                *pDst++ = *pData++;
    458              };
    459              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    460              pRing->WrOff = WrOff;
    461          #else
    462              SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
   \       0x22   0x9501             STR      R5,[SP, #+4]
   \       0x24   0x46A3             MOV      R11,R4
   \       0x26   0x46CA             MOV      R10,R9
   \       0x28   0x9A01             LDR      R2,[SP, #+4]
   \       0x2A   0x4659             MOV      R1,R11
   \       0x2C   0x4650             MOV      R0,R10
   \       0x2E   0x.... 0x....      BL       __aeabi_memcpy
    463              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    464              pRing->WrOff = WrOff + NumBytes;
   \       0x32   0x19A8             ADDS     R0,R5,R6
   \       0x34   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \       0x38   0xE01F             B.N      ??_WriteNoCheck_1
    465          #endif
    466            } else {
    467              //
    468              // We reach the end of the buffer, so need to wrap around
    469              //
    470          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    471              pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    472              NumBytesAtOnce = Rem;
    473              while (NumBytesAtOnce--) {
    474                *pDst++ = *pData++;
    475              };
    476              pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
    477              NumBytesAtOnce = NumBytes - Rem;
    478              while (NumBytesAtOnce--) {
    479                *pDst++ = *pData++;
    480              };
    481              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    482              pRing->WrOff = NumBytes - Rem;
    483          #else
    484              NumBytesAtOnce = Rem;
   \                     ??_WriteNoCheck_0: (+1)
   \       0x3A   0x9700             STR      R7,[SP, #+0]
    485              pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \       0x3C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x40   0x4430             ADD      R0,R0,R6
   \       0x42   0x9001             STR      R0,[SP, #+4]
    486              SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
   \       0x44   0x9800             LDR      R0,[SP, #+0]
   \       0x46   0x9003             STR      R0,[SP, #+12]
   \       0x48   0x9402             STR      R4,[SP, #+8]
   \       0x4A   0xF8DD 0x9004      LDR      R9,[SP, #+4]
   \       0x4E   0x9A03             LDR      R2,[SP, #+12]
   \       0x50   0x9902             LDR      R1,[SP, #+8]
   \       0x52   0x4648             MOV      R0,R9
   \       0x54   0x.... 0x....      BL       __aeabi_memcpy
    487              NumBytesAtOnce = NumBytes - Rem;
   \       0x58   0x1BE8             SUBS     R0,R5,R7
   \       0x5A   0x9000             STR      R0,[SP, #+0]
    488              pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
   \       0x5C   0xF8D8 0x9004      LDR      R9,[R8, #+4]
    489              SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
   \       0x60   0x9800             LDR      R0,[SP, #+0]
   \       0x62   0x9001             STR      R0,[SP, #+4]
   \       0x64   0xEB04 0x0B07      ADD      R11,R4,R7
   \       0x68   0x46CA             MOV      R10,R9
   \       0x6A   0x9A01             LDR      R2,[SP, #+4]
   \       0x6C   0x4659             MOV      R1,R11
   \       0x6E   0x4650             MOV      R0,R10
   \       0x70   0x.... 0x....      BL       __aeabi_memcpy
    490              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    491              pRing->WrOff = NumBytesAtOnce;
   \       0x74   0x9800             LDR      R0,[SP, #+0]
   \       0x76   0xF8C8 0x000C      STR      R0,[R8, #+12]
    492          #endif
    493            }
    494          }
   \                     ??_WriteNoCheck_1: (+1)
   \       0x7A   0xB005             ADD      SP,SP,#+20
   \       0x7C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    495          
    496          /*********************************************************************
    497          *
    498          *       _PostTerminalSwitch()
    499          *
    500          *  Function description
    501          *    Switch terminal to the given terminal ID.  It is the caller's
    502          *    responsibility to ensure the terminal ID is correct and there is
    503          *    enough space in the buffer for this to complete successfully.
    504          *
    505          *  Parameters
    506          *    pRing        Ring buffer to post to.
    507          *    TerminalId   Terminal ID to switch to.
    508          */

   \                                 In section .text, align 2, keep-with-next
    509          static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
   \                     _PostTerminalSwitch: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    510            unsigned char ac[2];
    511          
    512            ac[0] = 0xFFu;
   \        0x6   0x20FF             MOVS     R0,#+255
   \        0x8   0xF88D 0x0000      STRB     R0,[SP, #+0]
    513            ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0x5C08             LDRB     R0,[R1, R0]
   \       0x16   0xF88D 0x0001      STRB     R0,[SP, #+1]
    514            _WriteBlocking(pRing, (const char*)ac, 2u);
   \       0x1A   0x2202             MOVS     R2,#+2
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       _WriteBlocking
    515          }
   \       0x24   0xBD31             POP      {R0,R4,R5,PC}
    516          
    517          /*********************************************************************
    518          *
    519          *       _GetAvailWriteSpace()
    520          *
    521          *  Function description
    522          *    Returns the number of bytes that can be written to the ring
    523          *    buffer without blocking.
    524          *
    525          *  Parameters
    526          *    pRing        Ring buffer to check.
    527          *
    528          *  Return value
    529          *    Number of bytes that are free in the buffer.
    530          */

   \                                 In section .text, align 2, keep-with-next
    531          static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
   \                     _GetAvailWriteSpace: (+1)
   \        0x0   0x0003             MOVS     R3,R0
    532            unsigned RdOff;
    533            unsigned WrOff;
    534            unsigned r;
    535            //
    536            // Avoid warnings regarding volatile access order.  It's not a problem
    537            // in this case, but dampen compiler enthusiasm.
    538            //
    539            RdOff = pRing->RdOff;
   \        0x2   0x6919             LDR      R1,[R3, #+16]
    540            WrOff = pRing->WrOff;
   \        0x4   0x68DA             LDR      R2,[R3, #+12]
    541            if (RdOff <= WrOff) {
   \        0x6   0x428A             CMP      R2,R1
   \        0x8   0xD304             BCC.N    ??_GetAvailWriteSpace_0
    542              r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
   \        0xA   0x6898             LDR      R0,[R3, #+8]
   \        0xC   0x1E40             SUBS     R0,R0,#+1
   \        0xE   0x1A80             SUBS     R0,R0,R2
   \       0x10   0x1808             ADDS     R0,R1,R0
   \       0x12   0xE001             B.N      ??_GetAvailWriteSpace_1
    543            } else {
    544              r = RdOff - WrOff - 1u;
   \                     ??_GetAvailWriteSpace_0: (+1)
   \       0x14   0x1A88             SUBS     R0,R1,R2
   \       0x16   0x1E40             SUBS     R0,R0,#+1
    545            }
    546            return r;
   \                     ??_GetAvailWriteSpace_1: (+1)
   \       0x18   0x4770             BX       LR
    547          }
    548          
    549          /*********************************************************************
    550          *
    551          *       Public code
    552          *
    553          **********************************************************************
    554          */
    555          
    556          /*********************************************************************
    557          *
    558          *       SEGGER_RTT_ReadUpBufferNoLock()
    559          *
    560          *  Function description
    561          *    Reads characters from SEGGER real-time-terminal control block
    562          *    which have been previously stored by the application.
    563          *    Do not lock against interrupts and multiple access.
    564          *    Used to do the same operation that J-Link does, to transfer
    565          *    RTT data via other channels, such as TCP/IP or UART.
    566          *
    567          *  Parameters
    568          *    BufferIndex  Index of Up-buffer to be used.
    569          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
    570          *    BufferSize   Size of the target application buffer.
    571          *
    572          *  Return value
    573          *    Number of bytes that have been read.
    574          *
    575          *  Additional information
    576          *    This function must not be called when J-Link might also do RTT.
    577          */

   \                                 In section .text, align 2, keep-with-next
    578          unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
   \                     SEGGER_RTT_ReadUpBufferNoLock: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x0016             MOVS     R6,R2
    579            unsigned                NumBytesRem;
    580            unsigned                NumBytesRead;
    581            unsigned                RdOff;
    582            unsigned                WrOff;
    583            unsigned char*          pBuffer;
    584            SEGGER_RTT_BUFFER_UP*   pRing;
    585            volatile char*          pSrc;
    586          
    587            INIT();
   \        0xA   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \        0xE   0x0027             MOVS     R7,R4
   \       0x10   0x7838             LDRB     R0,[R7, #+0]
   \       0x12   0x2853             CMP      R0,#+83
   \       0x14   0xD001             BEQ.N    ??SEGGER_RTT_ReadUpBufferNoLock_0
   \       0x16   0x.... 0x....      BL       _DoInit
    588            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \                     ??SEGGER_RTT_ReadUpBufferNoLock_0: (+1)
   \       0x1A   0x9904             LDR      R1,[SP, #+16]
   \       0x1C   0x2018             MOVS     R0,#+24
   \       0x1E   0x4341             MULS     R1,R0,R1
   \       0x20   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x24   0xF110 0x0718      ADDS     R7,R0,#+24
    589            pBuffer = (unsigned char*)pData;
   \       0x28   0x46D0             MOV      R8,R10
    590            RdOff = pRing->RdOff;
   \       0x2A   0xF8D7 0x9010      LDR      R9,[R7, #+16]
    591            WrOff = pRing->WrOff;
   \       0x2E   0x68F8             LDR      R0,[R7, #+12]
   \       0x30   0x9001             STR      R0,[SP, #+4]
    592            NumBytesRead = 0u;
   \       0x32   0x2400             MOVS     R4,#+0
    593            //
    594            // Read from current read position to wrap-around of buffer, first
    595            //
    596            if (RdOff > WrOff) {
   \       0x34   0x9801             LDR      R0,[SP, #+4]
   \       0x36   0x4548             CMP      R0,R9
   \       0x38   0xD21D             BCS.N    ??SEGGER_RTT_ReadUpBufferNoLock_1
    597              NumBytesRem = pRing->SizeOfBuffer - RdOff;
   \       0x3A   0x68B8             LDR      R0,[R7, #+8]
   \       0x3C   0xEBB0 0x0009      SUBS     R0,R0,R9
    598              NumBytesRem = MIN(NumBytesRem, BufferSize);
   \       0x40   0x42B0             CMP      R0,R6
   \       0x42   0xD201             BCS.N    ??SEGGER_RTT_ReadUpBufferNoLock_2
   \       0x44   0x0005             MOVS     R5,R0
   \       0x46   0xE000             B.N      ??SEGGER_RTT_ReadUpBufferNoLock_3
   \                     ??SEGGER_RTT_ReadUpBufferNoLock_2: (+1)
   \       0x48   0x0035             MOVS     R5,R6
    599              pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
   \                     ??SEGGER_RTT_ReadUpBufferNoLock_3: (+1)
   \       0x4A   0x6878             LDR      R0,[R7, #+4]
   \       0x4C   0x4448             ADD      R0,R0,R9
   \       0x4E   0x9000             STR      R0,[SP, #+0]
    600          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    601              NumBytesRead += NumBytesRem;
    602              BufferSize   -= NumBytesRem;
    603              RdOff        += NumBytesRem;
    604              while (NumBytesRem--) {
    605                *pBuffer++ = *pSrc++;
    606              };
    607          #else
    608              SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
   \       0x50   0x9503             STR      R5,[SP, #+12]
   \       0x52   0x9800             LDR      R0,[SP, #+0]
   \       0x54   0x9002             STR      R0,[SP, #+8]
   \       0x56   0x46C3             MOV      R11,R8
   \       0x58   0x9A03             LDR      R2,[SP, #+12]
   \       0x5A   0x9902             LDR      R1,[SP, #+8]
   \       0x5C   0x4658             MOV      R0,R11
   \       0x5E   0x.... 0x....      BL       __aeabi_memcpy
    609              NumBytesRead += NumBytesRem;
   \       0x62   0x192C             ADDS     R4,R5,R4
    610              pBuffer      += NumBytesRem;
   \       0x64   0x44A8             ADD      R8,R8,R5
    611              BufferSize   -= NumBytesRem;
   \       0x66   0x1B76             SUBS     R6,R6,R5
    612              RdOff        += NumBytesRem;
   \       0x68   0xEB15 0x0909      ADDS     R9,R5,R9
    613          #endif
    614              //
    615              // Handle wrap-around of buffer
    616              //
    617              if (RdOff == pRing->SizeOfBuffer) {
   \       0x6C   0x68B8             LDR      R0,[R7, #+8]
   \       0x6E   0x4581             CMP      R9,R0
   \       0x70   0xD101             BNE.N    ??SEGGER_RTT_ReadUpBufferNoLock_1
    618                RdOff = 0u;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x4681             MOV      R9,R0
    619              }
    620            }
    621            //
    622            // Read remaining items of buffer
    623            //
    624            NumBytesRem = WrOff - RdOff;
   \                     ??SEGGER_RTT_ReadUpBufferNoLock_1: (+1)
   \       0x76   0x9801             LDR      R0,[SP, #+4]
   \       0x78   0xEBB0 0x0009      SUBS     R0,R0,R9
    625            NumBytesRem = MIN(NumBytesRem, BufferSize);
   \       0x7C   0x42B0             CMP      R0,R6
   \       0x7E   0xD201             BCS.N    ??SEGGER_RTT_ReadUpBufferNoLock_4
   \       0x80   0x0005             MOVS     R5,R0
   \       0x82   0xE000             B.N      ??SEGGER_RTT_ReadUpBufferNoLock_5
   \                     ??SEGGER_RTT_ReadUpBufferNoLock_4: (+1)
   \       0x84   0x0035             MOVS     R5,R6
    626            if (NumBytesRem > 0u) {
   \                     ??SEGGER_RTT_ReadUpBufferNoLock_5: (+1)
   \       0x86   0x2D00             CMP      R5,#+0
   \       0x88   0xD010             BEQ.N    ??SEGGER_RTT_ReadUpBufferNoLock_6
    627              pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
   \       0x8A   0x6878             LDR      R0,[R7, #+4]
   \       0x8C   0x4448             ADD      R0,R0,R9
   \       0x8E   0x9000             STR      R0,[SP, #+0]
    628          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    629              NumBytesRead += NumBytesRem;
    630              BufferSize   -= NumBytesRem;
    631              RdOff        += NumBytesRem;
    632              while (NumBytesRem--) {
    633                *pBuffer++ = *pSrc++;
    634              };
    635          #else
    636              SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
   \       0x90   0x9503             STR      R5,[SP, #+12]
   \       0x92   0x9800             LDR      R0,[SP, #+0]
   \       0x94   0x9002             STR      R0,[SP, #+8]
   \       0x96   0x46C3             MOV      R11,R8
   \       0x98   0x9A03             LDR      R2,[SP, #+12]
   \       0x9A   0x9902             LDR      R1,[SP, #+8]
   \       0x9C   0x4658             MOV      R0,R11
   \       0x9E   0x.... 0x....      BL       __aeabi_memcpy
    637              NumBytesRead += NumBytesRem;
   \       0xA2   0x192C             ADDS     R4,R5,R4
    638              pBuffer      += NumBytesRem;
   \       0xA4   0x44A8             ADD      R8,R8,R5
    639              BufferSize   -= NumBytesRem;
   \       0xA6   0x1B76             SUBS     R6,R6,R5
    640              RdOff        += NumBytesRem;
   \       0xA8   0xEB15 0x0909      ADDS     R9,R5,R9
    641          #endif
    642            }
    643            //
    644            // Update read offset of buffer
    645            //
    646            if (NumBytesRead) {
   \                     ??SEGGER_RTT_ReadUpBufferNoLock_6: (+1)
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD001             BEQ.N    ??SEGGER_RTT_ReadUpBufferNoLock_7
    647              pRing->RdOff = RdOff;
   \       0xB0   0xF8C7 0x9010      STR      R9,[R7, #+16]
    648            }
    649            //
    650            return NumBytesRead;
   \                     ??SEGGER_RTT_ReadUpBufferNoLock_7: (+1)
   \       0xB4   0x0020             MOVS     R0,R4
   \       0xB6   0xB005             ADD      SP,SP,#+20
   \       0xB8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    651          }
    652          
    653          /*********************************************************************
    654          *
    655          *       SEGGER_RTT_ReadNoLock()
    656          *
    657          *  Function description
    658          *    Reads characters from SEGGER real-time-terminal control block
    659          *    which have been previously stored by the host.
    660          *    Do not lock against interrupts and multiple access.
    661          *
    662          *  Parameters
    663          *    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
    664          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
    665          *    BufferSize   Size of the target application buffer.
    666          *
    667          *  Return value
    668          *    Number of bytes that have been read.
    669          */

   \                                 In section .text, align 2, keep-with-next
    670          unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
   \                     SEGGER_RTT_ReadNoLock: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x0016             MOVS     R6,R2
    671            unsigned                NumBytesRem;
    672            unsigned                NumBytesRead;
    673            unsigned                RdOff;
    674            unsigned                WrOff;
    675            unsigned char*          pBuffer;
    676            SEGGER_RTT_BUFFER_DOWN* pRing;
    677            volatile char*          pSrc;
    678            //
    679            INIT();
   \        0xA   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \        0xE   0x0027             MOVS     R7,R4
   \       0x10   0x7838             LDRB     R0,[R7, #+0]
   \       0x12   0x2853             CMP      R0,#+83
   \       0x14   0xD001             BEQ.N    ??SEGGER_RTT_ReadNoLock_0
   \       0x16   0x.... 0x....      BL       _DoInit
    680            pRing = (SEGGER_RTT_BUFFER_DOWN*)((uintptr_t)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \                     ??SEGGER_RTT_ReadNoLock_0: (+1)
   \       0x1A   0x9904             LDR      R1,[SP, #+16]
   \       0x1C   0x2018             MOVS     R0,#+24
   \       0x1E   0x4341             MULS     R1,R0,R1
   \       0x20   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x24   0xF110 0x0760      ADDS     R7,R0,#+96
    681            pBuffer = (unsigned char*)pData;
   \       0x28   0x46D0             MOV      R8,R10
    682            RdOff = pRing->RdOff;
   \       0x2A   0xF8D7 0x9010      LDR      R9,[R7, #+16]
    683            WrOff = pRing->WrOff;
   \       0x2E   0x68F8             LDR      R0,[R7, #+12]
   \       0x30   0x9001             STR      R0,[SP, #+4]
    684            NumBytesRead = 0u;
   \       0x32   0x2400             MOVS     R4,#+0
    685            //
    686            // Read from current read position to wrap-around of buffer, first
    687            //
    688            if (RdOff > WrOff) {
   \       0x34   0x9801             LDR      R0,[SP, #+4]
   \       0x36   0x4548             CMP      R0,R9
   \       0x38   0xD21D             BCS.N    ??SEGGER_RTT_ReadNoLock_1
    689              NumBytesRem = pRing->SizeOfBuffer - RdOff;
   \       0x3A   0x68B8             LDR      R0,[R7, #+8]
   \       0x3C   0xEBB0 0x0009      SUBS     R0,R0,R9
    690              NumBytesRem = MIN(NumBytesRem, BufferSize);
   \       0x40   0x42B0             CMP      R0,R6
   \       0x42   0xD201             BCS.N    ??SEGGER_RTT_ReadNoLock_2
   \       0x44   0x0005             MOVS     R5,R0
   \       0x46   0xE000             B.N      ??SEGGER_RTT_ReadNoLock_3
   \                     ??SEGGER_RTT_ReadNoLock_2: (+1)
   \       0x48   0x0035             MOVS     R5,R6
    691              pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
   \                     ??SEGGER_RTT_ReadNoLock_3: (+1)
   \       0x4A   0x6878             LDR      R0,[R7, #+4]
   \       0x4C   0x4448             ADD      R0,R0,R9
   \       0x4E   0x9000             STR      R0,[SP, #+0]
    692          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    693              NumBytesRead += NumBytesRem;
    694              BufferSize   -= NumBytesRem;
    695              RdOff        += NumBytesRem;
    696              while (NumBytesRem--) {
    697                *pBuffer++ = *pSrc++;
    698              };
    699          #else
    700              SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
   \       0x50   0x9503             STR      R5,[SP, #+12]
   \       0x52   0x9800             LDR      R0,[SP, #+0]
   \       0x54   0x9002             STR      R0,[SP, #+8]
   \       0x56   0x46C3             MOV      R11,R8
   \       0x58   0x9A03             LDR      R2,[SP, #+12]
   \       0x5A   0x9902             LDR      R1,[SP, #+8]
   \       0x5C   0x4658             MOV      R0,R11
   \       0x5E   0x.... 0x....      BL       __aeabi_memcpy
    701              NumBytesRead += NumBytesRem;
   \       0x62   0x192C             ADDS     R4,R5,R4
    702              pBuffer      += NumBytesRem;
   \       0x64   0x44A8             ADD      R8,R8,R5
    703              BufferSize   -= NumBytesRem;
   \       0x66   0x1B76             SUBS     R6,R6,R5
    704              RdOff        += NumBytesRem;
   \       0x68   0xEB15 0x0909      ADDS     R9,R5,R9
    705          #endif
    706              //
    707              // Handle wrap-around of buffer
    708              //
    709              if (RdOff == pRing->SizeOfBuffer) {
   \       0x6C   0x68B8             LDR      R0,[R7, #+8]
   \       0x6E   0x4581             CMP      R9,R0
   \       0x70   0xD101             BNE.N    ??SEGGER_RTT_ReadNoLock_1
    710                RdOff = 0u;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x4681             MOV      R9,R0
    711              }
    712            }
    713            //
    714            // Read remaining items of buffer
    715            //
    716            NumBytesRem = WrOff - RdOff;
   \                     ??SEGGER_RTT_ReadNoLock_1: (+1)
   \       0x76   0x9801             LDR      R0,[SP, #+4]
   \       0x78   0xEBB0 0x0009      SUBS     R0,R0,R9
    717            NumBytesRem = MIN(NumBytesRem, BufferSize);
   \       0x7C   0x42B0             CMP      R0,R6
   \       0x7E   0xD201             BCS.N    ??SEGGER_RTT_ReadNoLock_4
   \       0x80   0x0005             MOVS     R5,R0
   \       0x82   0xE000             B.N      ??SEGGER_RTT_ReadNoLock_5
   \                     ??SEGGER_RTT_ReadNoLock_4: (+1)
   \       0x84   0x0035             MOVS     R5,R6
    718            if (NumBytesRem > 0u) {
   \                     ??SEGGER_RTT_ReadNoLock_5: (+1)
   \       0x86   0x2D00             CMP      R5,#+0
   \       0x88   0xD010             BEQ.N    ??SEGGER_RTT_ReadNoLock_6
    719              pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
   \       0x8A   0x6878             LDR      R0,[R7, #+4]
   \       0x8C   0x4448             ADD      R0,R0,R9
   \       0x8E   0x9000             STR      R0,[SP, #+0]
    720          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    721              NumBytesRead += NumBytesRem;
    722              BufferSize   -= NumBytesRem;
    723              RdOff        += NumBytesRem;
    724              while (NumBytesRem--) {
    725                *pBuffer++ = *pSrc++;
    726              };
    727          #else
    728              SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
   \       0x90   0x9503             STR      R5,[SP, #+12]
   \       0x92   0x9800             LDR      R0,[SP, #+0]
   \       0x94   0x9002             STR      R0,[SP, #+8]
   \       0x96   0x46C3             MOV      R11,R8
   \       0x98   0x9A03             LDR      R2,[SP, #+12]
   \       0x9A   0x9902             LDR      R1,[SP, #+8]
   \       0x9C   0x4658             MOV      R0,R11
   \       0x9E   0x.... 0x....      BL       __aeabi_memcpy
    729              NumBytesRead += NumBytesRem;
   \       0xA2   0x192C             ADDS     R4,R5,R4
    730              pBuffer      += NumBytesRem;
   \       0xA4   0x44A8             ADD      R8,R8,R5
    731              BufferSize   -= NumBytesRem;
   \       0xA6   0x1B76             SUBS     R6,R6,R5
    732              RdOff        += NumBytesRem;
   \       0xA8   0xEB15 0x0909      ADDS     R9,R5,R9
    733          #endif
    734            }
    735            if (NumBytesRead) {
   \                     ??SEGGER_RTT_ReadNoLock_6: (+1)
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD001             BEQ.N    ??SEGGER_RTT_ReadNoLock_7
    736              pRing->RdOff = RdOff;
   \       0xB0   0xF8C7 0x9010      STR      R9,[R7, #+16]
    737            }
    738            //
    739            return NumBytesRead;
   \                     ??SEGGER_RTT_ReadNoLock_7: (+1)
   \       0xB4   0x0020             MOVS     R0,R4
   \       0xB6   0xB005             ADD      SP,SP,#+20
   \       0xB8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    740          }
    741          
    742          /*********************************************************************
    743          *
    744          *       SEGGER_RTT_ReadUpBuffer
    745          *
    746          *  Function description
    747          *    Reads characters from SEGGER real-time-terminal control block
    748          *    which have been previously stored by the application.
    749          *    Used to do the same operation that J-Link does, to transfer
    750          *    RTT data via other channels, such as TCP/IP or UART.
    751          *
    752          *  Parameters
    753          *    BufferIndex  Index of Up-buffer to be used.
    754          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
    755          *    BufferSize   Size of the target application buffer.
    756          *
    757          *  Return value
    758          *    Number of bytes that have been read.
    759          *
    760          *  Additional information
    761          *    This function must not be called when J-Link might also do RTT.
    762          *    This function locks against all other RTT operations. I.e. during
    763          *    the read operation, writing is also locked.
    764          *    If only one consumer reads from the up buffer,
    765          *    call sEGGER_RTT_ReadUpBufferNoLock() instead.
    766          */

   \                                 In section .text, align 2, keep-with-next
    767          unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
   \                     SEGGER_RTT_ReadUpBuffer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    768            unsigned NumBytesRead;
    769          
    770            SEGGER_RTT_LOCK();
   \        0x8   0xF3EF 0x8711      MRS      R7,BASEPRI
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
    771            //
    772            // Call the non-locking read function
    773            //
    774            NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
   \       0x12   0x0032             MOVS     R2,R6
   \       0x14   0x0029             MOVS     R1,R5
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       SEGGER_RTT_ReadUpBufferNoLock
    775            //
    776            // Finish up.
    777            //
    778            SEGGER_RTT_UNLOCK();
   \       0x1C   0xF387 0x8811      MSR      BASEPRI,R7
    779            //
    780            return NumBytesRead;
   \       0x20   0xBDF2             POP      {R1,R4-R7,PC}
    781          }
    782          
    783          /*********************************************************************
    784          *
    785          *       SEGGER_RTT_Read
    786          *
    787          *  Function description
    788          *    Reads characters from SEGGER real-time-terminal control block
    789          *    which have been previously stored by the host.
    790          *
    791          *  Parameters
    792          *    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
    793          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
    794          *    BufferSize   Size of the target application buffer.
    795          *
    796          *  Return value
    797          *    Number of bytes that have been read.
    798          */

   \                                 In section .text, align 2, keep-with-next
    799          unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
   \                     SEGGER_RTT_Read: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    800            unsigned NumBytesRead;
    801          
    802            SEGGER_RTT_LOCK();
   \        0x8   0xF3EF 0x8711      MRS      R7,BASEPRI
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
    803            //
    804            // Call the non-locking read function
    805            //
    806            NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
   \       0x12   0x0032             MOVS     R2,R6
   \       0x14   0x0029             MOVS     R1,R5
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       SEGGER_RTT_ReadNoLock
    807            //
    808            // Finish up.
    809            //
    810            SEGGER_RTT_UNLOCK();
   \       0x1C   0xF387 0x8811      MSR      BASEPRI,R7
    811            //
    812            return NumBytesRead;
   \       0x20   0xBDF2             POP      {R1,R4-R7,PC}
    813          }
    814          
    815          /*********************************************************************
    816          *
    817          *       SEGGER_RTT_WriteWithOverwriteNoLock
    818          *
    819          *  Function description
    820          *    Stores a specified number of characters in SEGGER RTT
    821          *    control block.
    822          *    SEGGER_RTT_WriteWithOverwriteNoLock does not lock the application
    823          *    and overwrites data if the data does not fit into the buffer.
    824          *
    825          *  Parameters
    826          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    827          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    828          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    829          *
    830          *  Notes
    831          *    (1) If there is not enough space in the "Up"-buffer, data is overwritten.
    832          *    (2) For performance reasons this function does not call Init()
    833          *        and may only be called after RTT has been initialized.
    834          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
    835          *    (3) Do not use SEGGER_RTT_WriteWithOverwriteNoLock if a J-Link
    836          *        connection reads RTT data.
    837          */

   \                                 In section .text, align 2, keep-with-next
    838          void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteWithOverwriteNoLock: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
    839            const char*           pData;
    840            SEGGER_RTT_BUFFER_UP* pRing;
    841            unsigned              Avail;
    842            volatile char*        pDst;
    843            //
    844            // Get "to-host" ring buffer and copy some elements into local variables.
    845            //
    846            pData = (const char *)pBuffer;
   \        0xA   0x46B0             MOV      R8,R6
    847            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \       0x10   0x2018             MOVS     R0,#+24
   \       0x12   0xFB00 0xF005      MUL      R0,R0,R5
   \       0x16   0x4408             ADD      R0,R1,R0
   \       0x18   0xF110 0x0918      ADDS     R9,R0,#+24
    848            //
    849            // Check if we will overwrite data and need to adjust the RdOff.
    850            //
    851            if (pRing->WrOff == pRing->RdOff) {
   \       0x1C   0xF8D9 0x100C      LDR      R1,[R9, #+12]
   \       0x20   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x24   0x4281             CMP      R1,R0
   \       0x26   0xD103             BNE.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_0
    852              Avail = pRing->SizeOfBuffer - 1u;
   \       0x28   0xF8D9 0x1008      LDR      R1,[R9, #+8]
   \       0x2C   0x1E49             SUBS     R1,R1,#+1
   \       0x2E   0xE015             B.N      ??SEGGER_RTT_WriteWithOverwriteNoLock_1
    853            } else if ( pRing->WrOff < pRing->RdOff) {
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_0: (+1)
   \       0x30   0xF8D9 0x100C      LDR      R1,[R9, #+12]
   \       0x34   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x38   0x4281             CMP      R1,R0
   \       0x3A   0xD206             BCS.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_2
    854              Avail = pRing->RdOff - pRing->WrOff - 1u;
   \       0x3C   0xF8D9 0x1010      LDR      R1,[R9, #+16]
   \       0x40   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0x44   0x1A09             SUBS     R1,R1,R0
   \       0x46   0x1E49             SUBS     R1,R1,#+1
   \       0x48   0xE008             B.N      ??SEGGER_RTT_WriteWithOverwriteNoLock_1
    855            } else {
    856              Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_2: (+1)
   \       0x4A   0xF8D9 0x2010      LDR      R2,[R9, #+16]
   \       0x4E   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0x52   0x1A12             SUBS     R2,R2,R0
   \       0x54   0xF8D9 0x1008      LDR      R1,[R9, #+8]
   \       0x58   0x1889             ADDS     R1,R1,R2
   \       0x5A   0x1E49             SUBS     R1,R1,#+1
    857            }
    858            if (NumBytes > Avail) {
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_1: (+1)
   \       0x5C   0x42A1             CMP      R1,R4
   \       0x5E   0xD213             BCS.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_3
    859              pRing->RdOff += (NumBytes - Avail);
   \       0x60   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x64   0x1820             ADDS     R0,R4,R0
   \       0x66   0x1A40             SUBS     R0,R0,R1
   \       0x68   0xF8C9 0x0010      STR      R0,[R9, #+16]
    860              while (pRing->RdOff >= pRing->SizeOfBuffer) {
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_4: (+1)
   \       0x6C   0xF8D9 0x2010      LDR      R2,[R9, #+16]
   \       0x70   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x74   0x4282             CMP      R2,R0
   \       0x76   0xD307             BCC.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_3
    861                pRing->RdOff -= pRing->SizeOfBuffer;
   \       0x78   0xF8D9 0x2010      LDR      R2,[R9, #+16]
   \       0x7C   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x80   0x1A12             SUBS     R2,R2,R0
   \       0x82   0xF8C9 0x2010      STR      R2,[R9, #+16]
   \       0x86   0xE7F1             B.N      ??SEGGER_RTT_WriteWithOverwriteNoLock_4
    862              }
    863            }
    864            //
    865            // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
    866            //
    867            Avail = pRing->SizeOfBuffer - pRing->WrOff;
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_3: (+1)
   \       0x88   0xF8D9 0xA008      LDR      R10,[R9, #+8]
   \       0x8C   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0x90   0xEBBA 0x0A00      SUBS     R10,R10,R0
    868            do {
    869              if (Avail > NumBytes) {
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_5: (+1)
   \       0x94   0x4554             CMP      R4,R10
   \       0x96   0xD214             BCS.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_6
    870                //
    871                // Last round
    872                //
    873                pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \       0x98   0xF8D9 0x1004      LDR      R1,[R9, #+4]
   \       0x9C   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0xA0   0x4408             ADD      R0,R1,R0
   \       0xA2   0x0007             MOVS     R7,R0
    874          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    875                Avail = NumBytes;
    876                while (NumBytes--) {
    877                  *pDst++ = *pData++;
    878                };
    879                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    880                pRing->WrOff += Avail;
    881          #else
    882                SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
   \       0xA4   0x9401             STR      R4,[SP, #+4]
   \       0xA6   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0xAA   0x46BB             MOV      R11,R7
   \       0xAC   0x9A01             LDR      R2,[SP, #+4]
   \       0xAE   0x9900             LDR      R1,[SP, #+0]
   \       0xB0   0x4658             MOV      R0,R11
   \       0xB2   0x.... 0x....      BL       __aeabi_memcpy
    883                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    884                pRing->WrOff += NumBytes;
   \       0xB6   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0xBA   0x1820             ADDS     R0,R4,R0
   \       0xBC   0xF8C9 0x000C      STR      R0,[R9, #+12]
    885          #endif
    886                break;
   \       0xC0   0xE01B             B.N      ??SEGGER_RTT_WriteWithOverwriteNoLock_7
    887              } else {
    888                //
    889                //  Wrap-around necessary, write until wrap-around and reset WrOff
    890                //
    891                pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_6: (+1)
   \       0xC2   0xF8D9 0x1004      LDR      R1,[R9, #+4]
   \       0xC6   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0xCA   0x4408             ADD      R0,R1,R0
   \       0xCC   0x0007             MOVS     R7,R0
    892          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    893                NumBytes -= Avail;
    894                while (Avail--) {
    895                  *pDst++ = *pData++;
    896                };
    897                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    898                pRing->WrOff = 0;
    899          #else
    900                SEGGER_RTT_MEMCPY((void*)pDst, pData, Avail);
   \       0xCE   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0xD2   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0xD6   0x46BB             MOV      R11,R7
   \       0xD8   0x9A01             LDR      R2,[SP, #+4]
   \       0xDA   0x9900             LDR      R1,[SP, #+0]
   \       0xDC   0x4658             MOV      R0,R11
   \       0xDE   0x.... 0x....      BL       __aeabi_memcpy
    901                pData += Avail;
   \       0xE2   0x44D0             ADD      R8,R8,R10
    902                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    903                pRing->WrOff = 0;
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0xF8C9 0x000C      STR      R0,[R9, #+12]
    904                NumBytes -= Avail;
   \       0xEA   0xEBB4 0x040A      SUBS     R4,R4,R10
    905          #endif
    906                Avail = (pRing->SizeOfBuffer - 1);
   \       0xEE   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0xF2   0x1E40             SUBS     R0,R0,#+1
   \       0xF4   0x4682             MOV      R10,R0
    907              }
    908            } while (NumBytes);
   \       0xF6   0x2C00             CMP      R4,#+0
   \       0xF8   0xD1CC             BNE.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_5
    909          }
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_7: (+1)
   \       0xFA   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    910          
    911          /*********************************************************************
    912          *
    913          *       SEGGER_RTT_WriteSkipNoLock
    914          *
    915          *  Function description
    916          *    Stores a specified number of characters in SEGGER RTT
    917          *    control block which is then read by the host.
    918          *    SEGGER_RTT_WriteSkipNoLock does not lock the application and
    919          *    skips all data, if the data does not fit into the buffer.
    920          *
    921          *  Parameters
    922          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    923          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    924          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    925          *                 MUST be > 0!!!
    926          *                 This is done for performance reasons, so no initial check has do be done.
    927          *
    928          *  Return value
    929          *    1: Data has been copied
    930          *    0: No space, data has not been copied
    931          *
    932          *  Notes
    933          *    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
    934          *    (2) For performance reasons this function does not call Init()
    935          *        and may only be called after RTT has been initialized.
    936          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
    937          */
    938          #if (RTT_USE_ASM == 0)

   \                                 In section .text, align 2, keep-with-next
    939          unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteSkipNoLock: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0014             MOVS     R4,R2
    940            const char*           pData;
    941            SEGGER_RTT_BUFFER_UP* pRing;
    942            unsigned              Avail;
    943            unsigned              RdOff;
    944            unsigned              WrOff;
    945            unsigned              Rem;
    946            volatile char*        pDst;
    947            //
    948            // Cases:
    949            //   1) RdOff <= WrOff => Space until wrap-around is sufficient
    950            //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
    951            //   3) RdOff <  WrOff => No space in buf
    952            //   4) RdOff >  WrOff => Space is sufficient
    953            //   5) RdOff >  WrOff => No space in buf
    954            //
    955            // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
    956            //
    957            pData = (const char *)pBuffer;
   \        0xC   0x9501             STR      R5,[SP, #+4]
    958            pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \       0x12   0x2018             MOVS     R0,#+24
   \       0x14   0xFB00 0xF00A      MUL      R0,R0,R10
   \       0x18   0x4408             ADD      R0,R1,R0
   \       0x1A   0xF110 0x0618      ADDS     R6,R0,#+24
    959            RdOff = pRing->RdOff;
   \       0x1E   0x6930             LDR      R0,[R6, #+16]
   \       0x20   0x9002             STR      R0,[SP, #+8]
    960            WrOff = pRing->WrOff;
   \       0x22   0x68F7             LDR      R7,[R6, #+12]
    961            pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \       0x24   0x6870             LDR      R0,[R6, #+4]
   \       0x26   0x4438             ADD      R0,R0,R7
   \       0x28   0x9000             STR      R0,[SP, #+0]
    962            if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   \       0x2A   0x9802             LDR      R0,[SP, #+8]
   \       0x2C   0x4287             CMP      R7,R0
   \       0x2E   0xD33D             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_0
    963              Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   \       0x30   0xF8D6 0x8008      LDR      R8,[R6, #+8]
   \       0x34   0xEBB8 0x0807      SUBS     R8,R8,R7
   \       0x38   0xF1B8 0x0801      SUBS     R8,R8,#+1
    964              if (Avail >= NumBytes) {                            // Case 1)?
   \       0x3C   0x45A0             CMP      R8,R4
   \       0x3E   0xD30D             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_1
    965                memcpy((void*)pDst, pData, NumBytes);
   \       0x40   0x9404             STR      R4,[SP, #+16]
   \       0x42   0x9801             LDR      R0,[SP, #+4]
   \       0x44   0x9003             STR      R0,[SP, #+12]
   \       0x46   0xF8DD 0x9000      LDR      R9,[SP, #+0]
   \       0x4A   0x9A04             LDR      R2,[SP, #+16]
   \       0x4C   0x9903             LDR      R1,[SP, #+12]
   \       0x4E   0x4648             MOV      R0,R9
   \       0x50   0x.... 0x....      BL       __aeabi_memcpy
    966                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    967                pRing->WrOff = WrOff + NumBytes;
   \       0x54   0x19E0             ADDS     R0,R4,R7
   \       0x56   0x60F0             STR      R0,[R6, #+12]
    968                return 1;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xE03E             B.N      ??SEGGER_RTT_WriteSkipNoLock_2
    969              }
    970              Avail += RdOff;                                     // Space incl. wrap-around
   \                     ??SEGGER_RTT_WriteSkipNoLock_1: (+1)
   \       0x5C   0x9802             LDR      R0,[SP, #+8]
   \       0x5E   0xEB10 0x0808      ADDS     R8,R0,R8
    971              if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   \       0x62   0x45A0             CMP      R8,R4
   \       0x64   0xD338             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_3
    972                Rem = pRing->SizeOfBuffer - WrOff;                // Space until end of buffer
   \       0x66   0xF8D6 0x9008      LDR      R9,[R6, #+8]
   \       0x6A   0xEBB9 0x0907      SUBS     R9,R9,R7
    973                memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
   \       0x6E   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \       0x72   0x9801             LDR      R0,[SP, #+4]
   \       0x74   0x9003             STR      R0,[SP, #+12]
   \       0x76   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \       0x7A   0x9A04             LDR      R2,[SP, #+16]
   \       0x7C   0x9903             LDR      R1,[SP, #+12]
   \       0x7E   0x4658             MOV      R0,R11
   \       0x80   0x.... 0x....      BL       __aeabi_memcpy
    974                NumBytes -= Rem;
   \       0x84   0xEBB4 0x0409      SUBS     R4,R4,R9
    975                //
    976                // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
    977                // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
    978                // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
    979                // Therefore, check if 2nd memcpy is necessary at all
    980                //
    981                if (NumBytes) {
   \       0x88   0x2C00             CMP      R4,#+0
   \       0x8A   0xD00C             BEQ.N    ??SEGGER_RTT_WriteSkipNoLock_4
    982                  pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
   \       0x8C   0x6870             LDR      R0,[R6, #+4]
   \       0x8E   0x9000             STR      R0,[SP, #+0]
    983                  memcpy((void*)pDst, pData + Rem, NumBytes);
   \       0x90   0x9404             STR      R4,[SP, #+16]
   \       0x92   0x9801             LDR      R0,[SP, #+4]
   \       0x94   0x4448             ADD      R0,R0,R9
   \       0x96   0x9003             STR      R0,[SP, #+12]
   \       0x98   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \       0x9C   0x9A04             LDR      R2,[SP, #+16]
   \       0x9E   0x9903             LDR      R1,[SP, #+12]
   \       0xA0   0x4658             MOV      R0,R11
   \       0xA2   0x.... 0x....      BL       __aeabi_memcpy
    984                }
    985                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    986                pRing->WrOff = NumBytes;
   \                     ??SEGGER_RTT_WriteSkipNoLock_4: (+1)
   \       0xA6   0x60F4             STR      R4,[R6, #+12]
    987                return 1;
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0xE016             B.N      ??SEGGER_RTT_WriteSkipNoLock_2
    988              }
    989            } else {                                             // Potential case 4)
    990              Avail = RdOff - WrOff - 1u;
   \                     ??SEGGER_RTT_WriteSkipNoLock_0: (+1)
   \       0xAC   0xF8DD 0x8008      LDR      R8,[SP, #+8]
   \       0xB0   0xEBB8 0x0807      SUBS     R8,R8,R7
   \       0xB4   0xF1B8 0x0801      SUBS     R8,R8,#+1
    991              if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   \       0xB8   0x45A0             CMP      R8,R4
   \       0xBA   0xD30D             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_3
    992                memcpy((void*)pDst, pData, NumBytes);
   \       0xBC   0x9404             STR      R4,[SP, #+16]
   \       0xBE   0x9801             LDR      R0,[SP, #+4]
   \       0xC0   0x9003             STR      R0,[SP, #+12]
   \       0xC2   0xF8DD 0x9000      LDR      R9,[SP, #+0]
   \       0xC6   0x9A04             LDR      R2,[SP, #+16]
   \       0xC8   0x9903             LDR      R1,[SP, #+12]
   \       0xCA   0x4648             MOV      R0,R9
   \       0xCC   0x.... 0x....      BL       __aeabi_memcpy
    993                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    994                pRing->WrOff = WrOff + NumBytes;
   \       0xD0   0x19E0             ADDS     R0,R4,R7
   \       0xD2   0x60F0             STR      R0,[R6, #+12]
    995                return 1;
   \       0xD4   0x2001             MOVS     R0,#+1
   \       0xD6   0xE000             B.N      ??SEGGER_RTT_WriteSkipNoLock_2
    996              }
    997            }
    998            return 0;     // No space in buffer
   \                     ??SEGGER_RTT_WriteSkipNoLock_3: (+1)
   \       0xD8   0x2000             MOVS     R0,#+0
   \                     ??SEGGER_RTT_WriteSkipNoLock_2: (+1)
   \       0xDA   0xB005             ADD      SP,SP,#+20
   \       0xDC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    999          }
   1000          #endif
   1001          
   1002          /*********************************************************************
   1003          *
   1004          *       SEGGER_RTT_WriteDownBufferNoLock
   1005          *
   1006          *  Function description
   1007          *    Stores a specified number of characters in SEGGER RTT
   1008          *    control block inside a <Down> buffer.
   1009          *    SEGGER_RTT_WriteDownBufferNoLock does not lock the application.
   1010          *    Used to do the same operation that J-Link does, to transfer
   1011          *    RTT data from other channels, such as TCP/IP or UART.
   1012          *
   1013          *  Parameters
   1014          *    BufferIndex  Index of "Down"-buffer to be used.
   1015          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
   1016          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
   1017          *
   1018          *  Return value
   1019          *    Number of bytes which have been stored in the "Down"-buffer.
   1020          *
   1021          *  Notes
   1022          *    (1) Data is stored according to buffer flags.
   1023          *    (2) For performance reasons this function does not call Init()
   1024          *        and may only be called after RTT has been initialized.
   1025          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
   1026          *
   1027          *  Additional information
   1028          *    This function must not be called when J-Link might also do RTT.
   1029          */

   \                                 In section .text, align 2, keep-with-next
   1030          unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteDownBufferNoLock: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1031            unsigned                Status;
   1032            unsigned                Avail;
   1033            const char*             pData;
   1034            SEGGER_RTT_BUFFER_UP*   pRing;
   1035            //
   1036            // Get "to-target" ring buffer.
   1037            // It is save to cast that to a "to-host" buffer. Up and Down buffer differ in volatility of offsets that might be modified by J-Link.
   1038            //
   1039            pData = (const char *)pBuffer;
   \        0xA   0x46A8             MOV      R8,R5
   1040            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \       0x10   0x2018             MOVS     R0,#+24
   \       0x12   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x16   0x4408             ADD      R0,R1,R0
   \       0x18   0xF110 0x0960      ADDS     R9,R0,#+96
   1041            //
   1042            // How we output depends upon the mode...
   1043            //
   1044            switch (pRing->Flags) {
   \       0x1C   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD003             BEQ.N    ??SEGGER_RTT_WriteDownBufferNoLock_0
   \       0x24   0x2802             CMP      R0,#+2
   \       0x26   0xD020             BEQ.N    ??SEGGER_RTT_WriteDownBufferNoLock_1
   \       0x28   0xD310             BCC.N    ??SEGGER_RTT_WriteDownBufferNoLock_2
   \       0x2A   0xE025             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_3
   1045            case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
   1046              //
   1047              // If we are in skip mode and there is no space for the whole
   1048              // of this output, don't bother.
   1049              //
   1050              Avail = _GetAvailWriteSpace(pRing);
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_0: (+1)
   \       0x2C   0x4648             MOV      R0,R9
   \       0x2E   0x.... 0x....      BL       _GetAvailWriteSpace
   \       0x32   0x0007             MOVS     R7,R0
   1051              if (Avail < NumBytes) {
   \       0x34   0x42B7             CMP      R7,R6
   \       0x36   0xD202             BCS.N    ??SEGGER_RTT_WriteDownBufferNoLock_4
   1052                Status = 0u;
   \       0x38   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x3C   0xE005             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_5
   1053              } else {
   1054                Status = NumBytes;
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_4: (+1)
   \       0x3E   0x46B2             MOV      R10,R6
   1055                _WriteNoCheck(pRing, pData, NumBytes);
   \       0x40   0x0032             MOVS     R2,R6
   \       0x42   0x4641             MOV      R1,R8
   \       0x44   0x4648             MOV      R0,R9
   \       0x46   0x.... 0x....      BL       _WriteNoCheck
   1056              }
   1057              break;
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_5: (+1)
   \       0x4A   0xE017             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_6
   1058            case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
   1059              //
   1060              // If we are in trim mode, trim to what we can output without blocking.
   1061              //
   1062              Avail = _GetAvailWriteSpace(pRing);
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_2: (+1)
   \       0x4C   0x4648             MOV      R0,R9
   \       0x4E   0x.... 0x....      BL       _GetAvailWriteSpace
   \       0x52   0x0007             MOVS     R7,R0
   1063              Status = Avail < NumBytes ? Avail : NumBytes;
   \       0x54   0x42B7             CMP      R7,R6
   \       0x56   0xD201             BCS.N    ??SEGGER_RTT_WriteDownBufferNoLock_7
   \       0x58   0x46BA             MOV      R10,R7
   \       0x5A   0xE000             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_8
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_7: (+1)
   \       0x5C   0x46B2             MOV      R10,R6
   1064              _WriteNoCheck(pRing, pData, Status);
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_8: (+1)
   \       0x5E   0x4652             MOV      R2,R10
   \       0x60   0x4641             MOV      R1,R8
   \       0x62   0x4648             MOV      R0,R9
   \       0x64   0x.... 0x....      BL       _WriteNoCheck
   1065              break;
   \       0x68   0xE008             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_6
   1066            case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
   1067              //
   1068              // If we are in blocking mode, output everything.
   1069              //
   1070              Status = _WriteBlocking(pRing, pData, NumBytes);
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_1: (+1)
   \       0x6A   0x0032             MOVS     R2,R6
   \       0x6C   0x4641             MOV      R1,R8
   \       0x6E   0x4648             MOV      R0,R9
   \       0x70   0x.... 0x....      BL       _WriteBlocking
   \       0x74   0x4682             MOV      R10,R0
   1071              break;
   \       0x76   0xE001             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_6
   1072            default:
   1073              Status = 0u;
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_3: (+1)
   \       0x78   0xF05F 0x0A00      MOVS     R10,#+0
   1074              break;
   1075            }
   1076            //
   1077            // Finish up.
   1078            //
   1079            return Status;
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_6: (+1)
   \       0x7C   0x4650             MOV      R0,R10
   \       0x7E   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1080          }
   1081          
   1082          /*********************************************************************
   1083          *
   1084          *       SEGGER_RTT_WriteNoLock
   1085          *
   1086          *  Function description
   1087          *    Stores a specified number of characters in SEGGER RTT
   1088          *    control block which is then read by the host.
   1089          *    SEGGER_RTT_WriteNoLock does not lock the application.
   1090          *
   1091          *  Parameters
   1092          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1093          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
   1094          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
   1095          *
   1096          *  Return value
   1097          *    Number of bytes which have been stored in the "Up"-buffer.
   1098          *
   1099          *  Notes
   1100          *    (1) Data is stored according to buffer flags.
   1101          *    (2) For performance reasons this function does not call Init()
   1102          *        and may only be called after RTT has been initialized.
   1103          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
   1104          */

   \                                 In section .text, align 2, keep-with-next
   1105          unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteNoLock: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1106            unsigned              Status;
   1107            unsigned              Avail;
   1108            const char*           pData;
   1109            SEGGER_RTT_BUFFER_UP* pRing;
   1110            //
   1111            // Get "to-host" ring buffer.
   1112            //
   1113            pData = (const char *)pBuffer;
   \        0xA   0x46A8             MOV      R8,R5
   1114            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \       0x10   0x2018             MOVS     R0,#+24
   \       0x12   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x16   0x4408             ADD      R0,R1,R0
   \       0x18   0xF110 0x0918      ADDS     R9,R0,#+24
   1115            //
   1116            // How we output depends upon the mode...
   1117            //
   1118            switch (pRing->Flags) {
   \       0x1C   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD003             BEQ.N    ??SEGGER_RTT_WriteNoLock_0
   \       0x24   0x2802             CMP      R0,#+2
   \       0x26   0xD020             BEQ.N    ??SEGGER_RTT_WriteNoLock_1
   \       0x28   0xD310             BCC.N    ??SEGGER_RTT_WriteNoLock_2
   \       0x2A   0xE025             B.N      ??SEGGER_RTT_WriteNoLock_3
   1119            case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
   1120              //
   1121              // If we are in skip mode and there is no space for the whole
   1122              // of this output, don't bother.
   1123              //
   1124              Avail = _GetAvailWriteSpace(pRing);
   \                     ??SEGGER_RTT_WriteNoLock_0: (+1)
   \       0x2C   0x4648             MOV      R0,R9
   \       0x2E   0x.... 0x....      BL       _GetAvailWriteSpace
   \       0x32   0x0007             MOVS     R7,R0
   1125              if (Avail < NumBytes) {
   \       0x34   0x42B7             CMP      R7,R6
   \       0x36   0xD202             BCS.N    ??SEGGER_RTT_WriteNoLock_4
   1126                Status = 0u;
   \       0x38   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x3C   0xE005             B.N      ??SEGGER_RTT_WriteNoLock_5
   1127              } else {
   1128                Status = NumBytes;
   \                     ??SEGGER_RTT_WriteNoLock_4: (+1)
   \       0x3E   0x46B2             MOV      R10,R6
   1129                _WriteNoCheck(pRing, pData, NumBytes);
   \       0x40   0x0032             MOVS     R2,R6
   \       0x42   0x4641             MOV      R1,R8
   \       0x44   0x4648             MOV      R0,R9
   \       0x46   0x.... 0x....      BL       _WriteNoCheck
   1130              }
   1131              break;
   \                     ??SEGGER_RTT_WriteNoLock_5: (+1)
   \       0x4A   0xE017             B.N      ??SEGGER_RTT_WriteNoLock_6
   1132            case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
   1133              //
   1134              // If we are in trim mode, trim to what we can output without blocking.
   1135              //
   1136              Avail = _GetAvailWriteSpace(pRing);
   \                     ??SEGGER_RTT_WriteNoLock_2: (+1)
   \       0x4C   0x4648             MOV      R0,R9
   \       0x4E   0x.... 0x....      BL       _GetAvailWriteSpace
   \       0x52   0x0007             MOVS     R7,R0
   1137              Status = Avail < NumBytes ? Avail : NumBytes;
   \       0x54   0x42B7             CMP      R7,R6
   \       0x56   0xD201             BCS.N    ??SEGGER_RTT_WriteNoLock_7
   \       0x58   0x46BA             MOV      R10,R7
   \       0x5A   0xE000             B.N      ??SEGGER_RTT_WriteNoLock_8
   \                     ??SEGGER_RTT_WriteNoLock_7: (+1)
   \       0x5C   0x46B2             MOV      R10,R6
   1138              _WriteNoCheck(pRing, pData, Status);
   \                     ??SEGGER_RTT_WriteNoLock_8: (+1)
   \       0x5E   0x4652             MOV      R2,R10
   \       0x60   0x4641             MOV      R1,R8
   \       0x62   0x4648             MOV      R0,R9
   \       0x64   0x.... 0x....      BL       _WriteNoCheck
   1139              break;
   \       0x68   0xE008             B.N      ??SEGGER_RTT_WriteNoLock_6
   1140            case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
   1141              //
   1142              // If we are in blocking mode, output everything.
   1143              //
   1144              Status = _WriteBlocking(pRing, pData, NumBytes);
   \                     ??SEGGER_RTT_WriteNoLock_1: (+1)
   \       0x6A   0x0032             MOVS     R2,R6
   \       0x6C   0x4641             MOV      R1,R8
   \       0x6E   0x4648             MOV      R0,R9
   \       0x70   0x.... 0x....      BL       _WriteBlocking
   \       0x74   0x4682             MOV      R10,R0
   1145              break;
   \       0x76   0xE001             B.N      ??SEGGER_RTT_WriteNoLock_6
   1146            default:
   1147              Status = 0u;
   \                     ??SEGGER_RTT_WriteNoLock_3: (+1)
   \       0x78   0xF05F 0x0A00      MOVS     R10,#+0
   1148              break;
   1149            }
   1150            //
   1151            // Finish up.
   1152            //
   1153            return Status;
   \                     ??SEGGER_RTT_WriteNoLock_6: (+1)
   \       0x7C   0x4650             MOV      R0,R10
   \       0x7E   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1154          }
   1155          
   1156          /*********************************************************************
   1157          *
   1158          *       SEGGER_RTT_WriteDownBuffer
   1159          *
   1160          *  Function description
   1161          *    Stores a specified number of characters in SEGGER RTT control block in a <Down> buffer.
   1162          *
   1163          *  Parameters
   1164          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1165          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
   1166          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
   1167          *
   1168          *  Return value
   1169          *    Number of bytes which have been stored in the "Down"-buffer.
   1170          *
   1171          *  Notes
   1172          *    (1) Data is stored according to buffer flags.
   1173          *
   1174          *  Additional information
   1175          *    This function must not be called when J-Link might also do RTT.
   1176          *    This function locks against all other RTT operations. I.e. during
   1177          *    the write operation, writing from the application is also locked.
   1178          *    If only one consumer writes to the down buffer,
   1179          *    call SEGGER_RTT_WriteDownBufferNoLock() instead.
   1180          */

   \                                 In section .text, align 2, keep-with-next
   1181          unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteDownBuffer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1182            unsigned Status;
   1183          
   1184            INIT();
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable27_1
   \        0xC   0x7838             LDRB     R0,[R7, #+0]
   \        0xE   0x2853             CMP      R0,#+83
   \       0x10   0xD001             BEQ.N    ??SEGGER_RTT_WriteDownBuffer_0
   \       0x12   0x.... 0x....      BL       _DoInit
   1185            SEGGER_RTT_LOCK();
   \                     ??SEGGER_RTT_WriteDownBuffer_0: (+1)
   \       0x16   0xF3EF 0x8711      MRS      R7,BASEPRI
   \       0x1A   0x2020             MOVS     R0,#+32
   \       0x1C   0xF380 0x8811      MSR      BASEPRI,R0
   1186            Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
   \       0x20   0x0032             MOVS     R2,R6
   \       0x22   0x0029             MOVS     R1,R5
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       SEGGER_RTT_WriteDownBufferNoLock
   1187            SEGGER_RTT_UNLOCK();
   \       0x2A   0xF387 0x8811      MSR      BASEPRI,R7
   1188            return Status;
   \       0x2E   0xBDF2             POP      {R1,R4-R7,PC}
   1189          }
   1190          
   1191          /*********************************************************************
   1192          *
   1193          *       SEGGER_RTT_Write
   1194          *
   1195          *  Function description
   1196          *    Stores a specified number of characters in SEGGER RTT
   1197          *    control block which is then read by the host.
   1198          *
   1199          *  Parameters
   1200          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1201          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
   1202          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
   1203          *
   1204          *  Return value
   1205          *    Number of bytes which have been stored in the "Up"-buffer.
   1206          *
   1207          *  Notes
   1208          *    (1) Data is stored according to buffer flags.
   1209          */

   \                                 In section .text, align 2, keep-with-next
   1210          unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_Write: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1211            unsigned Status;
   1212          
   1213            INIT();
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable27_1
   \        0xC   0x7838             LDRB     R0,[R7, #+0]
   \        0xE   0x2853             CMP      R0,#+83
   \       0x10   0xD001             BEQ.N    ??SEGGER_RTT_Write_0
   \       0x12   0x.... 0x....      BL       _DoInit
   1214            SEGGER_RTT_LOCK();
   \                     ??SEGGER_RTT_Write_0: (+1)
   \       0x16   0xF3EF 0x8711      MRS      R7,BASEPRI
   \       0x1A   0x2020             MOVS     R0,#+32
   \       0x1C   0xF380 0x8811      MSR      BASEPRI,R0
   1215            Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
   \       0x20   0x0032             MOVS     R2,R6
   \       0x22   0x0029             MOVS     R1,R5
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       SEGGER_RTT_WriteNoLock
   1216            SEGGER_RTT_UNLOCK();
   \       0x2A   0xF387 0x8811      MSR      BASEPRI,R7
   1217            return Status;
   \       0x2E   0xBDF2             POP      {R1,R4-R7,PC}
   1218          }
   1219          
   1220          /*********************************************************************
   1221          *
   1222          *       SEGGER_RTT_WriteString
   1223          *
   1224          *  Function description
   1225          *    Stores string in SEGGER RTT control block.
   1226          *    This data is read by the host.
   1227          *
   1228          *  Parameters
   1229          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1230          *    s            Pointer to string.
   1231          *
   1232          *  Return value
   1233          *    Number of bytes which have been stored in the "Up"-buffer.
   1234          *
   1235          *  Notes
   1236          *    (1) Data is stored according to buffer flags.
   1237          *    (2) String passed to this function has to be \0 terminated
   1238          *    (3) \0 termination character is *not* stored in RTT buffer
   1239          */

   \                                 In section .text, align 2, keep-with-next
   1240          unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
   \                     SEGGER_RTT_WriteString: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   1241            unsigned Len;
   1242          
   1243            Len = STRLEN(s);
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x0005             MOVS     R5,R0
   1244            return SEGGER_RTT_Write(BufferIndex, s, Len);
   \        0xE   0x002A             MOVS     R2,R5
   \       0x10   0x0021             MOVS     R1,R4
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0x.... 0x....      BL       SEGGER_RTT_Write
   \       0x18   0xBD70             POP      {R4-R6,PC}
   1245          }
   1246          
   1247          /*********************************************************************
   1248          *
   1249          *       SEGGER_RTT_PutCharSkipNoLock
   1250          *
   1251          *  Function description
   1252          *    Stores a single character/byte in SEGGER RTT buffer.
   1253          *    SEGGER_RTT_PutCharSkipNoLock does not lock the application and
   1254          *    skips the byte, if it does not fit into the buffer.
   1255          *
   1256          *  Parameters
   1257          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1258          *    c            Byte to be stored.
   1259          *
   1260          *  Return value
   1261          *    Number of bytes which have been stored in the "Up"-buffer.
   1262          *
   1263          *  Notes
   1264          *    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
   1265          *    (2) For performance reasons this function does not call Init()
   1266          *        and may only be called after RTT has been initialized.
   1267          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
   1268          */
   1269          

   \                                 In section .text, align 2, keep-with-next
   1270          unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
   \                     SEGGER_RTT_PutCharSkipNoLock: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0002             MOVS     R2,R0
   1271            SEGGER_RTT_BUFFER_UP* pRing;
   1272            unsigned              WrOff;
   1273            unsigned              Status;
   1274            volatile char*        pDst;
   1275            //
   1276            // Get "to-host" ring buffer.
   1277            //
   1278            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \        0x8   0x2018             MOVS     R0,#+24
   \        0xA   0xFB00 0xF002      MUL      R0,R0,R2
   \        0xE   0x4420             ADD      R0,R4,R0
   \       0x10   0xF110 0x0418      ADDS     R4,R0,#+24
   1279            //
   1280            // Get write position and handle wrap-around if necessary
   1281            //
   1282            WrOff = pRing->WrOff + 1;
   \       0x14   0x68E5             LDR      R5,[R4, #+12]
   \       0x16   0x1C6D             ADDS     R5,R5,#+1
   1283            if (WrOff == pRing->SizeOfBuffer) {
   \       0x18   0x68A0             LDR      R0,[R4, #+8]
   \       0x1A   0x4285             CMP      R5,R0
   \       0x1C   0xD101             BNE.N    ??SEGGER_RTT_PutCharSkipNoLock_0
   1284              WrOff = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x0005             MOVS     R5,R0
   1285            }
   1286            //
   1287            // Output byte if free space is available
   1288            //
   1289            if (WrOff != pRing->RdOff) {
   \                     ??SEGGER_RTT_PutCharSkipNoLock_0: (+1)
   \       0x22   0x6920             LDR      R0,[R4, #+16]
   \       0x24   0x4285             CMP      R5,R0
   \       0x26   0xD007             BEQ.N    ??SEGGER_RTT_PutCharSkipNoLock_1
   1290              pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \       0x28   0x6866             LDR      R6,[R4, #+4]
   \       0x2A   0x68E0             LDR      R0,[R4, #+12]
   \       0x2C   0x4430             ADD      R0,R6,R0
   \       0x2E   0x0003             MOVS     R3,R0
   1291              *pDst = c;
   \       0x30   0x7019             STRB     R1,[R3, #+0]
   1292              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1293              pRing->WrOff = WrOff;
   \       0x32   0x60E5             STR      R5,[R4, #+12]
   1294              Status = 1;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE000             B.N      ??SEGGER_RTT_PutCharSkipNoLock_2
   1295            } else {
   1296              Status = 0;
   \                     ??SEGGER_RTT_PutCharSkipNoLock_1: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   1297            }
   1298            //
   1299            return Status;
   \                     ??SEGGER_RTT_PutCharSkipNoLock_2: (+1)
   \       0x3A   0xBC70             POP      {R4-R6}
   \       0x3C   0x4770             BX       LR
   1300          }
   1301          
   1302          /*********************************************************************
   1303          *
   1304          *       SEGGER_RTT_PutCharSkip
   1305          *
   1306          *  Function description
   1307          *    Stores a single character/byte in SEGGER RTT buffer.
   1308          *
   1309          *  Parameters
   1310          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1311          *    c            Byte to be stored.
   1312          *
   1313          *  Return value
   1314          *    Number of bytes which have been stored in the "Up"-buffer.
   1315          *
   1316          *  Notes
   1317          *    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
   1318          */
   1319          

   \                                 In section .text, align 2, keep-with-next
   1320          unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
   \                     SEGGER_RTT_PutCharSkip: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1321            SEGGER_RTT_BUFFER_UP* pRing;
   1322            unsigned              WrOff;
   1323            unsigned              Status;
   1324            volatile char*        pDst;
   1325            //
   1326            // Prepare
   1327            //
   1328            INIT();
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable27_1
   \        0xC   0x46B8             MOV      R8,R7
   \        0xE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x12   0x2853             CMP      R0,#+83
   \       0x14   0xD001             BEQ.N    ??SEGGER_RTT_PutCharSkip_0
   \       0x16   0x.... 0x....      BL       _DoInit
   1329            SEGGER_RTT_LOCK();
   \                     ??SEGGER_RTT_PutCharSkip_0: (+1)
   \       0x1A   0xF3EF 0x8111      MRS      R1,BASEPRI
   \       0x1E   0x2020             MOVS     R0,#+32
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   1330            //
   1331            // Get "to-host" ring buffer.
   1332            //
   1333            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \       0x24   0x2018             MOVS     R0,#+24
   \       0x26   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x2A   0x4438             ADD      R0,R7,R0
   \       0x2C   0xF110 0x0218      ADDS     R2,R0,#+24
   1334            //
   1335            // Get write position and handle wrap-around if necessary
   1336            //
   1337            WrOff = pRing->WrOff + 1;
   \       0x30   0x68D3             LDR      R3,[R2, #+12]
   \       0x32   0x1C5B             ADDS     R3,R3,#+1
   1338            if (WrOff == pRing->SizeOfBuffer) {
   \       0x34   0x6890             LDR      R0,[R2, #+8]
   \       0x36   0x4283             CMP      R3,R0
   \       0x38   0xD101             BNE.N    ??SEGGER_RTT_PutCharSkip_1
   1339              WrOff = 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x0003             MOVS     R3,R0
   1340            }
   1341            //
   1342            // Output byte if free space is available
   1343            //
   1344            if (WrOff != pRing->RdOff) {
   \                     ??SEGGER_RTT_PutCharSkip_1: (+1)
   \       0x3E   0x6910             LDR      R0,[R2, #+16]
   \       0x40   0x4283             CMP      R3,R0
   \       0x42   0xD007             BEQ.N    ??SEGGER_RTT_PutCharSkip_2
   1345              pDst  = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \       0x44   0x6857             LDR      R7,[R2, #+4]
   \       0x46   0x68D0             LDR      R0,[R2, #+12]
   \       0x48   0x4438             ADD      R0,R7,R0
   \       0x4A   0x0006             MOVS     R6,R0
   1346              *pDst = c;
   \       0x4C   0x7035             STRB     R5,[R6, #+0]
   1347              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1348              pRing->WrOff = WrOff;
   \       0x4E   0x60D3             STR      R3,[R2, #+12]
   1349              Status = 1;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xE000             B.N      ??SEGGER_RTT_PutCharSkip_3
   1350            } else {
   1351              Status = 0;
   \                     ??SEGGER_RTT_PutCharSkip_2: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   1352            }
   1353            //
   1354            // Finish up.
   1355            //
   1356            SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_PutCharSkip_3: (+1)
   \       0x56   0xF381 0x8811      MSR      BASEPRI,R1
   1357            //
   1358            return Status;
   \       0x5A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1359          }
   1360          
   1361           /*********************************************************************
   1362          *
   1363          *       SEGGER_RTT_PutChar
   1364          *
   1365          *  Function description
   1366          *    Stores a single character/byte in SEGGER RTT buffer.
   1367          *
   1368          *  Parameters
   1369          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1370          *    c            Byte to be stored.
   1371          *
   1372          *  Return value
   1373          *    Number of bytes which have been stored in the "Up"-buffer.
   1374          *
   1375          *  Notes
   1376          *    (1) Data is stored according to buffer flags.
   1377          */
   1378          

   \                                 In section .text, align 2, keep-with-next
   1379          unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
   \                     SEGGER_RTT_PutChar: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1380            SEGGER_RTT_BUFFER_UP* pRing;
   1381            unsigned              WrOff;
   1382            unsigned              Status;
   1383            volatile char*        pDst;
   1384            //
   1385            // Prepare
   1386            //
   1387            INIT();
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable27_1
   \        0xC   0x46B8             MOV      R8,R7
   \        0xE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x12   0x2853             CMP      R0,#+83
   \       0x14   0xD001             BEQ.N    ??SEGGER_RTT_PutChar_0
   \       0x16   0x.... 0x....      BL       _DoInit
   1388            SEGGER_RTT_LOCK();
   \                     ??SEGGER_RTT_PutChar_0: (+1)
   \       0x1A   0xF3EF 0x8111      MRS      R1,BASEPRI
   \       0x1E   0x2020             MOVS     R0,#+32
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   1389            //
   1390            // Get "to-host" ring buffer.
   1391            //
   1392            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \       0x24   0x2018             MOVS     R0,#+24
   \       0x26   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x2A   0x4438             ADD      R0,R7,R0
   \       0x2C   0xF110 0x0218      ADDS     R2,R0,#+24
   1393            //
   1394            // Get write position and handle wrap-around if necessary
   1395            //
   1396            WrOff = pRing->WrOff + 1;
   \       0x30   0x68D3             LDR      R3,[R2, #+12]
   \       0x32   0x1C5B             ADDS     R3,R3,#+1
   1397            if (WrOff == pRing->SizeOfBuffer) {
   \       0x34   0x6890             LDR      R0,[R2, #+8]
   \       0x36   0x4283             CMP      R3,R0
   \       0x38   0xD101             BNE.N    ??SEGGER_RTT_PutChar_1
   1398              WrOff = 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x0003             MOVS     R3,R0
   1399            }
   1400            //
   1401            // Wait for free space if mode is set to blocking
   1402            //
   1403            if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
   \                     ??SEGGER_RTT_PutChar_1: (+1)
   \       0x3E   0x6950             LDR      R0,[R2, #+20]
   \       0x40   0x2802             CMP      R0,#+2
   \       0x42   0xD102             BNE.N    ??SEGGER_RTT_PutChar_2
   1404              while (WrOff == pRing->RdOff) {
   \                     ??SEGGER_RTT_PutChar_3: (+1)
   \       0x44   0x6910             LDR      R0,[R2, #+16]
   \       0x46   0x4283             CMP      R3,R0
   \       0x48   0xD0FC             BEQ.N    ??SEGGER_RTT_PutChar_3
   1405                ;
   1406              }
   1407            }
   1408            //
   1409            // Output byte if free space is available
   1410            //
   1411            if (WrOff != pRing->RdOff) {
   \                     ??SEGGER_RTT_PutChar_2: (+1)
   \       0x4A   0x6910             LDR      R0,[R2, #+16]
   \       0x4C   0x4283             CMP      R3,R0
   \       0x4E   0xD007             BEQ.N    ??SEGGER_RTT_PutChar_4
   1412              pDst  = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \       0x50   0x6857             LDR      R7,[R2, #+4]
   \       0x52   0x68D0             LDR      R0,[R2, #+12]
   \       0x54   0x4438             ADD      R0,R7,R0
   \       0x56   0x0006             MOVS     R6,R0
   1413              *pDst = c;
   \       0x58   0x7035             STRB     R5,[R6, #+0]
   1414              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1415              pRing->WrOff = WrOff;
   \       0x5A   0x60D3             STR      R3,[R2, #+12]
   1416              Status = 1;
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0xE000             B.N      ??SEGGER_RTT_PutChar_5
   1417            } else {
   1418              Status = 0;
   \                     ??SEGGER_RTT_PutChar_4: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   1419            }
   1420            //
   1421            // Finish up.
   1422            //
   1423            SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_PutChar_5: (+1)
   \       0x62   0xF381 0x8811      MSR      BASEPRI,R1
   1424            return Status;
   \       0x66   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1425          }
   1426          
   1427          /*********************************************************************
   1428          *
   1429          *       SEGGER_RTT_GetKey
   1430          *
   1431          *  Function description
   1432          *    Reads one character from the SEGGER RTT buffer.
   1433          *    Host has previously stored data there.
   1434          *
   1435          *  Return value
   1436          *    <  0 -   No character available (buffer empty).
   1437          *    >= 0 -   Character which has been read. (Possible values: 0 - 255)
   1438          *
   1439          *  Notes
   1440          *    (1) This function is only specified for accesses to RTT buffer 0.
   1441          */

   \                                 In section .text, align 2, keep-with-next
   1442          int SEGGER_RTT_GetKey(void) {
   \                     SEGGER_RTT_GetKey: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1443            char c;
   1444            int r;
   1445          
   1446            r = (int)SEGGER_RTT_Read(0u, &c, 1u);
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x.... 0x....      BL       SEGGER_RTT_Read
   \        0xC   0x0001             MOVS     R1,R0
   1447            if (r == 1) {
   \        0xE   0x2901             CMP      R1,#+1
   \       0x10   0xD102             BNE.N    ??SEGGER_RTT_GetKey_0
   1448              r = (int)(unsigned char)c;
   \       0x12   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x16   0xE001             B.N      ??SEGGER_RTT_GetKey_1
   1449            } else {
   1450              r = -1;
   \                     ??SEGGER_RTT_GetKey_0: (+1)
   \       0x18   0xF05F 0x30FF      MOVS     R0,#+4294967295
   1451            }
   1452            return r;
   \                     ??SEGGER_RTT_GetKey_1: (+1)
   \       0x1C   0xBD02             POP      {R1,PC}
   1453          }
   1454          
   1455          /*********************************************************************
   1456          *
   1457          *       SEGGER_RTT_WaitKey
   1458          *
   1459          *  Function description
   1460          *    Waits until at least one character is avaible in the SEGGER RTT buffer.
   1461          *    Once a character is available, it is read and this function returns.
   1462          *
   1463          *  Return value
   1464          *    >=0 -   Character which has been read.
   1465          *
   1466          *  Notes
   1467          *    (1) This function is only specified for accesses to RTT buffer 0
   1468          *    (2) This function is blocking if no character is present in RTT buffer
   1469          */

   \                                 In section .text, align 2, keep-with-next
   1470          int SEGGER_RTT_WaitKey(void) {
   \                     SEGGER_RTT_WaitKey: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1471            int r;
   1472          
   1473            do {
   1474              r = SEGGER_RTT_GetKey();
   \                     ??SEGGER_RTT_WaitKey_0: (+1)
   \        0x2   0x.... 0x....      BL       SEGGER_RTT_GetKey
   \        0x6   0x0004             MOVS     R4,R0
   1475            } while (r < 0);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD4FA             BMI.N    ??SEGGER_RTT_WaitKey_0
   1476            return r;
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0xBD10             POP      {R4,PC}
   1477          }
   1478          
   1479          /*********************************************************************
   1480          *
   1481          *       SEGGER_RTT_HasKey
   1482          *
   1483          *  Function description
   1484          *    Checks if at least one character for reading is available in the SEGGER RTT buffer.
   1485          *
   1486          *  Return value
   1487          *    == 0 -     No characters are available to read.
   1488          *    == 1 -     At least one character is available.
   1489          *
   1490          *  Notes
   1491          *    (1) This function is only specified for accesses to RTT buffer 0
   1492          */

   \                                 In section .text, align 2, keep-with-next
   1493          int SEGGER_RTT_HasKey(void) {
   \                     SEGGER_RTT_HasKey: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1494            SEGGER_RTT_BUFFER_DOWN* pRing;
   1495            unsigned RdOff;
   1496            int r;
   1497          
   1498            INIT();
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \        0x6   0x0025             MOVS     R5,R4
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   \        0xA   0x2853             CMP      R0,#+83
   \        0xC   0xD001             BEQ.N    ??SEGGER_RTT_HasKey_0
   \        0xE   0x.... 0x....      BL       _DoInit
   1499            pRing = (SEGGER_RTT_BUFFER_DOWN*)((uintptr_t)&_SEGGER_RTT.aDown[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \                     ??SEGGER_RTT_HasKey_0: (+1)
   \       0x12   0xF114 0x0160      ADDS     R1,R4,#+96
   1500            RdOff = pRing->RdOff;
   \       0x16   0x690A             LDR      R2,[R1, #+16]
   1501            if (RdOff != pRing->WrOff) {
   \       0x18   0x68C8             LDR      R0,[R1, #+12]
   \       0x1A   0x4282             CMP      R2,R0
   \       0x1C   0xD001             BEQ.N    ??SEGGER_RTT_HasKey_1
   1502              r = 1;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE000             B.N      ??SEGGER_RTT_HasKey_2
   1503            } else {
   1504              r = 0;
   \                     ??SEGGER_RTT_HasKey_1: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   1505            }
   1506            return r;
   \                     ??SEGGER_RTT_HasKey_2: (+1)
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
   1507          }
   1508          
   1509          /*********************************************************************
   1510          *
   1511          *       SEGGER_RTT_HasData
   1512          *
   1513          *  Function description
   1514          *    Check if there is data from the host in the given buffer.
   1515          *
   1516          *  Return value:
   1517          *  ==0:  No data
   1518          *  !=0:  Data in buffer
   1519          *
   1520          */

   \                                 In section .text, align 2, keep-with-next
   1521          unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
   \                     SEGGER_RTT_HasData: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   1522            SEGGER_RTT_BUFFER_DOWN* pRing;
   1523            unsigned                v;
   1524          
   1525            pRing = (SEGGER_RTT_BUFFER_DOWN*)((uintptr_t)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \        0x6   0x2018             MOVS     R0,#+24
   \        0x8   0xFB00 0xF002      MUL      R0,R0,R2
   \        0xC   0x4408             ADD      R0,R1,R0
   \        0xE   0xF110 0x0160      ADDS     R1,R0,#+96
   1526            v = pRing->WrOff;
   \       0x12   0x68C8             LDR      R0,[R1, #+12]
   1527            return v - pRing->RdOff;
   \       0x14   0x6909             LDR      R1,[R1, #+16]
   \       0x16   0x1A40             SUBS     R0,R0,R1
   \       0x18   0x4770             BX       LR
   1528          }
   1529          
   1530          /*********************************************************************
   1531          *
   1532          *       SEGGER_RTT_HasDataUp
   1533          *
   1534          *  Function description
   1535          *    Check if there is data remaining to be sent in the given buffer.
   1536          *
   1537          *  Return value:
   1538          *  ==0:  No data
   1539          *  !=0:  Data in buffer
   1540          *
   1541          */

   \                                 In section .text, align 2, keep-with-next
   1542          unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
   \                     SEGGER_RTT_HasDataUp: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1543            SEGGER_RTT_BUFFER_UP* pRing;
   1544            unsigned                v;
   1545          
   1546            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0x2   0x.... 0x....      LDR.W    R2,??DataTable27_1
   \        0x6   0x2018             MOVS     R0,#+24
   \        0x8   0xFB00 0xF001      MUL      R0,R0,R1
   \        0xC   0x4410             ADD      R0,R2,R0
   \        0xE   0xF110 0x0218      ADDS     R2,R0,#+24
   1547            v = pRing->RdOff;
   \       0x12   0x6910             LDR      R0,[R2, #+16]
   1548            return pRing->WrOff - v;
   \       0x14   0x68D2             LDR      R2,[R2, #+12]
   \       0x16   0x1A10             SUBS     R0,R2,R0
   \       0x18   0x4770             BX       LR
   1549          }
   1550          
   1551          /*********************************************************************
   1552          *
   1553          *       SEGGER_RTT_AllocDownBuffer
   1554          *
   1555          *  Function description
   1556          *    Run-time configuration of the next down-buffer (H->T).
   1557          *    The next buffer, which is not used yet is configured.
   1558          *    This includes: Buffer address, size, name, flags, ...
   1559          *
   1560          *  Parameters
   1561          *    sName        Pointer to a constant name string.
   1562          *    pBuffer      Pointer to a buffer to be used.
   1563          *    BufferSize   Size of the buffer.
   1564          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1565          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1566          *
   1567          *  Return value
   1568          *    >= 0 - O.K. Buffer Index
   1569          *     < 0 - Error
   1570          */

   \                                 In section .text, align 2, keep-with-next
   1571          int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   \                     SEGGER_RTT_AllocDownBuffer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1572            int BufferIndex;
   1573            volatile SEGGER_RTT_CB* pRTTCB;
   1574          
   1575            INIT();
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable27_1
   \       0x10   0x46C1             MOV      R9,R8
   \       0x12   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x16   0x2853             CMP      R0,#+83
   \       0x18   0xD001             BEQ.N    ??SEGGER_RTT_AllocDownBuffer_0
   \       0x1A   0x.... 0x....      BL       _DoInit
   1576            SEGGER_RTT_LOCK();
   \                     ??SEGGER_RTT_AllocDownBuffer_0: (+1)
   \       0x1E   0xF3EF 0x8211      MRS      R2,BASEPRI
   \       0x22   0x2020             MOVS     R0,#+32
   \       0x24   0xF380 0x8811      MSR      BASEPRI,R0
   1577            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1578            BufferIndex = 0;
   \       0x28   0x2100             MOVS     R1,#+0
   1579            do {
   1580              if (pRTTCB->aDown[BufferIndex].pBuffer == NULL) {
   \                     ??SEGGER_RTT_AllocDownBuffer_1: (+1)
   \       0x2A   0x2318             MOVS     R3,#+24
   \       0x2C   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x30   0x4440             ADD      R0,R8,R0
   \       0x32   0x6E40             LDR      R0,[R0, #+100]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD004             BEQ.N    ??SEGGER_RTT_AllocDownBuffer_2
   1581                break;
   1582              }
   1583              BufferIndex++;
   \                     ??SEGGER_RTT_AllocDownBuffer_3: (+1)
   \       0x38   0x1C49             ADDS     R1,R1,#+1
   1584            } while (BufferIndex < pRTTCB->MaxNumDownBuffers);
   \       0x3A   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x3E   0x4281             CMP      R1,R0
   \       0x40   0xDBF3             BLT.N    ??SEGGER_RTT_AllocDownBuffer_1
   1585            if (BufferIndex < pRTTCB->MaxNumDownBuffers) {
   \                     ??SEGGER_RTT_AllocDownBuffer_2: (+1)
   \       0x42   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x46   0x4281             CMP      R1,R0
   \       0x48   0xDA1D             BGE.N    ??SEGGER_RTT_AllocDownBuffer_4
   1586              pRTTCB->aDown[BufferIndex].sName        = sName;
   \       0x4A   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x4E   0x4440             ADD      R0,R8,R0
   \       0x50   0x6604             STR      R4,[R0, #+96]
   1587              pRTTCB->aDown[BufferIndex].pBuffer      = (char*)pBuffer;
   \       0x52   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x56   0x4440             ADD      R0,R8,R0
   \       0x58   0x6645             STR      R5,[R0, #+100]
   1588              pRTTCB->aDown[BufferIndex].SizeOfBuffer = BufferSize;
   \       0x5A   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x5E   0x4440             ADD      R0,R8,R0
   \       0x60   0x6686             STR      R6,[R0, #+104]
   1589              pRTTCB->aDown[BufferIndex].RdOff        = 0u;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xFB03 0xFC01      MUL      R12,R3,R1
   \       0x68   0x44C4             ADD      R12,R8,R12
   \       0x6A   0xF8CC 0x0070      STR      R0,[R12, #+112]
   1590              pRTTCB->aDown[BufferIndex].WrOff        = 0u;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xFB03 0xFC01      MUL      R12,R3,R1
   \       0x74   0x44C4             ADD      R12,R8,R12
   \       0x76   0xF8CC 0x006C      STR      R0,[R12, #+108]
   1591              pRTTCB->aDown[BufferIndex].Flags        = Flags;
   \       0x7A   0xFB03 0xF301      MUL      R3,R3,R1
   \       0x7E   0xEB08 0x0003      ADD      R0,R8,R3
   \       0x82   0x6747             STR      R7,[R0, #+116]
   \       0x84   0xE002             B.N      ??SEGGER_RTT_AllocDownBuffer_5
   1592              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1593            } else {
   1594              BufferIndex = -1;
   \                     ??SEGGER_RTT_AllocDownBuffer_4: (+1)
   \       0x86   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x8A   0x0001             MOVS     R1,R0
   1595            }
   1596            SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_AllocDownBuffer_5: (+1)
   \       0x8C   0xF382 0x8811      MSR      BASEPRI,R2
   1597            return BufferIndex;
   \       0x90   0x0008             MOVS     R0,R1
   \       0x92   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1598          }
   1599          
   1600          /*********************************************************************
   1601          *
   1602          *       SEGGER_RTT_AllocUpBuffer
   1603          *
   1604          *  Function description
   1605          *    Run-time configuration of the next up-buffer (T->H).
   1606          *    The next buffer, which is not used yet is configured.
   1607          *    This includes: Buffer address, size, name, flags, ...
   1608          *
   1609          *  Parameters
   1610          *    sName        Pointer to a constant name string.
   1611          *    pBuffer      Pointer to a buffer to be used.
   1612          *    BufferSize   Size of the buffer.
   1613          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1614          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1615          *
   1616          *  Return value
   1617          *    >= 0 - O.K. Buffer Index
   1618          *     < 0 - Error
   1619          */

   \                                 In section .text, align 2, keep-with-next
   1620          int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   \                     SEGGER_RTT_AllocUpBuffer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1621            int BufferIndex;
   1622            volatile SEGGER_RTT_CB* pRTTCB;
   1623          
   1624            INIT();
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable27_1
   \       0x10   0x46C1             MOV      R9,R8
   \       0x12   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x16   0x2853             CMP      R0,#+83
   \       0x18   0xD001             BEQ.N    ??SEGGER_RTT_AllocUpBuffer_0
   \       0x1A   0x.... 0x....      BL       _DoInit
   1625            SEGGER_RTT_LOCK();
   \                     ??SEGGER_RTT_AllocUpBuffer_0: (+1)
   \       0x1E   0xF3EF 0x8211      MRS      R2,BASEPRI
   \       0x22   0x2020             MOVS     R0,#+32
   \       0x24   0xF380 0x8811      MSR      BASEPRI,R0
   1626            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1627            BufferIndex = 0;
   \       0x28   0x2100             MOVS     R1,#+0
   1628            do {
   1629              if (pRTTCB->aUp[BufferIndex].pBuffer == NULL) {
   \                     ??SEGGER_RTT_AllocUpBuffer_1: (+1)
   \       0x2A   0x2318             MOVS     R3,#+24
   \       0x2C   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x30   0x4440             ADD      R0,R8,R0
   \       0x32   0x69C0             LDR      R0,[R0, #+28]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD004             BEQ.N    ??SEGGER_RTT_AllocUpBuffer_2
   1630                break;
   1631              }
   1632              BufferIndex++;
   \                     ??SEGGER_RTT_AllocUpBuffer_3: (+1)
   \       0x38   0x1C49             ADDS     R1,R1,#+1
   1633            } while (BufferIndex < pRTTCB->MaxNumUpBuffers);
   \       0x3A   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x3E   0x4281             CMP      R1,R0
   \       0x40   0xDBF3             BLT.N    ??SEGGER_RTT_AllocUpBuffer_1
   1634            if (BufferIndex < pRTTCB->MaxNumUpBuffers) {
   \                     ??SEGGER_RTT_AllocUpBuffer_2: (+1)
   \       0x42   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x46   0x4281             CMP      R1,R0
   \       0x48   0xDA1D             BGE.N    ??SEGGER_RTT_AllocUpBuffer_4
   1635              pRTTCB->aUp[BufferIndex].sName        = sName;
   \       0x4A   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x4E   0x4440             ADD      R0,R8,R0
   \       0x50   0x6184             STR      R4,[R0, #+24]
   1636              pRTTCB->aUp[BufferIndex].pBuffer      = (char*)pBuffer;
   \       0x52   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x56   0x4440             ADD      R0,R8,R0
   \       0x58   0x61C5             STR      R5,[R0, #+28]
   1637              pRTTCB->aUp[BufferIndex].SizeOfBuffer = BufferSize;
   \       0x5A   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x5E   0x4440             ADD      R0,R8,R0
   \       0x60   0x6206             STR      R6,[R0, #+32]
   1638              pRTTCB->aUp[BufferIndex].RdOff        = 0u;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xFB03 0xFC01      MUL      R12,R3,R1
   \       0x68   0x44C4             ADD      R12,R8,R12
   \       0x6A   0xF8CC 0x0028      STR      R0,[R12, #+40]
   1639              pRTTCB->aUp[BufferIndex].WrOff        = 0u;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xFB03 0xFC01      MUL      R12,R3,R1
   \       0x74   0x44C4             ADD      R12,R8,R12
   \       0x76   0xF8CC 0x0024      STR      R0,[R12, #+36]
   1640              pRTTCB->aUp[BufferIndex].Flags        = Flags;
   \       0x7A   0xFB03 0xF301      MUL      R3,R3,R1
   \       0x7E   0xEB08 0x0003      ADD      R0,R8,R3
   \       0x82   0x62C7             STR      R7,[R0, #+44]
   \       0x84   0xE002             B.N      ??SEGGER_RTT_AllocUpBuffer_5
   1641              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1642            } else {
   1643              BufferIndex = -1;
   \                     ??SEGGER_RTT_AllocUpBuffer_4: (+1)
   \       0x86   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x8A   0x0001             MOVS     R1,R0
   1644            }
   1645            SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_AllocUpBuffer_5: (+1)
   \       0x8C   0xF382 0x8811      MSR      BASEPRI,R2
   1646            return BufferIndex;
   \       0x90   0x0008             MOVS     R0,R1
   \       0x92   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1647          }
   1648          
   1649          /*********************************************************************
   1650          *
   1651          *       SEGGER_RTT_ConfigUpBuffer
   1652          *
   1653          *  Function description
   1654          *    Run-time configuration of a specific up-buffer (T->H).
   1655          *    Buffer to be configured is specified by index.
   1656          *    This includes: Buffer address, size, name, flags, ...
   1657          *
   1658          *  Parameters
   1659          *    BufferIndex  Index of the buffer to configure.
   1660          *    sName        Pointer to a constant name string.
   1661          *    pBuffer      Pointer to a buffer to be used.
   1662          *    BufferSize   Size of the buffer.
   1663          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1664          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1665          *
   1666          *  Return value
   1667          *    >= 0 - O.K.
   1668          *     < 0 - Error
   1669          *
   1670          *  Additional information
   1671          *    Buffer 0 is configured on compile-time.
   1672          *    May only be called once per buffer.
   1673          *    Buffer name and flags can be reconfigured using the appropriate functions.
   1674          */

   \                                 In section .text, align 2, keep-with-next
   1675          int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   \                     SEGGER_RTT_ConfigUpBuffer: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1676            int r;
   1677            volatile SEGGER_RTT_CB* pRTTCB;
   1678            volatile SEGGER_RTT_BUFFER_UP* pUp;
   1679          
   1680            INIT();
   \       0x10   0x.... 0x....      LDR.W    R5,??DataTable27_1
   \       0x14   0x46AB             MOV      R11,R5
   \       0x16   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \       0x1A   0x2853             CMP      R0,#+83
   \       0x1C   0xD001             BEQ.N    ??SEGGER_RTT_ConfigUpBuffer_0
   \       0x1E   0x.... 0x....      BL       _DoInit
   1681            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1682            if (BufferIndex < SEGGER_RTT_MAX_NUM_UP_BUFFERS) {
   \                     ??SEGGER_RTT_ConfigUpBuffer_0: (+1)
   \       0x22   0x2C03             CMP      R4,#+3
   \       0x24   0xD21E             BCS.N    ??SEGGER_RTT_ConfigUpBuffer_1
   1683              SEGGER_RTT_LOCK();
   \       0x26   0xF3EF 0x8111      MRS      R1,BASEPRI
   \       0x2A   0x2020             MOVS     R0,#+32
   \       0x2C   0xF380 0x8811      MSR      BASEPRI,R0
   1684              pUp = &pRTTCB->aUp[BufferIndex];
   \       0x30   0x2018             MOVS     R0,#+24
   \       0x32   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x36   0x4428             ADD      R0,R5,R0
   \       0x38   0x3018             ADDS     R0,R0,#+24
   \       0x3A   0x4681             MOV      R9,R0
   1685              if (BufferIndex) {
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD00B             BEQ.N    ??SEGGER_RTT_ConfigUpBuffer_2
   1686                pUp->sName        = sName;
   \       0x40   0xF8C9 0xA000      STR      R10,[R9, #+0]
   1687                pUp->pBuffer      = (char*)pBuffer;
   \       0x44   0xF8C9 0x6004      STR      R6,[R9, #+4]
   1688                pUp->SizeOfBuffer = BufferSize;
   \       0x48   0xF8C9 0x7008      STR      R7,[R9, #+8]
   1689                pUp->RdOff        = 0u;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xF8C9 0x0010      STR      R0,[R9, #+16]
   1690                pUp->WrOff        = 0u;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF8C9 0x000C      STR      R0,[R9, #+12]
   1691              }
   1692              pUp->Flags          = Flags;
   \                     ??SEGGER_RTT_ConfigUpBuffer_2: (+1)
   \       0x58   0xF8C9 0x8014      STR      R8,[R9, #+20]
   1693              SEGGER_RTT_UNLOCK();
   \       0x5C   0xF381 0x8811      MSR      BASEPRI,R1
   1694              r =  0;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xE001             B.N      ??SEGGER_RTT_ConfigUpBuffer_3
   1695            } else {
   1696              r = -1;
   \                     ??SEGGER_RTT_ConfigUpBuffer_1: (+1)
   \       0x64   0xF05F 0x30FF      MOVS     R0,#+4294967295
   1697            }
   1698            return r;
   \                     ??SEGGER_RTT_ConfigUpBuffer_3: (+1)
   \       0x68   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1699          }
   1700          
   1701          /*********************************************************************
   1702          *
   1703          *       SEGGER_RTT_ConfigDownBuffer
   1704          *
   1705          *  Function description
   1706          *    Run-time configuration of a specific down-buffer (H->T).
   1707          *    Buffer to be configured is specified by index.
   1708          *    This includes: Buffer address, size, name, flags, ...
   1709          *
   1710          *  Parameters
   1711          *    BufferIndex  Index of the buffer to configure.
   1712          *    sName        Pointer to a constant name string.
   1713          *    pBuffer      Pointer to a buffer to be used.
   1714          *    BufferSize   Size of the buffer.
   1715          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1716          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1717          *
   1718          *  Return value
   1719          *    >= 0  O.K.
   1720          *     < 0  Error
   1721          *
   1722          *  Additional information
   1723          *    Buffer 0 is configured on compile-time.
   1724          *    May only be called once per buffer.
   1725          *    Buffer name and flags can be reconfigured using the appropriate functions.
   1726          */

   \                                 In section .text, align 2, keep-with-next
   1727          int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   \                     SEGGER_RTT_ConfigDownBuffer: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1728            int r;
   1729            volatile SEGGER_RTT_CB* pRTTCB;
   1730            volatile SEGGER_RTT_BUFFER_DOWN* pDown;
   1731          
   1732            INIT();
   \       0x10   0x.... 0x....      LDR.W    R5,??DataTable27_1
   \       0x14   0x46AB             MOV      R11,R5
   \       0x16   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \       0x1A   0x2853             CMP      R0,#+83
   \       0x1C   0xD001             BEQ.N    ??SEGGER_RTT_ConfigDownBuffer_0
   \       0x1E   0x.... 0x....      BL       _DoInit
   1733            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1734            if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
   \                     ??SEGGER_RTT_ConfigDownBuffer_0: (+1)
   \       0x22   0x2C03             CMP      R4,#+3
   \       0x24   0xD21E             BCS.N    ??SEGGER_RTT_ConfigDownBuffer_1
   1735              SEGGER_RTT_LOCK();
   \       0x26   0xF3EF 0x8111      MRS      R1,BASEPRI
   \       0x2A   0x2020             MOVS     R0,#+32
   \       0x2C   0xF380 0x8811      MSR      BASEPRI,R0
   1736              pDown = &pRTTCB->aDown[BufferIndex];
   \       0x30   0x2018             MOVS     R0,#+24
   \       0x32   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x36   0x4428             ADD      R0,R5,R0
   \       0x38   0x3060             ADDS     R0,R0,#+96
   \       0x3A   0x4681             MOV      R9,R0
   1737              if (BufferIndex) {
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD00B             BEQ.N    ??SEGGER_RTT_ConfigDownBuffer_2
   1738                pDown->sName        = sName;
   \       0x40   0xF8C9 0xA000      STR      R10,[R9, #+0]
   1739                pDown->pBuffer      = (char*)pBuffer;
   \       0x44   0xF8C9 0x6004      STR      R6,[R9, #+4]
   1740                pDown->SizeOfBuffer = BufferSize;
   \       0x48   0xF8C9 0x7008      STR      R7,[R9, #+8]
   1741                pDown->RdOff        = 0u;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xF8C9 0x0010      STR      R0,[R9, #+16]
   1742                pDown->WrOff        = 0u;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF8C9 0x000C      STR      R0,[R9, #+12]
   1743              }
   1744              pDown->Flags          = Flags;
   \                     ??SEGGER_RTT_ConfigDownBuffer_2: (+1)
   \       0x58   0xF8C9 0x8014      STR      R8,[R9, #+20]
   1745              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1746              SEGGER_RTT_UNLOCK();
   \       0x5C   0xF381 0x8811      MSR      BASEPRI,R1
   1747              r =  0;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xE001             B.N      ??SEGGER_RTT_ConfigDownBuffer_3
   1748            } else {
   1749              r = -1;
   \                     ??SEGGER_RTT_ConfigDownBuffer_1: (+1)
   \       0x64   0xF05F 0x30FF      MOVS     R0,#+4294967295
   1750            }
   1751            return r;
   \                     ??SEGGER_RTT_ConfigDownBuffer_3: (+1)
   \       0x68   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1752          }
   1753          
   1754          /*********************************************************************
   1755          *
   1756          *       SEGGER_RTT_SetNameUpBuffer
   1757          *
   1758          *  Function description
   1759          *    Run-time configuration of a specific up-buffer name (T->H).
   1760          *    Buffer to be configured is specified by index.
   1761          *
   1762          *  Parameters
   1763          *    BufferIndex  Index of the buffer to renamed.
   1764          *    sName        Pointer to a constant name string.
   1765          *
   1766          *  Return value
   1767          *    >= 0  O.K.
   1768          *     < 0  Error
   1769          */

   \                                 In section .text, align 2, keep-with-next
   1770          int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
   \                     SEGGER_RTT_SetNameUpBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1771            int r;
   1772            volatile SEGGER_RTT_CB* pRTTCB;
   1773            volatile SEGGER_RTT_BUFFER_UP* pUp;
   1774          
   1775            INIT();
   \        0x8   0x....             LDR.N    R7,??DataTable27_1
   \        0xA   0x46B8             MOV      R8,R7
   \        0xC   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x10   0x2853             CMP      R0,#+83
   \       0x12   0xD001             BEQ.N    ??SEGGER_RTT_SetNameUpBuffer_0
   \       0x14   0x.... 0x....      BL       _DoInit
   1776            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1777            if (BufferIndex < SEGGER_RTT_MAX_NUM_UP_BUFFERS) {
   \                     ??SEGGER_RTT_SetNameUpBuffer_0: (+1)
   \       0x18   0x2C03             CMP      R4,#+3
   \       0x1A   0xD20F             BCS.N    ??SEGGER_RTT_SetNameUpBuffer_1
   1778              SEGGER_RTT_LOCK();
   \       0x1C   0xF3EF 0x8111      MRS      R1,BASEPRI
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   1779              pUp = &pRTTCB->aUp[BufferIndex];
   \       0x26   0x2018             MOVS     R0,#+24
   \       0x28   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x2C   0x4438             ADD      R0,R7,R0
   \       0x2E   0x3018             ADDS     R0,R0,#+24
   \       0x30   0x0006             MOVS     R6,R0
   1780              pUp->sName = sName;
   \       0x32   0x6035             STR      R5,[R6, #+0]
   1781              SEGGER_RTT_UNLOCK();
   \       0x34   0xF381 0x8811      MSR      BASEPRI,R1
   1782              r =  0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE001             B.N      ??SEGGER_RTT_SetNameUpBuffer_2
   1783            } else {
   1784              r = -1;
   \                     ??SEGGER_RTT_SetNameUpBuffer_1: (+1)
   \       0x3C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   1785            }
   1786            return r;
   \                     ??SEGGER_RTT_SetNameUpBuffer_2: (+1)
   \       0x40   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1787          }
   1788          
   1789          /*********************************************************************
   1790          *
   1791          *       SEGGER_RTT_SetNameDownBuffer
   1792          *
   1793          *  Function description
   1794          *    Run-time configuration of a specific Down-buffer name (T->H).
   1795          *    Buffer to be configured is specified by index.
   1796          *
   1797          *  Parameters
   1798          *    BufferIndex  Index of the buffer to renamed.
   1799          *    sName        Pointer to a constant name string.
   1800          *
   1801          *  Return value
   1802          *    >= 0  O.K.
   1803          *     < 0  Error
   1804          */

   \                                 In section .text, align 2, keep-with-next
   1805          int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
   \                     SEGGER_RTT_SetNameDownBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1806            int r;
   1807            volatile SEGGER_RTT_CB* pRTTCB;
   1808            volatile SEGGER_RTT_BUFFER_DOWN* pDown;
   1809          
   1810            INIT();
   \        0x8   0x....             LDR.N    R7,??DataTable27_1
   \        0xA   0x46B8             MOV      R8,R7
   \        0xC   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x10   0x2853             CMP      R0,#+83
   \       0x12   0xD001             BEQ.N    ??SEGGER_RTT_SetNameDownBuffer_0
   \       0x14   0x.... 0x....      BL       _DoInit
   1811            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1812            if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
   \                     ??SEGGER_RTT_SetNameDownBuffer_0: (+1)
   \       0x18   0x2C03             CMP      R4,#+3
   \       0x1A   0xD20F             BCS.N    ??SEGGER_RTT_SetNameDownBuffer_1
   1813              SEGGER_RTT_LOCK();
   \       0x1C   0xF3EF 0x8111      MRS      R1,BASEPRI
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   1814              pDown = &pRTTCB->aDown[BufferIndex];
   \       0x26   0x2018             MOVS     R0,#+24
   \       0x28   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x2C   0x4438             ADD      R0,R7,R0
   \       0x2E   0x3060             ADDS     R0,R0,#+96
   \       0x30   0x0006             MOVS     R6,R0
   1815              pDown->sName = sName;
   \       0x32   0x6035             STR      R5,[R6, #+0]
   1816              SEGGER_RTT_UNLOCK();
   \       0x34   0xF381 0x8811      MSR      BASEPRI,R1
   1817              r =  0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE001             B.N      ??SEGGER_RTT_SetNameDownBuffer_2
   1818            } else {
   1819              r = -1;
   \                     ??SEGGER_RTT_SetNameDownBuffer_1: (+1)
   \       0x3C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   1820            }
   1821            return r;
   \                     ??SEGGER_RTT_SetNameDownBuffer_2: (+1)
   \       0x40   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1822          }
   1823          
   1824          /*********************************************************************
   1825          *
   1826          *       SEGGER_RTT_SetFlagsUpBuffer
   1827          *
   1828          *  Function description
   1829          *    Run-time configuration of specific up-buffer flags (T->H).
   1830          *    Buffer to be configured is specified by index.
   1831          *
   1832          *  Parameters
   1833          *    BufferIndex  Index of the buffer.
   1834          *    Flags        Flags to set for the buffer.
   1835          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1836          *
   1837          *  Return value
   1838          *    >= 0  O.K.
   1839          *     < 0  Error
   1840          */

   \                                 In section .text, align 2, keep-with-next
   1841          int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
   \                     SEGGER_RTT_SetFlagsUpBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1842            int r;
   1843            volatile SEGGER_RTT_CB* pRTTCB;
   1844            volatile SEGGER_RTT_BUFFER_UP* pUp;
   1845          
   1846            INIT();
   \        0x8   0x....             LDR.N    R7,??DataTable27_1
   \        0xA   0x46B8             MOV      R8,R7
   \        0xC   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x10   0x2853             CMP      R0,#+83
   \       0x12   0xD001             BEQ.N    ??SEGGER_RTT_SetFlagsUpBuffer_0
   \       0x14   0x.... 0x....      BL       _DoInit
   1847            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1848            if (BufferIndex < SEGGER_RTT_MAX_NUM_UP_BUFFERS) {
   \                     ??SEGGER_RTT_SetFlagsUpBuffer_0: (+1)
   \       0x18   0x2C03             CMP      R4,#+3
   \       0x1A   0xD20F             BCS.N    ??SEGGER_RTT_SetFlagsUpBuffer_1
   1849              SEGGER_RTT_LOCK();
   \       0x1C   0xF3EF 0x8111      MRS      R1,BASEPRI
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   1850              pUp = &pRTTCB->aUp[BufferIndex];
   \       0x26   0x2018             MOVS     R0,#+24
   \       0x28   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x2C   0x4438             ADD      R0,R7,R0
   \       0x2E   0x3018             ADDS     R0,R0,#+24
   \       0x30   0x0006             MOVS     R6,R0
   1851              pUp->Flags = Flags;
   \       0x32   0x6175             STR      R5,[R6, #+20]
   1852              SEGGER_RTT_UNLOCK();
   \       0x34   0xF381 0x8811      MSR      BASEPRI,R1
   1853              r =  0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE001             B.N      ??SEGGER_RTT_SetFlagsUpBuffer_2
   1854            } else {
   1855              r = -1;
   \                     ??SEGGER_RTT_SetFlagsUpBuffer_1: (+1)
   \       0x3C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   1856            }
   1857            return r;
   \                     ??SEGGER_RTT_SetFlagsUpBuffer_2: (+1)
   \       0x40   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1858          }
   1859          
   1860          /*********************************************************************
   1861          *
   1862          *       SEGGER_RTT_SetFlagsDownBuffer
   1863          *
   1864          *  Function description
   1865          *    Run-time configuration of specific Down-buffer flags (T->H).
   1866          *    Buffer to be configured is specified by index.
   1867          *
   1868          *  Parameters
   1869          *    BufferIndex  Index of the buffer to renamed.
   1870          *    Flags        Flags to set for the buffer.
   1871          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1872          *
   1873          *  Return value
   1874          *    >= 0  O.K.
   1875          *     < 0  Error
   1876          */

   \                                 In section .text, align 2, keep-with-next
   1877          int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
   \                     SEGGER_RTT_SetFlagsDownBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1878            int r;
   1879            volatile SEGGER_RTT_CB* pRTTCB;
   1880            volatile SEGGER_RTT_BUFFER_DOWN* pDown;
   1881          
   1882            INIT();
   \        0x8   0x....             LDR.N    R7,??DataTable27_1
   \        0xA   0x46B8             MOV      R8,R7
   \        0xC   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x10   0x2853             CMP      R0,#+83
   \       0x12   0xD001             BEQ.N    ??SEGGER_RTT_SetFlagsDownBuffer_0
   \       0x14   0x.... 0x....      BL       _DoInit
   1883            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1884            if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
   \                     ??SEGGER_RTT_SetFlagsDownBuffer_0: (+1)
   \       0x18   0x2C03             CMP      R4,#+3
   \       0x1A   0xD20F             BCS.N    ??SEGGER_RTT_SetFlagsDownBuffer_1
   1885              SEGGER_RTT_LOCK();
   \       0x1C   0xF3EF 0x8111      MRS      R1,BASEPRI
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   1886              pDown = &pRTTCB->aDown[BufferIndex];
   \       0x26   0x2018             MOVS     R0,#+24
   \       0x28   0xFB00 0xF004      MUL      R0,R0,R4
   \       0x2C   0x4438             ADD      R0,R7,R0
   \       0x2E   0x3060             ADDS     R0,R0,#+96
   \       0x30   0x0006             MOVS     R6,R0
   1887              pDown->Flags = Flags;
   \       0x32   0x6175             STR      R5,[R6, #+20]
   1888              SEGGER_RTT_UNLOCK();
   \       0x34   0xF381 0x8811      MSR      BASEPRI,R1
   1889              r =  0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE001             B.N      ??SEGGER_RTT_SetFlagsDownBuffer_2
   1890            } else {
   1891              r = -1;
   \                     ??SEGGER_RTT_SetFlagsDownBuffer_1: (+1)
   \       0x3C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   1892            }
   1893            return r;
   \                     ??SEGGER_RTT_SetFlagsDownBuffer_2: (+1)
   \       0x40   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1894          }
   1895          
   1896          /*********************************************************************
   1897          *
   1898          *       SEGGER_RTT_Init
   1899          *
   1900          *  Function description
   1901          *    Initializes the RTT Control Block.
   1902          *    Should be used in RAM targets, at start of the application.
   1903          *
   1904          */

   \                                 In section .text, align 2, keep-with-next
   1905          void SEGGER_RTT_Init (void) {
   \                     SEGGER_RTT_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1906            _DoInit();
   \        0x2   0x.... 0x....      BL       _DoInit
   1907          }
   \        0x6   0xBD01             POP      {R0,PC}
   1908          
   1909          /*********************************************************************
   1910          *
   1911          *       SEGGER_RTT_SetTerminal
   1912          *
   1913          *  Function description
   1914          *    Sets the terminal to be used for output on channel 0.
   1915          *
   1916          *  Parameters
   1917          *    TerminalId  Index of the terminal.
   1918          *
   1919          *  Return value
   1920          *    >= 0  O.K.
   1921          *     < 0  Error (e.g. if RTT is configured for non-blocking mode and there was no space in the buffer to set the new terminal Id)
   1922          *
   1923          *  Notes
   1924          *    (1) Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
   1925          */

   \                                 In section .text, align 2, keep-with-next
   1926          int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
   \                     SEGGER_RTT_SetTerminal: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1927            unsigned char         ac[2];
   1928            SEGGER_RTT_BUFFER_UP* pRing;
   1929            unsigned Avail;
   1930            int r;
   1931          
   1932            INIT();
   \        0x6   0x.... 0x....      LDR.W    R8,??DataTable24
   \        0xA   0x4647             MOV      R7,R8
   \        0xC   0x7838             LDRB     R0,[R7, #+0]
   \        0xE   0x2853             CMP      R0,#+83
   \       0x10   0xD001             BEQ.N    ??SEGGER_RTT_SetTerminal_0
   \       0x12   0x.... 0x....      BL       _DoInit
   1933            r = 0;
   \                     ??SEGGER_RTT_SetTerminal_0: (+1)
   \       0x16   0x2700             MOVS     R7,#+0
   1934            ac[0] = 0xFFu;
   \       0x18   0x20FF             MOVS     R0,#+255
   \       0x1A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1935            if (TerminalId < sizeof(_aTerminalId)) { // We only support a certain number of channels
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2810             CMP      R0,#+16
   \       0x24   0xD22E             BCS.N    ??SEGGER_RTT_SetTerminal_1
   1936              ac[1] = _aTerminalId[TerminalId];
   \       0x26   0x....             LDR.N    R1,??DataTable27
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x5C08             LDRB     R0,[R1, R0]
   \       0x2E   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1937              pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \       0x32   0xF118 0x0018      ADDS     R0,R8,#+24
   \       0x36   0x0005             MOVS     R5,R0
   1938              SEGGER_RTT_LOCK();                     // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
   \       0x38   0xF3EF 0x8811      MRS      R8,BASEPRI
   \       0x3C   0x2020             MOVS     R0,#+32
   \       0x3E   0xF380 0x8811      MSR      BASEPRI,R0
   1939              if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
   \       0x42   0x7D28             LDRB     R0,[R5, #+20]
   \       0x44   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x48   0x2802             CMP      R0,#+2
   \       0x4A   0xD107             BNE.N    ??SEGGER_RTT_SetTerminal_2
   1940                _ActiveTerminal = TerminalId;
   \       0x4C   0x....             LDR.N    R0,??DataTable27_2
   \       0x4E   0x7004             STRB     R4,[R0, #+0]
   1941                _WriteBlocking(pRing, (const char*)ac, 2u);
   \       0x50   0x2202             MOVS     R2,#+2
   \       0x52   0x4669             MOV      R1,SP
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0x.... 0x....      BL       _WriteBlocking
   \       0x5A   0xE010             B.N      ??SEGGER_RTT_SetTerminal_3
   1942              } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
   1943                Avail = _GetAvailWriteSpace(pRing);
   \                     ??SEGGER_RTT_SetTerminal_2: (+1)
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0x.... 0x....      BL       _GetAvailWriteSpace
   \       0x62   0x0006             MOVS     R6,R0
   1944                if (Avail >= 2) {
   \       0x64   0x2E02             CMP      R6,#+2
   \       0x66   0xD307             BCC.N    ??SEGGER_RTT_SetTerminal_4
   1945                  _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
   \       0x68   0x....             LDR.N    R0,??DataTable27_2
   \       0x6A   0x7004             STRB     R4,[R0, #+0]
   1946                  _WriteNoCheck(pRing, (const char*)ac, 2u);
   \       0x6C   0x2202             MOVS     R2,#+2
   \       0x6E   0x4669             MOV      R1,SP
   \       0x70   0x0028             MOVS     R0,R5
   \       0x72   0x.... 0x....      BL       _WriteNoCheck
   \       0x76   0xE002             B.N      ??SEGGER_RTT_SetTerminal_3
   1947                } else {
   1948                  r = -1;
   \                     ??SEGGER_RTT_SetTerminal_4: (+1)
   \       0x78   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x7C   0x0007             MOVS     R7,R0
   1949                }
   1950              }
   1951              SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_SetTerminal_3: (+1)
   \       0x7E   0xF388 0x8811      MSR      BASEPRI,R8
   \       0x82   0xE002             B.N      ??SEGGER_RTT_SetTerminal_5
   1952            } else {
   1953              r = -1;
   \                     ??SEGGER_RTT_SetTerminal_1: (+1)
   \       0x84   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x88   0x0007             MOVS     R7,R0
   1954            }
   1955            return r;
   \                     ??SEGGER_RTT_SetTerminal_5: (+1)
   \       0x8A   0x0038             MOVS     R0,R7
   \       0x8C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1956          }
   1957          
   1958          /*********************************************************************
   1959          *
   1960          *       SEGGER_RTT_TerminalOut
   1961          *
   1962          *  Function description
   1963          *    Writes a string to the given terminal
   1964          *     without changing the terminal for channel 0.
   1965          *
   1966          *  Parameters
   1967          *    TerminalId   Index of the terminal.
   1968          *    s            String to be printed on the terminal.
   1969          *
   1970          *  Return value
   1971          *    >= 0 - Number of bytes written.
   1972          *     < 0 - Error.
   1973          *
   1974          */

   \                                 In section .text, align 2, keep-with-next
   1975          int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
   \                     SEGGER_RTT_TerminalOut: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1976            int                   Status;
   1977            unsigned              FragLen;
   1978            unsigned              Avail;
   1979            SEGGER_RTT_BUFFER_UP* pRing;
   1980            //
   1981            INIT();
   \        0x8   0x.... 0x....      LDR.W    R9,??DataTable27_1
   \        0xC   0x46CA             MOV      R10,R9
   \        0xE   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \       0x12   0x2853             CMP      R0,#+83
   \       0x14   0xD001             BEQ.N    ??SEGGER_RTT_TerminalOut_0
   \       0x16   0x.... 0x....      BL       _DoInit
   1982            //
   1983            // Validate terminal ID.
   1984            //
   1985            if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
   \                     ??SEGGER_RTT_TerminalOut_0: (+1)
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x2810             CMP      R0,#+16
   \       0x20   0xDA61             BGE.N    ??SEGGER_RTT_TerminalOut_1
   1986              //
   1987              // Get "to-host" ring buffer.
   1988              //
   1989              pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \       0x22   0xF119 0x0018      ADDS     R0,R9,#+24
   \       0x26   0x4680             MOV      R8,R0
   1990              //
   1991              // Need to be able to change terminal, write data, change back.
   1992              // Compute the fixed and variable sizes.
   1993              //
   1994              FragLen = STRLEN(s);
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0x.... 0x....      BL       strlen
   \       0x2E   0x0006             MOVS     R6,R0
   1995              //
   1996              // How we output depends upon the mode...
   1997              //
   1998              SEGGER_RTT_LOCK();
   \       0x30   0xF3EF 0x8911      MRS      R9,BASEPRI
   \       0x34   0x2020             MOVS     R0,#+32
   \       0x36   0xF380 0x8811      MSR      BASEPRI,R0
   1999              Avail = _GetAvailWriteSpace(pRing);
   \       0x3A   0x4640             MOV      R0,R8
   \       0x3C   0x.... 0x....      BL       _GetAvailWriteSpace
   \       0x40   0x0007             MOVS     R7,R0
   2000              switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
   \       0x42   0xF898 0x0014      LDRB     R0,[R8, #+20]
   \       0x46   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD003             BEQ.N    ??SEGGER_RTT_TerminalOut_2
   \       0x4E   0x2802             CMP      R0,#+2
   \       0x50   0xD033             BEQ.N    ??SEGGER_RTT_TerminalOut_3
   \       0x52   0xD317             BCC.N    ??SEGGER_RTT_TerminalOut_4
   \       0x54   0xE042             B.N      ??SEGGER_RTT_TerminalOut_5
   2001              case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
   2002                //
   2003                // If we are in skip mode and there is no space for the whole
   2004                // of this output, don't bother switching terminals at all.
   2005                //
   2006                if (Avail < (FragLen + 4u)) {
   \                     ??SEGGER_RTT_TerminalOut_2: (+1)
   \       0x56   0x1D30             ADDS     R0,R6,#+4
   \       0x58   0x4287             CMP      R7,R0
   \       0x5A   0xD202             BCS.N    ??SEGGER_RTT_TerminalOut_6
   2007                  Status = 0;
   \       0x5C   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x60   0xE00F             B.N      ??SEGGER_RTT_TerminalOut_7
   2008                } else {
   2009                  _PostTerminalSwitch(pRing, TerminalId);
   \                     ??SEGGER_RTT_TerminalOut_6: (+1)
   \       0x62   0x0021             MOVS     R1,R4
   \       0x64   0xB2C9             UXTB     R1,R1
   \       0x66   0x4640             MOV      R0,R8
   \       0x68   0x.... 0x....      BL       _PostTerminalSwitch
   2010                  Status = (int)_WriteBlocking(pRing, s, FragLen);
   \       0x6C   0x0032             MOVS     R2,R6
   \       0x6E   0x0029             MOVS     R1,R5
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x.... 0x....      BL       _WriteBlocking
   \       0x76   0x4682             MOV      R10,R0
   2011                  _PostTerminalSwitch(pRing, _ActiveTerminal);
   \       0x78   0x....             LDR.N    R0,??DataTable27_2
   \       0x7A   0x7801             LDRB     R1,[R0, #+0]
   \       0x7C   0x4640             MOV      R0,R8
   \       0x7E   0x.... 0x....      BL       _PostTerminalSwitch
   2012                }
   2013                break;
   \                     ??SEGGER_RTT_TerminalOut_7: (+1)
   \       0x82   0xE02D             B.N      ??SEGGER_RTT_TerminalOut_8
   2014              case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
   2015                //
   2016                // If we are in trim mode and there is not enough space for everything,
   2017                // trim the output but always include the terminal switch.  If no room
   2018                // for terminal switch, skip that totally.
   2019                //
   2020                if (Avail < 4u) {
   \                     ??SEGGER_RTT_TerminalOut_4: (+1)
   \       0x84   0x2F04             CMP      R7,#+4
   \       0x86   0xD202             BCS.N    ??SEGGER_RTT_TerminalOut_9
   2021                  Status = -1;
   \       0x88   0xF05F 0x3AFF      MOVS     R10,#+4294967295
   \       0x8C   0xE014             B.N      ??SEGGER_RTT_TerminalOut_10
   2022                } else {
   2023                  _PostTerminalSwitch(pRing, TerminalId);
   \                     ??SEGGER_RTT_TerminalOut_9: (+1)
   \       0x8E   0x0021             MOVS     R1,R4
   \       0x90   0xB2C9             UXTB     R1,R1
   \       0x92   0x4640             MOV      R0,R8
   \       0x94   0x.... 0x....      BL       _PostTerminalSwitch
   2024                  Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
   \       0x98   0x1F38             SUBS     R0,R7,#+4
   \       0x9A   0x4286             CMP      R6,R0
   \       0x9C   0xD201             BCS.N    ??SEGGER_RTT_TerminalOut_11
   \       0x9E   0x0032             MOVS     R2,R6
   \       0xA0   0xE000             B.N      ??SEGGER_RTT_TerminalOut_12
   \                     ??SEGGER_RTT_TerminalOut_11: (+1)
   \       0xA2   0x1F3A             SUBS     R2,R7,#+4
   \                     ??SEGGER_RTT_TerminalOut_12: (+1)
   \       0xA4   0x0029             MOVS     R1,R5
   \       0xA6   0x4640             MOV      R0,R8
   \       0xA8   0x.... 0x....      BL       _WriteBlocking
   \       0xAC   0x4682             MOV      R10,R0
   2025                  _PostTerminalSwitch(pRing, _ActiveTerminal);
   \       0xAE   0x....             LDR.N    R0,??DataTable27_2
   \       0xB0   0x7801             LDRB     R1,[R0, #+0]
   \       0xB2   0x4640             MOV      R0,R8
   \       0xB4   0x.... 0x....      BL       _PostTerminalSwitch
   2026                }
   2027                break;
   \                     ??SEGGER_RTT_TerminalOut_10: (+1)
   \       0xB8   0xE012             B.N      ??SEGGER_RTT_TerminalOut_8
   2028              case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
   2029                //
   2030                // If we are in blocking mode, output everything.
   2031                //
   2032                _PostTerminalSwitch(pRing, TerminalId);
   \                     ??SEGGER_RTT_TerminalOut_3: (+1)
   \       0xBA   0x0021             MOVS     R1,R4
   \       0xBC   0xB2C9             UXTB     R1,R1
   \       0xBE   0x4640             MOV      R0,R8
   \       0xC0   0x.... 0x....      BL       _PostTerminalSwitch
   2033                Status = (int)_WriteBlocking(pRing, s, FragLen);
   \       0xC4   0x0032             MOVS     R2,R6
   \       0xC6   0x0029             MOVS     R1,R5
   \       0xC8   0x4640             MOV      R0,R8
   \       0xCA   0x.... 0x....      BL       _WriteBlocking
   \       0xCE   0x4682             MOV      R10,R0
   2034                _PostTerminalSwitch(pRing, _ActiveTerminal);
   \       0xD0   0x....             LDR.N    R0,??DataTable27_2
   \       0xD2   0x7801             LDRB     R1,[R0, #+0]
   \       0xD4   0x4640             MOV      R0,R8
   \       0xD6   0x.... 0x....      BL       _PostTerminalSwitch
   2035                break;
   \       0xDA   0xE001             B.N      ??SEGGER_RTT_TerminalOut_8
   2036              default:
   2037                Status = -1;
   \                     ??SEGGER_RTT_TerminalOut_5: (+1)
   \       0xDC   0xF05F 0x3AFF      MOVS     R10,#+4294967295
   2038                break;
   2039              }
   2040              //
   2041              // Finish up.
   2042              //
   2043              SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_TerminalOut_8: (+1)
   \       0xE0   0xF389 0x8811      MSR      BASEPRI,R9
   \       0xE4   0xE001             B.N      ??SEGGER_RTT_TerminalOut_13
   2044            } else {
   2045              Status = -1;
   \                     ??SEGGER_RTT_TerminalOut_1: (+1)
   \       0xE6   0xF05F 0x3AFF      MOVS     R10,#+4294967295
   2046            }
   2047            return Status;
   \                     ??SEGGER_RTT_TerminalOut_13: (+1)
   \       0xEA   0x4650             MOV      R0,R10
   \       0xEC   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2048          }
   2049          
   2050          /*********************************************************************
   2051          *
   2052          *       SEGGER_RTT_GetAvailWriteSpace
   2053          *
   2054          *  Function description
   2055          *    Returns the number of bytes available in the ring buffer.
   2056          *
   2057          *  Parameters
   2058          *    BufferIndex  Index of the up buffer.
   2059          *
   2060          *  Return value
   2061          *    Number of bytes that are free in the selected up buffer.
   2062          */

   \                                 In section .text, align 2, keep-with-next
   2063          unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex) {
   \                     SEGGER_RTT_GetAvailWriteSpace: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2064            SEGGER_RTT_BUFFER_UP* pRing;
   2065          
   2066            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0x4   0x....             LDR.N    R1,??DataTable27_1
   \        0x6   0x2018             MOVS     R0,#+24
   \        0x8   0xFB00 0xF004      MUL      R0,R0,R4
   \        0xC   0x4408             ADD      R0,R1,R0
   \        0xE   0xF110 0x0518      ADDS     R5,R0,#+24
   2067            return _GetAvailWriteSpace(pRing);
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       _GetAvailWriteSpace
   \       0x18   0xBD32             POP      {R1,R4,R5,PC}
   2068          }
   2069          
   2070          
   2071          /*********************************************************************
   2072          *
   2073          *       SEGGER_RTT_GetBytesInBuffer()
   2074          *
   2075          *  Function description
   2076          *    Returns the number of bytes currently used in the up buffer.
   2077          *
   2078          *  Parameters
   2079          *    BufferIndex  Index of the up buffer.
   2080          *
   2081          *  Return value
   2082          *    Number of bytes that are used in the buffer.
   2083          */

   \                                 In section .text, align 2, keep-with-next
   2084          unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
   \                     SEGGER_RTT_GetBytesInBuffer: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0001             MOVS     R1,R0
   2085            unsigned RdOff;
   2086            unsigned WrOff;
   2087            unsigned r;
   2088            volatile SEGGER_RTT_CB* pRTTCB;
   2089            //
   2090            // Avoid warnings regarding volatile access order.  It's not a problem
   2091            // in this case, but dampen compiler enthusiasm.
   2092            //
   2093            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0x4   0x....             LDR.N    R2,??DataTable27_1
   2094            RdOff = pRTTCB->aUp[BufferIndex].RdOff;
   \        0x6   0x2018             MOVS     R0,#+24
   \        0x8   0xFB00 0xF301      MUL      R3,R0,R1
   \        0xC   0x4413             ADD      R3,R2,R3
   \        0xE   0x6A9B             LDR      R3,[R3, #+40]
   2095            WrOff = pRTTCB->aUp[BufferIndex].WrOff;
   \       0x10   0xFB00 0xF401      MUL      R4,R0,R1
   \       0x14   0x4414             ADD      R4,R2,R4
   \       0x16   0x6A64             LDR      R4,[R4, #+36]
   2096            if (RdOff <= WrOff) {
   \       0x18   0x429C             CMP      R4,R3
   \       0x1A   0xD301             BCC.N    ??SEGGER_RTT_GetBytesInBuffer_0
   2097              r = WrOff - RdOff;
   \       0x1C   0x1AE0             SUBS     R0,R4,R3
   \       0x1E   0xE005             B.N      ??SEGGER_RTT_GetBytesInBuffer_1
   2098            } else {
   2099              r = pRTTCB->aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
   \                     ??SEGGER_RTT_GetBytesInBuffer_0: (+1)
   \       0x20   0xFB00 0xF001      MUL      R0,R0,R1
   \       0x24   0x4410             ADD      R0,R2,R0
   \       0x26   0x6A00             LDR      R0,[R0, #+32]
   \       0x28   0x1B00             SUBS     R0,R0,R4
   \       0x2A   0x1818             ADDS     R0,R3,R0
   2100            }
   2101            return r;
   \                     ??SEGGER_RTT_GetBytesInBuffer_1: (+1)
   \       0x2C   0xBC10             POP      {R4}
   \       0x2E   0x4770             BX       LR
   2102          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     _SEGGER_RTT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \        0x0   0x....'....        DC32     _acUpBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \        0x0   0x....'....        DC32     _acDownBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     `_DoInit::_aInitStr`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     _aTerminalId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0x....'....        DC32     _SEGGER_RTT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \        0x0   0x....'....        DC32     _ActiveTerminal

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x54 0x65          DC8 "Terminal"
   \              0x72 0x6D    
   \              0x69 0x6E    
   \              0x61 0x6C    
   \              0x00
   \        0x9                      DS8 3
   2103          
   2104          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   SEGGER_RTT_AllocDownBuffer
        32   -> _DoInit
      32   SEGGER_RTT_AllocUpBuffer
        32   -> _DoInit
      40   SEGGER_RTT_ConfigDownBuffer
        40   -> _DoInit
      40   SEGGER_RTT_ConfigUpBuffer
        40   -> _DoInit
      16   SEGGER_RTT_GetAvailWriteSpace
        16   -> _GetAvailWriteSpace
       4   SEGGER_RTT_GetBytesInBuffer
       8   SEGGER_RTT_GetKey
         8   -> SEGGER_RTT_Read
       0   SEGGER_RTT_HasData
       0   SEGGER_RTT_HasDataUp
      16   SEGGER_RTT_HasKey
        16   -> _DoInit
       8   SEGGER_RTT_Init
         8   -> _DoInit
      24   SEGGER_RTT_PutChar
        24   -> _DoInit
      24   SEGGER_RTT_PutCharSkip
        24   -> _DoInit
      12   SEGGER_RTT_PutCharSkipNoLock
      24   SEGGER_RTT_Read
        24   -> SEGGER_RTT_ReadNoLock
      56   SEGGER_RTT_ReadNoLock
        56   -> _DoInit
        56   -> __aeabi_memcpy
      24   SEGGER_RTT_ReadUpBuffer
        24   -> SEGGER_RTT_ReadUpBufferNoLock
      56   SEGGER_RTT_ReadUpBufferNoLock
        56   -> _DoInit
        56   -> __aeabi_memcpy
      24   SEGGER_RTT_SetFlagsDownBuffer
        24   -> _DoInit
      24   SEGGER_RTT_SetFlagsUpBuffer
        24   -> _DoInit
      24   SEGGER_RTT_SetNameDownBuffer
        24   -> _DoInit
      24   SEGGER_RTT_SetNameUpBuffer
        24   -> _DoInit
      32   SEGGER_RTT_SetTerminal
        32   -> _DoInit
        32   -> _GetAvailWriteSpace
        32   -> _WriteBlocking
        32   -> _WriteNoCheck
      32   SEGGER_RTT_TerminalOut
        32   -> _DoInit
        32   -> _GetAvailWriteSpace
        32   -> _PostTerminalSwitch
        32   -> _WriteBlocking
        32   -> strlen
       8   SEGGER_RTT_WaitKey
         8   -> SEGGER_RTT_GetKey
      24   SEGGER_RTT_Write
        24   -> SEGGER_RTT_WriteNoLock
        24   -> _DoInit
      24   SEGGER_RTT_WriteDownBuffer
        24   -> SEGGER_RTT_WriteDownBufferNoLock
        24   -> _DoInit
      32   SEGGER_RTT_WriteDownBufferNoLock
        32   -> _GetAvailWriteSpace
        32   -> _WriteBlocking
        32   -> _WriteNoCheck
      32   SEGGER_RTT_WriteNoLock
        32   -> _GetAvailWriteSpace
        32   -> _WriteBlocking
        32   -> _WriteNoCheck
      56   SEGGER_RTT_WriteSkipNoLock
        56   -> __aeabi_memcpy
      16   SEGGER_RTT_WriteString
        16   -> SEGGER_RTT_Write
        16   -> strlen
      48   SEGGER_RTT_WriteWithOverwriteNoLock
        48   -> __aeabi_memcpy
      24   _DoInit
        24   -> __aeabi_memset
       0   _GetAvailWriteSpace
      16   _PostTerminalSwitch
        16   -> _WriteBlocking
      48   _WriteBlocking
        48   -> __aeabi_memcpy
      56   _WriteNoCheck
        56   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable26
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
      12  ?_0
     150  SEGGER_RTT_AllocDownBuffer
     150  SEGGER_RTT_AllocUpBuffer
     108  SEGGER_RTT_ConfigDownBuffer
     108  SEGGER_RTT_ConfigUpBuffer
      26  SEGGER_RTT_GetAvailWriteSpace
      48  SEGGER_RTT_GetBytesInBuffer
      30  SEGGER_RTT_GetKey
      26  SEGGER_RTT_HasData
      26  SEGGER_RTT_HasDataUp
      38  SEGGER_RTT_HasKey
       8  SEGGER_RTT_Init
     106  SEGGER_RTT_PutChar
      94  SEGGER_RTT_PutCharSkip
      62  SEGGER_RTT_PutCharSkipNoLock
      34  SEGGER_RTT_Read
     188  SEGGER_RTT_ReadNoLock
      34  SEGGER_RTT_ReadUpBuffer
     188  SEGGER_RTT_ReadUpBufferNoLock
      68  SEGGER_RTT_SetFlagsDownBuffer
      68  SEGGER_RTT_SetFlagsUpBuffer
      68  SEGGER_RTT_SetNameDownBuffer
      68  SEGGER_RTT_SetNameUpBuffer
     144  SEGGER_RTT_SetTerminal
     240  SEGGER_RTT_TerminalOut
      16  SEGGER_RTT_WaitKey
      48  SEGGER_RTT_Write
      48  SEGGER_RTT_WriteDownBuffer
     130  SEGGER_RTT_WriteDownBufferNoLock
     130  SEGGER_RTT_WriteNoLock
     224  SEGGER_RTT_WriteSkipNoLock
      26  SEGGER_RTT_WriteString
     254  SEGGER_RTT_WriteWithOverwriteNoLock
       1  _ActiveTerminal
     106  _DoInit
      26  _GetAvailWriteSpace
      38  _PostTerminalSwitch
     168  _SEGGER_RTT
     142  _WriteBlocking
     128  _WriteNoCheck
      20  _aInitStr
      16  _aTerminalId
   1'024  _acDownBuffer
   1'024  _acUpBuffer

 
 2'217 bytes in section .bss
    48 bytes in section .rodata
 3'428 bytes in section .text
 
 3'428 bytes of CODE  memory
    48 bytes of CONST memory
 2'217 bytes of DATA  memory

Errors: none
Warnings: none
