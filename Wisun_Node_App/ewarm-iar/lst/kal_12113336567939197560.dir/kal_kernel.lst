###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:28
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\kal\kal_kernel.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\kal_12113336567939197560.dir\kal_kernel.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\kal\kal_kernel.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\kal_12113336567939197560.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\kal_12113336567939197560.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\kal\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\kal_12113336567939197560.dir\kal_kernel.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\kal_12113336567939197560.dir\kal_kernel.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\kal_12113336567939197560.dir\kal_kernel.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\kal\kal_kernel.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Common - Kernel Abstraction Layer (Kal) - Micrium Os Kernel
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                       DEPENDENCIES & AVAIL CHECK(S)
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <rtos_description.h>
     25          
     26          #if defined(RTOS_MODULE_KERNEL_AVAIL)
     27          
     28          /********************************************************************************************************
     29           ********************************************************************************************************
     30           *                                               INCLUDE FILES
     31           ********************************************************************************************************
     32           *******************************************************************************************************/
     33          
     34          #include  <common/include/lib_def.h>
     35          #include  <common/include/kal.h>
     36          #include  <common/include/rtos_opt_def.h>
     37          #include  <common/include/rtos_path.h>
     38          #include  <rtos_cfg.h>
     39          #include  <rtos_description.h>
     40          
     41          #include  <os_cfg.h>
     42          #ifdef  OS_CFG_COMPAT_INIT
     43          #include  <os_cfg_app.h>
     44          #endif
     45          
     46          #include  <common/source/rtos/rtos_utils_priv.h>
     47          #include  <common/source/kal/kal_priv.h>
     48          #include  <common/include/lib_math.h>
     49          #include  <common/include/lib_mem.h>
     50          #include  <common/include/toolchains.h>
     51          
     52          #include  <cpu/include/cpu.h>
     53          
     54          #if (defined(RTOS_MODULE_KERNEL_OS3_AVAIL))
     55          #include  <os.h>
     56          #elif (defined(RTOS_MODULE_KERNEL_AVAIL))
     57          #include  <kernel/include/os.h>
     58          #endif
     59          
     60          #include  <common/source/common/common_priv.h>
     61          #include  <common/source/rtos/rtos_utils_priv.h>
     62          
     63          /********************************************************************************************************
     64           ********************************************************************************************************
     65           *                                               LOCAL DEFINES
     66           ********************************************************************************************************
     67           *******************************************************************************************************/
     68          
     69          #define  KAL_CFG_TASK_STK_SIZE_PCT_FULL    90u
     70          
     71          #define  KAL_INIT_STATUS_NONE               0u
     72          #define  KAL_INIT_STATUS_OK                 1u
     73          #define  KAL_INIT_STATUS_FAIL               2u
     74          
     75          #define  LOG_DFLT_CH                       (COMMON, KAL)
     76          #define  RTOS_MODULE_CUR                    RTOS_CFG_MODULE_COMMON
     77          
     78          /********************************************************************************************************
     79           ********************************************************************************************************
     80           *                                               LOCAL CONSTANTS
     81           ********************************************************************************************************
     82           *******************************************************************************************************/
     83          

   \                                 In section .rodata, align 4
     84          KAL_CPP_EXT const KAL_TASK_HANDLE     KAL_TaskHandleNull = KAL_OBJ_HANDLE_NULL;
   \                     KAL_TaskHandleNull:
   \        0x0   0x0000'0000        DC32 0x0

   \                                 In section .rodata, align 4
     85          KAL_CPP_EXT const KAL_LOCK_HANDLE     KAL_LockHandleNull = KAL_OBJ_HANDLE_NULL;
   \                     KAL_LockHandleNull:
   \        0x0   0x0000'0000        DC32 0x0

   \                                 In section .rodata, align 4
     86          KAL_CPP_EXT const KAL_SEM_HANDLE      KAL_SemHandleNull = KAL_OBJ_HANDLE_NULL;
   \                     KAL_SemHandleNull:
   \        0x0   0x0000'0000        DC32 0x0

   \                                 In section .rodata, align 4
     87          KAL_CPP_EXT const KAL_TMR_HANDLE      KAL_TmrHandleNull = KAL_OBJ_HANDLE_NULL;
   \                     KAL_TmrHandleNull:
   \        0x0   0x0000'0000        DC32 0x0

   \                                 In section .rodata, align 4
     88          KAL_CPP_EXT const KAL_Q_HANDLE        KAL_QHandleNull = KAL_OBJ_HANDLE_NULL;
   \                     KAL_QHandleNull:
   \        0x0   0x0000'0000        DC32 0x0

   \                                 In section .rodata, align 4
     89          KAL_CPP_EXT const KAL_MON_HANDLE      KAL_MonHandleNull = KAL_OBJ_HANDLE_NULL;
   \                     KAL_MonHandleNull:
   \        0x0   0x0000'0000        DC32 0x0

   \                                 In section .rodata, align 4
     90          KAL_CPP_EXT const KAL_TASK_REG_HANDLE KAL_TaskRegHandleNull = KAL_OBJ_HANDLE_NULL;
   \                     KAL_TaskRegHandleNull:
   \        0x0   0x0000'0000        DC32 0x0
     91          
     92          /********************************************************************************************************
     93           ********************************************************************************************************
     94           *                                           LOCAL DATA TYPES
     95           ********************************************************************************************************
     96           *******************************************************************************************************/
     97          
     98          //                                                                 ------------------ KAL TASK TYPE -------------------
     99          typedef struct kal_task {
    100            OS_TCB         TCB;                                           // TCB for OS-III.
    101          
    102            CPU_STK        *StkBasePtr;                                   // Task stack base ptr.
    103            CPU_INT32U     StkSizeElements;                               // Task stack size (in CPU_STK elements).
    104          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    105            const CPU_CHAR *NamePtr;                                      // Task name string.
    106          #endif
    107          } KAL_TASK;
    108          
    109          //                                                                 ------------------- KAL LOCK TYPE ------------------
    110          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    111          typedef struct kal_lock {
    112            OS_MUTEX   Mutex;                                             // OS-III mutex obj.
    113            CPU_INT08U OptFlags;                                          // Opt flags associated with this lock.
    114          } KAL_LOCK;
    115          #endif
    116          
    117          //                                                                 ------------------- KAL MON TYPE -------------------
    118          #if (OS_CFG_MON_EN == DEF_ENABLED)
    119          typedef struct kal_mon_arg_wrapper {
    120            void *DataPtr;                                                // Ptr to arg passed when calling KAL_MonOp().
    121          
    122            //                                                               Callback fnct called when entering KAL_MonOp().
    123            KAL_MON_RES (*EnterFnct)(void *p_mon_data, void *p_op_data);
    124            //                                                               Callback fnct called when evaluating monitor.
    125            KAL_MON_RES (*EvalFnct)(void *p_mon_data, void *p_eval_op_data, void *p_scan_op_data);
    126          } KAL_MON_DATA_WRAPPER;
    127          #endif
    128          
    129          //                                                                 ------------------- KAL TMR TYPE -------------------
    130          #if (OS_CFG_TMR_EN == DEF_ENABLED)
    131          typedef struct kal_tmr {
    132            OS_TMR Tmr;                                                   // OS-III tmr obj.
    133          
    134            void (*CallbackFnct)(void *p_arg);                            // Tmr registered callback fnct.
    135            void   *CallbackArg;                                          // Arg to pass to callback fnct.
    136          } KAL_TMR;
    137          #endif
    138          
    139          //                                                                 ---------------- KAL TASK REG TYPE -----------------
    140          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    141          typedef struct kal_task_reg_data {
    142            OS_REG_ID Id;                                                 // Id of the task reg.
    143          } KAL_TASK_REG_DATA;
    144          #endif
    145          
    146          //                                                                 -------------- KAL INTERNAL DATA TYPE --------------
    147          typedef struct kal_data {
    148          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    149            MEM_DYN_POOL MutexPool;                                       // Dyn mem pool used to alloc mutex.
    150          #endif
    151          
    152          #if (OS_CFG_SEM_EN == DEF_ENABLED)
    153            MEM_DYN_POOL SemPool;                                         // Dyn mem pool used to alloc sems.
    154          #endif
    155          
    156          #if (OS_CFG_MON_EN == DEF_ENABLED)
    157            MEM_DYN_POOL MonPool;                                         // Dyn mem pool used to alloc mons.
    158          #endif
    159          
    160          #if (OS_CFG_TMR_EN == DEF_ENABLED)
    161            MEM_DYN_POOL TmrPool;                                         // Dyn mem pool used to alloc tmrs.
    162          #endif
    163          
    164          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    165            MEM_DYN_POOL TaskRegPool;                                     // Dyn mem pool used to alloc task regs.
    166          #endif
    167          } KAL_DATA;
    168          
    169          /********************************************************************************************************
    170           ********************************************************************************************************
    171           *                                       LOCAL GLOBAL VARIABLES
    172           ********************************************************************************************************
    173           *******************************************************************************************************/
    174          

   \                                 In section .bss, align 4
    175          static KAL_DATA *KAL_DataPtr = DEF_NULL;
   \                     KAL_DataPtr:
   \        0x0                      DS8 4
    176          
    177          /********************************************************************************************************
    178           ********************************************************************************************************
    179           *                                       LOCAL FUNCTION PROTOTYPES
    180           ********************************************************************************************************
    181           *******************************************************************************************************/
    182          
    183          static void KAL_Init(RTOS_ERR *p_err);
    184          
    185          #if (OS_CFG_TMR_EN == DEF_ENABLED)
    186          static void KAL_TmrFnctWrapper(void *p_tmr_os,
    187                                         void *p_arg);
    188          #endif
    189          
    190          #if (OS_CFG_MON_EN == DEF_ENABLED)
    191          static OS_MON_RES KAL_MonEnterFnct(OS_MON *p_mon,
    192                                             void   *p_op_data);
    193          
    194          static OS_MON_RES KAL_MonEvalFnct(OS_MON *p_mon,
    195                                            void   *p_eval_op_data,
    196                                            void   *p_scan_op_data);
    197          #endif
    198          
    199          static KAL_TICK KAL_msToTicks(CPU_INT32U ms);
    200          
    201          /********************************************************************************************************
    202           ********************************************************************************************************
    203           *                                           GLOBAL FUNCTIONS
    204           ********************************************************************************************************
    205           *******************************************************************************************************/
    206          
    207          /********************************************************************************************************
    208           *                                       KAL CORE API FUNCTIONS
    209           *******************************************************************************************************/
    210          
    211          /****************************************************************************************************//**
    212           *                                           KAL_FeatureQuery()
    213           *
    214           * @brief    Check if specified feature is available.
    215           *
    216           * @param    feature     Feature to query.
    217           *
    218           * @param    opt         Option associated with the feature requested.
    219           *
    220           * @return   DEF_YES, if feature is available.
    221           *           DEF_NO, otherwise.
    222           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    223          CPU_BOOLEAN KAL_FeatureQuery(KAL_FEATURE feature,
    224                                       KAL_OPT     opt)
    225          {
   \                     KAL_FeatureQuery: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    226            CPU_BOOLEAN is_en;
    227          
    228            PP_UNUSED_PARAM(opt);
    229          
    230            is_en = DEF_NO;
   \        0x2   0x2000             MOVS     R0,#+0
    231          
    232            switch (feature) {
   \        0x4   0x0013             MOVS     R3,R2
   \        0x6   0xB2DB             UXTB     R3,R3
   \        0x8   0x2B00             CMP      R3,#+0
   \        0xA   0xD021             BEQ.N    ??KAL_FeatureQuery_0
   \        0xC   0x2B02             CMP      R3,#+2
   \        0xE   0xD025             BEQ.N    ??KAL_FeatureQuery_1
   \       0x10   0xD321             BCC.N    ??KAL_FeatureQuery_2
   \       0x12   0x2B04             CMP      R3,#+4
   \       0x14   0xD022             BEQ.N    ??KAL_FeatureQuery_1
   \       0x16   0xD321             BCC.N    ??KAL_FeatureQuery_1
   \       0x18   0x2B06             CMP      R3,#+6
   \       0x1A   0xD025             BEQ.N    ??KAL_FeatureQuery_3
   \       0x1C   0xD321             BCC.N    ??KAL_FeatureQuery_4
   \       0x1E   0x2B08             CMP      R3,#+8
   \       0x20   0xD022             BEQ.N    ??KAL_FeatureQuery_3
   \       0x22   0xD321             BCC.N    ??KAL_FeatureQuery_3
   \       0x24   0x2B0A             CMP      R3,#+10
   \       0x26   0xD025             BEQ.N    ??KAL_FeatureQuery_5
   \       0x28   0xD321             BCC.N    ??KAL_FeatureQuery_6
   \       0x2A   0x2B0C             CMP      R3,#+12
   \       0x2C   0xD028             BEQ.N    ??KAL_FeatureQuery_7
   \       0x2E   0xD324             BCC.N    ??KAL_FeatureQuery_8
   \       0x30   0x2B0E             CMP      R3,#+14
   \       0x32   0xD026             BEQ.N    ??KAL_FeatureQuery_9
   \       0x34   0xD325             BCC.N    ??KAL_FeatureQuery_9
   \       0x36   0x2B10             CMP      R3,#+16
   \       0x38   0xD02C             BEQ.N    ??KAL_FeatureQuery_10
   \       0x3A   0xD322             BCC.N    ??KAL_FeatureQuery_9
   \       0x3C   0x2B12             CMP      R3,#+18
   \       0x3E   0xD02F             BEQ.N    ??KAL_FeatureQuery_11
   \       0x40   0xD32B             BCC.N    ??KAL_FeatureQuery_12
   \       0x42   0x2B14             CMP      R3,#+20
   \       0x44   0xD020             BEQ.N    ??KAL_FeatureQuery_13
   \       0x46   0xD32E             BCC.N    ??KAL_FeatureQuery_14
   \       0x48   0x2B16             CMP      R3,#+22
   \       0x4A   0xD02F             BEQ.N    ??KAL_FeatureQuery_15
   \       0x4C   0xD31F             BCC.N    ??KAL_FeatureQuery_16
   \       0x4E   0xE02E             B.N      ??KAL_FeatureQuery_17
    233              case KAL_FEATURE_TASK_CREATE:                               // ---------------------- TASKS -----------------------
    234                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_0: (+1)
   \       0x50   0x2301             MOVS     R3,#+1
   \       0x52   0x0018             MOVS     R0,R3
    235                break;
   \       0x54   0xE02B             B.N      ??KAL_FeatureQuery_18
    236          
    237              case KAL_FEATURE_TASK_DEL:
    238                       #if ((OS_CFG_TASK_DEL_EN == DEF_ENABLED) \
    239                && !defined(OS_SAFETY_CRITICAL_IEC61508))
    240          
    241                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_2: (+1)
   \       0x56   0x2301             MOVS     R3,#+1
   \       0x58   0x0018             MOVS     R0,R3
    242                       #endif
    243                break;
   \       0x5A   0xE028             B.N      ??KAL_FeatureQuery_18
    244          
    245          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)                            // ----------------------- LOCKS ----------------------
    246              case KAL_FEATURE_LOCK_CREATE:
    247              case KAL_FEATURE_LOCK_ACQUIRE:
    248              case KAL_FEATURE_LOCK_RELEASE:
    249                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_1: (+1)
   \       0x5C   0x2301             MOVS     R3,#+1
   \       0x5E   0x0018             MOVS     R0,R3
    250                break;
   \       0x60   0xE025             B.N      ??KAL_FeatureQuery_18
    251          
    252              case KAL_FEATURE_LOCK_DEL:
    253                       #if (!defined(OS_SAFETY_CRITICAL_IEC61508))
    254                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_4: (+1)
   \       0x62   0x2301             MOVS     R3,#+1
   \       0x64   0x0018             MOVS     R0,R3
    255                       #endif
    256                break;
   \       0x66   0xE022             B.N      ??KAL_FeatureQuery_18
    257          #endif // OS_CFG_MUTEX_EN
    258          
    259          #if (OS_CFG_SEM_EN == DEF_ENABLED)                              // ----------------------- SEMS -----------------------
    260              case KAL_FEATURE_SEM_CREATE:
    261              case KAL_FEATURE_SEM_PEND:
    262              case KAL_FEATURE_SEM_POST:
    263                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_3: (+1)
   \       0x68   0x2301             MOVS     R3,#+1
   \       0x6A   0x0018             MOVS     R0,R3
    264                break;
   \       0x6C   0xE01F             B.N      ??KAL_FeatureQuery_18
    265          
    266              case KAL_FEATURE_SEM_ABORT:
    267                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_6: (+1)
   \       0x6E   0x2301             MOVS     R3,#+1
   \       0x70   0x0018             MOVS     R0,R3
    268                break;
   \       0x72   0xE01C             B.N      ??KAL_FeatureQuery_18
    269          
    270              case KAL_FEATURE_SEM_SET:
    271                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_5: (+1)
   \       0x74   0x2301             MOVS     R3,#+1
   \       0x76   0x0018             MOVS     R0,R3
    272                break;
   \       0x78   0xE019             B.N      ??KAL_FeatureQuery_18
    273          
    274              case KAL_FEATURE_SEM_DEL:
    275                       #if (!defined(OS_SAFETY_CRITICAL_IEC61508))
    276                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_8: (+1)
   \       0x7A   0x2301             MOVS     R3,#+1
   \       0x7C   0x0018             MOVS     R0,R3
    277                       #endif
    278                break;
   \       0x7E   0xE016             B.N      ??KAL_FeatureQuery_18
    279          #endif // OS_CFG_SEM_EN
    280          
    281              case KAL_FEATURE_TMR:                                       // ----------------------- TMRS -----------------------
    282                       #if (OS_CFG_TMR_EN == DEF_ENABLED)
    283                is_en = DEF_YES;
    284                       #endif
    285                break;
   \                     ??KAL_FeatureQuery_7: (+1)
   \       0x80   0xE015             B.N      ??KAL_FeatureQuery_18
    286          
    287              case KAL_FEATURE_Q_CREATE:                                  // ---------------------- QUEUES ----------------------
    288              case KAL_FEATURE_Q_PEND:
    289              case KAL_FEATURE_Q_POST:
    290                       #if (OS_CFG_Q_EN == DEF_ENABLED)
    291                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_9: (+1)
   \       0x82   0x2301             MOVS     R3,#+1
   \       0x84   0x0018             MOVS     R0,R3
    292                       #endif
    293                break;
   \       0x86   0xE012             B.N      ??KAL_FeatureQuery_18
    294          
    295          #if (OS_CFG_MON_EN == DEF_ENABLED)                              // ---------------------- MONITORS ---------------------
    296              case KAL_FEATURE_MON:
    297                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_13: (+1)
   \       0x88   0x2301             MOVS     R3,#+1
   \       0x8A   0x0018             MOVS     R0,R3
    298                break;
   \       0x8C   0xE00F             B.N      ??KAL_FeatureQuery_18
    299          
    300              case KAL_FEATURE_MON_DEL:
    301                       #if (!defined(OS_SAFETY_CRITICAL_IEC61508))
    302                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_16: (+1)
   \       0x8E   0x2301             MOVS     R3,#+1
   \       0x90   0x0018             MOVS     R0,R3
    303                       #endif
    304                break;
   \       0x92   0xE00C             B.N      ??KAL_FeatureQuery_18
    305          #endif
    306          
    307              case KAL_FEATURE_DLY:                                       // ----------------------- DLYS -----------------------
    308                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_10: (+1)
   \       0x94   0x2301             MOVS     R3,#+1
   \       0x96   0x0018             MOVS     R0,R3
    309                break;
   \       0x98   0xE009             B.N      ??KAL_FeatureQuery_18
    310          
    311              case KAL_FEATURE_PEND_TIMEOUT:                              // ------------------- PEND TIMEOUT -------------------
    312                       #if (OS_CFG_TICK_EN == DEF_ENABLED)
    313                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_12: (+1)
   \       0x9A   0x2301             MOVS     R3,#+1
   \       0x9C   0x0018             MOVS     R0,R3
    314                       #endif
    315                break;
   \       0x9E   0xE006             B.N      ??KAL_FeatureQuery_18
    316          
    317              case KAL_FEATURE_TICK_GET:                                  // ------------------- TICK CTR INFO ------------------
    318                       #if (OS_CFG_TICK_EN == DEF_ENABLED)
    319                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_11: (+1)
   \       0xA0   0x2301             MOVS     R3,#+1
   \       0xA2   0x0018             MOVS     R0,R3
    320                       #endif
    321                break;
   \       0xA4   0xE003             B.N      ??KAL_FeatureQuery_18
    322          
    323              case KAL_FEATURE_TASK_REG:                                  // ------------------- TASK STORAGE -------------------
    324                       #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    325                is_en = DEF_YES;
   \                     ??KAL_FeatureQuery_14: (+1)
   \       0xA6   0x2301             MOVS     R3,#+1
   \       0xA8   0x0018             MOVS     R0,R3
    326                       #endif
    327                break;
   \       0xAA   0xE000             B.N      ??KAL_FeatureQuery_18
    328          
    329              case KAL_FEATURE_CPU_USAGE_GET:                             // ------------------ CPU USAGE INFO ------------------
    330                       #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) \
    331                && (OS_CFG_DBG_EN == DEF_ENABLED)                   \
    332                && (OS_CFG_STAT_TASK_EN == DEF_ENABLED))
    333                is_en = DEF_YES;
    334                       #endif
    335                break;
   \                     ??KAL_FeatureQuery_15: (+1)
   \       0xAC   0xE7FF             B.N      ??KAL_FeatureQuery_18
    336          
    337              default:
    338                break;
    339            }
    340          
    341            return (is_en);
   \                     ??KAL_FeatureQuery_17: (+1)
   \                     ??KAL_FeatureQuery_18: (+1)
   \       0xAE   0xB2C0             UXTB     R0,R0
   \       0xB0   0x4770             BX       LR
    342          }
    343          
    344          /********************************************************************************************************
    345           *                                           TASK API FUNCTIONS
    346           *******************************************************************************************************/
    347          
    348          /****************************************************************************************************//**
    349           *                                               KAL_TaskAlloc()
    350           *
    351           * @brief    Allocate a task object and its stack.
    352           *
    353           * @param    p_name      Pointer to name of the task.
    354           *
    355           * @param    p_stk_base  Pointer to start of task stack. If NULL, the stack will be allocated from
    356           *                       the KAL memory segment.
    357           *
    358           * @param    stk_size    Size (in CPU_STK elements) of the task stack.
    359           *
    360           * @param    p_cfg       Pointer to KAL task configuration structure.
    361           *
    362           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
    363           *                       from this function:
    364           *                           - RTOS_ERR_NONE
    365           *                           - RTOS_ERR_SEG_OVF
    366           *
    367           * @return   Allocated task's handle.
    368           *
    369           * @note     (1) This function will initialize KAL if KAL has not yet been initialized.
    370           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          KAL_TASK_HANDLE KAL_TaskAlloc(const CPU_CHAR   *p_name,
    372                                        CPU_STK          *p_stk_base,
    373                                        CPU_STK_SIZE     stk_size,
    374                                        KAL_TASK_EXT_CFG *p_cfg,
    375                                        RTOS_ERR         *p_err)
    376          {
   \                     KAL_TaskAlloc: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x4693             MOV      R11,R2
   \        0xA   0x001D             MOVS     R5,R3
   \        0xC   0x9E0E             LDR      R6,[SP, #+56]
    377            KAL_TASK_HANDLE handle = KAL_TaskHandleNull;
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable23
   \       0x12   0xF8D0 0x9000      LDR      R9,[R0, #+0]
    378            KAL_TASK        *p_task;
    379            CPU_ADDR        stk_addr;
    380            CPU_ADDR        stk_addr_aligned;
    381            CPU_SIZE_T      actual_stk_size;
    382            MEM_SEG         *p_mem_seg;
    383          
    384            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, handle);
   \       0x16   0x2E00             CMP      R6,#+0
   \       0x18   0xD101             BNE.N    ??KAL_TaskAlloc_0
   \       0x1A   0x.... 0x....      BL       CPU_SW_Exception
    385          
    386            RTOS_ASSERT_DBG_ERR_SET((stk_size >= OS_CFG_STK_SIZE_MIN), *p_err, RTOS_ERR_INVALID_ARG, handle);
   \                     ??KAL_TaskAlloc_0: (+1)
   \       0x1E   0xF1BB 0x0F40      CMP      R11,#+64
   \       0x22   0xD20B             BCS.N    ??KAL_TaskAlloc_1
   \       0x24   0x2008             MOVS     R0,#+8
   \       0x26   0x7030             STRB     R0,[R6, #+0]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x2C   0x6070             STR      R0,[R6, #+4]
   \       0x2E   0xF44F 0x70C1      MOV      R0,#+386
   \       0x32   0x60B0             STR      R0,[R6, #+8]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \       0x38   0x60F0             STR      R0,[R6, #+12]
   \                     ??KAL_TaskAlloc_2: (+1)
   \       0x3A   0xE7FE             B.N      ??KAL_TaskAlloc_2
    387          
    388            //                                                               Make sure no unsupported cfg recv.
    389            RTOS_ASSERT_DBG_ERR_SET((p_cfg == DEF_NULL), *p_err, RTOS_ERR_NOT_SUPPORTED, handle);
   \                     ??KAL_TaskAlloc_1: (+1)
   \       0x3C   0x2D00             CMP      R5,#+0
   \       0x3E   0xD00B             BEQ.N    ??KAL_TaskAlloc_3
   \       0x40   0x2007             MOVS     R0,#+7
   \       0x42   0x7030             STRB     R0,[R6, #+0]
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x48   0x6070             STR      R0,[R6, #+4]
   \       0x4A   0xF240 0x1085      MOVW     R0,#+389
   \       0x4E   0x60B0             STR      R0,[R6, #+8]
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \       0x54   0x60F0             STR      R0,[R6, #+12]
   \                     ??KAL_TaskAlloc_4: (+1)
   \       0x56   0xE7FE             B.N      ??KAL_TaskAlloc_4
    390          
    391            if (KAL_DataPtr == DEF_NULL) {
   \                     ??KAL_TaskAlloc_3: (+1)
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \       0x5C   0x6800             LDR      R0,[R0, #+0]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD107             BNE.N    ??KAL_TaskAlloc_5
    392              KAL_Init(p_err);                                            // KAL initialization (see Note #1).
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0x.... 0x....      BL       KAL_Init
    393              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x68   0x7830             LDRB     R0,[R6, #+0]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD001             BEQ.N    ??KAL_TaskAlloc_5
    394                return (handle);
   \       0x6E   0x4648             MOV      R0,R9
   \       0x70   0xE040             B.N      ??KAL_TaskAlloc_6
    395              }
    396            }
    397          
    398            p_mem_seg = Common_MemSegPtrGet();
   \                     ??KAL_TaskAlloc_5: (+1)
   \       0x72   0x.... 0x....      BL       Common_MemSegPtrGet
   \       0x76   0x0007             MOVS     R7,R0
    399          
    400            if (p_stk_base == DEF_NULL) {                                 // Must alloc task stk on mem seg.
   \       0x78   0x2C00             CMP      R4,#+0
   \       0x7A   0xD112             BNE.N    ??KAL_TaskAlloc_7
    401              stk_addr_aligned = (CPU_ADDR)Mem_SegAllocExt("KAL task stk",
    402                                                           p_mem_seg,
    403                                                           (stk_size * sizeof(CPU_STK)),
    404                                                           CPU_CFG_STK_ALIGN_BYTES,
    405                                                           DEF_NULL,
    406                                                           p_err);
   \       0x7C   0x9601             STR      R6,[SP, #+4]
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x9000             STR      R0,[SP, #+0]
   \       0x82   0x2308             MOVS     R3,#+8
   \       0x84   0xEA5F 0x028B      LSLS     R2,R11,#+2
   \       0x88   0x0039             MOVS     R1,R7
   \       0x8A   0x.... 0x....      LDR.W    R0,??DataTable23_4
   \       0x8E   0x.... 0x....      BL       Mem_SegAllocExt
   \       0x92   0x4680             MOV      R8,R0
    407              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x94   0x7830             LDRB     R0,[R6, #+0]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD001             BEQ.N    ??KAL_TaskAlloc_8
    408                LOG_DBG(("KAL_TaskAlloc failed to allocate task stack."));
    409                return (handle);
   \       0x9A   0x4648             MOV      R0,R9
   \       0x9C   0xE02A             B.N      ??KAL_TaskAlloc_6
    410              }
    411              actual_stk_size = stk_size;
   \                     ??KAL_TaskAlloc_8: (+1)
   \       0x9E   0x46DA             MOV      R10,R11
   \       0xA0   0xE016             B.N      ??KAL_TaskAlloc_9
    412            } else {
    413              //                                                             Align stk ptr, if needed.
    414              stk_addr = (CPU_ADDR)p_stk_base;
   \                     ??KAL_TaskAlloc_7: (+1)
   \       0xA2   0x9402             STR      R4,[SP, #+8]
    415              stk_addr_aligned = MATH_ROUND_INC_UP_PWR2(stk_addr, CPU_CFG_STK_ALIGN_BYTES);
   \       0xA4   0x9802             LDR      R0,[SP, #+8]
   \       0xA6   0xF010 0x0F07      TST      R0,#0x7
   \       0xAA   0xD102             BNE.N    ??KAL_TaskAlloc_10
   \       0xAC   0xF05F 0x0800      MOVS     R8,#+0
   \       0xB0   0xE001             B.N      ??KAL_TaskAlloc_11
   \                     ??KAL_TaskAlloc_10: (+1)
   \       0xB2   0xF05F 0x0808      MOVS     R8,#+8
   \                     ??KAL_TaskAlloc_11: (+1)
   \       0xB6   0x9802             LDR      R0,[SP, #+8]
   \       0xB8   0x08C0             LSRS     R0,R0,#+3
   \       0xBA   0x00C0             LSLS     R0,R0,#+3
   \       0xBC   0xEB18 0x0800      ADDS     R8,R8,R0
    416              actual_stk_size = (((stk_size * sizeof(CPU_STK)) - (stk_addr_aligned - stk_addr)) / sizeof(CPU_STK));
   \       0xC0   0xEBD8 0x008B      RSBS     R0,R8,R11, LSL #+2
   \       0xC4   0xF8DD 0xA008      LDR      R10,[SP, #+8]
   \       0xC8   0xEB1A 0x0A00      ADDS     R10,R10,R0
   \       0xCC   0xEA5F 0x0A9A      LSRS     R10,R10,#+2
    417            }
    418          
    419            p_task = (KAL_TASK *)Mem_SegAlloc("KAL task",
    420                                              p_mem_seg,
    421                                              sizeof(KAL_TASK),
    422                                              p_err);
   \                     ??KAL_TaskAlloc_9: (+1)
   \       0xD0   0x0033             MOVS     R3,R6
   \       0xD2   0x22A4             MOVS     R2,#+164
   \       0xD4   0x0039             MOVS     R1,R7
   \       0xD6   0x.... 0x....      LDR.W    R0,??DataTable26
   \       0xDA   0x.... 0x....      BL       Mem_SegAlloc
   \       0xDE   0x0001             MOVS     R1,R0
    423            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0xE0   0x7830             LDRB     R0,[R6, #+0]
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD001             BEQ.N    ??KAL_TaskAlloc_12
    424              LOG_DBG(("KAL_TaskAlloc failed to allocate KAL_TASK data object."));
    425              return (handle);
   \       0xE6   0x4648             MOV      R0,R9
   \       0xE8   0xE004             B.N      ??KAL_TaskAlloc_6
    426            }
    427          
    428            p_task->StkBasePtr = (CPU_STK *)stk_addr_aligned;
   \                     ??KAL_TaskAlloc_12: (+1)
   \       0xEA   0xF8C1 0x809C      STR      R8,[R1, #+156]
    429            p_task->StkSizeElements = actual_stk_size;
   \       0xEE   0xF8C1 0xA0A0      STR      R10,[R1, #+160]
    430          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    431            p_task->NamePtr = p_name;
    432          #else
    433            PP_UNUSED_PARAM(p_name);
    434          #endif
    435            handle.TaskObjPtr = (void *)p_task;
   \       0xF2   0x0008             MOVS     R0,R1
    436          
    437            LOG_VRB(("KAL_TaskAlloc call successful."));
    438          
    439            return (handle);
   \                     ??KAL_TaskAlloc_6: (+1)
   \       0xF4   0xB005             ADD      SP,SP,#+20
   \       0xF6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    440          }
    441          
    442          /****************************************************************************************************//**
    443           *                                               KAL_TaskCreate()
    444           *
    445           * @brief    Create and start a task.
    446           *
    447           * @param    task_handle     Handle of the task to create.
    448           *
    449           * @param    p_fnct          Pointer to task function.
    450           *
    451           * @param    p_task_arg      Pointer to argument that will be passed to task function (can be DEF_NULL).
    452           *
    453           * @param    prio            Task priority.
    454           *
    455           * @param    p_cfg           Pointer to KAL task configuration structure.
    456           *
    457           * @param    p_err           Pointer to the variable that will receive one of the following error
    458           *                           code(s) from this function:
    459           *                               - RTOS_ERR_NONE
    460           *                               - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    461           *
    462           * @note     (1) The task must be allocated prior to this call using KAL_TaskAlloc().
    463           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    464          void KAL_TaskCreate(KAL_TASK_HANDLE  task_handle,
    465                              void (*p_fnct)(void *p_arg),
    466                              void             *p_task_arg,
    467                              KAL_TASK_PRIO    prio,
    468                              KAL_TASK_EXT_CFG *p_cfg,
    469                              RTOS_ERR         *p_err)
    470          {
   \                     KAL_TaskCreate: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0x9C12             LDR      R4,[SP, #+72]
   \       0x10   0x9D13             LDR      R5,[SP, #+76]
    471            KAL_TASK     *p_task;
    472            CPU_STK_SIZE stk_limit;
    473          
    474            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??KAL_TaskCreate_0
   \       0x16   0x.... 0x....      BL       CPU_SW_Exception
    475          
    476            RTOS_ASSERT_DBG_ERR_SET((p_fnct != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_TaskCreate_0: (+1)
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD10B             BNE.N    ??KAL_TaskCreate_1
   \       0x20   0x200A             MOVS     R0,#+10
   \       0x22   0x7028             STRB     R0,[R5, #+0]
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x28   0x6068             STR      R0,[R5, #+4]
   \       0x2A   0xF44F 0x70EE      MOV      R0,#+476
   \       0x2E   0x60A8             STR      R0,[R5, #+8]
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x34   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_TaskCreate_2: (+1)
   \       0x36   0xE7FE             B.N      ??KAL_TaskCreate_2
    477          
    478            RTOS_ASSERT_DBG_ERR_SET((KAL_TASK_HANDLE_IS_NULL(task_handle) != DEF_YES), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_TaskCreate_1: (+1)
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable23
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0x4582             CMP      R10,R0
   \       0x40   0xD10B             BNE.N    ??KAL_TaskCreate_3
   \       0x42   0x200A             MOVS     R0,#+10
   \       0x44   0x7028             STRB     R0,[R5, #+0]
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x4A   0x6068             STR      R0,[R5, #+4]
   \       0x4C   0xF44F 0x70EF      MOV      R0,#+478
   \       0x50   0x60A8             STR      R0,[R5, #+8]
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x56   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_TaskCreate_4: (+1)
   \       0x58   0xE7FE             B.N      ??KAL_TaskCreate_4
    479          
    480            //                                                               Make sure no unsupported cfg recv.
    481            RTOS_ASSERT_DBG_ERR_SET((p_cfg == DEF_NULL), *p_err, RTOS_ERR_NOT_SUPPORTED,; );
   \                     ??KAL_TaskCreate_3: (+1)
   \       0x5A   0x2C00             CMP      R4,#+0
   \       0x5C   0xD00B             BEQ.N    ??KAL_TaskCreate_5
   \       0x5E   0x2007             MOVS     R0,#+7
   \       0x60   0x7028             STRB     R0,[R5, #+0]
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x66   0x6068             STR      R0,[R5, #+4]
   \       0x68   0xF240 0x10E1      MOVW     R0,#+481
   \       0x6C   0x60A8             STR      R0,[R5, #+8]
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \       0x72   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_TaskCreate_6: (+1)
   \       0x74   0xE7FE             B.N      ??KAL_TaskCreate_6
    482          
    483            p_task = (KAL_TASK *)task_handle.TaskObjPtr;
   \                     ??KAL_TaskCreate_5: (+1)
   \       0x76   0x46D3             MOV      R11,R10
    484            stk_limit = (p_task->StkSizeElements * (100u - KAL_CFG_TASK_STK_SIZE_PCT_FULL)) / 100u;
   \       0x78   0xF8DB 0x10A0      LDR      R1,[R11, #+160]
   \       0x7C   0x200A             MOVS     R0,#+10
   \       0x7E   0x4341             MULS     R1,R0,R1
   \       0x80   0x2064             MOVS     R0,#+100
   \       0x82   0xFBB1 0xF9F0      UDIV     R9,R1,R0
    485          
    486            OSTaskCreate(&p_task->TCB,
    487          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    488                         (CPU_CHAR *)p_task->NamePtr,
    489          #else
    490                         DEF_NULL,
    491          #endif
    492                         p_fnct,
    493                         p_task_arg,
    494                         prio,
    495                         p_task->StkBasePtr,
    496                         stk_limit,
    497                         p_task->StkSizeElements,
    498                         0u,
    499                         0u,
    500                         DEF_NULL,
    501                         (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
    502                         p_err);
   \       0x86   0x9508             STR      R5,[SP, #+32]
   \       0x88   0x2003             MOVS     R0,#+3
   \       0x8A   0x9007             STR      R0,[SP, #+28]
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x9006             STR      R0,[SP, #+24]
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x9005             STR      R0,[SP, #+20]
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x9004             STR      R0,[SP, #+16]
   \       0x98   0xF8DB 0x00A0      LDR      R0,[R11, #+160]
   \       0x9C   0x9003             STR      R0,[SP, #+12]
   \       0x9E   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0xA2   0xF8DB 0x009C      LDR      R0,[R11, #+156]
   \       0xA6   0x9001             STR      R0,[SP, #+4]
   \       0xA8   0x4640             MOV      R0,R8
   \       0xAA   0xB2C0             UXTB     R0,R0
   \       0xAC   0x9000             STR      R0,[SP, #+0]
   \       0xAE   0x003B             MOVS     R3,R7
   \       0xB0   0x0032             MOVS     R2,R6
   \       0xB2   0x2100             MOVS     R1,#+0
   \       0xB4   0x4658             MOV      R0,R11
   \       0xB6   0x.... 0x....      BL       OSTaskCreate
    503            if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {
    504              LOG_DBG(("Successfully created task ", (s)p_task->NamePtr, " with priority ", (u)prio));
    505            } else {
    506              LOG_DBG(("Call to OSTaskCreate failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
    507            }
    508          
    509            return;
   \       0xBA   0xB009             ADD      SP,SP,#+36
   \       0xBC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    510          }
    511          
    512          /****************************************************************************************************//**
    513           *                                               KAL_TaskPrioSet()
    514           *
    515           * @brief    Change the priority of a task.
    516           *
    517           * @param    task_handle     Handle of the task to change the priority.
    518           *
    519           * @param    prio            Task priority.
    520           *
    521           * @param    p_err           Pointer to the variable that will receive one of the following error
    522           *                           code(s) from this function:
    523           *                               - RTOS_ERR_NONE
    524           *                               - RTOS_ERR_INVALID_ARG
    525           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    526          void KAL_TaskPrioSet(KAL_TASK_HANDLE task_handle,
    527                               KAL_TASK_PRIO   prio,
    528                               RTOS_ERR        *p_err)
    529          {
   \                     KAL_TaskPrioSet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    530            OS_TCB *p_tcb;
    531          
    532            RTOS_ASSERT_DBG((KAL_TASK_HANDLE_IS_NULL(task_handle) != DEF_YES), RTOS_ERR_NULL_PTR,; );
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable23
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x4284             CMP      R4,R0
   \       0x10   0xD100             BNE.N    ??KAL_TaskPrioSet_0
   \                     ??KAL_TaskPrioSet_1: (+1)
   \       0x12   0xE7FE             B.N      ??KAL_TaskPrioSet_1
    533          
    534            p_tcb = &((KAL_TASK *)task_handle.TaskObjPtr)->TCB;           // Get TCB from task handle provided.
   \                     ??KAL_TaskPrioSet_0: (+1)
   \       0x14   0x0027             MOVS     R7,R4
    535          
    536            OSTaskChangePrio(p_tcb,
    537                             prio,
    538                             p_err);
   \       0x16   0x0032             MOVS     R2,R6
   \       0x18   0x0029             MOVS     R1,R5
   \       0x1A   0xB2C9             UXTB     R1,R1
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0x.... 0x....      BL       OSTaskChangePrio
    539          
    540            return;
   \       0x22   0xBDF1             POP      {R0,R4-R7,PC}
    541          }
    542          
    543          /****************************************************************************************************//**
    544           *                                               KAL_TaskDel()
    545           *
    546           * @brief    Delete a task.
    547           *
    548           * @param    task_handle     Handle of the task to delete.
    549           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    550          void KAL_TaskDel(KAL_TASK_HANDLE task_handle)
    551          {
   \                     KAL_TaskDel: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
    552            RTOS_ASSERT_DBG((KAL_TASK_HANDLE_IS_NULL(task_handle) != DEF_YES), RTOS_ERR_NULL_PTR,; );
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable27
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x4284             CMP      R4,R0
   \        0xE   0xD100             BNE.N    ??KAL_TaskDel_0
   \                     ??KAL_TaskDel_1: (+1)
   \       0x10   0xE7FE             B.N      ??KAL_TaskDel_1
    553          
    554              #if ((OS_CFG_TASK_DEL_EN == DEF_ENABLED) \
    555            && !defined(OS_SAFETY_CRITICAL_IEC61508))
    556            {
    557              OS_TCB   *p_tcb;
    558              RTOS_ERR err;
    559          
    560              p_tcb = &((KAL_TASK *)task_handle.TaskObjPtr)->TCB;         // Get TCB from task handle provided.
   \                     ??KAL_TaskDel_0: (+1)
   \       0x12   0x0025             MOVS     R5,R4
    561          
    562              OSTaskDel(p_tcb,
    563                        &err);
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x.... 0x....      BL       OSTaskDel
    564              //                                                             OSTaskDel does not return another err in this case.
    565              RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \       0x1C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD001             BEQ.N    ??KAL_TaskDel_2
   \       0x24   0x.... 0x....      BL       CPU_SW_Exception
    566          
    567              return;
   \                     ??KAL_TaskDel_2: (+1)
   \       0x28   0xB005             ADD      SP,SP,#+20
   \       0x2A   0xBD30             POP      {R4,R5,PC}
    568            }
    569              #else
    570            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_NOT_AVAIL,; );
    571              #endif
    572          }
    573          
    574          /****************************************************************************************************//**
    575           *                                           KAL_TaskUUID_Get()
    576           *
    577           * @brief    Get unique universal identificator (UUID) for current task.
    578           *
    579           * @note     (1) This function can only be used to obtain the UUID of the task that is currently
    580           *               running.
    581           *
    582           * @note     (2) This function can be used to obtain the UUID of a task that has not been created by
    583           *               KAL.
    584           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    585          KAL_TASK_UUID KAL_TaskUUID_Get(void)
    586          {
    587            KAL_TASK_UUID task_uid;
    588          
    589            task_uid = (KAL_TASK_UUID)OSTCBCurPtr;
   \                     KAL_TaskUUID_Get: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \        0x4   0x6800             LDR      R0,[R0, #+0]
    590          
    591            return (task_uid);
   \        0x6   0x4770             BX       LR
    592          }
    593          
    594          /********************************************************************************************************
    595           *                                           LOCK API FUNCTIONS
    596           *******************************************************************************************************/
    597          
    598          /****************************************************************************************************//**
    599           *                                               KAL_LockCreate()
    600           *
    601           * @brief    Create a lock, which is unlocked by default.
    602           *
    603           * @param    p_name  Pointer to name of the lock.
    604           *
    605           * @param    p_cfg   Pointer to KAL lock configuration structure.
    606           *
    607           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
    608           *                   this function:
    609           *                       - RTOS_ERR_NONE
    610           *                       - RTOS_ERR_NOT_AVAIL
    611           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    612           *                       - RTOS_ERR_POOL_EMPTY
    613           *                       - RTOS_ERR_BLK_ALLOC_CALLBACK
    614           *                       - RTOS_ERR_SEG_OVF
    615           *
    616           * @return   Created lock handle.
    617           *
    618           * @note     (1) This function will initialize KAL if KAL has not yet been initialized.
    619           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    620          KAL_LOCK_HANDLE KAL_LockCreate(const CPU_CHAR   *p_name,
    621                                         KAL_LOCK_EXT_CFG *p_cfg,
    622                                         RTOS_ERR         *p_err)
    623          {
   \                     KAL_LockCreate: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
    624            KAL_LOCK_HANDLE handle = KAL_LockHandleNull;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \        0xE   0x6806             LDR      R6,[R0, #+0]
    625          
    626            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, handle);
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD101             BNE.N    ??KAL_LockCreate_0
   \       0x14   0x.... 0x....      BL       CPU_SW_Exception
    627          
    628            if (KAL_DataPtr == DEF_NULL) {
   \                     ??KAL_LockCreate_0: (+1)
   \       0x18   0x.... 0x....      LDR.W    R7,??DataTable27_2
   \       0x1C   0x6838             LDR      R0,[R7, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD107             BNE.N    ??KAL_LockCreate_1
    629              KAL_Init(p_err);                                            // KAL initialization (see Note #1).
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       KAL_Init
    630              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x28   0x7828             LDRB     R0,[R5, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD001             BEQ.N    ??KAL_LockCreate_1
    631                return(handle);
   \       0x2E   0x0030             MOVS     R0,R6
   \       0x30   0xE02B             B.N      ??KAL_LockCreate_2
    632              }
    633            }
    634          
    635              #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    636            {
    637              KAL_LOCK   *p_kal_lock;
    638              CPU_INT08U opt_flags;
    639          
    640              p_kal_lock = (KAL_LOCK *)Mem_DynPoolBlkGet(&KAL_DataPtr->MutexPool,
    641                                                         p_err);
   \                     ??KAL_LockCreate_1: (+1)
   \       0x32   0x0029             MOVS     R1,R5
   \       0x34   0x6838             LDR      R0,[R7, #+0]
   \       0x36   0x.... 0x....      BL       Mem_DynPoolBlkGet
   \       0x3A   0x4681             MOV      R9,R0
    642              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x3C   0x7828             LDRB     R0,[R5, #+0]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD001             BEQ.N    ??KAL_LockCreate_3
    643                return (handle);
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0xE021             B.N      ??KAL_LockCreate_2
    644              }
    645          
    646              OSMutexCreate(&p_kal_lock->Mutex,
    647                            (CPU_CHAR *)p_name,
    648                            p_err);
   \                     ??KAL_LockCreate_3: (+1)
   \       0x46   0x002A             MOVS     R2,R5
   \       0x48   0x4651             MOV      R1,R10
   \       0x4A   0x4648             MOV      R0,R9
   \       0x4C   0x.... 0x....      BL       OSMutexCreate
    649              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {
   \       0x50   0x7828             LDRB     R0,[R5, #+0]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD10D             BNE.N    ??KAL_LockCreate_4
    650                if ((p_cfg != DEF_NULL)
    651                    && (DEF_BIT_IS_SET(p_cfg->Opt, KAL_OPT_CREATE_REENTRANT) == DEF_YES)) {
   \       0x56   0x2C00             CMP      R4,#+0
   \       0x58   0xD005             BEQ.N    ??KAL_LockCreate_5
   \       0x5A   0x7820             LDRB     R0,[R4, #+0]
   \       0x5C   0x07C0             LSLS     R0,R0,#+31
   \       0x5E   0xD502             BPL.N    ??KAL_LockCreate_5
    652                  opt_flags = KAL_OPT_CREATE_REENTRANT;
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x4680             MOV      R8,R0
   \       0x64   0xE001             B.N      ??KAL_LockCreate_6
    653                } else {
    654                  opt_flags = KAL_OPT_CREATE_NON_REENTRANT;
   \                     ??KAL_LockCreate_5: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x4680             MOV      R8,R0
    655                }
    656                p_kal_lock->OptFlags = opt_flags;
   \                     ??KAL_LockCreate_6: (+1)
   \       0x6A   0xF889 0x8018      STRB     R8,[R9, #+24]
    657                handle.LockObjPtr = (void *)p_kal_lock;
   \       0x6E   0x464E             MOV      R6,R9
   \       0x70   0xE00A             B.N      ??KAL_LockCreate_7
    658                LOG_VRB(("KAL_LockCreate call successful."));
    659              } else {
    660                RTOS_ERR local_err;
    661          
    662                LOG_DBG(("Call to OSMutexCreate failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
    663          
    664                Mem_DynPoolBlkFree(&KAL_DataPtr->MutexPool,
    665                                   (void *)p_kal_lock,
    666                                   &local_err);
   \                     ??KAL_LockCreate_4: (+1)
   \       0x72   0x466A             MOV      R2,SP
   \       0x74   0x4649             MOV      R1,R9
   \       0x76   0x6838             LDR      R0,[R7, #+0]
   \       0x78   0x.... 0x....      BL       Mem_DynPoolBlkFree
    667                RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL, handle);
   \       0x7C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD001             BEQ.N    ??KAL_LockCreate_7
   \       0x84   0x.... 0x....      BL       CPU_SW_Exception
    668              }
    669          
    670              return (handle);
   \                     ??KAL_LockCreate_7: (+1)
   \       0x88   0x0030             MOVS     R0,R6
   \                     ??KAL_LockCreate_2: (+1)
   \       0x8A   0xB004             ADD      SP,SP,#+16
   \       0x8C   0xE8BD 0x87F0      POP      {R4-R10,PC}
    671            }
    672              #else
    673            PP_UNUSED_PARAM(p_name);
    674            PP_UNUSED_PARAM(p_cfg);
    675          
    676            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
    677          
    678            return (handle);
    679              #endif
    680          }
    681          
    682          /****************************************************************************************************//**
    683           *                                               KAL_LockAcquire()
    684           *
    685           * @brief    Acquire a lock.
    686           *
    687           * @param    lock_handle     Handle of the lock to acquire.
    688           *
    689           * @param    opt             Options available:
    690           *                               - KAL_OPT_PEND_NONE:          block until timeout expires or lock is available.
    691           *                               - KAL_OPT_PEND_BLOCKING:      block until timeout expires or lock is available.
    692           *                               - KAL_OPT_PEND_NON_BLOCKING:  return immediately even if lock is not available.
    693           *
    694           * @param    timeout_ms      Timeout, in milliseconds. A value of 0 will never timeout.
    695           *
    696           * @param    p_err           Pointer to the variable that will receive one of the following error
    697           *                           code(s) from this function:
    698           *                               - RTOS_ERR_NONE
    699           *                               - RTOS_ERR_NOT_AVAIL
    700           *                               - RTOS_ERR_WOULD_OVF
    701           *                               - RTOS_ERR_OS_OBJ_DEL
    702           *                               - RTOS_ERR_WOULD_BLOCK
    703           *                               - RTOS_ERR_IS_OWNER
    704           *                               - RTOS_ERR_OS_SCHED_LOCKED
    705           *                               - RTOS_ERR_ABORT
    706           *                               - RTOS_ERR_TIMEOUT
    707           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    708          void KAL_LockAcquire(KAL_LOCK_HANDLE lock_handle,
    709                               KAL_OPT         opt,
    710                               CPU_INT32U      timeout_ms,
    711                               RTOS_ERR        *p_err)
    712          {
   \                     KAL_LockAcquire: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
    713            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
    714            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??KAL_LockAcquire_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
    715          
    716            RTOS_ASSERT_DBG_ERR_SET((KAL_LOCK_HANDLE_IS_NULL(lock_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_LockAcquire_0: (+1)
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x4286             CMP      R6,R0
   \       0x1C   0xD10B             BNE.N    ??KAL_LockAcquire_1
   \       0x1E   0x200A             MOVS     R0,#+10
   \       0x20   0x7028             STRB     R0,[R5, #+0]
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x26   0x6068             STR      R0,[R5, #+4]
   \       0x28   0xF44F 0x7033      MOV      R0,#+716
   \       0x2C   0x60A8             STR      R0,[R5, #+8]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \       0x32   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_LockAcquire_2: (+1)
   \       0x34   0xE7FE             B.N      ??KAL_LockAcquire_2
    717          
    718            RTOS_ASSERT_DBG_ERR_SET((DEF_BIT_IS_SET_ANY(opt, (KAL_OPT)(~(KAL_OPT_PEND_NONE | KAL_OPT_PEND_NON_BLOCKING))) == DEF_NO), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??KAL_LockAcquire_1: (+1)
   \       0x36   0x0038             MOVS     R0,R7
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0xF010 0x0FFE      TST      R0,#0xFE
   \       0x3E   0xD00B             BEQ.N    ??KAL_LockAcquire_3
   \       0x40   0x2008             MOVS     R0,#+8
   \       0x42   0x7028             STRB     R0,[R5, #+0]
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x48   0x6068             STR      R0,[R5, #+4]
   \       0x4A   0xF240 0x20CE      MOVW     R0,#+718
   \       0x4E   0x60A8             STR      R0,[R5, #+8]
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \       0x54   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_LockAcquire_4: (+1)
   \       0x56   0xE7FE             B.N      ??KAL_LockAcquire_4
    719          
    720              #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    721            {
    722              KAL_LOCK   *p_kal_lock;
    723              CPU_INT32U timeout_ticks;
    724              OS_OPT     opt_os;
    725          
    726              if (timeout_ms != KAL_TIMEOUT_INFINITE) {
   \                     ??KAL_LockAcquire_3: (+1)
   \       0x58   0x2C00             CMP      R4,#+0
   \       0x5A   0xD004             BEQ.N    ??KAL_LockAcquire_5
    727                timeout_ticks = KAL_msToTicks(timeout_ms);
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       KAL_msToTicks
   \       0x62   0x4680             MOV      R8,R0
   \       0x64   0xE001             B.N      ??KAL_LockAcquire_6
    728              } else {
    729                timeout_ticks = 0u;
   \                     ??KAL_LockAcquire_5: (+1)
   \       0x66   0xF05F 0x0800      MOVS     R8,#+0
    730              }
    731          
    732              opt_os = OS_OPT_NONE;
   \                     ??KAL_LockAcquire_6: (+1)
   \       0x6A   0xF05F 0x0A00      MOVS     R10,#+0
    733              if (DEF_BIT_IS_CLR(opt, KAL_OPT_PEND_NON_BLOCKING) == DEF_YES) {
   \       0x6E   0x07F8             LSLS     R0,R7,#+31
   \       0x70   0xD501             BPL.N    ??KAL_LockAcquire_7
    734                opt_os |= OS_OPT_PEND_BLOCKING;
    735              } else {
    736                opt_os |= OS_OPT_PEND_NON_BLOCKING;
   \                     ??KAL_LockAcquire_8: (+1)
   \       0x72   0xF45A 0x4A00      ORRS     R10,R10,#0x8000
    737              }
    738          
    739              p_kal_lock = (KAL_LOCK *)lock_handle.LockObjPtr;
   \                     ??KAL_LockAcquire_7: (+1)
   \       0x76   0x46B1             MOV      R9,R6
    740              OSMutexPend(&p_kal_lock->Mutex,
    741                          timeout_ticks,
    742                          opt_os,
    743                          DEF_NULL,
    744                          p_err);
   \       0x78   0x9500             STR      R5,[SP, #+0]
   \       0x7A   0x2300             MOVS     R3,#+0
   \       0x7C   0x4652             MOV      R2,R10
   \       0x7E   0xB292             UXTH     R2,R2
   \       0x80   0x4641             MOV      R1,R8
   \       0x82   0x4648             MOV      R0,R9
   \       0x84   0x.... 0x....      BL       OSMutexPend
    745              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_IS_OWNER) {
   \       0x88   0x7828             LDRB     R0,[R5, #+0]
   \       0x8A   0x2823             CMP      R0,#+35
   \       0x8C   0xD11B             BNE.N    ??KAL_LockAcquire_9
    746                if (DEF_BIT_IS_SET(p_kal_lock->OptFlags, KAL_OPT_CREATE_REENTRANT) == DEF_YES) {
   \       0x8E   0xF899 0x0018      LDRB     R0,[R9, #+24]
   \       0x92   0x07C0             LSLS     R0,R0,#+31
   \       0x94   0xD50B             BPL.N    ??KAL_LockAcquire_10
    747                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0x7028             STRB     R0,[R5, #+0]
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x9E   0x6068             STR      R0,[R5, #+4]
   \       0xA0   0xF240 0x20EB      MOVW     R0,#+747
   \       0xA4   0x60A8             STR      R0,[R5, #+8]
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \       0xAA   0x60E8             STR      R0,[R5, #+12]
   \       0xAC   0xE00B             B.N      ??KAL_LockAcquire_11
    748                } else {
    749                  RTOS_ERR local_err;
    750          
    751                  LOG_DBG(("KAL_LockAcquire failed with re-entrancy error."));
    752                  OSMutexPost(&p_kal_lock->Mutex,                         // Post mutex to decrement nesting ctr.
    753                              OS_OPT_POST_NONE,
    754                              &local_err);
   \                     ??KAL_LockAcquire_10: (+1)
   \       0xAE   0x466A             MOV      R2,SP
   \       0xB0   0x2100             MOVS     R1,#+0
   \       0xB2   0x4648             MOV      R0,R9
   \       0xB4   0x.... 0x....      BL       OSMutexPost
    755                  RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_IS_OWNER), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \       0xB8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xBC   0x2823             CMP      R0,#+35
   \       0xBE   0xD002             BEQ.N    ??KAL_LockAcquire_11
   \       0xC0   0x.... 0x....      BL       CPU_SW_Exception
   \       0xC4   0xE7FF             B.N      ??KAL_LockAcquire_11
    756                }
    757              } else if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    758                LOG_DBG(("Call to OSMutexPend failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
    759              }
    760          
    761              return;
   \                     ??KAL_LockAcquire_9: (+1)
   \                     ??KAL_LockAcquire_11: (+1)
   \       0xC6   0xE8BD 0x87FF      POP      {R0-R10,PC}
    762            }
    763              #else
    764            PP_UNUSED_PARAM(lock_handle);
    765            PP_UNUSED_PARAM(opt);
    766            PP_UNUSED_PARAM(timeout_ms);
    767          
    768            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
    769          
    770            return;
    771              #endif
    772          }
    773          
    774          /****************************************************************************************************//**
    775           *                                               KAL_LockRelease()
    776           *
    777           * @brief    Release a lock.
    778           *
    779           * @param    lock_handle     Handle of the lock to release.
    780           *
    781           * @param    p_err           Pointer to the variable that will receive one of the following error
    782           *                           code(s) from this function:
    783           *                               - RTOS_ERR_NONE
    784           *                               - RTOS_ERR_NOT_AVAIL
    785           *                               - RTOS_ERR_OWNERSHIP
    786           *                               - RTOS_ERR_IS_OWNER
    787           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    788          void KAL_LockRelease(KAL_LOCK_HANDLE lock_handle,
    789                               RTOS_ERR        *p_err)
    790          {
   \                     KAL_LockRelease: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    791            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
    792            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??KAL_LockRelease_0
   \        0xA   0x.... 0x....      BL       CPU_SW_Exception
    793          
    794            RTOS_ASSERT_DBG_ERR_SET((KAL_LOCK_HANDLE_IS_NULL(lock_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_LockRelease_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x4285             CMP      R5,R0
   \       0x16   0xD10B             BNE.N    ??KAL_LockRelease_1
   \       0x18   0x200A             MOVS     R0,#+10
   \       0x1A   0x7020             STRB     R0,[R4, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x20   0x6060             STR      R0,[R4, #+4]
   \       0x22   0xF240 0x301A      MOVW     R0,#+794
   \       0x26   0x60A0             STR      R0,[R4, #+8]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable27_4
   \       0x2C   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_LockRelease_2: (+1)
   \       0x2E   0xE7FE             B.N      ??KAL_LockRelease_2
    795          
    796              #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    797            {
    798              KAL_LOCK *p_kal_lock;
    799          
    800              p_kal_lock = (KAL_LOCK *)lock_handle.LockObjPtr;
   \                     ??KAL_LockRelease_1: (+1)
   \       0x30   0x002E             MOVS     R6,R5
    801              OSMutexPost(&p_kal_lock->Mutex,
    802                          OS_OPT_POST_NONE,
    803                          p_err);
   \       0x32   0x0022             MOVS     R2,R4
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x0030             MOVS     R0,R6
   \       0x38   0x.... 0x....      BL       OSMutexPost
    804              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_IS_OWNER) {
   \       0x3C   0x7820             LDRB     R0,[R4, #+0]
   \       0x3E   0x2823             CMP      R0,#+35
   \       0x40   0xD10E             BNE.N    ??KAL_LockRelease_3
    805                if (DEF_BIT_IS_SET(p_kal_lock->OptFlags, KAL_OPT_CREATE_REENTRANT) == DEF_YES) {
   \       0x42   0x7E30             LDRB     R0,[R6, #+24]
   \       0x44   0x07C0             LSLS     R0,R0,#+31
   \       0x46   0xD50B             BPL.N    ??KAL_LockRelease_4
    806                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x7020             STRB     R0,[R4, #+0]
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x50   0x6060             STR      R0,[R4, #+4]
   \       0x52   0xF240 0x3026      MOVW     R0,#+806
   \       0x56   0x60A0             STR      R0,[R4, #+8]
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable27_4
   \       0x5C   0x60E0             STR      R0,[R4, #+12]
   \       0x5E   0xE7FF             B.N      ??KAL_LockRelease_4
    807                } else {
    808                  LOG_DBG(("KAL_LockRelease failed with re-entrancy error."));
    809                }
    810              } else if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    811                LOG_DBG(("Call to OSMutexPost failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
    812              }
    813          
    814              return;
   \                     ??KAL_LockRelease_3: (+1)
   \                     ??KAL_LockRelease_4: (+1)
   \       0x60   0xBD70             POP      {R4-R6,PC}
    815            }
    816              #else
    817            PP_UNUSED_PARAM(lock_handle);
    818          
    819            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
    820          
    821            return;
    822              #endif
    823          }
    824          
    825          /****************************************************************************************************//**
    826           *                                               KAL_LockDel()
    827           *
    828           * @brief    Delete a lock.
    829           *
    830           * @param    lock_handle     Handle of the lock to delete.
    831           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    832          void KAL_LockDel(KAL_LOCK_HANDLE lock_handle)
    833          {
   \                     KAL_LockDel: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
    834            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
    835            RTOS_ASSERT_DBG((KAL_LOCK_HANDLE_IS_NULL(lock_handle) == DEF_NO), RTOS_ERR_NULL_PTR,; );
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x4284             CMP      R4,R0
   \        0xE   0xD100             BNE.N    ??KAL_LockDel_0
   \                     ??KAL_LockDel_1: (+1)
   \       0x10   0xE7FE             B.N      ??KAL_LockDel_1
    836          
    837              #if ((OS_CFG_MUTEX_EN == DEF_ENABLED) \
    838            && !defined(OS_SAFETY_CRITICAL_IEC61508))                     // Mutex is avail. Not safety critical.
    839            {
    840              KAL_LOCK *p_kal_lock;
    841              RTOS_ERR err;
    842          
    843              p_kal_lock = (KAL_LOCK *)lock_handle.LockObjPtr;
   \                     ??KAL_LockDel_0: (+1)
   \       0x12   0x0025             MOVS     R5,R4
    844          
    845              (void)OSMutexDel(&p_kal_lock->Mutex,
    846                               OS_OPT_DEL_ALWAYS,
    847                               &err);
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       OSMutexDel
    848              //                                                             OSMutexDel does not return another err in this case.
    849              RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \       0x1E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD001             BEQ.N    ??KAL_LockDel_2
   \       0x26   0x.... 0x....      BL       CPU_SW_Exception
    850          
    851              Mem_DynPoolBlkFree(&KAL_DataPtr->MutexPool,
    852                                 (void *)p_kal_lock,
    853                                 &err);
   \                     ??KAL_LockDel_2: (+1)
   \       0x2A   0x466A             MOV      R2,SP
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x.... 0x....      BL       Mem_DynPoolBlkFree
    854              RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \       0x38   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD001             BEQ.N    ??KAL_LockDel_3
   \       0x40   0x.... 0x....      BL       CPU_SW_Exception
    855          
    856              return;
   \                     ??KAL_LockDel_3: (+1)
   \       0x44   0xB005             ADD      SP,SP,#+20
   \       0x46   0xBD30             POP      {R4,R5,PC}
    857            }
    858              #else //                                                       Mutex or mutex del is not avail.
    859            PP_UNUSED_PARAM(lock_handle);
    860          
    861            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_NOT_AVAIL,; );
    862              #endif
    863          }
    864          
    865          /********************************************************************************************************
    866           *                                           SEM API FUNCTIONS
    867           *******************************************************************************************************/
    868          
    869          /****************************************************************************************************//**
    870           *                                               KAL_SemCreate()
    871           *
    872           * @brief    Create a semaphore, with a count of 0.
    873           *
    874           * @param    p_name  Pointer to name of the semaphore.
    875           *
    876           * @param    p_cfg   Pointer to KAL semaphore configuration structure.
    877           *
    878           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
    879           *                   this function:
    880           *                       - RTOS_ERR_NONE
    881           *                       - RTOS_ERR_NOT_AVAIL
    882           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    883           *                       - RTOS_ERR_POOL_EMPTY
    884           *                       - RTOS_ERR_BLK_ALLOC_CALLBACK
    885           *                       - RTOS_ERR_SEG_OVF
    886           *
    887           * @return   Created semaphore's handle.
    888           *
    889           * @note     (1) This function will initialize KAL if KAL has not yet been initialized.
    890           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    891          KAL_SEM_HANDLE KAL_SemCreate(const CPU_CHAR  *p_name,
    892                                       KAL_SEM_EXT_CFG *p_cfg,
    893                                       RTOS_ERR        *p_err)
    894          {
   \                     KAL_SemCreate: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
    895            KAL_SEM_HANDLE handle = KAL_SemHandleNull;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \       0x10   0x6806             LDR      R6,[R0, #+0]
    896          
    897            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
    898            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, handle);
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??KAL_SemCreate_0
   \       0x16   0x.... 0x....      BL       CPU_SW_Exception
    899          
    900            //                                                               Make sure no unsupported cfg recv.
    901            RTOS_ASSERT_DBG_ERR_SET((p_cfg == DEF_NULL), *p_err, RTOS_ERR_NOT_SUPPORTED, handle);
   \                     ??KAL_SemCreate_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD00B             BEQ.N    ??KAL_SemCreate_1
   \       0x1E   0x2007             MOVS     R0,#+7
   \       0x20   0x7028             STRB     R0,[R5, #+0]
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x26   0x6068             STR      R0,[R5, #+4]
   \       0x28   0xF240 0x3085      MOVW     R0,#+901
   \       0x2C   0x60A8             STR      R0,[R5, #+8]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable27_6
   \       0x32   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_SemCreate_2: (+1)
   \       0x34   0xE7FE             B.N      ??KAL_SemCreate_2
    902          
    903            if (KAL_DataPtr == DEF_NULL) {
   \                     ??KAL_SemCreate_1: (+1)
   \       0x36   0x.... 0x....      LDR.W    R9,??DataTable27_2
   \       0x3A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD107             BNE.N    ??KAL_SemCreate_3
    904              KAL_Init(p_err);                                            // KAL initialization (see Note #1).
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0x.... 0x....      BL       KAL_Init
    905              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x48   0x7828             LDRB     R0,[R5, #+0]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD001             BEQ.N    ??KAL_SemCreate_3
    906                return(handle);
   \       0x4E   0x0030             MOVS     R0,R6
   \       0x50   0xE024             B.N      ??KAL_SemCreate_4
    907              }
    908            }
    909          
    910              #if (OS_CFG_SEM_EN == DEF_ENABLED)
    911            {
    912              OS_SEM *p_sem;
    913          
    914              p_sem = (OS_SEM *)Mem_DynPoolBlkGet(&KAL_DataPtr->SemPool,
    915                                                  p_err);
   \                     ??KAL_SemCreate_3: (+1)
   \       0x52   0x0029             MOVS     R1,R5
   \       0x54   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x58   0x3024             ADDS     R0,R0,#+36
   \       0x5A   0x.... 0x....      BL       Mem_DynPoolBlkGet
   \       0x5E   0x0007             MOVS     R7,R0
    916              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x60   0x7828             LDRB     R0,[R5, #+0]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD001             BEQ.N    ??KAL_SemCreate_5
    917                return (handle);
   \       0x66   0x0030             MOVS     R0,R6
   \       0x68   0xE018             B.N      ??KAL_SemCreate_4
    918              }
    919          
    920              OSSemCreate(p_sem,
    921                          (CPU_CHAR *)p_name,
    922                          0u,
    923                          p_err);
   \                     ??KAL_SemCreate_5: (+1)
   \       0x6A   0x002B             MOVS     R3,R5
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0x4641             MOV      R1,R8
   \       0x70   0x0038             MOVS     R0,R7
   \       0x72   0x.... 0x....      BL       OSSemCreate
    924              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {
   \       0x76   0x7828             LDRB     R0,[R5, #+0]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD101             BNE.N    ??KAL_SemCreate_6
    925                handle.SemObjPtr = (void *)p_sem;
   \       0x7C   0x003E             MOVS     R6,R7
   \       0x7E   0xE00C             B.N      ??KAL_SemCreate_7
    926              } else {
    927                RTOS_ERR local_err;
    928          
    929                LOG_DBG(("Call to OSSemCreate failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
    930          
    931                Mem_DynPoolBlkFree(&KAL_DataPtr->SemPool,
    932                                   (void *)p_sem,
    933                                   &local_err);
   \                     ??KAL_SemCreate_6: (+1)
   \       0x80   0x466A             MOV      R2,SP
   \       0x82   0x0039             MOVS     R1,R7
   \       0x84   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x88   0x3024             ADDS     R0,R0,#+36
   \       0x8A   0x.... 0x....      BL       Mem_DynPoolBlkFree
    934                RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL, handle);
   \       0x8E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD001             BEQ.N    ??KAL_SemCreate_7
   \       0x96   0x.... 0x....      BL       CPU_SW_Exception
    935              }
    936          
    937              return (handle);
   \                     ??KAL_SemCreate_7: (+1)
   \       0x9A   0x0030             MOVS     R0,R6
   \                     ??KAL_SemCreate_4: (+1)
   \       0x9C   0xB005             ADD      SP,SP,#+20
   \       0x9E   0xE8BD 0x83F0      POP      {R4-R9,PC}
    938            }
    939              #else
    940            PP_UNUSED_PARAM(p_name);
    941          
    942            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
    943          
    944            return (handle);
    945              #endif
    946          }
    947          
    948          /****************************************************************************************************//**
    949           *                                               KAL_SemPend()
    950           *
    951           * @brief    Pend on a semaphore.
    952           *
    953           * @param    sem_handle  Handle of the semaphore to pend on.
    954           *
    955           * @param    opt         Options available:
    956           *                           - KAL_OPT_PEND_NONE:          block until timeout expires or semaphore is available.
    957           *                           - KAL_OPT_PEND_BLOCKING:      block until timeout expires or semaphore is available.
    958           *                           - KAL_OPT_PEND_NON_BLOCKING:  return immediately even if semaphore is not available.
    959           *
    960           * @param    timeout_ms  Timeout, in milliseconds. A value of 0 will never timeout.
    961           *
    962           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
    963           *                       from this function:
    964           *                           - RTOS_ERR_NONE
    965           *                           - RTOS_ERR_NOT_AVAIL
    966           *                           - RTOS_ERR_OS_OBJ_DEL
    967           *                           - RTOS_ERR_WOULD_BLOCK
    968           *                           - RTOS_ERR_OS_SCHED_LOCKED
    969           *                           - RTOS_ERR_ABORT
    970           *                           - RTOS_ERR_TIMEOUT
    971           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    972          void KAL_SemPend(KAL_SEM_HANDLE sem_handle,
    973                           KAL_OPT        opt,
    974                           CPU_INT32U     timeout_ms,
    975                           RTOS_ERR       *p_err)
    976          {
   \                     KAL_SemPend: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
    977            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
    978            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??KAL_SemPend_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
    979          
    980            RTOS_ASSERT_DBG_ERR_SET((KAL_SEM_HANDLE_IS_NULL(sem_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_SemPend_0: (+1)
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x4286             CMP      R6,R0
   \       0x1C   0xD10B             BNE.N    ??KAL_SemPend_1
   \       0x1E   0x200A             MOVS     R0,#+10
   \       0x20   0x7028             STRB     R0,[R5, #+0]
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x26   0x6068             STR      R0,[R5, #+4]
   \       0x28   0xF44F 0x7075      MOV      R0,#+980
   \       0x2C   0x60A8             STR      R0,[R5, #+8]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \       0x32   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_SemPend_2: (+1)
   \       0x34   0xE7FE             B.N      ??KAL_SemPend_2
    981          
    982            RTOS_ASSERT_DBG_ERR_SET((DEF_BIT_IS_SET_ANY(opt, (KAL_OPT)(~(KAL_OPT_PEND_NONE | KAL_OPT_PEND_NON_BLOCKING))) == DEF_NO), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??KAL_SemPend_1: (+1)
   \       0x36   0x0038             MOVS     R0,R7
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0xF010 0x0FFE      TST      R0,#0xFE
   \       0x3E   0xD00B             BEQ.N    ??KAL_SemPend_3
   \       0x40   0x2008             MOVS     R0,#+8
   \       0x42   0x7028             STRB     R0,[R5, #+0]
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x48   0x6068             STR      R0,[R5, #+4]
   \       0x4A   0xF240 0x30D6      MOVW     R0,#+982
   \       0x4E   0x60A8             STR      R0,[R5, #+8]
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \       0x54   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_SemPend_4: (+1)
   \       0x56   0xE7FE             B.N      ??KAL_SemPend_4
    983          
    984              #if (OS_CFG_SEM_EN == DEF_ENABLED)
    985            {
    986              CPU_INT32U timeout_ticks;
    987              OS_OPT     opt_os;
    988          
    989              if (timeout_ms != KAL_TIMEOUT_INFINITE) {
   \                     ??KAL_SemPend_3: (+1)
   \       0x58   0x2C00             CMP      R4,#+0
   \       0x5A   0xD004             BEQ.N    ??KAL_SemPend_5
    990                timeout_ticks = KAL_msToTicks(timeout_ms);
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       KAL_msToTicks
   \       0x62   0x4680             MOV      R8,R0
   \       0x64   0xE001             B.N      ??KAL_SemPend_6
    991              } else {
    992                timeout_ticks = 0u;
   \                     ??KAL_SemPend_5: (+1)
   \       0x66   0xF05F 0x0800      MOVS     R8,#+0
    993              }
    994          
    995              opt_os = OS_OPT_NONE;
   \                     ??KAL_SemPend_6: (+1)
   \       0x6A   0xF05F 0x0900      MOVS     R9,#+0
    996              if (DEF_BIT_IS_CLR(opt, KAL_OPT_PEND_NON_BLOCKING) == DEF_YES) {
   \       0x6E   0x07F8             LSLS     R0,R7,#+31
   \       0x70   0xD501             BPL.N    ??KAL_SemPend_7
    997                opt_os |= OS_OPT_PEND_BLOCKING;
    998              } else {
    999                opt_os |= OS_OPT_PEND_NON_BLOCKING;
   \                     ??KAL_SemPend_8: (+1)
   \       0x72   0xF459 0x4900      ORRS     R9,R9,#0x8000
   1000              }
   1001          
   1002              OSSemPend((OS_SEM *)sem_handle.SemObjPtr,
   1003                        timeout_ticks,
   1004                        opt_os,
   1005                        DEF_NULL,
   1006                        p_err);
   \                     ??KAL_SemPend_7: (+1)
   \       0x76   0x9500             STR      R5,[SP, #+0]
   \       0x78   0x2300             MOVS     R3,#+0
   \       0x7A   0x464A             MOV      R2,R9
   \       0x7C   0xB292             UXTH     R2,R2
   \       0x7E   0x4641             MOV      R1,R8
   \       0x80   0x0030             MOVS     R0,R6
   \       0x82   0x.... 0x....      BL       OSSemPend
   1007          
   1008              return;
   \       0x86   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   1009            }
   1010              #else
   1011            PP_UNUSED_PARAM(sem_handle);
   1012            PP_UNUSED_PARAM(opt);
   1013            PP_UNUSED_PARAM(timeout_ms);
   1014          
   1015            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   1016          
   1017            return;
   1018              #endif
   1019          }
   1020          
   1021          /****************************************************************************************************//**
   1022           *                                               KAL_SemPost()
   1023           *
   1024           * @brief    Post a semaphore.
   1025           *
   1026           * @param    sem_handle  Handle of the semaphore to post.
   1027           *
   1028           * @param    opt         Options available:
   1029           *                       KAL_OPT_POST_NONE:     wake only the highest priority task pending on semaphore.
   1030           *
   1031           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1032           *                       from this function:
   1033           *                           - RTOS_ERR_NONE
   1034           *                           - RTOS_ERR_NOT_AVAIL
   1035           *                           - RTOS_ERR_WOULD_OVF
   1036           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1037          void KAL_SemPost(KAL_SEM_HANDLE sem_handle,
   1038                           KAL_OPT        opt,
   1039                           RTOS_ERR       *p_err)
   1040          {
   \                     KAL_SemPost: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   1041            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1042            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??KAL_SemPost_0
   \        0xC   0x.... 0x....      BL       CPU_SW_Exception
   1043          
   1044            RTOS_ASSERT_DBG_ERR_SET((KAL_SEM_HANDLE_IS_NULL(sem_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_SemPost_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x4285             CMP      R5,R0
   \       0x18   0xD10B             BNE.N    ??KAL_SemPost_1
   \       0x1A   0x200A             MOVS     R0,#+10
   \       0x1C   0x7020             STRB     R0,[R4, #+0]
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x22   0x6060             STR      R0,[R4, #+4]
   \       0x24   0xF240 0x4014      MOVW     R0,#+1044
   \       0x28   0x60A0             STR      R0,[R4, #+8]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable27_8
   \       0x2E   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_SemPost_2: (+1)
   \       0x30   0xE7FE             B.N      ??KAL_SemPost_2
   1045          
   1046            RTOS_ASSERT_DBG_ERR_SET((opt == KAL_OPT_POST_NONE), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??KAL_SemPost_1: (+1)
   \       0x32   0x0030             MOVS     R0,R6
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD00B             BEQ.N    ??KAL_SemPost_3
   \       0x3A   0x2008             MOVS     R0,#+8
   \       0x3C   0x7020             STRB     R0,[R4, #+0]
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x42   0x6060             STR      R0,[R4, #+4]
   \       0x44   0xF240 0x4016      MOVW     R0,#+1046
   \       0x48   0x60A0             STR      R0,[R4, #+8]
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable27_8
   \       0x4E   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_SemPost_4: (+1)
   \       0x50   0xE7FE             B.N      ??KAL_SemPost_4
   1047          
   1048          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   1049            OSSemPost((OS_SEM *)sem_handle.SemObjPtr,
   1050                      OS_OPT_POST_1,
   1051                      p_err);
   \                     ??KAL_SemPost_3: (+1)
   \       0x52   0x0022             MOVS     R2,R4
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0x.... 0x....      BL       OSSemPost
   1052            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1053              LOG_DBG(("Call to OSSemPost failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1054            }
   1055          
   1056            return;
   \       0x5C   0xBD70             POP      {R4-R6,PC}
   1057          #else
   1058            PP_UNUSED_PARAM(sem_handle);
   1059            PP_UNUSED_PARAM(opt);
   1060          
   1061            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   1062          
   1063            return;
   1064          #endif
   1065          }
   1066          
   1067          /****************************************************************************************************//**
   1068           *                                           KAL_SemPendAbort()
   1069           *
   1070           * @brief    Abort given semaphore and resume all the tasks pending on it.
   1071           *
   1072           * @param    sem_handle  Handle of the semaphore to abort.
   1073           *
   1074           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1075           *                       from this function:
   1076           *                           - RTOS_ERR_NONE
   1077           *                           - RTOS_ERR_NOT_AVAIL
   1078           *                           - RTOS_ERR_NONE_WAITING
   1079           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1080          void KAL_SemPendAbort(KAL_SEM_HANDLE sem_handle,
   1081                                RTOS_ERR       *p_err)
   1082          {
   \                     KAL_SemPendAbort: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1083            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1084            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??KAL_SemPendAbort_0
   \        0xA   0x.... 0x....      BL       CPU_SW_Exception
   1085          
   1086            RTOS_ASSERT_DBG_ERR_SET((KAL_SEM_HANDLE_IS_NULL(sem_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_SemPendAbort_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x4285             CMP      R5,R0
   \       0x16   0xD10B             BNE.N    ??KAL_SemPendAbort_1
   \       0x18   0x200A             MOVS     R0,#+10
   \       0x1A   0x7020             STRB     R0,[R4, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x20   0x6060             STR      R0,[R4, #+4]
   \       0x22   0xF240 0x403E      MOVW     R0,#+1086
   \       0x26   0x60A0             STR      R0,[R4, #+8]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \       0x2C   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_SemPendAbort_2: (+1)
   \       0x2E   0xE7FE             B.N      ??KAL_SemPendAbort_2
   1087          
   1088          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   1089            {
   1090              (void)OSSemPendAbort((OS_SEM *)sem_handle.SemObjPtr,
   1091                                   OS_OPT_PEND_ABORT_ALL,
   1092                                   p_err);
   \                     ??KAL_SemPendAbort_1: (+1)
   \       0x30   0x0022             MOVS     R2,R4
   \       0x32   0xF44F 0x7180      MOV      R1,#+256
   \       0x36   0x0028             MOVS     R0,R5
   \       0x38   0x.... 0x....      BL       OSSemPendAbort
   1093              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE_WAITING) {
   \       0x3C   0x7820             LDRB     R0,[R4, #+0]
   \       0x3E   0x2824             CMP      R0,#+36
   \       0x40   0xD10B             BNE.N    ??KAL_SemPendAbort_3
   1094                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x7020             STRB     R0,[R4, #+0]
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x4A   0x6060             STR      R0,[R4, #+4]
   \       0x4C   0xF240 0x4046      MOVW     R0,#+1094
   \       0x50   0x60A0             STR      R0,[R4, #+8]
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \       0x56   0x60E0             STR      R0,[R4, #+12]
   \       0x58   0xE7FF             B.N      ??KAL_SemPendAbort_4
   1095              } else if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1096                LOG_DBG(("Call to OSSemPendAbort failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1097              }
   1098          
   1099              return;
   \                     ??KAL_SemPendAbort_3: (+1)
   \                     ??KAL_SemPendAbort_4: (+1)
   \       0x5A   0xBD31             POP      {R0,R4,R5,PC}
   1100            }
   1101          #else //                                                           Sems or sems pend abort is not avail.
   1102            PP_UNUSED_PARAM(sem_handle);
   1103          
   1104            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   1105          
   1106            return;
   1107          #endif
   1108          }
   1109          
   1110          /****************************************************************************************************//**
   1111           *                                               KAL_SemSet()
   1112           *
   1113           * @brief    Set value of semaphore.
   1114           *
   1115           * @param    sem_handle  Handle of the semaphore to set.
   1116           *
   1117           * @param    cnt         Count value to set semaphore.
   1118           *
   1119           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1120           *                       from this function:
   1121           *                           - RTOS_ERR_NONE
   1122           *                           - RTOS_ERR_NOT_AVAIL
   1123           *                           - RTOS_ERR_OS_TASK_WAITING
   1124           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1125          void KAL_SemSet(KAL_SEM_HANDLE sem_handle,
   1126                          CPU_INT08U     cnt,
   1127                          RTOS_ERR       *p_err)
   1128          {
   \                     KAL_SemSet: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   1129            //                                                               ------------------ VALIDATE ARGS -------------------
   1130            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??KAL_SemSet_0
   \        0xC   0x.... 0x....      BL       CPU_SW_Exception
   1131          
   1132            RTOS_ASSERT_DBG_ERR_SET((KAL_SEM_HANDLE_IS_NULL(sem_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_SemSet_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x4285             CMP      R5,R0
   \       0x18   0xD10B             BNE.N    ??KAL_SemSet_1
   \       0x1A   0x200A             MOVS     R0,#+10
   \       0x1C   0x7020             STRB     R0,[R4, #+0]
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x22   0x6060             STR      R0,[R4, #+4]
   \       0x24   0xF240 0x406C      MOVW     R0,#+1132
   \       0x28   0x60A0             STR      R0,[R4, #+8]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable27_10
   \       0x2E   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_SemSet_2: (+1)
   \       0x30   0xE7FE             B.N      ??KAL_SemSet_2
   1133          
   1134          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   1135            {
   1136              OSSemSet((OS_SEM *)sem_handle.SemObjPtr,
   1137                       cnt,
   1138                       p_err);
   \                     ??KAL_SemSet_1: (+1)
   \       0x32   0x0022             MOVS     R2,R4
   \       0x34   0x0031             MOVS     R1,R6
   \       0x36   0xB2C9             UXTB     R1,R1
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       OSSemSet
   1139              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1140                LOG_DBG(("Call to OSSemSet failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1141              }
   1142          
   1143              return;
   \       0x3E   0xBD70             POP      {R4-R6,PC}
   1144            }
   1145          #else //                                                           Sems or sems set is not avail.
   1146            PP_UNUSED_PARAM(sem_handle);
   1147            PP_UNUSED_PARAM(cnt);
   1148          
   1149            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   1150          
   1151            return;
   1152          #endif
   1153          }
   1154          
   1155          /****************************************************************************************************//**
   1156           *                                               KAL_SemDel()
   1157           *
   1158           * @brief    Delete a semaphore.
   1159           *
   1160           * @param    sem_handle  Handle of the semaphore to delete.
   1161           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1162          void KAL_SemDel(KAL_SEM_HANDLE sem_handle)
   1163          {
   \                     KAL_SemDel: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   1164            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1165            RTOS_ASSERT_DBG((KAL_SEM_HANDLE_IS_NULL(sem_handle) == DEF_NO), RTOS_ERR_NULL_PTR,; );
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x4284             CMP      R4,R0
   \        0xE   0xD100             BNE.N    ??KAL_SemDel_0
   \                     ??KAL_SemDel_1: (+1)
   \       0x10   0xE7FE             B.N      ??KAL_SemDel_1
   1166          
   1167              #if ((OS_CFG_SEM_EN == DEF_ENABLED) \
   1168            && !defined(OS_SAFETY_CRITICAL_IEC61508))
   1169            {
   1170              OS_SEM   *p_sem;
   1171              RTOS_ERR err;
   1172          
   1173              p_sem = (OS_SEM *)sem_handle.SemObjPtr;
   \                     ??KAL_SemDel_0: (+1)
   \       0x12   0x0025             MOVS     R5,R4
   1174          
   1175              (void)OSSemDel(p_sem,
   1176                             OS_OPT_DEL_ALWAYS,
   1177                             &err);
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       OSSemDel
   1178              //                                                             OSSemDel should not return another err in this case.
   1179              RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \       0x1E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD001             BEQ.N    ??KAL_SemDel_2
   \       0x26   0x.... 0x....      BL       CPU_SW_Exception
   1180          
   1181              Mem_DynPoolBlkFree(&KAL_DataPtr->SemPool,
   1182                                 (void *)p_sem,
   1183                                 &err);
   \                     ??KAL_SemDel_2: (+1)
   \       0x2A   0x466A             MOV      R2,SP
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x3024             ADDS     R0,R0,#+36
   \       0x36   0x.... 0x....      BL       Mem_DynPoolBlkFree
   1184              RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \       0x3A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD001             BEQ.N    ??KAL_SemDel_3
   \       0x42   0x.... 0x....      BL       CPU_SW_Exception
   1185          
   1186              return;
   \                     ??KAL_SemDel_3: (+1)
   \       0x46   0xB005             ADD      SP,SP,#+20
   \       0x48   0xBD30             POP      {R4,R5,PC}
   1187            }
   1188              #else //                                                       Sems or sems del is not avail.
   1189            PP_UNUSED_PARAM(sem_handle);
   1190          
   1191            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_NOT_AVAIL,; );
   1192              #endif
   1193          }
   1194          
   1195          /********************************************************************************************************
   1196           *                                           TMR API FUNCTIONS
   1197           *******************************************************************************************************/
   1198          
   1199          /****************************************************************************************************//**
   1200           *                                               KAL_TmrCreate()
   1201           *
   1202           * @brief    Create a single-shot timer.
   1203           *
   1204           * @param    p_name          Pointer to name of the timer.
   1205           *
   1206           * @param    p_callback      Pointer to the callback function that will be called on completion of timer.
   1207           *
   1208           * @param    p_callback_arg  Argument passed to callback function.
   1209           *
   1210           * @param    interval_ms     If timer is 'one-shot', delay  used by the timer, in milliseconds.
   1211           *                           If timer is 'periodic', period used by the timer, in milliseconds.
   1212           *
   1213           * @param    p_cfg           Pointer to KAL timer configuration structure.
   1214           *
   1215           * @param    p_err           Pointer to the variable that will receive one of the following error
   1216           *                           code(s) from this function:
   1217           *                               - RTOS_ERR_NONE
   1218           *                               - RTOS_ERR_NOT_AVAIL
   1219           *                               - RTOS_ERR_OS_ILLEGAL_RUN_TIME
   1220           *                               - RTOS_ERR_POOL_EMPTY
   1221           *                               - RTOS_ERR_BLK_ALLOC_CALLBACK
   1222           *                               - RTOS_ERR_SEG_OVF
   1223           *
   1224           * @return   Created timer handle.
   1225           *
   1226           * @note     (1) This function will initialize KAL if KAL has not yet been initialized.
   1227           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1228          KAL_TMR_HANDLE KAL_TmrCreate(const CPU_CHAR  *p_name,
   1229                                       void (*p_callback)(void *p_arg),
   1230                                       void            *p_callback_arg,
   1231                                       CPU_INT32U      interval_ms,
   1232                                       KAL_TMR_EXT_CFG *p_cfg,
   1233                                       RTOS_ERR        *p_err)
   1234          {
   \                     KAL_TmrCreate: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9D08             LDR      R5,[SP, #+32]
   \        0xE   0x9E09             LDR      R6,[SP, #+36]
   1235            KAL_TMR_HANDLE handle = KAL_TmrHandleNull;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable27_11
   \       0x14   0xF8D0 0x9000      LDR      R9,[R0, #+0]
   1236          
   1237            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1238            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, handle);
   \       0x18   0x2E00             CMP      R6,#+0
   \       0x1A   0xD101             BNE.N    ??KAL_TmrCreate_0
   \       0x1C   0x.... 0x....      BL       CPU_SW_Exception
   1239            //                                                               Check if OS is initialized.
   1240            RTOS_ASSERT_DBG_ERR_SET((OSInitialized == DEF_TRUE), *p_err, RTOS_ERR_NOT_INIT, handle);
   \                     ??KAL_TmrCreate_0: (+1)
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable27_12
   \       0x24   0x7800             LDRB     R0,[R0, #+0]
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD00B             BEQ.N    ??KAL_TmrCreate_1
   \       0x2A   0x2013             MOVS     R0,#+19
   \       0x2C   0x7030             STRB     R0,[R6, #+0]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x32   0x6070             STR      R0,[R6, #+4]
   \       0x34   0xF44F 0x609B      MOV      R0,#+1240
   \       0x38   0x60B0             STR      R0,[R6, #+8]
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable27_13
   \       0x3E   0x60F0             STR      R0,[R6, #+12]
   \                     ??KAL_TmrCreate_2: (+1)
   \       0x40   0xE7FE             B.N      ??KAL_TmrCreate_2
   1241          
   1242            //                                                               Validate callback fnct ptr.
   1243            RTOS_ASSERT_DBG_ERR_SET((p_callback != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, handle);
   \                     ??KAL_TmrCreate_1: (+1)
   \       0x42   0x0038             MOVS     R0,R7
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD10B             BNE.N    ??KAL_TmrCreate_3
   \       0x48   0x200A             MOVS     R0,#+10
   \       0x4A   0x7030             STRB     R0,[R6, #+0]
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x50   0x6070             STR      R0,[R6, #+4]
   \       0x52   0xF240 0x40DB      MOVW     R0,#+1243
   \       0x56   0x60B0             STR      R0,[R6, #+8]
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable27_13
   \       0x5C   0x60F0             STR      R0,[R6, #+12]
   \                     ??KAL_TmrCreate_4: (+1)
   \       0x5E   0xE7FE             B.N      ??KAL_TmrCreate_4
   1244          
   1245            //                                                               Validate time.
   1246            RTOS_ASSERT_DBG_ERR_SET((interval_ms != 0u), *p_err, RTOS_ERR_INVALID_ARG, handle);
   \                     ??KAL_TmrCreate_3: (+1)
   \       0x60   0x2C00             CMP      R4,#+0
   \       0x62   0xD10B             BNE.N    ??KAL_TmrCreate_5
   \       0x64   0x2008             MOVS     R0,#+8
   \       0x66   0x7030             STRB     R0,[R6, #+0]
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x6C   0x6070             STR      R0,[R6, #+4]
   \       0x6E   0xF240 0x40DE      MOVW     R0,#+1246
   \       0x72   0x60B0             STR      R0,[R6, #+8]
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable27_13
   \       0x78   0x60F0             STR      R0,[R6, #+12]
   \                     ??KAL_TmrCreate_6: (+1)
   \       0x7A   0xE7FE             B.N      ??KAL_TmrCreate_6
   1247          
   1248            if (p_cfg != DEF_NULL) {
   \                     ??KAL_TmrCreate_5: (+1)
   \       0x7C   0x2D00             CMP      R5,#+0
   \       0x7E   0xD00F             BEQ.N    ??KAL_TmrCreate_7
   1249              RTOS_ASSERT_DBG_ERR_SET((DEF_BIT_IS_SET_ANY(p_cfg->Opt, (KAL_OPT)(~(KAL_OPT_TMR_NONE | KAL_OPT_TMR_PERIODIC))) == DEF_NO), *p_err, RTOS_ERR_INVALID_ARG, handle);
   \       0x80   0x7828             LDRB     R0,[R5, #+0]
   \       0x82   0xF010 0x0FFE      TST      R0,#0xFE
   \       0x86   0xD00B             BEQ.N    ??KAL_TmrCreate_7
   \       0x88   0x2008             MOVS     R0,#+8
   \       0x8A   0x7030             STRB     R0,[R6, #+0]
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x90   0x6070             STR      R0,[R6, #+4]
   \       0x92   0xF240 0x40E1      MOVW     R0,#+1249
   \       0x96   0x60B0             STR      R0,[R6, #+8]
   \       0x98   0x.... 0x....      LDR.W    R0,??DataTable27_13
   \       0x9C   0x60F0             STR      R0,[R6, #+12]
   \                     ??KAL_TmrCreate_8: (+1)
   \       0x9E   0xE7FE             B.N      ??KAL_TmrCreate_8
   1250            }
   1251          
   1252            if (KAL_DataPtr == DEF_NULL) {
   \                     ??KAL_TmrCreate_7: (+1)
   \       0xA0   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \       0xA4   0x6800             LDR      R0,[R0, #+0]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD107             BNE.N    ??KAL_TmrCreate_9
   1253              KAL_Init(p_err);                                            // KAL initialization (see Note #1).
   \       0xAA   0x0030             MOVS     R0,R6
   \       0xAC   0x.... 0x....      BL       KAL_Init
   1254              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0xB0   0x7830             LDRB     R0,[R6, #+0]
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD001             BEQ.N    ??KAL_TmrCreate_9
   1255                return(handle);
   \       0xB6   0x4648             MOV      R0,R9
   \       0xB8   0xE00B             B.N      ??KAL_TmrCreate_10
   1256              }
   1257            }
   1258          
   1259              #if (OS_CFG_TMR_EN == DEF_ENABLED)
   1260            {
   1261              KAL_TMR    *p_tmr;
   1262              CPU_INT32U tmr_dly;
   1263              CPU_INT32U tmr_period;
   1264              OS_OPT     opt_os;
   1265              KAL_TICK   ticks;
   1266              #ifdef  OS_CFG_COMPAT_INIT
   1267                  #if  ((OS_CFG_TMR_TASK_RATE_HZ >= 1000u) \
   1268              && (OS_CFG_TMR_TASK_RATE_HZ % 1000u == 0u))
   1269              const CPU_INT08U mult = OS_CFG_TMR_TASK_RATE_HZ / 1000u;
   1270                  #endif
   1271                  #endif
   1272          
   1273              p_tmr = (KAL_TMR *)Mem_DynPoolBlkGet(&KAL_DataPtr->TmrPool,
   1274                                                   p_err);
   1275              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1276                return (handle);
   1277              }
   1278          
   1279              p_tmr->CallbackFnct = p_callback;
   1280              p_tmr->CallbackArg = p_callback_arg;
   1281              //                                                             Calc nbr of tmr ticks (rounded up nearest int).
   1282          #ifdef  OS_CFG_COMPAT_INIT
   1283                  #if  ((OS_CFG_TMR_TASK_RATE_HZ >= 1000u) \
   1284              && (OS_CFG_TMR_TASK_RATE_HZ % 1000u == 0u))                 // Optimize calc if possible for often used vals.
   1285              ticks = interval_ms * mult;
   1286                  #elif (OS_CFG_TMR_TASK_RATE_HZ == 100u)
   1287              ticks = ((interval_ms +  9u) /  10u);
   1288                  #elif (OS_CFG_TMR_TASK_RATE_HZ == 10u)
   1289              ticks = ((interval_ms + 99u) / 100u);
   1290                  #else //                                                   General formula.
   1291              ticks = (((interval_ms * OS_CFG_TMR_TASK_RATE_HZ)  + 1000u - 1u) / 1000u);
   1292                  #endif
   1293          #else
   1294              ticks = (((interval_ms * OSCfg_TmrTaskRate_Hz)  + 1000u - 1u) / 1000u);
   1295          #endif
   1296              //                                                             Tmr is 'periodic'.
   1297              if ((p_cfg != DEF_NULL)
   1298                  && (DEF_BIT_IS_SET(p_cfg->Opt, KAL_OPT_TMR_PERIODIC) == DEF_YES)) {
   1299                opt_os = OS_OPT_TMR_PERIODIC;
   1300                tmr_dly = 0u;
   1301                tmr_period = ticks;
   1302              } else {
   1303                opt_os = OS_OPT_TMR_ONE_SHOT;                             // Tmr is 'one-shot'.
   1304                tmr_dly = ticks;
   1305                tmr_period = 0u;
   1306              }
   1307          
   1308              OSTmrCreate(&p_tmr->Tmr,                                    // Create tmr obj.
   1309                          (CPU_CHAR *)p_name,
   1310                          tmr_dly,
   1311                          tmr_period,
   1312                          opt_os,
   1313                          KAL_TmrFnctWrapper,
   1314                          (void *)p_tmr,
   1315                          p_err);
   1316              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {
   1317                handle.TmrObjPtr = p_tmr;
   1318                LOG_VRB(("KAL_TmrCreate call successful."));
   1319              } else {
   1320                RTOS_ERR local_err;
   1321          
   1322                LOG_DBG(("Call to OSTmrCreate failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1323          
   1324                Mem_DynPoolBlkFree(&KAL_DataPtr->TmrPool,
   1325                                   p_tmr,
   1326                                   &local_err);
   1327                RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL, handle);
   1328              }
   1329          
   1330              return (handle);
   1331            }
   1332              #else
   1333            PP_UNUSED_PARAM(p_name);
   1334            PP_UNUSED_PARAM(p_callback);
   1335            PP_UNUSED_PARAM(p_callback_arg);
   1336            PP_UNUSED_PARAM(interval_ms);
   1337            PP_UNUSED_PARAM(p_cfg);
   1338          
   1339            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   \                     ??KAL_TmrCreate_9: (+1)
   \       0xBA   0x2006             MOVS     R0,#+6
   \       0xBC   0x7030             STRB     R0,[R6, #+0]
   \       0xBE   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0xC2   0x6070             STR      R0,[R6, #+4]
   \       0xC4   0xF240 0x503B      MOVW     R0,#+1339
   \       0xC8   0x60B0             STR      R0,[R6, #+8]
   \       0xCA   0x.... 0x....      LDR.W    R0,??DataTable27_13
   \       0xCE   0x60F0             STR      R0,[R6, #+12]
   1340          
   1341            return (handle);
   \       0xD0   0x4648             MOV      R0,R9
   \                     ??KAL_TmrCreate_10: (+1)
   \       0xD2   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1342              #endif
   1343          }
   1344          
   1345          /****************************************************************************************************//**
   1346           *                                               KAL_TmrStart()
   1347           *
   1348           * @brief    Start timer.
   1349           *
   1350           * @param    tmr_handle  Handle of timer to start.
   1351           *
   1352           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1353           *                       from this function:
   1354           *                           - RTOS_ERR_NONE
   1355           *                           - RTOS_ERR_NOT_AVAIL
   1356           *                           - RTOS_ERR_NOT_INIT
   1357           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1358          void KAL_TmrStart(KAL_TMR_HANDLE tmr_handle,
   1359                            RTOS_ERR       *p_err)
   1360          {
   \                     KAL_TmrStart: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1361            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1362            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??KAL_TmrStart_0
   \        0xA   0x.... 0x....      BL       CPU_SW_Exception
   1363          
   1364            RTOS_ASSERT_DBG_ERR_SET((KAL_TMR_HANDLE_IS_NULL(tmr_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_TmrStart_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable27_11
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x4285             CMP      R5,R0
   \       0x16   0xD10B             BNE.N    ??KAL_TmrStart_1
   \       0x18   0x200A             MOVS     R0,#+10
   \       0x1A   0x7020             STRB     R0,[R4, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x20   0x6060             STR      R0,[R4, #+4]
   \       0x22   0xF240 0x5054      MOVW     R0,#+1364
   \       0x26   0x60A0             STR      R0,[R4, #+8]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable27_14
   \       0x2C   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_TmrStart_2: (+1)
   \       0x2E   0xE7FE             B.N      ??KAL_TmrStart_2
   1365          
   1366              #if (OS_CFG_TMR_EN == DEF_ENABLED)
   1367            {
   1368              KAL_TMR *p_tmr;
   1369          
   1370              p_tmr = (KAL_TMR *)tmr_handle.TmrObjPtr;
   1371          
   1372              OSTmrStart(&p_tmr->Tmr,
   1373                         p_err);
   1374              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1375                LOG_DBG(("Call to OSTmrStart failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1376              }
   1377          
   1378              return;
   1379            }
   1380              #else
   1381            PP_UNUSED_PARAM(tmr_handle);
   1382          
   1383            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   \                     ??KAL_TmrStart_1: (+1)
   \       0x30   0x2006             MOVS     R0,#+6
   \       0x32   0x7020             STRB     R0,[R4, #+0]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x38   0x6060             STR      R0,[R4, #+4]
   \       0x3A   0xF240 0x5067      MOVW     R0,#+1383
   \       0x3E   0x60A0             STR      R0,[R4, #+8]
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable27_14
   \       0x44   0x60E0             STR      R0,[R4, #+12]
   1384          
   1385            return;
   \       0x46   0xBD31             POP      {R0,R4,R5,PC}
   1386              #endif
   1387          }
   1388          
   1389          /********************************************************************************************************
   1390           *                                           Q API FUNCTIONS
   1391           *******************************************************************************************************/
   1392          
   1393          /****************************************************************************************************//**
   1394           *                                               KAL_QCreate()
   1395           *
   1396           * @brief    Create an empty queue.
   1397           *
   1398           * @param    p_name          Pointer to name of the queue.
   1399           *
   1400           * @param    max_msg_qty     Maximum number of message contained in the queue.
   1401           *
   1402           * @param    p_cfg           Pointer to KAL queue configuration structure.
   1403           *
   1404           * @param    p_err           Pointer to the variable that will receive one of the following error
   1405           *                           code(s) from this function:
   1406           *                               - RTOS_ERR_NONE
   1407           *                               - RTOS_ERR_NOT_AVAIL
   1408           *                               - RTOS_ERR_OS_ILLEGAL_RUN_TIME
   1409           *                               - RTOS_ERR_SEG_OVF
   1410           *
   1411           * @return   Created queue handle.
   1412           *
   1413           * @note     (1) This function will initialize KAL if KAL has not yet been initialized.
   1414           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1415          KAL_Q_HANDLE KAL_QCreate(const CPU_CHAR *p_name,
   1416                                   KAL_MSG_QTY    max_msg_qty,
   1417                                   KAL_Q_EXT_CFG  *p_cfg,
   1418                                   RTOS_ERR       *p_err)
   1419          {
   \                     KAL_QCreate: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
   1420            KAL_Q_HANDLE handle = KAL_QHandleNull;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable27_15
   \       0x10   0x6807             LDR      R7,[R0, #+0]
   1421          
   1422            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1423            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, handle);
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??KAL_QCreate_0
   \       0x16   0x.... 0x....      BL       CPU_SW_Exception
   1424          
   1425            //                                                               Make sure no unsupported cfg recv.
   1426            RTOS_ASSERT_DBG_ERR_SET((p_cfg == DEF_NULL), *p_err, RTOS_ERR_NOT_SUPPORTED, handle);
   \                     ??KAL_QCreate_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD00A             BEQ.N    ??KAL_QCreate_1
   \       0x1E   0x2007             MOVS     R0,#+7
   \       0x20   0x7028             STRB     R0,[R5, #+0]
   \       0x22   0x....             LDR.N    R0,??DataTable23_1
   \       0x24   0x6068             STR      R0,[R5, #+4]
   \       0x26   0xF240 0x5092      MOVW     R0,#+1426
   \       0x2A   0x60A8             STR      R0,[R5, #+8]
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable27_16
   \       0x30   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_QCreate_2: (+1)
   \       0x32   0xE7FE             B.N      ??KAL_QCreate_2
   1427          
   1428            if (KAL_DataPtr == DEF_NULL) {
   \                     ??KAL_QCreate_1: (+1)
   \       0x34   0x....             LDR.N    R0,??DataTable23_3
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD107             BNE.N    ??KAL_QCreate_3
   1429              KAL_Init(p_err);                                            // KAL initialization (see Note #1).
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x.... 0x....      BL       KAL_Init
   1430              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x42   0x7828             LDRB     R0,[R5, #+0]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD001             BEQ.N    ??KAL_QCreate_3
   1431                return(handle);
   \       0x48   0x0038             MOVS     R0,R7
   \       0x4A   0xE01B             B.N      ??KAL_QCreate_4
   1432              }
   1433            }
   1434          
   1435              #if (OS_CFG_Q_EN == DEF_ENABLED)
   1436            {
   1437              MEM_SEG *p_mem_seg;
   1438              OS_Q    *p_q;
   1439          
   1440              p_mem_seg = Common_MemSegPtrGet();
   \                     ??KAL_QCreate_3: (+1)
   \       0x4C   0x.... 0x....      BL       Common_MemSegPtrGet
   \       0x50   0x4680             MOV      R8,R0
   1441          
   1442              p_q = (OS_Q *)Mem_SegAlloc("KAL Q",
   1443                                         p_mem_seg,
   1444                                         sizeof(OS_Q),
   1445                                         p_err);
   \       0x52   0x002B             MOVS     R3,R5
   \       0x54   0x2218             MOVS     R2,#+24
   \       0x56   0x4641             MOV      R1,R8
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable27_17
   \       0x5C   0x.... 0x....      BL       Mem_SegAlloc
   \       0x60   0x4681             MOV      R9,R0
   1446              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x62   0x7828             LDRB     R0,[R5, #+0]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD001             BEQ.N    ??KAL_QCreate_5
   1447                return (handle);
   \       0x68   0x0038             MOVS     R0,R7
   \       0x6A   0xE00B             B.N      ??KAL_QCreate_4
   1448              }
   1449          
   1450              OSQCreate(p_q,
   1451                        (CPU_CHAR *)p_name,
   1452                        max_msg_qty,
   1453                        p_err);
   \                     ??KAL_QCreate_5: (+1)
   \       0x6C   0x002B             MOVS     R3,R5
   \       0x6E   0x0032             MOVS     R2,R6
   \       0x70   0xB292             UXTH     R2,R2
   \       0x72   0x4651             MOV      R1,R10
   \       0x74   0x4648             MOV      R0,R9
   \       0x76   0x.... 0x....      BL       OSQCreate
   1454              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {
   \       0x7A   0x7828             LDRB     R0,[R5, #+0]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD100             BNE.N    ??KAL_QCreate_6
   1455                handle.QObjPtr = (void *)p_q;
   \       0x80   0x464F             MOV      R7,R9
   1456                LOG_VRB(("KAL_QCreate call successful."));
   1457              } else {
   1458                LOG_DBG(("Call to OSQCreate failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err), ". Memory allocated for Q is lost."));
   1459              }
   1460          
   1461              return (handle);
   \                     ??KAL_QCreate_6: (+1)
   \       0x82   0x0038             MOVS     R0,R7
   \                     ??KAL_QCreate_4: (+1)
   \       0x84   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1462            }
   1463              #else
   1464            PP_UNUSED_PARAM(p_name);
   1465            PP_UNUSED_PARAM(max_msg_qty);
   1466          
   1467            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   1468          
   1469            return (handle);
   1470              #endif
   1471          }
   1472          
   1473          /****************************************************************************************************//**
   1474           *                                               KAL_QPend()
   1475           *
   1476           * @brief    Pend/get first message of queue.
   1477           *
   1478           * @param    q_handle    Handle of the queue to pend on.
   1479           *
   1480           * @param    opt         Options available:
   1481           *                           - KAL_OPT_PEND_NONE:          block until timeout expires or message is available.
   1482           *                           - KAL_OPT_PEND_BLOCKING:      block until timeout expires or message is available.
   1483           *                           - KAL_OPT_PEND_NON_BLOCKING:  return immediately with or without message.
   1484           *
   1485           * @param    timeout_ms  Timeout, in milliseconds. A value of 0 will never timeout.
   1486           *
   1487           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1488           *                       from this function:
   1489           *                           - RTOS_ERR_NONE
   1490           *                           - RTOS_ERR_NOT_AVAIL
   1491           *                           - RTOS_ERR_OS_OBJ_DEL
   1492           *                           - RTOS_ERR_NOT_FOUND
   1493           *                           - RTOS_ERR_WOULD_BLOCK
   1494           *                           - RTOS_ERR_OS_SCHED_LOCKED
   1495           *                           - RTOS_ERR_ABORT
   1496           *                           - RTOS_ERR_TIMEOUT
   1497           *
   1498           * @return   Pointer to message obtained, if any, if no error.
   1499           *           Null pointer, otherwise.
   1500           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1501          void *KAL_QPend(KAL_Q_HANDLE q_handle,
   1502                          KAL_OPT      opt,
   1503                          CPU_INT32U   timeout_ms,
   1504                          RTOS_ERR     *p_err)
   1505          {
   \                     KAL_QPend: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
   1506            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1507            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_NULL);
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??KAL_QPend_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
   1508          
   1509            RTOS_ASSERT_DBG_ERR_SET((KAL_Q_HANDLE_IS_NULL(q_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR, DEF_NULL);
   \                     ??KAL_QPend_0: (+1)
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable27_15
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x4286             CMP      R6,R0
   \       0x1C   0xD10A             BNE.N    ??KAL_QPend_1
   \       0x1E   0x200A             MOVS     R0,#+10
   \       0x20   0x7028             STRB     R0,[R5, #+0]
   \       0x22   0x....             LDR.N    R0,??DataTable23_1
   \       0x24   0x6068             STR      R0,[R5, #+4]
   \       0x26   0xF240 0x50E5      MOVW     R0,#+1509
   \       0x2A   0x60A8             STR      R0,[R5, #+8]
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable27_18
   \       0x30   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_QPend_2: (+1)
   \       0x32   0xE7FE             B.N      ??KAL_QPend_2
   1510          
   1511            RTOS_ASSERT_DBG_ERR_SET((DEF_BIT_IS_SET_ANY(opt, (KAL_OPT)(~(KAL_OPT_PEND_NONE | KAL_OPT_PEND_NON_BLOCKING))) == DEF_NO), *p_err, RTOS_ERR_INVALID_ARG, DEF_NULL);
   \                     ??KAL_QPend_1: (+1)
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0xF010 0x0FFE      TST      R0,#0xFE
   \       0x3C   0xD00A             BEQ.N    ??KAL_QPend_3
   \       0x3E   0x2008             MOVS     R0,#+8
   \       0x40   0x7028             STRB     R0,[R5, #+0]
   \       0x42   0x....             LDR.N    R0,??DataTable23_1
   \       0x44   0x6068             STR      R0,[R5, #+4]
   \       0x46   0xF240 0x50E7      MOVW     R0,#+1511
   \       0x4A   0x60A8             STR      R0,[R5, #+8]
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable27_18
   \       0x50   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_QPend_4: (+1)
   \       0x52   0xE7FE             B.N      ??KAL_QPend_4
   1512          
   1513              #if (OS_CFG_Q_EN == DEF_ENABLED)
   1514            {
   1515              void        *p_msg;
   1516              CPU_INT32U  timeout_ticks;
   1517              OS_MSG_SIZE msg_size;
   1518              OS_OPT      opt_os;
   1519          
   1520              if (timeout_ms != KAL_TIMEOUT_INFINITE) {
   \                     ??KAL_QPend_3: (+1)
   \       0x54   0x2C00             CMP      R4,#+0
   \       0x56   0xD004             BEQ.N    ??KAL_QPend_5
   1521                timeout_ticks = KAL_msToTicks(timeout_ms);
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x.... 0x....      BL       KAL_msToTicks
   \       0x5E   0x4680             MOV      R8,R0
   \       0x60   0xE001             B.N      ??KAL_QPend_6
   1522              } else {
   1523                timeout_ticks = 0u;
   \                     ??KAL_QPend_5: (+1)
   \       0x62   0xF05F 0x0800      MOVS     R8,#+0
   1524              }
   1525          
   1526              opt_os = OS_OPT_NONE;
   \                     ??KAL_QPend_6: (+1)
   \       0x66   0xF05F 0x0900      MOVS     R9,#+0
   1527              if (DEF_BIT_IS_CLR(opt, KAL_OPT_PEND_NON_BLOCKING) == DEF_YES) {
   \       0x6A   0x07F8             LSLS     R0,R7,#+31
   \       0x6C   0xD501             BPL.N    ??KAL_QPend_7
   1528                opt_os |= OS_OPT_PEND_BLOCKING;
   1529              } else {
   1530                opt_os |= OS_OPT_PEND_NON_BLOCKING;
   \                     ??KAL_QPend_8: (+1)
   \       0x6E   0xF459 0x4900      ORRS     R9,R9,#0x8000
   1531              }
   1532          
   1533              p_msg = OSQPend((OS_Q *)q_handle.QObjPtr,
   1534                              timeout_ticks,
   1535                              opt_os,
   1536                              &msg_size,
   1537                              DEF_NULL,
   1538                              p_err);
   \                     ??KAL_QPend_7: (+1)
   \       0x72   0x9501             STR      R5,[SP, #+4]
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x9000             STR      R0,[SP, #+0]
   \       0x78   0xAB02             ADD      R3,SP,#+8
   \       0x7A   0x464A             MOV      R2,R9
   \       0x7C   0xB292             UXTH     R2,R2
   \       0x7E   0x4641             MOV      R1,R8
   \       0x80   0x0030             MOVS     R0,R6
   \       0x82   0x.... 0x....      BL       OSQPend
   1539              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1540                LOG_DBG(("Call to OSQPend failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1541              }
   1542          
   1543              return (p_msg);
   \       0x86   0xE8BD 0x83FE      POP      {R1-R9,PC}
   1544            }
   1545              #else
   1546            PP_UNUSED_PARAM(q_handle);
   1547            PP_UNUSED_PARAM(opt);
   1548            PP_UNUSED_PARAM(timeout_ms);
   1549          
   1550            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   1551          
   1552            return (DEF_NULL);
   1553              #endif
   1554          }
   1555          
   1556          /****************************************************************************************************//**
   1557           *                                               KAL_QPost()
   1558           *
   1559           * @brief    Post message on queue.
   1560           *
   1561           * @param    q_handle    Handle of the queue on which to post message.
   1562           *
   1563           * @param    p_msg       Pointer to message to post.
   1564           *
   1565           * @param    opt         Options available:
   1566           *                       KAL_OPT_POST_NONE:     wake only the highest priority task pending on queue.
   1567           *
   1568           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1569           *                       from this function:
   1570           *                           - RTOS_ERR_NONE
   1571           *                           - RTOS_ERR_NOT_AVAIL
   1572           *                           - RTOS_ERR_WOULD_OVF
   1573           *                           - RTOS_ERR_NO_MORE_RSRC
   1574           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1575          void KAL_QPost(KAL_Q_HANDLE q_handle,
   1576                         void         *p_msg,
   1577                         KAL_OPT      opt,
   1578                         RTOS_ERR     *p_err)
   1579          {
   \                     KAL_QPost: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
   \        0x8   0x001C             MOVS     R4,R3
   1580            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1581            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??KAL_QPost_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
   1582          
   1583            RTOS_ASSERT_DBG_ERR_SET((KAL_Q_HANDLE_IS_NULL(q_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_QPost_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable27_15
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x4285             CMP      R5,R0
   \       0x1A   0xD10A             BNE.N    ??KAL_QPost_1
   \       0x1C   0x200A             MOVS     R0,#+10
   \       0x1E   0x7020             STRB     R0,[R4, #+0]
   \       0x20   0x....             LDR.N    R0,??DataTable23_1
   \       0x22   0x6060             STR      R0,[R4, #+4]
   \       0x24   0xF240 0x602F      MOVW     R0,#+1583
   \       0x28   0x60A0             STR      R0,[R4, #+8]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable27_19
   \       0x2E   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_QPost_2: (+1)
   \       0x30   0xE7FE             B.N      ??KAL_QPost_2
   1584          
   1585            RTOS_ASSERT_DBG_ERR_SET((opt == KAL_OPT_POST_NONE), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??KAL_QPost_1: (+1)
   \       0x32   0x0038             MOVS     R0,R7
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD00A             BEQ.N    ??KAL_QPost_3
   \       0x3A   0x2008             MOVS     R0,#+8
   \       0x3C   0x7020             STRB     R0,[R4, #+0]
   \       0x3E   0x....             LDR.N    R0,??DataTable23_1
   \       0x40   0x6060             STR      R0,[R4, #+4]
   \       0x42   0xF240 0x6031      MOVW     R0,#+1585
   \       0x46   0x60A0             STR      R0,[R4, #+8]
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable27_19
   \       0x4C   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_QPost_4: (+1)
   \       0x4E   0xE7FE             B.N      ??KAL_QPost_4
   1586          
   1587              #if (OS_CFG_Q_EN == DEF_ENABLED)                            // Qs are available.
   1588            {
   1589              OSQPost((OS_Q *)q_handle.QObjPtr,
   1590                      p_msg,
   1591                      0u,
   1592                      OS_OPT_POST_1,
   1593                      p_err);
   \                     ??KAL_QPost_3: (+1)
   \       0x50   0x9400             STR      R4,[SP, #+0]
   \       0x52   0x2300             MOVS     R3,#+0
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x0031             MOVS     R1,R6
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0x.... 0x....      BL       OSQPost
   1594              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {
   1595                LOG_DBG(("Call to OSQPost failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1596              }
   1597          
   1598              return;
   \       0x5E   0xBDF1             POP      {R0,R4-R7,PC}
   1599            }
   1600              #else
   1601            PP_UNUSED_PARAM(q_handle);
   1602            PP_UNUSED_PARAM(p_msg);
   1603          
   1604            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   1605          
   1606            return;
   1607              #endif
   1608          }
   1609          
   1610          /********************************************************************************************************
   1611           *                                           MON API FUNCTIONS
   1612           *******************************************************************************************************/
   1613          
   1614          /****************************************************************************************************//**
   1615           *                                               KAL_MonCreate()
   1616           *
   1617           * @brief    Create a monitor.
   1618           *
   1619           * @param    p_name      Pointer to name of the monitor.
   1620           *
   1621           * @param    p_mon_obj   Pointer to monitor object, if any. If DEF_NULL, monitor object will be
   1622           *                       allocated from monitor pool by KAL.
   1623           *
   1624           * @param    p_mon_data  Pointer to data that will be passed to callback functions.
   1625           *
   1626           * @param    p_cfg       Pointer to KAL monitor configuration structure. Reserved for future use, must
   1627           *                       be DEF_NULL.
   1628           *
   1629           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1630           *                       from this function:
   1631           *                           - RTOS_ERR_NONE
   1632           *                           - RTOS_ERR_NOT_AVAIL
   1633           *                           - RTOS_ERR_OS_ILLEGAL_RUN_TIME
   1634           *                           - RTOS_ERR_POOL_EMPTY
   1635           *                           - RTOS_ERR_BLK_ALLOC_CALLBACK
   1636           *                           - RTOS_ERR_SEG_OVF
   1637           *
   1638           * @return   Created monitor handle.
   1639           *
   1640           * @note     (1) This function will initialize KAL if KAL has not yet been initialized.
   1641           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1642          KAL_MON_HANDLE KAL_MonCreate(const CPU_CHAR  *p_name,
   1643                                       void            *p_mon_obj,
   1644                                       void            *p_mon_data,
   1645                                       KAL_MON_EXT_CFG *p_cfg,
   1646                                       RTOS_ERR        *p_err)
   1647          {
   \                     KAL_MonCreate: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x001D             MOVS     R5,R3
   \        0xE   0x9E0E             LDR      R6,[SP, #+56]
   1648            KAL_MON_HANDLE handle = KAL_MonHandleNull;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable27_20
   \       0x14   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   1649          
   1650            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1651            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, handle);
   \       0x18   0x2E00             CMP      R6,#+0
   \       0x1A   0xD101             BNE.N    ??KAL_MonCreate_0
   \       0x1C   0x.... 0x....      BL       CPU_SW_Exception
   1652          
   1653            //                                                               Make sure no unsupported cfg recv.
   1654            RTOS_ASSERT_DBG_ERR_SET((p_cfg == DEF_NULL), *p_err, RTOS_ERR_NOT_SUPPORTED, handle);
   \                     ??KAL_MonCreate_0: (+1)
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD00A             BEQ.N    ??KAL_MonCreate_1
   \       0x24   0x2007             MOVS     R0,#+7
   \       0x26   0x7030             STRB     R0,[R6, #+0]
   \       0x28   0x....             LDR.N    R0,??DataTable23_1
   \       0x2A   0x6070             STR      R0,[R6, #+4]
   \       0x2C   0xF240 0x6076      MOVW     R0,#+1654
   \       0x30   0x60B0             STR      R0,[R6, #+8]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable27_21
   \       0x36   0x60F0             STR      R0,[R6, #+12]
   \                     ??KAL_MonCreate_2: (+1)
   \       0x38   0xE7FE             B.N      ??KAL_MonCreate_2
   1655          
   1656            if (KAL_DataPtr == DEF_NULL) {
   \                     ??KAL_MonCreate_1: (+1)
   \       0x3A   0x.... 0x....      LDR.W    R9,??DataTable27_2
   \       0x3E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD107             BNE.N    ??KAL_MonCreate_3
   1657              KAL_Init(p_err);                                            // KAL initialization (see Note #1).
   \       0x46   0x0030             MOVS     R0,R6
   \       0x48   0x.... 0x....      BL       KAL_Init
   1658              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x4C   0x7830             LDRB     R0,[R6, #+0]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD001             BEQ.N    ??KAL_MonCreate_3
   1659                return(handle);
   \       0x52   0x4640             MOV      R0,R8
   \       0x54   0xE029             B.N      ??KAL_MonCreate_4
   1660              }
   1661            }
   1662          
   1663              #if (OS_CFG_MON_EN == DEF_ENABLED)
   1664            {
   1665              void *p_mon_obj_local;
   1666          
   1667              if (p_mon_obj == DEF_NULL) {                                // Allocate mon obj if req'd.
   \                     ??KAL_MonCreate_3: (+1)
   \       0x56   0x2C00             CMP      R4,#+0
   \       0x58   0xD10B             BNE.N    ??KAL_MonCreate_5
   1668                p_mon_obj_local = Mem_DynPoolBlkGet(&KAL_DataPtr->MonPool,
   1669                                                    p_err);
   \       0x5A   0x0031             MOVS     R1,R6
   \       0x5C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x60   0x3048             ADDS     R0,R0,#+72
   \       0x62   0x.... 0x....      BL       Mem_DynPoolBlkGet
   \       0x66   0x4682             MOV      R10,R0
   1670                if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x68   0x7830             LDRB     R0,[R6, #+0]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD002             BEQ.N    ??KAL_MonCreate_6
   1671                  LOG_DBG(("KAL_MonCreate: failed to allocate mon data."));
   1672                  return (handle);
   \       0x6E   0x4640             MOV      R0,R8
   \       0x70   0xE01B             B.N      ??KAL_MonCreate_4
   1673                }
   1674              } else {
   1675                p_mon_obj_local = p_mon_obj;
   \                     ??KAL_MonCreate_5: (+1)
   \       0x72   0x46A2             MOV      R10,R4
   1676              }
   1677          
   1678              OSMonCreate((OS_MON *)  p_mon_obj_local,
   1679                          (CPU_CHAR *)p_name,
   1680                          p_mon_data,
   1681                          p_err);
   \                     ??KAL_MonCreate_6: (+1)
   \       0x74   0x0033             MOVS     R3,R6
   \       0x76   0x003A             MOVS     R2,R7
   \       0x78   0x4659             MOV      R1,R11
   \       0x7A   0x4650             MOV      R0,R10
   \       0x7C   0x.... 0x....      BL       OSMonCreate
   1682              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {
   \       0x80   0x7830             LDRB     R0,[R6, #+0]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD101             BNE.N    ??KAL_MonCreate_7
   1683                handle.MonObjPtr = p_mon_obj_local;
   \       0x86   0x46D0             MOV      R8,R10
   \       0x88   0xE00E             B.N      ??KAL_MonCreate_8
   1684                LOG_VRB(("KAL_MonCreate call successful."));
   1685              } else {
   1686                LOG_DBG(("Call to OSMonCreate failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1687          
   1688                if (p_mon_obj == DEF_NULL) {
   \                     ??KAL_MonCreate_7: (+1)
   \       0x8A   0x2C00             CMP      R4,#+0
   \       0x8C   0xD10C             BNE.N    ??KAL_MonCreate_8
   1689                  RTOS_ERR local_err;
   1690          
   1691                  Mem_DynPoolBlkFree(&KAL_DataPtr->MonPool,
   1692                                     p_mon_obj_local,
   1693                                     &local_err);
   \       0x8E   0x466A             MOV      R2,SP
   \       0x90   0x4651             MOV      R1,R10
   \       0x92   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x96   0x3048             ADDS     R0,R0,#+72
   \       0x98   0x.... 0x....      BL       Mem_DynPoolBlkFree
   1694                  RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL, handle);
   \       0x9C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD001             BEQ.N    ??KAL_MonCreate_8
   \       0xA4   0x.... 0x....      BL       CPU_SW_Exception
   1695                }
   1696              }
   1697          
   1698              return (handle);
   \                     ??KAL_MonCreate_8: (+1)
   \       0xA8   0x4640             MOV      R0,R8
   \                     ??KAL_MonCreate_4: (+1)
   \       0xAA   0xB005             ADD      SP,SP,#+20
   \       0xAC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1699            }
   1700              #else
   1701            PP_UNUSED_PARAM(p_name);
   1702            PP_UNUSED_PARAM(p_mon_obj);
   1703            PP_UNUSED_PARAM(p_mon_data);
   1704          
   1705            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   1706          
   1707            return (handle);
   1708              #endif
   1709          }
   1710          
   1711          /****************************************************************************************************//**
   1712           *                                               KAL_MonOp()
   1713           *
   1714           * @brief    Execute an operation on a monitor.
   1715           *
   1716           * @param    mon_handle      Handle of the monitor on which operation is executed.
   1717           *
   1718           * @param    p_op_data       Pointer to arg that will be passed to callback functions.
   1719           *
   1720           * @param    on_enter_fnct   Function that will be called on entering the monitor.
   1721           *
   1722           * @param    on_eval_fnct    Function that will be called when evaluating if this task can run.
   1723           *
   1724           * @param    opt             Options for call.
   1725           *                               - KAL_OPT_MON_NONE            No option.
   1726           *                               - KAL_OPT_MON_NO_SCHED        Scheduler will not be called.
   1727           *
   1728           * @param    timeout_ms      Timeout, in milliseconds. A value of KAL_TIMEOUT_INFINITE will never timeout.
   1729           *
   1730           * @param    p_err           Pointer to the variable that will receive one of the following error
   1731           *                           code(s) from this function:
   1732           *                               - RTOS_ERR_NONE
   1733           *                               - RTOS_ERR_NOT_AVAIL
   1734           *                               - RTOS_ERR_OS_OBJ_DEL
   1735           *                               - RTOS_ERR_ABORT
   1736           *                               - RTOS_ERR_TIMEOUT
   1737           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1738          void KAL_MonOp(KAL_MON_HANDLE mon_handle,
   1739                         void *p_op_data,
   1740                         KAL_MON_RES (*on_enter_fnct)(void *p_mon_data, void *p_op_data),
   1741                         KAL_MON_RES (*on_eval_fnct)(void *p_mon_data, void *p_eval_op_data, void *p_scan_op_data),
   1742                         KAL_OPT opt,
   1743                         KAL_TICK timeout_ms,
   1744                         RTOS_ERR *p_err)
   1745          {
   \                     KAL_MonOp: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x4698             MOV      R8,R3
   \        0x8   0x9E12             LDR      R6,[SP, #+72]
   \        0xA   0x9C13             LDR      R4,[SP, #+76]
   \        0xC   0x9D14             LDR      R5,[SP, #+80]
   1746            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1747            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD101             BNE.N    ??KAL_MonOp_0
   \       0x12   0x.... 0x....      BL       CPU_SW_Exception
   1748          
   1749            RTOS_ASSERT_DBG_ERR_SET((KAL_MON_HANDLE_IS_NULL(mon_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_MonOp_0: (+1)
   \       0x16   0x9806             LDR      R0,[SP, #+24]
   \       0x18   0x.... 0x....      LDR.W    R1,??DataTable27_20
   \       0x1C   0x6809             LDR      R1,[R1, #+0]
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD10A             BNE.N    ??KAL_MonOp_1
   \       0x22   0x200A             MOVS     R0,#+10
   \       0x24   0x7028             STRB     R0,[R5, #+0]
   \       0x26   0x....             LDR.N    R0,??DataTable23_1
   \       0x28   0x6068             STR      R0,[R5, #+4]
   \       0x2A   0xF240 0x60D5      MOVW     R0,#+1749
   \       0x2E   0x60A8             STR      R0,[R5, #+8]
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable27_22
   \       0x34   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_MonOp_2: (+1)
   \       0x36   0xE7FE             B.N      ??KAL_MonOp_2
   1750          
   1751            RTOS_ASSERT_DBG_ERR_SET((DEF_BIT_IS_SET_ANY(opt, (KAL_OPT)(~(KAL_OPT_MON_NONE | KAL_OPT_MON_NO_SCHED))) == DEF_NO), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??KAL_MonOp_1: (+1)
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0xF010 0x0FFE      TST      R0,#0xFE
   \       0x40   0xD00A             BEQ.N    ??KAL_MonOp_3
   \       0x42   0x2008             MOVS     R0,#+8
   \       0x44   0x7028             STRB     R0,[R5, #+0]
   \       0x46   0x....             LDR.N    R0,??DataTable23_1
   \       0x48   0x6068             STR      R0,[R5, #+4]
   \       0x4A   0xF240 0x60D7      MOVW     R0,#+1751
   \       0x4E   0x60A8             STR      R0,[R5, #+8]
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable27_22
   \       0x54   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_MonOp_4: (+1)
   \       0x56   0xE7FE             B.N      ??KAL_MonOp_4
   1752          
   1753              #if (OS_CFG_MON_EN == DEF_ENABLED)
   1754            {
   1755              OS_OPT               opt_os = OS_OPT_POST_NONE;
   \                     ??KAL_MonOp_3: (+1)
   \       0x58   0x2700             MOVS     R7,#+0
   1756              KAL_MON_DATA_WRAPPER arg_wrapper;
   1757              CPU_INT32U           timeout_ticks;
   1758              OS_MON_ON_ENTER_PTR  on_enter_local;
   1759              OS_MON_ON_EVAL_PTR   on_eval_local;
   1760          
   1761              arg_wrapper.DataPtr = p_op_data;
   \       0x5A   0x9807             LDR      R0,[SP, #+28]
   \       0x5C   0x9003             STR      R0,[SP, #+12]
   1762              arg_wrapper.EnterFnct = on_enter_fnct;
   \       0x5E   0x9808             LDR      R0,[SP, #+32]
   \       0x60   0x9004             STR      R0,[SP, #+16]
   1763              arg_wrapper.EvalFnct = on_eval_fnct;
   \       0x62   0xF8CD 0x8014      STR      R8,[SP, #+20]
   1764          
   1765              if (timeout_ms == KAL_TIMEOUT_INFINITE) {
   \       0x66   0x2C00             CMP      R4,#+0
   \       0x68   0xD102             BNE.N    ??KAL_MonOp_5
   1766                timeout_ticks = 0u;
   \       0x6A   0xF05F 0x0900      MOVS     R9,#+0
   \       0x6E   0xE003             B.N      ??KAL_MonOp_6
   1767              } else {
   1768                timeout_ticks = KAL_msToTicks(timeout_ms);
   \                     ??KAL_MonOp_5: (+1)
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x.... 0x....      BL       KAL_msToTicks
   \       0x76   0x4681             MOV      R9,R0
   1769              }
   1770          
   1771              if (DEF_BIT_IS_SET(opt, KAL_OPT_MON_NO_SCHED) == DEF_YES) {
   \                     ??KAL_MonOp_6: (+1)
   \       0x78   0x07F0             LSLS     R0,R6,#+31
   \       0x7A   0xD501             BPL.N    ??KAL_MonOp_7
   1772                DEF_BIT_SET(opt_os, OS_OPT_POST_NO_SCHED);
   \       0x7C   0xF457 0x4700      ORRS     R7,R7,#0x8000
   1773              }
   1774          
   1775              if (on_enter_fnct != DEF_NULL) {
   \                     ??KAL_MonOp_7: (+1)
   \       0x80   0x9808             LDR      R0,[SP, #+32]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD002             BEQ.N    ??KAL_MonOp_8
   1776                on_enter_local = KAL_MonEnterFnct;
   \       0x86   0x.... 0x....      ADR.W    R11,KAL_MonEnterFnct
   \       0x8A   0xE001             B.N      ??KAL_MonOp_9
   1777              } else {
   1778                on_enter_local = DEF_NULL;
   \                     ??KAL_MonOp_8: (+1)
   \       0x8C   0xF05F 0x0B00      MOVS     R11,#+0
   1779              }
   1780          
   1781              if (on_eval_fnct != DEF_NULL) {
   \                     ??KAL_MonOp_9: (+1)
   \       0x90   0x4640             MOV      R0,R8
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD002             BEQ.N    ??KAL_MonOp_10
   1782                on_eval_local = KAL_MonEvalFnct;
   \       0x96   0x.... 0x....      ADR.W    R10,KAL_MonEvalFnct
   \       0x9A   0xE001             B.N      ??KAL_MonOp_11
   1783              } else {
   1784                on_eval_local = DEF_NULL;
   \                     ??KAL_MonOp_10: (+1)
   \       0x9C   0xF05F 0x0A00      MOVS     R10,#+0
   1785              }
   1786          
   1787              OSMonOp((OS_MON *)mon_handle.MonObjPtr,
   1788                      timeout_ticks,
   1789                      &arg_wrapper,
   1790                      on_enter_local,
   1791                      on_eval_local,
   1792                      opt_os,
   1793                      p_err);
   \                     ??KAL_MonOp_11: (+1)
   \       0xA0   0x9502             STR      R5,[SP, #+8]
   \       0xA2   0x0038             MOVS     R0,R7
   \       0xA4   0xB280             UXTH     R0,R0
   \       0xA6   0x9001             STR      R0,[SP, #+4]
   \       0xA8   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \       0xAC   0x465B             MOV      R3,R11
   \       0xAE   0xAA03             ADD      R2,SP,#+12
   \       0xB0   0x4649             MOV      R1,R9
   \       0xB2   0x9806             LDR      R0,[SP, #+24]
   \       0xB4   0x.... 0x....      BL       OSMonOp
   1794              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1795                LOG_DBG(("Call to OSMonOp failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1796              }
   1797          
   1798              return;
   \       0xB8   0xB009             ADD      SP,SP,#+36
   \       0xBA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1799            }
   1800              #else
   1801            PP_UNUSED_PARAM(mon_handle);
   1802            PP_UNUSED_PARAM(p_op_data);
   1803            PP_UNUSED_PARAM(on_enter_fnct);
   1804            PP_UNUSED_PARAM(on_eval_fnct);
   1805            PP_UNUSED_PARAM(opt);
   1806            PP_UNUSED_PARAM(timeout_ms);
   1807          
   1808            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   1809          
   1810            return;
   1811              #endif
   1812          }
   1813          
   1814          /****************************************************************************************************//**
   1815           *                                               KAL_MonDel()
   1816           *
   1817           * @brief    Delete a monitor.
   1818           *
   1819           * @param    mon_handle  Handle of the monitor to delete.
   1820           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1821          void KAL_MonDel(KAL_MON_HANDLE mon_handle)
   1822          {
   \                     KAL_MonDel: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1823            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1824            RTOS_ASSERT_DBG((KAL_MON_HANDLE_IS_NULL(mon_handle) == DEF_NO), RTOS_ERR_NULL_PTR,; );
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable27_20
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x4284             CMP      R4,R0
   \        0xC   0xD100             BNE.N    ??KAL_MonDel_0
   \                     ??KAL_MonDel_1: (+1)
   \        0xE   0xE7FE             B.N      ??KAL_MonDel_1
   1825          
   1826              #if ((OS_CFG_MON_EN == DEF_ENABLED) \
   1827            && !defined(OS_SAFETY_CRITICAL_IEC61508))
   1828            {
   1829              RTOS_ERR err;
   1830          
   1831              (void)OSMonDel((OS_MON *)mon_handle.MonObjPtr,
   1832                             OS_OPT_DEL_ALWAYS,
   1833                             &err);
   \                     ??KAL_MonDel_0: (+1)
   \       0x10   0x466A             MOV      R2,SP
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       OSMonDel
   1834              //                                                             OSMonDel should not return another err in this case.
   1835              RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \       0x1A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??KAL_MonDel_2
   \       0x22   0x.... 0x....      BL       CPU_SW_Exception
   1836          
   1837              Mem_DynPoolBlkFree(&KAL_DataPtr->MonPool,
   1838                                 mon_handle.MonObjPtr,
   1839                                 &err);
   \                     ??KAL_MonDel_2: (+1)
   \       0x26   0x466A             MOV      R2,SP
   \       0x28   0x0021             MOVS     R1,R4
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \       0x2E   0x6800             LDR      R0,[R0, #+0]
   \       0x30   0x3048             ADDS     R0,R0,#+72
   \       0x32   0x.... 0x....      BL       Mem_DynPoolBlkFree
   1840              RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \       0x36   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD001             BEQ.N    ??KAL_MonDel_3
   \       0x3E   0x.... 0x....      BL       CPU_SW_Exception
   1841          
   1842              return;
   \                     ??KAL_MonDel_3: (+1)
   \       0x42   0xBD1F             POP      {R0-R4,PC}
   1843            }
   1844              #else
   1845            PP_UNUSED_PARAM(mon_handle);
   1846          
   1847            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_NOT_AVAIL,; );
   1848              #endif
   1849          }
   1850          
   1851          /********************************************************************************************************
   1852           *                                           DLY API FUNCTIONS
   1853           *******************************************************************************************************/
   1854          
   1855          /****************************************************************************************************//**
   1856           *                                                   KAL_Dly()
   1857           *
   1858           * @brief    Delay current task (in milliseconds).
   1859           *
   1860           * @param    dly_ms  Delay value, in milliseconds.
   1861           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1862          void KAL_Dly(CPU_INT32U dly_ms)
   1863          {
   \                     KAL_Dly: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   1864          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1865            CPU_INT32U dly_ticks;
   1866            RTOS_ERR   err;
   1867          
   1868            dly_ticks = KAL_msToTicks(dly_ms);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       KAL_msToTicks
   \        0xC   0x0004             MOVS     R4,R0
   1869            if (dly_ticks == 0u) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD00A             BEQ.N    ??KAL_Dly_0
   1870              return;
   1871            }
   1872          
   1873            OSTimeDly(dly_ticks,
   1874                      OS_OPT_TIME_DLY,
   1875                      &err);
   \                     ??KAL_Dly_1: (+1)
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       OSTimeDly
   1876            RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \       0x1C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD001             BEQ.N    ??KAL_Dly_2
   \       0x24   0x.... 0x....      BL       CPU_SW_Exception
   1877          
   1878            return;
   \                     ??KAL_Dly_2: (+1)
   \                     ??KAL_Dly_0: (+1)
   \       0x28   0xB005             ADD      SP,SP,#+20
   \       0x2A   0xBD30             POP      {R4,R5,PC}
   1879          #else
   1880            PP_UNUSED_PARAM(dly_ms);
   1881          
   1882            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_NOT_AVAIL,; );
   1883          #endif
   1884          }
   1885          
   1886          /****************************************************************************************************//**
   1887           *                                               KAL_DlyTick()
   1888           *
   1889           * @brief    Delay current task (in ticks).
   1890           *
   1891           * @param    dly_ticks   Delay value, in ticks.
   1892           *
   1893           * @param    opt         Options available:
   1894           *                           - KAL_OPT_DLY_NONE:       apply a 'normal' delay.
   1895           *                           - KAL_OPT_DLY:            apply a 'normal' delay.
   1896           *                           - KAL_OPT_DLY_PERIODIC:   apply a periodic delay.
   1897           *
   1898           * @note     (1) When used in PERIODIC mode, it is possible that starving the task calling KAL_DlyTick
   1899           *               leads to an error if delay has already passed. This should be considered a design
   1900           *               flaw more than a critical error. If used in normal DLY mode, there is no reason why
   1901           *               an error could be returned so it is a critical assert instead of a debug one.
   1902           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1903          void KAL_DlyTick(KAL_TICK dly_ticks,
   1904                           KAL_OPT  opt)
   1905          {
   \                     KAL_DlyTick: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1906          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1907            OS_OPT   opt_os;
   1908            RTOS_ERR err;
   1909          
   1910            if (dly_ticks == 0u) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD017             BEQ.N    ??KAL_DlyTick_0
   1911              return;
   1912            }
   1913          
   1914            if (DEF_BIT_IS_SET(opt, KAL_OPT_DLY_PERIODIC) == DEF_YES) {
   \                     ??KAL_DlyTick_1: (+1)
   \        0xA   0x07E8             LSLS     R0,R5,#+31
   \        0xC   0xD501             BPL.N    ??KAL_DlyTick_2
   1915              opt_os = OS_OPT_TIME_PERIODIC;
   \        0xE   0x2608             MOVS     R6,#+8
   \       0x10   0xE000             B.N      ??KAL_DlyTick_3
   1916            } else {
   1917              opt_os = OS_OPT_TIME_DLY;
   \                     ??KAL_DlyTick_2: (+1)
   \       0x12   0x2600             MOVS     R6,#+0
   1918            }
   1919          
   1920            OSTimeDly(dly_ticks,
   1921                      opt_os,
   1922                      &err);
   \                     ??KAL_DlyTick_3: (+1)
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x0031             MOVS     R1,R6
   \       0x18   0xB289             UXTH     R1,R1
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       OSTimeDly
   1923          
   1924            if (DEF_BIT_IS_SET(opt, KAL_OPT_DLY_PERIODIC) == DEF_YES) {   // See Note #1.
   \       0x20   0x07E8             LSLS     R0,R5,#+31
   \       0x22   0xD504             BPL.N    ??KAL_DlyTick_4
   1925              RTOS_ASSERT_DBG((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_DBG_FAIL,; );
   \       0x24   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD006             BEQ.N    ??KAL_DlyTick_5
   \                     ??KAL_DlyTick_6: (+1)
   \       0x2C   0xE7FE             B.N      ??KAL_DlyTick_6
   1926            } else {
   1927              RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \                     ??KAL_DlyTick_4: (+1)
   \       0x2E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD001             BEQ.N    ??KAL_DlyTick_5
   \       0x36   0x.... 0x....      BL       CPU_SW_Exception
   1928            }
   1929          
   1930            return;
   \                     ??KAL_DlyTick_5: (+1)
   \                     ??KAL_DlyTick_0: (+1)
   \       0x3A   0xBD7F             POP      {R0-R6,PC}
   1931          #else
   1932            PP_UNUSED_PARAM(dly_ticks);
   1933            PP_UNUSED_PARAM(opt);
   1934          
   1935            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_NOT_AVAIL,; );
   1936          #endif
   1937          }
   1938          
   1939          /********************************************************************************************************
   1940           *                                       TASK REG API FUNCTIONS
   1941           *******************************************************************************************************/
   1942          
   1943          /****************************************************************************************************//**
   1944           *                                           KAL_TaskRegCreate()
   1945           *
   1946           * @brief    Create a task register.
   1947           *
   1948           * @param    p_cfg   Pointer to KAL task register configuration structure.
   1949           *
   1950           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
   1951           *                   this function:
   1952           *                       - RTOS_ERR_NONE
   1953           *                       - RTOS_ERR_NOT_AVAIL
   1954           *                       - RTOS_ERR_POOL_EMPTY
   1955           *                       - RTOS_ERR_NO_MORE_RSRC
   1956           *                       - RTOS_ERR_BLK_ALLOC_CALLBACK
   1957           *                       - RTOS_ERR_SEG_OVF
   1958           *
   1959           * @return   Created task register's handle.
   1960           *
   1961           * @note     (1) This function will initialize KAL if KAL has not yet been initialized.
   1962           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1963          KAL_TASK_REG_HANDLE KAL_TaskRegCreate(KAL_TASK_REG_EXT_CFG *p_cfg,
   1964                                                RTOS_ERR             *p_err)
   1965          {
   \                     KAL_TaskRegCreate: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1966            KAL_TASK_REG_HANDLE handle = KAL_TaskRegHandleNull;
   \        0x8   0x....             LDR.N    R0,??DataTable27_23
   \        0xA   0x6806             LDR      R6,[R0, #+0]
   1967          
   1968            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   1969            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, handle);
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??KAL_TaskRegCreate_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
   1970          
   1971            //                                                               Make sure no unsupported cfg recv.
   1972            RTOS_ASSERT_DBG_ERR_SET((p_cfg == DEF_NULL), *p_err, RTOS_ERR_NOT_SUPPORTED, handle);
   \                     ??KAL_TaskRegCreate_0: (+1)
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD009             BEQ.N    ??KAL_TaskRegCreate_1
   \       0x18   0x2007             MOVS     R0,#+7
   \       0x1A   0x7028             STRB     R0,[R5, #+0]
   \       0x1C   0x....             LDR.N    R0,??DataTable27_24
   \       0x1E   0x6068             STR      R0,[R5, #+4]
   \       0x20   0xF240 0x70B4      MOVW     R0,#+1972
   \       0x24   0x60A8             STR      R0,[R5, #+8]
   \       0x26   0x....             LDR.N    R0,??DataTable27_25
   \       0x28   0x60E8             STR      R0,[R5, #+12]
   \                     ??KAL_TaskRegCreate_2: (+1)
   \       0x2A   0xE7FE             B.N      ??KAL_TaskRegCreate_2
   1973          
   1974            if (KAL_DataPtr == DEF_NULL) {
   \                     ??KAL_TaskRegCreate_1: (+1)
   \       0x2C   0x....             LDR.N    R7,??DataTable27_2
   \       0x2E   0x6838             LDR      R0,[R7, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD107             BNE.N    ??KAL_TaskRegCreate_3
   1975              KAL_Init(p_err);                                            // KAL initialization (see Note #1).
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0x.... 0x....      BL       KAL_Init
   1976              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x3A   0x7828             LDRB     R0,[R5, #+0]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD001             BEQ.N    ??KAL_TaskRegCreate_3
   1977                return(handle);
   \       0x40   0x0030             MOVS     R0,R6
   \       0x42   0xE021             B.N      ??KAL_TaskRegCreate_4
   1978              }
   1979            }
   1980          
   1981              #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   1982            {
   1983              KAL_TASK_REG_DATA *p_task_reg;
   1984          
   1985              p_task_reg = (KAL_TASK_REG_DATA *)Mem_DynPoolBlkGet(&KAL_DataPtr->TaskRegPool,
   1986                                                                  p_err);
   \                     ??KAL_TaskRegCreate_3: (+1)
   \       0x44   0x0029             MOVS     R1,R5
   \       0x46   0x6838             LDR      R0,[R7, #+0]
   \       0x48   0x306C             ADDS     R0,R0,#+108
   \       0x4A   0x.... 0x....      BL       Mem_DynPoolBlkGet
   \       0x4E   0x4680             MOV      R8,R0
   1987              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x50   0x7828             LDRB     R0,[R5, #+0]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD001             BEQ.N    ??KAL_TaskRegCreate_5
   1988                return (handle);
   \       0x56   0x0030             MOVS     R0,R6
   \       0x58   0xE016             B.N      ??KAL_TaskRegCreate_4
   1989              }
   1990          
   1991              p_task_reg->Id = OSTaskRegGetID(p_err);
   \                     ??KAL_TaskRegCreate_5: (+1)
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0x.... 0x....      BL       OSTaskRegGetID
   \       0x60   0xF888 0x0000      STRB     R0,[R8, #+0]
   1992              if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {
   \       0x64   0x7828             LDRB     R0,[R5, #+0]
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD101             BNE.N    ??KAL_TaskRegCreate_6
   1993                handle.TaskRegObjPtr = (void *)p_task_reg;
   \       0x6A   0x4646             MOV      R6,R8
   \       0x6C   0xE00B             B.N      ??KAL_TaskRegCreate_7
   1994                LOG_VRB(("KAL_TaskRegCreate call successful."));
   1995              } else {
   1996                RTOS_ERR local_err;
   1997          
   1998                LOG_DBG(("Call to OSTaskRegGetID failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   1999          
   2000                //                                                           Free rsrc to pool.
   2001                Mem_DynPoolBlkFree(&KAL_DataPtr->TaskRegPool,
   2002                                   (void *)p_task_reg,
   2003                                   &local_err);
   \                     ??KAL_TaskRegCreate_6: (+1)
   \       0x6E   0x466A             MOV      R2,SP
   \       0x70   0x4641             MOV      R1,R8
   \       0x72   0x6838             LDR      R0,[R7, #+0]
   \       0x74   0x306C             ADDS     R0,R0,#+108
   \       0x76   0x.... 0x....      BL       Mem_DynPoolBlkFree
   2004                RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL, handle);
   \       0x7A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD001             BEQ.N    ??KAL_TaskRegCreate_7
   \       0x82   0x.... 0x....      BL       CPU_SW_Exception
   2005              }
   2006          
   2007              return (handle);
   \                     ??KAL_TaskRegCreate_7: (+1)
   \       0x86   0x0030             MOVS     R0,R6
   \                     ??KAL_TaskRegCreate_4: (+1)
   \       0x88   0xB004             ADD      SP,SP,#+16
   \       0x8A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2008            }
   2009              #else
   2010            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   2011          
   2012            return (handle);
   2013              #endif
   2014          }
   2015          
   2016          /****************************************************************************************************//**
   2017           *                                               KAL_TaskRegGet()
   2018           *
   2019           * @brief    Get value from a task register.
   2020           *
   2021           * @param    task_handle         Handle of the task associated to the task register. Current task is used if NULL.
   2022           *
   2023           * @param    task_reg_handle     Handle of the task register to read.
   2024           *
   2025           * @param    p_err               Pointer to the variable that will receive one of the following error
   2026           *                               code(s) from this function:
   2027           *                                   - RTOS_ERR_NONE
   2028           *                                   - RTOS_ERR_NOT_AVAIL
   2029           *
   2030           * @return   Value read from the task register, if no error.
   2031           *           0, otherwise.
   2032           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2033          KAL_TASK_REG KAL_TaskRegGet(KAL_TASK_HANDLE     task_handle,
   2034                                      KAL_TASK_REG_HANDLE task_reg_handle,
   2035                                      RTOS_ERR            *p_err)
   2036          {
   \                     KAL_TaskRegGet: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   2037            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   2038            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??KAL_TaskRegGet_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
   2039          
   2040            RTOS_ASSERT_DBG_ERR_SET((KAL_TASK_REG_HANDLE_IS_NULL(task_reg_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??KAL_TaskRegGet_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable27_23
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x4286             CMP      R6,R0
   \       0x18   0xD109             BNE.N    ??KAL_TaskRegGet_1
   \       0x1A   0x200A             MOVS     R0,#+10
   \       0x1C   0x7020             STRB     R0,[R4, #+0]
   \       0x1E   0x....             LDR.N    R0,??DataTable27_24
   \       0x20   0x6060             STR      R0,[R4, #+4]
   \       0x22   0xF44F 0x60FF      MOV      R0,#+2040
   \       0x26   0x60A0             STR      R0,[R4, #+8]
   \       0x28   0x....             LDR.N    R0,??DataTable27_26
   \       0x2A   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_TaskRegGet_2: (+1)
   \       0x2C   0xE7FE             B.N      ??KAL_TaskRegGet_2
   2041          
   2042              #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   2043            {
   2044              KAL_TASK_REG_DATA *p_task_reg;
   2045              OS_TCB            *p_task_tcb;
   2046              KAL_TASK_REG      ret_val;
   2047          
   2048              p_task_reg = (KAL_TASK_REG_DATA *)task_reg_handle.TaskRegObjPtr;
   \                     ??KAL_TaskRegGet_1: (+1)
   \       0x2E   0x0037             MOVS     R7,R6
   2049          
   2050              if (KAL_TASK_HANDLE_IS_NULL(task_handle) == DEF_YES) {
   \       0x30   0x....             LDR.N    R0,??DataTable27
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x4285             CMP      R5,R0
   \       0x36   0xD103             BNE.N    ??KAL_TaskRegGet_3
   2051                p_task_tcb = OSTCBCurPtr;                                 // Use cur task if no task handle is provided.
   \       0x38   0x....             LDR.N    R0,??DataTable27_1
   \       0x3A   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   \       0x3E   0xE000             B.N      ??KAL_TaskRegGet_4
   2052              } else {
   2053                //                                                           Get TCB from task handle provided.
   2054                p_task_tcb = &((KAL_TASK *)task_handle.TaskObjPtr)->TCB;
   \                     ??KAL_TaskRegGet_3: (+1)
   \       0x40   0x46A8             MOV      R8,R5
   2055              }
   2056          
   2057              ret_val = OSTaskRegGet(p_task_tcb,
   2058                                     p_task_reg->Id,
   2059                                     p_err);
   \                     ??KAL_TaskRegGet_4: (+1)
   \       0x42   0x0022             MOVS     R2,R4
   \       0x44   0x7839             LDRB     R1,[R7, #+0]
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0x.... 0x....      BL       OSTaskRegGet
   2060              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   2061                LOG_DBG(("Call to OSTaskRegGet failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   2062              }
   2063          
   2064              return (ret_val);
   \       0x4C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2065            }
   2066              #else
   2067            PP_UNUSED_PARAM(task_handle);
   2068            PP_UNUSED_PARAM(task_reg_handle);
   2069          
   2070            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   2071          
   2072            return (0u);
   2073              #endif
   2074          }
   2075          
   2076          /****************************************************************************************************//**
   2077           *                                               KAL_TaskRegSet()
   2078           *
   2079           * @brief    Set value of task register.
   2080           *
   2081           * @param    task_handle         Handle of the task associated to the task register. Current task is used if NULL.
   2082           *
   2083           * @param    task_reg_handle     Handle of the task register to write to.
   2084           *
   2085           * @param    val                 Value to write in the task register.
   2086           *
   2087           * @param    p_err               Pointer to the variable that will receive one of the following error
   2088           *                               code(s) from this function:
   2089           *                                   - RTOS_ERR_NONE
   2090           *                                   - RTOS_ERR_NOT_AVAIL
   2091           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2092          void KAL_TaskRegSet(KAL_TASK_HANDLE     task_handle,
   2093                              KAL_TASK_REG_HANDLE task_reg_handle,
   2094                              KAL_TASK_REG        val,
   2095                              RTOS_ERR            *p_err)
   2096          {
   \                     KAL_TaskRegSet: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x001C             MOVS     R4,R3
   2097            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   2098            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD101             BNE.N    ??KAL_TaskRegSet_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
   2099          
   2100            RTOS_ASSERT_DBG_ERR_SET((KAL_TASK_REG_HANDLE_IS_NULL(task_reg_handle) == DEF_NO), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??KAL_TaskRegSet_0: (+1)
   \       0x14   0x....             LDR.N    R0,??DataTable27_23
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x4286             CMP      R6,R0
   \       0x1A   0xD109             BNE.N    ??KAL_TaskRegSet_1
   \       0x1C   0x200A             MOVS     R0,#+10
   \       0x1E   0x7020             STRB     R0,[R4, #+0]
   \       0x20   0x....             LDR.N    R0,??DataTable27_24
   \       0x22   0x6060             STR      R0,[R4, #+4]
   \       0x24   0xF640 0x0034      MOVW     R0,#+2100
   \       0x28   0x60A0             STR      R0,[R4, #+8]
   \       0x2A   0x....             LDR.N    R0,??DataTable27_27
   \       0x2C   0x60E0             STR      R0,[R4, #+12]
   \                     ??KAL_TaskRegSet_2: (+1)
   \       0x2E   0xE7FE             B.N      ??KAL_TaskRegSet_2
   2101          
   2102              #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   2103            {
   2104              KAL_TASK_REG_DATA *p_task_reg;
   2105              OS_TCB            *p_task_tcb;
   2106          
   2107              p_task_reg = (KAL_TASK_REG_DATA *)task_reg_handle.TaskRegObjPtr;
   \                     ??KAL_TaskRegSet_1: (+1)
   \       0x30   0x46B0             MOV      R8,R6
   2108          
   2109              if (KAL_TASK_HANDLE_IS_NULL(task_handle) == DEF_YES) {
   \       0x32   0x....             LDR.N    R0,??DataTable27
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x4285             CMP      R5,R0
   \       0x38   0xD103             BNE.N    ??KAL_TaskRegSet_3
   2110                p_task_tcb = OSTCBCurPtr;                                 // Use cur task if no task handle is provided.
   \       0x3A   0x....             LDR.N    R0,??DataTable27_1
   \       0x3C   0xF8D0 0x9000      LDR      R9,[R0, #+0]
   \       0x40   0xE000             B.N      ??KAL_TaskRegSet_4
   2111              } else {
   2112                //                                                           Get TCB from task handle provided.
   2113                p_task_tcb = &((KAL_TASK *)task_handle.TaskObjPtr)->TCB;
   \                     ??KAL_TaskRegSet_3: (+1)
   \       0x42   0x46A9             MOV      R9,R5
   2114              }
   2115          
   2116              OSTaskRegSet(p_task_tcb,
   2117                           p_task_reg->Id,
   2118                           (OS_REG)val,
   2119                           p_err);
   \                     ??KAL_TaskRegSet_4: (+1)
   \       0x44   0x0023             MOVS     R3,R4
   \       0x46   0x003A             MOVS     R2,R7
   \       0x48   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \       0x4C   0x4648             MOV      R0,R9
   \       0x4E   0x.... 0x....      BL       OSTaskRegSet
   2120              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   2121                LOG_DBG(("Call to OSTaskRegSet failed with err: ", RTOS_ERR_LOG_ARG_GET(*p_err)));
   2122              }
   2123          
   2124              return;
   \       0x52   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   2125            }
   2126              #else
   2127            PP_UNUSED_PARAM(task_handle);
   2128            PP_UNUSED_PARAM(task_reg_handle);
   2129            PP_UNUSED_PARAM(val);
   2130          
   2131            RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
   2132          
   2133            return;
   2134              #endif
   2135          }
   2136          
   2137          /********************************************************************************************************
   2138           *                                           TICK API FUNCTIONS
   2139           *******************************************************************************************************/
   2140          
   2141          /****************************************************************************************************//**
   2142           *                                               KAL_TickGet()
   2143           *
   2144           * @brief    Get value of OS' tick counter.
   2145           *
   2146           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
   2147           *                   this function:
   2148           *                       - RTOS_ERR_NONE
   2149           *
   2150           * @return   OS tick counter's value.
   2151           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2152          KAL_TICK KAL_TickGet(RTOS_ERR *p_err)
   2153          {
   \                     KAL_TickGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2154          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   2155            KAL_TICK tick_cnt;
   2156          
   2157            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   2158            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??KAL_TickGet_0
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
   2159          
   2160            tick_cnt = OSTimeGet(p_err);
   \                     ??KAL_TickGet_0: (+1)
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       OSTimeGet
   \       0x12   0x0005             MOVS     R5,R0
   2161            //                                                               OSTimeGet should never return another err.
   2162            RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL, 0u);
   \       0x14   0x7820             LDRB     R0,[R4, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??KAL_TickGet_1
   \       0x1A   0x.... 0x....      BL       CPU_SW_Exception
   2163          
   2164            return (tick_cnt);
   \                     ??KAL_TickGet_1: (+1)
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
   2165          #else
   2166            PP_UNUSED_PARAM(p_err);
   2167          
   2168            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_NOT_AVAIL, 0u);
   2169          
   2170            return (0u);
   2171          #endif
   2172          }
   2173          
   2174          /****************************************************************************************************//**
   2175           *                                               KAL_TickRateGet()
   2176           *
   2177           * @brief    Get value of OS' tick rate, in Hz.
   2178           *
   2179           * @return   OS tick rate's value.
   2180           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2181          KAL_TICK_RATE_HZ KAL_TickRateGet(void)
   2182          {
   \                     KAL_TickRateGet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   2183          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   2184          #ifdef  OS_CFG_COMPAT_INIT
   2185            return (OS_CFG_TICK_RATE_HZ);
   2186          #else
   2187            KAL_TICK_RATE_HZ rate;
   2188            RTOS_ERR err;
   2189          
   2190            rate = (KAL_TICK_RATE_HZ)OSTimeTickRateHzGet(&err);
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x.... 0x....      BL       OSTimeTickRateHzGet
   2191            RTOS_ASSERT_CRITICAL(DEF_TRUE, RTOS_ERR_FAIL, 0u);
   2192          
   2193            return (rate);
   \        0x8   0xB005             ADD      SP,SP,#+20
   \        0xA   0xBD00             POP      {PC}
   2194          #endif
   2195          #else
   2196            return (0u);
   2197          #endif
   2198          }
   2199          
   2200          /********************************************************************************************************
   2201           *                                           CPU USAGE API FUNCTION
   2202           *******************************************************************************************************/
   2203          
   2204          /****************************************************************************************************//**
   2205           *                                           KAL_CPU_UsageGet()
   2206           *
   2207           * @brief    Get value of the CPU Usage.
   2208           *
   2209           * @return   CPU usage's percentage represented as an integer from 0 (0%) to 10000 (100%).
   2210           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2211          KAL_CPU_USAGE KAL_CPU_UsageGet(void)
   2212          {
   \                     KAL_CPU_UsageGet: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2213            //                                                               ---------------- VALIDATE ARGUMENTS ----------------
   2214          #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) \
   2215            && (OS_CFG_DBG_EN == DEF_ENABLED)          \
   2216            && (OS_CFG_STAT_TASK_EN == DEF_ENABLED))
   2217            {
   2218              KAL_CPU_USAGE cpu_usage;
   2219          
   2220              cpu_usage = OSStatTaskCPUUsage;
   2221          
   2222              return (cpu_usage);
   2223            }
   2224          #else
   2225            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_NOT_AVAIL, 0u);
   \        0x2   0x.... 0x....      BL       CPU_SW_Exception
   2226          
   2227            return (0u);
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}
   2228          #endif
   2229          }
   2230          
   2231          /********************************************************************************************************
   2232           ********************************************************************************************************
   2233           *                                               LOCAL FUNCTIONS
   2234           ********************************************************************************************************
   2235           *******************************************************************************************************/
   2236          
   2237          /****************************************************************************************************//**
   2238           *                                               KAL_Init()
   2239           *
   2240           * @brief    Initializes the Kernel Abstraction Layer.
   2241           *
   2242           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
   2243           *                   this function:
   2244           *                       - RTOS_ERR_NONE
   2245           *                       - RTOS_ERR_BLK_ALLOC_CALLBACK
   2246           *                       - RTOS_ERR_SEG_OVF
   2247           *
   2248           * @note     (1) This function will be called by the first function KAL_XXXCreate() called by the
   2249           *               application.
   2250           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2251          static void KAL_Init(RTOS_ERR *p_err)
   2252          {
   \                     KAL_Init: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2253            MEM_SEG *p_mem_seg;
   2254          
   2255            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??KAL_Init_0
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
   2256            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??KAL_Init_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x7020             STRB     R0,[R4, #+0]
   \       0x10   0x....             LDR.N    R0,??DataTable27_24
   \       0x12   0x6060             STR      R0,[R4, #+4]
   \       0x14   0xF44F 0x600D      MOV      R0,#+2256
   \       0x18   0x60A0             STR      R0,[R4, #+8]
   \       0x1A   0x....             LDR.N    R0,??DataTable27_28
   \       0x1C   0x60E0             STR      R0,[R4, #+12]
   2257          
   2258            OSSchedLock(p_err);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       OSSchedLock
   2259            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x24   0x7820             LDRB     R0,[R4, #+0]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD003             BEQ.N    ??KAL_Init_1
   2260              OSSchedUnlock(p_err);
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x.... 0x....      BL       OSSchedUnlock
   2261              return;
   \       0x30   0xE071             B.N      ??KAL_Init_2
   2262            }
   2263          
   2264            if (KAL_DataPtr == DEF_NULL) {
   \                     ??KAL_Init_1: (+1)
   \       0x32   0x....             LDR.N    R6,??DataTable27_2
   \       0x34   0x6830             LDR      R0,[R6, #+0]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD16A             BNE.N    ??KAL_Init_3
   2265              p_mem_seg = Common_MemSegPtrGet();
   \       0x3A   0x.... 0x....      BL       Common_MemSegPtrGet
   \       0x3E   0x0005             MOVS     R5,R0
   2266          
   2267              KAL_DataPtr = (KAL_DATA *)Mem_SegAlloc("KAL internal data",
   2268                                                     p_mem_seg,
   2269                                                     sizeof(KAL_DATA),
   2270                                                     p_err);
   \       0x40   0x0023             MOVS     R3,R4
   \       0x42   0x2290             MOVS     R2,#+144
   \       0x44   0x0029             MOVS     R1,R5
   \       0x46   0x....             LDR.N    R0,??DataTable27_29
   \       0x48   0x.... 0x....      BL       Mem_SegAlloc
   \       0x4C   0x6030             STR      R0,[R6, #+0]
   2271              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x4E   0x7820             LDRB     R0,[R4, #+0]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD003             BEQ.N    ??KAL_Init_4
   2272                OSSchedUnlock(p_err);
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       OSSchedUnlock
   2273                return;
   \       0x5A   0xE05C             B.N      ??KAL_Init_2
   2274              }
   2275          
   2276          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2277              Mem_DynPoolCreate("KAL mutex pool",
   2278                                &KAL_DataPtr->MutexPool,
   2279                                p_mem_seg,
   2280                                sizeof(KAL_LOCK),
   2281                                sizeof(CPU_ALIGN),
   2282                                0u,
   2283                                LIB_MEM_BLK_QTY_UNLIMITED,
   2284                                p_err);
   \                     ??KAL_Init_4: (+1)
   \       0x5C   0x9403             STR      R4,[SP, #+12]
   \       0x5E   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x62   0x9002             STR      R0,[SP, #+8]
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x9001             STR      R0,[SP, #+4]
   \       0x68   0x2004             MOVS     R0,#+4
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0x231C             MOVS     R3,#+28
   \       0x6E   0x002A             MOVS     R2,R5
   \       0x70   0x6831             LDR      R1,[R6, #+0]
   \       0x72   0x....             LDR.N    R0,??DataTable27_30
   \       0x74   0x.... 0x....      BL       Mem_DynPoolCreate
   2285              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x78   0x7820             LDRB     R0,[R4, #+0]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD003             BEQ.N    ??KAL_Init_5
   2286                OSSchedUnlock(p_err);
   \       0x7E   0x0020             MOVS     R0,R4
   \       0x80   0x.... 0x....      BL       OSSchedUnlock
   2287                return;
   \       0x84   0xE047             B.N      ??KAL_Init_2
   2288              }
   2289          #endif
   2290          
   2291          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   2292              Mem_DynPoolCreate("KAL sem pool",
   2293                                &KAL_DataPtr->SemPool,
   2294                                p_mem_seg,
   2295                                sizeof(OS_SEM),
   2296                                sizeof(CPU_ALIGN),
   2297                                0u,
   2298                                LIB_MEM_BLK_QTY_UNLIMITED,
   2299                                p_err);
   \                     ??KAL_Init_5: (+1)
   \       0x86   0x9403             STR      R4,[SP, #+12]
   \       0x88   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x8C   0x9002             STR      R0,[SP, #+8]
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0x9001             STR      R0,[SP, #+4]
   \       0x92   0x2004             MOVS     R0,#+4
   \       0x94   0x9000             STR      R0,[SP, #+0]
   \       0x96   0x2310             MOVS     R3,#+16
   \       0x98   0x002A             MOVS     R2,R5
   \       0x9A   0x6830             LDR      R0,[R6, #+0]
   \       0x9C   0xF110 0x0124      ADDS     R1,R0,#+36
   \       0xA0   0x....             LDR.N    R0,??DataTable27_31
   \       0xA2   0x.... 0x....      BL       Mem_DynPoolCreate
   2300              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0xA6   0x7820             LDRB     R0,[R4, #+0]
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD003             BEQ.N    ??KAL_Init_6
   2301                OSSchedUnlock(p_err);
   \       0xAC   0x0020             MOVS     R0,R4
   \       0xAE   0x.... 0x....      BL       OSSchedUnlock
   2302                return;
   \       0xB2   0xE030             B.N      ??KAL_Init_2
   2303              }
   2304          #endif
   2305          
   2306          #if (OS_CFG_TMR_EN == DEF_ENABLED)
   2307              Mem_DynPoolCreate("KAL tmr pool",
   2308                                &KAL_DataPtr->TmrPool,
   2309                                p_mem_seg,
   2310                                sizeof(KAL_TMR),
   2311                                sizeof(CPU_ALIGN),
   2312                                0u,
   2313                                LIB_MEM_BLK_QTY_UNLIMITED,
   2314                                p_err);
   2315              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   2316                OSSchedUnlock(p_err);
   2317                return;
   2318              }
   2319          #endif
   2320          
   2321          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   2322              Mem_DynPoolCreate("KAL task reg pool",
   2323                                &KAL_DataPtr->TaskRegPool,
   2324                                p_mem_seg,
   2325                                sizeof(KAL_TASK_REG_DATA),
   2326                                sizeof(CPU_ALIGN),
   2327                                0u,
   2328                                LIB_MEM_BLK_QTY_UNLIMITED,
   2329                                p_err);
   \                     ??KAL_Init_6: (+1)
   \       0xB4   0x9403             STR      R4,[SP, #+12]
   \       0xB6   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0xBA   0x9002             STR      R0,[SP, #+8]
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0x9001             STR      R0,[SP, #+4]
   \       0xC0   0x2004             MOVS     R0,#+4
   \       0xC2   0x9000             STR      R0,[SP, #+0]
   \       0xC4   0x2301             MOVS     R3,#+1
   \       0xC6   0x002A             MOVS     R2,R5
   \       0xC8   0x6830             LDR      R0,[R6, #+0]
   \       0xCA   0xF110 0x016C      ADDS     R1,R0,#+108
   \       0xCE   0x....             LDR.N    R0,??DataTable27_32
   \       0xD0   0x.... 0x....      BL       Mem_DynPoolCreate
   2330              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0xD4   0x7820             LDRB     R0,[R4, #+0]
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD003             BEQ.N    ??KAL_Init_7
   2331                OSSchedUnlock(p_err);
   \       0xDA   0x0020             MOVS     R0,R4
   \       0xDC   0x.... 0x....      BL       OSSchedUnlock
   2332                return;
   \       0xE0   0xE019             B.N      ??KAL_Init_2
   2333              }
   2334          #endif
   2335          
   2336          #if (OS_CFG_MON_EN == DEF_ENABLED)
   2337              Mem_DynPoolCreate("KAL mon pool",
   2338                                &KAL_DataPtr->MonPool,
   2339                                p_mem_seg,
   2340                                sizeof(OS_MON),
   2341                                sizeof(CPU_ALIGN),
   2342                                0u,
   2343                                LIB_MEM_BLK_QTY_UNLIMITED,
   2344                                p_err);
   \                     ??KAL_Init_7: (+1)
   \       0xE2   0x9403             STR      R4,[SP, #+12]
   \       0xE4   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0xE8   0x9002             STR      R0,[SP, #+8]
   \       0xEA   0x2000             MOVS     R0,#+0
   \       0xEC   0x9001             STR      R0,[SP, #+4]
   \       0xEE   0x2004             MOVS     R0,#+4
   \       0xF0   0x9000             STR      R0,[SP, #+0]
   \       0xF2   0x2310             MOVS     R3,#+16
   \       0xF4   0x002A             MOVS     R2,R5
   \       0xF6   0x6830             LDR      R0,[R6, #+0]
   \       0xF8   0xF110 0x0148      ADDS     R1,R0,#+72
   \       0xFC   0x....             LDR.N    R0,??DataTable27_33
   \       0xFE   0x.... 0x....      BL       Mem_DynPoolCreate
   2345              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \      0x102   0x7820             LDRB     R0,[R4, #+0]
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD003             BEQ.N    ??KAL_Init_3
   2346                OSSchedUnlock(p_err);
   \      0x108   0x0020             MOVS     R0,R4
   \      0x10A   0x.... 0x....      BL       OSSchedUnlock
   2347                return;
   \      0x10E   0xE002             B.N      ??KAL_Init_2
   2348              }
   2349          #endif
   2350              LOG_VRB(("KAL_Init successful."));
   2351            }
   2352          
   2353            OSSchedUnlock(p_err);
   \                     ??KAL_Init_3: (+1)
   \      0x110   0x0020             MOVS     R0,R4
   \      0x112   0x.... 0x....      BL       OSSchedUnlock
   2354            return;
   \                     ??KAL_Init_2: (+1)
   \      0x116   0xBD7F             POP      {R0-R6,PC}
   2355          }
   2356          
   2357          /****************************************************************************************************//**
   2358           *                                           KAL_TmrFnctWrapper()
   2359           *
   2360           * @brief    Wrapper function for timer callback.
   2361           *
   2362           * @param    p_tmr_os    Pointer to OS timer object.
   2363           *
   2364           * @param    p_arg       Pointer to KAL timer object.
   2365           *******************************************************************************************************/
   2366          
   2367          #if (OS_CFG_TMR_EN == DEF_ENABLED)
   2368          static void KAL_TmrFnctWrapper(void *p_tmr_os,
   2369                                         void *p_arg)
   2370          {
   2371            KAL_TMR *p_tmr;
   2372          
   2373            PP_UNUSED_PARAM(p_tmr_os);
   2374          
   2375            p_tmr = (KAL_TMR *)p_arg;
   2376            p_tmr->CallbackFnct(p_tmr->CallbackArg);
   2377          }
   2378          #endif
   2379          
   2380          /****************************************************************************************************//**
   2381           *                                           KAL_MonConvertRes()
   2382           *
   2383           * @brief    Wrapper function for timer callback.
   2384           *
   2385           * @param    res     Monitor result in KAL format.
   2386           *
   2387           * @return   Converted monitor result value.
   2388           *******************************************************************************************************/
   2389          
   2390          #if (OS_CFG_MON_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2391          static OS_MON_RES KAL_MonConvertRes(KAL_MON_RES res)
   2392          {
   \                     KAL_MonConvertRes: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2393            OS_MON_RES res_converted = 0u;
   \        0x2   0x2000             MOVS     R0,#+0
   2394          
   2395            res_converted |= (DEF_BIT_IS_SET(res, KAL_MON_RES_BLOCK) == DEF_YES) ? (OS_MON_RES_BLOCK)       : 0u;
   \        0x4   0x000A             MOVS     R2,R1
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0xF012 0x0201      ANDS     R2,R2,#0x1
   \        0xC   0x4310             ORRS     R0,R2,R0
   2396            res_converted |= (DEF_BIT_IS_SET(res, KAL_MON_RES_STOP_EVAL) == DEF_YES) ? (OS_MON_RES_STOP_EVAL)   : 0u;
   \        0xE   0x000A             MOVS     R2,R1
   \       0x10   0xB2D2             UXTB     R2,R2
   \       0x12   0x0852             LSRS     R2,R2,#+1
   \       0x14   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x18   0xEA50 0x0042      ORRS     R0,R0,R2, LSL #+1
   2397            res_converted |= (DEF_BIT_IS_SET(res, KAL_MON_RES_ACQUIRE) == DEF_YES) ? (OS_MON_RES_ACQUIRE)     : 0u;
   \       0x1C   0x000A             MOVS     R2,R1
   \       0x1E   0xB2D2             UXTB     R2,R2
   \       0x20   0x0892             LSRS     R2,R2,#+2
   \       0x22   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x26   0xEA50 0x0082      ORRS     R0,R0,R2, LSL #+2
   2398            res_converted |= (DEF_BIT_IS_SET(res, KAL_MON_RES_RELEASE) == DEF_YES) ? (OS_MON_RES_RELEASE)     : 0u;
   \       0x2A   0x000A             MOVS     R2,R1
   \       0x2C   0xB2D2             UXTB     R2,R2
   \       0x2E   0x08D2             LSRS     R2,R2,#+3
   \       0x30   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x34   0xEA50 0x00C2      ORRS     R0,R0,R2, LSL #+3
   2399            res_converted |= (DEF_BIT_IS_SET(res, KAL_MON_RES_SUBSCRIBE) == DEF_YES) ? (OS_MON_RES_SUBSCRIBE)   : 0u;
   \       0x38   0x000A             MOVS     R2,R1
   \       0x3A   0xB2D2             UXTB     R2,R2
   \       0x3C   0x0912             LSRS     R2,R2,#+4
   \       0x3E   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x42   0xEA50 0x1002      ORRS     R0,R0,R2, LSL #+4
   2400            res_converted |= (DEF_BIT_IS_SET(res, KAL_MON_RES_UNSUBSCRIBE) == DEF_YES) ? (OS_MON_RES_UNSUBSCRIBE) : 0u;
   \       0x46   0x000A             MOVS     R2,R1
   \       0x48   0xB2D2             UXTB     R2,R2
   \       0x4A   0x0952             LSRS     R2,R2,#+5
   \       0x4C   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x50   0xEA50 0x1042      ORRS     R0,R0,R2, LSL #+5
   2401            res_converted |= (DEF_BIT_IS_SET(res, KAL_MON_RES_TRY_FAIL) == DEF_YES) ? (OS_MON_RES_TRY_FAIL)    : 0u;
   \       0x54   0x000A             MOVS     R2,R1
   \       0x56   0xB2D2             UXTB     R2,R2
   \       0x58   0x0992             LSRS     R2,R2,#+6
   \       0x5A   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x5E   0xEA50 0x1082      ORRS     R0,R0,R2, LSL #+6
   2402          
   2403            return (res_converted);
   \       0x62   0x4770             BX       LR
   2404          }
   2405          #endif
   2406          
   2407          /****************************************************************************************************//**
   2408           *                                           KAL_MonEnterFnct()
   2409           *
   2410           * @brief    Wrapper function for monitor enter callback.
   2411           *
   2412           * @param    p_mon       Pointer to OS monitor object.
   2413           *
   2414           * @param    p_op_data   Argument passed to OSMonOp. In this case, wrapper for arguments passed by
   2415           *                       caller of KAL_MonOp().
   2416           *
   2417           * @return   OS monitor result value.
   2418           *******************************************************************************************************/
   2419          
   2420          #if (OS_CFG_MON_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
   2421          static OS_MON_RES KAL_MonEnterFnct(OS_MON *p_mon,
   2422                                             void   *p_op_data)
   2423          {
   \                     KAL_MonEnterFnct: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2424            KAL_MON_DATA_WRAPPER *p_arg_wrapper = (KAL_MON_DATA_WRAPPER *)p_op_data;
   \        0x6   0x002E             MOVS     R6,R5
   2425            KAL_MON_RES          res;
   2426          
   2427            res = p_arg_wrapper->EnterFnct(p_mon->MonDataPtr,
   2428                                           p_arg_wrapper->DataPtr);
   \        0x8   0x6831             LDR      R1,[R6, #+0]
   \        0xA   0x68E0             LDR      R0,[R4, #+12]
   \        0xC   0x6872             LDR      R2,[R6, #+4]
   \        0xE   0x4790             BLX      R2
   \       0x10   0x0007             MOVS     R7,R0
   2429            return (KAL_MonConvertRes(res));
   \       0x12   0x0038             MOVS     R0,R7
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x.... 0x....      BL       KAL_MonConvertRes
   \       0x1A   0xBDF2             POP      {R1,R4-R7,PC}
   2430          }
   2431          #endif
   2432          
   2433          /****************************************************************************************************//**
   2434           *                                               KAL_MonEvalFnct()
   2435           *
   2436           * @brief    Wrapper function for monitor evaluation callback.
   2437           *
   2438           * @param    p_mon           Pointer to OS monitor object.
   2439           *
   2440           * @param    p_eval_op_data  Argument passed to OSMonOp. In this case, wrapper for arguments passed by
   2441           *                           previous caller of KAL_MonOp().
   2442           *
   2443           * @param    p_scan_op_data  Argument passed to OSMonOp. In this case, wrapper for arguments passed by
   2444           *                           current caller of KAL_MonOp().
   2445           *
   2446           * @return   OS monitor result value.
   2447           *******************************************************************************************************/
   2448          
   2449          #if (OS_CFG_MON_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
   2450          static OS_MON_RES KAL_MonEvalFnct(OS_MON *p_mon,
   2451                                            void   *p_eval_op_data,
   2452                                            void   *p_scan_op_data)
   2453          {
   \                     KAL_MonEvalFnct: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   2454            KAL_MON_DATA_WRAPPER *p_eval_op_data_wrapper = (KAL_MON_DATA_WRAPPER *)p_eval_op_data;
   \        0xA   0x002F             MOVS     R7,R5
   2455            KAL_MON_DATA_WRAPPER *p_scan_op_data_wrapper = (KAL_MON_DATA_WRAPPER *)p_scan_op_data;
   \        0xC   0x46B0             MOV      R8,R6
   2456            KAL_MON_RES          res;
   2457          
   2458            res = p_eval_op_data_wrapper->EvalFnct(p_mon->MonDataPtr,
   2459                                                   p_eval_op_data_wrapper->DataPtr,
   2460                                                   p_scan_op_data_wrapper->DataPtr);
   \        0xE   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x12   0x6839             LDR      R1,[R7, #+0]
   \       0x14   0x68E0             LDR      R0,[R4, #+12]
   \       0x16   0x68BB             LDR      R3,[R7, #+8]
   \       0x18   0x4798             BLX      R3
   \       0x1A   0x4681             MOV      R9,R0
   2461            return (KAL_MonConvertRes(res));
   \       0x1C   0x4648             MOV      R0,R9
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x.... 0x....      BL       KAL_MonConvertRes
   \       0x24   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2462          }
   2463          #endif
   2464          
   2465          /****************************************************************************************************//**
   2466           *                                               KAL_msToTicks()
   2467           *
   2468           * @brief    Convert milliseconds value to tick value.
   2469           *
   2470           * @param    ms  Millisecond value to convert.
   2471           *
   2472           * @return   Number of ticks corresponding to the millisecond value, rounded up, if needed.
   2473           *******************************************************************************************************/
   2474          // TODO: Get rid of this function and use ms variant of OS when available

   \                                 In section .text, align 2, keep-with-next
   2475          static KAL_TICK KAL_msToTicks(CPU_INT32U ms)
   2476          {
   \                     KAL_msToTicks: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2477            KAL_TICK ticks;
   2478          
   2479          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   2480            KAL_TICK_RATE_HZ  tick_rate;
   2481          
   2482            tick_rate = KAL_TickRateGet();
   \        0x4   0x.... 0x....      BL       KAL_TickRateGet
   \        0x8   0x0001             MOVS     R1,R0
   2483          
   2484            ticks = (((ms * tick_rate)  + 1000u - 1u) / 1000u);
   \        0xA   0xFB01 0xF204      MUL      R2,R1,R4
   \        0xE   0xF202 0x32E7      ADDW     R2,R2,#+999
   \       0x12   0xF44F 0x707A      MOV      R0,#+1000
   \       0x16   0xFBB2 0xF0F0      UDIV     R0,R2,R0
   2485          #else
   2486            PP_UNUSED_PARAM(ms);
   2487          
   2488            ticks = 0u;
   2489          #endif
   2490          
   2491            return (ticks);
   \       0x1A   0xBD10             POP      {R4,PC}
   2492          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x....'....        DC32     KAL_TaskHandleNull

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \        0x0   0x....'....        DC32     `KAL_TaskAlloc::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \        0x0   0x....'....        DC32     KAL_DataPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \        0x0   0x....'....        DC32     `KAL_TaskCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \        0x0   0x....'....        DC32     KAL_LockHandleNull

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     KAL_TaskHandleNull

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \        0x0   0x....'....        DC32     KAL_DataPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \        0x0   0x....'....        DC32     `KAL_LockAcquire::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \        0x0   0x....'....        DC32     `KAL_LockRelease::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \        0x0   0x....'....        DC32     KAL_SemHandleNull

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \        0x0   0x....'....        DC32     `KAL_SemCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \        0x0   0x....'....        DC32     `KAL_SemPend::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_8:
   \        0x0   0x....'....        DC32     `KAL_SemPost::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_9:
   \        0x0   0x....'....        DC32     `KAL_SemPendAbort::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_10:
   \        0x0   0x....'....        DC32     `KAL_SemSet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_11:
   \        0x0   0x....'....        DC32     KAL_TmrHandleNull

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_12:
   \        0x0   0x....'....        DC32     OSInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_13:
   \        0x0   0x....'....        DC32     `KAL_TmrCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_14:
   \        0x0   0x....'....        DC32     `KAL_TmrStart::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_15:
   \        0x0   0x....'....        DC32     KAL_QHandleNull

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_16:
   \        0x0   0x....'....        DC32     `KAL_QCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_17:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_18:
   \        0x0   0x....'....        DC32     `KAL_QPend::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_19:
   \        0x0   0x....'....        DC32     `KAL_QPost::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_20:
   \        0x0   0x....'....        DC32     KAL_MonHandleNull

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_21:
   \        0x0   0x....'....        DC32     `KAL_MonCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_22:
   \        0x0   0x....'....        DC32     `KAL_MonOp::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_23:
   \        0x0   0x....'....        DC32     KAL_TaskRegHandleNull

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_24:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_25:
   \        0x0   0x....'....        DC32     `KAL_TaskRegCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_26:
   \        0x0   0x....'....        DC32     `KAL_TaskRegGet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_27:
   \        0x0   0x....'....        DC32     `KAL_TaskRegSet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_28:
   \        0x0   0x....'....        DC32     `KAL_Init::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_29:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_30:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_31:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_32:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_33:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x63, 0x6F, 0x6D, 0x6D, 0x6F
   \              0x5C 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x6F
   \       0x58   0x6E 0x5C          DC8 0x6E, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65
   \       0x60   0x5C 0x6B          DC8 0x5C, 0x6B, 0x61, 0x6C, 0x5C, 0x6B, 0x61, 0x6C
   \              0x61 0x6C    
   \              0x5C 0x6B    
   \              0x61 0x6C
   \       0x68   0x5F 0x6B          DC8 0x5F, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x2E
   \              0x65 0x72    
   \              0x6E 0x65    
   \              0x6C 0x2E
   \       0x70   0x63 0x00          DC8 0x63, 0
   \       0x72                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x4B 0x41          DC8 "KAL task stk"
   \              0x4C 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x20 0x73    
   \              0x74 0x6B    
   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x4B 0x41          DC8 "KAL task"
   \              0x4C 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x4B 0x41          DC8 "KAL Q"
   \              0x4C 0x20    
   \              0x51 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x4B 0x41          DC8 "KAL internal data"
   \              0x4C 0x20    
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x6E    
   \              0x61 0x6C    
   \              0x20 0x64    
   \              0x61 0x74    
   \              0x61 0x00
   \       0x12                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x4B 0x41          DC8 "KAL mutex pool"
   \              0x4C 0x20    
   \              0x6D 0x75    
   \              0x74 0x65    
   \              0x78 0x20    
   \              0x70 0x6F    
   \              0x6F 0x6C    
   \              0x00
   \        0xF                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x4B 0x41          DC8 "KAL sem pool"
   \              0x4C 0x20    
   \              0x73 0x65    
   \              0x6D 0x20    
   \              0x70 0x6F    
   \              0x6F 0x6C    
   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x4B 0x41          DC8 "KAL task reg pool"
   \              0x4C 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x20 0x72    
   \              0x65 0x67    
   \              0x20 0x70    
   \              0x6F 0x6F    
   \              0x6C 0x00
   \       0x12                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x4B 0x41          DC8 "KAL mon pool"
   \              0x4C 0x20    
   \              0x6D 0x6F    
   \              0x6E 0x20    
   \              0x70 0x6F    
   \              0x6F 0x6C    
   \              0x00
   \        0xD                      DS8 3
   2493          
   2494          /********************************************************************************************************
   2495           ********************************************************************************************************
   2496           *                                   DEPENDENCIES & AVAIL CHECK(S) END
   2497           ********************************************************************************************************
   2498           *******************************************************************************************************/
   2499          
   2500          #endif // defined(RTOS_MODULE_KERNEL_AVAIL))

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   KAL_CPU_UsageGet
         8   -> CPU_SW_Exception
      32   KAL_Dly
        32   -> CPU_SW_Exception
        32   -> KAL_msToTicks
        32   -> OSTimeDly
      32   KAL_DlyTick
        32   -> CPU_SW_Exception
        32   -> OSTimeDly
       0   KAL_FeatureQuery
      32   KAL_Init
        32   -> CPU_SW_Exception
        32   -> Common_MemSegPtrGet
        32   -> Mem_DynPoolCreate
        32   -> Mem_SegAlloc
        32   -> OSSchedLock
        32   -> OSSchedUnlock
      48   KAL_LockAcquire
        48   -> CPU_SW_Exception
        48   -> KAL_msToTicks
        48   -> OSMutexPend
        48   -> OSMutexPost
      48   KAL_LockCreate
        48   -> CPU_SW_Exception
        48   -> KAL_Init
        48   -> Mem_DynPoolBlkFree
        48   -> Mem_DynPoolBlkGet
        48   -> OSMutexCreate
      32   KAL_LockDel
        32   -> CPU_SW_Exception
        32   -> Mem_DynPoolBlkFree
        32   -> OSMutexDel
      16   KAL_LockRelease
        16   -> CPU_SW_Exception
        16   -> OSMutexPost
       0   KAL_MonConvertRes
      56   KAL_MonCreate
        56   -> CPU_SW_Exception
        56   -> KAL_Init
        56   -> Mem_DynPoolBlkFree
        56   -> Mem_DynPoolBlkGet
        56   -> OSMonCreate
      24   KAL_MonDel
        24   -> CPU_SW_Exception
        24   -> Mem_DynPoolBlkFree
        24   -> OSMonDel
      24   KAL_MonEnterFnct
        24   -- Indirect call
        24   -> KAL_MonConvertRes
      32   KAL_MonEvalFnct
        32   -- Indirect call
        32   -> KAL_MonConvertRes
      72   KAL_MonOp
        72   -> CPU_SW_Exception
        72   -> KAL_msToTicks
        72   -> OSMonOp
      32   KAL_QCreate
        32   -> CPU_SW_Exception
        32   -> Common_MemSegPtrGet
        32   -> KAL_Init
        32   -> Mem_SegAlloc
        32   -> OSQCreate
      40   KAL_QPend
        40   -> CPU_SW_Exception
        40   -> KAL_msToTicks
        40   -> OSQPend
      24   KAL_QPost
        24   -> CPU_SW_Exception
        24   -> OSQPost
      48   KAL_SemCreate
        48   -> CPU_SW_Exception
        48   -> KAL_Init
        48   -> Mem_DynPoolBlkFree
        48   -> Mem_DynPoolBlkGet
        48   -> OSSemCreate
      32   KAL_SemDel
        32   -> CPU_SW_Exception
        32   -> Mem_DynPoolBlkFree
        32   -> OSSemDel
      32   KAL_SemPend
        32   -> CPU_SW_Exception
        32   -> KAL_msToTicks
        32   -> OSSemPend
      16   KAL_SemPendAbort
        16   -> CPU_SW_Exception
        16   -> OSSemPendAbort
      16   KAL_SemPost
        16   -> CPU_SW_Exception
        16   -> OSSemPost
      16   KAL_SemSet
        16   -> CPU_SW_Exception
        16   -> OSSemSet
      56   KAL_TaskAlloc
        56   -> CPU_SW_Exception
        56   -> Common_MemSegPtrGet
        56   -> KAL_Init
        56   -> Mem_SegAlloc
        56   -> Mem_SegAllocExt
      72   KAL_TaskCreate
        72   -> CPU_SW_Exception
        72   -> OSTaskCreate
      32   KAL_TaskDel
        32   -> CPU_SW_Exception
        32   -> OSTaskDel
      24   KAL_TaskPrioSet
        24   -> OSTaskChangePrio
      40   KAL_TaskRegCreate
        40   -> CPU_SW_Exception
        40   -> KAL_Init
        40   -> Mem_DynPoolBlkFree
        40   -> Mem_DynPoolBlkGet
        40   -> OSTaskRegGetID
      24   KAL_TaskRegGet
        24   -> CPU_SW_Exception
        24   -> OSTaskRegGet
      32   KAL_TaskRegSet
        32   -> CPU_SW_Exception
        32   -> OSTaskRegSet
       0   KAL_TaskUUID_Get
      16   KAL_TickGet
        16   -> CPU_SW_Exception
        16   -> OSTimeGet
      24   KAL_TickRateGet
        24   -> OSTimeTickRateHzGet
      32   KAL_TmrCreate
        32   -> CPU_SW_Exception
        32   -> KAL_Init
      16   KAL_TmrStart
        16   -> CPU_SW_Exception
       8   KAL_msToTicks
         8   -> KAL_TickRateGet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_10
       4  ??DataTable27_11
       4  ??DataTable27_12
       4  ??DataTable27_13
       4  ??DataTable27_14
       4  ??DataTable27_15
       4  ??DataTable27_16
       4  ??DataTable27_17
       4  ??DataTable27_18
       4  ??DataTable27_19
       4  ??DataTable27_2
       4  ??DataTable27_20
       4  ??DataTable27_21
       4  ??DataTable27_22
       4  ??DataTable27_23
       4  ??DataTable27_24
       4  ??DataTable27_25
       4  ??DataTable27_26
       4  ??DataTable27_27
       4  ??DataTable27_28
       4  ??DataTable27_29
       4  ??DataTable27_3
       4  ??DataTable27_30
       4  ??DataTable27_31
       4  ??DataTable27_32
       4  ??DataTable27_33
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
     116  ?_0
      16  ?_1
      12  ?_2
       8  ?_3
      20  ?_4
      16  ?_5
      16  ?_6
      20  ?_7
      16  ?_8
      10  KAL_CPU_UsageGet
       4  KAL_DataPtr
      44  KAL_Dly
      60  KAL_DlyTick
     178  KAL_FeatureQuery
     280  KAL_Init
     202  KAL_LockAcquire
     144  KAL_LockCreate
      72  KAL_LockDel
       4  KAL_LockHandleNull
      98  KAL_LockRelease
     100  KAL_MonConvertRes
     176  KAL_MonCreate
      68  KAL_MonDel
      28  KAL_MonEnterFnct
      40  KAL_MonEvalFnct
       4  KAL_MonHandleNull
     190  KAL_MonOp
     136  KAL_QCreate
       4  KAL_QHandleNull
     138  KAL_QPend
      96  KAL_QPost
     162  KAL_SemCreate
      74  KAL_SemDel
       4  KAL_SemHandleNull
     138  KAL_SemPend
      92  KAL_SemPendAbort
      94  KAL_SemPost
      64  KAL_SemSet
     250  KAL_TaskAlloc
     192  KAL_TaskCreate
      44  KAL_TaskDel
       4  KAL_TaskHandleNull
      36  KAL_TaskPrioSet
     142  KAL_TaskRegCreate
      80  KAL_TaskRegGet
       4  KAL_TaskRegHandleNull
      86  KAL_TaskRegSet
       8  KAL_TaskUUID_Get
      34  KAL_TickGet
      12  KAL_TickRateGet
     214  KAL_TmrCreate
       4  KAL_TmrHandleNull
      72  KAL_TmrStart
      28  KAL_msToTicks
     296  -- Other

 
     4 bytes in section .bss
   564 bytes in section .rodata
 4'050 bytes in section .text
 
 4'050 bytes of CODE  memory
   564 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
