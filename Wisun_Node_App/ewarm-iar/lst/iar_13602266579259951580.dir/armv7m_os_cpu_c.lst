###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:24
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\iar\armv7m_os_cpu_c.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\iar_13602266579259951580.dir\armv7m_os_cpu_c.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\iar\armv7m_os_cpu_c.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\iar_13602266579259951580.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\iar_13602266579259951580.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\iar\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\iar_13602266579259951580.dir\armv7m_os_cpu_c.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\iar_13602266579259951580.dir\armv7m_os_cpu_c.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\iar_13602266579259951580.dir\armv7m_os_cpu_c.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\iar\armv7m_os_cpu_c.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Kernel - ARM Cortex-M Port
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /****************************************************************************************************//**
     19           * @note     (1) This port targets the following:
     20           *                   Core      : ARMv7M and ARMv8M Cortex-M
     21           *                   Mode      : Thumb-2 ISA
     22           *                   Toolchain : IAR EWARM
     23           *
     24           * @note     (2) This port supports the ARM Cortex-M3, Cortex-M4, Cortex-M7 and Cortex-M33 architectures.
     25           *******************************************************************************************************/
     26          
     27          #define   OS_CPU_GLOBALS
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const CPU_CHAR *os_cpu_c__c = "$Id: $";
     31          #endif
     32          
     33          /********************************************************************************************************
     34           *                                               INCLUDE FILES
     35           *******************************************************************************************************/
     36          
     37          #include  <em_core.h>
     38          
     39          #include  <kernel/include/os.h>

   \                                 In section .bss, align 4
   \   __absolute CPU_STK *OS_CPU_ExceptStkBase
   \                     OS_CPU_ExceptStkBase:
   \        0x0                      DS8 4
     40          #include  <kernel/source/os_priv.h>
     41          
     42          #ifdef SL_COMPONENT_CATALOG_PRESENT
     43          #include "sl_component_catalog.h"
     44          #endif
     45          #ifdef SL_CATALOG_POWER_MANAGER_PRESENT
     46          #include <sl_power_manager.h>
     47          #endif
     48          
     49          #ifdef __cplusplus
     50          extern  "C" {
     51          #endif
     52          
     53          /********************************************************************************************************
     54           *                                             GLOBAL VARIABLES
     55           *******************************************************************************************************/
     56          #if (OS_CFG_ERRNO_EN == 1)
     57          extern int micriumos_errno;
     58          #endif
     59          
     60          /********************************************************************************************************
     61           *                                           FLOATING POINT DEFINES
     62           *******************************************************************************************************/
     63          
     64          #define  CPU_REG_FP_FPCCR              (*((CPU_REG32 *)0xE000EF34uL)) // Floating-Point Context Control Reg.
     65          
     66          //                                                                 Enabled FP lazy stacking and enable ..
     67          //                                                                 ..automatic state saving.
     68          #define  CPU_REG_FPCCR_LAZY_STK                        0xC0000000uL
     69          
     70          /********************************************************************************************************
     71           *                                            INTERRUPT HANDLING
     72           *******************************************************************************************************/
     73          
     74          #pragma optimize=speed

   \                                 In section .text, align 2, keep-with-next
     75          void OSDisableIRQ(void)
     76          {
     77          #if (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
     78            __set_BASEPRI(CORE_ATOMIC_BASE_PRIORITY_LEVEL << (8 - __NVIC_PRIO_BITS));
   \                     OSDisableIRQ: (+1)
   \        0x0   0x2030             MOVS     R0,#+48
   \        0x2   0xF380 0x8811      MSR      BASEPRI,R0
     79          #else
     80            __disable_irq();
     81          #endif
     82          }
   \        0x6   0x4770             BX       LR
     83          
     84          #pragma optimize=speed

   \                                 In section .text, align 2, keep-with-next
     85          void OSEnableIRQ(void)
     86          {
     87          #if (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
     88            __set_BASEPRI(0);
   \                     OSEnableIRQ: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0xF380 0x8811      MSR      BASEPRI,R0
     89          #else
     90            __enable_irq();
     91          #endif
     92          }
   \        0x6   0x4770             BX       LR
     93          
     94          /*****************************************************************************************************//**
     95           *                                         OSIdleContextPowerManagerHook
     96           *
     97           * @brief    This function allows to customize how the sleep mode is entered. However,
     98           *           sl_power_manager_sleep() MUST ultimately be called WITH the scheduler locked.
     99           *
    100           * @note     This function is for internal use only.
    101           *******************************************************************************************************/

   \                                 In section .text, align 2
    102          __WEAK void OSIdleContextPowerManagerHook(void)
    103          {
    104          #ifdef SL_CATALOG_POWER_MANAGER_PRESENT
    105            RTOS_ERR err;
    106          
    107            OSSchedLock(&err);
    108            OS_ASSERT_DBG_NO_ERR(RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE, RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
    109            sl_power_manager_sleep();
    110            OSSchedUnlock(&err);
    111            OS_ASSERT_DBG_NO_ERR(RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE, RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
    112          #endif
    113          }
   \                     OSIdleContextPowerManagerHook: (+1)
   \        0x0   0x4770             BX       LR
    114          
    115          /*****************************************************************************************************//**
    116           *                                             OSIdleContext
    117           *
    118           * @brief    This function handles idling. It should never return.
    119           *           Being called from an idle context, it means there is no context save.
    120           *           Extra care must be taken as no states will be saved and any set of instructions with side
    121           *           effects shall be performed in a critical section.
    122           *           This function is called using the isr stack.
    123           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    124          void OSIdleContext(void)
    125          {
    126          #ifdef SL_CATALOG_POWER_MANAGER_PRESENT
    127            OSIdleContextPowerManagerHook();
    128          #else
    129            while (1) {
    130              __NOP();
   \                     OSIdleContext: (+1)
   \                     ??OSIdleContext_0: (+1)
   \        0x0   0xBF00             Nop
   \        0x2   0xE7FD             B.N      ??OSIdleContext_0
    131            }
    132          #endif
    133          }
    134          
    135          /*****************************************************************************************************//**
    136           *                                               OSInitHook()
    137           *
    138           * @brief    Called by OSInit() at the beginning of OSInit().
    139           *
    140           * @note     (1) When using hardware floating point, follow these steps during the reset handler:
    141           *                - (a) Set full access for CP10 and CP11 bits in CPACR register.
    142           *                - (b) Set bits ASPEN and LSPEN in FPCCR register.
    143           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    144          void OSInitHook(void)
    145          {
    146          #if (OS_CPU_ARM_FP_EN > 0u)
    147            CPU_INT32U reg_val;
    148          #endif
    149            //                                                               8-byte align the ISR stack.
    150            OS_CPU_ExceptStkBase = (CPU_STK *)&OSCfg_ISRStkBasePtr[OSCfg_ISRStkSize - 1u];
   \                     OSInitHook: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable7
   \        0x2   0x....             LDR.N    R1,??DataTable7_1
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0x....             LDR.N    R2,??DataTable7_2
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \        0xE   0x1F09             SUBS     R1,R1,#+4
   \       0x10   0x6001             STR      R1,[R0, #+0]
    151            OS_CPU_ExceptStkBase = (CPU_STK *)((CPU_STK)(OS_CPU_ExceptStkBase) & 0xFFFFFFF8);
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x08C9             LSRS     R1,R1,#+3
   \       0x16   0x00C9             LSLS     R1,R1,#+3
   \       0x18   0x6001             STR      R1,[R0, #+0]
    152          
    153          #if (OS_CPU_ARM_FP_EN > 0u)
    154            reg_val = CPU_REG_FP_FPCCR;                                   // Check the floating point mode.
   \       0x1A   0x....             LDR.N    R0,??DataTable7_3
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
    155            if ((reg_val & CPU_REG_FPCCR_LAZY_STK) != CPU_REG_FPCCR_LAZY_STK) {
   \       0x1E   0xF011 0x4040      ANDS     R0,R1,#0xC0000000
   \       0x22   0xF1B0 0x4F40      CMP      R0,#+3221225472
   \       0x26   0xD000             BEQ.N    ??OSInitHook_0
    156              while (1u) {                                                // See Note (1).
   \                     ??OSInitHook_1: (+1)
   \       0x28   0xE7FE             B.N      ??OSInitHook_1
    157                ;
    158              }
    159            }
    160          #endif
    161          }
   \                     ??OSInitHook_0: (+1)
   \       0x2A   0x4770             BX       LR
    162          
    163          /****************************************************************************************************//**
    164           *                                           OSRedzoneHitHook()
    165           *
    166           * @brief    Called when a task's stack has overflowed.
    167           *
    168           * @param    p_tcb   Pointer to the TCB of the offending task. NULL if ISR.
    169           *******************************************************************************************************/
    170          
    171          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    172          void OSRedzoneHitHook(OS_TCB *p_tcb)
    173          {
    174            CORE_DECLARE_IRQ_STATE;
    175          
    176            CORE_ENTER_ATOMIC();
    177          #if OS_CFG_APP_HOOKS_EN > 0u
    178            if (OS_AppRedzoneHitHookPtr != (OS_APP_HOOK_TCB)0) {
    179              (*OS_AppRedzoneHitHookPtr)(p_tcb);
    180            } else {
    181              CPU_SW_EXCEPTION(; );
    182            }
    183          #else
    184            (void)p_tcb;                                                  // Prevent compiler warning
    185            CPU_SW_EXCEPTION(; );
    186          #endif
    187            CORE_EXIT_ATOMIC();
    188          }
    189          #endif
    190          
    191          /****************************************************************************************************//**
    192           *                                               OSStatTaskHook()
    193           *
    194           * @brief    This function is called every second by the Kernel's statistics task.  This allows your
    195           *           application to add functionality to the statistics task.
    196           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    197          void OSStatTaskHook(void)
    198          {
   \                     OSStatTaskHook: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    199          #if OS_CFG_APP_HOOKS_EN > 0u
    200            if (OS_AppStatTaskHookPtr != (OS_APP_HOOK_VOID)0) {
   \        0x2   0x....             LDR.N    R1,??DataTable7_4
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??OSStatTaskHook_0
    201              (*OS_AppStatTaskHookPtr)();
   \        0xA   0x6808             LDR      R0,[R1, #+0]
   \        0xC   0x4780             BLX      R0
    202            }
    203          #endif
    204          }
   \                     ??OSStatTaskHook_0: (+1)
   \        0xE   0xBD01             POP      {R0,PC}
    205          
    206          /****************************************************************************************************//**
    207           *                                           OSTaskCreateHook()
    208           *
    209           * @brief    Called when a task is created.
    210           *
    211           * @param    p_tcb   Pointer to the TCB of the task being created.
    212           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    213          void OSTaskCreateHook(OS_TCB *p_tcb)
    214          {
   \                     OSTaskCreateHook: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    215          #if OS_CFG_APP_HOOKS_EN > 0u
    216            if (OS_AppTaskCreateHookPtr != (OS_APP_HOOK_TCB)0) {
   \        0x4   0x....             LDR.N    R1,??DataTable7_5
   \        0x6   0x6808             LDR      R0,[R1, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??OSTaskCreateHook_0
    217              (*OS_AppTaskCreateHookPtr)(p_tcb);
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0x4788             BLX      R1
    218            }
    219          #else
    220            (void)p_tcb;                                                  // Prevent compiler warning
    221          #endif
    222          }
   \                     ??OSTaskCreateHook_0: (+1)
   \       0x12   0xBD10             POP      {R4,PC}
    223          
    224          /****************************************************************************************************//**
    225           *                                               OSTaskDelHook()
    226           *
    227           * @brief    Called when a task is deleted.
    228           *
    229           * @param    p_tcb   Pointer to the TCB of the task being deleted.
    230           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    231          void OSTaskDelHook(OS_TCB *p_tcb)
    232          {
   \                     OSTaskDelHook: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    233          #if OS_CFG_APP_HOOKS_EN > 0u
    234            if (OS_AppTaskDelHookPtr != (OS_APP_HOOK_TCB)0) {
   \        0x4   0x....             LDR.N    R1,??DataTable7_6
   \        0x6   0x6808             LDR      R0,[R1, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??OSTaskDelHook_0
    235              (*OS_AppTaskDelHookPtr)(p_tcb);
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0x4788             BLX      R1
    236            }
    237          #else
    238            (void)p_tcb;                                                  // Prevent compiler warning
    239          #endif
    240          }
   \                     ??OSTaskDelHook_0: (+1)
   \       0x12   0xBD10             POP      {R4,PC}
    241          
    242          /****************************************************************************************************//**
    243           *                                           OSTaskReturnHook()
    244           *
    245           * @brief    Called if a task accidentally returns. In other words, a task should either be an infinite
    246           *           loop or delete itself when done.
    247           *
    248           * @param    p_tcb   Pointer to the TCB of the task that is returning.
    249           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    250          void OSTaskReturnHook(OS_TCB *p_tcb)
    251          {
   \                     OSTaskReturnHook: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    252          #if OS_CFG_APP_HOOKS_EN > 0u
    253            if (OS_AppTaskReturnHookPtr != (OS_APP_HOOK_TCB)0) {
   \        0x4   0x....             LDR.N    R1,??DataTable7_7
   \        0x6   0x6808             LDR      R0,[R1, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??OSTaskReturnHook_0
    254              (*OS_AppTaskReturnHookPtr)(p_tcb);
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0x4788             BLX      R1
    255            }
    256          #else
    257            (void)p_tcb;                                                  // Prevent compiler warning
    258          #endif
    259          }
   \                     ??OSTaskReturnHook_0: (+1)
   \       0x12   0xBD10             POP      {R4,PC}
    260          
    261          /****************************************************************************************************//**
    262           *                                               OSTaskStkInit()
    263           *
    264           * @brief    Initializes the stack frame of the task being created as if it had been already
    265           *           switched-out. This function is called by OSTaskCreate() and is highly processor specific.
    266           *
    267           * @param    p_task          Pointer to the task entry point address.
    268           *
    269           * @param    p_arg           Pointer to a user-supplied data area that will be passed to the task
    270           *                           when the task first executes.
    271           *
    272           * @param    p_stk_base      Pointer to the base address of the stack.
    273           *
    274           * @param    p_stk_limit     Pointer to the element to set as the 'watermark' limit of the stack.
    275           *
    276           * @param    stk_size        Size of the stack (measured as number of CPU_STK elements).
    277           *
    278           * @param    opt             Options used to alter the behavior of OSTaskStkInit().
    279           *                           See OS.H for OS_TASK_OPT_xxx.
    280           *
    281           * @return   Always returns the location of the new top-of-stack once the processor registers have
    282           *           been placed on the stack in the proper order.
    283           *
    284           * @note     (1) Interrupts are enabled when task starts executing.
    285           *
    286           * @note     (2) All tasks run in Thread mode, using process stack.
    287           *
    288           * @note     (3) There are two different stack frames depending on whether the Floating-Point(FP)
    289           *               co-processor is enabled or not.
    290           *               - (a) The stack frame shown in the diagram is used when the Co-processor Access Control
    291           *                     Register(CPACR) is disabling the Floating Point Unit. In this case, the FP
    292           *                     registers(S0- S31) & FP Status Control(FPSCR) register are not saved in the stack frame.
    293           *               - (b) The stack frame shown in the diagram is used when the Floating Point Unit is enabled,
    294           *                     that is, CP10 and CP11 field in CPACR are ones and FPCCR sets bits ASPEN and LSPEN to 1,
    295           *                     and also only when a FP instruction is used.
    296           *               - (c) When enabling the FPU through CPACR, make sure to set bits ASPEN and LSPEN in the
    297           *                     Floating-Point Context Control Register (FPCCR).
    298           *                       @verbatim
    299           *                                               +-------------+
    300           *                                               |             |
    301           *                                               +-------------+
    302           *                                               |             |
    303           *                                               +-------------+
    304           *                                               |    FPSCR    |
    305           *                                               +-------------+
    306           *                                               |     S15     |
    307           *                                               +-------------+
    308           *                                               |     S14     |
    309           *                                               +-------------+
    310           *                                               |     S13     |
    311           *                                               +-------------+
    312           *                                                       .
    313           *                                                       .
    314           *                                                       .
    315           *                                               +-------------+
    316           *                                               |     S2      |
    317           *                                               +-------------+
    318           *                                               |     S1      |
    319           *                         +-------------+       +-------------+
    320           *                         |             |       |     S0      |
    321           *                         +-------------+       +-------------+
    322           *                         |    xPSR     |       |    xPSR     |
    323           *                         +-------------+       +-------------+
    324           *                         | Return Addr |       | Return Addr |
    325           *                         +-------------+       +-------------+
    326           *                         |  LR(R14)    |       |   LR(R14)   |
    327           *                         +-------------+       +-------------+
    328           *                         |    R12      |       |     R12     |
    329           *                         +-------------+       +-------------+
    330           *                         |    R3       |       |     R3      |
    331           *                         +-------------+       +-------------+
    332           *                         |    R2       |       |     R2      |
    333           *                         +-------------+       +-------------+
    334           *                         |    R1       |       |     R1      |
    335           *                         +-------------+       +-------------+
    336           *                         |    R0       |       |     R0      |
    337           *                         +-------------+       +-------------+
    338           *                         | EXEC_RETURN |       |     S31     |
    339           *                         +-------------+       +-------------+
    340           *                         |    R11      |       |     S30     |
    341           *                         +-------------+       +-------------+
    342           *                         |    R10      |       |     S29     |
    343           *                         +-------------+       +-------------+
    344           *                         |    R9       |               .
    345           *                         +-------------+               .
    346           *                         |    R8       |               .
    347           *                         +-------------+       +-------------+
    348           *                         |    R7       |       |     S17     |
    349           *                         +-------------+       +-------------+
    350           *                         |    R6       |       |     S16     |
    351           *                         +-------------+       +-------------+
    352           *                         |    R5       |       | EXEC_RETURN |
    353           *                         +-------------+       +-------------+
    354           *                         |    R4       |       |     R11     |
    355           *                         +-------------+       +-------------+
    356           *                            - (a)              |     R10     |
    357           *                                               +-------------+
    358           *                                               |     R9      |
    359           *                                               +-------------+
    360           *                                               |     R8      |
    361           *                                               +-------------+
    362           *                                               |     R7      |
    363           *                                               +-------------+
    364           *                                               |     R6      |
    365           *                                               +-------------+
    366           *                                               |     R5      |
    367           *                                               +-------------+
    368           *                                               |     R4      |
    369           *                                               +-------------+
    370           *                       @endverbatim
    371           * @note     (4) The SP must be 8-byte aligned in conforming to the Procedure Call Standard for the ARM architecture
    372           *               - (a) Section 2.1 of the  ABI for the ARM Architecture Advisory Note. SP must be 8-byte aligned
    373           *                     on entry to AAPCS-Conforming functions states :
    374           *                     The Procedure Call Standard for the ARM Architecture [AAPCS] requires primitive
    375           *                     data types to be naturally aligned according to their sizes (for size = 1, 2, 4, 8 bytes).
    376           *                     Doing otherwise creates more problems than it solves.
    377           *                     In return for preserving the natural alignment of data, conforming code is permitted
    378           *                     to rely on that alignment. To support aligning data allocated on the stack, the stack
    379           *                     pointer (SP) is required to be 8-byte aligned on entry to a conforming function. In
    380           *                     practice this requirement is met if:
    381           *                   - (1) At each call site, the current size of the calling function's stack frame is a multiple of 8 bytes.
    382           *                         This places an obligation on compilers and assembly language programmers.
    383           *                   - (2) SP is a multiple of 8 when control first enters a program.
    384           *                         This places an obligation on authors of low level OS, RTOS, and runtime library
    385           *                         code to align SP at all points at which control first enters
    386           *                         a body of (AAPCS-conforming) code.
    387           *                     In turn, this requires the value of SP to be aligned to 0 modulo 8:
    388           *                   - (3) By exception handlers, before calling AAPCS-conforming code.
    389           *                   - (4) By OS/RTOS/run-time system code, before giving control to an application.
    390           *               - (b) Section 2.3.1 corrective steps from the the SP must be 8-byte aligned on entry
    391           *                     to AAPCS-conforming functions advisory note also states.
    392           *                     " This requirement extends to operating systems and run-time code for all architecture versions
    393           *                     prior to ARMV7 and to the A, R and M architecture profiles thereafter. Special considerations
    394           *                     associated with ARMV7M are discussed in section 2.3.3"
    395           *                   - (1) Even if the SP 8-byte aligment is not a requirement for the ARMv7M profile, the stack is aligned
    396           *                         to 8-byte boundaries to support legacy execution enviroments.
    397           *               - (c) Section 5.2.1.2 from the Procedure Call Standard for the ARM
    398           *                     architecture states :  "The stack must also conform to the following
    399           *                     constraint at a public interface:
    400           *                   - (1) SP mod 8 = 0. The stack must be double-word aligned"
    401           *               - (d) From the ARM Technical Support Knowledge Base. 8 Byte stack aligment.
    402           *                     "8 byte stack alignment is a requirement of the ARM Architecture Procedure
    403           *                     Call Standard [AAPCS]. This specifies that functions must maintain an 8 byte
    404           *                     aligned stack address (e.g. 0x00, 0x08, 0x10, 0x18, 0x20) on all external
    405           *                     interfaces. In practice this requirement is met if:
    406           *                   - (1) At each external interface, the current stack pointer
    407           *                         is a multiple of 8 bytes.
    408           *                   - (2) Your OS maintains 8 byte stack alignment on its external interfaces
    409           *                         e.g. on task switches"
    410           *
    411           * @note     (5) Exception Return Behavior(EXEC_RETURN)
    412           *               0xFFFFFFFD  Return to Thread mode, exception return uses non-floating point state
    413           *                           from the PSP and execution uses PSP after return.
    414           *               0xFFFFFFBC  If SL_TRUSTZONE_NONSECURE,
    415           *                           Security state is Non-Secure, Non-Secure stack used,
    416           *                           return to Thread mode, exception return uses non-floating point state
    417           *                           from the PSP and execution uses PSP after return
    418           *                @n
    419           *               Non-floating point state is set at stack initialization. If FPU is enabled and a FP
    420           *               instruction is used, the state will change dynamically allowing to save the FP
    421           *               registers on-demand.
    422           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    423          CPU_STK *OSTaskStkInit(OS_TASK_PTR  p_task,
    424                                 void         *p_arg,
    425                                 CPU_STK      *p_stk_base,
    426                                 CPU_STK      *p_stk_limit,
    427                                 CPU_STK_SIZE stk_size,
    428                                 OS_OPT       opt)
    429          {
   \                     OSTaskStkInit: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x9D03             LDR      R5,[SP, #+12]
    430            CPU_STK *p_stk;
    431          
    432            (void)opt;                                                    // 'opt' is not used, prevent warning
    433          
    434            p_stk = &p_stk_base[stk_size];                                // Load stack pointer
   \        0x6   0xEB02 0x0085      ADD      R0,R2,R5, LSL #+2
    435                                                                          // Align the stack to 8-bytes.
    436            p_stk = (CPU_STK *)((CPU_STK)(p_stk) & 0xFFFFFFF8u);
   \        0xA   0x08C0             LSRS     R0,R0,#+3
   \        0xC   0x00C0             LSLS     R0,R0,#+3
    437            //                                                               Registers stacked as if auto-saved on exception
    438          
    439            *(--p_stk) = (CPU_STK)0x01000000u;                            // xPSR
   \        0xE   0x1F06             SUBS     R6,R0,#+4
   \       0x10   0xF05F 0x7080      MOVS     R0,#+16777216
   \       0x14   0x6030             STR      R0,[R6, #+0]
    440            *(--p_stk) = (CPU_STK)p_task;                                 // Entry Point
   \       0x16   0x1F30             SUBS     R0,R6,#+4
   \       0x18   0x6004             STR      R4,[R0, #+0]
    441            *(--p_stk) = (CPU_STK)OS_TaskReturn;                          // R14 (LR)
   \       0x1A   0x1F06             SUBS     R6,R0,#+4
   \       0x1C   0x....             LDR.N    R0,??DataTable7_8
   \       0x1E   0x6030             STR      R0,[R6, #+0]
    442            *(--p_stk) = (CPU_STK)0x12121212u;                            // R12
   \       0x20   0x1F36             SUBS     R6,R6,#+4
   \       0x22   0xF05F 0x3012      MOVS     R0,#+303174162
   \       0x26   0x6030             STR      R0,[R6, #+0]
    443            *(--p_stk) = (CPU_STK)0x03030303u;                            // R3
   \       0x28   0x1F36             SUBS     R6,R6,#+4
   \       0x2A   0xF05F 0x3003      MOVS     R0,#+50529027
   \       0x2E   0x6030             STR      R0,[R6, #+0]
    444            *(--p_stk) = (CPU_STK)0x02020202u;                            // R2
   \       0x30   0x1F36             SUBS     R6,R6,#+4
   \       0x32   0xF05F 0x3002      MOVS     R0,#+33686018
   \       0x36   0x6030             STR      R0,[R6, #+0]
    445            *(--p_stk) = (CPU_STK)p_stk_limit;                            // R1
   \       0x38   0x1F30             SUBS     R0,R6,#+4
   \       0x3A   0x6003             STR      R3,[R0, #+0]
    446            *(--p_stk) = (CPU_STK)p_arg;                                  // R0 : argument
   \       0x3C   0x1F00             SUBS     R0,R0,#+4
   \       0x3E   0x6001             STR      R1,[R0, #+0]
    447          
    448          #if defined(SL_TRUSTZONE_NONSECURE)
    449            *(--p_stk) = (CPU_STK)0xFFFFFFBCuL;                           // R14: EXEC_RETURN; See Note 5
    450          #else
    451            *(--p_stk) = (CPU_STK)0xFFFFFFFDuL;                           // R14: EXEC_RETURN; See Note 5
   \       0x40   0x1F06             SUBS     R6,R0,#+4
   \       0x42   0xF07F 0x0002      MVNS     R0,#+2
   \       0x46   0x6030             STR      R0,[R6, #+0]
    452          #endif
    453            //                                                               Remaining registers saved on process stack
    454            *(--p_stk) = (CPU_STK)0x11111111uL;                           // R11
   \       0x48   0x1F36             SUBS     R6,R6,#+4
   \       0x4A   0xF05F 0x3011      MOVS     R0,#+286331153
   \       0x4E   0x6030             STR      R0,[R6, #+0]
    455            *(--p_stk) = (CPU_STK)0x10101010uL;                           // R10
   \       0x50   0x1F36             SUBS     R6,R6,#+4
   \       0x52   0xF05F 0x3010      MOVS     R0,#+269488144
   \       0x56   0x6030             STR      R0,[R6, #+0]
    456            *(--p_stk) = (CPU_STK)0x09090909uL;                           // R9
   \       0x58   0x1F36             SUBS     R6,R6,#+4
   \       0x5A   0xF05F 0x3009      MOVS     R0,#+151587081
   \       0x5E   0x6030             STR      R0,[R6, #+0]
    457            *(--p_stk) = (CPU_STK)0x08080808uL;                           // R8
   \       0x60   0x1F36             SUBS     R6,R6,#+4
   \       0x62   0xF05F 0x3008      MOVS     R0,#+134744072
   \       0x66   0x6030             STR      R0,[R6, #+0]
    458            *(--p_stk) = (CPU_STK)0x07070707uL;                           // R7
   \       0x68   0x1F36             SUBS     R6,R6,#+4
   \       0x6A   0xF05F 0x3007      MOVS     R0,#+117901063
   \       0x6E   0x6030             STR      R0,[R6, #+0]
    459            *(--p_stk) = (CPU_STK)0x06060606uL;                           // R6
   \       0x70   0x1F36             SUBS     R6,R6,#+4
   \       0x72   0xF05F 0x3006      MOVS     R0,#+101058054
   \       0x76   0x6030             STR      R0,[R6, #+0]
    460            *(--p_stk) = (CPU_STK)0x05050505uL;                           // R5
   \       0x78   0x1F36             SUBS     R6,R6,#+4
   \       0x7A   0xF05F 0x3005      MOVS     R0,#+84215045
   \       0x7E   0x6030             STR      R0,[R6, #+0]
    461            *(--p_stk) = (CPU_STK)0x04040404uL;                           // R4
   \       0x80   0x1F30             SUBS     R0,R6,#+4
   \       0x82   0xF05F 0x3604      MOVS     R6,#+67372036
   \       0x86   0x6006             STR      R6,[R0, #+0]
    462          
    463            return (p_stk);
   \       0x88   0xBC70             POP      {R4-R6}
   \       0x8A   0x4770             BX       LR
    464          }
    465          
    466          /****************************************************************************************************//**
    467           *                                               OSTaskSwHook()
    468           *
    469           * @brief    Allows you to perform other operations during a context switch. This function is called
    470           *           when a task switch is performed.
    471           *
    472           * @note     (1) Interrupts are disabled during this call.
    473           *
    474           * @note     (2) It is assumed that the global pointer 'OSTCBHighRdyPtr' points to the TCB of the task
    475           *               that will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCurPtr' points
    476           *               to the task being switched out (i.e. the preempted task).
    477           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    478          void OSTaskSwHook(void)
    479          {
   \                     OSTaskSwHook: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    480          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    481            CPU_BOOLEAN stk_status;
    482          #endif
    483          
    484          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    485            if (OSTCBHighRdyPtr != DEF_NULL && OSSchedRoundRobinEn) {
    486              if (OSTCBHighRdyPtr->TimeQuantaCtr == 0u) {
    487                OS_SchedRoundRobinResetQuanta(OSTCBHighRdyPtr);
    488              }
    489              OS_SchedRoundRobinRestartTimer(OSTCBHighRdyPtr);
    490            }
    491          #endif
    492          
    493          #if OS_CFG_APP_HOOKS_EN > 0u
    494            if (OS_AppTaskSwHookPtr != (OS_APP_HOOK_VOID)0) {
   \        0x2   0x....             LDR.N    R1,??DataTable7_9
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??OSTaskSwHook_0
    495              (*OS_AppTaskSwHookPtr)();
   \        0xA   0x6808             LDR      R0,[R1, #+0]
   \        0xC   0x4780             BLX      R0
    496            }
    497          #endif
    498          
    499            OS_TRACE_TASK_SWITCHED_IN(OSTCBHighRdyPtr);
    500          
    501          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    502            if (OSTCBCurPtr != DEF_NULL) {
    503              int_dis_time = CPU_IntDisMeasMaxCurReset();                 // Keep track of per-task interrupt disable time
    504              if (OSTCBCurPtr->IntDisTimeMax < int_dis_time) {
    505                OSTCBCurPtr->IntDisTimeMax = int_dis_time;
    506              }
    507            }
    508          #endif
    509          
    510          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    511            //                                                               Keep track of per-task scheduler lock time
    512            if ((OSTCBCurPtr != DEF_NULL)
    513                && (OSTCBCurPtr->SchedLockTimeMax < OSSchedLockTimeMaxCur)) {
    514              OSTCBCurPtr->SchedLockTimeMax = OSSchedLockTimeMaxCur;
    515            }
    516            OSSchedLockTimeMaxCur = (CPU_TS)0;                            // Reset the per-task value
    517          #endif
    518          
    519          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    520            //                                                               Check if stack overflowed.
    521            if (OSTCBCurPtr != DEF_NULL) {
    522              stk_status = OSTaskStkRedzoneChk(DEF_NULL);
    523              if (stk_status != DEF_OK) {
    524                OSRedzoneHitHook(OSTCBCurPtr);
    525              }
    526            }
    527          #endif
    528          
    529          #if (OS_CFG_ERRNO_EN == 1)
    530            if (OSTCBCurPtr != DEF_NULL) {
   \                     ??OSTaskSwHook_0: (+1)
   \        0xE   0x....             LDR.N    R1,??DataTable7_10
   \       0x10   0x6808             LDR      R0,[R1, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD004             BEQ.N    ??OSTaskSwHook_1
    531              OSTCBCurPtr->local_errno = micriumos_errno;
   \       0x16   0x....             LDR.N    R0,??DataTable7_11
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x6809             LDR      R1,[R1, #+0]
   \       0x1C   0xF8C1 0x0098      STR      R0,[R1, #+152]
    532            }
    533            if (OSTCBHighRdyPtr != DEF_NULL) {
   \                     ??OSTaskSwHook_1: (+1)
   \       0x20   0x....             LDR.N    R1,??DataTable7_12
   \       0x22   0x6808             LDR      R0,[R1, #+0]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD004             BEQ.N    ??OSTaskSwHook_2
    534              micriumos_errno = OSTCBHighRdyPtr->local_errno;
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0xF8D0 0x1098      LDR      R1,[R0, #+152]
   \       0x2E   0x....             LDR.N    R0,??DataTable7_11
   \       0x30   0x6001             STR      R1,[R0, #+0]
    535            }
    536          #endif
    537          }
   \                     ??OSTaskSwHook_2: (+1)
   \       0x32   0xBD01             POP      {R0,PC}
    538          
    539          /*****************************************************************************************************//**
    540           *                                             OSCanReturnToSleep()
    541           *
    542           * @brief    Allows performing other operations during an Idle check.
    543           *
    544           * @return   True, if the system can sleep after the interrupt.
    545           *           False, otherwise.
    546           *******************************************************************************************************/

   \                                 In section .text, align 2
    547          __WEAK bool OSCanReturnToSleep(void)
    548          {
   \                     OSCanReturnToSleep: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    549            return (OSIsIdle());
   \        0x2   0x.... 0x....      BL       OSIsIdle
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??OSCanReturnToSleep_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??OSCanReturnToSleep_1
   \                     ??OSCanReturnToSleep_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??OSCanReturnToSleep_1: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0xBD02             POP      {R1,PC}
    550          }
    551          
    552          /***************************************************************************//**
    553           * Check if the MCU can sleep after an interrupt.
    554           *
    555           * @return  True, if the system can sleep after the interrupt.
    556           *          False, otherwise.
    557           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    558          bool sl_power_manager_sleep_on_isr_exit(void)
    559          {
   \                     sl_power_manager_sleep_on_isr_exit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    560            return (OSCanReturnToSleep());
   \        0x2   0x.... 0x....      BL       OSCanReturnToSleep
   \        0x6   0xBD02             POP      {R1,PC}
    561          }
    562          
    563          /***************************************************************************//**
    564           * Check if sleep must be cancelled
    565           *
    566           * @return  True, if the system can go to sleep.
    567           *          False, otherwise.
    568           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    569          bool sl_power_manager_is_ok_to_sleep(void)
    570          {
   \                     sl_power_manager_is_ok_to_sleep: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    571            return (OSIsIdle());
   \        0x2   0x.... 0x....      BL       OSIsIdle
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??sl_power_manager_is_ok_to_sleep_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??sl_power_manager_is_ok_to_sleep_1
   \                     ??sl_power_manager_is_ok_to_sleep_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??sl_power_manager_is_ok_to_sleep_1: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0xBD02             POP      {R1,PC}
    572          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     OS_CPU_ExceptStkBase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x....'....        DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0xE000'EF34        DC32     0xe000ef34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x....'....        DC32     OS_AppStatTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x....'....        DC32     OS_AppTaskCreateHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0x....'....        DC32     OS_AppTaskDelHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0x....'....        DC32     OS_AppTaskReturnHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \        0x0   0x....'....        DC32     OS_TaskReturn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \        0x0   0x....'....        DC32     OS_AppTaskSwHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \        0x0   0x....'....        DC32     micriumos_errno

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \        0x0   0x....'....        DC32     OSTCBHighRdyPtr
    573          
    574          #ifdef __cplusplus
    575          }
    576          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OSCanReturnToSleep
         8   -> OSIsIdle
       0   OSDisableIRQ
       0   OSEnableIRQ
       0   OSIdleContext
       0   OSIdleContextPowerManagerHook
       0   OSInitHook
       8   OSStatTaskHook
         8   -- Indirect call
       8   OSTaskCreateHook
         8   -- Indirect call
       8   OSTaskDelHook
         8   -- Indirect call
       8   OSTaskReturnHook
         8   -- Indirect call
      12   OSTaskStkInit
       8   OSTaskSwHook
         8   -- Indirect call
       8   sl_power_manager_is_ok_to_sleep
         8   -> OSIsIdle
       8   sl_power_manager_sleep_on_isr_exit
         8   -> OSCanReturnToSleep


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      20  OSCanReturnToSleep
       8  OSDisableIRQ
       8  OSEnableIRQ
       4  OSIdleContext
       2  OSIdleContextPowerManagerHook
      44  OSInitHook
      16  OSStatTaskHook
      20  OSTaskCreateHook
      20  OSTaskDelHook
      20  OSTaskReturnHook
     140  OSTaskStkInit
      52  OSTaskSwHook
       4  OS_CPU_ExceptStkBase
      20  sl_power_manager_is_ok_to_sleep
       8  sl_power_manager_sleep_on_isr_exit

 
   4 bytes in section .bss
 434 bytes in section .text
 
 412 bytes of CODE memory (+ 22 bytes shared)
   4 bytes of DATA memory

Errors: none
Warnings: none
