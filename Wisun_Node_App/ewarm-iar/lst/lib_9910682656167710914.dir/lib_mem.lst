###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:27
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\lib\lib_mem.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\lib_9910682656167710914.dir\lib_mem.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\lib\lib_mem.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\lib_9910682656167710914.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\lib_9910682656167710914.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\lib\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\lib_9910682656167710914.dir\lib_mem.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\lib_9910682656167710914.dir\lib_mem.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\lib_9910682656167710914.dir\lib_mem.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\lib\lib_mem.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Common - Memory Operations
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                               INCLUDE FILES
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <em_core.h>
     25          
     26          #include  <cpu/include/cpu.h>
     27          
     28          #include  <common/include/rtos_path.h>
     29          #include  <common_cfg.h>
     30          
     31          #include  <common/include/rtos_err.h>
     32          #include  <common/include/toolchains.h>
     33          #include  <common/include/lib_mem.h>
     34          #include  <common/include/lib_math.h>
     35          #include  <common/include/lib_str.h>
     36          #include  <common/include/lib_utils.h>
     37          
     38          #include  <common/source/rtos/rtos_utils_priv.h>
     39          #include  <common/source/kal/kal_priv.h>
     40          #include  <common/source/logging/logging_priv.h>
     41          
     42          /********************************************************************************************************
     43           ********************************************************************************************************
     44           *                                               LOCAL DEFINES
     45           ********************************************************************************************************
     46           *******************************************************************************************************/
     47          
     48          #define  LOG_DFLT_CH                       (COMMON, LIB)
     49          #define  RTOS_MODULE_CUR                    RTOS_CFG_MODULE_COMMON
     50          
     51          /********************************************************************************************************
     52           *                                       DYNAMIC MEMORY POOL OPTIONS
     53           *******************************************************************************************************/
     54          
     55          #define  MEM_DYN_POOL_OPT_NONE              DEF_BIT_NONE
     56          #define  MEM_DYN_POOL_OPT_HW                DEF_BIT_00
     57          #define  MEM_DYN_POOL_OPT_PERSISTENT        DEF_BIT_01
     58          
     59          /********************************************************************************************************
     60           ********************************************************************************************************
     61           *                                           LOCAL DATA TYPES
     62           ********************************************************************************************************
     63           *******************************************************************************************************/
     64          
     65          typedef enum mem_seg_status {
     66            MEM_SEG_STATUS_NONE,
     67            MEM_SEG_STATUS_EXISTS,
     68            MEM_SEG_STATUS_OVERLAPS
     69          } MEM_SEG_STATUS;
     70          
     71          /********************************************************************************************************
     72           ********************************************************************************************************
     73           *                                       LOCAL GLOBAL VARIABLES
     74           ********************************************************************************************************
     75           *******************************************************************************************************/
     76          
     77          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
     78          #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR

   \                                 In section .bss, align 4
     79          CPU_INT08U Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                     // Mem heap data.
   \                     Mem_Heap:
   \        0x0                      DS8 9'216

   \                                 In section .data, align 4
     80          MEM_SEG    Mem_SegHeap = MEM_SEG_INIT("Heap", &Mem_Heap[0u], LIB_MEM_CFG_HEAP_SIZE, LIB_MEM_CFG_HEAP_PADDING_ALIGN);
   \                     Mem_SegHeap:
   \        0x0   0x....'....        DC32 Mem_Heap, Mem_Heap + 0x23ff, Mem_Heap, 0x0, 1
   \              0x....'....  
   \              0x....'....  
   \              0x0000'0000  
   \              0x0000'0001
     81          #else
     82          MEM_SEG Mem_SegHeap = MEM_SEG_INIT("Heap", (CPU_ADDR)LIB_MEM_CFG_HEAP_BASE_ADDR, LIB_MEM_CFG_HEAP_SIZE, LIB_MEM_CFG_HEAP_PADDING_ALIGN);
     83          #endif
     84          #endif
     85          

   \                                 In section .bss, align 4
     86          MEM_SEG *Mem_SegHeadPtr;                                        // Ptr to head of seg list.
   \                     Mem_SegHeadPtr:
   \        0x0                      DS8 4
     87          
     88          /********************************************************************************************************
     89           ********************************************************************************************************
     90           *                                       LOCAL FUNCTION PROTOTYPES
     91           ********************************************************************************************************
     92           *******************************************************************************************************/
     93          
     94          static void Mem_SegCreateCritical(const CPU_CHAR *p_name,
     95                                            MEM_SEG        *p_seg,
     96                                            CPU_ADDR       seg_base_addr,
     97                                            CPU_SIZE_T     padding_align,
     98                                            CPU_SIZE_T     size);
     99          
    100          #if (RTOS_ARG_CHK_EXT_EN)
    101          static MEM_SEG *Mem_SegOverlapChkCritical(CPU_ADDR       seg_base_addr,
    102                                                    CPU_SIZE_T     size,
    103                                                    MEM_SEG_STATUS *p_err);
    104          #endif
    105          
    106          static void *Mem_SegAllocInternal(const CPU_CHAR *p_name,
    107                                            MEM_SEG        *p_seg,
    108                                            CPU_SIZE_T     size,
    109                                            CPU_SIZE_T     align,
    110                                            CPU_SIZE_T     padding_align,
    111                                            CPU_SIZE_T     *p_bytes_reqd,
    112                                            RTOS_ERR       *p_err);
    113          
    114          static void *Mem_SegAllocExtCritical(MEM_SEG    *p_seg,
    115                                               CPU_SIZE_T size,
    116                                               CPU_SIZE_T align,
    117                                               CPU_SIZE_T padding_align,
    118                                               CPU_SIZE_T *p_bytes_reqd,
    119                                               RTOS_ERR   *p_err);
    120          
    121          static void Mem_DynPoolCreateInternal(const CPU_CHAR *p_name,
    122                                                MEM_DYN_POOL   *p_pool,
    123                                                MEM_SEG        *p_seg,
    124                                                CPU_SIZE_T     blk_size,
    125                                                CPU_SIZE_T     blk_align,
    126                                                CPU_SIZE_T     blk_qty_init,
    127                                                CPU_SIZE_T     blk_qty_max,
    128                                                RTOS_ERR       *p_err);
    129          
    130          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
    131          static void Mem_SegAllocTrackCritical(const CPU_CHAR *p_name,
    132                                                MEM_SEG        *p_seg,
    133                                                CPU_SIZE_T     size,
    134                                                RTOS_ERR       *p_err);
    135          #endif
    136          
    137          /********************************************************************************************************
    138           ********************************************************************************************************
    139           *                                           GLOBAL FUNCTIONS
    140           ********************************************************************************************************
    141           *******************************************************************************************************/
    142          
    143          /********************************************************************************************************
    144           *                                               Mem_Init()
    145           *
    146           * @brief   Initializes the Memory Management Module as follows :
    147           *               - (a) Initialize the heap memory pool.
    148           *               - (b) Initialize the memory pool table.
    149           *
    150           * @note     (1) The following function is deprecated. Unless already used, it should no longer be
    151           *               used, since they will be removed in a future version.
    152           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    153          void Mem_Init(void)
    154          {
   \                     Mem_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    155          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    156            {
    157              RTOS_ERR err;
    158          
    159              Mem_SegReg(&Mem_SegHeap,
    160                         &err);
   \        0x2   0x4669             MOV      R1,SP
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable17
   \        0x8   0x.... 0x....      BL       Mem_SegReg
    161              RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
   \        0xC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD001             BEQ.N    ??Mem_Init_0
   \       0x14   0x.... 0x....      BL       CPU_SW_Exception
    162            }
    163          #endif
    164          }
   \                     ??Mem_Init_0: (+1)
   \       0x18   0xB005             ADD      SP,SP,#+20
   \       0x1A   0xBD00             POP      {PC}
    165          
    166          /****************************************************************************************************//**
    167           *                                                   Mem_Clr()
    168           *
    169           * @brief    Clears the data buffer (see Note #2).
    170           *
    171           * @param    p_mem   Pointer to the memory buffer to clear.
    172           *
    173           * @param    size    Number of data buffer octets to clear (see Note #1).
    174           *
    175           * @note     (1) Null clears are allowed (i.e. zero-length clears).
    176           *               See also 'Mem_Set()  Note #1'.
    177           *******************************************************************************************************/
    178          
    179          #if (LIB_MEM_CFG_STD_C_LIB_EN == DEF_DISABLED)

   \                                 In section .text, align 2
    180          __WEAK void Mem_Clr(void       *p_mem,
    181                              CPU_SIZE_T size)
    182          {
   \                     Mem_Clr: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    183            Mem_Set(p_mem,
    184                    0u,                                                   // Clear data by setting each data octet to 0.
    185                    size);
   \        0x6   0x0022             MOVS     R2,R4
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0x.... 0x....      BL       Mem_Set
    186          }
   \       0x10   0xBD31             POP      {R0,R4,R5,PC}
    187          #endif
    188          
    189          /****************************************************************************************************//**
    190           *                                                   Mem_Set()
    191           *
    192           * @brief    Fills the data buffer with specified data octet.
    193           *
    194           * @param    p_mem       Pointer to the memory buffer to fill with the specified data octet.
    195           *
    196           * @param    data_val    Data filled octet value.
    197           *
    198           * @param    size        Number of data buffer octets to fill (see Note #1).
    199           *
    200           * @note     (1) Null sets are allowed (i.e. zero-length sets).
    201           *
    202           * @note     (2) For best CPU performance, this function fills the data buffer using 'CPU_ALIGN'-sized
    203           *               data words. Since many word-aligned processors REQUIRE that multi-octet words be
    204           *               accessed on word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on
    205           *               'CPU_ALIGN' addresses.
    206           *
    207           * @note     (3) Modulo arithmetic determines if a memory buffer starts on a 'CPU_ALIGN' address
    208           *               boundary.
    209           *               @n
    210           *               Modulo arithmetic in ANSI-C REQUIREs operations are performed on integer values, so
    211           *               address values MUST be cast to an appropriately-sized integer value before any
    212           *               'mem_align_mod' arithmetic operation.
    213           *******************************************************************************************************/
    214          
    215          #if (LIB_MEM_CFG_STD_C_LIB_EN == DEF_DISABLED)

   \                                 In section .text, align 2
    216          __WEAK void Mem_Set(void       *p_mem,
    217                              CPU_INT08U data_val,
    218                              CPU_SIZE_T size)
    219          {
   \                     Mem_Set: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    220            CPU_SIZE_T size_rem;
    221            CPU_ALIGN  data_align;
    222            CPU_ALIGN  *p_mem_align;
    223            CPU_INT08U *p_mem_08;
    224            CPU_DATA   mem_align_mod;
    225            CPU_DATA   i;
    226          
    227            if ((size < 1)                                                // See Note #1.
    228                || (p_mem == DEF_NULL)) {
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD001             BEQ.N    ??Mem_Set_0
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD100             BNE.N    ??Mem_Set_1
    229              return;
   \                     ??Mem_Set_0: (+1)
   \        0xA   0xE02C             B.N      ??Mem_Set_2
    230            }
    231          
    232            data_align = 0u;
   \                     ??Mem_Set_1: (+1)
   \        0xC   0x2500             MOVS     R5,#+0
    233            for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                    // Fill each data_align octet with data val.
   \        0xE   0x2700             MOVS     R7,#+0
   \                     ??Mem_Set_3: (+1)
   \       0x10   0x2F04             CMP      R7,#+4
   \       0x12   0xD206             BCS.N    ??Mem_Set_4
    234              data_align <<= DEF_OCTET_NBR_BITS;
   \       0x14   0x022D             LSLS     R5,R5,#+8
    235              data_align |= (CPU_ALIGN)data_val;
   \       0x16   0x002B             MOVS     R3,R5
   \       0x18   0x000D             MOVS     R5,R1
   \       0x1A   0xB2ED             UXTB     R5,R5
   \       0x1C   0x431D             ORRS     R5,R5,R3
    236            }
   \       0x1E   0x1C7F             ADDS     R7,R7,#+1
   \       0x20   0xE7F6             B.N      ??Mem_Set_3
    237          
    238            size_rem = size;                                              // See Note #3.
   \                     ??Mem_Set_4: (+1)
   \       0x22   0x0013             MOVS     R3,R2
    239            mem_align_mod = (CPU_INT08U)((CPU_ADDR)p_mem % sizeof(CPU_ALIGN));
   \       0x24   0xF010 0x0403      ANDS     R4,R0,#0x3
    240          
    241            p_mem_08 = (CPU_INT08U *)p_mem;
   \       0x28   0x0006             MOVS     R6,R0
    242            if (mem_align_mod != 0u) {                                    // If leading octets avail,                   ...
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD009             BEQ.N    ??Mem_Set_5
    243              i = mem_align_mod;
   \       0x2E   0x0027             MOVS     R7,R4
    244              while ((size_rem > 0)                                       // ... start mem buf fill with leading octets ...
    245                     && (i < sizeof(CPU_ALIGN))) {                        // ... until next CPU_ALIGN word boundary.
   \                     ??Mem_Set_6: (+1)
   \       0x30   0x2B00             CMP      R3,#+0
   \       0x32   0xD006             BEQ.N    ??Mem_Set_5
   \       0x34   0x2F04             CMP      R7,#+4
   \       0x36   0xD204             BCS.N    ??Mem_Set_5
    246                *p_mem_08++ = data_val;
   \       0x38   0x7031             STRB     R1,[R6, #+0]
   \       0x3A   0x1C76             ADDS     R6,R6,#+1
    247                size_rem -= sizeof(CPU_INT08U);
   \       0x3C   0x1E5B             SUBS     R3,R3,#+1
    248                i++;
   \       0x3E   0x1C7F             ADDS     R7,R7,#+1
   \       0x40   0xE7F6             B.N      ??Mem_Set_6
    249              }
    250            }
    251          
    252            p_mem_align = (CPU_ALIGN *)p_mem_08;                          // See Note #2.
   \                     ??Mem_Set_5: (+1)
   \       0x42   0x46B6             MOV      LR,R6
    253            while (size_rem >= sizeof(CPU_ALIGN)) {                       // While mem buf aligned on CPU_ALIGN word boundaries,
   \                     ??Mem_Set_7: (+1)
   \       0x44   0x2B04             CMP      R3,#+4
   \       0x46   0xD305             BCC.N    ??Mem_Set_8
    254              *p_mem_align++ = data_align;                                // ... fill mem buf with    CPU_ALIGN-sized data.
   \       0x48   0xF8CE 0x5000      STR      R5,[LR, #+0]
   \       0x4C   0xF11E 0x0E04      ADDS     LR,LR,#+4
    255              size_rem -= sizeof(CPU_ALIGN);
   \       0x50   0x1F1B             SUBS     R3,R3,#+4
   \       0x52   0xE7F7             B.N      ??Mem_Set_7
    256            }
    257          
    258            p_mem_08 = (CPU_INT08U *)p_mem_align;
   \                     ??Mem_Set_8: (+1)
   \       0x54   0x46F4             MOV      R12,LR
    259            while (size_rem > 0) {                                        // Finish mem buf fill with trailing octets.
   \                     ??Mem_Set_9: (+1)
   \       0x56   0x2B00             CMP      R3,#+0
   \       0x58   0xD005             BEQ.N    ??Mem_Set_10
    260              *p_mem_08++ = data_val;
   \       0x5A   0xF88C 0x1000      STRB     R1,[R12, #+0]
   \       0x5E   0xF11C 0x0C01      ADDS     R12,R12,#+1
    261              size_rem -= sizeof(CPU_INT08U);
   \       0x62   0x1E5B             SUBS     R3,R3,#+1
   \       0x64   0xE7F7             B.N      ??Mem_Set_9
    262            }
    263          }
   \                     ??Mem_Set_10: (+1)
   \                     ??Mem_Set_2: (+1)
   \       0x66   0xBDF0             POP      {R4-R7,PC}
    264          #endif
    265          
    266          /****************************************************************************************************//**
    267           *                                               Mem_Copy()
    268           *
    269           * @brief    Copies data octets from one memory buffer to another memory buffer.
    270           *
    271           * @param    p_dest  Pointer to the destination memory buffer.
    272           *
    273           * @param    p_src   Pointer to the source memory buffer.
    274           *
    275           * @param    size    Number of octets to copy (see Note #1).
    276           *
    277           * @note     (1) Null copies are allowed (i.e. zero-length copies).
    278           *
    279           * @note     (2) Memory buffers NOT checked for overlapping.
    280           *               - (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
    281           *                     copying takes place between objects that overlap, the behavior is undefined".
    282           *               - (b) Data octets from a source memory buffer at a higher address value SHOULD
    283           *                     successfully copy to a destination memory buffer at a lower address value. This
    284           *                     occurs even if any octets of the memory buffers overlap, as long as there are no
    285           *                     individual, atomic CPU word copy overlaps.
    286           *                     @n
    287           *                     Since Mem_Copy() copies the data octet via 'CPU_ALIGN'-sized words &/or octets,
    288           *                     and since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses (see
    289           *                     Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
    290           *                     ever overlap.
    291           *                     @n
    292           *                     Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
    293           *                     buffers as long as the source memory buffer is at a higher address value than the
    294           *                     destination memory buffer.
    295           *
    296           * @note     (3) For best CPU performance, this function copies data buffers using 'CPU_ALIGN'-sized
    297           *               data words. Since many word-aligned processors REQUIRE that multi-octet words be
    298           *               accessed on word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on
    299           *               'CPU_ALIGN' addresses.
    300           *
    301           * @note     (4) Modulo arithmetic determines if a memory buffer starts on a 'CPU_ALIGN' address
    302           *               boundary.
    303           *               @n
    304           *               Modulo arithmetic in ANSI-C REQUIRE operations are performed on integer values, so
    305           *               address values MUST be cast to an appropriately-sized integer value before any
    306           *               'mem_align_mod' arithmetic operation.
    307           *******************************************************************************************************/
    308          
    309          #if ((LIB_MEM_CFG_STD_C_LIB_EN == DEF_DISABLED) \
    310            && (LIB_MEM_CFG_MEM_COPY_OPTIMIZE_ASM_EN == DEF_DISABLED))

   \                                 In section .text, align 2
    311          __WEAK LIB_MEM_COPY_FNCT_PREFIX void Mem_Copy(void       *p_dest,
    312                                                        const void *p_src,
    313                                                        CPU_SIZE_T size)
    314          {
   \                     Mem_Copy: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x0003             MOVS     R3,R0
    315            CPU_SIZE_T       size_rem;
    316            CPU_SIZE_T       mem_gap_octets;
    317            CPU_ALIGN        *p_mem_align_dest;
    318            const CPU_ALIGN  *p_mem_align_src;
    319            CPU_INT08U       *p_mem_08_dest;
    320            const CPU_INT08U *p_mem_08_src;
    321            CPU_DATA         i;
    322            CPU_DATA         mem_align_mod_dest;
    323            CPU_DATA         mem_align_mod_src;
    324            CPU_BOOLEAN      mem_aligned;
    325          
    326            if ((size < 1)                                                // See Note #1.
    327                || (p_dest == DEF_NULL)
    328                || (p_src == DEF_NULL)) {
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD003             BEQ.N    ??Mem_Copy_0
   \        0xA   0x2B00             CMP      R3,#+0
   \        0xC   0xD001             BEQ.N    ??Mem_Copy_0
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD100             BNE.N    ??Mem_Copy_1
    329              return;
   \                     ??Mem_Copy_0: (+1)
   \       0x12   0xE046             B.N      ??Mem_Copy_2
    330            }
    331          
    332            size_rem = size;
   \                     ??Mem_Copy_1: (+1)
   \       0x14   0x0010             MOVS     R0,R2
    333          
    334            p_mem_08_dest = (CPU_INT08U *)p_dest;
   \       0x16   0x469C             MOV      R12,R3
    335            p_mem_08_src = (const CPU_INT08U *)p_src;
   \       0x18   0x468E             MOV      LR,R1
    336          
    337            mem_gap_octets = (CPU_SIZE_T)(p_mem_08_src - p_mem_08_dest);
   \       0x1A   0xEBBE 0x080C      SUBS     R8,LR,R12
    338          
    339            if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                    // Avoid bufs overlap.
   \       0x1E   0xF1B8 0x0F04      CMP      R8,#+4
   \       0x22   0xD332             BCC.N    ??Mem_Copy_3
    340                                                                          // See Note #4.
    341              mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)p_mem_08_dest % sizeof(CPU_ALIGN));
   \       0x24   0xF01C 0x0A03      ANDS     R10,R12,#0x3
   \       0x28   0x4654             MOV      R4,R10
    342              mem_align_mod_src = (CPU_INT08U)((CPU_ADDR)p_mem_08_src  % sizeof(CPU_ALIGN));
   \       0x2A   0xF01E 0x0A03      ANDS     R10,LR,#0x3
   \       0x2E   0x4656             MOV      R6,R10
    343          
    344              mem_aligned = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \       0x30   0x42B4             CMP      R4,R6
   \       0x32   0xD101             BNE.N    ??Mem_Copy_4
   \       0x34   0x2701             MOVS     R7,#+1
   \       0x36   0xE000             B.N      ??Mem_Copy_5
   \                     ??Mem_Copy_4: (+1)
   \       0x38   0x2700             MOVS     R7,#+0
    345          
    346              if (mem_aligned == DEF_YES) {
   \                     ??Mem_Copy_5: (+1)
   \       0x3A   0x46BA             MOV      R10,R7
   \       0x3C   0xFA5F 0xFA8A      UXTB     R10,R10
   \       0x40   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x44   0xD121             BNE.N    ??Mem_Copy_3
    347                //                                                           If mem bufs' alignment offset equal, optimize copy for mem buf alignment.
    348                if (mem_align_mod_dest != 0u) {                           // If leading octets avail,                   ...
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD00F             BEQ.N    ??Mem_Copy_6
    349                  i = mem_align_mod_dest;
   \       0x4A   0x0025             MOVS     R5,R4
    350                  while ((size_rem > 0)                                   // ... start mem buf copy with leading octets ...
    351                         && (i < sizeof(CPU_ALIGN))) {                    // ... until next CPU_ALIGN word boundary.
   \                     ??Mem_Copy_7: (+1)
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD00C             BEQ.N    ??Mem_Copy_6
   \       0x50   0x2D04             CMP      R5,#+4
   \       0x52   0xD20A             BCS.N    ??Mem_Copy_6
    352                    *p_mem_08_dest++ = *p_mem_08_src++;
   \       0x54   0xF89E 0xA000      LDRB     R10,[LR, #+0]
   \       0x58   0xF88C 0xA000      STRB     R10,[R12, #+0]
   \       0x5C   0xF11E 0x0E01      ADDS     LR,LR,#+1
   \       0x60   0xF11C 0x0C01      ADDS     R12,R12,#+1
    353                    size_rem -= sizeof(CPU_INT08U);
   \       0x64   0x1E40             SUBS     R0,R0,#+1
    354                    i++;
   \       0x66   0x1C6D             ADDS     R5,R5,#+1
   \       0x68   0xE7F0             B.N      ??Mem_Copy_7
    355                  }
    356                }
    357          
    358                p_mem_align_dest = (CPU_ALIGN *)p_mem_08_dest;            // See Note #3.
   \                     ??Mem_Copy_6: (+1)
   \       0x6A   0x46E3             MOV      R11,R12
    359                p_mem_align_src = (const CPU_ALIGN *)p_mem_08_src;
   \       0x6C   0x46F1             MOV      R9,LR
    360                while (size_rem >= sizeof(CPU_ALIGN)) {                   // While mem bufs aligned on CPU_ALIGN word boundaries,
   \                     ??Mem_Copy_8: (+1)
   \       0x6E   0x2804             CMP      R0,#+4
   \       0x70   0xD309             BCC.N    ??Mem_Copy_9
    361                  *p_mem_align_dest++ = *p_mem_align_src++;               // ... copy psrc to pdest with CPU_ALIGN-sized words.
   \       0x72   0xF8D9 0xA000      LDR      R10,[R9, #+0]
   \       0x76   0xF8CB 0xA000      STR      R10,[R11, #+0]
   \       0x7A   0xF119 0x0904      ADDS     R9,R9,#+4
   \       0x7E   0xF11B 0x0B04      ADDS     R11,R11,#+4
    362                  size_rem -= sizeof(CPU_ALIGN);
   \       0x82   0x1F00             SUBS     R0,R0,#+4
   \       0x84   0xE7F3             B.N      ??Mem_Copy_8
    363                }
    364          
    365                p_mem_08_dest = (CPU_INT08U *)p_mem_align_dest;
   \                     ??Mem_Copy_9: (+1)
   \       0x86   0x46DC             MOV      R12,R11
    366                p_mem_08_src = (const CPU_INT08U *)p_mem_align_src;
   \       0x88   0x46CE             MOV      LR,R9
    367              }
    368            }
    369          
    370            while (size_rem > 0) {                                        // For unaligned mem bufs or trailing octets, ...
   \                     ??Mem_Copy_3: (+1)
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD009             BEQ.N    ??Mem_Copy_10
    371              *p_mem_08_dest++ = *p_mem_08_src++;                         // ... copy psrc to pdest by octets.
   \       0x8E   0xF89E 0xA000      LDRB     R10,[LR, #+0]
   \       0x92   0xF88C 0xA000      STRB     R10,[R12, #+0]
   \       0x96   0xF11E 0x0E01      ADDS     LR,LR,#+1
   \       0x9A   0xF11C 0x0C01      ADDS     R12,R12,#+1
    372              size_rem -= sizeof(CPU_INT08U);
   \       0x9E   0x1E40             SUBS     R0,R0,#+1
   \       0xA0   0xE7F3             B.N      ??Mem_Copy_3
    373            }
    374          }
   \                     ??Mem_Copy_10: (+1)
   \                     ??Mem_Copy_2: (+1)
   \       0xA2   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    375          #endif
    376          
    377          /****************************************************************************************************//**
    378           *                                               Mem_Move()
    379           *
    380           * @brief    Moves data octets from one memory buffer to another memory buffer, or within the same
    381           *           memory buffer. Overlapping is correctly handled for all move operations.
    382           *
    383           * @param    p_dest  Pointer to destination memory buffer.
    384           *
    385           * @param    p_src   Pointer to source memory buffer.
    386           *
    387           * @param    size    Number of octets to move (see Note #1).
    388           *
    389           * @note     (1) Null move operations are allowed (i.e. zero-length).
    390           *
    391           * @note     (2) Memory buffers checked for overlapping.
    392           *
    393           * @note     (3) For best CPU performance, this function copies data buffer using 'CPU_ALIGN'-sized
    394           *               data words. Since many word-aligned processors REQUIRE that multi-octet words be
    395           *               accessed on word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on
    396           *               'CPU_ALIGN'd addresses.
    397           *
    398           * @note     (4) Modulo arithmetic determines if a memory buffer starts on a 'CPU_ALIGN' address
    399           *               boundary.
    400           *               @n
    401           *               Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values, so
    402           *               address values MUST be cast to an appropriately-sized integer value before any
    403           *               'mem_align_mod' arithmetic operation.
    404           *******************************************************************************************************/
    405          
    406          #if (LIB_MEM_CFG_STD_C_LIB_EN == DEF_DISABLED)

   \                                 In section .text, align 2
    407          __WEAK void Mem_Move(void       *p_dest,
    408                               const void *p_src,
    409                               CPU_SIZE_T size)
    410          {
   \                     Mem_Move: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    411            CPU_SIZE_T       size_rem;
    412            CPU_SIZE_T       mem_gap_octets;
    413            CPU_ALIGN        *p_mem_align_dest;
    414            const CPU_ALIGN  *p_mem_align_src;
    415            CPU_INT08U       *p_mem_08_dest;
    416            const CPU_INT08U *p_mem_08_src;
    417            CPU_INT08S       i;
    418            CPU_DATA         mem_align_mod_dest;
    419            CPU_DATA         mem_align_mod_src;
    420            CPU_BOOLEAN      mem_aligned;
    421          
    422            if ((size < 1)                                                // See Note #1.
    423                || (p_dest == DEF_NULL)
    424                || (p_src == DEF_NULL)) {
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD003             BEQ.N    ??Mem_Move_0
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD001             BEQ.N    ??Mem_Move_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD100             BNE.N    ??Mem_Move_1
    425              return;
   \                     ??Mem_Move_0: (+1)
   \       0x16   0xE057             B.N      ??Mem_Move_2
    426            }
    427          
    428            p_mem_08_src = (const CPU_INT08U *)p_src;
   \                     ??Mem_Move_1: (+1)
   \       0x18   0x9501             STR      R5,[SP, #+4]
    429            p_mem_08_dest = (CPU_INT08U *)p_dest;
   \       0x1A   0x9402             STR      R4,[SP, #+8]
    430            if (p_mem_08_src > p_mem_08_dest) {
   \       0x1C   0x9902             LDR      R1,[SP, #+8]
   \       0x1E   0x9801             LDR      R0,[SP, #+4]
   \       0x20   0x4281             CMP      R1,R0
   \       0x22   0xD205             BCS.N    ??Mem_Move_3
    431              Mem_Copy(p_dest, p_src, size);
   \       0x24   0x0032             MOVS     R2,R6
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       Mem_Copy
    432              return;
   \       0x2E   0xE04B             B.N      ??Mem_Move_2
    433            }
    434          
    435            size_rem = size;
   \                     ??Mem_Move_3: (+1)
   \       0x30   0x0030             MOVS     R0,R6
    436          
    437            p_mem_08_dest = (CPU_INT08U *)p_dest + size - 1;
   \       0x32   0xEB04 0x0106      ADD      R1,R4,R6
   \       0x36   0x1E49             SUBS     R1,R1,#+1
    438            p_mem_08_src = (const CPU_INT08U *)p_src  + size - 1;
   \       0x38   0xEB05 0x0206      ADD      R2,R5,R6
   \       0x3C   0x1E52             SUBS     R2,R2,#+1
    439          
    440            mem_gap_octets = (CPU_SIZE_T)(p_mem_08_dest - p_mem_08_src);
   \       0x3E   0xEBB1 0x0E02      SUBS     LR,R1,R2
    441          
    442            if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                    // Avoid bufs overlap.
   \       0x42   0xF1BE 0x0F04      CMP      LR,#+4
   \       0x46   0xD337             BCC.N    ??Mem_Move_4
    443                                                                          // See Note #4.
    444              mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)p_mem_08_dest % sizeof(CPU_ALIGN));
   \       0x48   0xF011 0x0303      ANDS     R3,R1,#0x3
   \       0x4C   0x4699             MOV      R9,R3
    445              mem_align_mod_src = (CPU_INT08U)((CPU_ADDR)p_mem_08_src  % sizeof(CPU_ALIGN));
   \       0x4E   0xF012 0x0303      ANDS     R3,R2,#0x3
   \       0x52   0x9300             STR      R3,[SP, #+0]
    446          
    447              mem_aligned = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \       0x54   0x9B00             LDR      R3,[SP, #+0]
   \       0x56   0x4599             CMP      R9,R3
   \       0x58   0xD102             BNE.N    ??Mem_Move_5
   \       0x5A   0xF05F 0x0A01      MOVS     R10,#+1
   \       0x5E   0xE001             B.N      ??Mem_Move_6
   \                     ??Mem_Move_5: (+1)
   \       0x60   0xF05F 0x0A00      MOVS     R10,#+0
    448          
    449              if (mem_aligned == DEF_YES) {
   \                     ??Mem_Move_6: (+1)
   \       0x64   0x4653             MOV      R3,R10
   \       0x66   0xB2DB             UXTB     R3,R3
   \       0x68   0x2B01             CMP      R3,#+1
   \       0x6A   0xD125             BNE.N    ??Mem_Move_4
    450                //                                                           If mem bufs' alignment offset equal, optimize copy for mem buf alignment.
    451                if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {      // If leading octets avail,                   ...
   \       0x6C   0xF1B9 0x0F03      CMP      R9,#+3
   \       0x70   0xD00F             BEQ.N    ??Mem_Move_7
    452                  i = (CPU_INT08S)mem_align_mod_dest;
   \       0x72   0x464B             MOV      R3,R9
   \       0x74   0x4698             MOV      R8,R3
    453                  while ((size_rem > 0)                                   // ... start mem buf copy with leading octets ...
    454                         && (i >= 0)) {                                   // ... until next CPU_ALIGN word boundary.
   \                     ??Mem_Move_8: (+1)
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD00B             BEQ.N    ??Mem_Move_7
   \       0x7A   0x4643             MOV      R3,R8
   \       0x7C   0xB25B             SXTB     R3,R3
   \       0x7E   0x2B00             CMP      R3,#+0
   \       0x80   0xD407             BMI.N    ??Mem_Move_7
    455                    *p_mem_08_dest-- = *p_mem_08_src--;
   \       0x82   0x7813             LDRB     R3,[R2, #+0]
   \       0x84   0x700B             STRB     R3,[R1, #+0]
   \       0x86   0x1E52             SUBS     R2,R2,#+1
   \       0x88   0x1E49             SUBS     R1,R1,#+1
    456                    size_rem -= sizeof(CPU_INT08U);
   \       0x8A   0x1E40             SUBS     R0,R0,#+1
    457                    i--;
   \       0x8C   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \       0x90   0xE7F1             B.N      ??Mem_Move_8
    458                  }
    459                }
    460          
    461                //                                                           See Note #3.
    462                p_mem_align_dest = (CPU_ALIGN *)(((CPU_INT08U *)p_mem_08_dest - sizeof(CPU_ALIGN)) + 1);
   \                     ??Mem_Move_7: (+1)
   \       0x92   0x1ECB             SUBS     R3,R1,#+3
   \       0x94   0x469B             MOV      R11,R3
    463                p_mem_align_src = (const CPU_ALIGN *)(((CPU_INT08U *)p_mem_08_src  - sizeof(CPU_ALIGN)) + 1);
   \       0x96   0x1ED3             SUBS     R3,R2,#+3
   \       0x98   0x001F             MOVS     R7,R3
    464                while (size_rem >= sizeof(CPU_ALIGN)) {                   // While mem bufs aligned on CPU_ALIGN word boundaries,
   \                     ??Mem_Move_9: (+1)
   \       0x9A   0x2804             CMP      R0,#+4
   \       0x9C   0xD307             BCC.N    ??Mem_Move_10
    465                  *p_mem_align_dest-- = *p_mem_align_src--;               // ... copy psrc to pdest with CPU_ALIGN-sized words.
   \       0x9E   0x683B             LDR      R3,[R7, #+0]
   \       0xA0   0xF8CB 0x3000      STR      R3,[R11, #+0]
   \       0xA4   0x1F3F             SUBS     R7,R7,#+4
   \       0xA6   0xF1BB 0x0B04      SUBS     R11,R11,#+4
    466                  size_rem -= sizeof(CPU_ALIGN);
   \       0xAA   0x1F00             SUBS     R0,R0,#+4
   \       0xAC   0xE7F5             B.N      ??Mem_Move_9
    467                }
    468          
    469                p_mem_08_dest = (CPU_INT08U *)p_mem_align_dest + sizeof(CPU_ALIGN) - 1;
   \                     ??Mem_Move_10: (+1)
   \       0xAE   0xF11B 0x0303      ADDS     R3,R11,#+3
   \       0xB2   0x0019             MOVS     R1,R3
    470                p_mem_08_src = (const CPU_INT08U *)p_mem_align_src  + sizeof(CPU_ALIGN) - 1;
   \       0xB4   0x1CFB             ADDS     R3,R7,#+3
   \       0xB6   0x001A             MOVS     R2,R3
    471              }
    472            }
    473          
    474            while (size_rem > 0) {                                        // For unaligned mem bufs or trailing octets, ...
   \                     ??Mem_Move_4: (+1)
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD005             BEQ.N    ??Mem_Move_11
    475              *p_mem_08_dest-- = *p_mem_08_src--;                         // ... copy psrc to pdest by octets.
   \       0xBC   0x7813             LDRB     R3,[R2, #+0]
   \       0xBE   0x700B             STRB     R3,[R1, #+0]
   \       0xC0   0x1E52             SUBS     R2,R2,#+1
   \       0xC2   0x1E49             SUBS     R1,R1,#+1
    476              size_rem -= sizeof(CPU_INT08U);
   \       0xC4   0x1E40             SUBS     R0,R0,#+1
   \       0xC6   0xE7F7             B.N      ??Mem_Move_4
    477            }
    478          }
   \                     ??Mem_Move_11: (+1)
   \                     ??Mem_Move_2: (+1)
   \       0xC8   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    479          #endif
    480          
    481          /****************************************************************************************************//**
    482           *                                                   Mem_Cmp()
    483           *
    484           * @brief    Verifies that ALL data octets in the two memory buffers are identical in sequence.
    485           *
    486           * @param    p1_mem  Pointer to first memory buffer.
    487           *
    488           * @param    p2_mem  Pointer to second memory buffer.
    489           *
    490           * @param    size    Number of data buffer octets to compare (see Note #1).
    491           *
    492           * @return   DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    493           *           DEF_NO, otherwise.
    494           *
    495           * @note     (1) Null compares are allowed (i.e. zero-length compares); 'DEF_YES' is returned to
    496           *               indicate identical null compare.
    497           *
    498           * @note     (2) Many memory buffer comparisons vary ONLY in the least significant octets (e.g.
    499           *               network address buffers). Consequently, memory buffer comparison is more efficient if
    500           *               the comparison starts from the end of the memory buffers. This aborts sooner on
    501           *               dissimilar memory buffers that vary only in the least significant octets.
    502           *
    503           * @note     (3) For best CPU performance, this function compares data buffers using 'CPU_ALIGN'-sized
    504           *               data words. Since many word-aligned processors REQUIRE that multi-octet words be
    505           *               accessed on word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on
    506           *               'CPU_ALIGN'd addresses.
    507           *
    508           * @note     (4) Modulo arithmetic determines if a memory buffer starts on a 'CPU_ALIGN' address
    509           *               boundary.
    510           *               @n
    511           *               Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values, so
    512           *               address values MUST be cast to an appropriately-sized integer value before any
    513           *               'mem_align_mod' arithmetic operation.
    514           *******************************************************************************************************/
    515          
    516          #if (LIB_MEM_CFG_STD_C_LIB_EN == DEF_DISABLED)

   \                                 In section .text, align 2
    517          __WEAK CPU_BOOLEAN Mem_Cmp(const void *p1_mem,
    518                                     const void *p2_mem,
    519                                     CPU_SIZE_T size)
    520          {
   \                     Mem_Cmp: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0013             MOVS     R3,R2
    521            CPU_SIZE_T       size_rem;
    522            CPU_ALIGN        *p1_mem_align;
    523            CPU_ALIGN        *p2_mem_align;
    524            const CPU_INT08U *p1_mem_08;
    525            const CPU_INT08U *p2_mem_08;
    526            CPU_DATA         i;
    527            CPU_DATA         mem_align_mod_1;
    528            CPU_DATA         mem_align_mod_2;
    529            CPU_BOOLEAN      mem_aligned;
    530            CPU_BOOLEAN      mem_cmp;
    531          
    532            if ((size < 1)                                                // See Note #1.
    533                || (p1_mem == DEF_NULL)
    534                || (p2_mem == DEF_NULL)) {
   \        0xA   0x2B00             CMP      R3,#+0
   \        0xC   0xD003             BEQ.N    ??Mem_Cmp_0
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD001             BEQ.N    ??Mem_Cmp_0
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD101             BNE.N    ??Mem_Cmp_1
    535              return (DEF_NO);
   \                     ??Mem_Cmp_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE06F             B.N      ??Mem_Cmp_2
    536            }
    537          
    538            mem_cmp = DEF_YES;                                            // Assume mem bufs are identical until cmp fails.
   \                     ??Mem_Cmp_1: (+1)
   \       0x1A   0x2001             MOVS     R0,#+1
    539            size_rem = size;
   \       0x1C   0x0019             MOVS     R1,R3
    540            //                                                               Start @ end of mem bufs (see Note #2).
    541            p1_mem_08 = (const CPU_INT08U *)p1_mem + size;
   \       0x1E   0xEB05 0x0803      ADD      R8,R5,R3
    542            p2_mem_08 = (const CPU_INT08U *)p2_mem + size;
   \       0x22   0xEB04 0x0903      ADD      R9,R4,R3
    543            //                                                               See Note #4.
    544            mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
   \       0x26   0xF018 0x0603      ANDS     R6,R8,#0x3
    545            mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
   \       0x2A   0xF019 0x0A03      ANDS     R10,R9,#0x3
   \       0x2E   0xF8CD 0xA000      STR      R10,[SP, #+0]
    546          
    547            mem_aligned = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
   \       0x32   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0x36   0x4566             CMP      R6,R12
   \       0x38   0xD102             BNE.N    ??Mem_Cmp_3
   \       0x3A   0xF05F 0x0C01      MOVS     R12,#+1
   \       0x3E   0xE001             B.N      ??Mem_Cmp_4
   \                     ??Mem_Cmp_3: (+1)
   \       0x40   0xF05F 0x0C00      MOVS     R12,#+0
    548          
    549            if (mem_aligned == DEF_YES) {
   \                     ??Mem_Cmp_4: (+1)
   \       0x44   0x46E2             MOV      R10,R12
   \       0x46   0xFA5F 0xFA8A      UXTB     R10,R10
   \       0x4A   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x4E   0xD13C             BNE.N    ??Mem_Cmp_5
    550              //                                                             If mem bufs' alignment offset equal, optimize cmp for mem buf alignment.
    551              if (mem_align_mod_1 != 0u) {                                // If trailing octets avail,                  ...
   \       0x50   0x2E00             CMP      R6,#+0
   \       0x52   0xD01A             BEQ.N    ??Mem_Cmp_6
    552                i = mem_align_mod_1;
   \       0x54   0x0032             MOVS     R2,R6
    553                while ((mem_cmp == DEF_YES)                               // ... cmp mem bufs while identical &         ...
    554                       && (size_rem > 0)                                  // ... start mem buf cmp with trailing octets ...
    555                       && (i > 0)) {                                      // ... until next CPU_ALIGN word boundary.
   \                     ??Mem_Cmp_7: (+1)
   \       0x56   0x4682             MOV      R10,R0
   \       0x58   0xFA5F 0xFA8A      UXTB     R10,R10
   \       0x5C   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x60   0xD113             BNE.N    ??Mem_Cmp_6
   \       0x62   0x2900             CMP      R1,#+0
   \       0x64   0xD011             BEQ.N    ??Mem_Cmp_6
   \       0x66   0x2A00             CMP      R2,#+0
   \       0x68   0xD00F             BEQ.N    ??Mem_Cmp_6
    556                  p1_mem_08--;
   \       0x6A   0xF1B8 0x0801      SUBS     R8,R8,#+1
    557                  p2_mem_08--;
   \       0x6E   0xF1B9 0x0901      SUBS     R9,R9,#+1
    558                  if (*p1_mem_08 != *p2_mem_08) {                         // If ANY data octet(s) NOT identical, cmp fails.
   \       0x72   0xF898 0xB000      LDRB     R11,[R8, #+0]
   \       0x76   0xF899 0xA000      LDRB     R10,[R9, #+0]
   \       0x7A   0x45D3             CMP      R11,R10
   \       0x7C   0xD002             BEQ.N    ??Mem_Cmp_8
    559                    mem_cmp = DEF_NO;
   \       0x7E   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x82   0x4650             MOV      R0,R10
    560                  }
    561                  size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_8: (+1)
   \       0x84   0x1E49             SUBS     R1,R1,#+1
    562                  i--;
   \       0x86   0x1E52             SUBS     R2,R2,#+1
   \       0x88   0xE7E5             B.N      ??Mem_Cmp_7
    563                }
    564              }
    565          
    566              if (mem_cmp == DEF_YES) {                                   // If cmp still identical, cmp aligned mem bufs.
   \                     ??Mem_Cmp_6: (+1)
   \       0x8A   0x4682             MOV      R10,R0
   \       0x8C   0xFA5F 0xFA8A      UXTB     R10,R10
   \       0x90   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x94   0xD119             BNE.N    ??Mem_Cmp_5
    567                p1_mem_align = (CPU_ALIGN *)p1_mem_08;                    // See Note #3.
   \       0x96   0x4647             MOV      R7,R8
    568                p2_mem_align = (CPU_ALIGN *)p2_mem_08;
   \       0x98   0x46CE             MOV      LR,R9
    569          
    570                while ((mem_cmp == DEF_YES)                               // Cmp mem bufs while identical & ...
    571                       && (size_rem >= sizeof(CPU_ALIGN))) {              // ... mem bufs aligned on CPU_ALIGN word boundaries.
   \                     ??Mem_Cmp_9: (+1)
   \       0x9A   0x4682             MOV      R10,R0
   \       0x9C   0xFA5F 0xFA8A      UXTB     R10,R10
   \       0xA0   0xF1BA 0x0F01      CMP      R10,#+1
   \       0xA4   0xD10F             BNE.N    ??Mem_Cmp_10
   \       0xA6   0x2904             CMP      R1,#+4
   \       0xA8   0xD30D             BCC.N    ??Mem_Cmp_10
    572                  p1_mem_align--;
   \       0xAA   0x1F3F             SUBS     R7,R7,#+4
    573                  p2_mem_align--;
   \       0xAC   0xF1BE 0x0E04      SUBS     LR,LR,#+4
    574                  if (*p1_mem_align != *p2_mem_align) {                   // If ANY data octet(s) NOT identical, cmp fails.
   \       0xB0   0xF8D7 0xB000      LDR      R11,[R7, #+0]
   \       0xB4   0xF8DE 0xA000      LDR      R10,[LR, #+0]
   \       0xB8   0x45D3             CMP      R11,R10
   \       0xBA   0xD002             BEQ.N    ??Mem_Cmp_11
    575                    mem_cmp = DEF_NO;
   \       0xBC   0xF05F 0x0A00      MOVS     R10,#+0
   \       0xC0   0x4650             MOV      R0,R10
    576                  }
    577                  size_rem -= sizeof(CPU_ALIGN);
   \                     ??Mem_Cmp_11: (+1)
   \       0xC2   0x1F09             SUBS     R1,R1,#+4
   \       0xC4   0xE7E9             B.N      ??Mem_Cmp_9
    578                }
    579          
    580                p1_mem_08 = (CPU_INT08U *)p1_mem_align;
   \                     ??Mem_Cmp_10: (+1)
   \       0xC6   0x46B8             MOV      R8,R7
    581                p2_mem_08 = (CPU_INT08U *)p2_mem_align;
   \       0xC8   0x46F1             MOV      R9,LR
    582              }
    583            }
    584          
    585            while ((mem_cmp == DEF_YES)                                   // Cmp mem bufs while identical ...
    586                   && (size_rem > 0)) {                                   // ... for unaligned mem bufs or trailing octets.
   \                     ??Mem_Cmp_5: (+1)
   \       0xCA   0x4682             MOV      R10,R0
   \       0xCC   0xFA5F 0xFA8A      UXTB     R10,R10
   \       0xD0   0xF1BA 0x0F01      CMP      R10,#+1
   \       0xD4   0xD110             BNE.N    ??Mem_Cmp_12
   \       0xD6   0x2900             CMP      R1,#+0
   \       0xD8   0xD00E             BEQ.N    ??Mem_Cmp_12
    587              p1_mem_08--;
   \       0xDA   0xF1B8 0x0801      SUBS     R8,R8,#+1
    588              p2_mem_08--;
   \       0xDE   0xF1B9 0x0901      SUBS     R9,R9,#+1
    589              if (*p1_mem_08 != *p2_mem_08) {                             // If ANY data octet(s) NOT identical, cmp fails.
   \       0xE2   0xF898 0xB000      LDRB     R11,[R8, #+0]
   \       0xE6   0xF899 0xA000      LDRB     R10,[R9, #+0]
   \       0xEA   0x45D3             CMP      R11,R10
   \       0xEC   0xD002             BEQ.N    ??Mem_Cmp_13
    590                mem_cmp = DEF_NO;
   \       0xEE   0xF05F 0x0A00      MOVS     R10,#+0
   \       0xF2   0x4650             MOV      R0,R10
    591              }
    592              size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_13: (+1)
   \       0xF4   0x1E49             SUBS     R1,R1,#+1
   \       0xF6   0xE7E8             B.N      ??Mem_Cmp_5
    593            }
    594          
    595            return (mem_cmp);
   \                     ??Mem_Cmp_12: (+1)
   \       0xF8   0xB2C0             UXTB     R0,R0
   \                     ??Mem_Cmp_2: (+1)
   \       0xFA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    596          }
    597          #endif
    598          
    599          /****************************************************************************************************//**
    600           *                                               Mem_SegCreate()
    601           *
    602           * @brief    Creates a new memory segment to be used for runtime memory allocation.
    603           *
    604           * @param    p_name          Pointer to segment name.
    605           *
    606           * @param    p_seg           Pointer to segment data. Must be allocated by caller.
    607           *
    608           * @param    seg_base_addr   Address of segment's first byte.
    609           *
    610           * @param    size            Total size of segment (in bytes).
    611           *
    612           * @param    padding_align   Padding alignment (in bytes) that will be added to any allocated buffer
    613           *                           from this memory segment. MUST be a power of 2.
    614           *                               - LIB_MEM_PADDING_ALIGN_NONE means no padding.
    615           *                               - LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
    616           *
    617           * @param    p_err           Pointer to the variable that will receive one of the following error
    618           *                           code(s) from this function:
    619           *                               - RTOS_ERR_NONE
    620           *                               - RTOS_ERR_INVALID_ARG
    621           *
    622           * @note     (1) New segments are checked for overlap with existing segments. A critical section must
    623           *               be maintained during the whole list search and adds a procedure to prevent a
    624           *               re-entrant call from creating another segment that would overlaps with the new one.
    625           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    626          void Mem_SegCreate(const CPU_CHAR *p_name,
    627                             MEM_SEG        *p_seg,
    628                             CPU_ADDR       seg_base_addr,
    629                             CPU_SIZE_T     size,
    630                             CPU_SIZE_T     padding_align,
    631                             RTOS_ERR       *p_err)
    632          {
   \                     Mem_SegCreate: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9C0A             LDR      R4,[SP, #+40]
   \        0xE   0x9F0B             LDR      R7,[SP, #+44]
    633            CORE_DECLARE_IRQ_STATE;
    634          
    635            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \       0x10   0x2F00             CMP      R7,#+0
   \       0x12   0xD101             BNE.N    ??Mem_SegCreate_0
   \       0x14   0x.... 0x....      BL       CPU_SW_Exception
    636          
    637            //                                                               Chk for null seg ptr.
    638            RTOS_ASSERT_DBG_ERR_SET((p_seg != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??Mem_SegCreate_0: (+1)
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD10B             BNE.N    ??Mem_SegCreate_1
   \       0x1C   0x200A             MOVS     R0,#+10
   \       0x1E   0x7038             STRB     R0,[R7, #+0]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x24   0x6078             STR      R0,[R7, #+4]
   \       0x26   0xF240 0x207E      MOVW     R0,#+638
   \       0x2A   0x60B8             STR      R0,[R7, #+8]
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \       0x30   0x60F8             STR      R0,[R7, #+12]
   \                     ??Mem_SegCreate_2: (+1)
   \       0x32   0xE7FE             B.N      ??Mem_SegCreate_2
    639          
    640            //                                                               Chk for invalid sized seg.
    641            RTOS_ASSERT_DBG_ERR_SET((size >= 1u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??Mem_SegCreate_1: (+1)
   \       0x34   0x2E00             CMP      R6,#+0
   \       0x36   0xD10B             BNE.N    ??Mem_SegCreate_3
   \       0x38   0x2008             MOVS     R0,#+8
   \       0x3A   0x7038             STRB     R0,[R7, #+0]
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x40   0x6078             STR      R0,[R7, #+4]
   \       0x42   0xF240 0x2081      MOVW     R0,#+641
   \       0x46   0x60B8             STR      R0,[R7, #+8]
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \       0x4C   0x60F8             STR      R0,[R7, #+12]
   \                     ??Mem_SegCreate_4: (+1)
   \       0x4E   0xE7FE             B.N      ??Mem_SegCreate_4
    642            //                                                               Chk for addr space ovf.
    643            RTOS_ASSERT_DBG_ERR_SET((seg_base_addr + (size - 1u) >= seg_base_addr), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??Mem_SegCreate_3: (+1)
   \       0x50   0xEB16 0x0008      ADDS     R0,R6,R8
   \       0x54   0x1E40             SUBS     R0,R0,#+1
   \       0x56   0x4540             CMP      R0,R8
   \       0x58   0xD20B             BCS.N    ??Mem_SegCreate_5
   \       0x5A   0x2008             MOVS     R0,#+8
   \       0x5C   0x7038             STRB     R0,[R7, #+0]
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x62   0x6078             STR      R0,[R7, #+4]
   \       0x64   0xF240 0x2083      MOVW     R0,#+643
   \       0x68   0x60B8             STR      R0,[R7, #+8]
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \       0x6E   0x60F8             STR      R0,[R7, #+12]
   \                     ??Mem_SegCreate_6: (+1)
   \       0x70   0xE7FE             B.N      ??Mem_SegCreate_6
    644          
    645            RTOS_ASSERT_DBG_ERR_SET(((padding_align == LIB_MEM_PADDING_ALIGN_NONE)
    646                                     || (padding_align == LIB_MEM_BUF_ALIGN_AUTO)
    647                                     || (MATH_IS_PWR2(padding_align) == DEF_YES)), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??Mem_SegCreate_5: (+1)
   \       0x72   0x2C01             CMP      R4,#+1
   \       0x74   0xD00B             BEQ.N    ??Mem_SegCreate_7
   \       0x76   0x2C00             CMP      R4,#+0
   \       0x78   0xD009             BEQ.N    ??Mem_SegCreate_7
   \       0x7A   0x2C00             CMP      R4,#+0
   \       0x7C   0xD004             BEQ.N    ??Mem_SegCreate_8
   \       0x7E   0x1E60             SUBS     R0,R4,#+1
   \       0x80   0x4204             TST      R4,R0
   \       0x82   0xD101             BNE.N    ??Mem_SegCreate_8
   \       0x84   0x2001             MOVS     R0,#+1
   \       0x86   0xE000             B.N      ??Mem_SegCreate_9
   \                     ??Mem_SegCreate_8: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegCreate_9: (+1)
   \       0x8A   0x2801             CMP      R0,#+1
   \       0x8C   0xD101             BNE.N    ??Mem_SegCreate_10
   \                     ??Mem_SegCreate_7: (+1)
   \       0x8E   0x2001             MOVS     R0,#+1
   \       0x90   0xE000             B.N      ??Mem_SegCreate_11
   \                     ??Mem_SegCreate_10: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegCreate_11: (+1)
   \       0x94   0xB2C0             UXTB     R0,R0
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD10B             BNE.N    ??Mem_SegCreate_12
   \       0x9A   0x2008             MOVS     R0,#+8
   \       0x9C   0x7038             STRB     R0,[R7, #+0]
   \       0x9E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0xA2   0x6078             STR      R0,[R7, #+4]
   \       0xA4   0xF240 0x2087      MOVW     R0,#+647
   \       0xA8   0x60B8             STR      R0,[R7, #+8]
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \       0xAE   0x60F8             STR      R0,[R7, #+12]
   \                     ??Mem_SegCreate_13: (+1)
   \       0xB0   0xE7FE             B.N      ??Mem_SegCreate_13
    648          
    649            CORE_ENTER_ATOMIC();
   \                     ??Mem_SegCreate_12: (+1)
   \       0xB2   0x.... 0x....      BL       CORE_EnterAtomic
   \       0xB6   0x4681             MOV      R9,R0
    650          #if RTOS_ARG_CHK_EXT_EN
    651            {
    652              MEM_SEG_STATUS status;
    653          
    654              (void)Mem_SegOverlapChkCritical(seg_base_addr,              // Chk for overlap.
    655                                              size,
    656                                              &status);
   \       0xB8   0x466A             MOV      R2,SP
   \       0xBA   0x0031             MOVS     R1,R6
   \       0xBC   0x4640             MOV      R0,R8
   \       0xBE   0x.... 0x....      BL       Mem_SegOverlapChkCritical
    657              if (status != MEM_SEG_STATUS_NONE) {
   \       0xC2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD00E             BEQ.N    ??Mem_SegCreate_14
    658                CORE_EXIT_ATOMIC();
   \       0xCA   0x4648             MOV      R0,R9
   \       0xCC   0x.... 0x....      BL       CORE_ExitAtomic
    659                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_ARG);
   \       0xD0   0x2008             MOVS     R0,#+8
   \       0xD2   0x7038             STRB     R0,[R7, #+0]
   \       0xD4   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0xD8   0x6078             STR      R0,[R7, #+4]
   \       0xDA   0xF240 0x2093      MOVW     R0,#+659
   \       0xDE   0x60B8             STR      R0,[R7, #+8]
   \       0xE0   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \       0xE4   0x60F8             STR      R0,[R7, #+12]
    660                return;
   \       0xE6   0xE014             B.N      ??Mem_SegCreate_15
    661              }
    662            }
    663          #endif
    664          
    665            Mem_SegCreateCritical(p_name,                                 // Create seg.
    666                                  p_seg,
    667                                  seg_base_addr,
    668                                  padding_align,
    669                                  size);
   \                     ??Mem_SegCreate_14: (+1)
   \       0xE8   0x9600             STR      R6,[SP, #+0]
   \       0xEA   0x0023             MOVS     R3,R4
   \       0xEC   0x4642             MOV      R2,R8
   \       0xEE   0x0029             MOVS     R1,R5
   \       0xF0   0x4650             MOV      R0,R10
   \       0xF2   0x.... 0x....      BL       Mem_SegCreateCritical
    670            CORE_EXIT_ATOMIC();
   \       0xF6   0x4648             MOV      R0,R9
   \       0xF8   0x.... 0x....      BL       CORE_ExitAtomic
    671          
    672            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xFC   0x2000             MOVS     R0,#+0
   \       0xFE   0x7038             STRB     R0,[R7, #+0]
   \      0x100   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \      0x104   0x6078             STR      R0,[R7, #+4]
   \      0x106   0xF44F 0x7028      MOV      R0,#+672
   \      0x10A   0x60B8             STR      R0,[R7, #+8]
   \      0x10C   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \      0x110   0x60F8             STR      R0,[R7, #+12]
    673          }
   \                     ??Mem_SegCreate_15: (+1)
   \      0x112   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}
    674          
    675          /****************************************************************************************************//**
    676           *                                               Mem_SegReg()
    677           *
    678           * @brief    Registers a memory segment that was created at compile-time to enable both usage output
    679           *           and overlap checks when creating a new memory segment.
    680           *
    681           * @param    p_seg   Pointer to segment data already created.
    682           *
    683           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
    684           *                   this function:
    685           *                       - RTOS_ERR_NONE
    686           *                       - RTOS_ERR_ALREADY_EXISTS
    687           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    688          void Mem_SegReg(MEM_SEG  *p_seg,
    689                          RTOS_ERR *p_err)
    690          {
   \                     Mem_SegReg: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
    691            MEM_SEG *p_seg_loop;
    692            CORE_DECLARE_IRQ_STATE;
    693          
    694            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x6   0x2E00             CMP      R6,#+0
   \        0x8   0xD101             BNE.N    ??Mem_SegReg_0
   \        0xA   0x.... 0x....      BL       CPU_SW_Exception
    695          
    696            //                                                               Chk for null seg ptr.
    697            RTOS_ASSERT_DBG_ERR_SET((p_seg != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??Mem_SegReg_0: (+1)
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD10B             BNE.N    ??Mem_SegReg_1
   \       0x12   0x200A             MOVS     R0,#+10
   \       0x14   0x7030             STRB     R0,[R6, #+0]
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x1A   0x6070             STR      R0,[R6, #+4]
   \       0x1C   0xF240 0x20B9      MOVW     R0,#+697
   \       0x20   0x60B0             STR      R0,[R6, #+8]
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable18
   \       0x26   0x60F0             STR      R0,[R6, #+12]
   \                     ??Mem_SegReg_2: (+1)
   \       0x28   0xE7FE             B.N      ??Mem_SegReg_2
    698          
    699            CORE_ENTER_ATOMIC();
   \                     ??Mem_SegReg_1: (+1)
   \       0x2A   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x2E   0x0007             MOVS     R7,R0
    700            p_seg_loop = Mem_SegHeadPtr;
   \       0x30   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \       0x34   0x680C             LDR      R4,[R1, #+0]
    701            while (p_seg_loop != DEF_NULL) {
   \                     ??Mem_SegReg_3: (+1)
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD012             BEQ.N    ??Mem_SegReg_4
    702              if (p_seg_loop == p_seg) {                                  // Check if seg already in list.
   \       0x3A   0x42AC             CMP      R4,R5
   \       0x3C   0xD10E             BNE.N    ??Mem_SegReg_5
    703                CORE_EXIT_ATOMIC();
   \       0x3E   0x0038             MOVS     R0,R7
   \       0x40   0x.... 0x....      BL       CORE_ExitAtomic
    704                RTOS_ERR_SET(*p_err, RTOS_ERR_ALREADY_EXISTS);
   \       0x44   0x2015             MOVS     R0,#+21
   \       0x46   0x7030             STRB     R0,[R6, #+0]
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x4C   0x6070             STR      R0,[R6, #+4]
   \       0x4E   0xF44F 0x7030      MOV      R0,#+704
   \       0x52   0x60B0             STR      R0,[R6, #+8]
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable18
   \       0x58   0x60F0             STR      R0,[R6, #+12]
    705                return;
   \       0x5A   0xE012             B.N      ??Mem_SegReg_6
    706              }
    707          
    708              p_seg_loop = p_seg_loop->NextPtr;
   \                     ??Mem_SegReg_5: (+1)
   \       0x5C   0x68E4             LDR      R4,[R4, #+12]
   \       0x5E   0xE7EA             B.N      ??Mem_SegReg_3
    709            }
    710          
    711            p_seg->NextPtr = Mem_SegHeadPtr;                              // Add segment at head of list.
   \                     ??Mem_SegReg_4: (+1)
   \       0x60   0x6808             LDR      R0,[R1, #+0]
   \       0x62   0x60E8             STR      R0,[R5, #+12]
    712            Mem_SegHeadPtr = p_seg;
   \       0x64   0x600D             STR      R5,[R1, #+0]
    713            CORE_EXIT_ATOMIC();
   \       0x66   0x0038             MOVS     R0,R7
   \       0x68   0x.... 0x....      BL       CORE_ExitAtomic
    714          
    715            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x7030             STRB     R0,[R6, #+0]
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x74   0x6070             STR      R0,[R6, #+4]
   \       0x76   0xF240 0x20CB      MOVW     R0,#+715
   \       0x7A   0x60B0             STR      R0,[R6, #+8]
   \       0x7C   0x.... 0x....      LDR.W    R0,??DataTable18
   \       0x80   0x60F0             STR      R0,[R6, #+12]
    716          }
   \                     ??Mem_SegReg_6: (+1)
   \       0x82   0xBDF1             POP      {R0,R4-R7,PC}
    717          
    718          /****************************************************************************************************//**
    719           *                                               Mem_SegClr()
    720           *
    721           * @brief    Clears a memory segment.
    722           *
    723           * @param    p_seg   Pointer to segment data. Must be allocated by caller.
    724           *
    725           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
    726           *                   this function:
    727           *                       - RTOS_ERR_NONE
    728           *
    729           * @note     (1) Use this function with extreme caution. It must only be called on memory segments
    730           *               that are no longer used.
    731           *
    732           * @note     (2) This function is disabled when debug mode is enabled to avoid heap memory leaks.
    733           *******************************************************************************************************/
    734          
    735          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_DISABLED)

   \                                 In section .text, align 2, keep-with-next
    736          void Mem_SegClr(MEM_SEG  *p_seg,
    737                          RTOS_ERR *p_err)
    738          {
   \                     Mem_SegClr: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    739            CORE_DECLARE_IRQ_STATE;
    740          
    741            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD101             BNE.N    ??Mem_SegClr_0
   \        0xA   0x.... 0x....      BL       CPU_SW_Exception
    742          
    743            //                                                               Chk for null seg ptr.
    744            RTOS_ASSERT_DBG_ERR_SET((p_seg != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??Mem_SegClr_0: (+1)
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD10B             BNE.N    ??Mem_SegClr_1
   \       0x12   0x200A             MOVS     R0,#+10
   \       0x14   0x7028             STRB     R0,[R5, #+0]
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x1A   0x6068             STR      R0,[R5, #+4]
   \       0x1C   0xF44F 0x703A      MOV      R0,#+744
   \       0x20   0x60A8             STR      R0,[R5, #+8]
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \       0x26   0x60E8             STR      R0,[R5, #+12]
   \                     ??Mem_SegClr_2: (+1)
   \       0x28   0xE7FE             B.N      ??Mem_SegClr_2
    745          
    746            CORE_ENTER_ATOMIC();
   \                     ??Mem_SegClr_1: (+1)
   \       0x2A   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x2E   0x0006             MOVS     R6,R0
    747            p_seg->AddrNext = p_seg->AddrBase;
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x60A0             STR      R0,[R4, #+8]
    748            CORE_EXIT_ATOMIC();
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0x.... 0x....      BL       CORE_ExitAtomic
    749          
    750            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x7028             STRB     R0,[R5, #+0]
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x42   0x6068             STR      R0,[R5, #+4]
   \       0x44   0xF240 0x20EE      MOVW     R0,#+750
   \       0x48   0x60A8             STR      R0,[R5, #+8]
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \       0x4E   0x60E8             STR      R0,[R5, #+12]
    751          }
   \       0x50   0xBD70             POP      {R4-R6,PC}
    752          #endif
    753          
    754          /****************************************************************************************************//**
    755           *                                           Mem_SegRemSizeGet()
    756           *
    757           * @brief    Calculates the remaining free space in the memory segment.
    758           *
    759           * @param    p_seg       Pointer to segment data.
    760           *
    761           * @param    align       Alignment in bytes to assume for calculation of free space.
    762           *                       LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
    763           *
    764           * @param    p_seg_info  Pointer to structure that will receive further segment info data (used size,
    765           *                       total size, base address, and next allocation address).
    766           *
    767           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
    768           *                       from this function:
    769           *                           - RTOS_ERR_NONE
    770           *
    771           * @return   The amount of free space in the memory segment (bytes), if successful.
    772           *           0, otherwise or if the memory segment empty.
    773           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    774          CPU_SIZE_T Mem_SegRemSizeGet(MEM_SEG      *p_seg,
    775                                       CPU_SIZE_T   align,
    776                                       MEM_SEG_INFO *p_seg_info,
    777                                       RTOS_ERR     *p_err)
    778          {
   \                     Mem_SegRemSizeGet: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
    779            CPU_SIZE_T rem_size;
    780            CPU_SIZE_T total_size;
    781            CPU_SIZE_T used_size;
    782            CPU_SIZE_T next_buf_align;
    783            CPU_ADDR   next_addr_align;
    784            MEM_SEG    *p_seg_valid = p_seg;
   \        0xC   0x465F             MOV      R7,R11
    785            CORE_DECLARE_IRQ_STATE;
    786          
    787            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0);
   \        0xE   0x2E00             CMP      R6,#+0
   \       0x10   0xD101             BNE.N    ??Mem_SegRemSizeGet_0
   \       0x12   0x.... 0x....      BL       CPU_SW_Exception
    788          
    789            //                                                               Chk for invalid align val.
    790            RTOS_ASSERT_DBG_ERR_SET((MATH_IS_PWR2(align) == DEF_YES)
    791                                    || (align == LIB_MEM_BUF_ALIGN_AUTO), *p_err, RTOS_ERR_INVALID_ARG, 0);
   \                     ??Mem_SegRemSizeGet_0: (+1)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD004             BEQ.N    ??Mem_SegRemSizeGet_1
   \       0x1A   0x1E60             SUBS     R0,R4,#+1
   \       0x1C   0x4204             TST      R4,R0
   \       0x1E   0xD101             BNE.N    ??Mem_SegRemSizeGet_1
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE000             B.N      ??Mem_SegRemSizeGet_2
   \                     ??Mem_SegRemSizeGet_1: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegRemSizeGet_2: (+1)
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD001             BEQ.N    ??Mem_SegRemSizeGet_3
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD101             BNE.N    ??Mem_SegRemSizeGet_4
   \                     ??Mem_SegRemSizeGet_3: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xE000             B.N      ??Mem_SegRemSizeGet_5
   \                     ??Mem_SegRemSizeGet_4: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegRemSizeGet_5: (+1)
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD10B             BNE.N    ??Mem_SegRemSizeGet_6
   \       0x3A   0x2008             MOVS     R0,#+8
   \       0x3C   0x7030             STRB     R0,[R6, #+0]
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x42   0x6070             STR      R0,[R6, #+4]
   \       0x44   0xF240 0x3017      MOVW     R0,#+791
   \       0x48   0x60B0             STR      R0,[R6, #+8]
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \       0x4E   0x60F0             STR      R0,[R6, #+12]
   \                     ??Mem_SegRemSizeGet_7: (+1)
   \       0x50   0xE7FE             B.N      ??Mem_SegRemSizeGet_7
    792          
    793          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    794            if (p_seg_valid == DEF_NULL) {                                // Dflt to heap in case p_seg is null.
   \                     ??Mem_SegRemSizeGet_6: (+1)
   \       0x52   0x2F00             CMP      R7,#+0
   \       0x54   0xD102             BNE.N    ??Mem_SegRemSizeGet_8
    795              p_seg_valid = &Mem_SegHeap;
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0x5A   0x0007             MOVS     R7,R0
    796            }
    797          #else
    798            RTOS_ASSERT_DBG_ERR_SET((p_seg_valid != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0);
    799          #endif
    800          
    801            next_buf_align = (align == LIB_MEM_BUF_ALIGN_AUTO) ? CPU_MIN_DATA_ALIGN_BYTES() : align;
   \                     ??Mem_SegRemSizeGet_8: (+1)
   \       0x5C   0x2C00             CMP      R4,#+0
   \       0x5E   0xD102             BNE.N    ??Mem_SegRemSizeGet_9
   \       0x60   0xF05F 0x0804      MOVS     R8,#+4
   \       0x64   0xE000             B.N      ??Mem_SegRemSizeGet_10
   \                     ??Mem_SegRemSizeGet_9: (+1)
   \       0x66   0x46A0             MOV      R8,R4
    802          
    803            CORE_ENTER_ATOMIC();                                          // Calc seg stats.
   \                     ??Mem_SegRemSizeGet_10: (+1)
   \       0x68   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x6C   0x4681             MOV      R9,R0
    804            next_addr_align = MATH_ROUND_INC_UP_PWR2((CPU_ADDR)p_seg_valid->AddrNext, next_buf_align);
   \       0x6E   0x68B9             LDR      R1,[R7, #+8]
   \       0x70   0xF1B8 0x0001      SUBS     R0,R8,#+1
   \       0x74   0x4201             TST      R1,R0
   \       0x76   0xD102             BNE.N    ??Mem_SegRemSizeGet_11
   \       0x78   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x7C   0xE000             B.N      ??Mem_SegRemSizeGet_12
   \                     ??Mem_SegRemSizeGet_11: (+1)
   \       0x7E   0x46C2             MOV      R10,R8
   \                     ??Mem_SegRemSizeGet_12: (+1)
   \       0x80   0x68B9             LDR      R1,[R7, #+8]
   \       0x82   0xF1B8 0x0001      SUBS     R0,R8,#+1
   \       0x86   0x4381             BICS     R1,R1,R0
   \       0x88   0xEB1A 0x0A01      ADDS     R10,R10,R1
    805            CORE_EXIT_ATOMIC();
   \       0x8C   0x4648             MOV      R0,R9
   \       0x8E   0x.... 0x....      BL       CORE_ExitAtomic
    806          
    807            total_size = ((CPU_ADDR)p_seg_valid->AddrEnd  - (CPU_ADDR)p_seg_valid->AddrBase) + 1u;
   \       0x92   0x6879             LDR      R1,[R7, #+4]
   \       0x94   0x6838             LDR      R0,[R7, #+0]
   \       0x96   0x1A09             SUBS     R1,R1,R0
   \       0x98   0x1C49             ADDS     R1,R1,#+1
    808            used_size = (CPU_ADDR)p_seg_valid->AddrNext - (CPU_ADDR)p_seg_valid->AddrBase;
   \       0x9A   0x68BA             LDR      R2,[R7, #+8]
   \       0x9C   0x6838             LDR      R0,[R7, #+0]
   \       0x9E   0x1A12             SUBS     R2,R2,R0
    809          
    810            if (next_addr_align > (CPU_ADDR)p_seg_valid->AddrEnd) {
   \       0xA0   0x6878             LDR      R0,[R7, #+4]
   \       0xA2   0x4550             CMP      R0,R10
   \       0xA4   0xD203             BCS.N    ??Mem_SegRemSizeGet_13
    811              next_addr_align = 0u;
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x4682             MOV      R10,R0
    812              rem_size = 0u;
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xE003             B.N      ??Mem_SegRemSizeGet_14
    813            } else {
    814              rem_size = total_size - (next_addr_align - (CPU_ADDR)p_seg_valid->AddrBase);
   \                     ??Mem_SegRemSizeGet_13: (+1)
   \       0xAE   0xEBB1 0x030A      SUBS     R3,R1,R10
   \       0xB2   0x6838             LDR      R0,[R7, #+0]
   \       0xB4   0x18C0             ADDS     R0,R0,R3
    815            }
    816          
    817            if (p_seg_info != DEF_NULL) {
   \                     ??Mem_SegRemSizeGet_14: (+1)
   \       0xB6   0x2D00             CMP      R5,#+0
   \       0xB8   0xD005             BEQ.N    ??Mem_SegRemSizeGet_15
    818              p_seg_info->TotalSize = total_size;
   \       0xBA   0x6069             STR      R1,[R5, #+4]
    819              p_seg_info->UsedSize = used_size;
   \       0xBC   0x602A             STR      R2,[R5, #+0]
    820              p_seg_info->AddrBase = (CPU_ADDR)p_seg_valid->AddrBase;
   \       0xBE   0x683B             LDR      R3,[R7, #+0]
   \       0xC0   0x60AB             STR      R3,[R5, #+8]
    821              p_seg_info->AddrNextAlloc = next_addr_align;
   \       0xC2   0xF8C5 0xA00C      STR      R10,[R5, #+12]
    822            }
    823          
    824            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??Mem_SegRemSizeGet_15: (+1)
   \       0xC6   0x2300             MOVS     R3,#+0
   \       0xC8   0x7033             STRB     R3,[R6, #+0]
   \       0xCA   0x.... 0x....      LDR.W    R3,??DataTable17_1
   \       0xCE   0x6073             STR      R3,[R6, #+4]
   \       0xD0   0xF44F 0x734E      MOV      R3,#+824
   \       0xD4   0x60B3             STR      R3,[R6, #+8]
   \       0xD6   0x.... 0x....      LDR.W    R3,??DataTable18_3
   \       0xDA   0x60F3             STR      R3,[R6, #+12]
    825          
    826            return (rem_size);
   \       0xDC   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    827          }
    828          
    829          /****************************************************************************************************//**
    830           *                                               Mem_SegAlloc()
    831           *
    832           * @brief    Allocates memory from a specified segment. The returned memory block will be aligned on a
    833           *           CPU word boundary.
    834           *
    835           * @param    p_name  Pointer to the allocated object name. Used to track allocations. May be DEF_NULL.
    836           *
    837           * @param    p_seg   Pointer to the segment from which to allocate memory. If NULL, it will allocate
    838           *                   from the general-purpose heap.
    839           *
    840           * @param    size    Size of memory block to allocate (in bytes).
    841           *
    842           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
    843           *                   this function:
    844           *                       - RTOS_ERR_NONE
    845           *                       - RTOS_ERR_SEG_OVF
    846           *
    847           * @return   Pointer to allocated memory block, if successful.
    848           *           DEF_NULL, otherwise.
    849           *
    850           * @note     (1) The memory block returned by this function will be aligned on a word boundary.
    851           *               To specify an alignment value, use either Mem_SegAllocExt() or Mem_SegAllocHW().
    852           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    853          void *Mem_SegAlloc(const CPU_CHAR *p_name,
    854                             MEM_SEG        *p_seg,
    855                             CPU_SIZE_T     size,
    856                             RTOS_ERR       *p_err)
    857          {
   \                     Mem_SegAlloc: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001C             MOVS     R4,R3
    858            void    *p_blk;
    859            MEM_SEG *p_seg_valid = p_seg;
   \        0xC   0x003D             MOVS     R5,R7
    860          
    861            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_NULL);
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD101             BNE.N    ??Mem_SegAlloc_0
   \       0x12   0x.... 0x....      BL       CPU_SW_Exception
    862          
    863          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    864            if (p_seg_valid == DEF_NULL) {                                // Dflt to heap in case p_seg is null.
   \                     ??Mem_SegAlloc_0: (+1)
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD102             BNE.N    ??Mem_SegAlloc_1
    865              p_seg_valid = &Mem_SegHeap;
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \       0x1E   0x0005             MOVS     R5,R0
    866            }
    867          #else
    868            RTOS_ASSERT_DBG_ERR_SET((p_seg_valid != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, DEF_NULL);
    869          #endif
    870          
    871            p_blk = Mem_SegAllocInternal(p_name,
    872                                         p_seg_valid,
    873                                         size,
    874                                         sizeof(CPU_ALIGN),
    875                                         LIB_MEM_PADDING_ALIGN_NONE,
    876                                         DEF_NULL,
    877                                         p_err);
   \                     ??Mem_SegAlloc_1: (+1)
   \       0x20   0x9402             STR      R4,[SP, #+8]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9001             STR      R0,[SP, #+4]
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0x2304             MOVS     R3,#+4
   \       0x2C   0x4642             MOV      R2,R8
   \       0x2E   0x0029             MOVS     R1,R5
   \       0x30   0x0030             MOVS     R0,R6
   \       0x32   0x.... 0x....      BL       Mem_SegAllocInternal
    878          
    879            return (p_blk);
   \       0x36   0xB004             ADD      SP,SP,#+16
   \       0x38   0xE8BD 0x81F0      POP      {R4-R8,PC}
    880          }
    881          
    882          /****************************************************************************************************//**
    883           *                                               Mem_SegAllocExt()
    884           *
    885           * @brief    Allocates memory from specified memory segment.
    886           *
    887           * @param    p_name          Pointer to the allocated object name. Used to track allocations. May be
    888           *                           DEF_NULL.
    889           *
    890           * @param    p_seg           Pointer to segment from which to allocate memory. If NULL, it will
    891           *                           allocate from the general-purpose heap.
    892           *
    893           * @param    size            Size of memory block to allocate (in bytes).
    894           *
    895           * @param    align           Required alignment of memory block (in bytes). MUST be a power of 2.
    896           *                           LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
    897           *
    898           * @param    p_bytes_reqd    Pointer to a variable that will receive the number of free bytes missing
    899           *                           for the allocation to succeed. Set to DEF_NULL to skip calculation.
    900           *
    901           * @param    p_err           Pointer to the variable that will receive one of the following error
    902           *                           code(s) from this function:
    903           *                               - RTOS_ERR_NONE
    904           *                               - RTOS_ERR_SEG_OVF
    905           *
    906           * @return   Pointer to allocated memory block, if successful.
    907           *           DEF_NULL, otherwise.
    908           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    909          void *Mem_SegAllocExt(const CPU_CHAR *p_name,
    910                                MEM_SEG        *p_seg,
    911                                CPU_SIZE_T     size,
    912                                CPU_SIZE_T     align,
    913                                CPU_SIZE_T     *p_bytes_reqd,
    914                                RTOS_ERR       *p_err)
    915          {
   \                     Mem_SegAllocExt: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
   \        0xC   0x9C0B             LDR      R4,[SP, #+44]
    916            void    *p_blk;
    917            MEM_SEG *p_seg_valid = p_seg;
   \        0xE   0x003D             MOVS     R5,R7
    918          
    919            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_NULL);
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD101             BNE.N    ??Mem_SegAllocExt_0
   \       0x14   0x.... 0x....      BL       CPU_SW_Exception
    920          
    921          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    922            if (p_seg_valid == DEF_NULL) {                                // Dflt to heap in case p_seg is null.
   \                     ??Mem_SegAllocExt_0: (+1)
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD102             BNE.N    ??Mem_SegAllocExt_1
    923              p_seg_valid = &Mem_SegHeap;
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \       0x20   0x0005             MOVS     R5,R0
    924            }
    925          #else
    926            RTOS_ASSERT_DBG_ERR_SET((p_seg_valid != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, DEF_NULL);
    927          #endif
    928          
    929            p_blk = Mem_SegAllocInternal(p_name,
    930                                         p_seg_valid,
    931                                         size,
    932                                         align,
    933                                         LIB_MEM_PADDING_ALIGN_NONE,
    934                                         p_bytes_reqd,
    935                                         p_err);
   \                     ??Mem_SegAllocExt_1: (+1)
   \       0x22   0x9402             STR      R4,[SP, #+8]
   \       0x24   0x980A             LDR      R0,[SP, #+40]
   \       0x26   0x9001             STR      R0,[SP, #+4]
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x464B             MOV      R3,R9
   \       0x2E   0x4642             MOV      R2,R8
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0x0030             MOVS     R0,R6
   \       0x34   0x.... 0x....      BL       Mem_SegAllocInternal
    936          
    937            return (p_blk);
   \       0x38   0xE8BD 0x83FE      POP      {R1-R9,PC}
    938          }
    939          
    940          /****************************************************************************************************//**
    941           *                                               Mem_SegAllocHW()
    942           *
    943           * @brief    Allocates memory from specified segment. The returned buffer will be padded in function
    944           *           of memory segment's properties.
    945           *
    946           * @param    p_name          Pointer to allocated object name. Used to track allocations. May be
    947           *                           DEF_NULL.
    948           *
    949           * @param    p_seg           Pointer to segment from which to allocate memory. If NULL, it will
    950           *                           allocate from the general-purpose heap.
    951           *
    952           * @param    size            Size of memory block to allocate (in bytes).
    953           *
    954           * @param    align           Required alignment of memory block (in bytes). MUST be a power of 2.
    955           *                           LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
    956           *
    957           * @param    p_bytes_reqd    Pointer to a variable that will receive the number of free bytes missing
    958           *                           for the allocation to succeed. Set to DEF_NULL to skip calculation.
    959           *
    960           * @param    p_err           Pointer to the variable that will receive one of the following error
    961           *                           code(s) from this function:
    962           *                               - RTOS_ERR_NONE
    963           *                               - RTOS_ERR_SEG_OVF
    964           *
    965           * @return   Pointer to allocated memory block, if successful.
    966           *           DEF_NULL, otherwise.
    967           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    968          void *Mem_SegAllocHW(const CPU_CHAR *p_name,
    969                               MEM_SEG        *p_seg,
    970                               CPU_SIZE_T     size,
    971                               CPU_SIZE_T     align,
    972                               CPU_SIZE_T     *p_bytes_reqd,
    973                               RTOS_ERR       *p_err)
    974          {
   \                     Mem_SegAllocHW: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
   \        0xC   0x9C0B             LDR      R4,[SP, #+44]
    975            void    *p_blk;
    976            MEM_SEG *p_seg_valid = p_seg;
   \        0xE   0x003D             MOVS     R5,R7
    977          
    978            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_NULL);
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD101             BNE.N    ??Mem_SegAllocHW_0
   \       0x14   0x.... 0x....      BL       CPU_SW_Exception
    979          
    980          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    981            if (p_seg_valid == DEF_NULL) {                                // Dflt to heap in case p_seg is null.
   \                     ??Mem_SegAllocHW_0: (+1)
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD102             BNE.N    ??Mem_SegAllocHW_1
    982              p_seg_valid = &Mem_SegHeap;
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \       0x20   0x0005             MOVS     R5,R0
    983            }
    984          #else
    985            RTOS_ASSERT_DBG_ERR_SET((p_seg_valid != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, DEF_NULL);
    986          #endif
    987          
    988            p_blk = Mem_SegAllocInternal(p_name,
    989                                         p_seg_valid,
    990                                         size,
    991                                         align,
    992                                         p_seg_valid->PaddingAlign,
    993                                         p_bytes_reqd,
    994                                         p_err);
   \                     ??Mem_SegAllocHW_1: (+1)
   \       0x22   0x9402             STR      R4,[SP, #+8]
   \       0x24   0x980A             LDR      R0,[SP, #+40]
   \       0x26   0x9001             STR      R0,[SP, #+4]
   \       0x28   0x6928             LDR      R0,[R5, #+16]
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x464B             MOV      R3,R9
   \       0x2E   0x4642             MOV      R2,R8
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0x0030             MOVS     R0,R6
   \       0x34   0x.... 0x....      BL       Mem_SegAllocInternal
    995          
    996            return (p_blk);
   \       0x38   0xE8BD 0x83FE      POP      {R1-R9,PC}
    997          }
    998          
    999          /****************************************************************************************************//**
   1000           *                                           Mem_DynPoolCreate()
   1001           *
   1002           * @brief    Creates a dynamic memory pool.
   1003           *
   1004           * @param    p_name          Pointer to the pool name.
   1005           *
   1006           * @param    p_pool          Pointer to the pool data.
   1007           *
   1008           * @param    p_seg           Pointer to segment from which to allocate memory. If NULL, it will be
   1009           *                           allocated from the general-purpose heap.
   1010           *
   1011           * @param    blk_size        Size of memory block to allocate from pool (in bytes). See Note #1.
   1012           *
   1013           * @param    blk_align       Required alignment of memory block (in bytes). MUST be a power of 2.
   1014           *                           LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
   1015           *
   1016           * @param    blk_qty_init    Initial number of elements to be allocated in pool.
   1017           *
   1018           * @param    blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1019           *                           LIB_MEM_BLK_QTY_UNLIMITED if there is no limit.
   1020           *
   1021           * @param    p_err           Pointer to the variable that will receive one of the following error
   1022           *                           code(s) from this function:
   1023           *                               - RTOS_ERR_NONE
   1024           *                               - RTOS_ERR_BLK_ALLOC_CALLBACK
   1025           *                               - RTOS_ERR_SEG_OVF
   1026           *
   1027           * @note     (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1028           *               block is stored in the block itself (only when free/unused).
   1029           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1030          void Mem_DynPoolCreate(const CPU_CHAR *p_name,
   1031                                 MEM_DYN_POOL   *p_pool,
   1032                                 MEM_SEG        *p_seg,
   1033                                 CPU_SIZE_T     blk_size,
   1034                                 CPU_SIZE_T     blk_align,
   1035                                 CPU_SIZE_T     blk_qty_init,
   1036                                 CPU_SIZE_T     blk_qty_max,
   1037                                 RTOS_ERR       *p_err)
   1038          {
   \                     Mem_DynPoolCreate: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x4699             MOV      R9,R3
   \        0xE   0x9D0F             LDR      R5,[SP, #+60]
   1039            MEM_SEG *p_seg_valid = p_seg;
   \       0x10   0x4646             MOV      R6,R8
   1040          
   1041            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??Mem_DynPoolCreate_0
   \       0x16   0x.... 0x....      BL       CPU_SW_Exception
   1042          
   1043            //                                                               Chk for NULL pool data ptr.
   1044            RTOS_ASSERT_DBG_ERR_SET((p_pool != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??Mem_DynPoolCreate_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD10B             BNE.N    ??Mem_DynPoolCreate_1
   \       0x1E   0x200A             MOVS     R0,#+10
   \       0x20   0x7028             STRB     R0,[R5, #+0]
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x26   0x6068             STR      R0,[R5, #+4]
   \       0x28   0xF240 0x4014      MOVW     R0,#+1044
   \       0x2C   0x60A8             STR      R0,[R5, #+8]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \       0x32   0x60E8             STR      R0,[R5, #+12]
   \                     ??Mem_DynPoolCreate_2: (+1)
   \       0x34   0xE7FE             B.N      ??Mem_DynPoolCreate_2
   1045          
   1046          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1047            if (p_seg_valid == DEF_NULL) {                                // Dflt to heap in case p_seg is null.
   \                     ??Mem_DynPoolCreate_1: (+1)
   \       0x36   0x2E00             CMP      R6,#+0
   \       0x38   0xD102             BNE.N    ??Mem_DynPoolCreate_3
   1048              p_seg_valid = &Mem_SegHeap;
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \       0x3E   0x0006             MOVS     R6,R0
   1049            }
   1050          #else
   1051            RTOS_ASSERT_DBG_ERR_SET((p_seg_valid != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   1052          #endif
   1053          
   1054            p_pool->Opt = MEM_DYN_POOL_OPT_NONE;
   \                     ??Mem_DynPoolCreate_3: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7020             STRB     R0,[R4, #+0]
   1055            p_pool->AllocFnct = DEF_NULL;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x61E0             STR      R0,[R4, #+28]
   1056            p_pool->AllocFnctArg = DEF_NULL;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x6220             STR      R0,[R4, #+32]
   1057          
   1058            Mem_DynPoolCreateInternal(p_name,
   1059                                      p_pool,
   1060                                      p_seg_valid,
   1061                                      blk_size,
   1062                                      blk_align,
   1063                                      blk_qty_init,
   1064                                      blk_qty_max,
   1065                                      p_err);
   \       0x4C   0x9503             STR      R5,[SP, #+12]
   \       0x4E   0x980E             LDR      R0,[SP, #+56]
   \       0x50   0x9002             STR      R0,[SP, #+8]
   \       0x52   0x980D             LDR      R0,[SP, #+52]
   \       0x54   0x9001             STR      R0,[SP, #+4]
   \       0x56   0x980C             LDR      R0,[SP, #+48]
   \       0x58   0x9000             STR      R0,[SP, #+0]
   \       0x5A   0x464B             MOV      R3,R9
   \       0x5C   0x0032             MOVS     R2,R6
   \       0x5E   0x0021             MOVS     R1,R4
   \       0x60   0x0038             MOVS     R0,R7
   \       0x62   0x.... 0x....      BL       Mem_DynPoolCreateInternal
   1066          }
   \       0x66   0xB005             ADD      SP,SP,#+20
   \       0x68   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1067          
   1068          /****************************************************************************************************//**
   1069           *                                       Mem_DynPoolCreatePersistent()
   1070           *
   1071           * @brief    Creates a persistent dynamic memory pool.
   1072           *
   1073           * @param    p_name          Pointer to the pool name.
   1074           *
   1075           * @param    p_pool          Pointer to the pool data.
   1076           *
   1077           * @param    p_seg           Pointer to segment from which to allocate memory.
   1078           *
   1079           * @param    blk_size        Size of memory block to allocate from pool (in bytes). See Note #1.
   1080           *
   1081           * @param    blk_align       Required alignment of memory block (in bytes). MUST be a power of 2.
   1082           *                           LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
   1083           *
   1084           * @param    blk_qty_init    Initial number of elements to be allocated in pool.
   1085           *
   1086           * @param    blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1087           *                           LIB_MEM_BLK_QTY_UNLIMITED if there is no limit.
   1088           *
   1089           * @param    alloc_callback  Function that will be called the first time each block is allocated.
   1090           *
   1091           * @param    p_callback_arg  Pointer to argument that will be passed to callback.
   1092           *
   1093           * @param    p_err           Pointer to the variable that will receive one of the following error
   1094           *                           code(s) from this function:
   1095           *                               - RTOS_ERR_NONE
   1096           *                               - RTOS_ERR_BLK_ALLOC_CALLBACK
   1097           *                               - RTOS_ERR_SEG_OVF
   1098           *
   1099           * @note     (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1100           *               block is stored in the block itself (only when free/unused).
   1101           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1102          void Mem_DynPoolCreatePersistent(const CPU_CHAR          *p_name,
   1103                                           MEM_DYN_POOL            *p_pool,
   1104                                           MEM_SEG                 *p_seg,
   1105                                           CPU_SIZE_T              blk_size,
   1106                                           CPU_SIZE_T              blk_align,
   1107                                           CPU_SIZE_T              blk_qty_init,
   1108                                           CPU_SIZE_T              blk_qty_max,
   1109                                           MEM_DYN_POOL_ALLOC_FNCT alloc_callback,
   1110                                           void                    *p_callback_arg,
   1111                                           RTOS_ERR                *p_err)
   1112          {
   \                     Mem_DynPoolCreatePersistent: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0xF8DD 0x9044      LDR      R9,[SP, #+68]
   \       0x12   0xF8DD 0xA048      LDR      R10,[SP, #+72]
   \       0x16   0x9D13             LDR      R5,[SP, #+76]
   1113            MEM_SEG *p_seg_valid = p_seg;
   \       0x18   0x003E             MOVS     R6,R7
   1114          
   1115            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD101             BNE.N    ??Mem_DynPoolCreatePersistent_0
   \       0x1E   0x.... 0x....      BL       CPU_SW_Exception
   1116          
   1117            //                                                               Chk for NULL pool data ptr.
   1118            RTOS_ASSERT_DBG_ERR_SET((p_pool != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??Mem_DynPoolCreatePersistent_0: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD10B             BNE.N    ??Mem_DynPoolCreatePersistent_1
   \       0x26   0x200A             MOVS     R0,#+10
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x2E   0x6068             STR      R0,[R5, #+4]
   \       0x30   0xF240 0x405E      MOVW     R0,#+1118
   \       0x34   0x60A8             STR      R0,[R5, #+8]
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \       0x3A   0x60E8             STR      R0,[R5, #+12]
   \                     ??Mem_DynPoolCreatePersistent_2: (+1)
   \       0x3C   0xE7FE             B.N      ??Mem_DynPoolCreatePersistent_2
   1119          
   1120          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1121            if (p_seg_valid == DEF_NULL) {                                // Dflt to heap in case p_seg is null.
   \                     ??Mem_DynPoolCreatePersistent_1: (+1)
   \       0x3E   0x2E00             CMP      R6,#+0
   \       0x40   0xD102             BNE.N    ??Mem_DynPoolCreatePersistent_3
   1122              p_seg_valid = &Mem_SegHeap;
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \       0x46   0x0006             MOVS     R6,R0
   1123            }
   1124          #else
   1125            RTOS_ASSERT_DBG_ERR_SET((p_seg_valid != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   1126          #endif
   1127          
   1128            p_pool->Opt = MEM_DYN_POOL_OPT_PERSISTENT;
   \                     ??Mem_DynPoolCreatePersistent_3: (+1)
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0x7020             STRB     R0,[R4, #+0]
   1129            p_pool->AllocFnct = alloc_callback;
   \       0x4C   0xF8C4 0x901C      STR      R9,[R4, #+28]
   1130            p_pool->AllocFnctArg = p_callback_arg;
   \       0x50   0xF8C4 0xA020      STR      R10,[R4, #+32]
   1131          
   1132            Mem_DynPoolCreateInternal(p_name,
   1133                                      p_pool,
   1134                                      p_seg_valid,
   1135                                      blk_size,
   1136                                      blk_align,
   1137                                      blk_qty_init,
   1138                                      blk_qty_max,
   1139                                      p_err);
   \       0x54   0x9503             STR      R5,[SP, #+12]
   \       0x56   0x9810             LDR      R0,[SP, #+64]
   \       0x58   0x9002             STR      R0,[SP, #+8]
   \       0x5A   0x980F             LDR      R0,[SP, #+60]
   \       0x5C   0x9001             STR      R0,[SP, #+4]
   \       0x5E   0x980E             LDR      R0,[SP, #+56]
   \       0x60   0x9000             STR      R0,[SP, #+0]
   \       0x62   0x4643             MOV      R3,R8
   \       0x64   0x0032             MOVS     R2,R6
   \       0x66   0x0021             MOVS     R1,R4
   \       0x68   0x4658             MOV      R0,R11
   \       0x6A   0x.... 0x....      BL       Mem_DynPoolCreateInternal
   1140          }
   \       0x6E   0xB005             ADD      SP,SP,#+20
   \       0x70   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1141          
   1142          /****************************************************************************************************//**
   1143           *                                           Mem_DynPoolCreateHW()
   1144           *
   1145           * @brief    Creates a dynamic memory pool. Memory blocks will be padded according to memory segment's
   1146           *           properties.
   1147           *
   1148           * @param    p_name          Pointer to the pool name.
   1149           *
   1150           * @param    p_pool          Pointer to the pool data.
   1151           *
   1152           * @param    p_seg           Pointer to the segment from which to allocate memory. If NULL, it will be
   1153           *                           allocated from the general-purpose heap.
   1154           *
   1155           * @param    blk_size        Size of memory block to allocate from pool (in bytes). See Note #1.
   1156           *
   1157           * @param    blk_align       Required alignment of memory block (in bytes). MUST be a power of 2.
   1158           *                           LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
   1159           *
   1160           * @param    blk_qty_init    Initial number of elements to be allocated in pool.
   1161           *
   1162           * @param    blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1163           *                           LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   1164           *
   1165           * @param    p_err           Pointer to the variable that will receive one of the following error
   1166           *                           code(s) from this function:
   1167           *                               - RTOS_ERR_NONE
   1168           *                               - RTOS_ERR_BLK_ALLOC_CALLBACK
   1169           *                               - RTOS_ERR_SEG_OVF
   1170           *
   1171           * @note     (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1172           *               block is stored in the block itself (only when free/unused).
   1173           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1174          void Mem_DynPoolCreateHW(const CPU_CHAR *p_name,
   1175                                   MEM_DYN_POOL   *p_pool,
   1176                                   MEM_SEG        *p_seg,
   1177                                   CPU_SIZE_T     blk_size,
   1178                                   CPU_SIZE_T     blk_align,
   1179                                   CPU_SIZE_T     blk_qty_init,
   1180                                   CPU_SIZE_T     blk_qty_max,
   1181                                   RTOS_ERR       *p_err)
   1182          {
   \                     Mem_DynPoolCreateHW: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x4699             MOV      R9,R3
   \        0xE   0x9D0F             LDR      R5,[SP, #+60]
   1183            MEM_SEG *p_seg_valid = p_seg;
   \       0x10   0x4646             MOV      R6,R8
   1184          
   1185            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??Mem_DynPoolCreateHW_0
   \       0x16   0x.... 0x....      BL       CPU_SW_Exception
   1186          
   1187            //                                                               Chk for NULL pool data ptr.
   1188            RTOS_ASSERT_DBG_ERR_SET((p_pool != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??Mem_DynPoolCreateHW_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD10B             BNE.N    ??Mem_DynPoolCreateHW_1
   \       0x1E   0x200A             MOVS     R0,#+10
   \       0x20   0x7028             STRB     R0,[R5, #+0]
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x26   0x6068             STR      R0,[R5, #+4]
   \       0x28   0xF240 0x40A4      MOVW     R0,#+1188
   \       0x2C   0x60A8             STR      R0,[R5, #+8]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable18_7
   \       0x32   0x60E8             STR      R0,[R5, #+12]
   \                     ??Mem_DynPoolCreateHW_2: (+1)
   \       0x34   0xE7FE             B.N      ??Mem_DynPoolCreateHW_2
   1189          
   1190          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1191            if (p_seg_valid == DEF_NULL) {                                // Dflt to heap in case p_seg is null.
   \                     ??Mem_DynPoolCreateHW_1: (+1)
   \       0x36   0x2E00             CMP      R6,#+0
   \       0x38   0xD102             BNE.N    ??Mem_DynPoolCreateHW_3
   1192              p_seg_valid = &Mem_SegHeap;
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \       0x3E   0x0006             MOVS     R6,R0
   1193            }
   1194          #else
   1195            RTOS_ASSERT_DBG_ERR_SET((p_seg_valid != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   1196          #endif
   1197          
   1198            p_pool->Opt = MEM_DYN_POOL_OPT_HW;
   \                     ??Mem_DynPoolCreateHW_3: (+1)
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0x7020             STRB     R0,[R4, #+0]
   1199            p_pool->AllocFnct = DEF_NULL;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x61E0             STR      R0,[R4, #+28]
   1200            p_pool->AllocFnctArg = DEF_NULL;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x6220             STR      R0,[R4, #+32]
   1201          
   1202            Mem_DynPoolCreateInternal(p_name,
   1203                                      p_pool,
   1204                                      p_seg_valid,
   1205                                      blk_size,
   1206                                      blk_align,
   1207                                      blk_qty_init,
   1208                                      blk_qty_max,
   1209                                      p_err);
   \       0x4C   0x9503             STR      R5,[SP, #+12]
   \       0x4E   0x980E             LDR      R0,[SP, #+56]
   \       0x50   0x9002             STR      R0,[SP, #+8]
   \       0x52   0x980D             LDR      R0,[SP, #+52]
   \       0x54   0x9001             STR      R0,[SP, #+4]
   \       0x56   0x980C             LDR      R0,[SP, #+48]
   \       0x58   0x9000             STR      R0,[SP, #+0]
   \       0x5A   0x464B             MOV      R3,R9
   \       0x5C   0x0032             MOVS     R2,R6
   \       0x5E   0x0021             MOVS     R1,R4
   \       0x60   0x0038             MOVS     R0,R7
   \       0x62   0x.... 0x....      BL       Mem_DynPoolCreateInternal
   1210          }
   \       0x66   0xB005             ADD      SP,SP,#+20
   \       0x68   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1211          
   1212          /****************************************************************************************************//**
   1213           *                                           Mem_DynPoolBlkGet()
   1214           *
   1215           * @brief    Gets a memory block from specified pool, growing it if needed.
   1216           *
   1217           * @param    p_pool  Pointer to the pool data.
   1218           *
   1219           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
   1220           *                   this function:
   1221           *                       - RTOS_ERR_NONE
   1222           *                       - RTOS_ERR_POOL_EMPTY
   1223           *                       - RTOS_ERR_BLK_ALLOC_CALLBACK
   1224           *                       - RTOS_ERR_SEG_OVF
   1225           *
   1226           * @return   Pointer to memory block, if successful.
   1227           *           DEF_NULL, otherwise.
   1228           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1229          void *Mem_DynPoolBlkGet(MEM_DYN_POOL *p_pool,
   1230                                  RTOS_ERR     *p_err)
   1231          {
   \                     Mem_DynPoolBlkGet: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1232            void           *p_blk;
   1233            const CPU_CHAR *p_pool_name;
   1234            CORE_DECLARE_IRQ_STATE;
   1235          
   1236            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_NULL);
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD101             BNE.N    ??Mem_DynPoolBlkGet_0
   \        0xC   0x.... 0x....      BL       CPU_SW_Exception
   1237          
   1238            //                                                               Chk for NULL pool data ptr.
   1239            RTOS_ASSERT_DBG_ERR_SET((p_pool != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, DEF_NULL);
   \                     ??Mem_DynPoolBlkGet_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD10B             BNE.N    ??Mem_DynPoolBlkGet_1
   \       0x14   0x200A             MOVS     R0,#+10
   \       0x16   0x7028             STRB     R0,[R5, #+0]
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x1C   0x6068             STR      R0,[R5, #+4]
   \       0x1E   0xF240 0x40D7      MOVW     R0,#+1239
   \       0x22   0x60A8             STR      R0,[R5, #+8]
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable18_8
   \       0x28   0x60E8             STR      R0,[R5, #+12]
   \                     ??Mem_DynPoolBlkGet_2: (+1)
   \       0x2A   0xE7FE             B.N      ??Mem_DynPoolBlkGet_2
   1240          
   1241            //                                                               Ensure pool is not empty if qty is limited.
   1242            CORE_ENTER_ATOMIC();
   \                     ??Mem_DynPoolBlkGet_1: (+1)
   \       0x2C   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x30   0x0006             MOVS     R6,R0
   1243            if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
   \       0x32   0x6960             LDR      R0,[R4, #+20]
   \       0x34   0xF110 0x0F01      CMN      R0,#+1
   \       0x38   0xD013             BEQ.N    ??Mem_DynPoolBlkGet_3
   1244              if (p_pool->BlkAllocCnt >= p_pool->BlkQtyMax) {
   \       0x3A   0x69A1             LDR      R1,[R4, #+24]
   \       0x3C   0x6960             LDR      R0,[R4, #+20]
   \       0x3E   0x4281             CMP      R1,R0
   \       0x40   0xD30F             BCC.N    ??Mem_DynPoolBlkGet_3
   1245                CORE_EXIT_ATOMIC();
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0x.... 0x....      BL       CORE_ExitAtomic
   1246          
   1247          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   1248                RTOS_ERR_SET_AND_LOG_DBG(*p_err, RTOS_ERR_POOL_EMPTY, ("Mem_DynPoolBlkGet: pool ", (s)p_pool->NamePtr, " has reached its max."));
   1249          #else
   1250                RTOS_ERR_SET_AND_LOG_DBG(*p_err, RTOS_ERR_POOL_EMPTY, ("Mem_DynPoolBlkGet: pool has reached its max."));
   \       0x48   0x2018             MOVS     R0,#+24
   \       0x4A   0x7028             STRB     R0,[R5, #+0]
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x50   0x6068             STR      R0,[R5, #+4]
   \       0x52   0xF240 0x40E2      MOVW     R0,#+1250
   \       0x56   0x60A8             STR      R0,[R5, #+8]
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable18_8
   \       0x5C   0x60E8             STR      R0,[R5, #+12]
   1251          #endif
   1252                return (DEF_NULL);
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xE071             B.N      ??Mem_DynPoolBlkGet_4
   1253              }
   1254            }
   1255          
   1256            //                                                               --------------- ALLOC FROM FREE LIST ---------------
   1257            p_pool->BlkAllocCnt++;
   \                     ??Mem_DynPoolBlkGet_3: (+1)
   \       0x62   0x69A0             LDR      R0,[R4, #+24]
   \       0x64   0x1C40             ADDS     R0,R0,#+1
   \       0x66   0x61A0             STR      R0,[R4, #+24]
   1258          
   1259            if (p_pool->BlkFreePtr != DEF_NULL) {
   \       0x68   0x6920             LDR      R0,[R4, #+16]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD021             BEQ.N    ??Mem_DynPoolBlkGet_5
   1260              p_blk = p_pool->BlkFreePtr;
   \       0x6E   0x6927             LDR      R7,[R4, #+16]
   1261              p_pool->BlkFreePtr = (DEF_BIT_IS_CLR(p_pool->Opt, MEM_DYN_POOL_OPT_PERSISTENT) == DEF_YES) ? *((void **)p_blk)
   1262                                   : *((void **)((CPU_INT08U *)p_blk + p_pool->BlkSize - sizeof(void *)));
   \       0x70   0x7820             LDRB     R0,[R4, #+0]
   \       0x72   0xB2C0             UXTB     R0,R0
   \       0x74   0x0840             LSRS     R0,R0,#+1
   \       0x76   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x7A   0xF090 0x0001      EORS     R0,R0,#0x1
   \       0x7E   0xB2C0             UXTB     R0,R0
   \       0x80   0x2801             CMP      R0,#+1
   \       0x82   0xD101             BNE.N    ??Mem_DynPoolBlkGet_6
   \       0x84   0x6838             LDR      R0,[R7, #+0]
   \       0x86   0xE003             B.N      ??Mem_DynPoolBlkGet_7
   \                     ??Mem_DynPoolBlkGet_6: (+1)
   \       0x88   0x68A0             LDR      R0,[R4, #+8]
   \       0x8A   0x4438             ADD      R0,R7,R0
   \       0x8C   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \                     ??Mem_DynPoolBlkGet_7: (+1)
   \       0x90   0x6120             STR      R0,[R4, #+16]
   1263              CORE_EXIT_ATOMIC();
   \       0x92   0x0030             MOVS     R0,R6
   \       0x94   0x.... 0x....      BL       CORE_ExitAtomic
   1264          
   1265              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x7028             STRB     R0,[R5, #+0]
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0xA0   0x6068             STR      R0,[R5, #+4]
   \       0xA2   0xF240 0x40F1      MOVW     R0,#+1265
   \       0xA6   0x60A8             STR      R0,[R5, #+8]
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable18_8
   \       0xAC   0x60E8             STR      R0,[R5, #+12]
   1266          
   1267              LOG_VRB(("Mem_DynPoolBlkGet: obtained already allocated block."));
   1268          
   1269              return (p_blk);
   \       0xAE   0x0038             MOVS     R0,R7
   \       0xB0   0xE049             B.N      ??Mem_DynPoolBlkGet_4
   1270            }
   1271          
   1272            CORE_EXIT_ATOMIC();
   \                     ??Mem_DynPoolBlkGet_5: (+1)
   \       0xB2   0x0030             MOVS     R0,R6
   \       0xB4   0x.... 0x....      BL       CORE_ExitAtomic
   1273          
   1274            //                                                               ------------------ ALLOC NEW BLK -------------------
   1275          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   1276            p_pool_name = p_pool->NamePtr;
   1277          #else
   1278            p_pool_name = DEF_NULL;
   \       0xB8   0x2700             MOVS     R7,#+0
   1279          #endif
   1280            p_blk = Mem_SegAllocInternal(p_pool_name,
   1281                                         p_pool->PoolSegPtr,
   1282                                         p_pool->BlkSize,
   1283                                         p_pool->BlkAlign,
   1284                                         (DEF_BIT_IS_CLR(p_pool->Opt, MEM_DYN_POOL_OPT_HW) == DEF_YES) ? LIB_MEM_PADDING_ALIGN_NONE
   1285                                         : p_pool->PoolSegPtr->PaddingAlign,
   1286                                         DEF_NULL,
   1287                                         p_err);
   \       0xBA   0x7820             LDRB     R0,[R4, #+0]
   \       0xBC   0x07C0             LSLS     R0,R0,#+31
   \       0xBE   0xD401             BMI.N    ??Mem_DynPoolBlkGet_8
   \       0xC0   0x2101             MOVS     R1,#+1
   \       0xC2   0xE001             B.N      ??Mem_DynPoolBlkGet_9
   \                     ??Mem_DynPoolBlkGet_8: (+1)
   \       0xC4   0x6860             LDR      R0,[R4, #+4]
   \       0xC6   0x6901             LDR      R1,[R0, #+16]
   \                     ??Mem_DynPoolBlkGet_9: (+1)
   \       0xC8   0x9502             STR      R5,[SP, #+8]
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0x9001             STR      R0,[SP, #+4]
   \       0xCE   0x9100             STR      R1,[SP, #+0]
   \       0xD0   0x68E3             LDR      R3,[R4, #+12]
   \       0xD2   0x68A2             LDR      R2,[R4, #+8]
   \       0xD4   0x6861             LDR      R1,[R4, #+4]
   \       0xD6   0x0038             MOVS     R0,R7
   \       0xD8   0x.... 0x....      BL       Mem_SegAllocInternal
   \       0xDC   0x4680             MOV      R8,R0
   1288            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0xDE   0x7828             LDRB     R0,[R5, #+0]
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD00A             BEQ.N    ??Mem_DynPoolBlkGet_10
   1289              CORE_ENTER_ATOMIC();
   \       0xE4   0x.... 0x....      BL       CORE_EnterAtomic
   \       0xE8   0x4681             MOV      R9,R0
   1290              p_pool->BlkAllocCnt--;
   \       0xEA   0x69A0             LDR      R0,[R4, #+24]
   \       0xEC   0x1E40             SUBS     R0,R0,#+1
   \       0xEE   0x61A0             STR      R0,[R4, #+24]
   1291              CORE_EXIT_ATOMIC();
   \       0xF0   0x4648             MOV      R0,R9
   \       0xF2   0x.... 0x....      BL       CORE_ExitAtomic
   1292              return (DEF_NULL);
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0xE025             B.N      ??Mem_DynPoolBlkGet_4
   1293            }
   1294          
   1295            if (p_pool->AllocFnct != DEF_NULL) {
   \                     ??Mem_DynPoolBlkGet_10: (+1)
   \       0xFA   0x69E0             LDR      R0,[R4, #+28]
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD021             BEQ.N    ??Mem_DynPoolBlkGet_11
   1296              CPU_BOOLEAN alloc_ok;
   1297          
   1298              alloc_ok = p_pool->AllocFnct(p_pool,
   1299                                           p_pool->PoolSegPtr,
   1300                                           p_blk,
   1301                                           p_pool->AllocFnctArg);
   \      0x100   0x6A23             LDR      R3,[R4, #+32]
   \      0x102   0x4642             MOV      R2,R8
   \      0x104   0x6861             LDR      R1,[R4, #+4]
   \      0x106   0x0020             MOVS     R0,R4
   \      0x108   0xF8D4 0xC01C      LDR      R12,[R4, #+28]
   \      0x10C   0x47E0             BLX      R12
   \      0x10E   0x4681             MOV      R9,R0
   1302              if (alloc_ok != DEF_OK) {
   \      0x110   0x4648             MOV      R0,R9
   \      0x112   0xB2C0             UXTB     R0,R0
   \      0x114   0x2801             CMP      R0,#+1
   \      0x116   0xD015             BEQ.N    ??Mem_DynPoolBlkGet_11
   1303                CORE_ENTER_ATOMIC();                                      // The allocated block will be lost.
   \      0x118   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x11C   0x4682             MOV      R10,R0
   1304                p_pool->BlkAllocCnt--;
   \      0x11E   0x69A0             LDR      R0,[R4, #+24]
   \      0x120   0x1E40             SUBS     R0,R0,#+1
   \      0x122   0x61A0             STR      R0,[R4, #+24]
   1305                CORE_EXIT_ATOMIC();
   \      0x124   0x4650             MOV      R0,R10
   \      0x126   0x.... 0x....      BL       CORE_ExitAtomic
   1306          
   1307                RTOS_ERR_SET_AND_LOG_ERR(*p_err, RTOS_ERR_BLK_ALLOC_CALLBACK, ("Mem_DynPoolBlkGet: failed due to callback, block lost."));
   \      0x12A   0x201A             MOVS     R0,#+26
   \      0x12C   0x7028             STRB     R0,[R5, #+0]
   \      0x12E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \      0x132   0x6068             STR      R0,[R5, #+4]
   \      0x134   0xF240 0x501B      MOVW     R0,#+1307
   \      0x138   0x60A8             STR      R0,[R5, #+8]
   \      0x13A   0x.... 0x....      LDR.W    R0,??DataTable18_8
   \      0x13E   0x60E8             STR      R0,[R5, #+12]
   1308                return (DEF_NULL);
   \      0x140   0x2000             MOVS     R0,#+0
   \      0x142   0xE000             B.N      ??Mem_DynPoolBlkGet_4
   1309              }
   1310            }
   1311          
   1312            LOG_VRB(("Mem_DynPoolBlkGet: obtained newly allocated block."));
   1313          
   1314            return (p_blk);
   \                     ??Mem_DynPoolBlkGet_11: (+1)
   \      0x144   0x4640             MOV      R0,R8
   \                     ??Mem_DynPoolBlkGet_4: (+1)
   \      0x146   0xB004             ADD      SP,SP,#+16
   \      0x148   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1315          }
   1316          
   1317          /****************************************************************************************************//**
   1318           *                                           Mem_DynPoolBlkFree()
   1319           *
   1320           * @brief    Frees a memory block, making it available for future use.
   1321           *
   1322           * @param    p_pool  Pointer to the pool data.
   1323           *
   1324           * @param    p_blk   Pointer to first byte of memory block.
   1325           *
   1326           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
   1327           *                   this function:
   1328           *                       - RTOS_ERR_NONE
   1329           *                       - RTOS_ERR_POOL_FULL
   1330           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1331          void Mem_DynPoolBlkFree(MEM_DYN_POOL *p_pool,
   1332                                  void         *p_blk,
   1333                                  RTOS_ERR     *p_err)
   1334          {
   \                     Mem_DynPoolBlkFree: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1335            void *p_blk_next_addr;
   1336            CORE_DECLARE_IRQ_STATE;
   1337          
   1338            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD101             BNE.N    ??Mem_DynPoolBlkFree_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
   1339          
   1340            //                                                               Chk for NULL pool data ptr.
   1341            RTOS_ASSERT_DBG_ERR_SET((p_pool != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??Mem_DynPoolBlkFree_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD10B             BNE.N    ??Mem_DynPoolBlkFree_1
   \       0x16   0x200A             MOVS     R0,#+10
   \       0x18   0x7030             STRB     R0,[R6, #+0]
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x1E   0x6070             STR      R0,[R6, #+4]
   \       0x20   0xF240 0x503D      MOVW     R0,#+1341
   \       0x24   0x60B0             STR      R0,[R6, #+8]
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable18_9
   \       0x2A   0x60F0             STR      R0,[R6, #+12]
   \                     ??Mem_DynPoolBlkFree_2: (+1)
   \       0x2C   0xE7FE             B.N      ??Mem_DynPoolBlkFree_2
   1342            RTOS_ASSERT_DBG_ERR_SET((p_blk != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??Mem_DynPoolBlkFree_1: (+1)
   \       0x2E   0x2D00             CMP      R5,#+0
   \       0x30   0xD10B             BNE.N    ??Mem_DynPoolBlkFree_3
   \       0x32   0x200A             MOVS     R0,#+10
   \       0x34   0x7030             STRB     R0,[R6, #+0]
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x3A   0x6070             STR      R0,[R6, #+4]
   \       0x3C   0xF240 0x503E      MOVW     R0,#+1342
   \       0x40   0x60B0             STR      R0,[R6, #+8]
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable18_9
   \       0x46   0x60F0             STR      R0,[R6, #+12]
   \                     ??Mem_DynPoolBlkFree_4: (+1)
   \       0x48   0xE7FE             B.N      ??Mem_DynPoolBlkFree_4
   1343          
   1344            CORE_ENTER_ATOMIC();                                          // Ensure pool is not full.
   \                     ??Mem_DynPoolBlkFree_3: (+1)
   \       0x4A   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x4E   0x0007             MOVS     R7,R0
   1345            if (p_pool->BlkAllocCnt == 0u) {
   \       0x50   0x69A0             LDR      R0,[R4, #+24]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD10E             BNE.N    ??Mem_DynPoolBlkFree_5
   1346              CORE_EXIT_ATOMIC();
   \       0x56   0x0038             MOVS     R0,R7
   \       0x58   0x.... 0x....      BL       CORE_ExitAtomic
   1347          
   1348          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   1349              RTOS_ERR_SET_AND_LOG_DBG(*p_err, RTOS_ERR_POOL_FULL, ("Mem_DynPoolBlkFree: pool ", (s)p_pool->NamePtr, " is already full."));
   1350          #else
   1351              RTOS_ERR_SET_AND_LOG_DBG(*p_err, RTOS_ERR_POOL_FULL, ("Mem_DynPoolBlkFree: pool is already full."));
   \       0x5C   0x2017             MOVS     R0,#+23
   \       0x5E   0x7030             STRB     R0,[R6, #+0]
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x64   0x6070             STR      R0,[R6, #+4]
   \       0x66   0xF240 0x5047      MOVW     R0,#+1351
   \       0x6A   0x60B0             STR      R0,[R6, #+8]
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable18_9
   \       0x70   0x60F0             STR      R0,[R6, #+12]
   1352          #endif
   1353              return;
   \       0x72   0xE029             B.N      ??Mem_DynPoolBlkFree_6
   1354            }
   1355          
   1356            p_pool->BlkAllocCnt--;
   \                     ??Mem_DynPoolBlkFree_5: (+1)
   \       0x74   0x69A0             LDR      R0,[R4, #+24]
   \       0x76   0x1E40             SUBS     R0,R0,#+1
   \       0x78   0x61A0             STR      R0,[R4, #+24]
   1357            CORE_EXIT_ATOMIC();
   \       0x7A   0x0038             MOVS     R0,R7
   \       0x7C   0x.... 0x....      BL       CORE_ExitAtomic
   1358          
   1359            p_blk_next_addr = (DEF_BIT_IS_CLR(p_pool->Opt, MEM_DYN_POOL_OPT_PERSISTENT) == DEF_YES) ? p_blk
   1360                              : ((CPU_INT08U *)p_blk) + p_pool->BlkSize - sizeof(void *);
   \       0x80   0x7820             LDRB     R0,[R4, #+0]
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0x0840             LSRS     R0,R0,#+1
   \       0x86   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x8A   0xF090 0x0001      EORS     R0,R0,#0x1
   \       0x8E   0xB2C0             UXTB     R0,R0
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD101             BNE.N    ??Mem_DynPoolBlkFree_7
   \       0x94   0x46A8             MOV      R8,R5
   \       0x96   0xE003             B.N      ??Mem_DynPoolBlkFree_8
   \                     ??Mem_DynPoolBlkFree_7: (+1)
   \       0x98   0x68A0             LDR      R0,[R4, #+8]
   \       0x9A   0x4428             ADD      R0,R5,R0
   \       0x9C   0xF1B0 0x0804      SUBS     R8,R0,#+4
   1361          
   1362            CORE_ENTER_ATOMIC();
   \                     ??Mem_DynPoolBlkFree_8: (+1)
   \       0xA0   0x.... 0x....      BL       CORE_EnterAtomic
   \       0xA4   0x4681             MOV      R9,R0
   1363            *((void **)p_blk_next_addr) = p_pool->BlkFreePtr;
   \       0xA6   0x6920             LDR      R0,[R4, #+16]
   \       0xA8   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1364            p_pool->BlkFreePtr = p_blk;
   \       0xAC   0x6125             STR      R5,[R4, #+16]
   1365            CORE_EXIT_ATOMIC();
   \       0xAE   0x4648             MOV      R0,R9
   \       0xB0   0x.... 0x....      BL       CORE_ExitAtomic
   1366          
   1367            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x7030             STRB     R0,[R6, #+0]
   \       0xB8   0x....             LDR.N    R0,??DataTable17_1
   \       0xBA   0x6070             STR      R0,[R6, #+4]
   \       0xBC   0xF240 0x5057      MOVW     R0,#+1367
   \       0xC0   0x60B0             STR      R0,[R6, #+8]
   \       0xC2   0x.... 0x....      LDR.W    R0,??DataTable18_9
   \       0xC6   0x60F0             STR      R0,[R6, #+12]
   1368          }
   \                     ??Mem_DynPoolBlkFree_6: (+1)
   \       0xC8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   1369          
   1370          /****************************************************************************************************//**
   1371           *                                       Mem_DynPoolBlkNbrAvailGet()
   1372           *
   1373           * @brief    Gets a number of available blocks in dynamic memory pool. If 'p_pool_info' is DEF_NULL,
   1374           *           this call will fail with a dynamic memory pool for which no limit was set at creation.
   1375           *
   1376           * @param    p_pool          Pointer to the pool data.
   1377           *
   1378           * @param    p_pool_info     Pointer to MEM_DYN_POOL_INFO that will be filled by this function. If
   1379           *                           DEF_NULL and if pool has a block limit, only the number of blocks
   1380           *                           remaining is returned.
   1381           *
   1382           * @param    p_err           Pointer to the variable that will receive one of the following error
   1383           *                           code(s) from this function:
   1384           *                               - RTOS_ERR_NONE
   1385           *                               - RTOS_ERR_POOL_UNLIMITED
   1386           *
   1387           * @return   Number of blocks remaining in dynamic memory pool, if successful.
   1388           *           0, if pool is empty or if an error occurred.
   1389           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1390          CPU_SIZE_T Mem_DynPoolBlkNbrAvailGet(MEM_DYN_POOL      *p_pool,
   1391                                               MEM_DYN_POOL_INFO *p_pool_info,
   1392                                               RTOS_ERR          *p_err)
   1393          {
   \                     Mem_DynPoolBlkNbrAvailGet: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0017             MOVS     R7,R2
   1394            CPU_SIZE_T blk_nbr_rem;
   1395            CORE_DECLARE_IRQ_STATE;
   1396          
   1397            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0);
   \        0xA   0x2F00             CMP      R7,#+0
   \        0xC   0xD101             BNE.N    ??Mem_DynPoolBlkNbrAvailGet_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
   1398          
   1399            //                                                               Chk for NULL pool data ptr.
   1400            RTOS_ASSERT_DBG_ERR_SET((p_pool != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0);
   \                     ??Mem_DynPoolBlkNbrAvailGet_0: (+1)
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD10A             BNE.N    ??Mem_DynPoolBlkNbrAvailGet_1
   \       0x16   0x200A             MOVS     R0,#+10
   \       0x18   0x7038             STRB     R0,[R7, #+0]
   \       0x1A   0x....             LDR.N    R0,??DataTable17_1
   \       0x1C   0x6078             STR      R0,[R7, #+4]
   \       0x1E   0xF44F 0x60AF      MOV      R0,#+1400
   \       0x22   0x60B8             STR      R0,[R7, #+8]
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable18_10
   \       0x28   0x60F8             STR      R0,[R7, #+12]
   \                     ??Mem_DynPoolBlkNbrAvailGet_2: (+1)
   \       0x2A   0xE7FE             B.N      ??Mem_DynPoolBlkNbrAvailGet_2
   1401          
   1402            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??Mem_DynPoolBlkNbrAvailGet_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x7038             STRB     R0,[R7, #+0]
   \       0x30   0x....             LDR.N    R5,??DataTable17_1
   \       0x32   0x607D             STR      R5,[R7, #+4]
   \       0x34   0xF240 0x507A      MOVW     R0,#+1402
   \       0x38   0x60B8             STR      R0,[R7, #+8]
   \       0x3A   0x.... 0x....      LDR.W    R10,??DataTable18_10
   \       0x3E   0xF8C7 0xA00C      STR      R10,[R7, #+12]
   1403          
   1404            CORE_ENTER_ATOMIC();
   \       0x42   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x46   0x4680             MOV      R8,R0
   1405            if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
   \       0x48   0x6970             LDR      R0,[R6, #+20]
   \       0x4A   0xF110 0x0F01      CMN      R0,#+1
   \       0x4E   0xD005             BEQ.N    ??Mem_DynPoolBlkNbrAvailGet_3
   1406              blk_nbr_rem = p_pool->BlkQtyMax - p_pool->BlkAllocCnt;
   \       0x50   0xF8D6 0x9014      LDR      R9,[R6, #+20]
   \       0x54   0x69B0             LDR      R0,[R6, #+24]
   \       0x56   0xEBB9 0x0900      SUBS     R9,R9,R0
   \       0x5A   0xE00B             B.N      ??Mem_DynPoolBlkNbrAvailGet_4
   1407            } else {
   1408              blk_nbr_rem = LIB_MEM_BLK_QTY_UNLIMITED;
   \                     ??Mem_DynPoolBlkNbrAvailGet_3: (+1)
   \       0x5C   0xF05F 0x39FF      MOVS     R9,#+4294967295
   1409              if (p_pool_info == DEF_NULL) {
   \       0x60   0x2C00             CMP      R4,#+0
   \       0x62   0xD107             BNE.N    ??Mem_DynPoolBlkNbrAvailGet_4
   1410                RTOS_ERR_SET(*p_err, RTOS_ERR_POOL_UNLIMITED);
   \       0x64   0x2019             MOVS     R0,#+25
   \       0x66   0x7038             STRB     R0,[R7, #+0]
   \       0x68   0x607D             STR      R5,[R7, #+4]
   \       0x6A   0xF240 0x5082      MOVW     R0,#+1410
   \       0x6E   0x60B8             STR      R0,[R7, #+8]
   \       0x70   0xF8C7 0xA00C      STR      R10,[R7, #+12]
   1411              }
   1412            }
   1413          
   1414            if (p_pool_info != DEF_NULL) {
   \                     ??Mem_DynPoolBlkNbrAvailGet_4: (+1)
   \       0x74   0x2C00             CMP      R4,#+0
   \       0x76   0xD023             BEQ.N    ??Mem_DynPoolBlkNbrAvailGet_5
   1415              CPU_SIZE_T blk_nbr_avail = 0u;
   \       0x78   0xF05F 0x0A00      MOVS     R10,#+0
   1416              void       *p_blk;
   1417          
   1418              p_blk = p_pool->BlkFreePtr;
   \       0x7C   0x6935             LDR      R5,[R6, #+16]
   1419              while (p_blk != DEF_NULL) {                                 // Iterate through free list to cnt nbr of blks.
   \                     ??Mem_DynPoolBlkNbrAvailGet_6: (+1)
   \       0x7E   0x2D00             CMP      R5,#+0
   \       0x80   0xD012             BEQ.N    ??Mem_DynPoolBlkNbrAvailGet_7
   1420                blk_nbr_avail++;
   \       0x82   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1421          
   1422                p_blk = (DEF_BIT_IS_CLR(p_pool->Opt, MEM_DYN_POOL_OPT_PERSISTENT) == DEF_YES) ? *((void **)p_blk)
   1423                        : *((void **)((CPU_INT08U *)p_blk + p_pool->BlkSize - sizeof(void *)));
   \       0x86   0x7830             LDRB     R0,[R6, #+0]
   \       0x88   0xB2C0             UXTB     R0,R0
   \       0x8A   0x0840             LSRS     R0,R0,#+1
   \       0x8C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x90   0xF090 0x0001      EORS     R0,R0,#0x1
   \       0x94   0xB2C0             UXTB     R0,R0
   \       0x96   0x2801             CMP      R0,#+1
   \       0x98   0xD101             BNE.N    ??Mem_DynPoolBlkNbrAvailGet_8
   \       0x9A   0x682D             LDR      R5,[R5, #+0]
   \       0x9C   0xE7EF             B.N      ??Mem_DynPoolBlkNbrAvailGet_6
   \                     ??Mem_DynPoolBlkNbrAvailGet_8: (+1)
   \       0x9E   0x68B0             LDR      R0,[R6, #+8]
   \       0xA0   0x4428             ADD      R0,R5,R0
   \       0xA2   0xF850 0x5C04      LDR      R5,[R0, #-4]
   \       0xA6   0xE7EA             B.N      ??Mem_DynPoolBlkNbrAvailGet_6
   1424              }
   1425          
   1426              p_pool_info->BlkQtyMax = p_pool->BlkQtyMax;
   \                     ??Mem_DynPoolBlkNbrAvailGet_7: (+1)
   \       0xA8   0x6970             LDR      R0,[R6, #+20]
   \       0xAA   0x6020             STR      R0,[R4, #+0]
   1427              p_pool_info->BlkNbrAllocCnt = p_pool->BlkAllocCnt;
   \       0xAC   0x69B0             LDR      R0,[R6, #+24]
   \       0xAE   0x6060             STR      R0,[R4, #+4]
   1428              CORE_EXIT_ATOMIC();
   \       0xB0   0x4640             MOV      R0,R8
   \       0xB2   0x.... 0x....      BL       CORE_ExitAtomic
   1429          
   1430              p_pool_info->BlkNbrRemCnt = blk_nbr_rem;
   \       0xB6   0xF8C4 0x9008      STR      R9,[R4, #+8]
   1431              p_pool_info->BlkNbrAvailCnt = blk_nbr_avail;
   \       0xBA   0xF8C4 0xA00C      STR      R10,[R4, #+12]
   \       0xBE   0xE002             B.N      ??Mem_DynPoolBlkNbrAvailGet_9
   1432          
   1433              LOG_VRB(("Calculated number of max blocks (", (u)p_pool_info->BlkQtyMax,
   1434                       ") allocated and used blocks (", (u)(p_pool_info->BlkNbrAllocCnt - blk_nbr_avail),
   1435                       ") allocated and currently unused blocks (", (u)blk_nbr_avail,
   1436                       ") and remaining blocks to allocate (", (u)blk_nbr_rem, ")."));
   1437            } else {
   1438              CORE_EXIT_ATOMIC();
   \                     ??Mem_DynPoolBlkNbrAvailGet_5: (+1)
   \       0xC0   0x4640             MOV      R0,R8
   \       0xC2   0x.... 0x....      BL       CORE_ExitAtomic
   1439            }
   1440          
   1441            return (blk_nbr_rem);
   \                     ??Mem_DynPoolBlkNbrAvailGet_9: (+1)
   \       0xC6   0x4648             MOV      R0,R9
   \       0xC8   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1442          }
   1443          
   1444          /****************************************************************************************************//**
   1445           *                                               Mem_SegTotalUsageGet()
   1446           *
   1447           * @brief    Gets the free/total memory information from the initial heap
   1448           *
   1449           * @param    p_used      Pointer to the variable that will receive the total size of memory used
   1450           *
   1451           * @param    p_free      Pointer to the variable that will receive the total size of free memory left
   1452           *
   1453           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1454           *                       from this function:
   1455           *                           - RTOS_ERR_NONE
   1456           *******************************************************************************************************/
   1457          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   1458          void Mem_SegTotalUsageGet(CPU_SIZE_T *p_used,
   1459                                    CPU_SIZE_T *p_free,
   1460                                    RTOS_ERR   *p_err)
   1461          {
   1462            MEM_SEG_INFO seg_info;
   1463            MEM_SEG      *p_seg = Mem_SegHeadPtr;
   1464          
   1465            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   1466            RTOS_ASSERT_DBG_ERR_SET((p_used != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   1467            RTOS_ASSERT_DBG_ERR_SET((p_free != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   1468          
   1469            *p_free = 0;
   1470            *p_used = 0;
   1471          
   1472            while (p_seg != 0) {
   1473              *p_free += Mem_SegRemSizeGet(p_seg, 1u, &seg_info, p_err);
   1474              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1475                return;
   1476              }
   1477              *p_used += seg_info.TotalSize;
   1478              p_seg = p_seg->NextPtr;
   1479            }
   1480          
   1481            *p_used -= *p_free;
   1482          
   1483            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   1484          }
   1485          #endif
   1486          
   1487          /****************************************************************************************************//**
   1488           *                                               Mem_OutputUsage()
   1489           *
   1490           * @brief    Outputs the memory usage report through 'out_fnct'.
   1491           *
   1492           * @param    out_fnct    Pointer to output function.
   1493           *
   1494           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1495           *                       from this function:
   1496           *                           - RTOS_ERR_NONE
   1497           *******************************************************************************************************/
   1498          
   1499          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   1500          void Mem_OutputUsage(void (*out_fnct)(CPU_CHAR *p_str),
   1501                               RTOS_ERR *p_err)
   1502          {
   1503            CPU_SIZE_T rem_size;
   1504            CPU_CHAR   str[DEF_INT_32U_NBR_DIG_MAX + 1u];
   1505            MEM_SEG    *p_seg;
   1506            CORE_DECLARE_IRQ_STATE;
   1507          
   1508            RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   1509          
   1510            //                                                               Chk for NULL out fnct ptr.
   1511            RTOS_ASSERT_DBG_ERR_SET((out_fnct != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   1512          
   1513            out_fnct((CPU_CHAR *)"---------------- Memory allocation info ----------------\r\n");
   1514            out_fnct((CPU_CHAR *)"| Type    | Size       | Free size  | Name\r\n");
   1515            out_fnct((CPU_CHAR *)"|---------|------------|------------|-------------------\r\n");
   1516          
   1517            CORE_ENTER_ATOMIC();
   1518            p_seg = Mem_SegHeadPtr;
   1519            while (p_seg != DEF_NULL) {
   1520              MEM_SEG_INFO   seg_info;
   1521              MEM_ALLOC_INFO *p_alloc;
   1522          
   1523              rem_size = Mem_SegRemSizeGet(p_seg, 1u, &seg_info, p_err);
   1524              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1525                return;
   1526              }
   1527          
   1528              out_fnct((CPU_CHAR *)"| Section | ");
   1529          
   1530              (void)Str_FmtNbr_Int32U(seg_info.TotalSize,
   1531                                      10u,
   1532                                      DEF_NBR_BASE_DEC,
   1533                                      ' ',
   1534                                      DEF_NO,
   1535                                      DEF_YES,
   1536                                      &str[0u]);
   1537          
   1538              out_fnct(str);
   1539              out_fnct((CPU_CHAR *)" | ");
   1540          
   1541              (void)Str_FmtNbr_Int32U(rem_size,
   1542                                      10u,
   1543                                      DEF_NBR_BASE_DEC,
   1544                                      ' ',
   1545                                      DEF_NO,
   1546                                      DEF_YES,
   1547                                      &str[0u]);
   1548          
   1549              out_fnct(str);
   1550              out_fnct((CPU_CHAR *)" | ");
   1551              out_fnct((p_seg->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_seg->NamePtr : (CPU_CHAR *)"Unknown");
   1552              out_fnct((CPU_CHAR *)"\r\n");
   1553          
   1554              p_alloc = p_seg->AllocInfoHeadPtr;
   1555              while (p_alloc != DEF_NULL) {
   1556                out_fnct((CPU_CHAR *)"| -- Obj  | ");
   1557          
   1558                (void)Str_FmtNbr_Int32U(p_alloc->Size,
   1559                                        10u,
   1560                                        DEF_NBR_BASE_DEC,
   1561                                        ' ',
   1562                                        DEF_NO,
   1563                                        DEF_YES,
   1564                                        &str[0u]);
   1565          
   1566                out_fnct(str);
   1567                out_fnct((CPU_CHAR *)" |            | ");
   1568          
   1569                out_fnct((p_alloc->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_alloc->NamePtr : (CPU_CHAR *)"Unknown");
   1570                out_fnct((CPU_CHAR *)"\r\n");
   1571          
   1572                p_alloc = p_alloc->NextPtr;
   1573              }
   1574          
   1575              p_seg = p_seg->NextPtr;
   1576            }
   1577            CORE_EXIT_ATOMIC();
   1578          
   1579            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   1580          }
   1581          #endif
   1582          
   1583          /********************************************************************************************************
   1584           ********************************************************************************************************
   1585           *                                           LOCAL FUNCTIONS
   1586           ********************************************************************************************************
   1587           *******************************************************************************************************/
   1588          
   1589          /****************************************************************************************************//**
   1590           *                                           Mem_SegCreateCritical()
   1591           *
   1592           * @brief          Creates a new memory segment to be used for runtime memory allocation or dynamic pools.
   1593           *
   1594           * @param          p_name          Pointer to segment name.
   1595           *
   1596           * @param          p_seg           Pointer to segment data. Must be allocated by caller.
   1597           *                                 Argument validated by caller.
   1598           *
   1599           * @param          seg_base_addr   Segment's first byte address.
   1600           *
   1601           * @param          padding_align   Padding alignment (in bytes), that will be added to any allocated buffer
   1602           *                                 from this memory segment. MUST be a power of 2.
   1603           *                                 LIB_MEM_PADDING_ALIGN_NONE means no padding.
   1604           *                                 LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
   1605           *                                 Argument validated by caller.
   1606           *
   1607           * @param          size            Total size of segment (in bytes).
   1608           *                                 Argument validated by caller.
   1609           *
   1610           * @return        Pointer to segment data, if successful.
   1611           *                DEF_NULL, otherwise.
   1612           *
   1613           * @note     (1) This function MUST be called within a CRITICAL_SECTION.
   1614           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1615          static void Mem_SegCreateCritical(const CPU_CHAR *p_name,
   1616                                            MEM_SEG        *p_seg,
   1617                                            CPU_ADDR       seg_base_addr,
   1618                                            CPU_SIZE_T     padding_align,
   1619                                            CPU_SIZE_T     size)
   1620          {
   \                     Mem_SegCreateCritical: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x9C03             LDR      R4,[SP, #+12]
   1621            p_seg->AddrBase = (void *) seg_base_addr;
   \        0x4   0x600A             STR      R2,[R1, #+0]
   1622            p_seg->AddrEnd = (void *)(seg_base_addr + (size - 1u));
   \        0x6   0x18A5             ADDS     R5,R4,R2
   \        0x8   0x1E6D             SUBS     R5,R5,#+1
   \        0xA   0x604D             STR      R5,[R1, #+4]
   1623            p_seg->AddrNext = (void *) seg_base_addr;
   \        0xC   0x608A             STR      R2,[R1, #+8]
   1624            p_seg->NextPtr = Mem_SegHeadPtr;
   \        0xE   0x.... 0x....      LDR.W    R5,??DataTable18_1
   \       0x12   0x682E             LDR      R6,[R5, #+0]
   \       0x14   0x60CE             STR      R6,[R1, #+12]
   1625            p_seg->PaddingAlign = (padding_align == LIB_MEM_BUF_ALIGN_AUTO) ? CPU_MIN_DATA_ALIGN_BYTES() : padding_align;
   \       0x16   0x2B00             CMP      R3,#+0
   \       0x18   0xD101             BNE.N    ??Mem_SegCreateCritical_0
   \       0x1A   0x2604             MOVS     R6,#+4
   \       0x1C   0xE000             B.N      ??Mem_SegCreateCritical_1
   \                     ??Mem_SegCreateCritical_0: (+1)
   \       0x1E   0x001E             MOVS     R6,R3
   \                     ??Mem_SegCreateCritical_1: (+1)
   \       0x20   0x610E             STR      R6,[R1, #+16]
   1626          
   1627          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   1628            p_seg->NamePtr = p_name;
   1629            p_seg->AllocInfoHeadPtr = DEF_NULL;
   1630          #else
   1631            PP_UNUSED_PARAM(p_name);
   1632          #endif
   1633          
   1634            Mem_SegHeadPtr = p_seg;
   \       0x22   0x6029             STR      R1,[R5, #+0]
   1635          }
   \       0x24   0xBC70             POP      {R4-R6}
   \       0x26   0x4770             BX       LR
   1636          
   1637          /****************************************************************************************************//**
   1638           *                                       Mem_SegOverlapChkCritical()
   1639           *
   1640           * @brief    Checks if existing memory segment exists or overlaps with specified memory area.
   1641           *
   1642           * @param    seg_base_addr   Address of first byte of memory area.
   1643           *
   1644           * @param    size            Size of memory area (in bytes).
   1645           *
   1646           * @param    p_status        Pointer to a variable that will receive the segment status :
   1647           *                               - MEM_SEG_STATUS_NONE     Segment does not exist.
   1648           *                               - MEM_SEG_STATUS_EXISTS   Segment already exists.
   1649           *                               - MEM_SEG_STATUS_OVERLAPS Segment overlaps another existing segment.
   1650           *
   1651           * @return   Pointer to memory segment that overlaps.
   1652           *           DEF_NULL, otherwise.
   1653           *
   1654           * @note     (1) This function MUST be called within a CRITICAL_SECTION.
   1655           *******************************************************************************************************/
   1656          
   1657          #if (RTOS_ARG_CHK_EXT_EN)

   \                                 In section .text, align 2, keep-with-next
   1658          static MEM_SEG *Mem_SegOverlapChkCritical(CPU_ADDR       seg_base_addr,
   1659                                                    CPU_SIZE_T     size,
   1660                                                    MEM_SEG_STATUS *p_status)
   1661          {
   \                     Mem_SegOverlapChkCritical: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000B             MOVS     R3,R1
   1662            MEM_SEG  *p_seg_chk;
   1663            CPU_ADDR seg_new_end;
   1664            CPU_ADDR seg_chk_start;
   1665            CPU_ADDR seg_chk_end;
   1666          
   1667            seg_new_end = seg_base_addr + (size - 1u);
   \        0x6   0x191F             ADDS     R7,R3,R4
   \        0x8   0x1E7F             SUBS     R7,R7,#+1
   1668            p_seg_chk = Mem_SegHeadPtr;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   1669          
   1670            while (p_seg_chk != DEF_NULL) {
   \                     ??Mem_SegOverlapChkCritical_0: (+1)
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD019             BEQ.N    ??Mem_SegOverlapChkCritical_1
   1671              seg_chk_start = (CPU_ADDR)p_seg_chk->AddrBase;
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0x0005             MOVS     R5,R0
   1672              seg_chk_end = (CPU_ADDR)p_seg_chk->AddrEnd;
   \       0x18   0x6848             LDR      R0,[R1, #+4]
   \       0x1A   0x0006             MOVS     R6,R0
   1673          
   1674              if ((seg_base_addr == seg_chk_start) && (seg_new_end == seg_chk_end)) {
   \       0x1C   0x42AC             CMP      R4,R5
   \       0x1E   0xD105             BNE.N    ??Mem_SegOverlapChkCritical_2
   \       0x20   0x42B7             CMP      R7,R6
   \       0x22   0xD103             BNE.N    ??Mem_SegOverlapChkCritical_2
   1675                *p_status = MEM_SEG_STATUS_EXISTS;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x7010             STRB     R0,[R2, #+0]
   1676          
   1677                return (p_seg_chk);
   \       0x28   0x0008             MOVS     R0,R1
   \       0x2A   0xE010             B.N      ??Mem_SegOverlapChkCritical_3
   1678              } else if (((seg_base_addr >= seg_chk_start) && (seg_base_addr <= seg_chk_end))
   1679                         || ((seg_base_addr <= seg_chk_start) && (seg_new_end >= seg_chk_start))) {
   \                     ??Mem_SegOverlapChkCritical_2: (+1)
   \       0x2C   0x42AC             CMP      R4,R5
   \       0x2E   0xD301             BCC.N    ??Mem_SegOverlapChkCritical_4
   \       0x30   0x42A6             CMP      R6,R4
   \       0x32   0xD203             BCS.N    ??Mem_SegOverlapChkCritical_5
   \                     ??Mem_SegOverlapChkCritical_4: (+1)
   \       0x34   0x42A5             CMP      R5,R4
   \       0x36   0xD305             BCC.N    ??Mem_SegOverlapChkCritical_6
   \       0x38   0x42AF             CMP      R7,R5
   \       0x3A   0xD303             BCC.N    ??Mem_SegOverlapChkCritical_6
   1680                *p_status = MEM_SEG_STATUS_OVERLAPS;
   \                     ??Mem_SegOverlapChkCritical_5: (+1)
   \       0x3C   0x2002             MOVS     R0,#+2
   \       0x3E   0x7010             STRB     R0,[R2, #+0]
   1681          
   1682                return (p_seg_chk);
   \       0x40   0x0008             MOVS     R0,R1
   \       0x42   0xE004             B.N      ??Mem_SegOverlapChkCritical_3
   1683              }
   1684          
   1685              p_seg_chk = p_seg_chk->NextPtr;
   \                     ??Mem_SegOverlapChkCritical_6: (+1)
   \       0x44   0x68C9             LDR      R1,[R1, #+12]
   \       0x46   0xE7E3             B.N      ??Mem_SegOverlapChkCritical_0
   1686            }
   1687          
   1688            *p_status = MEM_SEG_STATUS_NONE;
   \                     ??Mem_SegOverlapChkCritical_1: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x7010             STRB     R0,[R2, #+0]
   1689          
   1690            return (DEF_NULL);
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegOverlapChkCritical_3: (+1)
   \       0x4E   0xBCF0             POP      {R4-R7}
   \       0x50   0x4770             BX       LR
   1691          }
   1692          #endif
   1693          
   1694          /****************************************************************************************************//**
   1695           *                                           Mem_SegAllocInternal()
   1696           *
   1697           * @brief    Allocates memory from specified segment.
   1698           *
   1699           * @param    p_name          Pointer to allocated object name. Used to track allocations. May be
   1700           *                           DEF_NULL.
   1701           *
   1702           * @param    p_seg           Pointer to segment from which to allocate memory.
   1703           *                           Argument validated by caller.
   1704           *
   1705           * @param    size            Size of memory block to allocate (in bytes).
   1706           *
   1707           * @param    align           Required alignment of memory block (in bytes). MUST be a power of 2.
   1708           *                           LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
   1709           *
   1710           * @param    padding_align   Padding alignment (in bytes), that will be added to any allocated buffer
   1711           *                           from this memory segment. MUST be a power of 2.
   1712           *                           LIB_MEM_PADDING_ALIGN_NONE means no padding.
   1713           *
   1714           * @param    p_bytes_reqd    Pointer to a variable that will receive the number of free bytes missing
   1715           *                           for the allocation to succeed. Set to DEF_NULL to skip calculation.
   1716           *
   1717           * @param    p_err           Pointer to the variable that will receive one of the following error
   1718           *                           code(s) from this function:
   1719           *                           Argument validated by caller.
   1720           *
   1721           * @return   Pointer to allocated memory block, if successful.
   1722           *           DEF_NULL, otherwise.
   1723           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1724          static void *Mem_SegAllocInternal(const CPU_CHAR *p_name,
   1725                                            MEM_SEG        *p_seg,
   1726                                            CPU_SIZE_T     size,
   1727                                            CPU_SIZE_T     align,
   1728                                            CPU_SIZE_T     padding_align,
   1729                                            CPU_SIZE_T     *p_bytes_reqd,
   1730                                            RTOS_ERR       *p_err)
   1731          {
   \                     Mem_SegAllocInternal: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9F0C             LDR      R7,[SP, #+48]
   \        0xE   0xF8DD 0x8038      LDR      R8,[SP, #+56]
   1732            void *p_blk;
   1733            CORE_DECLARE_IRQ_STATE;
   1734          
   1735            //                                                               Chk for invalid sized mem req.
   1736            RTOS_ASSERT_DBG_ERR_SET((size >= 1u), *p_err, RTOS_ERR_INVALID_ARG, DEF_NULL);
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD10E             BNE.N    ??Mem_SegAllocInternal_0
   \       0x16   0x2008             MOVS     R0,#+8
   \       0x18   0xF888 0x0000      STRB     R0,[R8, #+0]
   \       0x1C   0x....             LDR.N    R0,??DataTable17_1
   \       0x1E   0xF8C8 0x0004      STR      R0,[R8, #+4]
   \       0x22   0xF44F 0x60D9      MOV      R0,#+1736
   \       0x26   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable18_11
   \       0x2E   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \                     ??Mem_SegAllocInternal_1: (+1)
   \       0x32   0xE7FE             B.N      ??Mem_SegAllocInternal_1
   1737          
   1738            //                                                               Chk that align is a pwr of 2.
   1739            RTOS_ASSERT_DBG_ERR_SET((MATH_IS_PWR2(align) == DEF_YES)
   1740                                    || (align == LIB_MEM_BUF_ALIGN_AUTO), *p_err, RTOS_ERR_INVALID_ARG, DEF_NULL);
   \                     ??Mem_SegAllocInternal_0: (+1)
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD004             BEQ.N    ??Mem_SegAllocInternal_2
   \       0x38   0x1E60             SUBS     R0,R4,#+1
   \       0x3A   0x4204             TST      R4,R0
   \       0x3C   0xD101             BNE.N    ??Mem_SegAllocInternal_2
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0xE000             B.N      ??Mem_SegAllocInternal_3
   \                     ??Mem_SegAllocInternal_2: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegAllocInternal_3: (+1)
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD001             BEQ.N    ??Mem_SegAllocInternal_4
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD101             BNE.N    ??Mem_SegAllocInternal_5
   \                     ??Mem_SegAllocInternal_4: (+1)
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xE000             B.N      ??Mem_SegAllocInternal_6
   \                     ??Mem_SegAllocInternal_5: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegAllocInternal_6: (+1)
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD10E             BNE.N    ??Mem_SegAllocInternal_7
   \       0x58   0x2008             MOVS     R0,#+8
   \       0x5A   0xF888 0x0000      STRB     R0,[R8, #+0]
   \       0x5E   0x....             LDR.N    R0,??DataTable17_1
   \       0x60   0xF8C8 0x0004      STR      R0,[R8, #+4]
   \       0x64   0xF240 0x60CC      MOVW     R0,#+1740
   \       0x68   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable18_11
   \       0x70   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \                     ??Mem_SegAllocInternal_8: (+1)
   \       0x74   0xE7FE             B.N      ??Mem_SegAllocInternal_8
   1741          
   1742            CORE_ENTER_ATOMIC();
   \                     ??Mem_SegAllocInternal_7: (+1)
   \       0x76   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x7A   0x4681             MOV      R9,R0
   1743            p_blk = Mem_SegAllocExtCritical(p_seg,
   1744                                            size,
   1745                                            align,
   1746                                            padding_align,
   1747                                            p_bytes_reqd,
   1748                                            p_err);
   \       0x7C   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x80   0x980D             LDR      R0,[SP, #+52]
   \       0x82   0x9000             STR      R0,[SP, #+0]
   \       0x84   0x003B             MOVS     R3,R7
   \       0x86   0x0022             MOVS     R2,R4
   \       0x88   0x0029             MOVS     R1,R5
   \       0x8A   0x0030             MOVS     R0,R6
   \       0x8C   0x.... 0x....      BL       Mem_SegAllocExtCritical
   \       0x90   0x4682             MOV      R10,R0
   1749            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x92   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD012             BEQ.N    ??Mem_SegAllocInternal_9
   1750              CORE_EXIT_ATOMIC();
   \       0x9A   0x4648             MOV      R0,R9
   \       0x9C   0x.... 0x....      BL       CORE_ExitAtomic
   1751              RTOS_ERR_SET(*p_err, RTOS_ERR_SEG_OVF);
   \       0xA0   0x2016             MOVS     R0,#+22
   \       0xA2   0xF888 0x0000      STRB     R0,[R8, #+0]
   \       0xA6   0x....             LDR.N    R0,??DataTable17_1
   \       0xA8   0xF8C8 0x0004      STR      R0,[R8, #+4]
   \       0xAC   0xF240 0x60D7      MOVW     R0,#+1751
   \       0xB0   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable18_11
   \       0xB8   0xF8C8 0x000C      STR      R0,[R8, #+12]
   1752          
   1753              return (DEF_NULL);
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xE003             B.N      ??Mem_SegAllocInternal_10
   1754            }
   1755          
   1756          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    // Track alloc if req'd.
   1757            Mem_SegAllocTrackCritical(p_name,
   1758                                      p_seg,
   1759                                      size,
   1760                                      p_err);
   1761            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1762              CORE_EXIT_ATOMIC();
   1763              return (DEF_NULL);
   1764            }
   1765          #else
   1766            PP_UNUSED_PARAM(p_name);
   1767          #endif
   1768            CORE_EXIT_ATOMIC();
   \                     ??Mem_SegAllocInternal_9: (+1)
   \       0xC0   0x4648             MOV      R0,R9
   \       0xC2   0x.... 0x....      BL       CORE_ExitAtomic
   1769          
   1770            return (p_blk);
   \       0xC6   0x4650             MOV      R0,R10
   \                     ??Mem_SegAllocInternal_10: (+1)
   \       0xC8   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1771          }
   1772          
   1773          /****************************************************************************************************//**
   1774           *                                           Mem_SegAllocExtCritical()
   1775           *
   1776           * @brief    Allocates memory from specified segment.
   1777           *
   1778           * @param    p_seg           Pointer to segment from which to allocate memory.
   1779           *
   1780           * @param    size            Size of memory block to allocate (in bytes).
   1781           *
   1782           * @param    align           Required alignment of memory block (in bytes). MUST be a power of 2.
   1783           *                           LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
   1784           *
   1785           * @param    padding_align   Padding alignment (in bytes), that will be added to any allocated buffer
   1786           *                           from this memory segment. MUST be a power of 2.
   1787           *                           LIB_MEM_PADDING_ALIGN_NONE means no padding.
   1788           *
   1789           * @param    p_bytes_reqd    Pointer to a variable that will receive the number of free bytes missing
   1790           *                           for the allocation to succeed. Set to DEF_NULL to skip calculation.
   1791           *
   1792           * @param    p_err           Pointer to the variable that will receive one of the following error
   1793           *                           code(s) from this function:
   1794           *                               - RTOS_ERR_NONE
   1795           *                               - RTOS_ERR_SEG_OVF
   1796           *
   1797           * @return   Pointer to allocated memory block, if successful.
   1798           *           DEF_NULL, otherwise.
   1799           *
   1800           * @note     (1) This function MUST be called within a CRITICAL_SECTION.
   1801           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1802          static void *Mem_SegAllocExtCritical(MEM_SEG    *p_seg,
   1803                                               CPU_SIZE_T size,
   1804                                               CPU_SIZE_T align,
   1805                                               CPU_SIZE_T padding_align,
   1806                                               CPU_SIZE_T *p_bytes_reqd,
   1807                                               RTOS_ERR   *p_err)
   1808          {
   \                     Mem_SegAllocExtCritical: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x9907             LDR      R1,[SP, #+28]
   \        0xA   0x9E08             LDR      R6,[SP, #+32]
   1809            CPU_ADDR   blk_addr;
   1810            CPU_ADDR   addr_next;
   1811            CPU_SIZE_T size_rem_seg;
   1812            CPU_SIZE_T size_tot_blk;
   1813            CPU_SIZE_T blk_align = DEF_MAX((align == LIB_MEM_BUF_ALIGN_AUTO) ? CPU_MIN_DATA_ALIGN_BYTES() : align, padding_align);
   \        0xC   0x2A00             CMP      R2,#+0
   \        0xE   0xD101             BNE.N    ??Mem_SegAllocExtCritical_0
   \       0x10   0x2004             MOVS     R0,#+4
   \       0x12   0xE000             B.N      ??Mem_SegAllocExtCritical_1
   \                     ??Mem_SegAllocExtCritical_0: (+1)
   \       0x14   0x0010             MOVS     R0,R2
   \                     ??Mem_SegAllocExtCritical_1: (+1)
   \       0x16   0x4283             CMP      R3,R0
   \       0x18   0xD205             BCS.N    ??Mem_SegAllocExtCritical_2
   \       0x1A   0x2A00             CMP      R2,#+0
   \       0x1C   0xD101             BNE.N    ??Mem_SegAllocExtCritical_3
   \       0x1E   0x2704             MOVS     R7,#+4
   \       0x20   0xE002             B.N      ??Mem_SegAllocExtCritical_4
   \                     ??Mem_SegAllocExtCritical_3: (+1)
   \       0x22   0x0017             MOVS     R7,R2
   \       0x24   0xE000             B.N      ??Mem_SegAllocExtCritical_4
   \                     ??Mem_SegAllocExtCritical_2: (+1)
   \       0x26   0x001F             MOVS     R7,R3
   1814          
   1815            //                                                               Compute align'ed blk addr.
   1816            blk_addr = MATH_ROUND_INC_UP_PWR2((CPU_ADDR)p_seg->AddrNext, blk_align);
   \                     ??Mem_SegAllocExtCritical_4: (+1)
   \       0x28   0xF8D5 0xC008      LDR      R12,[R5, #+8]
   \       0x2C   0x1E78             SUBS     R0,R7,#+1
   \       0x2E   0xEA1C 0x0F00      TST      R12,R0
   \       0x32   0xD102             BNE.N    ??Mem_SegAllocExtCritical_5
   \       0x34   0xF05F 0x0C00      MOVS     R12,#+0
   \       0x38   0xE000             B.N      ??Mem_SegAllocExtCritical_6
   \                     ??Mem_SegAllocExtCritical_5: (+1)
   \       0x3A   0x46BC             MOV      R12,R7
   \                     ??Mem_SegAllocExtCritical_6: (+1)
   \       0x3C   0xF8D5 0xE008      LDR      LR,[R5, #+8]
   \       0x40   0x1E78             SUBS     R0,R7,#+1
   \       0x42   0xEA3E 0x0E00      BICS     LR,LR,R0
   \       0x46   0xEB1C 0x0C0E      ADDS     R12,R12,LR
   1817            //                                                               Compute addr of next alloc.
   1818            addr_next = MATH_ROUND_INC_UP_PWR2(blk_addr + size, padding_align);
   \       0x4A   0xEB14 0x0E0C      ADDS     LR,R4,R12
   \       0x4E   0x1E58             SUBS     R0,R3,#+1
   \       0x50   0xEA1E 0x0F00      TST      LR,R0
   \       0x54   0xD102             BNE.N    ??Mem_SegAllocExtCritical_7
   \       0x56   0xF05F 0x0E00      MOVS     LR,#+0
   \       0x5A   0xE000             B.N      ??Mem_SegAllocExtCritical_8
   \                     ??Mem_SegAllocExtCritical_7: (+1)
   \       0x5C   0x469E             MOV      LR,R3
   \                     ??Mem_SegAllocExtCritical_8: (+1)
   \       0x5E   0xEB14 0x080C      ADDS     R8,R4,R12
   \       0x62   0x1E58             SUBS     R0,R3,#+1
   \       0x64   0xEA38 0x0800      BICS     R8,R8,R0
   \       0x68   0xEB1E 0x0E08      ADDS     LR,LR,R8
   1819          
   1820            size_rem_seg = ((CPU_ADDR)p_seg->AddrEnd - (CPU_ADDR)p_seg->AddrNext) + 1u;
   \       0x6C   0xF8D5 0x8004      LDR      R8,[R5, #+4]
   \       0x70   0x68A8             LDR      R0,[R5, #+8]
   \       0x72   0xEBB8 0x0800      SUBS     R8,R8,R0
   \       0x76   0xF118 0x0801      ADDS     R8,R8,#+1
   1821            size_tot_blk = addr_next - (CPU_ADDR)p_seg->AddrNext;         // Compute tot blk size including align and padding.
   \       0x7A   0xF8D5 0x9008      LDR      R9,[R5, #+8]
   \       0x7E   0xEBBE 0x0909      SUBS     R9,LR,R9
   1822            if (size_rem_seg < size_tot_blk) {                            // If seg doesn't have enough space ...
   \       0x82   0x45C8             CMP      R8,R9
   \       0x84   0xD210             BCS.N    ??Mem_SegAllocExtCritical_9
   1823              if (p_bytes_reqd != DEF_NULL) {                             // ... calc nbr of req'd bytes.
   \       0x86   0x2900             CMP      R1,#+0
   \       0x88   0xD002             BEQ.N    ??Mem_SegAllocExtCritical_10
   1824                *p_bytes_reqd = size_tot_blk - size_rem_seg;
   \       0x8A   0xEBB9 0x0008      SUBS     R0,R9,R8
   \       0x8E   0x6008             STR      R0,[R1, #+0]
   1825              }
   1826              RTOS_ERR_SET(*p_err, RTOS_ERR_SEG_OVF);
   \                     ??Mem_SegAllocExtCritical_10: (+1)
   \       0x90   0x2016             MOVS     R0,#+22
   \       0x92   0x7030             STRB     R0,[R6, #+0]
   \       0x94   0x....             LDR.N    R0,??DataTable17_1
   \       0x96   0x6070             STR      R0,[R6, #+4]
   \       0x98   0xF240 0x7022      MOVW     R0,#+1826
   \       0x9C   0x60B0             STR      R0,[R6, #+8]
   \       0x9E   0x.... 0x....      LDR.W    R0,??DataTable18_12
   \       0xA2   0x60F0             STR      R0,[R6, #+12]
   1827              return (DEF_NULL);
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0xE00C             B.N      ??Mem_SegAllocExtCritical_11
   1828            }
   1829          
   1830            p_seg->AddrNext = (void *)addr_next;
   \                     ??Mem_SegAllocExtCritical_9: (+1)
   \       0xA8   0xF8C5 0xE008      STR      LR,[R5, #+8]
   1831          
   1832            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x7030             STRB     R0,[R6, #+0]
   \       0xB0   0x....             LDR.N    R0,??DataTable17_1
   \       0xB2   0x6070             STR      R0,[R6, #+4]
   \       0xB4   0xF44F 0x60E5      MOV      R0,#+1832
   \       0xB8   0x60B0             STR      R0,[R6, #+8]
   \       0xBA   0x.... 0x....      LDR.W    R0,??DataTable18_12
   \       0xBE   0x60F0             STR      R0,[R6, #+12]
   1833          
   1834            return ((void *)blk_addr);
   \       0xC0   0x4660             MOV      R0,R12
   \                     ??Mem_SegAllocExtCritical_11: (+1)
   \       0xC2   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1835          }
   1836          
   1837          /****************************************************************************************************//**
   1838           *                                       Mem_SegAllocTrackCritical()
   1839           *
   1840           * @brief    Tracks segment allocation, adding the 'size' of the allocation under the 'p_name' entry.
   1841           *
   1842           * @param    p_name  Pointer to the name of the object. This string is not copied and its memory should
   1843           *                   remain accessible at all times.
   1844           *
   1845           * @param    p_seg   Pointer to segment data.
   1846           *
   1847           * @param    size    Allocation size (in bytes).
   1848           *
   1849           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from
   1850           *                   this function:
   1851           *                       - RTOS_ERR_NONE
   1852           *                       - RTOS_ERR_SEG_OVF
   1853           *******************************************************************************************************/
   1854          
   1855          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   1856          static void Mem_SegAllocTrackCritical(const CPU_CHAR *p_name,
   1857                                                MEM_SEG        *p_seg,
   1858                                                CPU_SIZE_T     size,
   1859                                                RTOS_ERR       *p_err)
   1860          {
   1861            MEM_ALLOC_INFO *p_alloc;
   1862          
   1863            //                                                               ------- UPDATE ALLOC INFO LIST, IF POSSIBLE --------
   1864            p_alloc = p_seg->AllocInfoHeadPtr;
   1865            while (p_alloc != DEF_NULL) {
   1866              if (p_alloc->NamePtr == p_name) {
   1867                p_alloc->Size += size;
   1868                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   1869                return;
   1870              }
   1871          
   1872              p_alloc = p_alloc->NextPtr;
   1873            }
   1874          
   1875            //                                                               --------- ADD NEW ALLOC INFO ENTRY IN LIST ---------
   1876            //                                                               Alloc new alloc info struct on heap.
   1877            p_alloc = (MEM_ALLOC_INFO *)Mem_SegAllocExtCritical(&Mem_SegHeap,
   1878                                                                sizeof(MEM_ALLOC_INFO),
   1879                                                                sizeof(CPU_ALIGN),
   1880                                                                LIB_MEM_PADDING_ALIGN_NONE,
   1881                                                                DEF_NULL,
   1882                                                                p_err);
   1883            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   1884              return;
   1885            }
   1886          
   1887            p_alloc->NamePtr = p_name;                                    // Populate alloc info.
   1888            p_alloc->Size = size;
   1889          
   1890            p_alloc->NextPtr = p_seg->AllocInfoHeadPtr;                   // Prepend new item in list.
   1891            p_seg->AllocInfoHeadPtr = p_alloc;
   1892          }
   1893          #endif
   1894          
   1895          /****************************************************************************************************//**
   1896           *                                       Mem_DynPoolCreateInternal()
   1897           *
   1898           * @brief    Creates a dynamic memory pool.
   1899           *
   1900           * @param    p_name          Pointer to the pool name.
   1901           *
   1902           * @param    p_pool          Pointer to the pool data.
   1903           *                           Argument validated by caller.
   1904           *
   1905           * @param    p_seg           Pointer to segment from which to allocate memory.
   1906           *                           Argument validated by caller.
   1907           *
   1908           * @param    blk_size        Size of memory block to allocate from pool (in bytes). See Note #1.
   1909           *
   1910           * @param    blk_align       Required alignment of memory block (in bytes). MUST be a power of 2.
   1911           *                           LIB_MEM_BUF_ALIGN_AUTO will use cache line size, if cache present.
   1912           *
   1913           * @param    blk_qty_init    Initial number of elements to be allocated in pool.
   1914           *
   1915           * @param    blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1916           *                           LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   1917           *
   1918           * @param    p_err           Pointer to the variable that will receive one of the following error
   1919           *                           code(s) from this function:
   1920           *                           Argument validated by caller.
   1921           *
   1922           * @note     (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1923           *               block is stored in the block itself (only when free/unused).
   1924           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1925          static void Mem_DynPoolCreateInternal(const CPU_CHAR *p_name,
   1926                                                MEM_DYN_POOL   *p_pool,
   1927                                                MEM_SEG        *p_seg,
   1928                                                CPU_SIZE_T     blk_size,
   1929                                                CPU_SIZE_T     blk_align,
   1930                                                CPU_SIZE_T     blk_qty_init,
   1931                                                CPU_SIZE_T     blk_qty_max,
   1932                                                RTOS_ERR       *p_err)
   1933          {
   \                     Mem_DynPoolCreateInternal: (+1)
   \        0x0   0xE92D 0x4FF9      PUSH     {R0,R3-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0x9E15             LDR      R6,[SP, #+84]
   1934            CPU_INT08U *p_blks;
   1935            CPU_SIZE_T blk_size_real;
   1936            CPU_SIZE_T blk_align_real;
   1937          
   1938            //                                                               Chk for invalid blk size.
   1939            RTOS_ASSERT_DBG_ERR_SET((blk_size >= 1u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \        0xC   0x9808             LDR      R0,[SP, #+32]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD109             BNE.N    ??Mem_DynPoolCreateInternal_0
   \       0x12   0x2008             MOVS     R0,#+8
   \       0x14   0x7030             STRB     R0,[R6, #+0]
   \       0x16   0x....             LDR.N    R0,??DataTable18_13
   \       0x18   0x6070             STR      R0,[R6, #+4]
   \       0x1A   0xF240 0x7093      MOVW     R0,#+1939
   \       0x1E   0x60B0             STR      R0,[R6, #+8]
   \       0x20   0x....             LDR.N    R0,??DataTable18_14
   \       0x22   0x60F0             STR      R0,[R6, #+12]
   \                     ??Mem_DynPoolCreateInternal_1: (+1)
   \       0x24   0xE7FE             B.N      ??Mem_DynPoolCreateInternal_1
   1940          
   1941            //                                                               Chk for invalid blk qty.
   1942            RTOS_ASSERT_DBG_ERR_SET(((blk_qty_max == LIB_MEM_BLK_QTY_UNLIMITED)
   1943                                     || (blk_qty_init <= blk_qty_max)), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??Mem_DynPoolCreateInternal_0: (+1)
   \       0x26   0x9814             LDR      R0,[SP, #+80]
   \       0x28   0xF110 0x0F01      CMN      R0,#+1
   \       0x2C   0xD003             BEQ.N    ??Mem_DynPoolCreateInternal_2
   \       0x2E   0x9914             LDR      R1,[SP, #+80]
   \       0x30   0x9813             LDR      R0,[SP, #+76]
   \       0x32   0x4281             CMP      R1,R0
   \       0x34   0xD301             BCC.N    ??Mem_DynPoolCreateInternal_3
   \                     ??Mem_DynPoolCreateInternal_2: (+1)
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE000             B.N      ??Mem_DynPoolCreateInternal_4
   \                     ??Mem_DynPoolCreateInternal_3: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??Mem_DynPoolCreateInternal_4: (+1)
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD109             BNE.N    ??Mem_DynPoolCreateInternal_5
   \       0x42   0x2008             MOVS     R0,#+8
   \       0x44   0x7030             STRB     R0,[R6, #+0]
   \       0x46   0x....             LDR.N    R0,??DataTable18_13
   \       0x48   0x6070             STR      R0,[R6, #+4]
   \       0x4A   0xF240 0x7097      MOVW     R0,#+1943
   \       0x4E   0x60B0             STR      R0,[R6, #+8]
   \       0x50   0x....             LDR.N    R0,??DataTable18_14
   \       0x52   0x60F0             STR      R0,[R6, #+12]
   \                     ??Mem_DynPoolCreateInternal_6: (+1)
   \       0x54   0xE7FE             B.N      ??Mem_DynPoolCreateInternal_6
   1944          
   1945            //                                                               Chk for illegal align spec.
   1946            RTOS_ASSERT_DBG_ERR_SET(((MATH_IS_PWR2(blk_align) == DEF_YES)
   1947                                     && (blk_align >= CPU_MIN_DATA_ALIGN_BYTES()))
   1948                                    || (blk_align == LIB_MEM_BUF_ALIGN_AUTO), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??Mem_DynPoolCreateInternal_5: (+1)
   \       0x56   0x9812             LDR      R0,[SP, #+72]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD006             BEQ.N    ??Mem_DynPoolCreateInternal_7
   \       0x5C   0x9812             LDR      R0,[SP, #+72]
   \       0x5E   0x9912             LDR      R1,[SP, #+72]
   \       0x60   0x1E49             SUBS     R1,R1,#+1
   \       0x62   0x4208             TST      R0,R1
   \       0x64   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_7
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0xE000             B.N      ??Mem_DynPoolCreateInternal_8
   \                     ??Mem_DynPoolCreateInternal_7: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \                     ??Mem_DynPoolCreateInternal_8: (+1)
   \       0x6C   0x2801             CMP      R0,#+1
   \       0x6E   0xD102             BNE.N    ??Mem_DynPoolCreateInternal_9
   \       0x70   0x9812             LDR      R0,[SP, #+72]
   \       0x72   0x2804             CMP      R0,#+4
   \       0x74   0xD202             BCS.N    ??Mem_DynPoolCreateInternal_10
   \                     ??Mem_DynPoolCreateInternal_9: (+1)
   \       0x76   0x9812             LDR      R0,[SP, #+72]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_11
   \                     ??Mem_DynPoolCreateInternal_10: (+1)
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xE000             B.N      ??Mem_DynPoolCreateInternal_12
   \                     ??Mem_DynPoolCreateInternal_11: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \                     ??Mem_DynPoolCreateInternal_12: (+1)
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD109             BNE.N    ??Mem_DynPoolCreateInternal_13
   \       0x88   0x2008             MOVS     R0,#+8
   \       0x8A   0x7030             STRB     R0,[R6, #+0]
   \       0x8C   0x....             LDR.N    R0,??DataTable18_13
   \       0x8E   0x6070             STR      R0,[R6, #+4]
   \       0x90   0xF240 0x709C      MOVW     R0,#+1948
   \       0x94   0x60B0             STR      R0,[R6, #+8]
   \       0x96   0x....             LDR.N    R0,??DataTable18_14
   \       0x98   0x60F0             STR      R0,[R6, #+12]
   \                     ??Mem_DynPoolCreateInternal_14: (+1)
   \       0x9A   0xE7FE             B.N      ??Mem_DynPoolCreateInternal_14
   1949          
   1950            blk_align_real = (blk_align == LIB_MEM_BUF_ALIGN_AUTO) ? CPU_MIN_DATA_ALIGN_BYTES() : blk_align;
   \                     ??Mem_DynPoolCreateInternal_13: (+1)
   \       0x9C   0x9812             LDR      R0,[SP, #+72]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD102             BNE.N    ??Mem_DynPoolCreateInternal_15
   \       0xA2   0x2004             MOVS     R0,#+4
   \       0xA4   0x9006             STR      R0,[SP, #+24]
   \       0xA6   0xE001             B.N      ??Mem_DynPoolCreateInternal_16
   \                     ??Mem_DynPoolCreateInternal_15: (+1)
   \       0xA8   0x9812             LDR      R0,[SP, #+72]
   \       0xAA   0x9006             STR      R0,[SP, #+24]
   1951            //                                                               Compute actual size of blks.
   1952            if (DEF_BIT_IS_SET(p_pool->Opt, MEM_DYN_POOL_OPT_PERSISTENT) == DEF_YES) {
   \                     ??Mem_DynPoolCreateInternal_16: (+1)
   \       0xAC   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0xB0   0x0840             LSRS     R0,R0,#+1
   \       0xB2   0x07C0             LSLS     R0,R0,#+31
   \       0xB4   0xD50D             BPL.N    ??Mem_DynPoolCreateInternal_17
   1953              blk_size_real = MATH_ROUND_INC_UP_PWR2(blk_size, CPU_MIN_DATA_ALIGN_BYTES());
   \       0xB6   0x9808             LDR      R0,[SP, #+32]
   \       0xB8   0xF010 0x0F03      TST      R0,#0x3
   \       0xBC   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_18
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0xE000             B.N      ??Mem_DynPoolCreateInternal_19
   \                     ??Mem_DynPoolCreateInternal_18: (+1)
   \       0xC2   0x2004             MOVS     R0,#+4
   \                     ??Mem_DynPoolCreateInternal_19: (+1)
   \       0xC4   0x9908             LDR      R1,[SP, #+32]
   \       0xC6   0x0889             LSRS     R1,R1,#+2
   \       0xC8   0x0089             LSLS     R1,R1,#+2
   \       0xCA   0x1840             ADDS     R0,R0,R1
   1954              blk_size_real += sizeof(void *);                            // Add space for next ptr.
   \       0xCC   0x1D00             ADDS     R0,R0,#+4
   \       0xCE   0x9004             STR      R0,[SP, #+16]
   \       0xD0   0xE007             B.N      ??Mem_DynPoolCreateInternal_20
   1955            } else {
   1956              blk_size_real = DEF_MAX(blk_size, sizeof(void *));          // Make sure enough space avail to store next ptr.
   \                     ??Mem_DynPoolCreateInternal_17: (+1)
   \       0xD2   0x9808             LDR      R0,[SP, #+32]
   \       0xD4   0x2805             CMP      R0,#+5
   \       0xD6   0xD302             BCC.N    ??Mem_DynPoolCreateInternal_21
   \       0xD8   0x9808             LDR      R0,[SP, #+32]
   \       0xDA   0x9004             STR      R0,[SP, #+16]
   \       0xDC   0xE001             B.N      ??Mem_DynPoolCreateInternal_20
   \                     ??Mem_DynPoolCreateInternal_21: (+1)
   \       0xDE   0x2004             MOVS     R0,#+4
   \       0xE0   0x9004             STR      R0,[SP, #+16]
   1957            }
   1958          
   1959            if (blk_qty_init != 0u) {                                     // Alloc init blks.
   \                     ??Mem_DynPoolCreateInternal_20: (+1)
   \       0xE2   0x9813             LDR      R0,[SP, #+76]
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xF000 0x80E5      BEQ.W    ??Mem_DynPoolCreateInternal_22
   1960              CPU_SIZE_T i;
   1961              CPU_SIZE_T blk_size_align;
   1962              CPU_SIZE_T blk_align_worst;
   1963              CPU_INT64U blk_init_tot_size;
   1964              CPU_ADDR   blk_next_addr;
   1965          
   1966              if (DEF_BIT_IS_CLR(p_pool->Opt, MEM_DYN_POOL_OPT_HW) == DEF_YES) {
   \       0xEA   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0xEE   0x07C0             LSLS     R0,R0,#+31
   \       0xF0   0xD402             BMI.N    ??Mem_DynPoolCreateInternal_23
   1967                blk_align_worst = blk_align_real;
   \       0xF2   0x9806             LDR      R0,[SP, #+24]
   \       0xF4   0x9003             STR      R0,[SP, #+12]
   \       0xF6   0xE00A             B.N      ??Mem_DynPoolCreateInternal_24
   1968              } else {
   1969                blk_align_worst = DEF_MAX(blk_align_real, p_seg->PaddingAlign);
   \                     ??Mem_DynPoolCreateInternal_23: (+1)
   \       0xF8   0xF8D9 0x1010      LDR      R1,[R9, #+16]
   \       0xFC   0x9806             LDR      R0,[SP, #+24]
   \       0xFE   0x4281             CMP      R1,R0
   \      0x100   0xD202             BCS.N    ??Mem_DynPoolCreateInternal_25
   \      0x102   0x9806             LDR      R0,[SP, #+24]
   \      0x104   0x9003             STR      R0,[SP, #+12]
   \      0x106   0xE002             B.N      ??Mem_DynPoolCreateInternal_24
   \                     ??Mem_DynPoolCreateInternal_25: (+1)
   \      0x108   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \      0x10C   0x9003             STR      R0,[SP, #+12]
   1970              }
   1971          
   1972              blk_size_align = MATH_ROUND_INC_UP_PWR2(blk_size_real,
   1973                                                      blk_align_worst);
   \                     ??Mem_DynPoolCreateInternal_24: (+1)
   \      0x10E   0x9904             LDR      R1,[SP, #+16]
   \      0x110   0x9803             LDR      R0,[SP, #+12]
   \      0x112   0x1E40             SUBS     R0,R0,#+1
   \      0x114   0x4201             TST      R1,R0
   \      0x116   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_26
   \      0x118   0x2000             MOVS     R0,#+0
   \      0x11A   0xE000             B.N      ??Mem_DynPoolCreateInternal_27
   \                     ??Mem_DynPoolCreateInternal_26: (+1)
   \      0x11C   0x9803             LDR      R0,[SP, #+12]
   \                     ??Mem_DynPoolCreateInternal_27: (+1)
   \      0x11E   0x9A04             LDR      R2,[SP, #+16]
   \      0x120   0x9903             LDR      R1,[SP, #+12]
   \      0x122   0x1E49             SUBS     R1,R1,#+1
   \      0x124   0x438A             BICS     R2,R2,R1
   \      0x126   0x1880             ADDS     R0,R0,R2
   \      0x128   0x9005             STR      R0,[SP, #+20]
   1974              blk_init_tot_size = (CPU_INT64U)blk_size_align * (CPU_INT64U)blk_qty_init;
   \      0x12A   0x9805             LDR      R0,[SP, #+20]
   \      0x12C   0x9913             LDR      R1,[SP, #+76]
   \      0x12E   0xFBA1 0x2300      UMULL    R2,R3,R1,R0
   1975              RTOS_ASSERT_DBG_ERR_SET((blk_init_tot_size <= DEF_INT_32U_MAX_VAL),*p_err, RTOS_ERR_INVALID_ARG,; );
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x2101             MOVS     R1,#+1
   \      0x136   0x428B             CMP      R3,R1
   \      0x138   0xD30C             BCC.N    ??Mem_DynPoolCreateInternal_28
   \      0x13A   0xD801             BHI.N    ??Mem_DynPoolCreateInternal_29
   \      0x13C   0x4282             CMP      R2,R0
   \      0x13E   0xD309             BCC.N    ??Mem_DynPoolCreateInternal_28
   \                     ??Mem_DynPoolCreateInternal_29: (+1)
   \      0x140   0x2008             MOVS     R0,#+8
   \      0x142   0x7030             STRB     R0,[R6, #+0]
   \      0x144   0x....             LDR.N    R0,??DataTable18_13
   \      0x146   0x6070             STR      R0,[R6, #+4]
   \      0x148   0xF240 0x70B7      MOVW     R0,#+1975
   \      0x14C   0x60B0             STR      R0,[R6, #+8]
   \      0x14E   0x....             LDR.N    R0,??DataTable18_14
   \      0x150   0x60F0             STR      R0,[R6, #+12]
   \                     ??Mem_DynPoolCreateInternal_30: (+1)
   \      0x152   0xE7FE             B.N      ??Mem_DynPoolCreateInternal_30
   1976          
   1977              //                                                             Remove extra space added to last blk because of blk align.
   1978              blk_init_tot_size -= (blk_size_align - blk_size_real);
   \                     ??Mem_DynPoolCreateInternal_28: (+1)
   \      0x154   0x9805             LDR      R0,[SP, #+20]
   \      0x156   0x9904             LDR      R1,[SP, #+16]
   \      0x158   0x1A40             SUBS     R0,R0,R1
   \      0x15A   0x2100             MOVS     R1,#+0
   \      0x15C   0x1A14             SUBS     R4,R2,R0
   \      0x15E   0xEB73 0x0501      SBCS     R5,R3,R1
   1979              if (DEF_BIT_IS_SET(p_pool->Opt, MEM_DYN_POOL_OPT_HW) == DEF_YES) {
   \      0x162   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x166   0x07C0             LSLS     R0,R0,#+31
   \      0x168   0xD531             BPL.N    ??Mem_DynPoolCreateInternal_31
   1980                blk_init_tot_size = MATH_ROUND_INC_UP_PWR2(blk_init_tot_size, (CPU_INT64U)p_seg->PaddingAlign);
   \      0x16A   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \      0x16E   0x2100             MOVS     R1,#+0
   \      0x170   0x1E40             SUBS     R0,R0,#+1
   \      0x172   0xF171 0x0100      SBCS     R1,R1,#+0
   \      0x176   0x4020             ANDS     R0,R4,R0
   \      0x178   0x4029             ANDS     R1,R5,R1
   \      0x17A   0x2900             CMP      R1,#+0
   \      0x17C   0xD104             BNE.N    ??Mem_DynPoolCreateInternal_32
   \      0x17E   0x2800             CMP      R0,#+0
   \      0x180   0xD102             BNE.N    ??Mem_DynPoolCreateInternal_32
   \      0x182   0x2000             MOVS     R0,#+0
   \      0x184   0x2100             MOVS     R1,#+0
   \      0x186   0xE002             B.N      ??Mem_DynPoolCreateInternal_33
   \                     ??Mem_DynPoolCreateInternal_32: (+1)
   \      0x188   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \      0x18C   0x2100             MOVS     R1,#+0
   \                     ??Mem_DynPoolCreateInternal_33: (+1)
   \      0x18E   0x46A2             MOV      R10,R4
   \      0x190   0x46AB             MOV      R11,R5
   \      0x192   0xF8D9 0x2010      LDR      R2,[R9, #+16]
   \      0x196   0x2300             MOVS     R3,#+0
   \      0x198   0x1E54             SUBS     R4,R2,#+1
   \      0x19A   0xF173 0x0500      SBCS     R5,R3,#+0
   \      0x19E   0x4652             MOV      R2,R10
   \      0x1A0   0x465B             MOV      R3,R11
   \      0x1A2   0x43A2             BICS     R2,R2,R4
   \      0x1A4   0x43AB             BICS     R3,R3,R5
   \      0x1A6   0x1814             ADDS     R4,R2,R0
   \      0x1A8   0xEB53 0x0501      ADCS     R5,R3,R1
   1981                RTOS_ASSERT_DBG_ERR_SET((blk_init_tot_size <= DEF_INT_32U_MAX_VAL),*p_err, RTOS_ERR_INVALID_ARG,; );
   \      0x1AC   0x2000             MOVS     R0,#+0
   \      0x1AE   0x2101             MOVS     R1,#+1
   \      0x1B0   0x428D             CMP      R5,R1
   \      0x1B2   0xD30C             BCC.N    ??Mem_DynPoolCreateInternal_31
   \      0x1B4   0xD801             BHI.N    ??Mem_DynPoolCreateInternal_34
   \      0x1B6   0x4284             CMP      R4,R0
   \      0x1B8   0xD309             BCC.N    ??Mem_DynPoolCreateInternal_31
   \                     ??Mem_DynPoolCreateInternal_34: (+1)
   \      0x1BA   0x2008             MOVS     R0,#+8
   \      0x1BC   0x7030             STRB     R0,[R6, #+0]
   \      0x1BE   0x....             LDR.N    R0,??DataTable18_13
   \      0x1C0   0x6070             STR      R0,[R6, #+4]
   \      0x1C2   0xF240 0x70BD      MOVW     R0,#+1981
   \      0x1C6   0x60B0             STR      R0,[R6, #+8]
   \      0x1C8   0x....             LDR.N    R0,??DataTable18_14
   \      0x1CA   0x60F0             STR      R0,[R6, #+12]
   \                     ??Mem_DynPoolCreateInternal_35: (+1)
   \      0x1CC   0xE7FE             B.N      ??Mem_DynPoolCreateInternal_35
   1982              }
   1983          
   1984              p_blks = (CPU_INT08U *)Mem_SegAllocInternal(p_name,         // Alloc initial blks.
   1985                                                          p_seg,
   1986                                                          (CPU_SIZE_T)blk_init_tot_size,
   1987                                                          blk_align_worst,
   1988                                                          LIB_MEM_PADDING_ALIGN_NONE,
   1989                                                          DEF_NULL,
   1990                                                          p_err);
   \                     ??Mem_DynPoolCreateInternal_31: (+1)
   \      0x1CE   0x9602             STR      R6,[SP, #+8]
   \      0x1D0   0x2000             MOVS     R0,#+0
   \      0x1D2   0x9001             STR      R0,[SP, #+4]
   \      0x1D4   0x2001             MOVS     R0,#+1
   \      0x1D6   0x9000             STR      R0,[SP, #+0]
   \      0x1D8   0x9B03             LDR      R3,[SP, #+12]
   \      0x1DA   0x0022             MOVS     R2,R4
   \      0x1DC   0x4649             MOV      R1,R9
   \      0x1DE   0x9807             LDR      R0,[SP, #+28]
   \      0x1E0   0x.... 0x....      BL       Mem_SegAllocInternal
   \      0x1E4   0x0007             MOVS     R7,R0
   1991              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \      0x1E6   0x7830             LDRB     R0,[R6, #+0]
   \      0x1E8   0x2800             CMP      R0,#+0
   \      0x1EA   0xD17D             BNE.N    ??Mem_DynPoolCreateInternal_36
   1992                return;
   1993              }
   1994          
   1995              p_pool->BlkFreePtr = (void *)p_blks;
   \                     ??Mem_DynPoolCreateInternal_37: (+1)
   \      0x1EC   0xF8C8 0x7010      STR      R7,[R8, #+16]
   1996          
   1997              if (DEF_BIT_IS_CLR(p_pool->Opt, MEM_DYN_POOL_OPT_PERSISTENT) == DEF_YES) {
   \      0x1F0   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x1F4   0xB2C0             UXTB     R0,R0
   \      0x1F6   0x0840             LSRS     R0,R0,#+1
   \      0x1F8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x1FC   0xF090 0x0001      EORS     R0,R0,#0x1
   \      0x200   0xB2C0             UXTB     R0,R0
   \      0x202   0x2801             CMP      R0,#+1
   \      0x204   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_38
   1998                blk_next_addr = (CPU_ADDR)p_blks;
   \      0x206   0x46BB             MOV      R11,R7
   \      0x208   0xE00C             B.N      ??Mem_DynPoolCreateInternal_39
   1999              } else {
   2000                blk_next_addr = (CPU_ADDR)(p_blks + MATH_ROUND_INC_UP_PWR2(blk_size, sizeof(void *)));
   \                     ??Mem_DynPoolCreateInternal_38: (+1)
   \      0x20A   0x9808             LDR      R0,[SP, #+32]
   \      0x20C   0xF010 0x0F03      TST      R0,#0x3
   \      0x210   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_40
   \      0x212   0x2100             MOVS     R1,#+0
   \      0x214   0xE000             B.N      ??Mem_DynPoolCreateInternal_41
   \                     ??Mem_DynPoolCreateInternal_40: (+1)
   \      0x216   0x2104             MOVS     R1,#+4
   \                     ??Mem_DynPoolCreateInternal_41: (+1)
   \      0x218   0x9808             LDR      R0,[SP, #+32]
   \      0x21A   0x0880             LSRS     R0,R0,#+2
   \      0x21C   0x0080             LSLS     R0,R0,#+2
   \      0x21E   0x1809             ADDS     R1,R1,R0
   \      0x220   0xEB07 0x0B01      ADD      R11,R7,R1
   2001              }
   2002          
   2003              for (i = 1u; i < blk_qty_init; i++) {                       // Set next addresses to each blk.
   \                     ??Mem_DynPoolCreateInternal_39: (+1)
   \      0x224   0xF05F 0x0A01      MOVS     R10,#+1
   \                     ??Mem_DynPoolCreateInternal_42: (+1)
   \      0x228   0x9813             LDR      R0,[SP, #+76]
   \      0x22A   0x4582             CMP      R10,R0
   \      0x22C   0xD225             BCS.N    ??Mem_DynPoolCreateInternal_43
   2004                *((void **)blk_next_addr) = p_blks + blk_size_align;
   \      0x22E   0x9805             LDR      R0,[SP, #+20]
   \      0x230   0x4438             ADD      R0,R7,R0
   \      0x232   0xF8CB 0x0000      STR      R0,[R11, #+0]
   2005          
   2006                if (p_pool->AllocFnct != DEF_NULL) {
   \      0x236   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \      0x23A   0x2800             CMP      R0,#+0
   \      0x23C   0xD015             BEQ.N    ??Mem_DynPoolCreateInternal_44
   2007                  CPU_BOOLEAN alloc_ok;
   2008          
   2009                  alloc_ok = p_pool->AllocFnct(p_pool, p_seg, p_blks, p_pool->AllocFnctArg);
   \      0x23E   0xF8D8 0x3020      LDR      R3,[R8, #+32]
   \      0x242   0x003A             MOVS     R2,R7
   \      0x244   0x4649             MOV      R1,R9
   \      0x246   0x4640             MOV      R0,R8
   \      0x248   0xF8D8 0xC01C      LDR      R12,[R8, #+28]
   \      0x24C   0x47E0             BLX      R12
   2010                  if (alloc_ok != DEF_OK) {
   \      0x24E   0x0001             MOVS     R1,R0
   \      0x250   0xB2C9             UXTB     R1,R1
   \      0x252   0x2901             CMP      R1,#+1
   \      0x254   0xD009             BEQ.N    ??Mem_DynPoolCreateInternal_44
   2011                    RTOS_ERR_SET_AND_LOG_ERR(*p_err, RTOS_ERR_BLK_ALLOC_CALLBACK, ("lib_mem: failed to create ", (u)blk_qty_init, " initial blocks in pool ", (s)p_name, "due to error in callback."));
   \      0x256   0x211A             MOVS     R1,#+26
   \      0x258   0x7031             STRB     R1,[R6, #+0]
   \      0x25A   0x....             LDR.N    R1,??DataTable18_13
   \      0x25C   0x6071             STR      R1,[R6, #+4]
   \      0x25E   0xF240 0x71DB      MOVW     R1,#+2011
   \      0x262   0x60B1             STR      R1,[R6, #+8]
   \      0x264   0x....             LDR.N    R1,??DataTable18_14
   \      0x266   0x60F1             STR      R1,[R6, #+12]
   2012                    return;
   \      0x268   0xE03E             B.N      ??Mem_DynPoolCreateInternal_36
   2013                  }
   2014                }
   2015          
   2016                blk_next_addr += blk_size_align;
   \                     ??Mem_DynPoolCreateInternal_44: (+1)
   \      0x26A   0x9805             LDR      R0,[SP, #+20]
   \      0x26C   0xEB10 0x0B0B      ADDS     R11,R0,R11
   2017                p_blks += blk_size_align;
   \      0x270   0x9805             LDR      R0,[SP, #+20]
   \      0x272   0x4407             ADD      R7,R7,R0
   2018              }
   \      0x274   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x278   0xE7D6             B.N      ??Mem_DynPoolCreateInternal_42
   2019          
   2020              *((void **)blk_next_addr) = DEF_NULL;
   \                     ??Mem_DynPoolCreateInternal_43: (+1)
   \      0x27A   0x2000             MOVS     R0,#+0
   \      0x27C   0xF8CB 0x0000      STR      R0,[R11, #+0]
   2021          
   2022              if (p_pool->AllocFnct != DEF_NULL) {
   \      0x280   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \      0x284   0x2800             CMP      R0,#+0
   \      0x286   0xD018             BEQ.N    ??Mem_DynPoolCreateInternal_45
   2023                CPU_BOOLEAN alloc_ok;
   2024          
   2025                alloc_ok = p_pool->AllocFnct(p_pool, p_seg, p_blks, p_pool->AllocFnctArg);
   \      0x288   0xF8D8 0x3020      LDR      R3,[R8, #+32]
   \      0x28C   0x003A             MOVS     R2,R7
   \      0x28E   0x4649             MOV      R1,R9
   \      0x290   0x4640             MOV      R0,R8
   \      0x292   0xF8D8 0xC01C      LDR      R12,[R8, #+28]
   \      0x296   0x47E0             BLX      R12
   2026                if (alloc_ok != DEF_OK) {
   \      0x298   0x0001             MOVS     R1,R0
   \      0x29A   0xB2C9             UXTB     R1,R1
   \      0x29C   0x2901             CMP      R1,#+1
   \      0x29E   0xD00C             BEQ.N    ??Mem_DynPoolCreateInternal_45
   2027                  RTOS_ERR_SET_AND_LOG_ERR(*p_err, RTOS_ERR_BLK_ALLOC_CALLBACK, ("lib_mem: failed to create ", (u)blk_qty_init, " initial blocks in pool ", (s)p_name, "due to error in callback."));
   \      0x2A0   0x211A             MOVS     R1,#+26
   \      0x2A2   0x7031             STRB     R1,[R6, #+0]
   \      0x2A4   0x....             LDR.N    R1,??DataTable18_13
   \      0x2A6   0x6071             STR      R1,[R6, #+4]
   \      0x2A8   0xF240 0x71EB      MOVW     R1,#+2027
   \      0x2AC   0x60B1             STR      R1,[R6, #+8]
   \      0x2AE   0x....             LDR.N    R1,??DataTable18_14
   \      0x2B0   0x60F1             STR      R1,[R6, #+12]
   2028                  return;
   \      0x2B2   0xE019             B.N      ??Mem_DynPoolCreateInternal_36
   2029                }
   2030              }
   2031            } else {
   2032              p_pool->BlkFreePtr = DEF_NULL;
   \                     ??Mem_DynPoolCreateInternal_22: (+1)
   \      0x2B4   0x2000             MOVS     R0,#+0
   \      0x2B6   0xF8C8 0x0010      STR      R0,[R8, #+16]
   2033            }
   2034          
   2035            //                                                               ----------------- CREATE POOL DATA -----------------
   2036            p_pool->PoolSegPtr = p_seg;
   \                     ??Mem_DynPoolCreateInternal_45: (+1)
   \      0x2BA   0xF8C8 0x9004      STR      R9,[R8, #+4]
   2037            p_pool->BlkSize = blk_size_real;
   \      0x2BE   0x9804             LDR      R0,[SP, #+16]
   \      0x2C0   0xF8C8 0x0008      STR      R0,[R8, #+8]
   2038            p_pool->BlkAlign = blk_align_real;
   \      0x2C4   0x9806             LDR      R0,[SP, #+24]
   \      0x2C6   0xF8C8 0x000C      STR      R0,[R8, #+12]
   2039            p_pool->BlkQtyMax = blk_qty_max;
   \      0x2CA   0x9814             LDR      R0,[SP, #+80]
   \      0x2CC   0xF8C8 0x0014      STR      R0,[R8, #+20]
   2040            p_pool->BlkAllocCnt = 0u;
   \      0x2D0   0x2000             MOVS     R0,#+0
   \      0x2D2   0xF8C8 0x0018      STR      R0,[R8, #+24]
   2041          
   2042          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2043            p_pool->NamePtr = p_name;
   2044          #endif
   2045          
   2046            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x2D6   0x2000             MOVS     R0,#+0
   \      0x2D8   0x7030             STRB     R0,[R6, #+0]
   \      0x2DA   0x....             LDR.N    R0,??DataTable18_13
   \      0x2DC   0x6070             STR      R0,[R6, #+4]
   \      0x2DE   0xF240 0x70FE      MOVW     R0,#+2046
   \      0x2E2   0x60B0             STR      R0,[R6, #+8]
   \      0x2E4   0x....             LDR.N    R0,??DataTable18_14
   \      0x2E6   0x60F0             STR      R0,[R6, #+12]
   2047          
   2048          #if LOG_VRB_IS_EN()
   2049            if (p_name == DEF_NULL) {
   2050              LOG_VRB(("Dyn pool created successfully."));
   2051            } else {
   2052              LOG_VRB(("Dyn pool \"", (s)p_name, "\" created successfully."));
   2053            }
   2054          #endif
   2055          }
   \                     ??Mem_DynPoolCreateInternal_36: (+1)
   \      0x2E8   0xB009             ADD      SP,SP,#+36
   \      0x2EA   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     Mem_SegHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x....'....        DC32     `Mem_SegCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x....'....        DC32     `Mem_SegReg::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x....'....        DC32     Mem_SegHeadPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x....'....        DC32     `Mem_SegClr::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \        0x0   0x....'....        DC32     `Mem_SegRemSizeGet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \        0x0   0x....'....        DC32     Mem_SegHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \        0x0   0x....'....        DC32     `Mem_DynPoolCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \        0x0   0x....'....        DC32     `Mem_DynPoolCreatePersistent::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \        0x0   0x....'....        DC32     `Mem_DynPoolCreateHW::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \        0x0   0x....'....        DC32     `Mem_DynPoolBlkGet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \        0x0   0x....'....        DC32     `Mem_DynPoolBlkFree::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \        0x0   0x....'....        DC32     `Mem_DynPoolBlkNbrAvailGet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \        0x0   0x....'....        DC32     `Mem_SegAllocInternal::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \        0x0   0x....'....        DC32     `Mem_SegAllocExtCritical::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \        0x0   0x....'....        DC32     `Mem_DynPoolCreateInternal::__func__`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x63, 0x6F, 0x6D, 0x6D, 0x6F
   \              0x5C 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x6F
   \       0x58   0x6E 0x5C          DC8 0x6E, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65
   \       0x60   0x5C 0x6C          DC8 0x5C, 0x6C, 0x69, 0x62, 0x5C, 0x6C, 0x69, 0x62
   \              0x69 0x62    
   \              0x5C 0x6C    
   \              0x69 0x62
   \       0x68   0x5F 0x6D          DC8 0x5F, 0x6D, 0x65, 0x6D, 0x2E, 0x63, 0
   \              0x65 0x6D    
   \              0x2E 0x63    
   \              0x00
   \       0x6F                      DS8 1

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Mem_Clr
        16   -> Mem_Set
      40   Mem_Cmp
      36   Mem_Copy
      32   Mem_DynPoolBlkFree
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> CPU_SW_Exception
      48   Mem_DynPoolBlkGet
        48   -- Indirect call
        48   -> CORE_EnterAtomic
        48   -> CORE_ExitAtomic
        48   -> CPU_SW_Exception
        48   -> Mem_SegAllocInternal
      32   Mem_DynPoolBlkNbrAvailGet
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> CPU_SW_Exception
      48   Mem_DynPoolCreate
        48   -> CPU_SW_Exception
        48   -> Mem_DynPoolCreateInternal
      48   Mem_DynPoolCreateHW
        48   -> CPU_SW_Exception
        48   -> Mem_DynPoolCreateInternal
      72   Mem_DynPoolCreateInternal
        72   -- Indirect call
        72   -> Mem_SegAllocInternal
      56   Mem_DynPoolCreatePersistent
        56   -> CPU_SW_Exception
        56   -> Mem_DynPoolCreateInternal
      24   Mem_Init
        24   -> CPU_SW_Exception
        24   -> Mem_SegReg
      48   Mem_Move
        48   -> Mem_Copy
      40   Mem_SegAlloc
        40   -> CPU_SW_Exception
        40   -> Mem_SegAllocInternal
      40   Mem_SegAllocExt
        40   -> CPU_SW_Exception
        40   -> Mem_SegAllocInternal
      28   Mem_SegAllocExtCritical
      40   Mem_SegAllocHW
        40   -> CPU_SW_Exception
        40   -> Mem_SegAllocInternal
      48   Mem_SegAllocInternal
        48   -> CORE_EnterAtomic
        48   -> CORE_ExitAtomic
        48   -> Mem_SegAllocExtCritical
      16   Mem_SegClr
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> CPU_SW_Exception
      40   Mem_SegCreate
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> CPU_SW_Exception
        40   -> Mem_SegCreateCritical
        40   -> Mem_SegOverlapChkCritical
      12   Mem_SegCreateCritical
      16   Mem_SegOverlapChkCritical
      24   Mem_SegReg
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CPU_SW_Exception
      40   Mem_SegRemSizeGet
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> CPU_SW_Exception
      20   Mem_Set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
     112  ?_0
      18  Mem_Clr
     254  Mem_Cmp
     166  Mem_Copy
     204  Mem_DynPoolBlkFree
     332  Mem_DynPoolBlkGet
     204  Mem_DynPoolBlkNbrAvailGet
     108  Mem_DynPoolCreate
     108  Mem_DynPoolCreateHW
     750  Mem_DynPoolCreateInternal
     116  Mem_DynPoolCreatePersistent
   9'216  Mem_Heap
      28  Mem_Init
     204  Mem_Move
      60  Mem_SegAlloc
      60  Mem_SegAllocExt
     198  Mem_SegAllocExtCritical
      60  Mem_SegAllocHW
     204  Mem_SegAllocInternal
      82  Mem_SegClr
     278  Mem_SegCreate
      40  Mem_SegCreateCritical
       4  Mem_SegHeadPtr
      20  Mem_SegHeap
      82  Mem_SegOverlapChkCritical
     132  Mem_SegReg
     224  Mem_SegRemSizeGet
     104  Mem_Set
     272  -- Other

 
 9'220 bytes in section .bss
    20 bytes in section .data
   384 bytes in section .rodata
 4'088 bytes in section .text
 
 3'342 bytes of CODE  memory (+ 746 bytes shared)
   384 bytes of CONST memory
 9'240 bytes of DATA  memory

Errors: none
Warnings: none
