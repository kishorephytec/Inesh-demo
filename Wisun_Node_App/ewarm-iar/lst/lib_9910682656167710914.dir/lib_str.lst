###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:29
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\lib\lib_str.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\lib_9910682656167710914.dir\lib_str.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\lib\lib_str.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\lib_9910682656167710914.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\lib_9910682656167710914.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\lib\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\lib_9910682656167710914.dir\lib_str.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\lib_9910682656167710914.dir\lib_str.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\lib_9910682656167710914.dir\lib_str.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\lib\lib_str.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Common - Ascii String Management
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /****************************************************************************************************//**
     19           * @note     (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given us
     20           *               permission to reprint portions of their documentation. Portions of this text are
     21           *               reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
     22           *               Standard for Information Technology -- Portable Operating System Interface (POSIX), The
     23           *               Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of
     24           *               Electrical and Electronics Engineers, Inc and The Open Group. In the event of any
     25           *               discrepancy between these versions and the original IEEE and The Open Group Standard, the
     26           *               original IEEE and The Open Group Standard is the referee document. The original Standard
     27           *               can be obtained online at http://www.opengroup.org/unix/online.html.
     28           *******************************************************************************************************/
     29          
     30          /********************************************************************************************************
     31           ********************************************************************************************************
     32           *                                               INCLUDE FILES
     33           *
     34           * Note(s) : (1) The file 'stdarg.h' is included ONLY for the use of variable arguments definitions such
     35           *               as va_start, va_list and va_end. It is included in a .c file in order to minimize chances
     36           *               of clashes with part of the software. Nothing else from this file should be used.
     37           ********************************************************************************************************
     38           *******************************************************************************************************/
     39          
     40          #include  <common/include/lib_str.h>
     41          #include  <common/include/lib_utils.h>
     42          #include  <common/source/lib/lib_str_priv.h>
     43          //                                                                 See Note #1.
     44          #include  <stdarg.h>
     45          
     46          /********************************************************************************************************
     47           ********************************************************************************************************
     48           *                                               DATA TYPES
     49           ********************************************************************************************************
     50           *******************************************************************************************************/
     51          
     52          typedef struct str_sprintf_cb_arg {
     53            CPU_CHAR   *BufPtr;
     54            CPU_SIZE_T CurIx;
     55          } STR_SPRINTF_CB_ARG;
     56          
     57          /********************************************************************************************************
     58           ********************************************************************************************************
     59           *                                               LOCAL TABLES
     60           ********************************************************************************************************
     61           *******************************************************************************************************/
     62          

   \                                 In section .rodata, align 4
     63          static const CPU_INT32U Str_MultOvfThTbl_Int32U[] = {
   \                     Str_MultOvfThTbl_Int32U:
   \        0x0   0xFFFF'FFFF        DC32 4'294'967'295, 4'294'967'295, 2'147'483'647, 1'431'655'765
   \              0xFFFF'FFFF  
   \              0x7FFF'FFFF  
   \              0x5555'5555
   \       0x10   0x3FFF'FFFF        DC32 1'073'741'823, 858'993'459, 715'827'882, 613'566'756, 536'870'911
   \              0x3333'3333  
   \              0x2AAA'AAAA  
   \              0x2492'4924  
   \              0x1FFF'FFFF
   \       0x24   0x1C71'C71C        DC32 477'218'588, 429'496'729, 390'451'572, 357'913'941, 330'382'099
   \              0x1999'9999  
   \              0x1745'D174  
   \              0x1555'5555  
   \              0x13B1'3B13
   \       0x38   0x1249'2492        DC32 306'783'378, 286'331'153, 268'435'455, 252'645'135, 238'609'294
   \              0x1111'1111  
   \              0x0FFF'FFFF  
   \              0x0F0F'0F0F  
   \              0x0E38'E38E
   \       0x4C   0x0D79'435E        DC32 226'050'910, 214'748'364, 204'522'252, 195'225'786, 186'737'708
   \              0x0CCC'CCCC  
   \              0x0C30'C30C  
   \              0x0BA2'E8BA  
   \              0x0B21'642C
   \       0x60   0x0AAA'AAAA        DC32 178'956'970, 171'798'691, 165'191'049, 159'072'862, 153'391'689
   \              0x0A3D'70A3  
   \              0x09D8'9D89  
   \              0x097B'425E  
   \              0x0924'9249
   \       0x74   0x08D3'DCB0        DC32 148'102'320, 143'165'576, 138'547'332, 134'217'727, 130'150'524
   \              0x0888'8888  
   \              0x0842'1084  
   \              0x07FF'FFFF  
   \              0x07C1'F07C
   \       0x88   0x0787'8787        DC32 126'322'567, 122'713'351, 119'304'647
   \              0x0750'7507  
   \              0x071C'71C7
     64            (CPU_INT32U) DEF_INT_32U_MAX_VAL,                             // Invalid base  0.
     65            (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1u),                      // Invalid base  1.
     66            (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2u),                      // 32-bit mult ovf th for base  2.
     67            (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3u),                      // 32-bit mult ovf th for base  3.
     68            (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4u),                      // 32-bit mult ovf th for base  4.
     69            (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5u),                      // 32-bit mult ovf th for base  5.
     70            (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6u),                      // 32-bit mult ovf th for base  6.
     71            (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7u),                      // 32-bit mult ovf th for base  7.
     72            (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8u),                      // 32-bit mult ovf th for base  8.
     73            (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9u),                      // 32-bit mult ovf th for base  9.
     74            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10u),                      // 32-bit mult ovf th for base 10.
     75            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11u),                      // 32-bit mult ovf th for base 11.
     76            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12u),                      // 32-bit mult ovf th for base 12.
     77            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13u),                      // 32-bit mult ovf th for base 13.
     78            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14u),                      // 32-bit mult ovf th for base 14.
     79            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15u),                      // 32-bit mult ovf th for base 15.
     80            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16u),                      // 32-bit mult ovf th for base 16.
     81            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17u),                      // 32-bit mult ovf th for base 17.
     82            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18u),                      // 32-bit mult ovf th for base 18.
     83            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19u),                      // 32-bit mult ovf th for base 19.
     84            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20u),                      // 32-bit mult ovf th for base 20.
     85            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21u),                      // 32-bit mult ovf th for base 21.
     86            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22u),                      // 32-bit mult ovf th for base 22.
     87            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23u),                      // 32-bit mult ovf th for base 23.
     88            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24u),                      // 32-bit mult ovf th for base 24.
     89            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25u),                      // 32-bit mult ovf th for base 25.
     90            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26u),                      // 32-bit mult ovf th for base 26.
     91            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27u),                      // 32-bit mult ovf th for base 27.
     92            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28u),                      // 32-bit mult ovf th for base 28.
     93            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29u),                      // 32-bit mult ovf th for base 29.
     94            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30u),                      // 32-bit mult ovf th for base 30.
     95            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31u),                      // 32-bit mult ovf th for base 31.
     96            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32u),                      // 32-bit mult ovf th for base 32.
     97            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33u),                      // 32-bit mult ovf th for base 33.
     98            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34u),                      // 32-bit mult ovf th for base 34.
     99            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35u),                      // 32-bit mult ovf th for base 35.
    100            (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36u)                       // 32-bit mult ovf th for base 36.
    101          };
    102          
    103          /********************************************************************************************************
    104           ********************************************************************************************************
    105           *                                       LOCAL FUNCTION PROTOTYPES
    106           ********************************************************************************************************
    107           *******************************************************************************************************/
    108          
    109          static CPU_CHAR *Str_FmtNbr_Int32(CPU_INT32U  nbr,
    110                                            CPU_INT08U  nbr_dig,
    111                                            CPU_INT08U  nbr_base,
    112                                            CPU_BOOLEAN nbr_neg,
    113                                            CPU_CHAR    lead_char,
    114                                            CPU_BOOLEAN lower_case,
    115                                            CPU_BOOLEAN nul,
    116                                            CPU_CHAR    *p_str);
    117          
    118          static CPU_INT32U Str_ParseNbr_Int32(const CPU_CHAR *p_str,
    119                                               CPU_CHAR       **p_str_next,
    120                                               CPU_INT08U     nbr_base,
    121                                               CPU_BOOLEAN    nbr_signed,
    122                                               CPU_BOOLEAN    *p_nbr_neg);
    123          
    124          static CPU_SIZE_T Str_FmtOutput(CPU_CHAR          *p_str,
    125                                          CPU_SIZE_T        min_char_cnt,
    126                                          CPU_SIZE_T        max_char_cnt,
    127                                          CPU_BOOLEAN       left_justify,
    128                                          STR_PRINTF_OUT_CB out_cb,
    129                                          void              *p_out_cb_arg,
    130                                          CPU_INT32S        rem_size);
    131          
    132          static CPU_SIZE_T Str_UnsgnIntFmtOutput(CPU_INT64U        nbr,
    133                                                  CPU_INT08U        base,
    134                                                  CPU_SIZE_T        min_digit_cnt,
    135                                                  CPU_BOOLEAN       left_justify,
    136                                                  CPU_CHAR          pad_char,
    137                                                  STR_PRINTF_OUT_CB out_cb,
    138                                                  void              *p_out_cb_arg,
    139                                                  CPU_INT32S        rem_size);
    140          
    141          static CPU_SIZE_T Str_SngIntFmtOutput(CPU_INT64S        nbr,
    142                                                CPU_SIZE_T        min_digit_cnt,
    143                                                CPU_BOOLEAN       left_justify,
    144                                                CPU_CHAR          pad_char,
    145                                                STR_PRINTF_OUT_CB out_cb,
    146                                                void              *p_out_cb_arg,
    147                                                CPU_INT32S        rem_size);
    148          
    149          static CPU_INT16U Str_PrintfImpl(STR_PRINTF_OUT_CB out_cb,
    150                                           void              *p_out_cb_arg,
    151                                           CPU_INT16U        max_char_cnt,
    152                                           const CPU_CHAR    *format,
    153                                           va_list           argp);
    154          
    155          static int Str_SprintfCb(int  c,
    156                                   void *p_arg);
    157          
    158          /********************************************************************************************************
    159           ********************************************************************************************************
    160           *                                           GLOBAL FUNCTIONS
    161           ********************************************************************************************************
    162           *******************************************************************************************************/
    163          
    164          /****************************************************************************************************//**
    165           *                                                   Str_Len()
    166           *
    167           * @brief    Calculates the length of a string.
    168           *
    169           * @param    p_str   Pointer to the string. This string is not modified.
    170           *
    171           * @return   Length of a string; number of characters in a string before the terminating NULL
    172           *           character.
    173           *
    174           * @note     (1) See notes for Str_Len_N().
    175           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    176          CPU_SIZE_T Str_Len(const CPU_CHAR *p_str)
    177          {
   \                     Str_Len: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    178            CPU_SIZE_T len;
    179          
    180            len = Str_Len_N(p_str,
    181                            DEF_INT_CPU_U_MAX_VAL);
   \        0x4   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       Str_Len_N
    182          
    183            return (len);
   \        0xE   0xBD10             POP      {R4,PC}
    184          }
    185          
    186          /****************************************************************************************************//**
    187           *                                               Str_Len_N()
    188           *
    189           * @brief    Calculates the length of a string, up to a maximum number of characters.
    190           *
    191           * @param    p_str       Pointer to the string. This string is not modified.
    192           *
    193           * @param    len_max     Maximum number of characters to search. Does NOT include the terminating NULL
    194           *                       character.
    195           *
    196           * @return   Length of string; number of characters in string before terminating NULL character, if
    197           *           terminating NULL character found.
    198           *           Requested maximum number of characters to search, if terminating NULL character NOT
    199           *           found.
    200           *
    201           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
    202           *               "The strlen() function shall compute the number of bytes in the string to which 's'
    203           *               ('p_str') points, [...] not including the terminating null byte."
    204           *
    205           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
    206           *               "The strlen() function shall return the length of 's' ('p_str'); [and that] no return
    207           *               value shall be reserved to indicate an error."
    208           *
    209           * @note     (3) String length calculation terminates when :
    210           *               - (a) String pointer points to NULL.
    211           *               - (b) Terminating NULL character found.
    212           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    213          CPU_SIZE_T Str_Len_N(const CPU_CHAR *p_str,
    214                               CPU_SIZE_T     len_max)
    215          {
   \                     Str_Len_N: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0004             MOVS     R4,R0
    216            const CPU_CHAR *p_str_len;
    217            CPU_SIZE_T     len;
    218          
    219            p_str_len = p_str;
   \        0x4   0x0022             MOVS     R2,R4
    220            len = 0u;
   \        0x6   0x2000             MOVS     R0,#+0
    221            while ((p_str_len != DEF_NULL)                                // Calc str len until NULL ptr (see Note #3a) ...
    222                   && (*p_str_len != (CPU_CHAR)'\0')                      // ... or NULL char found      (see Note #3b) ...
    223                   && (len < (CPU_SIZE_T)len_max)) {                      // ... or max nbr chars srch'd.
   \                     ??Str_Len_N_0: (+1)
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD007             BEQ.N    ??Str_Len_N_1
   \        0xC   0x7813             LDRB     R3,[R2, #+0]
   \        0xE   0x2B00             CMP      R3,#+0
   \       0x10   0xD004             BEQ.N    ??Str_Len_N_1
   \       0x12   0x4288             CMP      R0,R1
   \       0x14   0xD202             BCS.N    ??Str_Len_N_1
    224              p_str_len++;
   \       0x16   0x1C52             ADDS     R2,R2,#+1
    225              len++;
   \       0x18   0x1C40             ADDS     R0,R0,#+1
   \       0x1A   0xE7F5             B.N      ??Str_Len_N_0
    226            }
    227          
    228            return (len);
   \                     ??Str_Len_N_1: (+1)
   \       0x1C   0xBC10             POP      {R4}
   \       0x1E   0x4770             BX       LR
    229          }
    230          
    231          /****************************************************************************************************//**
    232           *                                               Str_Copy()
    233           *
    234           * @brief    Copies the source string to destination string buffer.
    235           *
    236           * @param    p_str_dest  Pointer to the destination string buffer to receive source string copy.
    237           *                       Destination buffer size is NOT validated; buffer overruns MUST be prevented
    238           *                       by caller. Destination buffer size MUST be large enough to accommodate the
    239           *                       entire source string size including the terminating NULL character.
    240           *
    241           * @param    p_str_src   Pointer to the source string to copy into destination string buffer. This
    242           *                       string is not modified.
    243           *
    244           * @return   Pointer to the destination string, if NO error(s).
    245           *           Pointer to NULL, otherwise (see Note #2).
    246           *
    247           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that :
    248           *               "The strcpy() function shall copy the string pointed to by 's2' ('p_str_src') [...]
    249           *               into the array pointed to by 's1' ('p_str_dest') [...] (including the terminating
    250           *               null byte)."
    251           *
    252           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : RETURN VALUE' states that :
    253           *               "The strcpy() function shall return 's1' ('p_str_dest'); [and that] no return value
    254           *               is reserved to indicate an error."
    255           *               This requirement is intentionally NOT implemented in order to return NULL for any
    256           *               error(s).
    257           *
    258           * @note     (3) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that:
    259           *               "if copying takes place between objects that overlap, the behavior is undefined".
    260           *
    261           * @note     (4) String copy terminates when :
    262           *               - (a) Destination/Source string pointer(s) are passed as NULL pointers. No string copy
    263           *                     performed; NULL pointer is returned.
    264           *               - (b) Destination/Source string pointer(s) point to NULL. String buffer(s) overlap with
    265           *                     NULL address; NULL pointer is returned.
    266           *               - (c) Source string's terminating NULL character found. Entire source string copied
    267           *                     into destination string buffer.
    268           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    269          CPU_CHAR *Str_Copy(CPU_CHAR       *p_str_dest,
    270                             const CPU_CHAR *p_str_src)
    271          {
   \                     Str_Copy: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    272            CPU_CHAR *p_str_rtn;
    273          
    274            p_str_rtn = Str_Copy_N(p_str_dest,
    275                                   p_str_src,
    276                                   DEF_INT_CPU_U_MAX_VAL);
   \        0x6   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       Str_Copy_N
    277          
    278            return (p_str_rtn);
   \       0x12   0xBD32             POP      {R1,R4,R5,PC}
    279          }
    280          
    281          /****************************************************************************************************//**
    282           *                                               Str_Copy_N()
    283           *
    284           * @brief    Copies the source string to the destination string buffer, up to a maximum number of
    285           *           characters.
    286           *
    287           * @param    p_str_dest  Pointer to the destination string buffer to receive source string copy.
    288           *                       Destination buffer size is NOT validated; buffer overruns MUST be prevented
    289           *                       by caller. Destination buffer size MUST be large enough to accommodate the
    290           *                       entire source string size including the terminating NULL character.
    291           *
    292           * @param    p_str_src   Pointer to the source string to copy into destination string buffer. This
    293           *                       string is not modified.
    294           *
    295           * @param    len_max     Maximum number of characters to copy. 'len_max' number of characters MAY
    296           *                       include the terminating NULL character. Zero-length copies allowed.
    297           *
    298           * @return   Pointer to destination string, if NO error(s).
    299           *           Pointer to NULL, otherwise.
    300           *
    301           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
    302           *               "The strncpy() function shall copy [...] the array pointed to by 's2' ('p_str_src')
    303           *               to the array pointed to by 's1' ('p_str_dest') [...] but "not more than 'n'
    304           *               ('len_max') bytes [...] & (bytes that follow a null byte are not copied)".
    305           *
    306           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
    307           *               "if the array pointed to by 's2' ('p_str_src') is a string that is shorter than 'n'
    308           *               ('len_max') bytes, null bytes shall be appended to the copy in the array pointed to
    309           *               by 's1' ('p_str_dest'), until 'n' ('len_max') bytes in all are written."
    310           *               Since Str_Copy() limits the maximum number of characters to copy via Str_Copy_N() by
    311           *               the CPU's maximum number of addressable characters, this requirement is intentionally
    312           *               NOT implemented to avoid appending a potentially large number of unnecessary
    313           *               terminating NULL characters.
    314           *
    315           * @note     (3) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : APPLICATION USAGE' states that :
    316           *               "if there is no null byte in the first 'n' ('len_max') bytes of the array pointed to
    317           *               by 's2' ('p_str_src'), the result is not null-terminated".
    318           *
    319           * @note     (4) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : RETURN VALUE' states that :
    320           *               "The strncpy() function shall return 's1' ('p_str_dest'); [...] no return value is
    321           *               reserved to indicate an error."
    322           *               This requirement is intentionally ignored in order to return NULL for any error(s).
    323           *
    324           * @note     (5) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
    325           *               "if copying takes place between objects that overlap, the behavior is undefined".
    326           *
    327           * @note     (6) String copy terminates when :
    328           *               - (a) Destination/Source string pointer(s) are passed as NULL pointers. No string copy
    329           *                     performed; NULL pointer is returned.
    330           *               - (b) Destination/Source string pointer(s) point to NULL. String buffer(s) overlap with
    331           *                     NULL address; NULL pointer is returned.
    332           *               - (c) Source string's terminating NULL character found. Entire source string copied
    333           *                     into destination string buffer.
    334           *               - (d) 'len_max' number of characters copied.
    335           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    336          CPU_CHAR *Str_Copy_N(CPU_CHAR       *p_str_dest,
    337                               const CPU_CHAR *p_str_src,
    338                               CPU_SIZE_T     len_max)
    339          {
   \                     Str_Copy_N: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000B             MOVS     R3,R1
   \        0x6   0x0015             MOVS     R5,R2
    340            CPU_CHAR       *p_str_copy_dest;
    341            const CPU_CHAR *p_str_copy_src;
    342            CPU_SIZE_T     len_copy;
    343          
    344            //                                                               Rtn NULL if str ptr(s) NULL (see Note #6a).
    345            if (p_str_dest == DEF_NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??Str_Copy_N_0
    346              return (DEF_NULL);
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE020             B.N      ??Str_Copy_N_1
    347            }
    348            if (p_str_src == DEF_NULL) {
   \                     ??Str_Copy_N_0: (+1)
   \       0x10   0x2B00             CMP      R3,#+0
   \       0x12   0xD101             BNE.N    ??Str_Copy_N_2
    349              return (DEF_NULL);
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE01C             B.N      ??Str_Copy_N_1
    350            }
    351          
    352            p_str_copy_dest = p_str_dest;
   \                     ??Str_Copy_N_2: (+1)
   \       0x18   0x0021             MOVS     R1,R4
    353            p_str_copy_src = p_str_src;
   \       0x1A   0x001A             MOVS     R2,R3
    354            len_copy = 0u;
   \       0x1C   0x2600             MOVS     R6,#+0
    355          
    356            while ((p_str_copy_dest != DEF_NULL)                          // Copy str until NULL ptr(s) (see Note #6b) ...
    357                   && (p_str_copy_src != DEF_NULL)
    358                   && (*p_str_copy_src != (CPU_CHAR)'\0')                 // ... or NULL char found (see Note #6c); ...
    359                   && (len_copy < len_max)) {                             // ... or max nbr chars copied (see Note #6d).
   \                     ??Str_Copy_N_3: (+1)
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD00C             BEQ.N    ??Str_Copy_N_4
   \       0x22   0x2A00             CMP      R2,#+0
   \       0x24   0xD00A             BEQ.N    ??Str_Copy_N_4
   \       0x26   0x7810             LDRB     R0,[R2, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD007             BEQ.N    ??Str_Copy_N_4
   \       0x2C   0x42AE             CMP      R6,R5
   \       0x2E   0xD205             BCS.N    ??Str_Copy_N_4
    360              *p_str_copy_dest = *p_str_copy_src;
   \       0x30   0x7810             LDRB     R0,[R2, #+0]
   \       0x32   0x7008             STRB     R0,[R1, #+0]
    361              p_str_copy_dest++;
   \       0x34   0x1C49             ADDS     R1,R1,#+1
    362              p_str_copy_src++;
   \       0x36   0x1C52             ADDS     R2,R2,#+1
    363              len_copy++;
   \       0x38   0x1C76             ADDS     R6,R6,#+1
   \       0x3A   0xE7F0             B.N      ??Str_Copy_N_3
    364            }
    365          
    366            //                                                               Rtn NULL if NULL ptr(s) found (see Note #6b).
    367            if ((p_str_copy_dest == DEF_NULL)
    368                || (p_str_copy_src == DEF_NULL)) {
   \                     ??Str_Copy_N_4: (+1)
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD001             BEQ.N    ??Str_Copy_N_5
   \       0x40   0x2A00             CMP      R2,#+0
   \       0x42   0xD101             BNE.N    ??Str_Copy_N_6
    369              return (DEF_NULL);
   \                     ??Str_Copy_N_5: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xE004             B.N      ??Str_Copy_N_1
    370            }
    371          
    372            if (len_copy < len_max) {                                     // If copy str len < max buf len (see Note #2), ...
   \                     ??Str_Copy_N_6: (+1)
   \       0x48   0x42AE             CMP      R6,R5
   \       0x4A   0xD201             BCS.N    ??Str_Copy_N_7
    373              *p_str_copy_dest = (CPU_CHAR)'\0';                          // ... copy NULL char (see Note #6c).
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x7008             STRB     R0,[R1, #+0]
    374            }
    375          
    376            return (p_str_dest);
   \                     ??Str_Copy_N_7: (+1)
   \       0x50   0x0020             MOVS     R0,R4
   \                     ??Str_Copy_N_1: (+1)
   \       0x52   0xBC70             POP      {R4-R6}
   \       0x54   0x4770             BX       LR
    377          }
    378          
    379          /****************************************************************************************************//**
    380           *                                                   Str_Cat()
    381           *
    382           * @brief    Appends the concatenation string to the destination string.
    383           *
    384           * @param    p_str_dest  Pointer to the destination string to append concatenation string. Destination
    385           *                       buffer size is NOT validated; buffer overruns MUST be prevented by caller.
    386           *                       Destination buffer size MUST be large enough to accommodate the entire
    387           *                       concatenated string size including the terminating NULL character.
    388           *
    389           * @param    p_str_cat   Pointer to the concatenation string to append to destination string.
    390           *                       Concatenation string buffer NOT modified.
    391           *
    392           * @return   Pointer to the destination string, if NO error(s).
    393           *           Pointer to NULL, otherwise (see Note #2).
    394           *
    395           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
    396           *               "The strcat() function shall append a copy of the string pointed to by 's2'
    397           *               ('p_str_cat') [...] to the end of the string pointed to by 's1' ('p_str_dest')."
    398           *               "The initial byte of 's2' ('p_str_cat') overwrites the null byte at the end of 's1'
    399           *               ('p_str_dest'). [...] A "terminating null byte" is appended at the end of the
    400           *               concatenated destination strings.
    401           *
    402           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : RETURN VALUE' states that :
    403           *               "The strcat() function shall return 's1' ('p_str_dest'); [and that] no return value
    404           *               shall be reserved to indicate an error."
    405           *               This requirement is intentionally NOT implemented in order to return NULL for any
    406           *               error(s).
    407           *
    408           * @note     (3) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
    409           *               "if copying takes place between objects that overlap, the behavior is undefined."
    410           *
    411           * @note     (4) String concatenation terminates when :
    412           *               - (a) Destination/Concatenation string pointer(s) are passed as NULL pointers. No
    413           *                     string concatenation performed; NULL pointer is returned.
    414           *               - (b) Destination/Concatenation string pointer(s) point to NULL. String buffer(s)
    415           *                     overlap with NULL address; NULL pointer is returned.
    416           *               - (c) Concatenation string's terminating NULL character found. Entire concatenation
    417           *                     string appended to destination string.
    418           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    419          CPU_CHAR *Str_Cat(CPU_CHAR       *p_str_dest,
    420                            const CPU_CHAR *p_str_cat)
    421          {
   \                     Str_Cat: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    422            CPU_CHAR *p_str_rtn;
    423          
    424            p_str_rtn = Str_Cat_N(p_str_dest,
    425                                  p_str_cat,
    426                                  DEF_INT_CPU_U_MAX_VAL);
   \        0x6   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       Str_Cat_N
    427          
    428            return (p_str_rtn);
   \       0x12   0xBD32             POP      {R1,R4,R5,PC}
    429          }
    430          
    431          /****************************************************************************************************//**
    432           *                                               Str_Cat_N()
    433           *
    434           * @brief    Appends concatenation string to destination string, up to a maximum number of characters.
    435           *
    436           * @param    p_str_dest  Pointer to the destination string to append concatenation string. Destination
    437           *                       buffer size is NOT validated; buffer overruns MUST be prevented by caller.
    438           *                       Destination buffer size MUST be large enough to accommodate the entire
    439           *                       concatenated string size including the terminating NULL character.
    440           *
    441           * @param    p_str_cat   Pointer to the concatenation string to append to destination string.
    442           *                       Concatenation string buffer NOT modified.
    443           *
    444           * @param    len_max     Maximum number of characters to concatenate. 'len_max' number of characters
    445           *                       does NOT include the terminating NULL character. Zero-length concatenations
    446           *                       allowed.
    447           *
    448           * @return   Pointer to the destination string, if NO error(s).
    449           *           Pointer to NULL, otherwise (see Note #2).
    450           *
    451           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
    452           *               "The strncat() function shall append [...] the array pointed to by 's2' ('p_str_cat')
    453           *               to the end of the string pointed to by 's1' ('p_str_dest') [...] but not more than
    454           *               'n' ('len_max') bytes".
    455           *               "The initial byte of 's2' ('p_str_cat') overwrites the null byte at the end of 's1'
    456           *               ('p_str_dest'). [...] (a null byte and bytes that follow it are not appended). [...]
    457           *               A terminating null byte is always appended to the result."
    458           *
    459           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : RETURN VALUE' states that :
    460           *               "The strncat() function shall return 's1' ('p_str_dest'); [and that]  no return value
    461           *               shall be reserved to indicate an error."
    462           *               This requirement is intentionally NOT implemented in order to return NULL for any
    463           *               error(s).
    464           *
    465           * @note     (3) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
    466           *               "if copying takes place between objects that overlap, the behavior is undefined."
    467           *
    468           * @note     (4) String concatenation terminates when :
    469           *               - (a) Destination/Concatenation string pointer(s) are passed as NULL pointers. No
    470           *                     string concatenation performed; NULL pointer is returned.
    471           *               - (b) Destination/Concatenation string pointer(s) point to NULL. String buffer(s)
    472           *                     overlap with NULL address; NULL pointer is returned.
    473           *               - (c) Concatenation string's terminating NULL character found. Entire concatenation
    474           *                     string appended to destination string.
    475           *               - (d) 'len_max' number of characters concatenated.
    476           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    477          CPU_CHAR *Str_Cat_N(CPU_CHAR       *p_str_dest,
    478                              const CPU_CHAR *p_str_cat,
    479                              CPU_SIZE_T     len_max)
    480          {
   \                     Str_Cat_N: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000B             MOVS     R3,R1
   \        0x6   0x0014             MOVS     R4,R2
    481            CPU_CHAR       *p_str_cat_dest;
    482            const CPU_CHAR *p_str_cat_src;
    483            CPU_SIZE_T     len_cat;
    484          
    485            //                                                               Rtn NULL if str ptr(s) NULL (see Note #4a).
    486            if (p_str_dest == DEF_NULL) {
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD101             BNE.N    ??Str_Cat_N_0
    487              return (DEF_NULL);
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE02D             B.N      ??Str_Cat_N_1
    488            }
    489            if (p_str_cat == DEF_NULL) {
   \                     ??Str_Cat_N_0: (+1)
   \       0x10   0x2B00             CMP      R3,#+0
   \       0x12   0xD101             BNE.N    ??Str_Cat_N_2
    490              return (DEF_NULL);
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE029             B.N      ??Str_Cat_N_1
    491            }
    492          
    493            if (len_max < 1) {                                            // Rtn dest str if cat len = 0.
   \                     ??Str_Cat_N_2: (+1)
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD101             BNE.N    ??Str_Cat_N_3
    494              return ((CPU_CHAR *)p_str_dest);
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0xE025             B.N      ??Str_Cat_N_1
    495            }
    496          
    497            p_str_cat_dest = p_str_dest;
   \                     ??Str_Cat_N_3: (+1)
   \       0x20   0x0029             MOVS     R1,R5
    498            while ((p_str_cat_dest != DEF_NULL)                           // Adv to end of cur dest str until NULL ptr ...
    499                   && (*p_str_cat_dest != (CPU_CHAR)'\0')) {              // ... or NULL char found..
   \                     ??Str_Cat_N_4: (+1)
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD004             BEQ.N    ??Str_Cat_N_5
   \       0x26   0x7808             LDRB     R0,[R1, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD001             BEQ.N    ??Str_Cat_N_5
    500              p_str_cat_dest++;
   \       0x2C   0x1C49             ADDS     R1,R1,#+1
   \       0x2E   0xE7F8             B.N      ??Str_Cat_N_4
    501            }
    502          
    503            if (p_str_cat_dest == DEF_NULL) {                             // Rtn NULL if NULL ptr found (see Note #4b).
   \                     ??Str_Cat_N_5: (+1)
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD101             BNE.N    ??Str_Cat_N_6
    504              return (DEF_NULL);
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xE019             B.N      ??Str_Cat_N_1
    505            }
    506          
    507            p_str_cat_src = p_str_cat;
   \                     ??Str_Cat_N_6: (+1)
   \       0x38   0x001A             MOVS     R2,R3
    508            len_cat = 0u;
   \       0x3A   0x2600             MOVS     R6,#+0
    509          
    510            while ((p_str_cat_dest != DEF_NULL)                           // Cat str until NULL ptr(s) (see Note #4b) ...
    511                   && (p_str_cat_src != DEF_NULL)
    512                   && (*p_str_cat_src != (CPU_CHAR)'\0')                  // ... or NULL char found (see Note #4c); ...
    513                   && (len_cat < (CPU_SIZE_T)len_max)) {                  // ... or max nbr chars cat'd (see Note #4d).
   \                     ??Str_Cat_N_7: (+1)
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD00C             BEQ.N    ??Str_Cat_N_8
   \       0x40   0x2A00             CMP      R2,#+0
   \       0x42   0xD00A             BEQ.N    ??Str_Cat_N_8
   \       0x44   0x7810             LDRB     R0,[R2, #+0]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD007             BEQ.N    ??Str_Cat_N_8
   \       0x4A   0x42A6             CMP      R6,R4
   \       0x4C   0xD205             BCS.N    ??Str_Cat_N_8
    514              *p_str_cat_dest = *p_str_cat_src;
   \       0x4E   0x7810             LDRB     R0,[R2, #+0]
   \       0x50   0x7008             STRB     R0,[R1, #+0]
    515              p_str_cat_dest++;
   \       0x52   0x1C49             ADDS     R1,R1,#+1
    516              p_str_cat_src++;
   \       0x54   0x1C52             ADDS     R2,R2,#+1
    517              len_cat++;
   \       0x56   0x1C76             ADDS     R6,R6,#+1
   \       0x58   0xE7F0             B.N      ??Str_Cat_N_7
    518            }
    519          
    520            //                                                               Rtn NULL if NULL ptr(s) found (see Note #4b).
    521            if ((p_str_cat_dest == DEF_NULL)
    522                || (p_str_cat_src == DEF_NULL)) {
   \                     ??Str_Cat_N_8: (+1)
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD001             BEQ.N    ??Str_Cat_N_9
   \       0x5E   0x2A00             CMP      R2,#+0
   \       0x60   0xD101             BNE.N    ??Str_Cat_N_10
    523              return (DEF_NULL);
   \                     ??Str_Cat_N_9: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xE002             B.N      ??Str_Cat_N_1
    524            }
    525          
    526            *p_str_cat_dest = (CPU_CHAR)'\0';                             // Append NULL char (see Note #1).
   \                     ??Str_Cat_N_10: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x7008             STRB     R0,[R1, #+0]
    527          
    528            return (p_str_dest);
   \       0x6A   0x0028             MOVS     R0,R5
   \                     ??Str_Cat_N_1: (+1)
   \       0x6C   0xBC70             POP      {R4-R6}
   \       0x6E   0x4770             BX       LR
    529          }
    530          
    531          /****************************************************************************************************//**
    532           *                                                   Str_Cmp()
    533           *
    534           * @brief    Determines if two strings are identical.
    535           *
    536           * @param    p1_str  Pointer to the first string. String buffer NOT modified.
    537           *
    538           * @param    p2_str  Pointer to the second string. String buffer NOT modified.
    539           *
    540           * @return   0, if strings are identical.
    541           *           Negative value, if 'p1_str' is less than 'p2_str'.
    542           *           Positive value, if 'p1_str' is greater than 'p2_str'.
    543           *
    544           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that :
    545           *               "the strcmp() function shall compare the string pointed to by 's1' ('p1_str') to the
    546           *               string pointed to by 's2' ('p2_str) [and] the sign of a non-zero return value shall
    547           *               be determined by the sign of the difference between the values of the first pair of
    548           *               bytes [...] that differ in the strings being compared".
    549           *
    550           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that :
    551           *               "upon successful completion, strcmp() shall return an integer greater than, equal to,
    552           *               or less than 0".
    553           *
    554           * @note     (3) String comparison terminates when :
    555           *               - (a) BOTH string pointer(s) are passed as NULL pointers. Return 0.
    556           *               - (b) 'p1_str' passed a NULL pointer. Return negative value of character pointed to by
    557           *                     'p2_str'.
    558           *               - (c) 'p2_str' passed a NULL pointer. Return positive value of character pointed to by
    559           *                     'p1_str'.
    560           *               - (d) BOTH strings at some point point to NULL. Strings overlap with NULL address.
    561           *                     Strings identical up to but NOT beyond or including the NULL address. Return 0.
    562           *               - (e) 'p1_str_cmp_next' points to NULL; 'p1_str' overlaps with NULL address. Strings
    563           *                     compared up to but NOT beyond or including the NULL address. Return negative
    564           *                     value of character pointed to by 'p2_str_cmp_next'.
    565           *               - (f) 'p2_str_cmp_next' points to NULL; 'p2_str' overlaps with NULL address. Strings
    566           *                     compared up to but NOT beyond or including the NULL address. Return positive
    567           *                     value of character pointed to by 'p1_str_cmp_next'.
    568           *               - (g) Terminating NULL character found in both strings. Strings identical. Return 0.
    569           *               - (h) Non-matching characters found. Return signed-integer difference of the character
    570           *                     pointed to by 'p2_str' from the character pointed to by 'p1_str'.
    571           *
    572           * @note     (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    573           *               return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    574           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    575          CPU_INT16S Str_Cmp(const CPU_CHAR *p1_str,
    576                             const CPU_CHAR *p2_str)
    577          {
   \                     Str_Cmp: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    578            CPU_INT16S cmp_val;
    579          
    580            cmp_val = Str_Cmp_N(p1_str,
    581                                p2_str,
    582                                DEF_INT_CPU_U_MAX_VAL);
   \        0x6   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       Str_Cmp_N
    583          
    584            return (cmp_val);
   \       0x12   0xB200             SXTH     R0,R0
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}
    585          }
    586          
    587          /****************************************************************************************************//**
    588           *                                               Str_Cmp_N()
    589           *
    590           * @brief    Determines if two strings are identical for up to a maximum number of characters.
    591           *
    592           * @param    p1_str      Pointer to the first string. String buffer NOT modified.
    593           *
    594           * @param    p2_str      Pointer to the second string. String buffer NOT modified.
    595           *
    596           * @param    len_max     Maximum number of characters to compare.
    597           *
    598           * @return   0, if strings are identical.
    599           *           Negative value, if 'p1_str' is less than 'p2_str'.
    600           *           Positive value, if 'p1_str' is greater than 'p2_str'.
    601           *
    602           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
    603           *               "The strncmp() function shall compare [...] the array pointed to by 's1' ('p1_str')
    604           *               to the array pointed to by 's2' ('p2_str) [...] but "not more than 'n' ('len_max')
    605           *               bytes" of either array. [...] [T]he sign of a non-zero return value is determined by
    606           *               the sign of the difference between the values of the first pair of bytes [...] that
    607           *               differ in the strings being compared".
    608           *
    609           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that :
    610           *               "upon successful completion, strncmp() shall return an integer greater than, equal
    611           *               to, or less than 0".
    612           *               - (a) BOTH string pointer(s) are passed as NULL pointers. Return 0.
    613           *               - (b) 'p1_str' passed a NULL pointer. Return negative value of character pointed to by
    614           *                     'p2_str'.
    615           *               - (c) 'p2_str' passed a NULL pointer. Return positive value of character pointed to by
    616           *                     'p1_str'.
    617           *               - (d) BOTH strings at some point point to NULL. Strings overlap with NULL address.
    618           *                     Strings identical up to but NOT beyond or including the NULL address. Return 0.
    619           *               - (e) 'p1_str_cmp_next' points to NULL; 'p1_str' overlaps with NULL address. Strings
    620           *                     compared up to but NOT beyond or including the NULL address. Return negative
    621           *                     value of character pointed to by 'p2_str_cmp_next'.
    622           *               - (f) 'p2_str_cmp_next' points to NULL; 'p2_str' overlaps with NULL address. Strings
    623           *                     compared up to but NOT beyond or including the NULL address. Return positive
    624           *                     value of character pointed to by 'p1_str_cmp_next'.
    625           *               - (g) Terminating NULL character found in both strings. Strings identical. Return 0.
    626           *               - (h) Non-matching characters found. Return signed-integer difference of the character
    627           *                     pointed to by 'p2_str' from the character pointed to by 'p1_str'.
    628           *               - (i) 'len_max' passed a zero length. Zero-length strings identical; 0 returned.
    629           *               - (j) First 'len_max' number of characters identical. Strings identical; 0 returned.
    630           *
    631           * @note     (3) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    632           *               return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    633           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    634          CPU_INT16S Str_Cmp_N(const CPU_CHAR *p1_str,
    635                               const CPU_CHAR *p2_str,
    636                               CPU_SIZE_T     len_max)
    637          {
   \                     Str_Cmp_N: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x0014             MOVS     R4,R2
    638            const CPU_CHAR *p1_str_cmp;
    639            const CPU_CHAR *p2_str_cmp;
    640            const CPU_CHAR *p1_str_cmp_next;
    641            const CPU_CHAR *p2_str_cmp_next;
    642            CPU_INT16S     cmp_val;
    643            CPU_SIZE_T     cmp_len;
    644          
    645            if (len_max < 1) {                                            // If cmp len = 0, rtn 0 (see Note #2i).
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??Str_Cmp_N_0
    646              return (0);
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE04A             B.N      ??Str_Cmp_N_1
    647            }
    648          
    649            if (p1_str == DEF_NULL) {
   \                     ??Str_Cmp_N_0: (+1)
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD107             BNE.N    ??Str_Cmp_N_2
    650              if (p2_str == DEF_NULL) {
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD101             BNE.N    ??Str_Cmp_N_3
    651                return (0);                                               // If BOTH str ptrs NULL, rtn 0 (see Note #2a).
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE044             B.N      ??Str_Cmp_N_1
    652              }
    653              cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str));
   \                     ??Str_Cmp_N_3: (+1)
   \       0x1A   0x7808             LDRB     R0,[R1, #+0]
   \       0x1C   0x4240             RSBS     R0,R0,#+0
    654              return (cmp_val);                                           // If p1_str NULL, rtn neg p2_str val (see Note #2b).
   \       0x1E   0xB200             SXTH     R0,R0
   \       0x20   0xE040             B.N      ??Str_Cmp_N_1
    655            }
    656            if (p2_str == DEF_NULL) {
   \                     ??Str_Cmp_N_2: (+1)
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD102             BNE.N    ??Str_Cmp_N_4
    657              cmp_val = (CPU_INT16S)(*p1_str);
   \       0x26   0x7828             LDRB     R0,[R5, #+0]
    658              return (cmp_val);                                           // If p2_str NULL, rtn pos p1_str val (see Note #2c).
   \       0x28   0xB200             SXTH     R0,R0
   \       0x2A   0xE03B             B.N      ??Str_Cmp_N_1
    659            }
    660          
    661            p1_str_cmp = p1_str;
   \                     ??Str_Cmp_N_4: (+1)
   \       0x2C   0x002F             MOVS     R7,R5
    662            p2_str_cmp = p2_str;
   \       0x2E   0x468C             MOV      R12,R1
    663            p1_str_cmp_next = p1_str_cmp;
   \       0x30   0x003A             MOVS     R2,R7
    664            p2_str_cmp_next = p2_str_cmp;
   \       0x32   0x4660             MOV      R0,R12
    665            p1_str_cmp_next++;
   \       0x34   0x1C52             ADDS     R2,R2,#+1
    666            p2_str_cmp_next++;
   \       0x36   0x1C43             ADDS     R3,R0,#+1
    667            cmp_len = 0u;
   \       0x38   0xF05F 0x0E00      MOVS     LR,#+0
    668          
    669            while ((*p1_str_cmp == *p2_str_cmp)                           // Cmp strs until non-matching chars (see Note #2h) ...
    670                   && (*p1_str_cmp != (CPU_CHAR)'\0')                     // ... or NULL chars (see Note #2g) ...
    671                   && (p1_str_cmp_next != DEF_NULL)                       // ... or NULL ptr(s) found (see Notes #2d, #2e, #2f).
    672                   && (p2_str_cmp_next != DEF_NULL)
    673                   && (cmp_len < (CPU_SIZE_T)len_max)) {                  // ... or max nbr chars cmp'd (see Note #2j).
   \                     ??Str_Cmp_N_5: (+1)
   \       0x3C   0x783E             LDRB     R6,[R7, #+0]
   \       0x3E   0xF89C 0x0000      LDRB     R0,[R12, #+0]
   \       0x42   0x4286             CMP      R6,R0
   \       0x44   0xD110             BNE.N    ??Str_Cmp_N_6
   \       0x46   0x7838             LDRB     R0,[R7, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD00D             BEQ.N    ??Str_Cmp_N_6
   \       0x4C   0x2A00             CMP      R2,#+0
   \       0x4E   0xD00B             BEQ.N    ??Str_Cmp_N_6
   \       0x50   0x2B00             CMP      R3,#+0
   \       0x52   0xD009             BEQ.N    ??Str_Cmp_N_6
   \       0x54   0x45A6             CMP      LR,R4
   \       0x56   0xD207             BCS.N    ??Str_Cmp_N_6
    674              p1_str_cmp++;
   \       0x58   0x1C7F             ADDS     R7,R7,#+1
    675              p2_str_cmp++;
   \       0x5A   0xF11C 0x0C01      ADDS     R12,R12,#+1
    676              p1_str_cmp_next++;
   \       0x5E   0x1C52             ADDS     R2,R2,#+1
    677              p2_str_cmp_next++;
   \       0x60   0x1C5B             ADDS     R3,R3,#+1
    678              cmp_len++;
   \       0x62   0xF11E 0x0E01      ADDS     LR,LR,#+1
   \       0x66   0xE7E9             B.N      ??Str_Cmp_N_5
    679            }
    680          
    681            if (cmp_len == len_max) {                                     // If strs identical for max len nbr of chars, ...
   \                     ??Str_Cmp_N_6: (+1)
   \       0x68   0x45A6             CMP      LR,R4
   \       0x6A   0xD101             BNE.N    ??Str_Cmp_N_7
    682              return (0);                                                 // ... rtn 0 (see Note #2j).
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xE019             B.N      ??Str_Cmp_N_1
    683            }
    684          
    685            if (*p1_str_cmp != *p2_str_cmp) {                             // If strs NOT identical, ...
   \                     ??Str_Cmp_N_7: (+1)
   \       0x70   0x783E             LDRB     R6,[R7, #+0]
   \       0x72   0xF89C 0x0000      LDRB     R0,[R12, #+0]
   \       0x76   0x4286             CMP      R6,R0
   \       0x78   0xD004             BEQ.N    ??Str_Cmp_N_8
    686                                                                          // ... calc & rtn char diff (see Note #2h).
    687              cmp_val = (CPU_INT16S)((CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp));
   \       0x7A   0x7838             LDRB     R0,[R7, #+0]
   \       0x7C   0xF89C 0x6000      LDRB     R6,[R12, #+0]
   \       0x80   0x1B80             SUBS     R0,R0,R6
   \       0x82   0xE00E             B.N      ??Str_Cmp_N_9
    688            } else if (*p1_str_cmp == (CPU_CHAR)'\0') {                   // If NULL char(s) found, ...
   \                     ??Str_Cmp_N_8: (+1)
   \       0x84   0x7838             LDRB     R0,[R7, #+0]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD101             BNE.N    ??Str_Cmp_N_10
    689              cmp_val = (CPU_INT16S)0;                                    // ... strs identical; rtn 0 (see Note #2g).
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xE009             B.N      ??Str_Cmp_N_9
    690            } else {
    691              if (p1_str_cmp_next == DEF_NULL) {
   \                     ??Str_Cmp_N_10: (+1)
   \       0x8E   0x2A00             CMP      R2,#+0
   \       0x90   0xD106             BNE.N    ??Str_Cmp_N_11
    692                if (p2_str_cmp_next == DEF_NULL) {                        // If BOTH next str ptrs NULL, ...
   \       0x92   0x2B00             CMP      R3,#+0
   \       0x94   0xD101             BNE.N    ??Str_Cmp_N_12
    693                  cmp_val = (CPU_INT16S)0;                                // ... rtn 0 (see Note #2d).
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xE003             B.N      ??Str_Cmp_N_9
    694                } else {                                                  // If p1_str_cmp_next NULL, ...
    695                                                                          // ... rtn neg p2_str_cmp_next val (see Note #2e).
    696                  cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next));
   \                     ??Str_Cmp_N_12: (+1)
   \       0x9A   0x7818             LDRB     R0,[R3, #+0]
   \       0x9C   0x4240             RSBS     R0,R0,#+0
   \       0x9E   0xE000             B.N      ??Str_Cmp_N_9
    697                }
    698              } else {                                                    // If p2_str_cmp_next NULL, ...
    699                cmp_val = (CPU_INT16S)(*p1_str_cmp_next);                 // ... rtn pos p1_str_cmp_next val (see Note #2f).
   \                     ??Str_Cmp_N_11: (+1)
   \       0xA0   0x7810             LDRB     R0,[R2, #+0]
    700              }
    701            }
    702          
    703            return (cmp_val);
   \                     ??Str_Cmp_N_9: (+1)
   \       0xA2   0xB200             SXTH     R0,R0
   \                     ??Str_Cmp_N_1: (+1)
   \       0xA4   0xBDF0             POP      {R4-R7,PC}
    704          }
    705          
    706          /****************************************************************************************************//**
    707           *                                           Str_CmpIgnoreCase()
    708           *
    709           * @brief    Determines if two strings are identical, ignoring case.
    710           *
    711           * @param    p1_str  Pointer to the first string. String buffer NOT modified.
    712           *
    713           * @param    p2_str  Pointer to the second string. String buffer NOT modified.
    714           *
    715           * @return   0, if strings are identical.
    716           *           Negative value, if 'p1_str' is less than 'p2_str'.
    717           *           Positive value, if 'p1_str' is greater than 'p2_str'.
    718           *
    719           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
    720           *               "The strcasecmp() function shall compare [...] the string pointed to by 's1'
    721           *               ('p1_str') to the string pointed to by 's2' ('p2_str') [...] ignoring differences in
    722           *               case [and that] strcasecmp() [...] shall behave as if the strings had been converted
    723           *               to lowercase and then a byte comparison performed. [...] [T]he sign of a non-zero
    724           *               return value shall be determined by the sign of the difference between the values of
    725           *               the first pair of bytes [...] that differ in the strings being compared"
    726           *
    727           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that :
    728           *               "upon successful completion, strcasecmp() shall return an integer greater than, equal
    729           *               to, or less than 0".
    730           *
    731           * @note     (3) String comparison terminates when :
    732           *               - (a) BOTH string pointer(s) are passed as NULL pointers. Return 0.
    733           *               - (b) 'p1_str' passed a NULL pointer. Return negative value of character pointed to by
    734           *                     'p2_str'.
    735           *               - (c) 'p2_str' passed a NULL pointer. Return positive value of character pointed to by
    736           *                     'p1_str'.
    737           *               - (d) BOTH strings at some point point to NULL. Strings overlap with NULL address.
    738           *                     Strings identical up to but NOT beyond or including the NULL address. Return 0.
    739           *               - (e) 'p1_str_cmp_next' points to NULL; 'p1_str' overlaps with NULL address. Strings
    740           *                     compared up to but NOT beyond or including the NULL address. Return negative
    741           *                     value of character pointed to by 'p2_str_cmp_next'.
    742           *               - (f) 'p2_str_cmp_next' points to NULL; 'p2_str' overlaps with NULL address. Strings
    743           *                     compared up to but NOT beyond or including the NULL address. Return positive
    744           *                     value of character pointed to by 'p1_str_cmp_next'.
    745           *               - (g) Terminating NULL character found in both strings. Strings identical. Return 0.
    746           *               - (h) Non-matching characters found. Return signed-integer difference of the character
    747           *                     pointed to by 'p2_str' from the character pointed to by 'p1_str'.
    748           *
    749           * @note     (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    750           *               return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    751           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    752          CPU_INT16S Str_CmpIgnoreCase(const CPU_CHAR *p1_str,
    753                                       const CPU_CHAR *p2_str)
    754          {
   \                     Str_CmpIgnoreCase: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    755            CPU_INT16S cmp_val;
    756          
    757            cmp_val = Str_CmpIgnoreCase_N(p1_str,
    758                                          p2_str,
    759                                          DEF_INT_CPU_U_MAX_VAL);
   \        0x6   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       Str_CmpIgnoreCase_N
    760          
    761            return (cmp_val);
   \       0x12   0xB200             SXTH     R0,R0
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}
    762          }
    763          
    764          /****************************************************************************************************//**
    765           *                                           Str_CmpIgnoreCase_N()
    766           *
    767           * @brief    Determines if two strings are identical for up to a maximum number of characters,
    768           *           ignoring case.
    769           *
    770           * @param    p1_str      Pointer to the first string. String buffer NOT modified.
    771           *
    772           * @param    p2_str      Pointer to the second string. String buffer NOT modified.
    773           *
    774           * @param    len_max     Maximum number of characters to compare.
    775           *
    776           * @return   0, if strings are identical.
    777           *           Negative value, if 'p1_str' is less than 'p2_str'.
    778           *           Positive value, if 'p1_str' is greater than 'p2_str'.
    779           *
    780           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
    781           *               "The strncasecmp() function shall compare [...] the string pointed to by 's1'
    782           *               ('p1_str') to the string pointed to by 's2' ('p2_str') [...] ignoring differences in
    783           *               case [...] but not more than 'n' ('len_max') bytes of either string. [...]
    784           *               strncasecmp() shall behave as if the strings had been converted to lowercase and then
    785           *               a byte comparison performed. [...] [T]he sign of a non-zero return value shall be
    786           *               determined by the sign of the difference between the values of the first pair of
    787           *               bytes [...] that differ in the strings being compared".
    788           *
    789           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that :
    790           *               "upon successful completion, strncasecmp() shall return an integer greater than,
    791           *               equal to, or less than 0".
    792           *
    793           * @note     (3) String comparison terminates when :
    794           *               - (a) BOTH string pointer(s) are passed as NULL pointers. Return 0.
    795           *               - (b) 'p1_str' passed a NULL pointer. Return negative value of character pointed to by
    796           *                     'p2_str'.
    797           *               - (c) 'p2_str' passed a NULL pointer. Return positive value of character pointed to by
    798           *                     'p1_str'.
    799           *               - (d) BOTH strings at some point point to NULL. Strings overlap with NULL address.
    800           *                     Strings identical up to but NOT beyond or including the NULL address. Return 0.
    801           *               - (e) 'p1_str_cmp_next' points to NULL; 'p1_str' overlaps with NULL address. Strings
    802           *                     compared up to but NOT beyond or including the NULL address. Return negative
    803           *                     value of character pointed to by 'p2_str_cmp_next'.
    804           *               - (f) 'p2_str_cmp_next' points to NULL; 'p2_str' overlaps with NULL address. Strings
    805           *                     compared up to but NOT beyond or including the NULL address. Return positive
    806           *                     value of character pointed to by 'p1_str_cmp_next'.
    807           *               - (g) Terminating NULL character found in both strings. Strings identical. Return 0.
    808           *               - (h) Non-matching characters found. Return signed-integer difference of the character
    809           *                     pointed to by 'p2_str' from the character pointed to by 'p1_str'.
    810           *               - (i) 'len_max' passed a zero length. Zero-length strings identical; 0 returned.
    811           *               - (j) First 'len_max' number of characters identical. Strings identical; 0 returned.
    812           *
    813           * @note     (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    814           *               return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    815           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    816          CPU_INT16S Str_CmpIgnoreCase_N(const CPU_CHAR *p1_str,
    817                                         const CPU_CHAR *p2_str,
    818                                         CPU_SIZE_T     len_max)
    819          {
   \                     Str_CmpIgnoreCase_N: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB081             SUB      SP,SP,#+4
   \        0x6   0x0016             MOVS     R6,R2
    820            const CPU_CHAR *p1_str_cmp;
    821            const CPU_CHAR *p2_str_cmp;
    822            const CPU_CHAR *p1_str_cmp_next;
    823            const CPU_CHAR *p2_str_cmp_next;
    824            CPU_CHAR       char_1;
    825            CPU_CHAR       char_2;
    826            CPU_INT16S     cmp_val;
    827            CPU_SIZE_T     cmp_len;
    828          
    829            if (len_max < 1) {                                            // If cmp len = 0, rtn 0 (see Note #3i).
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_0
    830              return (0);
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE07B             B.N      ??Str_CmpIgnoreCase_N_1
    831            }
    832          
    833            if (p1_str == DEF_NULL) {
   \                     ??Str_CmpIgnoreCase_N_0: (+1)
   \       0x10   0x9801             LDR      R0,[SP, #+4]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD10E             BNE.N    ??Str_CmpIgnoreCase_N_2
    834              if (p2_str == DEF_NULL) {
   \       0x16   0x9802             LDR      R0,[SP, #+8]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_3
    835                return (0);                                               // If BOTH str ptrs NULL, rtn 0 (see Note #3a).
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xE073             B.N      ??Str_CmpIgnoreCase_N_1
    836              }
    837              char_2 = ASCII_ToLower(*p2_str);
   \                     ??Str_CmpIgnoreCase_N_3: (+1)
   \       0x20   0x9802             LDR      R0,[SP, #+8]
   \       0x22   0x7800             LDRB     R0,[R0, #+0]
   \       0x24   0x.... 0x....      BL       ASCII_ToLower
   \       0x28   0x0001             MOVS     R1,R0
    838              cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
   \       0x2A   0x0008             MOVS     R0,R1
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x4240             RSBS     R0,R0,#+0
    839              return (cmp_val);                                           // If p1_str NULL, rtn neg p2_str val (see Note #3b).
   \       0x30   0xB200             SXTH     R0,R0
   \       0x32   0xE069             B.N      ??Str_CmpIgnoreCase_N_1
    840            }
    841            if (p2_str == DEF_NULL) {
   \                     ??Str_CmpIgnoreCase_N_2: (+1)
   \       0x34   0x9802             LDR      R0,[SP, #+8]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD108             BNE.N    ??Str_CmpIgnoreCase_N_4
    842              char_1 = ASCII_ToLower(*p1_str);
   \       0x3A   0x9801             LDR      R0,[SP, #+4]
   \       0x3C   0x7800             LDRB     R0,[R0, #+0]
   \       0x3E   0x.... 0x....      BL       ASCII_ToLower
   \       0x42   0x0001             MOVS     R1,R0
    843              cmp_val = (CPU_INT16S)char_1;
   \       0x44   0x0008             MOVS     R0,R1
   \       0x46   0xB2C0             UXTB     R0,R0
    844              return (cmp_val);                                           // If p2_str NULL, rtn pos p1_str val (see Note #3c).
   \       0x48   0xB200             SXTH     R0,R0
   \       0x4A   0xE05D             B.N      ??Str_CmpIgnoreCase_N_1
    845            }
    846          
    847            p1_str_cmp = p1_str;
   \                     ??Str_CmpIgnoreCase_N_4: (+1)
   \       0x4C   0xF8DD 0xB004      LDR      R11,[SP, #+4]
    848            p2_str_cmp = p2_str;
   \       0x50   0x9F02             LDR      R7,[SP, #+8]
    849            p1_str_cmp_next = p1_str_cmp;
   \       0x52   0x4659             MOV      R1,R11
    850            p2_str_cmp_next = p2_str_cmp;
   \       0x54   0x0038             MOVS     R0,R7
    851            p1_str_cmp_next++;
   \       0x56   0x1C4C             ADDS     R4,R1,#+1
    852            p2_str_cmp_next++;
   \       0x58   0x1C45             ADDS     R5,R0,#+1
    853            char_1 = ASCII_ToLower(*p1_str_cmp);
   \       0x5A   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \       0x5E   0x.... 0x....      BL       ASCII_ToLower
   \       0x62   0x4680             MOV      R8,R0
    854            char_2 = ASCII_ToLower(*p2_str_cmp);
   \       0x64   0x7838             LDRB     R0,[R7, #+0]
   \       0x66   0x.... 0x....      BL       ASCII_ToLower
   \       0x6A   0x4681             MOV      R9,R0
    855            cmp_len = 0u;
   \       0x6C   0xF05F 0x0A00      MOVS     R10,#+0
    856          
    857            while ((char_1 == char_2)                                     // Cmp strs until non-matching chars (see Note #3h) ...
    858                   && (*p1_str_cmp != (CPU_CHAR)'\0')                     // ... or NULL chars (see Note #3g) ...
    859                   && (p1_str_cmp_next != DEF_NULL)                       // ... or NULL ptr(s) found (see Note #3d).
    860                   && (p2_str_cmp_next != DEF_NULL)
    861                   && (cmp_len < (CPU_SIZE_T)len_max)) {                  // ... or max nbr chars cmp'd (see Note #3j).
   \                     ??Str_CmpIgnoreCase_N_5: (+1)
   \       0x70   0x4641             MOV      R1,R8
   \       0x72   0x4648             MOV      R0,R9
   \       0x74   0xB2C9             UXTB     R1,R1
   \       0x76   0xB2C0             UXTB     R0,R0
   \       0x78   0x4281             CMP      R1,R0
   \       0x7A   0xD11A             BNE.N    ??Str_CmpIgnoreCase_N_6
   \       0x7C   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD016             BEQ.N    ??Str_CmpIgnoreCase_N_6
   \       0x84   0x2C00             CMP      R4,#+0
   \       0x86   0xD014             BEQ.N    ??Str_CmpIgnoreCase_N_6
   \       0x88   0x2D00             CMP      R5,#+0
   \       0x8A   0xD012             BEQ.N    ??Str_CmpIgnoreCase_N_6
   \       0x8C   0x45B2             CMP      R10,R6
   \       0x8E   0xD210             BCS.N    ??Str_CmpIgnoreCase_N_6
    862              p1_str_cmp++;
   \       0x90   0xF11B 0x0B01      ADDS     R11,R11,#+1
    863              p2_str_cmp++;
   \       0x94   0x1C7F             ADDS     R7,R7,#+1
    864              p1_str_cmp_next++;
   \       0x96   0x1C64             ADDS     R4,R4,#+1
    865              p2_str_cmp_next++;
   \       0x98   0x1C6D             ADDS     R5,R5,#+1
    866              cmp_len++;
   \       0x9A   0xF11A 0x0A01      ADDS     R10,R10,#+1
    867              char_1 = ASCII_ToLower(*p1_str_cmp);
   \       0x9E   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \       0xA2   0x.... 0x....      BL       ASCII_ToLower
   \       0xA6   0x4680             MOV      R8,R0
    868              char_2 = ASCII_ToLower(*p2_str_cmp);
   \       0xA8   0x7838             LDRB     R0,[R7, #+0]
   \       0xAA   0x.... 0x....      BL       ASCII_ToLower
   \       0xAE   0x4681             MOV      R9,R0
   \       0xB0   0xE7DE             B.N      ??Str_CmpIgnoreCase_N_5
    869            }
    870          
    871            if (cmp_len == len_max) {                                     // If strs identical for max len nbr of chars, ...
   \                     ??Str_CmpIgnoreCase_N_6: (+1)
   \       0xB2   0x45B2             CMP      R10,R6
   \       0xB4   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_7
    872              return (0);                                                 // ... rtn 0 (see Note #3j).
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0xE026             B.N      ??Str_CmpIgnoreCase_N_1
    873            }
    874          
    875            if (char_1 != char_2) {                                       // If strs NOT identical, ...
   \                     ??Str_CmpIgnoreCase_N_7: (+1)
   \       0xBA   0x4641             MOV      R1,R8
   \       0xBC   0x4648             MOV      R0,R9
   \       0xBE   0xB2C9             UXTB     R1,R1
   \       0xC0   0xB2C0             UXTB     R0,R0
   \       0xC2   0x4281             CMP      R1,R0
   \       0xC4   0xD005             BEQ.N    ??Str_CmpIgnoreCase_N_8
    876                                                                          // ... calc & rtn char diff (see Note #3h).
    877              cmp_val = (CPU_INT16S)((CPU_INT16S)char_1 - (CPU_INT16S)char_2);
   \       0xC6   0x4640             MOV      R0,R8
   \       0xC8   0xB2C0             UXTB     R0,R0
   \       0xCA   0x4649             MOV      R1,R9
   \       0xCC   0xB2C9             UXTB     R1,R1
   \       0xCE   0x1A40             SUBS     R0,R0,R1
   \       0xD0   0xE019             B.N      ??Str_CmpIgnoreCase_N_9
    878            } else if (char_1 == (CPU_CHAR)'\0') {                        // If NULL char(s) found, ...
   \                     ??Str_CmpIgnoreCase_N_8: (+1)
   \       0xD2   0x4640             MOV      R0,R8
   \       0xD4   0xB2C0             UXTB     R0,R0
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_10
    879              cmp_val = (CPU_INT16S)0;                                    // ... strs identical; rtn 0 (see Note #3g).
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0xE013             B.N      ??Str_CmpIgnoreCase_N_9
    880            } else {
    881              if (p1_str_cmp_next == DEF_NULL) {
   \                     ??Str_CmpIgnoreCase_N_10: (+1)
   \       0xDE   0x2C00             CMP      R4,#+0
   \       0xE0   0xD10B             BNE.N    ??Str_CmpIgnoreCase_N_11
    882                if (p2_str_cmp_next == DEF_NULL) {                        // If BOTH next str ptrs NULL, ...
   \       0xE2   0x2D00             CMP      R5,#+0
   \       0xE4   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_12
    883                  cmp_val = (CPU_INT16S)0;                                // ... rtn 0 (see Note #3d).
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xE00D             B.N      ??Str_CmpIgnoreCase_N_9
    884                } else {                                                  // If p1_str_cmp_next NULL, ...
    885                  char_2 = ASCII_ToLower(*p2_str_cmp_next);
   \                     ??Str_CmpIgnoreCase_N_12: (+1)
   \       0xEA   0x7828             LDRB     R0,[R5, #+0]
   \       0xEC   0x.... 0x....      BL       ASCII_ToLower
   \       0xF0   0x4681             MOV      R9,R0
    886                  //                                                         ... rtn neg p2_str_cmp_next val (see Note #3e).
    887                  cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
   \       0xF2   0x4648             MOV      R0,R9
   \       0xF4   0xB2C0             UXTB     R0,R0
   \       0xF6   0x4240             RSBS     R0,R0,#+0
   \       0xF8   0xE005             B.N      ??Str_CmpIgnoreCase_N_9
    888                }
    889              } else {                                                    // If p2_str_cmp_next NULL, ...
    890                char_1 = ASCII_ToLower(*p1_str_cmp_next);
   \                     ??Str_CmpIgnoreCase_N_11: (+1)
   \       0xFA   0x7820             LDRB     R0,[R4, #+0]
   \       0xFC   0x.... 0x....      BL       ASCII_ToLower
   \      0x100   0x4680             MOV      R8,R0
    891                cmp_val = (CPU_INT16S)char_1;                             // ... rtn pos p1_str_cmp_next val (see Note #3f).
   \      0x102   0x4640             MOV      R0,R8
   \      0x104   0xB2C0             UXTB     R0,R0
    892              }
    893            }
    894          
    895            return (cmp_val);
   \                     ??Str_CmpIgnoreCase_N_9: (+1)
   \      0x106   0xB200             SXTH     R0,R0
   \                     ??Str_CmpIgnoreCase_N_1: (+1)
   \      0x108   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    896          }
    897          
    898          /****************************************************************************************************//**
    899           *                                               Str_Char()
    900           *
    901           * @brief    Searches the string for first occurrence of specific character.
    902           *
    903           * @param    p_str       Pointer to the string. String buffer NOT modified.
    904           *
    905           * @param    srch_char   Search character.
    906           *
    907           * @return   Pointer to the first occurrence of search character in string, if any occur.
    908           *           Pointer to NULL, otherwise.
    909           *
    910           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
    911           *               "The strchr() function shall locate the first occurrence of 'c' ('srch_char') [...]
    912           *               in the string pointed to by 's' ('p_str'). [...] The terminating null byte is
    913           *               considered to be part of the string."
    914           *
    915           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that :
    916           *               "upon completion, strchr() shall return [...] a pointer to the byte, [...] or a null
    917           *               pointer if the byte was not found."
    918           *               Although NO strchr() specification states to return NULL for any other reason(s),
    919           *               NULL is also returned for any error(s).
    920           *
    921           * @note     (3) String search terminates when :
    922           *               - (a) String pointer passed a NULL pointer. No string search performed. NULL pointer is
    923           *                     returned.
    924           *               - (b) String pointer points to NULL. String overlaps with NULL address. NULL pointer is
    925           *                     returned.
    926           *               - (c) String's terminating NULL character found. Search character NOT found in search
    927           *                     string. NULL pointer is returned. This is applicable even if search character is
    928           *                     the terminating NULL character.
    929           *               - (d) Search character found. Return pointer to first occurrence of search character in
    930           *                     search string.
    931           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    932          CPU_CHAR *Str_Char(const CPU_CHAR *p_str,
    933                             CPU_CHAR       srch_char)
    934          {
   \                     Str_Char: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    935            CPU_CHAR *p_str_rtn;
    936          
    937            p_str_rtn = Str_Char_N(p_str,
    938                                   DEF_INT_CPU_U_MAX_VAL,
    939                                   srch_char);
   \        0x6   0x0022             MOVS     R2,R4
   \        0x8   0xB2D2             UXTB     R2,R2
   \        0xA   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       Str_Char_N
    940          
    941            return (p_str_rtn);
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}
    942          }
    943          
    944          /****************************************************************************************************//**
    945           *                                               Str_Char_N()
    946           *
    947           * @brief    Searches the string for first occurrence of specific character, up to a maximum number of
    948           *           characters.
    949           *
    950           * @param    p_str       Pointer to the string. String buffer NOT modified.
    951           *
    952           * @param    len_max     Maximum number of characters to search. 'len_max' number of characters MAY
    953           *                       include terminating NULL character
    954           *
    955           * @param    srch_char   Search character.
    956           *
    957           * @return   Pointer to the first occurrence of search character in string, if any occur.
    958           *           Pointer to the NULL, otherwise.
    959           *
    960           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
    961           *               "The strchr() function shall locate the first occurrence of 'c' ('srch_char') [...]
    962           *               in the string pointed to by 's' ('p_str'). [...] The terminating null byte is
    963           *               considered to be part of the string."
    964           *
    965           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that :
    966           *               "upon completion, strchr() shall return [...] a pointer to the byte, [...] or a null
    967           *               pointer if the byte was not found."
    968           *               Although NO strchr() specification states to return NULL for any other reason(s),
    969           *               NULL is also returned for any error(s).
    970           *
    971           * @note     (3) String search terminates when :
    972           *               - (a) String pointer passed a NULL pointer. No string search performed. NULL pointer is
    973           *                     returned.
    974           *               - (b) String pointer points to NULL. String overlaps with NULL address. NULL pointer is
    975           *                     returned.
    976           *               - (c) String's terminating NULL character found. Search character NOT found in search
    977           *                     string. NULL pointer is returned. This is applicable even if search character is
    978           *                     the terminating NULL character.
    979           *               - (d) Search character found. Return pointer to first occurrence of search character in
    980           *                     search string.
    981           *               - (e) 'len_max' number of characters searched. Search character NOT found in search
    982           *                      string within first 'len_max' number of characters. NULL pointer is returned.
    983           *
    984           * @note     (4) Ideally, the 'len_max' argument would be the last argument in this function's
    985           *               argument list for consistency with all other custom string library functions.
    986           *               However, the 'len_max' argument is sequentially ordered as the second argument to
    987           *               comply with most standard library's strnchr() argument list.
    988           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    989          CPU_CHAR *Str_Char_N(const CPU_CHAR *p_str,
    990                               CPU_SIZE_T     len_max,
    991                               CPU_CHAR       srch_char)
    992          {
   \                     Str_Char_N: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0003             MOVS     R3,R0
   \        0x4   0x0014             MOVS     R4,R2
    993            const CPU_CHAR *p_str_char;
    994            CPU_SIZE_T     len_srch;
    995          
    996            if (p_str == DEF_NULL) {                                      // Rtn NULL if srch str ptr NULL (see Note #3a).
   \        0x6   0x2B00             CMP      R3,#+0
   \        0x8   0xD101             BNE.N    ??Str_Char_N_0
    997              return (DEF_NULL);
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE020             B.N      ??Str_Char_N_1
    998            }
    999          
   1000            if (len_max < 1) {                                            // Rtn NULL if srch len = 0 (see Note #3e).
   \                     ??Str_Char_N_0: (+1)
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD101             BNE.N    ??Str_Char_N_2
   1001              return (DEF_NULL);
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE01C             B.N      ??Str_Char_N_1
   1002            }
   1003          
   1004            p_str_char = p_str;
   \                     ??Str_Char_N_2: (+1)
   \       0x16   0x001A             MOVS     R2,R3
   1005            len_srch = 0u;
   \       0x18   0x2500             MOVS     R5,#+0
   1006          
   1007            while ((p_str_char != DEF_NULL)                               // Srch str until NULL ptr (see Note #3b) ...
   1008                   && (*p_str_char != (CPU_CHAR)'\0')                     // ... or NULL char (see Note #3c)  ...
   1009                   && (*p_str_char != (CPU_CHAR)srch_char)                // ... or srch char found (see Note #3d); ...
   1010                   && (len_srch < (CPU_SIZE_T)len_max)) {                 // ... or max nbr chars srch'd (see Note #3e).
   \                     ??Str_Char_N_3: (+1)
   \       0x1A   0x2A00             CMP      R2,#+0
   \       0x1C   0xD00C             BEQ.N    ??Str_Char_N_4
   \       0x1E   0x7810             LDRB     R0,[R2, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD009             BEQ.N    ??Str_Char_N_4
   \       0x24   0x7816             LDRB     R6,[R2, #+0]
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x4286             CMP      R6,R0
   \       0x2C   0xD004             BEQ.N    ??Str_Char_N_4
   \       0x2E   0x428D             CMP      R5,R1
   \       0x30   0xD202             BCS.N    ??Str_Char_N_4
   1011              p_str_char++;
   \       0x32   0x1C52             ADDS     R2,R2,#+1
   1012              len_srch++;
   \       0x34   0x1C6D             ADDS     R5,R5,#+1
   \       0x36   0xE7F0             B.N      ??Str_Char_N_3
   1013            }
   1014          
   1015          #if 0
   1016            if (p_str_char == DEF_NULL) {                                 // Rtn NULL if NULL ptr found (see Note #3b).
   1017              return (DEF_NULL);
   1018            }
   1019          #endif
   1020          
   1021            if (len_srch >= len_max) {                                    // Rtn NULL if srch char NOT found ...
   \                     ??Str_Char_N_4: (+1)
   \       0x38   0x428D             CMP      R5,R1
   \       0x3A   0xD301             BCC.N    ??Str_Char_N_5
   1022              return (DEF_NULL);                                          // ... within max nbr of chars (see Note #3e).
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xE007             B.N      ??Str_Char_N_1
   1023            }
   1024          
   1025            if (*p_str_char != srch_char) {                               // Rtn NULL if srch char NOT found (see Note #3c).
   \                     ??Str_Char_N_5: (+1)
   \       0x40   0x7816             LDRB     R6,[R2, #+0]
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0x4286             CMP      R6,R0
   \       0x48   0xD001             BEQ.N    ??Str_Char_N_6
   1026              return (DEF_NULL);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xE000             B.N      ??Str_Char_N_1
   1027            }
   1028          
   1029            return ((CPU_CHAR *)p_str_char);                              // Else rtn ptr to found srch char (see Note #3d).
   \                     ??Str_Char_N_6: (+1)
   \       0x4E   0x0010             MOVS     R0,R2
   \                     ??Str_Char_N_1: (+1)
   \       0x50   0xBC70             POP      {R4-R6}
   \       0x52   0x4770             BX       LR
   1030          }
   1031          
   1032          /****************************************************************************************************//**
   1033           *                                               Str_Char_Last()
   1034           *
   1035           * @brief    Searches the string for last occurrence of specific character.
   1036           *
   1037           * @param    p_str       Pointer to the string. String buffer NOT modified.
   1038           *
   1039           * @param    srch_char   Search character.
   1040           *
   1041           * @return   Pointer to the last occurrence of search character in string, if any.
   1042           *           Pointer to NULL, otherwise.
   1043           *
   1044           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
   1045           *               "The strrchr() function shall locate the last occurrence of 'c' ('srch_char') [...]
   1046           *               in the string pointed to by 's' ('p_str'). [...] The terminating null byte is
   1047           *               considered to be part of the string."
   1048           *
   1049           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that :
   1050           *               "upon successful completion, strrchr() shall return [...] a pointer to the byte [...]
   1051           *               or a null pointer if 'c' ('srch_char') does not occur in the string."
   1052           *               Although NO strrchr() specification states to return NULL for any other reason(s),
   1053           *               NULL is also returned for any error(s).
   1054           *
   1055           * @note     (3) String search terminates when :
   1056           *               - (a) String pointer passed a NULL pointer. No string search performed. NULL pointer is
   1057           *                     returned.
   1058           *               - (b) String pointer points to NULL. String overlaps with NULL address. NULL pointer is
   1059           *                     returned.
   1060           *               - (c) String searched from end to beginning. Search character NOT found in search
   1061           *                     string. NULL pointer is returned. Applicable even if search character is the
   1062           *                     terminating NULL character.
   1063           *               - (d) Search character found. Return pointer to last occurrence of search character in
   1064           *                     search string.
   1065           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1066          CPU_CHAR *Str_Char_Last(const CPU_CHAR *p_str,
   1067                                  CPU_CHAR       srch_char)
   1068          {
   \                     Str_Char_Last: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1069            CPU_CHAR *p_str_rtn;
   1070          
   1071            p_str_rtn = Str_Char_Last_N(p_str,
   1072                                        DEF_INT_CPU_U_MAX_VAL,
   1073                                        srch_char);
   \        0x6   0x0022             MOVS     R2,R4
   \        0x8   0xB2D2             UXTB     R2,R2
   \        0xA   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       Str_Char_Last_N
   1074          
   1075            return (p_str_rtn);
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}
   1076          }
   1077          
   1078          /****************************************************************************************************//**
   1079           *                                               Str_Char_Last_N()
   1080           *
   1081           * @brief    Searches the string for last occurrence of specific character, up to a maximum number of
   1082           *           characters.
   1083           *
   1084           * @param    p_str       Pointer to the string. String buffer NOT modified.
   1085           *
   1086           * @param    len_max     Maximum number of characters to search. 'len_max' number of characters MAY
   1087           *                       include terminating NULL character.
   1088           *
   1089           * @param    srch_char   Search character.
   1090           *
   1091           * @return   Pointer to the last occurrence of search character in string, if any.
   1092           *           Pointer to NULL, otherwise.
   1093           *
   1094           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
   1095           *               "The strrchr() function shall locate the last occurrence of 'c' ('srch_char') [...]
   1096           *               in the string pointed to by 's' ('p_str'). [...] The terminating null byte is
   1097           *               considered to be part of the string."
   1098           *
   1099           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that :
   1100           *               "upon successful completion, strrchr() shall return [...] a pointer to the byte [...]
   1101           *               or a null pointer if 'c' ('srch_char') does not occur in the string."
   1102           *               AlthougNO strrchr() specification states to return NULL for any other reason(s),
   1103           *               NULL is also returned for any error(s).
   1104           *
   1105           * @note     (3) String search terminates when :
   1106           *               - (a) String pointer passed a NULL pointer. No string search performed. NULL pointer is
   1107           *                     returned.
   1108           *               - (b) String pointer points to NULL. String overlaps with NULL address. NULL pointer is
   1109           *                     returned.
   1110           *               - (c) String searched from end to beginning. Search character NOT found in search
   1111           *                     string. NULL pointer is returned. Applicable even if search character is the
   1112           *                     terminating NULL character.
   1113           *               - (d) Search character found. Return pointer to last occurrence of search character in
   1114           *                     search string.
   1115           *               - (e) 'len_max' number of characters searched. Search character NOT found in search
   1116           *                     string within last 'len_max' number of characters. NULL pointer is returned.
   1117           *
   1118           * @note     (4) Ideally, the 'len_max' argument would be the last argument in this function's
   1119           *               argument list for consistency with all other custom string library functions.
   1120           *               However, the 'len_max' argument is sequentially ordered as the second argument to
   1121           *               comply with most standard library's strnrchr() argument list.
   1122           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1123          CPU_CHAR *Str_Char_Last_N(const CPU_CHAR *p_str,
   1124                                    CPU_SIZE_T     len_max,
   1125                                    CPU_CHAR       srch_char)
   1126          {
   \                     Str_Char_Last_N: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1127            const CPU_CHAR *p_str_char;
   1128            CPU_SIZE_T     str_len_max;
   1129            CPU_SIZE_T     str_len;
   1130          
   1131            if (p_str == DEF_NULL) {                                      // Rtn NULL if srch str ptr NULL (see Note #3a).
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??Str_Char_Last_N_0
   1132              return (DEF_NULL);
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE01E             B.N      ??Str_Char_Last_N_1
   1133            }
   1134          
   1135            if (len_max < 1) {                                            // Rtn NULL if srch len = 0 (see Note #3e).
   \                     ??Str_Char_Last_N_0: (+1)
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??Str_Char_Last_N_2
   1136              return (DEF_NULL);
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE01A             B.N      ??Str_Char_Last_N_1
   1137            }
   1138          
   1139            p_str_char = p_str;
   \                     ??Str_Char_Last_N_2: (+1)
   \       0x1A   0x0027             MOVS     R7,R4
   1140            str_len_max = len_max - sizeof("");                           // Str len adj'd for NULL char len.
   \       0x1C   0xF1B5 0x0801      SUBS     R8,R5,#+1
   1141            str_len = Str_Len_N(p_str_char, str_len_max);
   \       0x20   0x4641             MOV      R1,R8
   \       0x22   0x0038             MOVS     R0,R7
   \       0x24   0x.... 0x....      BL       Str_Len_N
   \       0x28   0x0001             MOVS     R1,R0
   1142            p_str_char += str_len;
   \       0x2A   0xEB07 0x0201      ADD      R2,R7,R1
   1143          
   1144          #if 0
   1145            if (p_str_char == DEF_NULL) {                                 // Rtn NULL if NULL ptr found (see Note #3b).
   1146              return (DEF_NULL);
   1147            }
   1148          #endif
   1149          
   1150            while ((p_str_char != p_str)                                  // Srch str from end until beginning (see Note #3c) ...
   1151                   && (*p_str_char != srch_char)) {                       // ... until srch char found (see Note #3d).
   \                     ??Str_Char_Last_N_3: (+1)
   \       0x2E   0x42A2             CMP      R2,R4
   \       0x30   0xD006             BEQ.N    ??Str_Char_Last_N_4
   \       0x32   0x7813             LDRB     R3,[R2, #+0]
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0x4283             CMP      R3,R0
   \       0x3A   0xD001             BEQ.N    ??Str_Char_Last_N_4
   1152              p_str_char--;
   \       0x3C   0x1E52             SUBS     R2,R2,#+1
   \       0x3E   0xE7F6             B.N      ??Str_Char_Last_N_3
   1153            }
   1154          
   1155            if (*p_str_char != srch_char) {                               // Rtn NULL if srch char NOT found (see Note #3c).
   \                     ??Str_Char_Last_N_4: (+1)
   \       0x40   0x7813             LDRB     R3,[R2, #+0]
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0x4283             CMP      R3,R0
   \       0x48   0xD001             BEQ.N    ??Str_Char_Last_N_5
   1156              return (DEF_NULL);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xE000             B.N      ??Str_Char_Last_N_1
   1157            }
   1158          
   1159            return ((CPU_CHAR *)p_str_char);                              // Else rtn ptr to found srch char (see Note #3d).
   \                     ??Str_Char_Last_N_5: (+1)
   \       0x4E   0x0010             MOVS     R0,R2
   \                     ??Str_Char_Last_N_1: (+1)
   \       0x50   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1160          }
   1161          
   1162          /****************************************************************************************************//**
   1163           *                                           Str_Char_Replace()
   1164           *
   1165           * @brief    Searches the string for specific character and replace it by another specific character.
   1166           *
   1167           * @param    p_str           Pointer to the string. This string will be modified.
   1168           *
   1169           * @param    char_srch       Search character.
   1170           *
   1171           * @param    char_replace    Replace character.
   1172           *
   1173           * @return   Pointer to the string, if NO error(s).
   1174           *           Pointer to NULL, otherwise.
   1175           *
   1176           * @note     (1) String search terminates when :
   1177           *               - (a) String pointer passed a NULL pointer. No string search performed. NULL pointer is
   1178           *                     returned.
   1179           *               - (b) String pointer points to NULL. String overlaps with NULL address. NULL pointer is
   1180           *                     returned.
   1181           *               - (c) String's terminating NULL character found. Search character NOT found in search
   1182           *                     string. NULL pointer is returned. Applicable even if search character is the
   1183           *                     terminating NULL character.
   1184           *               - (d) Search character found. Replace character found by the specified character.
   1185           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1186          CPU_CHAR *Str_Char_Replace(CPU_CHAR *p_str,
   1187                                     CPU_CHAR char_srch,
   1188                                     CPU_CHAR char_replace)
   1189          {
   \                     Str_Char_Replace: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   1190            CPU_CHAR *p_str_rtn;
   1191          
   1192            p_str_rtn = Str_Char_Replace_N(p_str,
   1193                                           char_srch,
   1194                                           char_replace,
   1195                                           DEF_INT_CPU_U_MAX_VAL);
   \        0x8   0xF05F 0x33FF      MOVS     R3,#+4294967295
   \        0xC   0x002A             MOVS     R2,R5
   \        0xE   0xB2D2             UXTB     R2,R2
   \       0x10   0x0021             MOVS     R1,R4
   \       0x12   0xB2C9             UXTB     R1,R1
   \       0x14   0x0030             MOVS     R0,R6
   \       0x16   0x.... 0x....      BL       Str_Char_Replace_N
   1196          
   1197            return (p_str_rtn);
   \       0x1A   0xBD70             POP      {R4-R6,PC}
   1198          }
   1199          
   1200          /****************************************************************************************************//**
   1201           *                                           Str_Char_Replace_N()
   1202           *
   1203           * @brief    Searches the string for specific character and replace it by another specific character,
   1204           *           up to a maximum number of characters.
   1205           *
   1206           * @param    p_str           Pointer to the string. This string will be modified.
   1207           *
   1208           * @param    char_srch       Search character.
   1209           *
   1210           * @param    char_replace    Replace character.
   1211           *
   1212           * @param    len_max         Maximum number of characters to search. 'len_max' number of characters
   1213           *                           MAY include terminating NULL character.
   1214           *
   1215           * @return      Pointer to the string, if NO error(s).
   1216           *              Pointer to NULL, otherwise.
   1217           *
   1218           * @note     (1) String search terminates when :
   1219           *               - (a) String pointer passed a NULL pointer. No string search performed. NULL pointer is
   1220           *                     returned.
   1221           *               - (b) String pointer points to NULL. String overlaps with NULL address. NULL pointer is
   1222           *                     returned.
   1223           *               - (c) String's terminating NULL character found. Search character NOT found in search
   1224           *                     string. NULL pointer is returned. Applicable even if search character is the
   1225           *                     terminating NULL character.
   1226           *               - (d) Search character found. Replace character found by the specified character.
   1227           *               - (e) 'len_max' number of characters searched. Search character NOT found in search
   1228           *                     string within first 'len_max' number of characters. NULL pointer is returned.
   1229           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1230          CPU_CHAR *Str_Char_Replace_N(CPU_CHAR   *p_str,
   1231                                       CPU_CHAR   char_srch,
   1232                                       CPU_CHAR   char_replace,
   1233                                       CPU_SIZE_T len_max)
   1234          {
   \                     Str_Char_Replace_N: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1235            CPU_CHAR   *p_str_char;
   1236            CPU_SIZE_T len;
   1237          
   1238            if (p_str == DEF_NULL) {                                      // Rtn NULL if srch str ptr NULL (see Note #2a).
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??Str_Char_Replace_N_0
   1239              return (DEF_NULL);
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE016             B.N      ??Str_Char_Replace_N_1
   1240            }
   1241          
   1242            if (len_max < 1) {                                            // Rtn NULL if srch len = 0 (see Note #2e).
   \                     ??Str_Char_Replace_N_0: (+1)
   \       0x10   0x2B00             CMP      R3,#+0
   \       0x12   0xD101             BNE.N    ??Str_Char_Replace_N_2
   1243              return (DEF_NULL);
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE012             B.N      ??Str_Char_Replace_N_1
   1244            }
   1245          
   1246            p_str_char = p_str;
   \                     ??Str_Char_Replace_N_2: (+1)
   \       0x18   0x0021             MOVS     R1,R4
   1247            len = len_max;
   \       0x1A   0x001A             MOVS     R2,R3
   1248          
   1249            while ((p_str_char != DEF_NULL)                               // Srch str until NULL ptr (see Note #2b) ...
   1250                   && (*p_str_char != ASCII_CHAR_NULL)                    // ... or NULL char (see Note #2c) ...
   1251                   && (len > 0)) {                                        // ... or max nbr chars srch'd (see Note #2e).
   \                     ??Str_Char_Replace_N_3: (+1)
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD00D             BEQ.N    ??Str_Char_Replace_N_4
   \       0x20   0x7808             LDRB     R0,[R1, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD00A             BEQ.N    ??Str_Char_Replace_N_4
   \       0x26   0x2A00             CMP      R2,#+0
   \       0x28   0xD008             BEQ.N    ??Str_Char_Replace_N_4
   1252              if (*p_str_char == char_srch) {
   \       0x2A   0x780F             LDRB     R7,[R1, #+0]
   \       0x2C   0x0028             MOVS     R0,R5
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x4287             CMP      R7,R0
   \       0x32   0xD100             BNE.N    ??Str_Char_Replace_N_5
   1253                *p_str_char = char_replace;                               // Replace char if srch char is found.
   \       0x34   0x700E             STRB     R6,[R1, #+0]
   1254              }
   1255          
   1256              p_str_char++;
   \                     ??Str_Char_Replace_N_5: (+1)
   \       0x36   0x1C49             ADDS     R1,R1,#+1
   1257              len--;
   \       0x38   0x1E52             SUBS     R2,R2,#+1
   \       0x3A   0xE7EF             B.N      ??Str_Char_Replace_N_3
   1258            }
   1259          
   1260            return (p_str);
   \                     ??Str_Char_Replace_N_4: (+1)
   \       0x3C   0x0020             MOVS     R0,R4
   \                     ??Str_Char_Replace_N_1: (+1)
   \       0x3E   0xBCF0             POP      {R4-R7}
   \       0x40   0x4770             BX       LR
   1261          }
   1262          
   1263          /****************************************************************************************************//**
   1264           *                                                   Str_Str()
   1265           *
   1266           * @brief    Searches a string for the first occurrence of a specific search string.
   1267           *
   1268           * @param    p_str       Pointer to a string. String buffer is NOT modified.
   1269           *
   1270           * @param    p_str_srch  Pointer to the search string. String buffer is NOT modified.
   1271           *
   1272           * @return   Pointer to the first occurrence of search string in the string, if any.
   1273           *           Pointer to the string, if search string has a zero length.
   1274           *           Pointer to NULL, otherwise.
   1275           *
   1276           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
   1277           *               "The strstr() function shall locate the first occurrence in the string pointed to by
   1278           *               's1' ('p_str') of the sequence of bytes [...] in the string pointed to by 's2'
   1279           *               ('p_str_srch') [...] (excluding the terminating null byte)."
   1280           *
   1281           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
   1282           *               "Upon successful completion, strstr() shall return [...] a pointer to the located
   1283           *               string [...] or a null pointer if the string is not found. [...] If 's2'
   1284           *               ('p_str_srch') points to a string with zero length, the function shall return 's1'
   1285           *               ('p_str')."
   1286           *               Although NO strstr() specification states to return NULL for any other reason(s),
   1287           *               NULL is also returned for any error(s).
   1288           *
   1289           * @note     (3) String search terminates when :
   1290           *               - (a) String pointer(s) are passed as NULL pointers. No string search performed. NULL
   1291           *                     pointer is returned.
   1292           *               - (b) String pointer(s) point to NULL. String buffer(s) overlap with NULL address. NULL
   1293           *                     pointer is returned.
   1294           *               - (c) for the first occurrence length equal to zero. No string search performed. String
   1295           *                     pointer returned.
   1296           *               - (d) Search string length greater than string length. No string search performed. NULL
   1297           *                     pointer returned.
   1298           *               - (e) Entire string has been searched. Search string not found. NULL pointer is
   1299           *                     returned.
   1300           *               - (f) Search string found. Return pointer to first occurrence of search string in
   1301           *                     string.
   1302           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1303          CPU_CHAR *Str_Str(const CPU_CHAR *p_str,
   1304                            const CPU_CHAR *p_str_srch)
   1305          {
   \                     Str_Str: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1306            CPU_CHAR *p_str_rtn;
   1307          
   1308            p_str_rtn = Str_Str_N(p_str,
   1309                                  p_str_srch,
   1310                                  DEF_INT_CPU_U_MAX_VAL);
   \        0x6   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       Str_Str_N
   1311          
   1312            return (p_str_rtn);
   \       0x12   0xBD32             POP      {R1,R4,R5,PC}
   1313          }
   1314          
   1315          /****************************************************************************************************//**
   1316           *                                               Str_Str_N()
   1317           *
   1318           * @brief    Searches the string for the first occurrence of a specific search string, up to a maximum
   1319           *           number of characters.
   1320           *
   1321           * @param    p_str       Pointer to a string. String buffer is NOT modified.
   1322           *
   1323           * @param    p_str_srch  Pointer to the search string. String buffer is NOT modified.
   1324           *
   1325           * @param    len_max     Maximum number of characters to search. 'len_max' number of characters does
   1326           *                       NOT include terminating NULL character.
   1327           *
   1328           * @return   Pointer to the first occurrence of search string in the string, if any.
   1329           *           Pointer to the string, if search string has a zero length.
   1330           *           Pointer to NULL, otherwise.
   1331           *
   1332           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
   1333           *               "The strstr() function shall locate the first occurrence  in the string pointed to by
   1334           *               's1' ('p_str') of the sequence of bytes [...] in the string pointed to by 's2'
   1335           *               ('p_str_srch') [...] (excluding the terminating null byte)."
   1336           *
   1337           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
   1338           *               "Upon successful completion, strstr() shall return [...] a pointer to the located
   1339           *               string [...] or a null pointer if the string is not found. [...] If 's2'
   1340           *               ('p_str_srch') points to a string with zero length, the function shall return 's1'
   1341           *               ('p_str')."
   1342           *               Although NO strstr() specification states to return NULL for any other reason(s),
   1343           *               NULL is also returned for any error(s).
   1344           *
   1345           * @note     (3) String search terminates when :
   1346           *               - (a) String pointer(s) are passed as NULL pointers. No string search performed. NULL
   1347           *                     pointer is returned.
   1348           *               - (b) String pointer(s) point to NULL. String buffer(s) overlap with NULL address. NULL
   1349           *                     pointer is returned.
   1350           *               - (c) for the first occurrence length equal to zero. No string search performed. String
   1351           *                     pointer returned.
   1352           *               - (d) Search string length greater than string length. No string search performed. NULL
   1353           *                     pointer returned.
   1354           *               - (e) Entire string has been searched. Search string not found. NULL pointer is
   1355           *                     returned.  The maximum size of the search is defined as the subtraction of the
   1356           *                     search string length from the string length.
   1357           *               - (f) Search string found. Return pointer to first occurrence of search string in
   1358           *                     string. Search string found via Str_Cmp_N().
   1359           *               - (g) 'len_max' number of characters searched.
   1360           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1361          CPU_CHAR *Str_Str_N(const CPU_CHAR *p_str,
   1362                              const CPU_CHAR *p_str_srch,
   1363                              CPU_SIZE_T     len_max)
   1364          {
   \                     Str_Str_N: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1365          #if 0
   1366            const CPU_CHAR *p_str_str;
   1367          #endif
   1368            CPU_SIZE_T     str_len;
   1369            CPU_SIZE_T     str_len_srch;
   1370            CPU_SIZE_T     len_max_srch;
   1371            CPU_SIZE_T     srch_len;
   1372            CPU_SIZE_T     srch_ix;
   1373            CPU_BOOLEAN    srch_done;
   1374            CPU_INT16S     srch_cmp;
   1375            const CPU_CHAR *p_str_srch_ix;
   1376          
   1377            //                                                               Rtn NULL if str ptr(s) NULL (see Note #3a).
   1378            if (p_str == DEF_NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??Str_Str_N_0
   1379              return (DEF_NULL);
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE049             B.N      ??Str_Str_N_1
   1380            }
   1381            if (p_str_srch == DEF_NULL) {
   \                     ??Str_Str_N_0: (+1)
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??Str_Str_N_2
   1382              return (DEF_NULL);
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE045             B.N      ??Str_Str_N_1
   1383            }
   1384          
   1385            if (len_max < 1) {                                            // Rtn NULL if srch len = 0 (see Note #3g).
   \                     ??Str_Str_N_2: (+1)
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD101             BNE.N    ??Str_Str_N_3
   1386              return (DEF_NULL);
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xE041             B.N      ??Str_Str_N_1
   1387            }
   1388          
   1389            //                                                               Lim max srch str len (to chk > str len).
   1390            len_max_srch = (len_max < DEF_INT_CPU_U_MAX_VAL)
   1391                           ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
   \                     ??Str_Str_N_3: (+1)
   \       0x22   0xF116 0x0F01      CMN      R6,#+1
   \       0x26   0xD002             BEQ.N    ??Str_Str_N_4
   \       0x28   0xF116 0x0801      ADDS     R8,R6,#+1
   \       0x2C   0xE001             B.N      ??Str_Str_N_5
   \                     ??Str_Str_N_4: (+1)
   \       0x2E   0xF05F 0x38FF      MOVS     R8,#+4294967295
   1392          
   1393            str_len = Str_Len_N(p_str, len_max);
   \                     ??Str_Str_N_5: (+1)
   \       0x32   0x0031             MOVS     R1,R6
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       Str_Len_N
   \       0x3A   0x4681             MOV      R9,R0
   1394            str_len_srch = Str_Len_N(p_str_srch, len_max_srch);
   \       0x3C   0x4641             MOV      R1,R8
   \       0x3E   0x0028             MOVS     R0,R5
   \       0x40   0x.... 0x....      BL       Str_Len_N
   \       0x44   0x0007             MOVS     R7,R0
   1395            if (str_len_srch < 1) {                                       // Rtn ptr to str if srch str len = 0 (see Note #2).
   \       0x46   0x2F00             CMP      R7,#+0
   \       0x48   0xD101             BNE.N    ??Str_Str_N_6
   1396              return ((CPU_CHAR *)p_str);
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0xE02B             B.N      ??Str_Str_N_1
   1397            }
   1398            if (str_len_srch > str_len) {                                 // Rtn NULL if srch str len > str len (see Note #3d).
   \                     ??Str_Str_N_6: (+1)
   \       0x4E   0x45B9             CMP      R9,R7
   \       0x50   0xD201             BCS.N    ??Str_Str_N_7
   1399              return (DEF_NULL);
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xE027             B.N      ??Str_Str_N_1
   1400            }
   1401          
   1402          #if 0
   1403            //                                                               Rtn NULL if NULL ptr found (see Note #3b).
   1404            p_str_str = p_str + str_len;
   1405            if (p_str_str == DEF_NULL) {
   1406              return (DEF_NULL);
   1407            }
   1408            p_str_str = p_str_srch + str_len_srch;
   1409            if (p_str_str == DEF_NULL) {
   1410              return (DEF_NULL);
   1411            }
   1412          #endif
   1413          
   1414            srch_len = str_len - str_len_srch;                            // Calc srch len (see Note #3e).
   \                     ??Str_Str_N_7: (+1)
   \       0x56   0xEBB9 0x0007      SUBS     R0,R9,R7
   \       0x5A   0x9002             STR      R0,[SP, #+8]
   1415            srch_ix = 0u;
   \       0x5C   0xF05F 0x0A00      MOVS     R10,#+0
   1416          
   1417            do {
   1418              p_str_srch_ix = (const CPU_CHAR *)(p_str + srch_ix);
   \                     ??Str_Str_N_8: (+1)
   \       0x60   0xEB04 0x000A      ADD      R0,R4,R10
   \       0x64   0x9001             STR      R0,[SP, #+4]
   1419              srch_cmp = Str_Cmp_N(p_str_srch_ix, p_str_srch, str_len_srch);
   \       0x66   0x003A             MOVS     R2,R7
   \       0x68   0x0029             MOVS     R1,R5
   \       0x6A   0x9801             LDR      R0,[SP, #+4]
   \       0x6C   0x.... 0x....      BL       Str_Cmp_N
   \       0x70   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1420              srch_done = (srch_cmp == 0) ? DEF_YES : DEF_NO;
   \       0x74   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD102             BNE.N    ??Str_Str_N_9
   \       0x7C   0xF05F 0x0B01      MOVS     R11,#+1
   \       0x80   0xE001             B.N      ??Str_Str_N_10
   \                     ??Str_Str_N_9: (+1)
   \       0x82   0xF05F 0x0B00      MOVS     R11,#+0
   1421              srch_ix++;
   \                     ??Str_Str_N_10: (+1)
   \       0x86   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1422            } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
   \       0x8A   0x4658             MOV      R0,R11
   \       0x8C   0xB2C0             UXTB     R0,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD102             BNE.N    ??Str_Str_N_11
   \       0x92   0x9802             LDR      R0,[SP, #+8]
   \       0x94   0x4550             CMP      R0,R10
   \       0x96   0xD2E3             BCS.N    ??Str_Str_N_8
   1423          
   1424            if (srch_cmp != 0) {                                          // Rtn NULL if srch str NOT found (see Note #3e).
   \                     ??Str_Str_N_11: (+1)
   \       0x98   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD001             BEQ.N    ??Str_Str_N_12
   1425              return (DEF_NULL);
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0xE000             B.N      ??Str_Str_N_1
   1426            }
   1427          
   1428            return ((CPU_CHAR *)p_str_srch_ix);                           // Else rtn ptr to found srch str (see Note #3f).
   \                     ??Str_Str_N_12: (+1)
   \       0xA4   0x9801             LDR      R0,[SP, #+4]
   \                     ??Str_Str_N_1: (+1)
   \       0xA6   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1429          }
   1430          
   1431          /****************************************************************************************************//**
   1432           *                                           Str_FmtNbr_Int32U()
   1433           *
   1434           * @brief    Formats a 32-bit unsigned integer into a multi-digit character string.
   1435           *
   1436           * @param    nbr         Number to format.
   1437           *
   1438           * @param    nbr_dig     Number of digits to format.
   1439           *                       The following may be used to specify the number of digits to format :
   1440           *                           - DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
   1441           *                           - DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
   1442           *
   1443           * @param    nbr_base    Base of number to format. The number's base MUST be between 2 and 36,
   1444           *                       inclusively.
   1445           *                       The following may be used to specify the number base :
   1446           *                           - DEF_NBR_BASE_BIN            Base  2
   1447           *                           - DEF_NBR_BASE_OCT            Base  8
   1448           *                           - DEF_NBR_BASE_DEC            Base 10
   1449           *                           - DEF_NBR_BASE_HEX            Base 16
   1450           *
   1451           * @param    lead_char   Prepend leading character. Leading character option prepends leading
   1452           *                       characters prior to the first non-zero digit. Leading character MUST be a
   1453           *                       printable ASCII character. Leading character MUST NOT be a number base digit,
   1454           *                       with the exception of '0'.
   1455           *                           - '\0'                    Do NOT prepend leading character to the string.
   1456           *                           - Printable character     Prepend leading character to the string.
   1457           *                           - Unprintable character   Format invalid string.
   1458           *
   1459           * @param    lower_case  Format alphabetic characters (if any) in lower case :
   1460           *                           - DEF_NO          Format alphabetic characters in upper case.
   1461           *                           - DEF_YES         Format alphabetic characters in lower case.
   1462           *
   1463           * @param    nul         Append terminating NULL-character. NULL-character terminate option DISABLED
   1464           *                       prevents overwriting previous character array formatting. Unless 'p_str'
   1465           *                       character array is pre-/post-terminated, NULL-character terminate option
   1466           *                       DISABLED will cause character string run-on.
   1467           *                           - DEF_NO          Do NOT append terminating NULL-character to the string.
   1468           *                           - DEF_YES         Append terminating NULL-character to the string.
   1469           *
   1470           * @param    p_str       Pointer to the character array to return formatted number string. Format
   1471           *                       buffer size is NOT validated; buffer overruns MUST be prevented by caller.
   1472           *                       To prevent character buffer overrun, character array size MUST be >=
   1473           *                       ('nbr_dig' + 1 'NUL' terminator) characters.
   1474           *
   1475           * @return   Pointer to the formatted string, if NO error(s).
   1476           *           Pointer to NULL, otherwise.
   1477           *
   1478           * @note     (1) See Str_FmtNbr_Int32()'s notes.
   1479           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1480          CPU_CHAR *Str_FmtNbr_Int32U(CPU_INT32U  nbr,
   1481                                      CPU_INT08U  nbr_dig,
   1482                                      CPU_INT08U  nbr_base,
   1483                                      CPU_CHAR    lead_char,
   1484                                      CPU_BOOLEAN lower_case,
   1485                                      CPU_BOOLEAN nul,
   1486                                      CPU_CHAR    *p_str)
   1487          {
   \                     Str_FmtNbr_Int32U: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1488            CPU_CHAR *p_str_fmt;
   1489          
   1490            p_str_fmt = Str_FmtNbr_Int32(nbr,                             // Fmt unsigned int into str.
   1491                                         nbr_dig,
   1492                                         nbr_base,
   1493                                         DEF_NO,
   1494                                         lead_char,
   1495                                         lower_case,
   1496                                         nul,
   1497                                         p_str);
   \        0xC   0x980C             LDR      R0,[SP, #+48]
   \        0xE   0x9003             STR      R0,[SP, #+12]
   \       0x10   0xF89D 0x002C      LDRB     R0,[SP, #+44]
   \       0x14   0x9002             STR      R0,[SP, #+8]
   \       0x16   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \       0x1A   0x9001             STR      R0,[SP, #+4]
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x0032             MOVS     R2,R6
   \       0x26   0xB2D2             UXTB     R2,R2
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0xB2C9             UXTB     R1,R1
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       Str_FmtNbr_Int32
   1498          
   1499            return (p_str_fmt);
   \       0x32   0xB005             ADD      SP,SP,#+20
   \       0x34   0xBDF0             POP      {R4-R7,PC}
   1500          }
   1501          
   1502          /****************************************************************************************************//**
   1503           *                                           Str_FmtNbr_Int32S()
   1504           *
   1505           * @brief    Formats a 32-bit signed integer into a multi-digit character string.
   1506           *
   1507           * @param    nbr         Number to format.
   1508           *
   1509           * @param    nbr_dig     Number of digits to format.
   1510           *                       The following may be used to specify the number of digits to format :
   1511           *                           - DEF_INT_32S_NBR_DIG_MIN + 1     Minimum number of 32-bit signed digits
   1512           *                           - DEF_INT_32S_NBR_DIG_MAX + 1     Maximum number of 32-bit signed digits
   1513           *                       (plus 1 digit for possible negative sign)
   1514           *
   1515           * @param    nbr_base    Base of number to format. The number's base MUST be between 2 and 36,
   1516           *                       inclusively.
   1517           *                       The following may be used to specify the number base :
   1518           *                           - DEF_NBR_BASE_BIN            Base  2
   1519           *                           - DEF_NBR_BASE_OCT            Base  8
   1520           *                           - DEF_NBR_BASE_DEC            Base 10
   1521           *                           - DEF_NBR_BASE_HEX            Base 16
   1522           *
   1523           * @param    lead_char   Prepend leading character. Leading character option prepends leading
   1524           *                       characters prior to the first non-zero digit. Leading character MUST be a
   1525           *                       printable ASCII character. Leading character MUST NOT be a number base digit,
   1526           *                       with the exception of '0'.
   1527           *                           -  '\0'                    Do NOT prepend leading character to the string.
   1528           *                           -  Printable character     Prepend leading character to the string.
   1529           *                           -  Unprintable character   Format invalid string.
   1530           *
   1531           * @param    lower_case  Format alphabetic characters (if any) in lower case :
   1532           *                           - DEF_NO          Format alphabetic characters in upper case.
   1533           *                           - DEF_YES         Format alphabetic characters in lower case.
   1534           *
   1535           * @param    nul         Append terminating NULL-character. NULL-character terminate option DISABLED
   1536           *                       prevents overwriting previous character array formatting. Unless 'p_str'
   1537           *                       character array is pre-/post-terminated, NULL-character terminate option
   1538           *                       DISABLED will cause character string run-on.
   1539           *                           - DEF_NO          Do NOT append terminating NULL-character to the string.
   1540           *                           - DEF_YES         Append terminating NULL-character to the string.
   1541           *
   1542           * @param    p_str       Pointer to the character array to return formatted number string. Format
   1543           *                       buffer size is NOT validated; buffer overruns MUST be prevented by caller.
   1544           *                       To prevent character buffer overrun, character array size MUST be >=
   1545           *                       ('nbr_dig' + 1 negative sign + 1 'NUL' terminator) characters.
   1546           *
   1547           * @return   Pointer to the formatted string, if NO error(s).
   1548           *           Pointer to NULL, otherwise.
   1549           *
   1550           * @note     (1) See Str_FmtNbr_Int32()'s notes.
   1551           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1552          CPU_CHAR *Str_FmtNbr_Int32S(CPU_INT32S  nbr,
   1553                                      CPU_INT08U  nbr_dig,
   1554                                      CPU_INT08U  nbr_base,
   1555                                      CPU_CHAR    lead_char,
   1556                                      CPU_BOOLEAN lower_case,
   1557                                      CPU_BOOLEAN nul,
   1558                                      CPU_CHAR    *p_str)
   1559          {
   \                     Str_FmtNbr_Int32S: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x4699             MOV      R9,R3
   1560            CPU_CHAR    *p_str_fmt;
   1561            CPU_INT32S  nbr_fmt;
   1562            CPU_BOOLEAN nbr_neg;
   1563          
   1564            if (nbr < 0) {                                                // If nbr neg, ...
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD503             BPL.N    ??Str_FmtNbr_Int32S_0
   1565              nbr_fmt = -nbr;                                             // ... negate nbr.
   \       0x12   0x4267             RSBS     R7,R4,#+0
   1566              nbr_neg = DEF_YES;
   \       0x14   0xF05F 0x0801      MOVS     R8,#+1
   \       0x18   0xE002             B.N      ??Str_FmtNbr_Int32S_1
   1567            } else {
   1568              nbr_fmt = nbr;
   \                     ??Str_FmtNbr_Int32S_0: (+1)
   \       0x1A   0x0027             MOVS     R7,R4
   1569              nbr_neg = DEF_NO;
   \       0x1C   0xF05F 0x0800      MOVS     R8,#+0
   1570            }
   1571          
   1572            p_str_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,             // Fmt signed int into str.
   1573                                         nbr_dig,
   1574                                         nbr_base,
   1575                                         nbr_neg,
   1576                                         lead_char,
   1577                                         lower_case,
   1578                                         nul,
   1579                                         p_str);
   \                     ??Str_FmtNbr_Int32S_1: (+1)
   \       0x20   0x980E             LDR      R0,[SP, #+56]
   \       0x22   0x9003             STR      R0,[SP, #+12]
   \       0x24   0xF89D 0x0034      LDRB     R0,[SP, #+52]
   \       0x28   0x9002             STR      R0,[SP, #+8]
   \       0x2A   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \       0x2E   0x9001             STR      R0,[SP, #+4]
   \       0x30   0x4648             MOV      R0,R9
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x4643             MOV      R3,R8
   \       0x38   0xB2DB             UXTB     R3,R3
   \       0x3A   0x0032             MOVS     R2,R6
   \       0x3C   0xB2D2             UXTB     R2,R2
   \       0x3E   0x0029             MOVS     R1,R5
   \       0x40   0xB2C9             UXTB     R1,R1
   \       0x42   0x0038             MOVS     R0,R7
   \       0x44   0x.... 0x....      BL       Str_FmtNbr_Int32
   1580          
   1581            return (p_str_fmt);
   \       0x48   0xB005             ADD      SP,SP,#+20
   \       0x4A   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1582          }
   1583          
   1584          /****************************************************************************************************//**
   1585           *                                               Str_FmtNbr_32()
   1586           *
   1587           * @brief    Formats a number into a multi-digit character string.
   1588           *
   1589           * @param    nbr         Number to format.
   1590           *
   1591           * @param    nbr_dig     Number of decimal digits to format (see Note #2).
   1592           *
   1593           * @param    nbr_dp      Number of decimal point digits to format.
   1594           *
   1595           * @param    lead_char   Prepend leading character. Leading character option prepends leading
   1596           *                       characters prior to the first non-zero digit. Leading character MUST be a
   1597           *                       printable ASCII character. Leading character MUST NOT be a number base digit,
   1598           *                       with the exception of '0'.
   1599           *                           - '\0'                    Do NOT prepend leading character to the string.
   1600           *                           - Printable character     Prepend leading character to the string.
   1601           *                           - Unprintable character   Format invalid string.
   1602           *
   1603           * @param    nul         Append terminating NULL-character. NULL-character terminate option DISABLED
   1604           *                       prevents overwriting previous character array formatting. Unless 'p_str'
   1605           *                       character array is pre-/post-terminated, NULL-character terminate option
   1606           *                       DISABLED will cause character string run-on.
   1607           *                           - DEF_NO          Do NOT append terminating NULL-character to the string.
   1608           *                           - DEF_YES         Append terminating NULL-character to the string.
   1609           *
   1610           * @param    p_str       Pointer to the character array to return formatted number string. Format
   1611           *                       buffer size is NOT validated; buffer overruns MUST be prevented by caller.
   1612           *                       To prevent character buffer overrun, character array size MUST be >=
   1613           *                       ('nbr_dig' + 'nbr_dp' + 1 negative sign + 1 decimal point + 1 'NUL'
   1614           *                       terminator) characters.
   1615           *
   1616           * @return   Pointer to the formatted string, if NO error(s)..
   1617           *           Pointer to NULL, otherwise.
   1618           *
   1619           * @note     (1) The maximum accuracy for 32-bit floating-point numbers :
   1620           *               @verbatim
   1621           *                           Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
   1622           *                       32-bit Floating-point Number  =  -----------------------------------------------------
   1623           *                                                                       log [External-Base]
   1624           *
   1625           *                                                       log [2 ^ 24]
   1626           *                                                   =  --------------
   1627           *                                                           log [10]
   1628           *
   1629           *                                                   <  7.225  Base-10 Digits
   1630           *
   1631           *                           where
   1632           *                                   Internal-Base                   Internal number base of floating-
   1633           *                                                                       point numbers (i.e.  2)
   1634           *                                   External-Base                   External number base of floating-
   1635           *                                                                       point numbers (i.e. 10)
   1636           *                                   Number-Internal-Base-Digits     Number of internal number base
   1637           *                                                                       significant digits (i.e. 24)
   1638           *               @endverbatim
   1639           *               Some CPUs' &/or compilers' floating-point implementations MAY further reduce the
   1640           *               maximum accuracy.
   1641           *
   1642           * @note     (2) See usage examples below.
   1643           *           - (a) If the total number of digits to format ('nbr_dig + nbr_dp') is zero; then NO
   1644           *                   formatting is performed except possible NULL-termination of the string.
   1645           *                       Example :
   1646           *           @verbatim
   1647           *                           nbr     = -23456.789
   1648           *                           nbr_dig =  0
   1649           *                           nbr_dp  =  0
   1650           *
   1651           *                           p_str   = ""                        See Note #4a
   1652           *           @endverbatim
   1653           *           - (b) If the number of digits to format ('nbr_dig') is less than the number of
   1654           *                   significant integer digits of the number to format ('nbr'); then an invalid
   1655           *                   string is formatted instead of truncating any significant integer digits.
   1656           *                       Example :
   1657           *           @verbatim
   1658           *                           nbr     = 23456.789
   1659           *                           nbr_dig = 3
   1660           *                           nbr_dp  = 2
   1661           *
   1662           *                           p_str   = "??????"                  See Note #4d
   1663           *           @endverbatim
   1664           *           - (c) If the number to format ('nbr') is negative but the number of digits to format
   1665           *                   ('nbr_dig') is equal to the number of significant integer digits of the number to
   1666           *                   format ('nbr'); then an invalid string is formatted instead of truncating the
   1667           *                   negative sign.
   1668           *                       Example :
   1669           *           @verbatim
   1670           *                           nbr     = -23456.789
   1671           *                           nbr_dig =  5
   1672           *                           nbr_dp  =  2
   1673           *
   1674           *                           p_str   = "????????"                See Note #4d
   1675           *           @endverbatim
   1676           *           - (d) If the number to format ('nbr') is negative but the number of significant integer
   1677           *                   digits is zero, and the number of digits to format ('nbr_dig') is one but the
   1678           *                   number of decimal point digits to format ('nbr_dp') is zero; then an invalid
   1679           *                   string is formatted instead of truncating the negative sign.
   1680           *                       Example :
   1681           *           @verbatim
   1682           *                           nbr     = -0.7895
   1683           *                           nbr_dig =  1
   1684           *                           nbr_dp  =  0
   1685           *
   1686           *                           p_str   = "?"                       See Note #4d
   1687           *           @endverbatim
   1688           *           - (e) If the number to format ('nbr') is negative but the number of significant integer
   1689           *                   digits is zero, and the number of digits to format ('nbr_dig') is zero but the
   1690           *                   number of decimal point digits to format ('nbr_dp') is non-zero; then the
   1691           *                   negative sign immediately prefixes the decimal point -- with NO decimal digits
   1692           *                   formatted, NOT even a single decimal digit of '0'.
   1693           *                       Example :
   1694           *           @verbatim
   1695           *                           nbr     = -0.7895
   1696           *                           nbr_dig =  0
   1697           *                           nbr_dp  =  2
   1698           *
   1699           *                           p_str   = "-.78"
   1700           *           @endverbatim
   1701           *           - (f) If the number to format ('nbr') is positive but the number of significant integer
   1702           *                   digits is zero, and the number of digits to format ('nbr_dig') is zero but the
   1703           *                   number of decimal point digits to format ('nbr_dp') is non-zero; then a single
   1704           *                   decimal digit of '0' prefixes the decimal point.
   1705           *                   This '0' digit is used whenever a negative sign is not formatted so that the
   1706           *                   formatted string's decimal point is not floating, but fixed in the string as the
   1707           *                   second character.
   1708           *                       Example :
   1709           *           @verbatim
   1710           *                           nbr     =  0.7895
   1711           *                           nbr_dig =  0
   1712           *                           nbr_dp  =  2
   1713           *
   1714           *                           p_str   = "0.78"
   1715           *           @endverbatim
   1716           *           - (g) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than :
   1717           *                   the maximum accuracy of the CPU's &/or compiler's 32-bit floating-point numbers,
   1718           *                   digits following all significantly-accurate digits of the number to format
   1719           *                   ('nbr') will be inaccurate. The configured maximum accuracy
   1720           *                   ('LIB_STR_CFG_FP_MAX_NBR_DIG_SIG'), all digits or decimal places following all
   1721           *                   significantly-accurate digits of the number to format ('nbr') will be replaced &
   1722           *                   formatted with zeros ('0').
   1723           *                       Example :
   1724           *           @verbatim
   1725           *                           nbr                            = 123456789.012345
   1726           *                           nbr_dig                        = 9
   1727           *                           nbr_dp                         = 6
   1728           *                           LIB_STR_CFG_FP_MAX_NBR_DIG_SIG = 7
   1729           *
   1730           *                           p_str                          = "123456700.000000"
   1731           *           @endverbatim
   1732           *                   Therefore, one or more least-significant digit(s) of the number to format ('nbr')
   1733           *                   MAY be rounded & not necessarily truncated due to the inaccuracy of the CPU's
   1734           *                   &/or compiler's floating-point implementation.
   1735           *
   1736           * @note     (3) String format terminates when :
   1737           *               - (a) Format string pointer is passed a NULL pointer. No string formatted; NULL pointer
   1738           *                     is returned.
   1739           *               - (b) Total number of digits to format ('nbr_dig + nbr_dp') is zero. NULL string
   1740           *                     formatted. NULL pointer is returned.
   1741           *               - (c) Number of digits to format ('nbr_dig') is less than number of significant integer
   1742           *                     digits of the number to format ('nbr'), including possible negative sign. Invalid
   1743           *                     string formatted. NULL pointer is returned.
   1744           *               - (d) Lead character is NOT a valid, printable character. Invalid string formatted.
   1745           *                     NULL pointer is returned.
   1746           *               - (e) Number successfully formatted into character string array.
   1747           *
   1748           * @note     (4) For any unsuccessful string format or error(s), an invalid string of question marks
   1749           *               ('?') will be formatted, where the number of question marks is determined by the
   1750           *               number of digits ('nbr_dig') & number of decimal point digits ('nbr_dp') to format :
   1751           *               @verbatim
   1752           *                                       {  (a)    0 (NULL string)          ,  if 'nbr_dig' = 0  AND
   1753           *                                       {                                        'nbr_dp'  = 0
   1754           *                                       {
   1755           *                                       {  (b)   'nbr_dig'                 ,  if 'nbr_dig' > 0  AND
   1756           *                                       {                                        'nbr_dp'  = 0
   1757           *                  Invalid string's     {
   1758           *                      number of     =  {  (c)  ['nbr_dp'               +  ,  if 'nbr_dig' = 0  AND
   1759           *                   question marks      {         1 (for decimal point) +        'nbr_dp'  > 0
   1760           *                                       {         1 (for negative sign) ]
   1761           *                                       {
   1762           *                                       {  (d)  ['nbr_dig'              +  ,  if 'nbr_dig' > 0  AND
   1763           *                                       {        'nbr_dp'               +        'nbr_dp'  > 0
   1764           *                                       {         1 (for decimal point) ]
   1765           *               @endverbatim
   1766           *******************************************************************************************************/
   1767          
   1768          #if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
   1769          CPU_CHAR *Str_FmtNbr_32(CPU_FP32    nbr,
   1770                                  CPU_INT08U  nbr_dig,
   1771                                  CPU_INT08U  nbr_dp,
   1772                                  CPU_CHAR    lead_char,
   1773                                  CPU_BOOLEAN nul,
   1774                                  CPU_CHAR    *p_str)
   1775          {
   1776            CPU_CHAR    *p_str_fmt;
   1777            CPU_DATA    i;
   1778            CPU_FP32    nbr_fmt;
   1779            CPU_FP32    nbr_log;
   1780            CPU_INT32U  nbr_shiftd;
   1781            CPU_INT16U  nbr_dig_max;
   1782            CPU_INT16U  nbr_dig_sig = 0;
   1783            CPU_INT08U  nbr_neg_sign;
   1784            CPU_INT08U  dig_val;
   1785            CPU_FP32    dig_exp;
   1786            CPU_FP32    dp_exp;
   1787            CPU_BOOLEAN lead_char_dig;
   1788            CPU_BOOLEAN lead_char_fmtd = DEF_NO;
   1789            CPU_BOOLEAN lead_char_0;
   1790            CPU_BOOLEAN fmt_invalid;
   1791            CPU_BOOLEAN print_char;
   1792            CPU_BOOLEAN nbr_neg;
   1793            CPU_BOOLEAN nbr_neg_fmtd = DEF_NO;
   1794          
   1795            //                                                               ---------------- VALIDATE FMT ARGS -----------------
   1796            if (p_str == DEF_NULL) {                                      // Rtn NULL if str ptr NULL (see Note #3a).
   1797              return (DEF_NULL);
   1798            }
   1799          
   1800            dig_exp = 1.0f;
   1801            fmt_invalid = DEF_NO;
   1802            lead_char_0 = (lead_char == '0') ? DEF_YES : DEF_NO;          // Chk if lead char a '0' dig.
   1803            nbr_fmt = 0.0f;
   1804            nbr_neg = DEF_NO;
   1805          
   1806            if ((nbr_dig < 1) && (nbr_dp < 1)) {                          // If nbr digs/dps = 0, ...
   1807              fmt_invalid = DEF_YES;                                      // ... fmt invalid str (see Note #3b).
   1808            }
   1809          
   1810            if (lead_char != (CPU_CHAR)'\0') {
   1811              print_char = ASCII_IsPrint(lead_char);
   1812              if (print_char != DEF_YES) {                                // If lead char non-printable, ...
   1813                fmt_invalid = DEF_YES;                                    // ... fmt invalid str (see Note #3d).
   1814              } else if (lead_char != '0') {                              // Chk lead char for non-0 dig.
   1815                lead_char_dig = ASCII_IsDig(lead_char);
   1816                if (lead_char_dig == DEF_YES) {                           // If lead char non-0 dig, ...
   1817                  fmt_invalid = DEF_YES;                                  // ... fmt invalid str (see Note #3d).
   1818                }
   1819              }
   1820            }
   1821          
   1822            //                                                               ----------------- PREPARE NBR FMT ------------------
   1823            p_str_fmt = p_str;
   1824          
   1825            if (fmt_invalid == DEF_NO) {
   1826              if (nbr < 0.0f) {                                           // If nbr neg, ...
   1827                nbr_fmt = -nbr;                                           // ... negate nbr.
   1828                nbr_neg_sign = 1u;
   1829                nbr_neg = DEF_YES;
   1830              } else {
   1831                nbr_fmt = nbr;
   1832                nbr_neg_sign = 0u;
   1833                nbr_neg = DEF_NO;
   1834              }
   1835          
   1836              nbr_log = nbr_fmt;
   1837              nbr_dig_max = 0u;
   1838              while (nbr_log >= 1.0f) {                                   // While base-10 digs avail, ...
   1839                nbr_dig_max++;                                            // ... calc max nbr digs.
   1840                nbr_log /= 10.0f;
   1841              }
   1842          
   1843              if (((nbr_dig >= (nbr_dig_max + nbr_neg_sign))              // If req'd nbr digs >= (max nbr digs + neg sign)    ..
   1844                   || (nbr_dig_max < 1))                                  // .. or NO nbr digs,                                ..
   1845                  && ((nbr_dig > 1)                                       // .. but NOT [(req'd nbr dig = 1) AND               ..
   1846                      || (nbr_dp > 0)                                     // ..          (req'd nbr dp  = 0) AND               ..
   1847                      || (nbr_neg == DEF_NO))) {                          // ..          (      nbr neg    )]   (see Note #2d).
   1848                                                                          // .. prepare nbr digs to fmt.
   1849                for (i = 1u; i < nbr_dig; i++) {
   1850                  dig_exp *= 10.0f;
   1851                }
   1852          
   1853                nbr_neg_fmtd = DEF_NO;
   1854                nbr_dig_sig = 0u;
   1855                lead_char_fmtd = DEF_NO;
   1856              } else {                                                    // Else if nbr trunc'd, ...
   1857                fmt_invalid = DEF_YES;                                    // ... fmt invalid str (see Note #3c).
   1858              }
   1859            }
   1860          
   1861            //                                                               ------------------- FMT NBR STR --------------------
   1862            for (i = nbr_dig; i > 0; i--) {                               // Fmt str for desired nbr digs :
   1863              if (fmt_invalid == DEF_NO) {
   1864                if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {       // If nbr sig digs < max, fmt str digs; ...
   1865                  nbr_shiftd = (CPU_INT32U)(nbr_fmt / dig_exp);
   1866                  if ((nbr_shiftd > 0)                                    // If shifted nbr > 0 ...
   1867                      || (i == 1u)) {                                     // ... OR on one's dig to fmt, ...
   1868                                                                          // ... calc & fmt dig val; ...
   1869                    if ((nbr_neg == DEF_YES)                              // If  nbr neg ...
   1870                        && (nbr_neg_fmtd == DEF_NO)) {                    // ... but neg sign NOT yet fmt'd; ...
   1871                      if (lead_char_fmtd == DEF_YES) {                    // ... & if lead char(s) fmt'd, ...
   1872                        p_str_fmt--;                                      // ... replace last lead char w/ ...
   1873                      }
   1874                      *p_str_fmt++ = '-';                                 // ... prepend neg sign (see Note #2b).
   1875                      nbr_neg_fmtd = DEF_YES;
   1876                    }
   1877          
   1878                    if (nbr_shiftd > 0) {                                 // If shifted nbr > 0, ...
   1879                      dig_val = (CPU_INT08U)(nbr_shiftd % 10u);
   1880                      *p_str_fmt++ = (CPU_CHAR)(dig_val    + '0');
   1881          
   1882                      nbr_dig_sig++;                                      // ... inc nbr sig digs; ...
   1883                    } else if ((nbr_dig > 1)                              // ... else if req'd digs > 1 ...
   1884                               || (nbr_neg == DEF_NO)) {                  // ... or non-neg nbr, ...
   1885                      *p_str_fmt++ = '0';                                 // ... fmt one '0' char.
   1886                    }
   1887                  } else if ((nbr_neg == DEF_YES)                         // ... else if nbr neg ...
   1888                             && (lead_char_0 == DEF_YES)                  // ... & lead char a '0' dig ...
   1889                             && (nbr_neg_fmtd == DEF_NO)) {               // ... but neg sign NOT yet fmt'd, ...
   1890                    *p_str_fmt++ = '-';                                   // ... prepend neg sign; ...
   1891                    nbr_neg_fmtd = DEF_YES;
   1892                  } else if (lead_char != (CPU_CHAR)'\0') {               // ... else if avail, ...
   1893                    *p_str_fmt++ = lead_char;                             // ... fmt lead char.
   1894                    lead_char_fmtd = DEF_YES;
   1895                  }
   1896          
   1897                  dig_exp /= 10.0f;                                       // Shift to next least-sig dig.
   1898                } else {                                                  // ... else append non-sig 0's (see Note #2h).
   1899                  *p_str_fmt++ = '0';
   1900                }
   1901              } else {                                                    // Else fmt '?' for invalid str (see Note #4).
   1902                *p_str_fmt++ = '?';
   1903              }
   1904            }
   1905          
   1906            if (nbr_dp > 0) {                                             // Fmt str for desired nbr dp :
   1907              if (nbr_dig < 1) {                                          // If NO digs fmt'd; ...
   1908                if (fmt_invalid == DEF_NO) {                              // ... nbr fmt valid, ...
   1909                  if ((nbr_neg == DEF_YES)                                // ... nbr neg ...
   1910                      && (nbr_neg_fmtd == DEF_NO)) {                      // ... but neg sign NOT yet fmt'd, ...
   1911                    *p_str_fmt++ = '-';                                   // ... prepend neg sign (see Note #2b); ...
   1912                  } else {                                                // ... else prepend 1 dig of '0' ...
   1913                    *p_str_fmt++ = '0';
   1914                  }
   1915                } else {                                                  // ... else fmt '?' for invalid str (see Note #4).
   1916                  *p_str_fmt++ = '?';
   1917                }
   1918              }
   1919          
   1920              if (fmt_invalid == DEF_NO) {                                // If nbr fmt valid, ...
   1921                *p_str_fmt++ = '.';                                       // ... append dp prior to dp conversion.
   1922              } else {                                                    // Else fmt '?' for invalid str (see Note #4).
   1923                *p_str_fmt++ = '?';
   1924              }
   1925          
   1926              dp_exp = 10.0f;
   1927              for (i = 0u; i < nbr_dp; i++) {
   1928                if (fmt_invalid == DEF_NO) {
   1929                  //                                                         If nbr sig digs < max, fmt str dps; ...
   1930                  if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {
   1931                    nbr_shiftd = (CPU_INT32U)(nbr_fmt * dp_exp);
   1932                    dig_val = (CPU_INT08U)(nbr_shiftd % 10u);
   1933                    *p_str_fmt++ = (CPU_CHAR)(dig_val    + '0');
   1934                    dp_exp *= 10.0f;                                      // Shift to next least-sig dp.
   1935          
   1936                    if ((nbr_shiftd > 0)                                  // If shifted nbr > 0 ...
   1937                        || (nbr_dig_sig > 0)) {                           // ... OR  > 0 sig digs already fmt'd, ...
   1938                      nbr_dig_sig++;                                      // ... inc nbr sig digs.
   1939                    }
   1940                  } else {                                                // ... else append non-sig 0's (see Note #2c2).
   1941                    *p_str_fmt++ = '0';
   1942                  }
   1943                } else {                                                  // Else fmt '?' for invalid str (see Note #4).
   1944                  *p_str_fmt++ = '?';
   1945                }
   1946              }
   1947            }
   1948          
   1949            if (nul != DEF_NO) {                                          // If NOT DISABLED, append NULL char.
   1950              *p_str_fmt = (CPU_CHAR)'\0';
   1951            }
   1952          
   1953            if (fmt_invalid != DEF_NO) {                                  // Rtn NULL for invalid str fmt (see Notes #3a - #3d).
   1954              return (DEF_NULL);
   1955            }
   1956          
   1957            return (p_str);                                               // Rtn ptr to fmt'd str (see Note #3e).
   1958          }
   1959          #endif
   1960          
   1961          /****************************************************************************************************//**
   1962           *                                           Str_ParseNbr_Int32U()
   1963           *
   1964           * @brief    Parses a 32-bit unsigned integer from a string.
   1965           *
   1966           * @param    p_str       Pointer to the string. String buffer NOT modified.
   1967           *
   1968           * @param    p_str_next  Optional pointer to a variable to :
   1969           *                       Return a pointer to first character following the integer string, if NO
   1970           *                       error(s);
   1971           *                       Return a pointer to 'p_str', otherwise.
   1972           *
   1973           * @param    nbr_base    Base of number to parse.
   1974           *
   1975           * @return   Parsed integer, if integer parsed with NO overflow.
   1976           *           DEF_INT_32U_MAX_VAL, if integer parsed but overflowed.
   1977           *           0, otherwise.
   1978           *
   1979           * @note     (1) See Str_ParseNbr_Int32()'s notes.
   1980           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1981          CPU_INT32U Str_ParseNbr_Int32U(const CPU_CHAR *p_str,
   1982                                         CPU_CHAR       **p_str_next,
   1983                                         CPU_INT08U     nbr_base)
   1984          {
   \                     Str_ParseNbr_Int32U: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1985            CPU_INT32U nbr;
   1986          
   1987            nbr = Str_ParseNbr_Int32(p_str,                               // Parse/convert str ...
   1988                                     p_str_next,
   1989                                     nbr_base,
   1990                                     DEF_NO,                              // ... as unsigned int (see Note #1).
   1991                                     DEF_NULL);
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
   \        0xC   0x2300             MOVS     R3,#+0
   \        0xE   0x0032             MOVS     R2,R6
   \       0x10   0xB2D2             UXTB     R2,R2
   \       0x12   0x0029             MOVS     R1,R5
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       Str_ParseNbr_Int32
   1992          
   1993            return (nbr);
   \       0x1A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1994          }
   1995          
   1996          /****************************************************************************************************//**
   1997           *                                           Str_ParseNbr_Int32S()
   1998           *
   1999           * @brief    Parses a 32-bit signed integer from a string.
   2000           *
   2001           * @param    p_str       Pointer to the string. String buffer NOT modified.
   2002           *
   2003           * @param    p_str_next  Optional pointer to a variable to :
   2004           *                       Return a pointer to first character following the integer string, if NO
   2005           *                       error(s);
   2006           *                       Return a pointer to 'p_str', otherwise.
   2007           *
   2008           * @param    nbr_base    Base of number to parse.
   2009           *
   2010           * @return   Parsed integer, if integer parsed with NO overflow.
   2011           *           DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed.
   2012           *           DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed.
   2013           *           0, otherwise.
   2014           *
   2015           * @note     (1) See Str_ParseNbr_Int32()'s notes.
   2016           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2017          CPU_INT32S Str_ParseNbr_Int32S(const CPU_CHAR *p_str,
   2018                                         CPU_CHAR       **p_str_next,
   2019                                         CPU_INT08U     nbr_base)
   2020          {
   \                     Str_ParseNbr_Int32S: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   2021            CPU_INT32S  nbr;
   2022            CPU_INT32U  nbr_abs;
   2023            CPU_BOOLEAN nbr_neg;
   2024          
   2025            nbr_abs = Str_ParseNbr_Int32(p_str,                           // Parse/convert str ...
   2026                                         p_str_next,
   2027                                         nbr_base,
   2028                                         DEF_YES,                         // ... as signed int.
   2029                                         &nbr_neg);
   \        0x8   0xA801             ADD      R0,SP,#+4
   \        0xA   0x9000             STR      R0,[SP, #+0]
   \        0xC   0x2301             MOVS     R3,#+1
   \        0xE   0x0032             MOVS     R2,R6
   \       0x10   0xB2D2             UXTB     R2,R2
   \       0x12   0x0029             MOVS     R1,R5
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       Str_ParseNbr_Int32
   \       0x1A   0x0001             MOVS     R1,R0
   2030          
   2031            if (nbr_neg == DEF_NO) {                                      // Chk for neg nbr & ovf/undf.
   \       0x1C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD107             BNE.N    ??Str_ParseNbr_Int32S_0
   2032              nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
   2033                    :  (CPU_INT32S)nbr_abs;
   \       0x24   0xF1B1 0x4F00      CMP      R1,#+2147483648
   \       0x28   0xD302             BCC.N    ??Str_ParseNbr_Int32S_1
   \       0x2A   0xF07F 0x4000      MVNS     R0,#+2147483648
   \       0x2E   0xE008             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_1: (+1)
   \       0x30   0x0008             MOVS     R0,R1
   \       0x32   0xE006             B.N      ??Str_ParseNbr_Int32S_2
   2034            } else {
   2035              nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
   2036                    : -(CPU_INT32S)nbr_abs;
   \                     ??Str_ParseNbr_Int32S_0: (+1)
   \       0x34   0xF1B1 0x4F00      CMP      R1,#+2147483648
   \       0x38   0xD302             BCC.N    ??Str_ParseNbr_Int32S_3
   \       0x3A   0xF05F 0x4000      MOVS     R0,#+2147483648
   \       0x3E   0xE000             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_3: (+1)
   \       0x40   0x4248             RSBS     R0,R1,#+0
   2037            }
   2038          
   2039            return (nbr);
   \                     ??Str_ParseNbr_Int32S_2: (+1)
   \       0x42   0xBD76             POP      {R1,R2,R4-R6,PC}
   2040          }
   2041          
   2042          /****************************************************************************************************//**
   2043           *                                               Str_Printf()
   2044           *
   2045           * @brief    printf()-like function that accepts a character output callback.
   2046           *
   2047           * @param    out_cb          Character output callback.
   2048           *
   2049           * @param    p_out_cb_arg    Character output callback argument.
   2050           *
   2051           * @param    format          Format string.
   2052           *
   2053           * @param    ...         Variable number of arguments that will be formatted according to the
   2054           *                       format specifiers in the format string.
   2055           *
   2056           * @return   See Str_PrintfImpl() return value description.
   2057           *
   2058           * @note     (1) See Str_PrintfImpl() notes.
   2059           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2060          CPU_INT16U Str_Printf(STR_PRINTF_OUT_CB out_cb,
   2061                                void              *p_out_cb_arg,
   2062                                const CPU_CHAR    *format,
   2063                                ...)
   2064          {
   \                     Str_Printf: (+1)
   \        0x0   0xB408             PUSH     {R3}
   \        0x2   0xB5FC             PUSH     {R2-R7,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   2065            CPU_INT16U char_cnt;
   2066            va_list    args;
   2067          
   2068            va_start(args, format);
   \        0xA   0xAE07             ADD      R6,SP,#+28
   2069            char_cnt = Str_PrintfImpl(out_cb,
   2070                                      p_out_cb_arg,
   2071                                      (CPU_INT16U)-1,
   2072                                      format,
   2073                                      args);
   \        0xC   0x9600             STR      R6,[SP, #+0]
   \        0xE   0x002B             MOVS     R3,R5
   \       0x10   0xF64F 0x72FF      MOVW     R2,#+65535
   \       0x14   0x0021             MOVS     R1,R4
   \       0x16   0x0038             MOVS     R0,R7
   \       0x18   0x.... 0x....      BL       Str_PrintfImpl
   2074            va_end(args);
   2075          
   2076            return (char_cnt);
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0xBCF6             POP      {R1,R2,R4-R7}
   \       0x20   0xF85D 0xFB08      LDR      PC,[SP], #+8
   2077          }
   2078          
   2079          /****************************************************************************************************//**
   2080           *                                               Str_Sprintf()
   2081           *
   2082           * @brief    sprintf() implementation.
   2083           *
   2084           * @param    p_str   Buffer that will receive the formatted output.
   2085           *
   2086           * @param    format  Format string.
   2087           *
   2088           * @param    ...     Variable number of arguments that will be formatted according to the
   2089           *                   format specifiers in the format string.
   2090           *
   2091           * @return   See Str_PrintfImpl() return value description.
   2092           *
   2093           * @note     (1) See Str_PrintfImpl() notes.
   2094           *
   2095           * @note     (2) The number of written characters excludes the ending null character.
   2096           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2097          CPU_INT16U Str_Sprintf(CPU_CHAR       *p_str,
   2098                                 const CPU_CHAR *format,
   2099                                 ...)
   2100          {
   \                     Str_Sprintf: (+1)
   \        0x0   0xB40C             PUSH     {R2,R3}
   \        0x2   0xB57F             PUSH     {R0-R6,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   2101            CPU_INT16U         char_cnt;
   2102            STR_SPRINTF_CB_ARG cb_arg;
   2103            va_list            args;
   2104          
   2105            cb_arg.BufPtr = p_str;
   \        0x8   0x9401             STR      R4,[SP, #+4]
   2106            cb_arg.CurIx = 0u;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9002             STR      R0,[SP, #+8]
   2107          
   2108            va_start(args, format);
   \        0xE   0xAE08             ADD      R6,SP,#+32
   2109            //                                                               Format string according to format specifiers and...
   2110            //                                                               ...store formatted in given buffer.
   2111            char_cnt = Str_PrintfImpl(Str_SprintfCb,
   2112                                      &cb_arg,
   2113                                      (CPU_INT16U)-1,
   2114                                      format,
   2115                                      args);
   \       0x10   0x9600             STR      R6,[SP, #+0]
   \       0x12   0x002B             MOVS     R3,R5
   \       0x14   0xF64F 0x72FF      MOVW     R2,#+65535
   \       0x18   0xA901             ADD      R1,SP,#+4
   \       0x1A   0x.... 0x....      ADR.W    R0,Str_SprintfCb
   \       0x1E   0x.... 0x....      BL       Str_PrintfImpl
   2116            va_end(args);
   2117          
   2118            if (char_cnt != 0u) {
   \       0x22   0x0001             MOVS     R1,R0
   \       0x24   0xB289             UXTH     R1,R1
   \       0x26   0x2900             CMP      R1,#+0
   \       0x28   0xD003             BEQ.N    ??Str_Sprintf_0
   2119              p_str[char_cnt] = '\0';                                     // Append automatically ending null character.
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x0001             MOVS     R1,R0
   \       0x2E   0xB289             UXTH     R1,R1
   \       0x30   0x5462             STRB     R2,[R4, R1]
   2120            }
   2121          
   2122            return (char_cnt);                                            // See Note #2.
   \                     ??Str_Sprintf_0: (+1)
   \       0x32   0xB280             UXTH     R0,R0
   \       0x34   0xB004             ADD      SP,SP,#+16
   \       0x36   0xBC70             POP      {R4-R6}
   \       0x38   0xF85D 0xFB0C      LDR      PC,[SP], #+12
   2123          }
   2124          
   2125          /****************************************************************************************************//**
   2126           *                                               Str_Snprintf()
   2127           *
   2128           * @brief    snprintf() implementation.
   2129           *
   2130           * @param    p_str   Buffer that will receive the formatted output.
   2131           *
   2132           * @param    size    Total capacity of the given string buffer.
   2133           *
   2134           * @param    format  Format string.
   2135           *
   2136           * @param    ...     Variable number of arguments that will be formatted according to the
   2137           *                   format specifiers in the format string.
   2138           *
   2139           * @return   See Str_PrintfImpl() return value description.
   2140           *
   2141           * @note     (1) See Str_PrintfImpl() notes.
   2142           *
   2143           * @note     (2) The number of written characters excludes the ending null character.
   2144           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2145          CPU_INT16U Str_Snprintf(CPU_CHAR       *p_str,
   2146                                  CPU_INT16U     size,
   2147                                  const CPU_CHAR *format,
   2148                                  ...)
   2149          {
   \                     Str_Snprintf: (+1)
   \        0x0   0xB408             PUSH     {R3}
   \        0x2   0xB5FF             PUSH     {R0-R7,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   2150            CPU_INT16U         char_cnt;
   2151            STR_SPRINTF_CB_ARG cb_arg;
   2152            va_list            args;
   2153          
   2154            cb_arg.BufPtr = p_str;
   \        0xA   0x9401             STR      R4,[SP, #+4]
   2155            cb_arg.CurIx = 0u;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9002             STR      R0,[SP, #+8]
   2156          
   2157            va_start(args, format);
   \       0x10   0xAF09             ADD      R7,SP,#+36
   2158            //                                                               Format string according to format specifiers and...
   2159            //                                                               ...store formatted up to N char in given buffer.
   2160            char_cnt = Str_PrintfImpl(Str_SprintfCb,
   2161                                      &cb_arg,
   2162                                      size - 1u,
   2163                                      format,
   2164                                      args);
   \       0x12   0x9700             STR      R7,[SP, #+0]
   \       0x14   0x0033             MOVS     R3,R6
   \       0x16   0x1E6A             SUBS     R2,R5,#+1
   \       0x18   0xB292             UXTH     R2,R2
   \       0x1A   0xA901             ADD      R1,SP,#+4
   \       0x1C   0x.... 0x....      ADR.W    R0,Str_SprintfCb
   \       0x20   0x.... 0x....      BL       Str_PrintfImpl
   2165            va_end(args);
   2166          
   2167            if (char_cnt != 0u) {
   \       0x24   0x0001             MOVS     R1,R0
   \       0x26   0xB289             UXTH     R1,R1
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD003             BEQ.N    ??Str_Snprintf_0
   2168              p_str[char_cnt] = '\0';                                     // Append automatically ending null character.
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x0001             MOVS     R1,R0
   \       0x30   0xB289             UXTH     R1,R1
   \       0x32   0x5462             STRB     R2,[R4, R1]
   2169            }
   2170          
   2171            return (char_cnt);                                            // See Note #2.
   \                     ??Str_Snprintf_0: (+1)
   \       0x34   0xB280             UXTH     R0,R0
   \       0x36   0xB004             ADD      SP,SP,#+16
   \       0x38   0xBCF0             POP      {R4-R7}
   \       0x3A   0xF85D 0xFB08      LDR      PC,[SP], #+8
   2172          }
   2173          
   2174          /********************************************************************************************************
   2175           ********************************************************************************************************
   2176           *                                           LOCAL FUNCTIONS
   2177           ********************************************************************************************************
   2178           *******************************************************************************************************/
   2179          
   2180          /****************************************************************************************************//**
   2181           *                                               Str_PrintfImpl()
   2182           *
   2183           * @brief    Generic printf()-like function implementation.
   2184           *
   2185           * @param    out_cb          Character output callback (putchar()-like with an extra callback-specific
   2186           *                           argument).
   2187           *
   2188           * @param    p_out_cb_arg    Character output callback argument.
   2189           *
   2190           * @param    format          Format string.
   2191           *
   2192           * @param    argp            Variable length argument list.
   2193           *
   2194           * @return   In accordance with the C99 specification, this function returns:
   2195           *               - (1) the number of written characters when no truncation occurs;
   2196           *               - (2) the number of characters that would have been written given that the buffer was
   2197           *                     big enough when truncation occurs.
   2198           *
   2199           * @note     (1) A truncation has occurred whenever the returned value is equal or greater than the
   2200           *               'max_char_cnt' parameter.
   2201           *
   2202           * @note     (2) A ending null character is not appended automatically by this function. If the null
   2203           *               character is needed, this is the responsibility of the caller function.
   2204           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2205          static CPU_INT16U Str_PrintfImpl(STR_PRINTF_OUT_CB out_cb,
   2206                                           void              *p_out_cb_arg,
   2207                                           CPU_INT16U        max_char_cnt,
   2208                                           const CPU_CHAR    *format,
   2209                                           va_list           argp)
   2210          {
   \                     Str_PrintfImpl: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x9D14             LDR      R5,[SP, #+80]
   2211            CPU_CHAR    *p_cur_char;
   2212            CPU_CHAR    pad_char;
   2213            CPU_SIZE_T  output_char_cnt;
   2214            CPU_SIZE_T  min_field_width;
   2215            CPU_SIZE_T  max_field_width;
   2216            CPU_BOOLEAN left_justify;
   2217            CPU_BOOLEAN long_long_flag;
   2218            CPU_BOOLEAN long_flag;
   2219            CPU_BOOLEAN dot_flag;
   2220            CPU_BOOLEAN arg_parsed;
   2221          
   2222            p_cur_char = (CPU_CHAR *)format;
   \        0xE   0x980A             LDR      R0,[SP, #+40]
   \       0x10   0x9006             STR      R0,[SP, #+24]
   2223            output_char_cnt = 0u;
   \       0x12   0x2600             MOVS     R6,#+0
   2224          
   2225            while (*p_cur_char != '\0') {
   \                     ??Str_PrintfImpl_0: (+1)
   \       0x14   0x9806             LDR      R0,[SP, #+24]
   \       0x16   0x7800             LDRB     R0,[R0, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xF000 0x821A      BEQ.W    ??Str_PrintfImpl_1
   2226              //                                                             move format string chars to buffer until a
   2227              //                                                             format control is found.
   2228              while ((*p_cur_char != '%') && (*p_cur_char != '\0')) {
   \                     ??Str_PrintfImpl_2: (+1)
   \       0x1E   0x9806             LDR      R0,[SP, #+24]
   \       0x20   0x7800             LDRB     R0,[R0, #+0]
   \       0x22   0x2825             CMP      R0,#+37
   \       0x24   0xD010             BEQ.N    ??Str_PrintfImpl_3
   \       0x26   0x9806             LDR      R0,[SP, #+24]
   \       0x28   0x7800             LDRB     R0,[R0, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD00C             BEQ.N    ??Str_PrintfImpl_3
   2229                if (output_char_cnt < max_char_cnt) {
   \       0x2E   0x4640             MOV      R0,R8
   \       0x30   0xB280             UXTH     R0,R0
   \       0x32   0x4286             CMP      R6,R0
   \       0x34   0xD203             BCS.N    ??Str_PrintfImpl_4
   2230                  out_cb((int)(*p_cur_char), p_out_cb_arg);
   \       0x36   0x0021             MOVS     R1,R4
   \       0x38   0x9806             LDR      R0,[SP, #+24]
   \       0x3A   0x7800             LDRB     R0,[R0, #+0]
   \       0x3C   0x47B8             BLX      R7
   2231                }
   2232                output_char_cnt += 1u;
   \                     ??Str_PrintfImpl_4: (+1)
   \       0x3E   0x1C76             ADDS     R6,R6,#+1
   2233                p_cur_char += 1u;
   \       0x40   0x9806             LDR      R0,[SP, #+24]
   \       0x42   0x1C40             ADDS     R0,R0,#+1
   \       0x44   0x9006             STR      R0,[SP, #+24]
   \       0x46   0xE7EA             B.N      ??Str_PrintfImpl_2
   2234              }
   2235          
   2236              if (*p_cur_char == '\0') {
   \                     ??Str_PrintfImpl_3: (+1)
   \       0x48   0x9806             LDR      R0,[SP, #+24]
   \       0x4A   0x7800             LDRB     R0,[R0, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xF000 0x8200      BEQ.W    ??Str_PrintfImpl_1
   2237                break;
   2238              }
   2239          
   2240              p_cur_char += 1u;
   \                     ??Str_PrintfImpl_5: (+1)
   \       0x52   0x9806             LDR      R0,[SP, #+24]
   \       0x54   0x1C40             ADDS     R0,R0,#+1
   \       0x56   0x9006             STR      R0,[SP, #+24]
   2241          
   2242              //                                                             initialize all the flags for this format.
   2243              dot_flag = DEF_NO;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF88D 0x001C      STRB     R0,[SP, #+28]
   2244              long_flag = DEF_NO;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF88D 0x0016      STRB     R0,[SP, #+22]
   2245              long_long_flag = DEF_NO;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF88D 0x0017      STRB     R0,[SP, #+23]
   2246              left_justify = DEF_NO;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x4682             MOV      R10,R0
   2247              min_field_width = 0u;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x4681             MOV      R9,R0
   2248              max_field_width = (CPU_SIZE_T)-1;
   \       0x72   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x76   0x9008             STR      R0,[SP, #+32]
   2249              pad_char = ' ';
   \       0x78   0x2020             MOVS     R0,#+32
   \       0x7A   0xF88D 0x0014      STRB     R0,[SP, #+20]
   2250          
   2251              arg_parsed = DEF_NO;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xF88D 0x0015      STRB     R0,[SP, #+21]
   2252              while (!arg_parsed && (*p_cur_char != '\0')) {
   \                     ??Str_PrintfImpl_6: (+1)
   \       0x84   0xF89D 0x0015      LDRB     R0,[SP, #+21]
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD1C3             BNE.N    ??Str_PrintfImpl_0
   \       0x8C   0x9806             LDR      R0,[SP, #+24]
   \       0x8E   0x7800             LDRB     R0,[R0, #+0]
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD0BF             BEQ.N    ??Str_PrintfImpl_0
   2253                if (ASCII_IsDig(*p_cur_char)) {
   \       0x94   0x9806             LDR      R0,[SP, #+24]
   \       0x96   0x7800             LDRB     R0,[R0, #+0]
   \       0x98   0x.... 0x....      BL       ASCII_IsDig
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD01C             BEQ.N    ??Str_PrintfImpl_7
   2254                  if (dot_flag) {
   \       0xA0   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD006             BEQ.N    ??Str_PrintfImpl_8
   2255                    min_field_width = (CPU_SIZE_T)Str_ParseNbr_Int32U(p_cur_char,
   2256                                                                      &p_cur_char,
   2257                                                                      DEF_NBR_BASE_DEC);
   \       0xA8   0x220A             MOVS     R2,#+10
   \       0xAA   0xA906             ADD      R1,SP,#+24
   \       0xAC   0x9806             LDR      R0,[SP, #+24]
   \       0xAE   0x.... 0x....      BL       Str_ParseNbr_Int32U
   \       0xB2   0x4681             MOV      R9,R0
   \       0xB4   0xE7E6             B.N      ??Str_PrintfImpl_6
   2258                  } else {
   2259                    if (*p_cur_char == '0') {
   \                     ??Str_PrintfImpl_8: (+1)
   \       0xB6   0x9806             LDR      R0,[SP, #+24]
   \       0xB8   0x7800             LDRB     R0,[R0, #+0]
   \       0xBA   0x2830             CMP      R0,#+48
   \       0xBC   0xD106             BNE.N    ??Str_PrintfImpl_9
   2260                      pad_char = '0';
   \       0xBE   0x2030             MOVS     R0,#+48
   \       0xC0   0xF88D 0x0014      STRB     R0,[SP, #+20]
   2261                      p_cur_char += 1u;
   \       0xC4   0x9806             LDR      R0,[SP, #+24]
   \       0xC6   0x1C40             ADDS     R0,R0,#+1
   \       0xC8   0x9006             STR      R0,[SP, #+24]
   \       0xCA   0xE7DB             B.N      ??Str_PrintfImpl_6
   2262                    } else {
   2263                      min_field_width = (CPU_SIZE_T)Str_ParseNbr_Int32U(p_cur_char,
   2264                                                                        &p_cur_char,
   2265                                                                        DEF_NBR_BASE_DEC);
   \                     ??Str_PrintfImpl_9: (+1)
   \       0xCC   0x220A             MOVS     R2,#+10
   \       0xCE   0xA906             ADD      R1,SP,#+24
   \       0xD0   0x9806             LDR      R0,[SP, #+24]
   \       0xD2   0x.... 0x....      BL       Str_ParseNbr_Int32U
   \       0xD6   0x4681             MOV      R9,R0
   \       0xD8   0xE7D4             B.N      ??Str_PrintfImpl_6
   2266                    }
   2267                  }
   2268                } else {
   2269                  switch (ASCII_ToLower(*p_cur_char)) {
   \                     ??Str_PrintfImpl_7: (+1)
   \       0xDA   0x9806             LDR      R0,[SP, #+24]
   \       0xDC   0x7800             LDRB     R0,[R0, #+0]
   \       0xDE   0x.... 0x....      BL       ASCII_ToLower
   \       0xE2   0x2825             CMP      R0,#+37
   \       0xE4   0xD01B             BEQ.N    ??Str_PrintfImpl_10
   \       0xE6   0x282A             CMP      R0,#+42
   \       0xE8   0xD035             BEQ.N    ??Str_PrintfImpl_11
   \       0xEA   0x282D             CMP      R0,#+45
   \       0xEC   0xD020             BEQ.N    ??Str_PrintfImpl_12
   \       0xEE   0x282E             CMP      R0,#+46
   \       0xF0   0xD021             BEQ.N    ??Str_PrintfImpl_13
   \       0xF2   0x285C             CMP      R0,#+92
   \       0xF4   0xF000 0x8184      BEQ.W    ??Str_PrintfImpl_14
   \       0xF8   0x2863             CMP      R0,#+99
   \       0xFA   0xF000 0x8174      BEQ.W    ??Str_PrintfImpl_15
   \       0xFE   0x2864             CMP      R0,#+100
   \      0x100   0xD035             BEQ.N    ??Str_PrintfImpl_16
   \      0x102   0x286C             CMP      R0,#+108
   \      0x104   0xD01B             BEQ.N    ??Str_PrintfImpl_17
   \      0x106   0x2870             CMP      R0,#+112
   \      0x108   0xF000 0x80CD      BEQ.W    ??Str_PrintfImpl_18
   \      0x10C   0x2873             CMP      R0,#+115
   \      0x10E   0xF000 0x8156      BEQ.W    ??Str_PrintfImpl_19
   \      0x112   0x2875             CMP      R0,#+117
   \      0x114   0xD076             BEQ.N    ??Str_PrintfImpl_20
   \      0x116   0x2878             CMP      R0,#+120
   \      0x118   0xF000 0x80C5      BEQ.W    ??Str_PrintfImpl_18
   \      0x11C   0xE195             B.N      ??Str_PrintfImpl_21
   2270                    case '%':
   2271                      if (output_char_cnt < max_char_cnt) {
   \                     ??Str_PrintfImpl_10: (+1)
   \      0x11E   0x4640             MOV      R0,R8
   \      0x120   0xB280             UXTH     R0,R0
   \      0x122   0x4286             CMP      R6,R0
   \      0x124   0xD202             BCS.N    ??Str_PrintfImpl_22
   2272                        out_cb((int)'%', p_out_cb_arg);
   \      0x126   0x0021             MOVS     R1,R4
   \      0x128   0x2025             MOVS     R0,#+37
   \      0x12A   0x47B8             BLX      R7
   2273                      }
   2274                      output_char_cnt += 1u;
   \                     ??Str_PrintfImpl_22: (+1)
   \      0x12C   0x1C76             ADDS     R6,R6,#+1
   2275                      break;
   \      0x12E   0xE18C             B.N      ??Str_PrintfImpl_23
   2276          
   2277                    case '-':
   2278                      left_justify = DEF_YES;
   \                     ??Str_PrintfImpl_12: (+1)
   \      0x130   0x2001             MOVS     R0,#+1
   \      0x132   0x4682             MOV      R10,R0
   2279                      break;
   \      0x134   0xE189             B.N      ??Str_PrintfImpl_23
   2280          
   2281                    case '.':
   2282                      dot_flag = DEF_YES;
   \                     ??Str_PrintfImpl_13: (+1)
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0xF88D 0x001C      STRB     R0,[SP, #+28]
   2283                      break;
   \      0x13C   0xE185             B.N      ??Str_PrintfImpl_23
   2284          
   2285                    case 'l':
   2286                      if (long_flag) {
   \                     ??Str_PrintfImpl_17: (+1)
   \      0x13E   0xF89D 0x0016      LDRB     R0,[SP, #+22]
   \      0x142   0x2800             CMP      R0,#+0
   \      0x144   0xD003             BEQ.N    ??Str_PrintfImpl_24
   2287                        long_long_flag = DEF_YES;
   \      0x146   0x2001             MOVS     R0,#+1
   \      0x148   0xF88D 0x0017      STRB     R0,[SP, #+23]
   \      0x14C   0xE002             B.N      ??Str_PrintfImpl_25
   2288                      } else {
   2289                        long_flag = DEF_YES;
   \                     ??Str_PrintfImpl_24: (+1)
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0xF88D 0x0016      STRB     R0,[SP, #+22]
   2290                      }
   2291                      break;
   \                     ??Str_PrintfImpl_25: (+1)
   \      0x154   0xE179             B.N      ??Str_PrintfImpl_23
   2292          
   2293                    case '*':
   2294                      if (dot_flag) {
   \                     ??Str_PrintfImpl_11: (+1)
   \      0x156   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \      0x15A   0x2800             CMP      R0,#+0
   \      0x15C   0xD003             BEQ.N    ??Str_PrintfImpl_26
   2295                        min_field_width = va_arg(argp, int);
   \      0x15E   0x6828             LDR      R0,[R5, #+0]
   \      0x160   0x1D2D             ADDS     R5,R5,#+4
   \      0x162   0x4681             MOV      R9,R0
   \      0x164   0xE002             B.N      ??Str_PrintfImpl_27
   2296                      } else {
   2297                        max_field_width = va_arg(argp, int);
   \                     ??Str_PrintfImpl_26: (+1)
   \      0x166   0x6828             LDR      R0,[R5, #+0]
   \      0x168   0x1D2D             ADDS     R5,R5,#+4
   \      0x16A   0x9008             STR      R0,[SP, #+32]
   2298                      }
   2299                      break;
   \                     ??Str_PrintfImpl_27: (+1)
   \      0x16C   0xE16D             B.N      ??Str_PrintfImpl_23
   2300                    case 'd':
   2301                      if (long_long_flag) {
   \                     ??Str_PrintfImpl_16: (+1)
   \      0x16E   0xF89D 0x0017      LDRB     R0,[SP, #+23]
   \      0x172   0x2800             CMP      R0,#+0
   \      0x174   0xD017             BEQ.N    ??Str_PrintfImpl_28
   2302                        output_char_cnt += Str_SngIntFmtOutput(va_arg(argp, long long),
   2303                                                               min_field_width,
   2304                                                               left_justify,
   2305                                                               pad_char,
   2306                                                               out_cb,
   2307                                                               p_out_cb_arg,
   2308                                                               max_char_cnt - output_char_cnt);
   \      0x176   0x1DEA             ADDS     R2,R5,#+7
   \      0x178   0xF032 0x0207      BICS     R2,R2,#0x7
   \      0x17C   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \      0x180   0xF112 0x0508      ADDS     R5,R2,#+8
   \      0x184   0x4642             MOV      R2,R8
   \      0x186   0xB292             UXTH     R2,R2
   \      0x188   0x1B92             SUBS     R2,R2,R6
   \      0x18A   0x9203             STR      R2,[SP, #+12]
   \      0x18C   0x9402             STR      R4,[SP, #+8]
   \      0x18E   0x9701             STR      R7,[SP, #+4]
   \      0x190   0xF89D 0x2014      LDRB     R2,[SP, #+20]
   \      0x194   0x9200             STR      R2,[SP, #+0]
   \      0x196   0x4653             MOV      R3,R10
   \      0x198   0xB2DB             UXTB     R3,R3
   \      0x19A   0x464A             MOV      R2,R9
   \      0x19C   0x.... 0x....      BL       Str_SngIntFmtOutput
   \      0x1A0   0x1980             ADDS     R0,R0,R6
   \      0x1A2   0x0006             MOVS     R6,R0
   \      0x1A4   0xE02A             B.N      ??Str_PrintfImpl_29
   2309                      } else if (long_flag) {
   \                     ??Str_PrintfImpl_28: (+1)
   \      0x1A6   0xF89D 0x0016      LDRB     R0,[SP, #+22]
   \      0x1AA   0x2800             CMP      R0,#+0
   \      0x1AC   0xD013             BEQ.N    ??Str_PrintfImpl_30
   2310                        output_char_cnt += Str_SngIntFmtOutput(va_arg(argp, long),
   2311                                                               min_field_width,
   2312                                                               left_justify,
   2313                                                               pad_char,
   2314                                                               out_cb,
   2315                                                               p_out_cb_arg,
   2316                                                               max_char_cnt - output_char_cnt);
   \      0x1AE   0x6828             LDR      R0,[R5, #+0]
   \      0x1B0   0x1D2D             ADDS     R5,R5,#+4
   \      0x1B2   0x4641             MOV      R1,R8
   \      0x1B4   0xB289             UXTH     R1,R1
   \      0x1B6   0x1B89             SUBS     R1,R1,R6
   \      0x1B8   0x9103             STR      R1,[SP, #+12]
   \      0x1BA   0x9402             STR      R4,[SP, #+8]
   \      0x1BC   0x9701             STR      R7,[SP, #+4]
   \      0x1BE   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \      0x1C2   0x9100             STR      R1,[SP, #+0]
   \      0x1C4   0x4653             MOV      R3,R10
   \      0x1C6   0xB2DB             UXTB     R3,R3
   \      0x1C8   0x464A             MOV      R2,R9
   \      0x1CA   0x17C1             ASRS     R1,R0,#+31
   \      0x1CC   0x.... 0x....      BL       Str_SngIntFmtOutput
   \      0x1D0   0x1980             ADDS     R0,R0,R6
   \      0x1D2   0x0006             MOVS     R6,R0
   \      0x1D4   0xE012             B.N      ??Str_PrintfImpl_29
   2317                      } else {
   2318                        output_char_cnt += Str_SngIntFmtOutput(va_arg(argp, int),
   2319                                                               min_field_width,
   2320                                                               left_justify,
   2321                                                               pad_char,
   2322                                                               out_cb,
   2323                                                               p_out_cb_arg,
   2324                                                               max_char_cnt - output_char_cnt);
   \                     ??Str_PrintfImpl_30: (+1)
   \      0x1D6   0x6828             LDR      R0,[R5, #+0]
   \      0x1D8   0x1D2D             ADDS     R5,R5,#+4
   \      0x1DA   0x4641             MOV      R1,R8
   \      0x1DC   0xB289             UXTH     R1,R1
   \      0x1DE   0x1B89             SUBS     R1,R1,R6
   \      0x1E0   0x9103             STR      R1,[SP, #+12]
   \      0x1E2   0x9402             STR      R4,[SP, #+8]
   \      0x1E4   0x9701             STR      R7,[SP, #+4]
   \      0x1E6   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \      0x1EA   0x9100             STR      R1,[SP, #+0]
   \      0x1EC   0x4653             MOV      R3,R10
   \      0x1EE   0xB2DB             UXTB     R3,R3
   \      0x1F0   0x464A             MOV      R2,R9
   \      0x1F2   0x17C1             ASRS     R1,R0,#+31
   \      0x1F4   0x.... 0x....      BL       Str_SngIntFmtOutput
   \      0x1F8   0x1980             ADDS     R0,R0,R6
   \      0x1FA   0x0006             MOVS     R6,R0
   2325                      }
   2326                      arg_parsed = DEF_YES;
   \                     ??Str_PrintfImpl_29: (+1)
   \      0x1FC   0x2001             MOVS     R0,#+1
   \      0x1FE   0xF88D 0x0015      STRB     R0,[SP, #+21]
   2327                      break;
   \      0x202   0xE122             B.N      ??Str_PrintfImpl_23
   2328          
   2329                    case 'u':
   2330                      if (long_long_flag) {
   \                     ??Str_PrintfImpl_20: (+1)
   \      0x204   0xF89D 0x0017      LDRB     R0,[SP, #+23]
   \      0x208   0x2800             CMP      R0,#+0
   \      0x20A   0xD019             BEQ.N    ??Str_PrintfImpl_31
   2331                        output_char_cnt += Str_UnsgnIntFmtOutput(va_arg(argp, unsigned long long),
   2332                                                                 10u,
   2333                                                                 min_field_width,
   2334                                                                 left_justify,
   2335                                                                 pad_char,
   2336                                                                 out_cb,
   2337                                                                 p_out_cb_arg,
   2338                                                                 max_char_cnt - output_char_cnt);
   \      0x20C   0x1DEA             ADDS     R2,R5,#+7
   \      0x20E   0xF032 0x0207      BICS     R2,R2,#0x7
   \      0x212   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \      0x216   0xF112 0x0508      ADDS     R5,R2,#+8
   \      0x21A   0x4642             MOV      R2,R8
   \      0x21C   0xB292             UXTH     R2,R2
   \      0x21E   0x1B92             SUBS     R2,R2,R6
   \      0x220   0x9204             STR      R2,[SP, #+16]
   \      0x222   0x9403             STR      R4,[SP, #+12]
   \      0x224   0x9702             STR      R7,[SP, #+8]
   \      0x226   0xF89D 0x2014      LDRB     R2,[SP, #+20]
   \      0x22A   0x9201             STR      R2,[SP, #+4]
   \      0x22C   0x4652             MOV      R2,R10
   \      0x22E   0xB2D2             UXTB     R2,R2
   \      0x230   0x9200             STR      R2,[SP, #+0]
   \      0x232   0x464B             MOV      R3,R9
   \      0x234   0x220A             MOVS     R2,#+10
   \      0x236   0x.... 0x....      BL       Str_UnsgnIntFmtOutput
   \      0x23A   0x1980             ADDS     R0,R0,R6
   \      0x23C   0x0006             MOVS     R6,R0
   \      0x23E   0xE02E             B.N      ??Str_PrintfImpl_32
   2339                      } else if (long_flag) {
   \                     ??Str_PrintfImpl_31: (+1)
   \      0x240   0xF89D 0x0016      LDRB     R0,[SP, #+22]
   \      0x244   0x2800             CMP      R0,#+0
   \      0x246   0xD015             BEQ.N    ??Str_PrintfImpl_33
   2340                        output_char_cnt += Str_UnsgnIntFmtOutput(va_arg(argp, unsigned long),
   2341                                                                 10u,
   2342                                                                 min_field_width,
   2343                                                                 left_justify,
   2344                                                                 pad_char,
   2345                                                                 out_cb,
   2346                                                                 p_out_cb_arg,
   2347                                                                 max_char_cnt - output_char_cnt);
   \      0x248   0x6828             LDR      R0,[R5, #+0]
   \      0x24A   0x1D2D             ADDS     R5,R5,#+4
   \      0x24C   0x4641             MOV      R1,R8
   \      0x24E   0xB289             UXTH     R1,R1
   \      0x250   0x1B89             SUBS     R1,R1,R6
   \      0x252   0x9104             STR      R1,[SP, #+16]
   \      0x254   0x9403             STR      R4,[SP, #+12]
   \      0x256   0x9702             STR      R7,[SP, #+8]
   \      0x258   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \      0x25C   0x9101             STR      R1,[SP, #+4]
   \      0x25E   0x4651             MOV      R1,R10
   \      0x260   0xB2C9             UXTB     R1,R1
   \      0x262   0x9100             STR      R1,[SP, #+0]
   \      0x264   0x464B             MOV      R3,R9
   \      0x266   0x220A             MOVS     R2,#+10
   \      0x268   0x2100             MOVS     R1,#+0
   \      0x26A   0x.... 0x....      BL       Str_UnsgnIntFmtOutput
   \      0x26E   0x1980             ADDS     R0,R0,R6
   \      0x270   0x0006             MOVS     R6,R0
   \      0x272   0xE014             B.N      ??Str_PrintfImpl_32
   2348                      } else {
   2349                        output_char_cnt += Str_UnsgnIntFmtOutput(va_arg(argp, unsigned int),
   2350                                                                 10u,
   2351                                                                 min_field_width,
   2352                                                                 left_justify,
   2353                                                                 pad_char,
   2354                                                                 out_cb,
   2355                                                                 p_out_cb_arg,
   2356                                                                 max_char_cnt - output_char_cnt);
   \                     ??Str_PrintfImpl_33: (+1)
   \      0x274   0x6828             LDR      R0,[R5, #+0]
   \      0x276   0x1D2D             ADDS     R5,R5,#+4
   \      0x278   0x4641             MOV      R1,R8
   \      0x27A   0xB289             UXTH     R1,R1
   \      0x27C   0x1B89             SUBS     R1,R1,R6
   \      0x27E   0x9104             STR      R1,[SP, #+16]
   \      0x280   0x9403             STR      R4,[SP, #+12]
   \      0x282   0x9702             STR      R7,[SP, #+8]
   \      0x284   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \      0x288   0x9101             STR      R1,[SP, #+4]
   \      0x28A   0x4651             MOV      R1,R10
   \      0x28C   0xB2C9             UXTB     R1,R1
   \      0x28E   0x9100             STR      R1,[SP, #+0]
   \      0x290   0x464B             MOV      R3,R9
   \      0x292   0x220A             MOVS     R2,#+10
   \      0x294   0x2100             MOVS     R1,#+0
   \      0x296   0x.... 0x....      BL       Str_UnsgnIntFmtOutput
   \      0x29A   0x1980             ADDS     R0,R0,R6
   \      0x29C   0x0006             MOVS     R6,R0
   2357                      }
   2358                      arg_parsed = DEF_YES;
   \                     ??Str_PrintfImpl_32: (+1)
   \      0x29E   0x2001             MOVS     R0,#+1
   \      0x2A0   0xF88D 0x0015      STRB     R0,[SP, #+21]
   2359                      break;
   \      0x2A4   0xE0D1             B.N      ??Str_PrintfImpl_23
   2360          
   2361                    case 'p':
   2362                    case 'x':
   2363                      if (output_char_cnt < max_char_cnt) {
   \                     ??Str_PrintfImpl_18: (+1)
   \      0x2A6   0x4640             MOV      R0,R8
   \      0x2A8   0xB280             UXTH     R0,R0
   \      0x2AA   0x4286             CMP      R6,R0
   \      0x2AC   0xD202             BCS.N    ??Str_PrintfImpl_34
   2364                        out_cb((int)'0', p_out_cb_arg);
   \      0x2AE   0x0021             MOVS     R1,R4
   \      0x2B0   0x2030             MOVS     R0,#+48
   \      0x2B2   0x47B8             BLX      R7
   2365                      }
   2366                      output_char_cnt += 1u;
   \                     ??Str_PrintfImpl_34: (+1)
   \      0x2B4   0x1C76             ADDS     R6,R6,#+1
   2367                      if (output_char_cnt < max_char_cnt) {
   \      0x2B6   0x4640             MOV      R0,R8
   \      0x2B8   0xB280             UXTH     R0,R0
   \      0x2BA   0x4286             CMP      R6,R0
   \      0x2BC   0xD20A             BCS.N    ??Str_PrintfImpl_35
   2368                        if (*p_cur_char == 'X') {
   \      0x2BE   0x9806             LDR      R0,[SP, #+24]
   \      0x2C0   0x7800             LDRB     R0,[R0, #+0]
   \      0x2C2   0x2858             CMP      R0,#+88
   \      0x2C4   0xD103             BNE.N    ??Str_PrintfImpl_36
   2369                          out_cb((int)'X', p_out_cb_arg);
   \      0x2C6   0x0021             MOVS     R1,R4
   \      0x2C8   0x2058             MOVS     R0,#+88
   \      0x2CA   0x47B8             BLX      R7
   \      0x2CC   0xE002             B.N      ??Str_PrintfImpl_35
   2370                        } else {
   2371                          out_cb((int)'x', p_out_cb_arg);
   \                     ??Str_PrintfImpl_36: (+1)
   \      0x2CE   0x0021             MOVS     R1,R4
   \      0x2D0   0x2078             MOVS     R0,#+120
   \      0x2D2   0x47B8             BLX      R7
   2372                        }
   2373                      }
   2374                      output_char_cnt += 1u;
   \                     ??Str_PrintfImpl_35: (+1)
   \      0x2D4   0x1C76             ADDS     R6,R6,#+1
   \      0x2D6   0x46B3             MOV      R11,R6
   2375                      if (long_flag) {
   \      0x2D8   0xF89D 0x0016      LDRB     R0,[SP, #+22]
   \      0x2DC   0x2800             CMP      R0,#+0
   \      0x2DE   0xD017             BEQ.N    ??Str_PrintfImpl_37
   2376                        output_char_cnt += Str_UnsgnIntFmtOutput(va_arg(argp, unsigned long),
   2377                                                                 16u,
   2378                                                                 min_field_width,
   2379                                                                 left_justify,
   2380                                                                 pad_char,
   2381                                                                 out_cb,
   2382                                                                 p_out_cb_arg,
   2383                                                                 max_char_cnt - output_char_cnt);
   \      0x2E0   0x6828             LDR      R0,[R5, #+0]
   \      0x2E2   0x1D2D             ADDS     R5,R5,#+4
   \      0x2E4   0x4641             MOV      R1,R8
   \      0x2E6   0xB289             UXTH     R1,R1
   \      0x2E8   0xEBB1 0x010B      SUBS     R1,R1,R11
   \      0x2EC   0x9104             STR      R1,[SP, #+16]
   \      0x2EE   0x9403             STR      R4,[SP, #+12]
   \      0x2F0   0x9702             STR      R7,[SP, #+8]
   \      0x2F2   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \      0x2F6   0x9101             STR      R1,[SP, #+4]
   \      0x2F8   0x4651             MOV      R1,R10
   \      0x2FA   0xB2C9             UXTB     R1,R1
   \      0x2FC   0x9100             STR      R1,[SP, #+0]
   \      0x2FE   0x464B             MOV      R3,R9
   \      0x300   0x2210             MOVS     R2,#+16
   \      0x302   0x2100             MOVS     R1,#+0
   \      0x304   0x.... 0x....      BL       Str_UnsgnIntFmtOutput
   \      0x308   0x0006             MOVS     R6,R0
   \      0x30A   0xEB16 0x060B      ADDS     R6,R6,R11
   \      0x30E   0xE052             B.N      ??Str_PrintfImpl_38
   2384                      } else if (long_long_flag) {
   \                     ??Str_PrintfImpl_37: (+1)
   \      0x310   0xF89D 0x0017      LDRB     R0,[SP, #+23]
   \      0x314   0x2800             CMP      R0,#+0
   \      0x316   0xD01B             BEQ.N    ??Str_PrintfImpl_39
   2385                        output_char_cnt += Str_UnsgnIntFmtOutput(va_arg(argp, unsigned long long),
   2386                                                                 16u,
   2387                                                                 min_field_width,
   2388                                                                 left_justify,
   2389                                                                 pad_char,
   2390                                                                 out_cb,
   2391                                                                 p_out_cb_arg,
   2392                                                                 max_char_cnt - output_char_cnt);
   \      0x318   0x1DEA             ADDS     R2,R5,#+7
   \      0x31A   0xF032 0x0207      BICS     R2,R2,#0x7
   \      0x31E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \      0x322   0xF112 0x0508      ADDS     R5,R2,#+8
   \      0x326   0x4642             MOV      R2,R8
   \      0x328   0xB292             UXTH     R2,R2
   \      0x32A   0xEBB2 0x020B      SUBS     R2,R2,R11
   \      0x32E   0x9204             STR      R2,[SP, #+16]
   \      0x330   0x9403             STR      R4,[SP, #+12]
   \      0x332   0x9702             STR      R7,[SP, #+8]
   \      0x334   0xF89D 0x2014      LDRB     R2,[SP, #+20]
   \      0x338   0x9201             STR      R2,[SP, #+4]
   \      0x33A   0x4652             MOV      R2,R10
   \      0x33C   0xB2D2             UXTB     R2,R2
   \      0x33E   0x9200             STR      R2,[SP, #+0]
   \      0x340   0x464B             MOV      R3,R9
   \      0x342   0x2210             MOVS     R2,#+16
   \      0x344   0x.... 0x....      BL       Str_UnsgnIntFmtOutput
   \      0x348   0x0006             MOVS     R6,R0
   \      0x34A   0xEB16 0x060B      ADDS     R6,R6,R11
   \      0x34E   0xE032             B.N      ??Str_PrintfImpl_38
   2393                      } else {
   2394                        if (*p_cur_char == 'p') {
   \                     ??Str_PrintfImpl_39: (+1)
   \      0x350   0x9806             LDR      R0,[SP, #+24]
   \      0x352   0x7800             LDRB     R0,[R0, #+0]
   \      0x354   0x2870             CMP      R0,#+112
   \      0x356   0xD117             BNE.N    ??Str_PrintfImpl_40
   2395                          output_char_cnt += Str_UnsgnIntFmtOutput((CPU_ADDR)va_arg(argp, void *),
   2396                                                                   16u,
   2397                                                                   min_field_width,
   2398                                                                   left_justify,
   2399                                                                   pad_char,
   2400                                                                   out_cb,
   2401                                                                   p_out_cb_arg,
   2402                                                                   max_char_cnt - output_char_cnt);
   \      0x358   0x6828             LDR      R0,[R5, #+0]
   \      0x35A   0x1D2D             ADDS     R5,R5,#+4
   \      0x35C   0x4641             MOV      R1,R8
   \      0x35E   0xB289             UXTH     R1,R1
   \      0x360   0xEBB1 0x010B      SUBS     R1,R1,R11
   \      0x364   0x9104             STR      R1,[SP, #+16]
   \      0x366   0x9403             STR      R4,[SP, #+12]
   \      0x368   0x9702             STR      R7,[SP, #+8]
   \      0x36A   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \      0x36E   0x9101             STR      R1,[SP, #+4]
   \      0x370   0x4651             MOV      R1,R10
   \      0x372   0xB2C9             UXTB     R1,R1
   \      0x374   0x9100             STR      R1,[SP, #+0]
   \      0x376   0x464B             MOV      R3,R9
   \      0x378   0x2210             MOVS     R2,#+16
   \      0x37A   0x2100             MOVS     R1,#+0
   \      0x37C   0x.... 0x....      BL       Str_UnsgnIntFmtOutput
   \      0x380   0x0006             MOVS     R6,R0
   \      0x382   0xEB16 0x060B      ADDS     R6,R6,R11
   \      0x386   0xE016             B.N      ??Str_PrintfImpl_38
   2403                        } else {
   2404                          output_char_cnt += Str_UnsgnIntFmtOutput(va_arg(argp, unsigned int),
   2405                                                                   16u,
   2406                                                                   min_field_width,
   2407                                                                   left_justify,
   2408                                                                   pad_char,
   2409                                                                   out_cb,
   2410                                                                   p_out_cb_arg,
   2411                                                                   max_char_cnt - output_char_cnt);
   \                     ??Str_PrintfImpl_40: (+1)
   \      0x388   0x6828             LDR      R0,[R5, #+0]
   \      0x38A   0x1D2D             ADDS     R5,R5,#+4
   \      0x38C   0x4641             MOV      R1,R8
   \      0x38E   0xB289             UXTH     R1,R1
   \      0x390   0xEBB1 0x010B      SUBS     R1,R1,R11
   \      0x394   0x9104             STR      R1,[SP, #+16]
   \      0x396   0x9403             STR      R4,[SP, #+12]
   \      0x398   0x9702             STR      R7,[SP, #+8]
   \      0x39A   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \      0x39E   0x9101             STR      R1,[SP, #+4]
   \      0x3A0   0x4651             MOV      R1,R10
   \      0x3A2   0xB2C9             UXTB     R1,R1
   \      0x3A4   0x9100             STR      R1,[SP, #+0]
   \      0x3A6   0x464B             MOV      R3,R9
   \      0x3A8   0x2210             MOVS     R2,#+16
   \      0x3AA   0x2100             MOVS     R1,#+0
   \      0x3AC   0x.... 0x....      BL       Str_UnsgnIntFmtOutput
   \      0x3B0   0x0006             MOVS     R6,R0
   \      0x3B2   0xEB16 0x060B      ADDS     R6,R6,R11
   2412                        }
   2413                      }
   2414                      arg_parsed = DEF_YES;
   \                     ??Str_PrintfImpl_38: (+1)
   \      0x3B6   0x2001             MOVS     R0,#+1
   \      0x3B8   0xF88D 0x0015      STRB     R0,[SP, #+21]
   2415                      break;
   \      0x3BC   0xE045             B.N      ??Str_PrintfImpl_23
   2416          
   2417                    case 's':
   2418                      output_char_cnt += Str_FmtOutput(va_arg(argp, CPU_CHAR *),
   2419                                                       min_field_width,
   2420                                                       max_field_width,
   2421                                                       left_justify,
   2422                                                       out_cb,
   2423                                                       p_out_cb_arg,
   2424                                                       max_char_cnt - output_char_cnt);
   \                     ??Str_PrintfImpl_19: (+1)
   \      0x3BE   0x6828             LDR      R0,[R5, #+0]
   \      0x3C0   0x1D2D             ADDS     R5,R5,#+4
   \      0x3C2   0x4641             MOV      R1,R8
   \      0x3C4   0xB289             UXTH     R1,R1
   \      0x3C6   0x1B89             SUBS     R1,R1,R6
   \      0x3C8   0x9102             STR      R1,[SP, #+8]
   \      0x3CA   0x9401             STR      R4,[SP, #+4]
   \      0x3CC   0x9700             STR      R7,[SP, #+0]
   \      0x3CE   0x4653             MOV      R3,R10
   \      0x3D0   0xB2DB             UXTB     R3,R3
   \      0x3D2   0x9A08             LDR      R2,[SP, #+32]
   \      0x3D4   0x4649             MOV      R1,R9
   \      0x3D6   0x.... 0x....      BL       Str_FmtOutput
   \      0x3DA   0x1980             ADDS     R0,R0,R6
   \      0x3DC   0x0006             MOVS     R6,R0
   2425                      arg_parsed = DEF_YES;
   \      0x3DE   0x2001             MOVS     R0,#+1
   \      0x3E0   0xF88D 0x0015      STRB     R0,[SP, #+21]
   2426                      break;
   \      0x3E4   0xE031             B.N      ??Str_PrintfImpl_23
   2427          
   2428                    case 'c':
   2429                      if (output_char_cnt < max_char_cnt) {
   \                     ??Str_PrintfImpl_15: (+1)
   \      0x3E6   0x4640             MOV      R0,R8
   \      0x3E8   0xB280             UXTH     R0,R0
   \      0x3EA   0x4286             CMP      R6,R0
   \      0x3EC   0xD203             BCS.N    ??Str_PrintfImpl_41
   2430                        out_cb(va_arg(argp, int), p_out_cb_arg);
   \      0x3EE   0x6828             LDR      R0,[R5, #+0]
   \      0x3F0   0x1D2D             ADDS     R5,R5,#+4
   \      0x3F2   0x0021             MOVS     R1,R4
   \      0x3F4   0x47B8             BLX      R7
   2431                      }
   2432                      output_char_cnt += 1u;
   \                     ??Str_PrintfImpl_41: (+1)
   \      0x3F6   0x1C76             ADDS     R6,R6,#+1
   2433                      arg_parsed = DEF_YES;
   \      0x3F8   0x2001             MOVS     R0,#+1
   \      0x3FA   0xF88D 0x0015      STRB     R0,[SP, #+21]
   2434                      break;
   \      0x3FE   0xE024             B.N      ??Str_PrintfImpl_23
   2435          
   2436                    case '\\':
   2437                      if (output_char_cnt < max_char_cnt) {
   \                     ??Str_PrintfImpl_14: (+1)
   \      0x400   0x4640             MOV      R0,R8
   \      0x402   0xB280             UXTH     R0,R0
   \      0x404   0x4286             CMP      R6,R0
   \      0x406   0xD21E             BCS.N    ??Str_PrintfImpl_42
   2438                        switch (*p_cur_char) {
   \      0x408   0x9806             LDR      R0,[SP, #+24]
   \      0x40A   0x7800             LDRB     R0,[R0, #+0]
   \      0x40C   0x2861             CMP      R0,#+97
   \      0x40E   0xD006             BEQ.N    ??Str_PrintfImpl_43
   \      0x410   0x2868             CMP      R0,#+104
   \      0x412   0xD008             BEQ.N    ??Str_PrintfImpl_44
   \      0x414   0x286E             CMP      R0,#+110
   \      0x416   0xD00E             BEQ.N    ??Str_PrintfImpl_45
   \      0x418   0x2872             CMP      R0,#+114
   \      0x41A   0xD008             BEQ.N    ??Str_PrintfImpl_46
   \      0x41C   0xE00F             B.N      ??Str_PrintfImpl_47
   2439                          case 'a':
   2440                            out_cb(0x07, p_out_cb_arg);
   \                     ??Str_PrintfImpl_43: (+1)
   \      0x41E   0x0021             MOVS     R1,R4
   \      0x420   0x2007             MOVS     R0,#+7
   \      0x422   0x47B8             BLX      R7
   2441                            break;
   \      0x424   0xE00F             B.N      ??Str_PrintfImpl_42
   2442                          case 'h':
   2443                            out_cb(0x08, p_out_cb_arg);
   \                     ??Str_PrintfImpl_44: (+1)
   \      0x426   0x0021             MOVS     R1,R4
   \      0x428   0x2008             MOVS     R0,#+8
   \      0x42A   0x47B8             BLX      R7
   2444                            break;
   \      0x42C   0xE00B             B.N      ??Str_PrintfImpl_42
   2445                          case 'r':
   2446                            out_cb(0x0D, p_out_cb_arg);
   \                     ??Str_PrintfImpl_46: (+1)
   \      0x42E   0x0021             MOVS     R1,R4
   \      0x430   0x200D             MOVS     R0,#+13
   \      0x432   0x47B8             BLX      R7
   2447                            break;
   \      0x434   0xE007             B.N      ??Str_PrintfImpl_42
   2448                          case 'n':
   2449                            out_cb(0x0A, p_out_cb_arg);
   \                     ??Str_PrintfImpl_45: (+1)
   \      0x436   0x0021             MOVS     R1,R4
   \      0x438   0x200A             MOVS     R0,#+10
   \      0x43A   0x47B8             BLX      R7
   2450                            break;
   \      0x43C   0xE003             B.N      ??Str_PrintfImpl_42
   2451                          default:
   2452                            out_cb((int)(*p_cur_char), p_out_cb_arg);
   \                     ??Str_PrintfImpl_47: (+1)
   \      0x43E   0x0021             MOVS     R1,R4
   \      0x440   0x9806             LDR      R0,[SP, #+24]
   \      0x442   0x7800             LDRB     R0,[R0, #+0]
   \      0x444   0x47B8             BLX      R7
   2453                            break;
   2454                        }
   2455                      }
   2456                      output_char_cnt += 1u;
   \                     ??Str_PrintfImpl_42: (+1)
   \      0x446   0x1C76             ADDS     R6,R6,#+1
   2457                      break;
   \      0x448   0xE7FF             B.N      ??Str_PrintfImpl_23
   2458          
   2459                    default:
   2460                      break;
   2461                  }
   2462                  p_cur_char += 1u;
   \                     ??Str_PrintfImpl_21: (+1)
   \                     ??Str_PrintfImpl_23: (+1)
   \      0x44A   0x9806             LDR      R0,[SP, #+24]
   \      0x44C   0x1C40             ADDS     R0,R0,#+1
   \      0x44E   0x9006             STR      R0,[SP, #+24]
   \      0x450   0xE618             B.N      ??Str_PrintfImpl_6
   2463                }
   2464              }
   2465            }
   2466          
   2467            return (output_char_cnt);
   \                     ??Str_PrintfImpl_1: (+1)
   \      0x452   0x0030             MOVS     R0,R6
   \      0x454   0xB280             UXTH     R0,R0
   \      0x456   0xB00B             ADD      SP,SP,#+44
   \      0x458   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2468          }
   2469          
   2470          /****************************************************************************************************//**
   2471           *                                               Str_SprintfCb()
   2472           *
   2473           * @brief    Str_Sprintf() and Str_Snprintf() output callback.
   2474           *
   2475           * @param    c       Character to be written.
   2476           *
   2477           * @param    p_arg   Pointer to an STR_SPRINTF_CB_ARG structure.
   2478           *
   2479           * @return   The written character.
   2480           *******************************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   2481          static int Str_SprintfCb(int  c,
   2482                                   void *p_arg)
   2483          {
   \                     Str_SprintfCb: (+1)
   \        0x0   0xB410             PUSH     {R4}
   2484            STR_SPRINTF_CB_ARG *p_sprintf_cb_arg;
   2485          
   2486            p_sprintf_cb_arg = (STR_SPRINTF_CB_ARG *)p_arg;
   \        0x2   0x000A             MOVS     R2,R1
   2487            p_sprintf_cb_arg->BufPtr[p_sprintf_cb_arg->CurIx++] = (CPU_CHAR)c;
   \        0x4   0x6853             LDR      R3,[R2, #+4]
   \        0x6   0x1C5C             ADDS     R4,R3,#+1
   \        0x8   0x6054             STR      R4,[R2, #+4]
   \        0xA   0x6814             LDR      R4,[R2, #+0]
   \        0xC   0x54E0             STRB     R0,[R4, R3]
   2488          
   2489            return (c);
   \        0xE   0xBC10             POP      {R4}
   \       0x10   0x4770             BX       LR
   2490          }
   2491          
   2492          /****************************************************************************************************//**
   2493           *                                               Str_FmtOutput()
   2494           *
   2495           * @brief    Justifies and outputs a given string.
   2496           *
   2497           * @param    p_str           Pointer to the string to output.
   2498           *
   2499           * @param    min_char_cnt    Minimum character count to output (pad if string shorter).
   2500           *
   2501           * @param    max_char_cnt    Maximum character count to output (truncate if string longer).
   2502           *
   2503           * @param    left_justify    Indicates whether to left or right justify.
   2504           *
   2505           * @param    out_cb          Character output callback.
   2506           *
   2507           * @param    p_out_cb_arg    Character output callback argument.
   2508           *
   2509           * @param    rem_size        Remaining character count to process.
   2510           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2511          static CPU_SIZE_T Str_FmtOutput(CPU_CHAR          *p_str,
   2512                                          CPU_SIZE_T        min_char_cnt,
   2513                                          CPU_SIZE_T        max_char_cnt,
   2514                                          CPU_BOOLEAN       left_justify,
   2515                                          STR_PRINTF_OUT_CB out_cb,
   2516                                          void              *p_out_cb_arg,
   2517                                          CPU_INT32S        rem_size)
   2518          {
   \                     Str_FmtOutput: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB081             SUB      SP,SP,#+4
   \        0x6   0xF8DD 0xB038      LDR      R11,[SP, #+56]
   \        0xA   0x9E0F             LDR      R6,[SP, #+60]
   \        0xC   0xF8DD 0x9040      LDR      R9,[SP, #+64]
   2519            CPU_CHAR   *p_cur_char;
   2520            CPU_CHAR   prev_char;
   2521            CPU_SIZE_T rem_char_cnt;
   2522            CPU_SIZE_T pad_char_cnt;
   2523            CPU_SIZE_T output_char_cnt;
   2524            CPU_SIZE_T len;
   2525          
   2526            //                                                               Chk if padding needed.
   2527            len = Str_Len(p_str);
   \       0x10   0x9801             LDR      R0,[SP, #+4]
   \       0x12   0x.... 0x....      BL       Str_Len
   \       0x16   0x0007             MOVS     R7,R0
   2528            pad_char_cnt = (len < min_char_cnt) ? min_char_cnt - len : 0u;
   \       0x18   0x9802             LDR      R0,[SP, #+8]
   \       0x1A   0x4287             CMP      R7,R0
   \       0x1C   0xD202             BCS.N    ??Str_FmtOutput_0
   \       0x1E   0x9C02             LDR      R4,[SP, #+8]
   \       0x20   0x1BE4             SUBS     R4,R4,R7
   \       0x22   0xE000             B.N      ??Str_FmtOutput_1
   \                     ??Str_FmtOutput_0: (+1)
   \       0x24   0x2400             MOVS     R4,#+0
   2529            output_char_cnt = 0u;
   \                     ??Str_FmtOutput_1: (+1)
   \       0x26   0xF05F 0x0800      MOVS     R8,#+0
   2530          
   2531            //                                                               Pad left if needed.
   2532            if (!left_justify && (pad_char_cnt > 0u)) {
   \       0x2A   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD10F             BNE.N    ??Str_FmtOutput_2
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD00D             BEQ.N    ??Str_FmtOutput_2
   2533              while (pad_char_cnt > 0u) {
   \                     ??Str_FmtOutput_3: (+1)
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD00B             BEQ.N    ??Str_FmtOutput_2
   2534                if (rem_size > 0) {
   \       0x3A   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x3E   0xDB02             BLT.N    ??Str_FmtOutput_4
   2535                  out_cb((int)' ', p_out_cb_arg);
   \       0x40   0x0031             MOVS     R1,R6
   \       0x42   0x2020             MOVS     R0,#+32
   \       0x44   0x47D8             BLX      R11
   2536                }
   2537                output_char_cnt += 1u;
   \                     ??Str_FmtOutput_4: (+1)
   \       0x46   0xF118 0x0801      ADDS     R8,R8,#+1
   2538                pad_char_cnt -= 1u;
   \       0x4A   0x1E64             SUBS     R4,R4,#+1
   2539                rem_size -= 1u;
   \       0x4C   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \       0x50   0xE7F1             B.N      ??Str_FmtOutput_3
   2540              }
   2541            }
   2542          
   2543            //                                                               Move string to the buffer
   2544            rem_char_cnt = DEF_MIN(DEF_MAX(min_char_cnt, len), max_char_cnt);
   \                     ??Str_FmtOutput_2: (+1)
   \       0x52   0x9802             LDR      R0,[SP, #+8]
   \       0x54   0x4287             CMP      R7,R0
   \       0x56   0xD201             BCS.N    ??Str_FmtOutput_5
   \       0x58   0x9902             LDR      R1,[SP, #+8]
   \       0x5A   0xE000             B.N      ??Str_FmtOutput_6
   \                     ??Str_FmtOutput_5: (+1)
   \       0x5C   0x0039             MOVS     R1,R7
   \                     ??Str_FmtOutput_6: (+1)
   \       0x5E   0x9803             LDR      R0,[SP, #+12]
   \       0x60   0x4281             CMP      R1,R0
   \       0x62   0xD206             BCS.N    ??Str_FmtOutput_7
   \       0x64   0x9802             LDR      R0,[SP, #+8]
   \       0x66   0x4287             CMP      R7,R0
   \       0x68   0xD201             BCS.N    ??Str_FmtOutput_8
   \       0x6A   0x9D02             LDR      R5,[SP, #+8]
   \       0x6C   0xE002             B.N      ??Str_FmtOutput_9
   \                     ??Str_FmtOutput_8: (+1)
   \       0x6E   0x003D             MOVS     R5,R7
   \       0x70   0xE000             B.N      ??Str_FmtOutput_9
   \                     ??Str_FmtOutput_7: (+1)
   \       0x72   0x9D03             LDR      R5,[SP, #+12]
   2545            p_cur_char = p_str;
   \                     ??Str_FmtOutput_9: (+1)
   \       0x74   0xF8DD 0xA004      LDR      R10,[SP, #+4]
   2546            prev_char = '\0';
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2547            while ((*p_cur_char != 0u) && (rem_char_cnt > 0u)) {
   \                     ??Str_FmtOutput_10: (+1)
   \       0x7E   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD014             BEQ.N    ??Str_FmtOutput_11
   \       0x86   0x2D00             CMP      R5,#+0
   \       0x88   0xD012             BEQ.N    ??Str_FmtOutput_11
   2548              if (rem_size > 0) {
   \       0x8A   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x8E   0xDB03             BLT.N    ??Str_FmtOutput_12
   2549                out_cb((int)(*p_cur_char), p_out_cb_arg);
   \       0x90   0x0031             MOVS     R1,R6
   \       0x92   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \       0x96   0x47D8             BLX      R11
   2550              }
   2551              prev_char = *p_cur_char;
   \                     ??Str_FmtOutput_12: (+1)
   \       0x98   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \       0x9C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2552              output_char_cnt += 1u;
   \       0xA0   0xF118 0x0801      ADDS     R8,R8,#+1
   2553              p_cur_char += 1u;
   \       0xA4   0xF11A 0x0A01      ADDS     R10,R10,#+1
   2554              rem_char_cnt -= 1u;
   \       0xA8   0x1E6D             SUBS     R5,R5,#+1
   2555              rem_size -= 1u;
   \       0xAA   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \       0xAE   0xE7E6             B.N      ??Str_FmtOutput_10
   2556            }
   2557            //                                                               Pad right if needed.
   2558            if (left_justify && (pad_char_cnt > 0u) && (prev_char != '\n') && (prev_char != '\r')) {
   \                     ??Str_FmtOutput_11: (+1)
   \       0xB0   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD017             BEQ.N    ??Str_FmtOutput_13
   \       0xB8   0x2C00             CMP      R4,#+0
   \       0xBA   0xD015             BEQ.N    ??Str_FmtOutput_13
   \       0xBC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xC0   0x280A             CMP      R0,#+10
   \       0xC2   0xD011             BEQ.N    ??Str_FmtOutput_13
   \       0xC4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xC8   0x280D             CMP      R0,#+13
   \       0xCA   0xD00D             BEQ.N    ??Str_FmtOutput_13
   2559              while (pad_char_cnt > 0u) {
   \                     ??Str_FmtOutput_14: (+1)
   \       0xCC   0x2C00             CMP      R4,#+0
   \       0xCE   0xD00B             BEQ.N    ??Str_FmtOutput_13
   2560                if (rem_size > 0) {
   \       0xD0   0xF1B9 0x0F01      CMP      R9,#+1
   \       0xD4   0xDB02             BLT.N    ??Str_FmtOutput_15
   2561                  out_cb((int)' ', p_out_cb_arg);
   \       0xD6   0x0031             MOVS     R1,R6
   \       0xD8   0x2020             MOVS     R0,#+32
   \       0xDA   0x47D8             BLX      R11
   2562                }
   2563                output_char_cnt += 1u;
   \                     ??Str_FmtOutput_15: (+1)
   \       0xDC   0xF118 0x0801      ADDS     R8,R8,#+1
   2564                pad_char_cnt -= 1u;
   \       0xE0   0x1E64             SUBS     R4,R4,#+1
   2565                rem_size -= 1u;
   \       0xE2   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \       0xE6   0xE7F1             B.N      ??Str_FmtOutput_14
   2566              }
   2567            }
   2568          
   2569            return (output_char_cnt);
   \                     ??Str_FmtOutput_13: (+1)
   \       0xE8   0x4640             MOV      R0,R8
   \       0xEA   0xB005             ADD      SP,SP,#+20
   \       0xEC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2570          }
   2571          
   2572          /****************************************************************************************************//**
   2573           *                                           Str_UnsgnIntFmtOutput()
   2574           *
   2575           * @brief    Formats and outputs an unsigned integer.
   2576           *
   2577           * @param    nbr             Number to output as a string.
   2578           *
   2579           * @param    base            Base used for the string conversion.
   2580           *
   2581           * @param    min_digit_cnt   Minimum number of digits to output (pad if less digits).
   2582           *
   2583           * @param    left_justify    Indicates whether to left or right justify.
   2584           *
   2585           * @param    pad_char        Character used for padding (normally either ' ' or '0').
   2586           *
   2587           * @param    out_cb          Character output callback.
   2588           *
   2589           * @param    p_out_cb_arg    Character output callback argument.
   2590           *
   2591           * @param    rem_size        Remaining character count to process.
   2592           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2593          static CPU_SIZE_T Str_UnsgnIntFmtOutput(CPU_INT64U        nbr,
   2594                                                  CPU_INT08U        base,
   2595                                                  CPU_SIZE_T        min_digit_cnt,
   2596                                                  CPU_BOOLEAN       left_justify,
   2597                                                  CPU_CHAR          pad_char,
   2598                                                  STR_PRINTF_OUT_CB out_cb,
   2599                                                  void              *p_out_cb_arg,
   2600                                                  CPU_INT32S        rem_size)
   2601          {
   \                     Str_UnsgnIntFmtOutput: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0xF8DD 0x8058      LDR      R8,[SP, #+88]
   \        0xE   0xF8DD 0x905C      LDR      R9,[SP, #+92]
   \       0x12   0x9F18             LDR      R7,[SP, #+96]
   2602            CPU_CHAR              *p_cur_char;
   2603            CPU_CHAR              outbuf[32];
   2604            CPU_SIZE_T            len;
   2605            CPU_SIZE_T            pad_char_cnt;
   2606            CPU_SIZE_T            output_char_cnt;
   2607            static const CPU_CHAR digits[] = "0123456789ABCDEF";
   2608          
   2609            //                                                               Build number.
   2610            p_cur_char = outbuf;
   \       0x14   0xAE01             ADD      R6,SP,#+4
   2611            do {
   2612              *p_cur_char = digits[nbr % base];
   \                     ??Str_UnsgnIntFmtOutput_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R10,??DataTable3
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0xF89D 0x2024      LDRB     R2,[SP, #+36]
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x28   0xF81A 0x0002      LDRB     R0,[R10, R2]
   \       0x2C   0x7030             STRB     R0,[R6, #+0]
   2613              p_cur_char += 1u;
   \       0x2E   0x1C76             ADDS     R6,R6,#+1
   2614            } while ((nbr /= base) > 0);
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x0029             MOVS     R1,R5
   \       0x34   0xF89D 0x2024      LDRB     R2,[SP, #+36]
   \       0x38   0x2300             MOVS     R3,#+0
   \       0x3A   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x3E   0x0004             MOVS     R4,R0
   \       0x40   0x000D             MOVS     R5,R1
   \       0x42   0x2D00             CMP      R5,#+0
   \       0x44   0xD1E7             BNE.N    ??Str_UnsgnIntFmtOutput_0
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD1E5             BNE.N    ??Str_UnsgnIntFmtOutput_0
   2615          
   2616            len = p_cur_char - outbuf;
   \       0x4A   0xA801             ADD      R0,SP,#+4
   \       0x4C   0x1A30             SUBS     R0,R6,R0
   \       0x4E   0x9000             STR      R0,[SP, #+0]
   2617            pad_char_cnt = (len < min_digit_cnt) ? min_digit_cnt - len : 0u;
   \       0x50   0x9900             LDR      R1,[SP, #+0]
   \       0x52   0x980A             LDR      R0,[SP, #+40]
   \       0x54   0x4281             CMP      R1,R0
   \       0x56   0xD205             BCS.N    ??Str_UnsgnIntFmtOutput_1
   \       0x58   0xF8DD 0xA028      LDR      R10,[SP, #+40]
   \       0x5C   0x9800             LDR      R0,[SP, #+0]
   \       0x5E   0xEBBA 0x0A00      SUBS     R10,R10,R0
   \       0x62   0xE001             B.N      ??Str_UnsgnIntFmtOutput_2
   \                     ??Str_UnsgnIntFmtOutput_1: (+1)
   \       0x64   0xF05F 0x0A00      MOVS     R10,#+0
   2618            output_char_cnt = 0u;
   \                     ??Str_UnsgnIntFmtOutput_2: (+1)
   \       0x68   0xF05F 0x0B00      MOVS     R11,#+0
   2619          
   2620            //                                                               Pad left if needed.
   2621            if (!left_justify && (pad_char_cnt > 0u)) {
   \       0x6C   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD111             BNE.N    ??Str_UnsgnIntFmtOutput_3
   \       0x74   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x78   0xD00E             BEQ.N    ??Str_UnsgnIntFmtOutput_3
   2622              while (pad_char_cnt > 0u) {
   \                     ??Str_UnsgnIntFmtOutput_4: (+1)
   \       0x7A   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x7E   0xD00B             BEQ.N    ??Str_UnsgnIntFmtOutput_3
   2623                if (rem_size > 0) {
   \       0x80   0x2F01             CMP      R7,#+1
   \       0x82   0xDB03             BLT.N    ??Str_UnsgnIntFmtOutput_5
   2624                  out_cb((int)pad_char, p_out_cb_arg);
   \       0x84   0x4649             MOV      R1,R9
   \       0x86   0xF89D 0x0054      LDRB     R0,[SP, #+84]
   \       0x8A   0x47C0             BLX      R8
   2625                }
   2626                output_char_cnt += 1u;
   \                     ??Str_UnsgnIntFmtOutput_5: (+1)
   \       0x8C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2627                pad_char_cnt -= 1u;
   \       0x90   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   2628                rem_size -= 1u;
   \       0x94   0x1E7F             SUBS     R7,R7,#+1
   \       0x96   0xE7F0             B.N      ??Str_UnsgnIntFmtOutput_4
   2629              }
   2630            }
   2631          
   2632            //                                                               Output number.
   2633            p_cur_char -= 1u;
   \                     ??Str_UnsgnIntFmtOutput_3: (+1)
   \       0x98   0x1E76             SUBS     R6,R6,#+1
   2634            while (p_cur_char >= outbuf) {
   \                     ??Str_UnsgnIntFmtOutput_6: (+1)
   \       0x9A   0xA801             ADD      R0,SP,#+4
   \       0x9C   0x4286             CMP      R6,R0
   \       0x9E   0xD309             BCC.N    ??Str_UnsgnIntFmtOutput_7
   2635              if (rem_size > 0) {
   \       0xA0   0x2F01             CMP      R7,#+1
   \       0xA2   0xDB02             BLT.N    ??Str_UnsgnIntFmtOutput_8
   2636                out_cb((int)(*p_cur_char), p_out_cb_arg);
   \       0xA4   0x4649             MOV      R1,R9
   \       0xA6   0x7830             LDRB     R0,[R6, #+0]
   \       0xA8   0x47C0             BLX      R8
   2637              }
   2638              output_char_cnt += 1u;
   \                     ??Str_UnsgnIntFmtOutput_8: (+1)
   \       0xAA   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2639              p_cur_char -= 1u;
   \       0xAE   0x1E76             SUBS     R6,R6,#+1
   2640              rem_size -= 1u;
   \       0xB0   0x1E7F             SUBS     R7,R7,#+1
   \       0xB2   0xE7F2             B.N      ??Str_UnsgnIntFmtOutput_6
   2641            }
   2642          
   2643            //                                                               Pad right if needed.
   2644            if (left_justify && (pad_char_cnt > 0u)) {
   \                     ??Str_UnsgnIntFmtOutput_7: (+1)
   \       0xB4   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD011             BEQ.N    ??Str_UnsgnIntFmtOutput_9
   \       0xBC   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xC0   0xD00E             BEQ.N    ??Str_UnsgnIntFmtOutput_9
   2645              while (pad_char_cnt > 0u) {
   \                     ??Str_UnsgnIntFmtOutput_10: (+1)
   \       0xC2   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xC6   0xD00B             BEQ.N    ??Str_UnsgnIntFmtOutput_9
   2646                if (rem_size > 0) {
   \       0xC8   0x2F01             CMP      R7,#+1
   \       0xCA   0xDB03             BLT.N    ??Str_UnsgnIntFmtOutput_11
   2647                  out_cb((int)pad_char, p_out_cb_arg);
   \       0xCC   0x4649             MOV      R1,R9
   \       0xCE   0xF89D 0x0054      LDRB     R0,[SP, #+84]
   \       0xD2   0x47C0             BLX      R8
   2648                }
   2649                output_char_cnt += 1u;
   \                     ??Str_UnsgnIntFmtOutput_11: (+1)
   \       0xD4   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2650                pad_char_cnt -= 1u;
   \       0xD8   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   2651                rem_size -= 1u;
   \       0xDC   0x1E7F             SUBS     R7,R7,#+1
   \       0xDE   0xE7F0             B.N      ??Str_UnsgnIntFmtOutput_10
   2652              }
   2653            }
   2654          
   2655            return (output_char_cnt);
   \                     ??Str_UnsgnIntFmtOutput_9: (+1)
   \       0xE0   0x4658             MOV      R0,R11
   \       0xE2   0xB00B             ADD      SP,SP,#+44
   \       0xE4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2656          }

   \                                 In section .rodata, align 4
   \                     `Str_UnsgnIntFmtOutput::digits`:
   \        0x0   0x30 0x31          DC8 "0123456789ABCDEF"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x00
   \       0x11                      DS8 3
   2657          
   2658          /****************************************************************************************************//**
   2659           *                                           Str_SngIntFmtOutput()
   2660           *
   2661           * @brief    Formats and outputs an signed integer.
   2662           *
   2663           * @param    nbr             Number to output as a string.
   2664           *
   2665           * @param    min_digit_cnt   Minimum number of digits to output (pad if less digits).
   2666           *
   2667           * @param    left_justify    Indicates whether to left or right justify.
   2668           *
   2669           * @param    pad_char        Character used for padding (normally either ' ' or '0').
   2670           *
   2671           * @param    out_cb          putchar-like callback.
   2672           *
   2673           * @param    p_out_cb_arg    Argument passed to callback.
   2674           *
   2675           * @param    rem_size        Remaining character count to process.
   2676           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2677          static CPU_SIZE_T Str_SngIntFmtOutput(CPU_INT64S        nbr,
   2678                                                CPU_SIZE_T        min_digit_cnt,
   2679                                                CPU_BOOLEAN       left_justify,
   2680                                                CPU_CHAR          pad_char,
   2681                                                STR_PRINTF_OUT_CB out_cb,
   2682                                                void              *p_out_cb_arg,
   2683                                                CPU_INT32S        rem_size)
   2684          {
   \                     Str_SngIntFmtOutput: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x9F17             LDR      R7,[SP, #+92]
   2685            CPU_CHAR              *p_cur_char;
   2686            CPU_CHAR              outbuf[32];
   2687            CPU_INT64U            abs_val;
   2688            CPU_SIZE_T            len;
   2689            CPU_SIZE_T            pad_char_cnt;
   2690            CPU_SIZE_T            output_char_cnt;
   2691            static const CPU_CHAR digits[] = "0123456789ABCDEF";
   2692          
   2693            //                                                               Build number (absolute value).
   2694            abs_val = (nbr < 0u) ? -nbr : nbr;
   \        0xC   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x10   0xD504             BPL.N    ??Str_SngIntFmtOutput_0
   \       0x12   0xF1D8 0x0400      RSBS     R4,R8,#+0
   \       0x16   0xEB79 0x0549      SBCS     R5,R9,R9, LSL #+1
   \       0x1A   0xE001             B.N      ??Str_SngIntFmtOutput_1
   \                     ??Str_SngIntFmtOutput_0: (+1)
   \       0x1C   0x4644             MOV      R4,R8
   \       0x1E   0x464D             MOV      R5,R9
   2695            p_cur_char = outbuf;
   \                     ??Str_SngIntFmtOutput_1: (+1)
   \       0x20   0xAE01             ADD      R6,SP,#+4
   2696            do {
   2697              *p_cur_char = digits[abs_val % 10];
   \                     ??Str_SngIntFmtOutput_2: (+1)
   \       0x22   0x.... 0x....      LDR.W    R10,??DataTable3_1
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0x220A             MOVS     R2,#+10
   \       0x2C   0x2300             MOVS     R3,#+0
   \       0x2E   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x32   0xF81A 0x0002      LDRB     R0,[R10, R2]
   \       0x36   0x7030             STRB     R0,[R6, #+0]
   2698              abs_val /= 10;
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x0029             MOVS     R1,R5
   \       0x3C   0x220A             MOVS     R2,#+10
   \       0x3E   0x2300             MOVS     R3,#+0
   \       0x40   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x44   0x0004             MOVS     R4,R0
   \       0x46   0x000D             MOVS     R5,R1
   2699              p_cur_char += 1u;
   \       0x48   0x1C76             ADDS     R6,R6,#+1
   2700            } while (abs_val > 0);
   \       0x4A   0x2D00             CMP      R5,#+0
   \       0x4C   0xD1E9             BNE.N    ??Str_SngIntFmtOutput_2
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xD1E7             BNE.N    ??Str_SngIntFmtOutput_2
   2701          
   2702            //                                                               Add minus sign if needed.
   2703            if (nbr < 0) {
   \       0x52   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x56   0xD502             BPL.N    ??Str_SngIntFmtOutput_3
   2704              *p_cur_char = '-';
   \       0x58   0x202D             MOVS     R0,#+45
   \       0x5A   0x7030             STRB     R0,[R6, #+0]
   2705              p_cur_char += 1u;
   \       0x5C   0x1C76             ADDS     R6,R6,#+1
   2706            }
   2707          
   2708            len = p_cur_char - outbuf;
   \                     ??Str_SngIntFmtOutput_3: (+1)
   \       0x5E   0xA801             ADD      R0,SP,#+4
   \       0x60   0x1A30             SUBS     R0,R6,R0
   \       0x62   0x9000             STR      R0,[SP, #+0]
   2709            pad_char_cnt = (len < min_digit_cnt) ? min_digit_cnt - len : 0u;
   \       0x64   0x9900             LDR      R1,[SP, #+0]
   \       0x66   0x9809             LDR      R0,[SP, #+36]
   \       0x68   0x4281             CMP      R1,R0
   \       0x6A   0xD205             BCS.N    ??Str_SngIntFmtOutput_4
   \       0x6C   0xF8DD 0xA024      LDR      R10,[SP, #+36]
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   \       0x72   0xEBBA 0x0A00      SUBS     R10,R10,R0
   \       0x76   0xE001             B.N      ??Str_SngIntFmtOutput_5
   \                     ??Str_SngIntFmtOutput_4: (+1)
   \       0x78   0xF05F 0x0A00      MOVS     R10,#+0
   2710            output_char_cnt = 0u;
   \                     ??Str_SngIntFmtOutput_5: (+1)
   \       0x7C   0xF05F 0x0B00      MOVS     R11,#+0
   2711          
   2712            //                                                               Pad left if needed.
   2713            if (!left_justify && (pad_char_cnt > 0u)) {
   \       0x80   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD112             BNE.N    ??Str_SngIntFmtOutput_6
   \       0x88   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x8C   0xD00F             BEQ.N    ??Str_SngIntFmtOutput_6
   2714              while (pad_char_cnt > 0u) {
   \                     ??Str_SngIntFmtOutput_7: (+1)
   \       0x8E   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x92   0xD00C             BEQ.N    ??Str_SngIntFmtOutput_6
   2715                if (rem_size > 0) {
   \       0x94   0x2F01             CMP      R7,#+1
   \       0x96   0xDB04             BLT.N    ??Str_SngIntFmtOutput_8
   2716                  out_cb((int)pad_char, p_out_cb_arg);
   \       0x98   0x9916             LDR      R1,[SP, #+88]
   \       0x9A   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \       0x9E   0x9A15             LDR      R2,[SP, #+84]
   \       0xA0   0x4790             BLX      R2
   2717                }
   2718                output_char_cnt += 1u;
   \                     ??Str_SngIntFmtOutput_8: (+1)
   \       0xA2   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2719                pad_char_cnt -= 1u;
   \       0xA6   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   2720                rem_size -= 1u;
   \       0xAA   0x1E7F             SUBS     R7,R7,#+1
   \       0xAC   0xE7EF             B.N      ??Str_SngIntFmtOutput_7
   2721              }
   2722            }
   2723          
   2724            //                                                               Output number.
   2725            p_cur_char -= 1u;
   \                     ??Str_SngIntFmtOutput_6: (+1)
   \       0xAE   0x1E76             SUBS     R6,R6,#+1
   2726            while (p_cur_char >= outbuf) {
   \                     ??Str_SngIntFmtOutput_9: (+1)
   \       0xB0   0xA801             ADD      R0,SP,#+4
   \       0xB2   0x4286             CMP      R6,R0
   \       0xB4   0xD30A             BCC.N    ??Str_SngIntFmtOutput_10
   2727              if (rem_size > 0) {
   \       0xB6   0x2F01             CMP      R7,#+1
   \       0xB8   0xDB03             BLT.N    ??Str_SngIntFmtOutput_11
   2728                out_cb((int)(*p_cur_char), p_out_cb_arg);
   \       0xBA   0x9916             LDR      R1,[SP, #+88]
   \       0xBC   0x7830             LDRB     R0,[R6, #+0]
   \       0xBE   0x9A15             LDR      R2,[SP, #+84]
   \       0xC0   0x4790             BLX      R2
   2729              }
   2730              output_char_cnt += 1u;
   \                     ??Str_SngIntFmtOutput_11: (+1)
   \       0xC2   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2731              p_cur_char -= 1u;
   \       0xC6   0x1E76             SUBS     R6,R6,#+1
   2732              rem_size -= 1u;
   \       0xC8   0x1E7F             SUBS     R7,R7,#+1
   \       0xCA   0xE7F1             B.N      ??Str_SngIntFmtOutput_9
   2733            }
   2734          
   2735            //                                                               Pad right if needed.
   2736            if (left_justify && (pad_char_cnt > 0u)) {
   \                     ??Str_SngIntFmtOutput_10: (+1)
   \       0xCC   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xD012             BEQ.N    ??Str_SngIntFmtOutput_12
   \       0xD4   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xD8   0xD00F             BEQ.N    ??Str_SngIntFmtOutput_12
   2737              while (pad_char_cnt > 0u) {
   \                     ??Str_SngIntFmtOutput_13: (+1)
   \       0xDA   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xDE   0xD00C             BEQ.N    ??Str_SngIntFmtOutput_12
   2738                if (rem_size > 0) {
   \       0xE0   0x2F01             CMP      R7,#+1
   \       0xE2   0xDB04             BLT.N    ??Str_SngIntFmtOutput_14
   2739                  out_cb((int)pad_char, p_out_cb_arg);
   \       0xE4   0x9916             LDR      R1,[SP, #+88]
   \       0xE6   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \       0xEA   0x9A15             LDR      R2,[SP, #+84]
   \       0xEC   0x4790             BLX      R2
   2740                }
   2741                output_char_cnt += 1u;
   \                     ??Str_SngIntFmtOutput_14: (+1)
   \       0xEE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   2742                pad_char_cnt -= 1u;
   \       0xF2   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   2743                rem_size -= 1u;
   \       0xF6   0x1E7F             SUBS     R7,R7,#+1
   \       0xF8   0xE7EF             B.N      ??Str_SngIntFmtOutput_13
   2744              }
   2745            }
   2746          
   2747            return (output_char_cnt);
   \                     ??Str_SngIntFmtOutput_12: (+1)
   \       0xFA   0x4658             MOV      R0,R11
   \       0xFC   0xB00B             ADD      SP,SP,#+44
   \       0xFE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2748          }

   \                                 In section .rodata, align 4
   \                     `Str_SngIntFmtOutput::digits`:
   \        0x0   0x30 0x31          DC8 "0123456789ABCDEF"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x00
   \       0x11                      DS8 3
   2749          
   2750          /****************************************************************************************************//**
   2751           *                                           Str_FmtNbr_Int32()
   2752           *
   2753           * @brief    Formats a 32-bit integer into a multi-digit character string.
   2754           *
   2755           * @param    nbr         Number to format.
   2756           *
   2757           * @param    nbr_dig     Number of digits to format (see Note #1).
   2758           *
   2759           * @param    nbr_base    Base of number to format. The number's base MUST be between 2 and 36,
   2760           *                       inclusively.
   2761           *                       The following may be used to specify the number base :
   2762           *                           - DEF_NBR_BASE_BIN            Base  2
   2763           *                           - DEF_NBR_BASE_OCT            Base  8
   2764           *                           - DEF_NBR_BASE_DEC            Base 10
   2765           *                           - DEF_NBR_BASE_HEX            Base 16
   2766           *
   2767           * @param    nbr_neg     Indicates whether number to format is negative :
   2768           *                           - DEF_NO          Number is non-negative.
   2769           *                           - DEF_YES         Number is     negative.
   2770           *                       Argument validated in Str_FmtNbr_Int32U(),
   2771           *                       Str_FmtNbr_Int32S().
   2772           *
   2773           * @param    lead_char   Prepend leading character. Leading character option prepends leading
   2774           *                       characters prior to the first non-zero digit. Leading character MUST be a
   2775           *                       printable ASCII character. Leading character MUST NOT be a number base digit,
   2776           *                       with the exception of '0'.
   2777           *                           - '\0'                    Do NOT prepend leading character to the string.
   2778           *                           - Printable character     Prepend leading character to the string.
   2779           *                           - Unprintable character   Format invalid string.
   2780           *
   2781           * @param    lower_case  Format alphabetic characters (if any) in lower case :
   2782           *                           - DEF_NO          Format alphabetic characters in upper case.
   2783           *                           - DEF_YES         Format alphabetic characters in lower case.
   2784           *
   2785           * @param    nul         Append terminating NULL-character. NULL-character terminate option DISABLED
   2786           *                       prevents overwriting previous character array formatting. Unless 'p_str'
   2787           *                       character array is pre-/post-terminated, NULL-character terminate option
   2788           *                       DISABLED will cause character string run-on.
   2789           *                           - DEF_NO          Do NOT append terminating NULL-character to the string.
   2790           *                           - DEF_YES         Append terminating NULL-character to the string.
   2791           *
   2792           * @param    p_str       Pointer to the character array to return formatted number string. Format
   2793           *                       buffer size is NOT validated; buffer overruns MUST be prevented by caller.
   2794           *                       To prevent character buffer overrun, character array size MUST be >=
   2795           *                       ('nbr_dig' + 1 negative sign + 1 'NUL' terminator) characters.
   2796           *
   2797           * @return   Pointer to the formatted string, if NO error(s).
   2798           *           Pointer to NULL, otherwise.
   2799           *
   2800           * @note     (1) The maximum number of digits to format for 32-bit integer numbers :
   2801           *                           @verbatim
   2802           *                           Maximum Number of             [  log (Number)      ]
   2803           *                       32-bit Integer Digits  =  floor [ -------------- + 1 ]
   2804           *                               to Format                 [   log (Base)       ]
   2805           *
   2806           *                           where
   2807           *                                   Number                  Number to format
   2808           *                                   Base            Base of number to format
   2809           *                           @endverbatim
   2810           *           - (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting is
   2811           *                   performed except possible NULL-termination of the string.
   2812           *                       Example :
   2813           *                           @verbatim
   2814           *                           nbr      = -23456
   2815           *                           nbr_dig  =  0
   2816           *                           nbr_base = 10
   2817           *
   2818           *                           p_str    = ""                       See Note #4a
   2819           *                           @endverbatim
   2820           *           - (b) If the number of digits to format ('nbr_dig') is less than the number of
   2821           *                   significant integer digits of the number to format ('nbr'); then an invalid
   2822           *                   string is formatted instead of truncating any significant integer digits.
   2823           *                       Example :
   2824           *                           @verbatim
   2825           *                           nbr      = 23456
   2826           *                           nbr_dig  = 3
   2827           *                           nbr_base = 10
   2828           *
   2829           *                           p_str    = "???"                    See Note #4b
   2830           *                           @endverbatim
   2831           *           - (c) If the number to format ('nbr') is negative but the number of digits to format
   2832           *                   ('nbr_dig') is equal to the number of significant integer digits of the number to
   2833           *                   format ('nbr'); then an invalid string is formatted instead of truncating the
   2834           *                   negative sign.
   2835           *                       Example :
   2836           *                           @verbatim
   2837           *                           nbr      = -23456
   2838           *                           nbr_dig  =  5
   2839           *                           nbr_base = 10
   2840           *
   2841           *                           p_str    = "?????"                  See Note #4b
   2842           *                           @endverbatim
   2843           *
   2844           * @note     (2) See usage examples below.
   2845           *           - (a) The number of leading characters is such that the total number of significant
   2846           *                   integer digits plus the number of leading characters plus possible negative sign
   2847           *                   character is equal to the requested number of integer digits to format
   2848           *                   ('nbr_dig').
   2849           *                       Examples :
   2850           *                           @verbatim
   2851           *                           nbr       = 23456
   2852           *                           nbr_dig   = 7
   2853           *                           nbr_base  = 10
   2854           *                           lead_char = ' '
   2855           *
   2856           *                           p_str     = "  23456"
   2857           *
   2858           *                           nbr       = -23456
   2859           *                           nbr_dig   = 7
   2860           *                           nbr_base  = 10
   2861           *                           lead_char = ' '
   2862           *
   2863           *                           p_str     = " -23456"
   2864           *                           @endverbatim
   2865           *           - (b) If the number to format ('nbr') is negative AND the leading character
   2866           *                   ('lead_char') is a '0' digit; then the negative sign character prefixes all
   2867           *                   leading characters prior to the formatted number.
   2868           *                       Examples :
   2869           *                           @verbatim
   2870           *                           nbr        = -23456
   2871           *                           nbr_dig    =  8
   2872           *                           nbr_base   = 10
   2873           *                           lead_char  = '0'
   2874           *
   2875           *                           p_str      = "-0023456"
   2876           *
   2877           *                           nbr        = -43981
   2878           *                           nbr_dig    =  8
   2879           *                           nbr_base   = 16
   2880           *                           lead_char  = '0'
   2881           *                           lower_case = DEF_NO
   2882           *
   2883           *                           p_str      = "-000ABCD"
   2884           *                           @endverbatim
   2885           *           - (c) If the number to format ('nbr') is negative AND the leading character
   2886           *                   ('lead_char') is NOT a '0' digit; then the negative sign character immediately
   2887           *                   prefixes the most significant digit of the formatted number.
   2888           *                       Examples :
   2889           *                           @verbatim
   2890           *                           nbr        = -23456
   2891           *                           nbr_dig    =  8
   2892           *                           nbr_base   = 10
   2893           *                           lead_char  = '#'
   2894           *
   2895           *                           p_str      = "##-23456"
   2896           *
   2897           *                           nbr        = -43981
   2898           *                           nbr_dig    =  8
   2899           *                           nbr_base   = 16
   2900           *                           lead_char  = '#'
   2901           *                           lower_case = DEF_YES
   2902           *
   2903           *                           p_str      = "###-abcd"
   2904           *                           @endverbatim
   2905           *           - (d) If the value of the number to format is zero & the number of digits to format is
   2906           *                   non-zero, but NO leading character available; then one digit of '0' value is
   2907           *                   formatted. This is NOT a leading character; but a single integer digit of '0'
   2908           *                   value.
   2909           *
   2910           * @note     (3) String format terminates when :
   2911           *               - (a) Format string pointer is passed a NULL pointer. No string formatted. NULL
   2912           *                     pointer is returned.
   2913           *               - (b) Number of digits to format ('nbr_dig') is zero. NULL string formatted. NULL
   2914           *                     pointer is returned.
   2915           *               - (c) Number of digits to format ('nbr_dig') is less than number of significant integer
   2916           *                     digits of the number to format ('nbr'), including possible negative sign. Invalid
   2917           *                     string formatted. NULL pointer is returned.
   2918           *               - (d) Base is passed an invalid base. Invalid string format performed; NULL pointer is
   2919           *                     returned.
   2920           *               - (e) Lead character is NOT a valid, printable character. Invalid string formatted.
   2921           *                     NULL pointer is returned.
   2922           *               - (f) Number successfully formatted into character string array.
   2923           *
   2924           * @note     (4) For any unsuccessful string format or error(s), an invalid string of question marks
   2925           *               ('?') will be formatted, where the number of question marks is determined by the
   2926           *               number of digits to format ('nbr_dig') :
   2927           *                   @verbatim
   2928           *                   Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   2929           *                       number of     =  {
   2930           *                   question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   2931           *                   @endverbatim
   2932           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2933          static CPU_CHAR *Str_FmtNbr_Int32(CPU_INT32U  nbr,
   2934                                            CPU_INT08U  nbr_dig,
   2935                                            CPU_INT08U  nbr_base,
   2936                                            CPU_BOOLEAN nbr_neg,
   2937                                            CPU_CHAR    lead_char,
   2938                                            CPU_BOOLEAN lower_case,
   2939                                            CPU_BOOLEAN nul,
   2940                                            CPU_CHAR    *p_str)
   2941          {
   \                     Str_FmtNbr_Int32: (+1)
   \        0x0   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \        0x4   0xB082             SUB      SP,SP,#+8
   \        0x6   0x4693             MOV      R11,R2
   \        0x8   0x9D0E             LDR      R5,[SP, #+56]
   2942            CPU_CHAR    *p_str_fmt;
   2943            CPU_DATA    i;
   2944            CPU_INT32U  nbr_fmt = 0;
   \        0xA   0x2400             MOVS     R4,#+0
   2945            CPU_INT32U  nbr_log;
   2946            CPU_INT08U  nbr_dig_max;
   2947            CPU_INT08U  nbr_dig_min;
   2948            CPU_INT08U  nbr_dig_fmtd = 0;
   \        0xC   0xF05F 0x0900      MOVS     R9,#+0
   2949            CPU_INT08U  nbr_neg_sign;
   2950            CPU_INT08U  nbr_lead_char;
   2951            CPU_INT08U  dig_val;
   2952            CPU_INT08U  lead_char_delta_0;
   2953            CPU_INT08U  lead_char_delta_a;
   2954            CPU_BOOLEAN lead_char_dig;
   2955            CPU_BOOLEAN lead_char_0;
   2956            CPU_BOOLEAN fmt_valid = DEF_YES;
   \       0x10   0xF05F 0x0A01      MOVS     R10,#+1
   2957            CPU_BOOLEAN print_char;
   2958            CPU_BOOLEAN nbr_neg_fmtd = DEF_NO;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF88D 0x0002      STRB     R0,[SP, #+2]
   2959          
   2960            //                                                               ---------------- VALIDATE FMT ARGS -----------------
   2961            if (p_str == DEF_NULL) {                                      // Rtn NULL if str ptr NULL (see Note #3a).
   \       0x1A   0x9811             LDR      R0,[SP, #+68]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD101             BNE.N    ??Str_FmtNbr_Int32_0
   2962              return (DEF_NULL);
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xE12C             B.N      ??Str_FmtNbr_Int32_1
   2963            }
   2964          
   2965            if (nbr_dig < 1) {                                            // If nbr digs = 0, ...
   \                     ??Str_FmtNbr_Int32_0: (+1)
   \       0x24   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD101             BNE.N    ??Str_FmtNbr_Int32_2
   2966              fmt_valid = DEF_NO;                                         // ... fmt valid str (see Note #3b).
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x4682             MOV      R10,R0
   2967            }
   2968            //                                                               If invalid base, ...
   2969            if ((nbr_base < 2u)
   2970                || (nbr_base > 36u)) {
   \                     ??Str_FmtNbr_Int32_2: (+1)
   \       0x30   0x4658             MOV      R0,R11
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0x2802             CMP      R0,#+2
   \       0x36   0xD303             BCC.N    ??Str_FmtNbr_Int32_3
   \       0x38   0x4658             MOV      R0,R11
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0x2825             CMP      R0,#+37
   \       0x3E   0xD301             BCC.N    ??Str_FmtNbr_Int32_4
   2971              fmt_valid = DEF_NO;                                         // ... fmt valid str (see Note #3d).
   \                     ??Str_FmtNbr_Int32_3: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x4682             MOV      R10,R0
   2972            }
   2973          
   2974            if (lead_char != (CPU_CHAR)'\0') {
   \                     ??Str_FmtNbr_Int32_4: (+1)
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD047             BEQ.N    ??Str_FmtNbr_Int32_5
   2975              print_char = ASCII_IsPrint(lead_char);
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0xB2C0             UXTB     R0,R0
   \       0x50   0x.... 0x....      BL       ASCII_IsPrint
   \       0x54   0xF88D 0x0007      STRB     R0,[SP, #+7]
   2976              if (print_char != DEF_YES) {                                // If lead char non-printable, ...
   \       0x58   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \       0x5C   0x2801             CMP      R0,#+1
   \       0x5E   0xD002             BEQ.N    ??Str_FmtNbr_Int32_6
   2977                fmt_valid = DEF_NO;                                       // ... fmt valid str (see Note #3e).
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x4682             MOV      R10,R0
   \       0x64   0xE03A             B.N      ??Str_FmtNbr_Int32_5
   2978              } else if (lead_char != '0') {                              // Chk lead char for non-0 nbr base dig.
   \                     ??Str_FmtNbr_Int32_6: (+1)
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0xB2C0             UXTB     R0,R0
   \       0x6A   0x2830             CMP      R0,#+48
   \       0x6C   0xD036             BEQ.N    ??Str_FmtNbr_Int32_5
   2979                lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
   \       0x6E   0xF1B5 0x0030      SUBS     R0,R5,#+48
   \       0x72   0xF88D 0x0005      STRB     R0,[SP, #+5]
   2980                if (lower_case != DEF_YES) {
   \       0x76   0xF89D 0x003C      LDRB     R0,[SP, #+60]
   \       0x7A   0x2801             CMP      R0,#+1
   \       0x7C   0xD004             BEQ.N    ??Str_FmtNbr_Int32_7
   2981                  lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
   \       0x7E   0xF1B5 0x0041      SUBS     R0,R5,#+65
   \       0x82   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \       0x86   0xE003             B.N      ??Str_FmtNbr_Int32_8
   2982                } else {
   2983                  lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
   \                     ??Str_FmtNbr_Int32_7: (+1)
   \       0x88   0xF1B5 0x0061      SUBS     R0,R5,#+97
   \       0x8C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2984                }
   2985          
   2986                lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 < nbr_base))
   2987                                 || ((nbr_base > 10u) && ((lead_char_delta_0 < 10u)
   2988                                                          || (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
   \                     ??Str_FmtNbr_Int32_8: (+1)
   \       0x90   0x4658             MOV      R0,R11
   \       0x92   0xB2C0             UXTB     R0,R0
   \       0x94   0x280B             CMP      R0,#+11
   \       0x96   0xD205             BCS.N    ??Str_FmtNbr_Int32_9
   \       0x98   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \       0x9C   0x4658             MOV      R0,R11
   \       0x9E   0xB2C0             UXTB     R0,R0
   \       0xA0   0x4281             CMP      R1,R0
   \       0xA2   0xD30E             BCC.N    ??Str_FmtNbr_Int32_10
   \                     ??Str_FmtNbr_Int32_9: (+1)
   \       0xA4   0x4658             MOV      R0,R11
   \       0xA6   0xB2C0             UXTB     R0,R0
   \       0xA8   0x280B             CMP      R0,#+11
   \       0xAA   0xD30E             BCC.N    ??Str_FmtNbr_Int32_11
   \       0xAC   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \       0xB0   0x280A             CMP      R0,#+10
   \       0xB2   0xD306             BCC.N    ??Str_FmtNbr_Int32_10
   \       0xB4   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0xB8   0x4658             MOV      R0,R11
   \       0xBA   0xB2C0             UXTB     R0,R0
   \       0xBC   0x380A             SUBS     R0,R0,#+10
   \       0xBE   0x4281             CMP      R1,R0
   \       0xC0   0xD203             BCS.N    ??Str_FmtNbr_Int32_11
   \                     ??Str_FmtNbr_Int32_10: (+1)
   \       0xC2   0x2001             MOVS     R0,#+1
   \       0xC4   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \       0xC8   0xE002             B.N      ??Str_FmtNbr_Int32_12
   \                     ??Str_FmtNbr_Int32_11: (+1)
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0xF88D 0x0003      STRB     R0,[SP, #+3]
   2989          
   2990                if (lead_char_dig == DEF_YES) {                           // If lead char non-0 nbr base dig, ...
   \                     ??Str_FmtNbr_Int32_12: (+1)
   \       0xD0   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \       0xD4   0x2801             CMP      R0,#+1
   \       0xD6   0xD101             BNE.N    ??Str_FmtNbr_Int32_5
   2991                  fmt_valid = DEF_NO;                                     // ... fmt valid str               (see Note #3e).
   \       0xD8   0x2000             MOVS     R0,#+0
   \       0xDA   0x4682             MOV      R10,R0
   2992                }
   2993              }
   2994            }
   2995          
   2996            //                                                               ----------------- PREPARE NBR FMT ------------------
   2997            p_str_fmt = p_str;
   \                     ??Str_FmtNbr_Int32_5: (+1)
   \       0xDC   0x9911             LDR      R1,[SP, #+68]
   2998            lead_char_0 = DEF_NO;
   \       0xDE   0x2300             MOVS     R3,#+0
   2999          
   3000            if (fmt_valid == DEF_YES) {
   \       0xE0   0x4650             MOV      R0,R10
   \       0xE2   0xB2C0             UXTB     R0,R0
   \       0xE4   0x2801             CMP      R0,#+1
   \       0xE6   0xD157             BNE.N    ??Str_FmtNbr_Int32_13
   3001              nbr_fmt = nbr;
   \       0xE8   0x9802             LDR      R0,[SP, #+8]
   \       0xEA   0x0004             MOVS     R4,R0
   3002              nbr_log = nbr;
   \       0xEC   0x9802             LDR      R0,[SP, #+8]
   \       0xEE   0x0006             MOVS     R6,R0
   3003              nbr_dig_max = 1u;
   \       0xF0   0x2001             MOVS     R0,#+1
   \       0xF2   0x0007             MOVS     R7,R0
   3004              while (nbr_log >= nbr_base) {                               // While nbr base digs avail, ...
   \                     ??Str_FmtNbr_Int32_14: (+1)
   \       0xF4   0x4658             MOV      R0,R11
   \       0xF6   0xB2C0             UXTB     R0,R0
   \       0xF8   0x4286             CMP      R6,R0
   \       0xFA   0xD305             BCC.N    ??Str_FmtNbr_Int32_15
   3005                nbr_dig_max++;                                            // ... calc max nbr digs.
   \       0xFC   0x1C7F             ADDS     R7,R7,#+1
   3006                nbr_log /= nbr_base;
   \       0xFE   0x4658             MOV      R0,R11
   \      0x100   0xB2C0             UXTB     R0,R0
   \      0x102   0xFBB6 0xF6F0      UDIV     R6,R6,R0
   \      0x106   0xE7F5             B.N      ??Str_FmtNbr_Int32_14
   3007              }
   3008          
   3009              nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
   \                     ??Str_FmtNbr_Int32_15: (+1)
   \      0x108   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \      0x10C   0x2801             CMP      R0,#+1
   \      0x10E   0xD102             BNE.N    ??Str_FmtNbr_Int32_16
   \      0x110   0xF05F 0x0801      MOVS     R8,#+1
   \      0x114   0xE001             B.N      ??Str_FmtNbr_Int32_17
   \                     ??Str_FmtNbr_Int32_16: (+1)
   \      0x116   0xF05F 0x0800      MOVS     R8,#+0
   3010              if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {              // If req'd nbr digs >= (max nbr digs + neg sign), ...
   \                     ??Str_FmtNbr_Int32_17: (+1)
   \      0x11A   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0x11E   0x4642             MOV      R2,R8
   \      0x120   0xB2D2             UXTB     R2,R2
   \      0x122   0xFA52 0xF287      UXTAB    R2,R2,R7
   \      0x126   0x4290             CMP      R0,R2
   \      0x128   0xDB34             BLT.N    ??Str_FmtNbr_Int32_18
   3011                nbr_neg_fmtd = DEF_NO;
   \      0x12A   0x2000             MOVS     R0,#+0
   \      0x12C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   3012                nbr_dig_min = DEF_MIN(nbr_dig_max, nbr_dig);
   \      0x130   0x003A             MOVS     R2,R7
   \      0x132   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0x136   0xB2D2             UXTB     R2,R2
   \      0x138   0x4282             CMP      R2,R0
   \      0x13A   0xD202             BCS.N    ??Str_FmtNbr_Int32_19
   \      0x13C   0xF88D 0x7001      STRB     R7,[SP, #+1]
   \      0x140   0xE003             B.N      ??Str_FmtNbr_Int32_20
   \                     ??Str_FmtNbr_Int32_19: (+1)
   \      0x142   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0x146   0xF88D 0x0001      STRB     R0,[SP, #+1]
   3013                //                                                           ... calc nbr digs to fmt & nbr lead chars.
   3014                if (lead_char != (CPU_CHAR)'\0') {
   \                     ??Str_FmtNbr_Int32_20: (+1)
   \      0x14A   0x0028             MOVS     R0,R5
   \      0x14C   0xB2C0             UXTB     R0,R0
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD00C             BEQ.N    ??Str_FmtNbr_Int32_21
   3015                  nbr_dig_fmtd = nbr_dig;
   \      0x152   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0x156   0x4681             MOV      R9,R0
   3016                  nbr_lead_char = nbr_dig
   3017                                  - (nbr_dig_min + nbr_neg_sign);
   \      0x158   0xF89D 0x200C      LDRB     R2,[SP, #+12]
   \      0x15C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \      0x160   0x1A12             SUBS     R2,R2,R0
   \      0x162   0xEBB2 0x0208      SUBS     R2,R2,R8
   \      0x166   0xF88D 0x2006      STRB     R2,[SP, #+6]
   \      0x16A   0xE007             B.N      ??Str_FmtNbr_Int32_22
   3018                } else {
   3019                  nbr_dig_fmtd = nbr_dig_min + nbr_neg_sign;
   \                     ??Str_FmtNbr_Int32_21: (+1)
   \      0x16C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \      0x170   0xEB18 0x0000      ADDS     R0,R8,R0
   \      0x174   0x4681             MOV      R9,R0
   3020                  nbr_lead_char = 0u;
   \      0x176   0x2000             MOVS     R0,#+0
   \      0x178   0xF88D 0x0006      STRB     R0,[SP, #+6]
   3021                }
   3022          
   3023                if (nbr_lead_char > 0) {                                  // If lead chars to fmt, ...
   \                     ??Str_FmtNbr_Int32_22: (+1)
   \      0x17C   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xD009             BEQ.N    ??Str_FmtNbr_Int32_13
   3024                  lead_char_0 = (lead_char == '0')                        // ... chk if lead char a '0' dig.
   3025                                ?  DEF_YES : DEF_NO;
   \      0x184   0x0028             MOVS     R0,R5
   \      0x186   0xB2C0             UXTB     R0,R0
   \      0x188   0x2830             CMP      R0,#+48
   \      0x18A   0xD101             BNE.N    ??Str_FmtNbr_Int32_23
   \      0x18C   0x2301             MOVS     R3,#+1
   \      0x18E   0xE003             B.N      ??Str_FmtNbr_Int32_13
   \                     ??Str_FmtNbr_Int32_23: (+1)
   \      0x190   0x2300             MOVS     R3,#+0
   \      0x192   0xE001             B.N      ??Str_FmtNbr_Int32_13
   3026                }
   3027              } else {                                                    // Else if nbr trunc'd, ...
   3028                fmt_valid = DEF_NO;                                       // ... fmt valid str (see Note #3c).
   \                     ??Str_FmtNbr_Int32_18: (+1)
   \      0x194   0x2000             MOVS     R0,#+0
   \      0x196   0x4682             MOV      R10,R0
   3029              }
   3030            }
   3031          
   3032            if (fmt_valid == DEF_NO) {
   \                     ??Str_FmtNbr_Int32_13: (+1)
   \      0x198   0x4650             MOV      R0,R10
   \      0x19A   0xB2C0             UXTB     R0,R0
   \      0x19C   0x2800             CMP      R0,#+0
   \      0x19E   0xD102             BNE.N    ??Str_FmtNbr_Int32_24
   3033              nbr_dig_fmtd = nbr_dig;
   \      0x1A0   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0x1A4   0x4681             MOV      R9,R0
   3034            }
   3035          
   3036            //                                                               ------------------- FMT NBR STR --------------------
   3037            p_str_fmt += nbr_dig_fmtd;                                    // Start fmt @ least-sig dig.
   \                     ??Str_FmtNbr_Int32_24: (+1)
   \      0x1A6   0x4648             MOV      R0,R9
   \      0x1A8   0xB2C0             UXTB     R0,R0
   \      0x1AA   0x4401             ADD      R1,R1,R0
   3038          
   3039            if (nul != DEF_NO) {                                          // If NOT DISABLED, append NULL char.
   \      0x1AC   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \      0x1B0   0x2800             CMP      R0,#+0
   \      0x1B2   0xD001             BEQ.N    ??Str_FmtNbr_Int32_25
   3040              *p_str_fmt = (CPU_CHAR)'\0';
   \      0x1B4   0x2000             MOVS     R0,#+0
   \      0x1B6   0x7008             STRB     R0,[R1, #+0]
   3041            }
   3042            p_str_fmt--;
   \                     ??Str_FmtNbr_Int32_25: (+1)
   \      0x1B8   0x1E4A             SUBS     R2,R1,#+1
   3043          
   3044            for (i = 0u; i < nbr_dig_fmtd; i++) {                         // Fmt str for desired nbr digs :
   \      0x1BA   0x2100             MOVS     R1,#+0
   \                     ??Str_FmtNbr_Int32_26: (+1)
   \      0x1BC   0x4648             MOV      R0,R9
   \      0x1BE   0xB2C0             UXTB     R0,R0
   \      0x1C0   0x4281             CMP      R1,R0
   \      0x1C2   0xD255             BCS.N    ??Str_FmtNbr_Int32_27
   3045              if (fmt_valid == DEF_YES) {
   \      0x1C4   0x4650             MOV      R0,R10
   \      0x1C6   0xB2C0             UXTB     R0,R0
   \      0x1C8   0x2801             CMP      R0,#+1
   \      0x1CA   0xD14C             BNE.N    ??Str_FmtNbr_Int32_28
   3046                if ((nbr_fmt > 0)                                         // If fmt nbr > 0 ...
   3047                    || (i == 0u)) {                                       // ... OR on one's  dig to fmt (see Note #2d), ...
   \      0x1CC   0x2C00             CMP      R4,#+0
   \      0x1CE   0xD101             BNE.N    ??Str_FmtNbr_Int32_29
   \      0x1D0   0x2900             CMP      R1,#+0
   \      0x1D2   0xD125             BNE.N    ??Str_FmtNbr_Int32_30
   3048                                                                          // ... calc & fmt dig val;
   3049                  dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
   \                     ??Str_FmtNbr_Int32_29: (+1)
   \      0x1D4   0x4658             MOV      R0,R11
   \      0x1D6   0xB2C0             UXTB     R0,R0
   \      0x1D8   0xFBB4 0xFCF0      UDIV     R12,R4,R0
   \      0x1DC   0xFB00 0x401C      MLS      R0,R0,R12,R4
   \      0x1E0   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3050                  if (dig_val < 10u) {
   \      0x1E4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x1E8   0x280A             CMP      R0,#+10
   \      0x1EA   0xD205             BCS.N    ??Str_FmtNbr_Int32_31
   3051                    *p_str_fmt-- = (CPU_CHAR)(dig_val + '0');
   \      0x1EC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x1F0   0x3030             ADDS     R0,R0,#+48
   \      0x1F2   0x7010             STRB     R0,[R2, #+0]
   \      0x1F4   0x1E52             SUBS     R2,R2,#+1
   \      0x1F6   0xE00E             B.N      ??Str_FmtNbr_Int32_32
   3052                  } else {
   3053                    if (lower_case != DEF_YES) {
   \                     ??Str_FmtNbr_Int32_31: (+1)
   \      0x1F8   0xF89D 0x003C      LDRB     R0,[SP, #+60]
   \      0x1FC   0x2801             CMP      R0,#+1
   \      0x1FE   0xD005             BEQ.N    ??Str_FmtNbr_Int32_33
   3054                      *p_str_fmt-- = (CPU_CHAR)((dig_val - 10u) + 'A');
   \      0x200   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x204   0x3037             ADDS     R0,R0,#+55
   \      0x206   0x7010             STRB     R0,[R2, #+0]
   \      0x208   0x1E52             SUBS     R2,R2,#+1
   \      0x20A   0xE004             B.N      ??Str_FmtNbr_Int32_32
   3055                    } else {
   3056                      *p_str_fmt-- = (CPU_CHAR)((dig_val - 10u) + 'a');
   \                     ??Str_FmtNbr_Int32_33: (+1)
   \      0x20C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x210   0x3057             ADDS     R0,R0,#+87
   \      0x212   0x7010             STRB     R0,[R2, #+0]
   \      0x214   0x1E52             SUBS     R2,R2,#+1
   3057                    }
   3058                  }
   3059          
   3060                  nbr_fmt /= nbr_base;                                    // Shift to next more-sig dig.
   \                     ??Str_FmtNbr_Int32_32: (+1)
   \      0x216   0x4658             MOV      R0,R11
   \      0x218   0xB2C0             UXTB     R0,R0
   \      0x21A   0xFBB4 0xF4F0      UDIV     R4,R4,R0
   \      0x21E   0xE025             B.N      ??Str_FmtNbr_Int32_34
   3061                } else if ((nbr_neg == DEF_YES)                           // ... else if nbr neg AND ...
   3062                           && (((lead_char_0 == DEF_NO)                   // ... lead char NOT a '0' dig ...
   3063                                && (nbr_neg_fmtd == DEF_NO))              // ... but neg sign NOT yet fmt'd OR ...
   3064                               || ((lead_char_0 != DEF_NO)                // ... lead char is  a '0' dig ...
   3065                                   && (i == (nbr_dig_fmtd - 1u))))) {     // ... & on most-sig dig to fmt, ...
   \                     ??Str_FmtNbr_Int32_30: (+1)
   \      0x220   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \      0x224   0x2801             CMP      R0,#+1
   \      0x226   0xD117             BNE.N    ??Str_FmtNbr_Int32_35
   \      0x228   0x0018             MOVS     R0,R3
   \      0x22A   0xB2C0             UXTB     R0,R0
   \      0x22C   0x2800             CMP      R0,#+0
   \      0x22E   0xD103             BNE.N    ??Str_FmtNbr_Int32_36
   \      0x230   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \      0x234   0x2800             CMP      R0,#+0
   \      0x236   0xD008             BEQ.N    ??Str_FmtNbr_Int32_37
   \                     ??Str_FmtNbr_Int32_36: (+1)
   \      0x238   0x0018             MOVS     R0,R3
   \      0x23A   0xB2C0             UXTB     R0,R0
   \      0x23C   0x2800             CMP      R0,#+0
   \      0x23E   0xD00B             BEQ.N    ??Str_FmtNbr_Int32_35
   \      0x240   0x4648             MOV      R0,R9
   \      0x242   0xB2C0             UXTB     R0,R0
   \      0x244   0x1E40             SUBS     R0,R0,#+1
   \      0x246   0x4281             CMP      R1,R0
   \      0x248   0xD106             BNE.N    ??Str_FmtNbr_Int32_35
   3066                  *p_str_fmt-- = '-';                                     // ... prepend neg sign (see Note #2a); ...
   \                     ??Str_FmtNbr_Int32_37: (+1)
   \      0x24A   0x202D             MOVS     R0,#+45
   \      0x24C   0x7010             STRB     R0,[R2, #+0]
   \      0x24E   0x1E52             SUBS     R2,R2,#+1
   3067                  nbr_neg_fmtd = DEF_YES;
   \      0x250   0x2001             MOVS     R0,#+1
   \      0x252   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \      0x256   0xE009             B.N      ??Str_FmtNbr_Int32_34
   3068                } else if (lead_char != (CPU_CHAR)'\0') {                 // ... else if avail, ...
   \                     ??Str_FmtNbr_Int32_35: (+1)
   \      0x258   0x0028             MOVS     R0,R5
   \      0x25A   0xB2C0             UXTB     R0,R0
   \      0x25C   0x2800             CMP      R0,#+0
   \      0x25E   0xD005             BEQ.N    ??Str_FmtNbr_Int32_34
   3069                  *p_str_fmt-- = lead_char;                               // ... fmt lead char.
   \      0x260   0x7015             STRB     R5,[R2, #+0]
   \      0x262   0x1E52             SUBS     R2,R2,#+1
   \      0x264   0xE002             B.N      ??Str_FmtNbr_Int32_34
   3070                }
   3071              } else {                                                    // Else fmt '?' for invalid str (see Note #4).
   3072                *p_str_fmt-- = '?';
   \                     ??Str_FmtNbr_Int32_28: (+1)
   \      0x266   0x203F             MOVS     R0,#+63
   \      0x268   0x7010             STRB     R0,[R2, #+0]
   \      0x26A   0x1E52             SUBS     R2,R2,#+1
   3073              }
   3074            }
   \                     ??Str_FmtNbr_Int32_34: (+1)
   \      0x26C   0x1C49             ADDS     R1,R1,#+1
   \      0x26E   0xE7A5             B.N      ??Str_FmtNbr_Int32_26
   3075          
   3076            if (fmt_valid == DEF_NO) {                                    // Rtn NULL for invalid str fmt (see Notes #3a - #3e).
   \                     ??Str_FmtNbr_Int32_27: (+1)
   \      0x270   0x4650             MOV      R0,R10
   \      0x272   0xB2C0             UXTB     R0,R0
   \      0x274   0x2800             CMP      R0,#+0
   \      0x276   0xD101             BNE.N    ??Str_FmtNbr_Int32_38
   3077              return (DEF_NULL);
   \      0x278   0x2000             MOVS     R0,#+0
   \      0x27A   0xE000             B.N      ??Str_FmtNbr_Int32_1
   3078            }
   3079          
   3080            return (p_str);                                               // Rtn ptr to fmt'd str (see Note #3f).
   \                     ??Str_FmtNbr_Int32_38: (+1)
   \      0x27C   0x9811             LDR      R0,[SP, #+68]
   \                     ??Str_FmtNbr_Int32_1: (+1)
   \      0x27E   0xB005             ADD      SP,SP,#+20
   \      0x280   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3081          }
   3082          
   3083          /****************************************************************************************************//**
   3084           *                                           Str_ParseNbr_Int32()
   3085           *
   3086           * @brief    Parses a 32-bit integer from a string.
   3087           *
   3088           * @param    p_str       Pointer to the string. String buffer NOT modified.
   3089           *
   3090           * @param    p_str_next  Optional pointer to a variable to :
   3091           *                       Return a pointer to first character following the integer string, if NO
   3092           *                       error(s);
   3093           *                       Return a pointer to 'p_str', otherwise.
   3094           *
   3095           * @param    nbr_base    Base of number to parse.
   3096           *
   3097           * @param    nbr_signed  Indicates whether number to parse is signed :
   3098           *                           - DEF_NO                  Number is unsigned.
   3099           *                           - DEF_YES                 Number is signed.
   3100           *
   3101           * @param    p_nbr_neg   Pointer to the variable to return if the parsed (signed) number is negative :
   3102           *                           - DEF_NO                  Number is non-negative.
   3103           *                           - DEF_YES                 Number is negative.
   3104           *
   3105           * @return   Parsed integer, if integer parsed with NO overflow.
   3106           *           DEF_INT_32U_MAX_VAL, if integer parsed but overflowed.
   3107           *           0, otherwise.
   3108           *
   3109           * @note     (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
   3110           *               functions shall convert the initial portion of the string pointed to by 'str'
   3111           *               ('p_str') to a type unsigned long or long [...] representation" :
   3112           *           - (a) "First, they decompose the input string into three parts" :
   3113           *               - (1) "An initial, possibly empty, sequence of white-space characters [as specified
   3114           *                       by isspace()]. The subject sequence is defined as the longest initial
   3115           *                       subsequence of the input string, starting with the first non-white-space
   3116           *                       character that is of the expected form. The subject sequence shall contain no
   3117           *                       characters if the input string is empty or consists entirely of white-space
   3118           *                       characters."
   3119           *               - (2) "A subject sequence interpreted as an integer.  represented in some radix
   3120           *                       determined by the value of 'base' ('nbr_base'). A subject sequence [...] may
   3121           *                       be preceded by a '+' or '-' sign." However, it does NOT seem reasonable to
   3122           *                       parse & convert a negative number integer string into an unsigned integer.
   3123           *                   - (A) "If the value of 'base' ('nbr_base') is 0, the expected form of the
   3124           *                           subject sequence is that of a decimal constant, octal constant, or
   3125           *                           hexadecimal constant. [...] A decimal constant begins with a non-zero
   3126           *                           digit, and consists of a sequence of decimal digits. [...] An octal
   3127           *                           constant consists of the prefix '0' optionally followed by a sequence of
   3128           *                           the digits '0' to '7' only. [...] A hexadecimal constant consists of the
   3129           *                           prefix '0x' or '0X' followed by a sequence of the decimal digits and
   3130           *                           letters 'a' (or 'A') to 'f' (or 'F') with values 10 to 15 respectively."
   3131           *                   - (B) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected
   3132           *                           form of the subject sequence is a sequence of letters and digits
   3133           *                           representing an integer with the radix specified by 'base' ('nbr_base').
   3134           *                           [...] The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   3135           *                           ascribed the values 10 to 35. [...] only letters whose ascribed values
   3136           *                           are less than that of base are permitted. [...] If the value of 'base'
   3137           *                           ('nbr_base') is 16, the characters '0x' or '0X' may optionally precede
   3138           *                           the sequence of letters and digits." Although NO specification states
   3139           *                           that "if the value of 'base' ('nbr_base') is" 8, the '0' character "may
   3140           *                           optionally precede the sequence of letters and digits"; it seems
   3141           *                           reasonable to allow the '0' character to be optionally parsed.
   3142           *               - (3) "A final string of one or more unrecognized characters, [...] including the
   3143           *                       terminating null byte of the input string [...] other than a sign or a
   3144           *                       permissible letter or digit."
   3145           *           - (b) Second, "they shall attempt to convert the subject sequence to [either an unsigned
   3146           *                   integer or an integer]".
   3147           *               - (1) "If the subject sequence is empty or does not have the expected form [...] no
   3148           *                       conversion [is] performed [and] the value of 'str' ('p_str') [is] stored in
   3149           *                       the object pointed to by 'endptr' ('p_str_next'), provided that 'endptr'
   3150           *                       ('p_str_next') is not a null pointer."
   3151           *               - (2) "If the subject sequence has the expected form [...] and the value of 'base'
   3152           *                       ('nbr_base') is 0, the sequence of characters starting with the first digit
   3153           *                       shall be interpreted as an integer constant. [If instead] the value of 'base'
   3154           *                       ('nbr_base') is between 2 and 36, it shall be used as the base for
   3155           *                       conversion, ascribing to each letter its value as given above."
   3156           *                       "A pointer to the final string shall be stored in the object pointed to by
   3157           *                       'endptr' ('p_str_next'), provided that 'endptr' ('p_str_next') is not a null
   3158           *                       pointer."
   3159           *           - (c) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states
   3160           *                   that :
   3161           *                   "Upon successful completion, these functions shall return the converted value. If
   3162           *                   the correct value is outside the range of representable values [either]
   3163           *                   {LONG_MIN} [or] {LONG_MAX} [...] shall be returned. [...] If no conversion could
   3164           *                   be performed, 0 shall be returned."
   3165           *
   3166           * @note     (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these
   3167           *               functions shall fail if [...] [EINVAL] - The value of 'base' ('nbr_base') is not
   3168           *               supported [or if] [ERANGE] - The value to be returned is not representable."
   3169           *
   3170           * @note     (3) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these
   3171           *               functions may fail if [...] [EINVAL] - No conversion could be performed."
   3172           *
   3173           * @note     (4) Return integer value and next string pointer should be used to diagnose parse success
   3174           *               or failure :
   3175           *           - (a) Valid parse string integer :
   3176           *                       @verbatim
   3177           *                       p_str      = "     ABCDE xyz"
   3178           *                       nbr_base   = 16
   3179           *
   3180           *                       nbr        = 703710
   3181           *                       p_str_next = " xyz"
   3182           *                       @endverbatim
   3183           *           - (b) Invalid parse string integer :
   3184           *                       @verbatim
   3185           *                       p_str      = "     ABCDE"
   3186           *                       nbr_base   = 10
   3187           *
   3188           *                       nbr        =  0
   3189           *                       p_str_next = p_str = "     ABCDE"
   3190           *                       @endverbatim
   3191           *           - (c) Valid hexadecimal parse string integer :
   3192           *                       @verbatim
   3193           *                       p_str      = "     0xGABCDE"
   3194           *                       nbr_base   = 16
   3195           *
   3196           *                       nbr        =  0
   3197           *                       p_str_next = "xGABCDE"
   3198           *                       @endverbatim
   3199           *           - (d) Valid decimal parse string integer ('0x' prefix ignored
   3200           *                           following invalid hexadecimal characters) :
   3201           *                       @verbatim
   3202           *                       p_str      = "     0xGABCDE"
   3203           *                       nbr_base   =  0
   3204           *
   3205           *                       nbr        =  0
   3206           *                       p_str_next = "xGABCDE"
   3207           *                       @endverbatim
   3208           *           - (e) Valid decimal parse string integer ('0'  prefix ignored
   3209           *                           following invalid octal       characters) :
   3210           *                       @verbatim
   3211           *                       p_str      = "     0GABCDE"
   3212           *                       nbr_base   =  0
   3213           *
   3214           *                       nbr        =  0
   3215           *                       p_str_next = "GABCDE"
   3216           *                       @endverbatim
   3217           *           - (f) Parse string integer overflow :
   3218           *                       @verbatim
   3219           *                       p_str      = "   12345678901234567890*123456"
   3220           *                       nbr_base   = 10
   3221           *
   3222           *                       nbr        = DEF_INT_32U_MAX_VAL
   3223           *                       p_str_next = "*123456"
   3224           *                       @endverbatim
   3225           *           - (g) Parse string integer underflow :
   3226           *                       @verbatim
   3227           *                       p_str      = "  -12345678901234567890*123456"
   3228           *                       nbr_base   = 10
   3229           *
   3230           *                       nbr        = DEF_INT_32S_MIN_VAL
   3231           *                       p_str_next = "*123456"
   3232           *                       @endverbatim
   3233           *
   3234           * @note     (5) String parse terminates when :
   3235           *           - (a) Base passed an invalid base (see Note #1a2B). No conversion performed; 0
   3236           *                   returned.
   3237           *           - (b) Parse string passed a NULL pointer OR empty integer sequence (see Note #1b1).
   3238           *                   No conversion performed; 0 returned.
   3239           *           - (c) Invalid parse string character found (see Note #1a3). Parsed integer returned.
   3240           *                   'p_str_next' points to invalid character.
   3241           *           - (d) Entire parse string converted (see Note #1b2). Parsed integer returned.
   3242           *                   'p_str_next' points to terminating NULL character.
   3243           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3244          static CPU_INT32U Str_ParseNbr_Int32(const CPU_CHAR *p_str,
   3245                                               CPU_CHAR       **p_str_next,
   3246                                               CPU_INT08U     nbr_base,
   3247                                               CPU_BOOLEAN    nbr_signed,
   3248                                               CPU_BOOLEAN    *p_nbr_neg)
   3249          {
   \                     Str_ParseNbr_Int32: (+1)
   \        0x0   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x0014             MOVS     R4,R2
   3250            const CPU_CHAR *p_str_parse;
   3251            const CPU_CHAR *p_str_parse_nbr;
   3252            CPU_CHAR       *p_str_parse_unused;
   3253            CPU_CHAR       parse_char;
   3254            CPU_INT08U     parse_dig;
   3255            CPU_INT32U     nbr;
   3256            CPU_BOOLEAN    nbr_neg_unused;
   3257            CPU_BOOLEAN    nbr_dig;
   3258            CPU_BOOLEAN    nbr_alpha;
   3259            CPU_BOOLEAN    nbr_hex;
   3260            CPU_BOOLEAN    nbr_hex_lower;
   3261            CPU_BOOLEAN    whitespace;
   3262            CPU_BOOLEAN    neg;
   3263            CPU_BOOLEAN    ovf;
   3264            CPU_BOOLEAN    done;
   3265          
   3266            //                                                               --------------- VALIDATE PARSE ARGS ----------------
   3267            if (p_str_next == DEF_NULL) {                                 // If NOT avail, ...
   \        0x8   0x9805             LDR      R0,[SP, #+20]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??Str_ParseNbr_Int32_0
   3268              p_str_next = (CPU_CHAR **)&p_str_parse_unused;              // ... re-cfg NULL rtn ptr to unused local var.
   \        0xE   0xA802             ADD      R0,SP,#+8
   \       0x10   0x9005             STR      R0,[SP, #+20]
   3269              PP_UNUSED_PARAM(p_str_parse_unused);
   3270            }
   3271            *p_str_next = (CPU_CHAR *)p_str;                              // Init rtn str in case of err.
   \                     ??Str_ParseNbr_Int32_0: (+1)
   \       0x12   0x9904             LDR      R1,[SP, #+16]
   \       0x14   0x9805             LDR      R0,[SP, #+20]
   \       0x16   0x6001             STR      R1,[R0, #+0]
   3272          
   3273            if (p_nbr_neg == DEF_NULL) {                                  // If NOT avail, ...
   \       0x18   0x9810             LDR      R0,[SP, #+64]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??Str_ParseNbr_Int32_1
   3274              p_nbr_neg = (CPU_BOOLEAN *)&nbr_neg_unused;                 // ... re-cfg NULL rtn ptr to unused local var.
   \       0x1E   0xF10D 0x0005      ADD      R0,SP,#+5
   \       0x22   0x9010             STR      R0,[SP, #+64]
   3275              PP_UNUSED_PARAM(nbr_neg_unused);
   3276            }
   3277            *p_nbr_neg = DEF_NO;                                          // Init nbr neg in case of err.
   \                     ??Str_ParseNbr_Int32_1: (+1)
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x9810             LDR      R0,[SP, #+64]
   \       0x28   0x7001             STRB     R1,[R0, #+0]
   3278          
   3279            if (p_str == DEF_NULL) {                                      // Rtn zero if str ptr NULL (see Note #5b).
   \       0x2A   0x9804             LDR      R0,[SP, #+16]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD101             BNE.N    ??Str_ParseNbr_Int32_2
   3280              return (0u);
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xE0F8             B.N      ??Str_ParseNbr_Int32_3
   3281            }
   3282            //                                                               Rtn zero if invalid base (see Note #5a).
   3283            if ((nbr_base == 1u)
   3284                || (nbr_base > 36u)) {
   \                     ??Str_ParseNbr_Int32_2: (+1)
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD003             BEQ.N    ??Str_ParseNbr_Int32_4
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0xB2C0             UXTB     R0,R0
   \       0x40   0x2825             CMP      R0,#+37
   \       0x42   0xD301             BCC.N    ??Str_ParseNbr_Int32_5
   3285              return (0u);
   \                     ??Str_ParseNbr_Int32_4: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xE0EE             B.N      ??Str_ParseNbr_Int32_3
   3286            }
   3287          
   3288            //                                                               ------------- IGNORE PRECEDING CHAR(S) -------------
   3289            p_str_parse = p_str;                                          // Save ptr to init'l str for err (see Note #1b1).
   \                     ??Str_ParseNbr_Int32_5: (+1)
   \       0x48   0xF8DD 0x8010      LDR      R8,[SP, #+16]
   3290          
   3291            whitespace = ASCII_IsSpace(*p_str_parse);
   \       0x4C   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x50   0x.... 0x....      BL       ASCII_IsSpace
   \       0x54   0xF88D 0x0001      STRB     R0,[SP, #+1]
   3292            while (whitespace == DEF_YES) {                               // Ignore initial white-space char(s) (see Note #1a1).
   \                     ??Str_ParseNbr_Int32_6: (+1)
   \       0x58   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x5C   0x2801             CMP      R0,#+1
   \       0x5E   0xD108             BNE.N    ??Str_ParseNbr_Int32_7
   3293              p_str_parse++;
   \       0x60   0xF118 0x0801      ADDS     R8,R8,#+1
   3294              whitespace = ASCII_IsSpace(*p_str_parse);
   \       0x64   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x68   0x.... 0x....      BL       ASCII_IsSpace
   \       0x6C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \       0x70   0xE7F2             B.N      ??Str_ParseNbr_Int32_6
   3295            }
   3296          
   3297            switch (*p_str_parse) {
   \                     ??Str_ParseNbr_Int32_7: (+1)
   \       0x72   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x76   0x282B             CMP      R0,#+43
   \       0x78   0xD002             BEQ.N    ??Str_ParseNbr_Int32_8
   \       0x7A   0x282D             CMP      R0,#+45
   \       0x7C   0xD004             BEQ.N    ??Str_ParseNbr_Int32_9
   \       0x7E   0xE00B             B.N      ??Str_ParseNbr_Int32_10
   3298              case '+':                                                   // Ignore pos sign (see Note #1a2).
   3299                p_str_parse++;
   \                     ??Str_ParseNbr_Int32_8: (+1)
   \       0x80   0xF118 0x0801      ADDS     R8,R8,#+1
   3300                neg = DEF_NO;
   \       0x84   0x2700             MOVS     R7,#+0
   3301                break;
   \       0x86   0xE008             B.N      ??Str_ParseNbr_Int32_11
   3302          
   3303              case '-':                                                   // Validate neg sign (see Note #1a2).
   3304                if (nbr_signed == DEF_YES) {
   \                     ??Str_ParseNbr_Int32_9: (+1)
   \       0x88   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \       0x8C   0x2801             CMP      R0,#+1
   \       0x8E   0xD101             BNE.N    ??Str_ParseNbr_Int32_12
   3305                  p_str_parse++;
   \       0x90   0xF118 0x0801      ADDS     R8,R8,#+1
   3306                }
   3307                neg = DEF_YES;
   \                     ??Str_ParseNbr_Int32_12: (+1)
   \       0x94   0x2701             MOVS     R7,#+1
   3308                break;
   \       0x96   0xE000             B.N      ??Str_ParseNbr_Int32_11
   3309          
   3310              default:
   3311                neg = DEF_NO;
   \                     ??Str_ParseNbr_Int32_10: (+1)
   \       0x98   0x2700             MOVS     R7,#+0
   3312                break;
   3313            }
   3314          
   3315            //                                                               --------- IGNORE NBR BASE PRECEDING CHAR(S) --------
   3316            p_str_parse_nbr = p_str_parse;                                // Save ptr to str's nbr (see Note #1a1).
   \                     ??Str_ParseNbr_Int32_11: (+1)
   \       0x9A   0xF8CD 0x800C      STR      R8,[SP, #+12]
   3317          
   3318            switch (nbr_base) {
   \       0x9E   0x0020             MOVS     R0,R4
   \       0xA0   0xB2C0             UXTB     R0,R0
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD004             BEQ.N    ??Str_ParseNbr_Int32_13
   \       0xA6   0x2808             CMP      R0,#+8
   \       0xA8   0xD026             BEQ.N    ??Str_ParseNbr_Int32_14
   \       0xAA   0x2810             CMP      R0,#+16
   \       0xAC   0xD02B             BEQ.N    ??Str_ParseNbr_Int32_15
   \       0xAE   0xE047             B.N      ??Str_ParseNbr_Int32_16
   3319              case  0u:                                                   // Determine unspecified nbr base (see Notes #1a2A).
   3320                if (*p_str_parse == '0') {                                // If avail, ...
   \                     ??Str_ParseNbr_Int32_13: (+1)
   \       0xB0   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0xB4   0x2830             CMP      R0,#+48
   \       0xB6   0xD11C             BNE.N    ??Str_ParseNbr_Int32_17
   3321                  p_str_parse++;                                          // ... adv past '0' prefix (see Note #1a2B).
   \       0xB8   0xF118 0x0801      ADDS     R8,R8,#+1
   3322                  switch (*p_str_parse) {
   \       0xBC   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0xC0   0x2858             CMP      R0,#+88
   \       0xC2   0xD001             BEQ.N    ??Str_ParseNbr_Int32_18
   \       0xC4   0x2878             CMP      R0,#+120
   \       0xC6   0xD111             BNE.N    ??Str_ParseNbr_Int32_19
   3323                    case 'x':                                             // For '0x' prefix, ...
   3324                    case 'X':
   3325                      nbr_base = 16u;                                     // ... set nbr base = 16 (see Note #1a2A).
   \                     ??Str_ParseNbr_Int32_18: (+1)
   \       0xC8   0x2010             MOVS     R0,#+16
   \       0xCA   0x0004             MOVS     R4,R0
   3326                      parse_char = (CPU_CHAR)(*(p_str_parse + 1));
   \       0xCC   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \       0xD0   0x0005             MOVS     R5,R0
   3327                      nbr_hex = ASCII_IsDigHex(parse_char);
   \       0xD2   0x0028             MOVS     R0,R5
   \       0xD4   0xB2C0             UXTB     R0,R0
   \       0xD6   0x.... 0x....      BL       ASCII_IsDigHex
   \       0xDA   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3328                      if (nbr_hex == DEF_YES) {                           // If next char is valid hex dig, ...
   \       0xDE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xE2   0x2801             CMP      R0,#+1
   \       0xE4   0xD101             BNE.N    ??Str_ParseNbr_Int32_20
   3329                        p_str_parse++;                                    // ... adv past '0x' prefix (see Note #1a2B).
   \       0xE6   0xF118 0x0801      ADDS     R8,R8,#+1
   3330                      }
   3331                      break;
   \                     ??Str_ParseNbr_Int32_20: (+1)
   \       0xEA   0xE004             B.N      ??Str_ParseNbr_Int32_21
   3332          
   3333                    default:                                              // For '0'  prefix, ...
   3334                      nbr_base = 8u;                                      // ... set nbr base =  8 (see Note #1a2A).
   \                     ??Str_ParseNbr_Int32_19: (+1)
   \       0xEC   0x2008             MOVS     R0,#+8
   \       0xEE   0x0004             MOVS     R4,R0
   3335                      break;
   \       0xF0   0xE001             B.N      ??Str_ParseNbr_Int32_21
   3336                  }
   3337                } else {                                                  // For non-'0' prefix, ...
   3338                  nbr_base = 10u;                                         // ... set nbr base = 10 (see Note #1a2A).
   \                     ??Str_ParseNbr_Int32_17: (+1)
   \       0xF2   0x200A             MOVS     R0,#+10
   \       0xF4   0x0004             MOVS     R4,R0
   3339                }
   3340                break;
   \                     ??Str_ParseNbr_Int32_21: (+1)
   \       0xF6   0xE023             B.N      ??Str_ParseNbr_Int32_22
   3341          
   3342              case  8u:                                                   // See Note #1a2A.
   3343                if (*p_str_parse == '0') {                                // If avail, ...
   \                     ??Str_ParseNbr_Int32_14: (+1)
   \       0xF8   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0xFC   0x2830             CMP      R0,#+48
   \       0xFE   0xD101             BNE.N    ??Str_ParseNbr_Int32_23
   3344                  p_str_parse++;                                          // ... adv past '0' prefix (see Note #1a2B).
   \      0x100   0xF118 0x0801      ADDS     R8,R8,#+1
   3345                }
   3346                break;
   \                     ??Str_ParseNbr_Int32_23: (+1)
   \      0x104   0xE01C             B.N      ??Str_ParseNbr_Int32_22
   3347          
   3348              case 16u:                                                   // See Note #1a2A.
   3349                if (*p_str_parse == '0') {                                // If avail, ...
   \                     ??Str_ParseNbr_Int32_15: (+1)
   \      0x106   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x10A   0x2830             CMP      R0,#+48
   \      0x10C   0xD117             BNE.N    ??Str_ParseNbr_Int32_24
   3350                  p_str_parse++;                                          // ... adv past '0'  prefix (see Note #1a2B).
   \      0x10E   0xF118 0x0801      ADDS     R8,R8,#+1
   3351                  switch (*p_str_parse) {
   \      0x112   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x116   0x2858             CMP      R0,#+88
   \      0x118   0xD001             BEQ.N    ??Str_ParseNbr_Int32_25
   \      0x11A   0x2878             CMP      R0,#+120
   \      0x11C   0xD10F             BNE.N    ??Str_ParseNbr_Int32_26
   3352                    case 'x':
   3353                    case 'X':
   3354                      parse_char = (CPU_CHAR)(*(p_str_parse + 1));
   \                     ??Str_ParseNbr_Int32_25: (+1)
   \      0x11E   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \      0x122   0x0005             MOVS     R5,R0
   3355                      nbr_hex = ASCII_IsDigHex(parse_char);
   \      0x124   0x0028             MOVS     R0,R5
   \      0x126   0xB2C0             UXTB     R0,R0
   \      0x128   0x.... 0x....      BL       ASCII_IsDigHex
   \      0x12C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3356                      if (nbr_hex == DEF_YES) {                           // If next char is valid hex dig, ...
   \      0x130   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x134   0x2801             CMP      R0,#+1
   \      0x136   0xD101             BNE.N    ??Str_ParseNbr_Int32_27
   3357                        p_str_parse++;                                    // ... adv past '0x' prefix (see Note #1a2B).
   \      0x138   0xF118 0x0801      ADDS     R8,R8,#+1
   3358                      }
   3359                      break;
   \                     ??Str_ParseNbr_Int32_27: (+1)
   \      0x13C   0xE7FF             B.N      ??Str_ParseNbr_Int32_24
   3360          
   3361                    default:
   3362                      break;
   3363                  }
   3364                }
   3365                break;
   \                     ??Str_ParseNbr_Int32_26: (+1)
   \                     ??Str_ParseNbr_Int32_24: (+1)
   \      0x13E   0xE7FF             B.N      ??Str_ParseNbr_Int32_22
   3366          
   3367              default:                                                    // See Note #1a2B.
   3368                break;
   3369            }
   3370          
   3371            //                                                               ------------------ PARSE INT STR -------------------
   3372            nbr = 0u;
   \                     ??Str_ParseNbr_Int32_16: (+1)
   \                     ??Str_ParseNbr_Int32_22: (+1)
   \      0x140   0xF05F 0x0B00      MOVS     R11,#+0
   3373            ovf = DEF_NO;
   \      0x144   0xF05F 0x0900      MOVS     R9,#+0
   3374            done = DEF_NO;
   \      0x148   0xF05F 0x0A00      MOVS     R10,#+0
   3375          
   3376            while (done == DEF_NO) {                                      // Parse str for desired nbr base digs (see Note #1b).
   \                     ??Str_ParseNbr_Int32_28: (+1)
   \      0x14C   0x4650             MOV      R0,R10
   \      0x14E   0xB2C0             UXTB     R0,R0
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD154             BNE.N    ??Str_ParseNbr_Int32_29
   3377              parse_char = (CPU_CHAR)*p_str_parse;
   \      0x154   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x158   0x0005             MOVS     R5,R0
   3378              nbr_alpha = ASCII_IsAlphaNum(parse_char);
   \      0x15A   0x0028             MOVS     R0,R5
   \      0x15C   0xB2C0             UXTB     R0,R0
   \      0x15E   0x.... 0x....      BL       ASCII_IsAlphaNum
   \      0x162   0xF88D 0x0003      STRB     R0,[SP, #+3]
   3379              if (nbr_alpha == DEF_YES) {                                 // If valid alpha num nbr dig avail, ...
   \      0x166   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \      0x16A   0x2801             CMP      R0,#+1
   \      0x16C   0xD144             BNE.N    ??Str_ParseNbr_Int32_30
   3380                                                                          // ... convert parse char into nbr dig.
   3381                nbr_dig = ASCII_IsDig(parse_char);
   \      0x16E   0x0028             MOVS     R0,R5
   \      0x170   0xB2C0             UXTB     R0,R0
   \      0x172   0x.... 0x....      BL       ASCII_IsDig
   \      0x176   0xF88D 0x0004      STRB     R0,[SP, #+4]
   3382                if (nbr_dig == DEF_YES) {
   \      0x17A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \      0x17E   0x2801             CMP      R0,#+1
   \      0x180   0xD103             BNE.N    ??Str_ParseNbr_Int32_31
   3383                  parse_dig = (CPU_INT08U)(parse_char - '0');
   \      0x182   0xF1B5 0x0030      SUBS     R0,R5,#+48
   \      0x186   0x0006             MOVS     R6,R0
   \      0x188   0xE010             B.N      ??Str_ParseNbr_Int32_32
   3384                } else {
   3385                  nbr_hex_lower = ASCII_IsLower(parse_char);
   \                     ??Str_ParseNbr_Int32_31: (+1)
   \      0x18A   0x0028             MOVS     R0,R5
   \      0x18C   0xB2C0             UXTB     R0,R0
   \      0x18E   0x.... 0x....      BL       ASCII_IsLower
   \      0x192   0xF88D 0x0002      STRB     R0,[SP, #+2]
   3386                  if (nbr_hex_lower == DEF_YES) {
   \      0x196   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \      0x19A   0x2801             CMP      R0,#+1
   \      0x19C   0xD103             BNE.N    ??Str_ParseNbr_Int32_33
   3387                    parse_dig = ((CPU_INT08U)(parse_char - 'a') + 10u);
   \      0x19E   0xF1B5 0x0057      SUBS     R0,R5,#+87
   \      0x1A2   0x0006             MOVS     R6,R0
   \      0x1A4   0xE002             B.N      ??Str_ParseNbr_Int32_32
   3388                  } else {
   3389                    parse_dig = ((CPU_INT08U)(parse_char - 'A') + 10u);
   \                     ??Str_ParseNbr_Int32_33: (+1)
   \      0x1A6   0xF1B5 0x0037      SUBS     R0,R5,#+55
   \      0x1AA   0x0006             MOVS     R6,R0
   3390                  }
   3391                }
   3392          
   3393                if (parse_dig < nbr_base) {                               // If parse char valid for nbr base ...
   \                     ??Str_ParseNbr_Int32_32: (+1)
   \      0x1AC   0x0031             MOVS     R1,R6
   \      0x1AE   0x0020             MOVS     R0,R4
   \      0x1B0   0xB2C9             UXTB     R1,R1
   \      0x1B2   0xB2C0             UXTB     R0,R0
   \      0x1B4   0x4281             CMP      R1,R0
   \      0x1B6   0xD21C             BCS.N    ??Str_ParseNbr_Int32_34
   3394                  if (ovf == DEF_NO) {                                    // ... & nbr NOT yet ovf'd, ...
   \      0x1B8   0x4648             MOV      R0,R9
   \      0x1BA   0xB2C0             UXTB     R0,R0
   \      0x1BC   0x2800             CMP      R0,#+0
   \      0x1BE   0xD115             BNE.N    ??Str_ParseNbr_Int32_35
   3395                    if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
   \      0x1C0   0x....             LDR.N    R0,??DataTable3_2
   \      0x1C2   0x0021             MOVS     R1,R4
   \      0x1C4   0xB2C9             UXTB     R1,R1
   \      0x1C6   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \      0x1CA   0x4558             CMP      R0,R11
   \      0x1CC   0xD30C             BCC.N    ??Str_ParseNbr_Int32_36
   3396                      //                                                     ... merge parse char dig into nbr.
   3397                      nbr *= nbr_base;
   \      0x1CE   0x0020             MOVS     R0,R4
   \      0x1D0   0xB2C0             UXTB     R0,R0
   \      0x1D2   0xFB00 0xFB0B      MUL      R11,R0,R11
   3398                      nbr += parse_dig;
   \      0x1D6   0xFA5B 0xFB86      UXTAB    R11,R11,R6
   3399                      if (nbr < parse_dig) {
   \      0x1DA   0x0030             MOVS     R0,R6
   \      0x1DC   0xB2C0             UXTB     R0,R0
   \      0x1DE   0x4583             CMP      R11,R0
   \      0x1E0   0xD204             BCS.N    ??Str_ParseNbr_Int32_35
   3400                        ovf = DEF_YES;
   \      0x1E2   0x2001             MOVS     R0,#+1
   \      0x1E4   0x4681             MOV      R9,R0
   \      0x1E6   0xE001             B.N      ??Str_ParseNbr_Int32_35
   3401                      }
   3402                    } else {
   3403                      ovf = DEF_YES;
   \                     ??Str_ParseNbr_Int32_36: (+1)
   \      0x1E8   0x2001             MOVS     R0,#+1
   \      0x1EA   0x4681             MOV      R9,R0
   3404                    }
   3405                  }
   3406                  p_str_parse++;
   \                     ??Str_ParseNbr_Int32_35: (+1)
   \      0x1EC   0xF118 0x0801      ADDS     R8,R8,#+1
   \      0x1F0   0xE7AC             B.N      ??Str_ParseNbr_Int32_28
   3407                } else {                                                  // Invalid char parsed (see Note #1a3).
   3408                  done = DEF_YES;
   \                     ??Str_ParseNbr_Int32_34: (+1)
   \      0x1F2   0x2001             MOVS     R0,#+1
   \      0x1F4   0x4682             MOV      R10,R0
   \      0x1F6   0xE7A9             B.N      ??Str_ParseNbr_Int32_28
   3409                }
   3410              } else {                                                    // Invalid OR NULL char parsed (see Note #1a3).
   3411                done = DEF_YES;
   \                     ??Str_ParseNbr_Int32_30: (+1)
   \      0x1F8   0x2001             MOVS     R0,#+1
   \      0x1FA   0x4682             MOV      R10,R0
   \      0x1FC   0xE7A6             B.N      ??Str_ParseNbr_Int32_28
   3412              }
   3413            }
   3414          
   3415            if (ovf == DEF_YES) {                                         // If nbr ovf'd, ...
   \                     ??Str_ParseNbr_Int32_29: (+1)
   \      0x1FE   0x4648             MOV      R0,R9
   \      0x200   0xB2C0             UXTB     R0,R0
   \      0x202   0x2801             CMP      R0,#+1
   \      0x204   0xD102             BNE.N    ??Str_ParseNbr_Int32_37
   3416              nbr = DEF_INT_32U_MAX_VAL;                                  // ... rtn max int val (see Note #1c).
   \      0x206   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x20A   0x4683             MOV      R11,R0
   3417            }
   3418          
   3419            if (p_str_parse != p_str_parse_nbr) {                         // If final parse str != init'l parse nbr str, ...
   \                     ??Str_ParseNbr_Int32_37: (+1)
   \      0x20C   0x9803             LDR      R0,[SP, #+12]
   \      0x20E   0x4580             CMP      R8,R0
   \      0x210   0xD003             BEQ.N    ??Str_ParseNbr_Int32_38
   3420              *p_str_next = (CPU_CHAR *)p_str_parse;                      // ... rtn parse str's next char (see Note #1b2); ...
   \      0x212   0x9805             LDR      R0,[SP, #+20]
   \      0x214   0xF8C0 0x8000      STR      R8,[R0, #+0]
   \      0x218   0xE002             B.N      ??Str_ParseNbr_Int32_39
   3421            } else {
   3422              *p_str_next = (CPU_CHAR *)p_str;                            // ... else rtn initial parse str (see Note #1b1).
   \                     ??Str_ParseNbr_Int32_38: (+1)
   \      0x21A   0x9904             LDR      R1,[SP, #+16]
   \      0x21C   0x9805             LDR      R0,[SP, #+20]
   \      0x21E   0x6001             STR      R1,[R0, #+0]
   3423            }
   3424          
   3425            *p_nbr_neg = neg;                                             // Rtn neg nbr status.
   \                     ??Str_ParseNbr_Int32_39: (+1)
   \      0x220   0x9810             LDR      R0,[SP, #+64]
   \      0x222   0x7007             STRB     R7,[R0, #+0]
   3426          
   3427            return (nbr);
   \      0x224   0x4658             MOV      R0,R11
   \                     ??Str_ParseNbr_Int32_3: (+1)
   \      0x226   0xB007             ADD      SP,SP,#+28
   \      0x228   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3428          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     `Str_UnsgnIntFmtOutput::digits`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     `Str_SngIntFmtOutput::digits`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     Str_MultOvfThTbl_Int32U

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Str_Cat
        16   -> Str_Cat_N
      12   Str_Cat_N
      16   Str_Char
        16   -> Str_Char_N
      16   Str_Char_Last
        16   -> Str_Char_Last_N
      24   Str_Char_Last_N
        24   -> Str_Len_N
      12   Str_Char_N
      16   Str_Char_Replace
        16   -> Str_Char_Replace_N
      16   Str_Char_Replace_N
      16   Str_Cmp
        16   -> Str_Cmp_N
      16   Str_CmpIgnoreCase
        16   -> Str_CmpIgnoreCase_N
      48   Str_CmpIgnoreCase_N
        48   -> ASCII_ToLower
      20   Str_Cmp_N
      16   Str_Copy
        16   -> Str_Copy_N
      12   Str_Copy_N
      56   Str_FmtNbr_Int32
        56   -> ASCII_IsPrint
      48   Str_FmtNbr_Int32S
        48   -> Str_FmtNbr_Int32
      40   Str_FmtNbr_Int32U
        40   -> Str_FmtNbr_Int32
      56   Str_FmtOutput
        56   -- Indirect call
        56   -> Str_Len
       8   Str_Len
         8   -> Str_Len_N
       4   Str_Len_N
      64   Str_ParseNbr_Int32
        64   -> ASCII_IsAlphaNum
        64   -> ASCII_IsDig
        64   -> ASCII_IsDigHex
        64   -> ASCII_IsLower
        64   -> ASCII_IsSpace
      24   Str_ParseNbr_Int32S
        24   -> Str_ParseNbr_Int32
      24   Str_ParseNbr_Int32U
        24   -> Str_ParseNbr_Int32
      32   Str_Printf
        32   -> Str_PrintfImpl
      80   Str_PrintfImpl
        80   -- Indirect call
        80   -> ASCII_IsDig
        80   -> ASCII_ToLower
        80   -> Str_FmtOutput
        80   -> Str_ParseNbr_Int32U
        80   -> Str_SngIntFmtOutput
        80   -> Str_UnsgnIntFmtOutput
      80   Str_SngIntFmtOutput
        80   -- Indirect call
        80 __aeabi_uldivmod
      40   Str_Snprintf
        40   -> Str_PrintfImpl
      40   Str_Sprintf
        40   -> Str_PrintfImpl
       4   Str_SprintfCb
      16   Str_Str
        16   -> Str_Str_N
      48   Str_Str_N
        48   -> Str_Cmp_N
        48   -> Str_Len_N
      80   Str_UnsgnIntFmtOutput
        80   -- Indirect call
        80 __aeabi_uldivmod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
      20  Str_Cat
     112  Str_Cat_N
      22  Str_Char
      22  Str_Char_Last
      84  Str_Char_Last_N
      84  Str_Char_N
      28  Str_Char_Replace
      66  Str_Char_Replace_N
      22  Str_Cmp
      22  Str_CmpIgnoreCase
     268  Str_CmpIgnoreCase_N
     166  Str_Cmp_N
      20  Str_Copy
      86  Str_Copy_N
     644  Str_FmtNbr_Int32
      78  Str_FmtNbr_Int32S
      54  Str_FmtNbr_Int32U
     240  Str_FmtOutput
      16  Str_Len
      32  Str_Len_N
     148  Str_MultOvfThTbl_Int32U
     556  Str_ParseNbr_Int32
      68  Str_ParseNbr_Int32S
      28  Str_ParseNbr_Int32U
      36  Str_Printf
   1'116  Str_PrintfImpl
     258  Str_SngIntFmtOutput
      62  Str_Snprintf
      60  Str_Sprintf
      18  Str_SprintfCb
      20  Str_Str
     170  Str_Str_N
     232  Str_UnsgnIntFmtOutput
      20  digits
      20  digits

 
   188 bytes in section .rodata
 4'722 bytes in section .text
 
 4'722 bytes of CODE  memory
   188 bytes of CONST memory

Errors: none
Warnings: none
