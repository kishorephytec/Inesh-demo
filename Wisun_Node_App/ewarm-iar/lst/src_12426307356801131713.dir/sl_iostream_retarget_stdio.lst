###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:36
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\src\sl_iostream_retarget_stdio.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_12426307356801131713.dir\sl_iostream_retarget_stdio.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\src\sl_iostream_retarget_stdio.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_12426307356801131713.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_12426307356801131713.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_12426307356801131713.dir\sl_iostream_retarget_stdio.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_12426307356801131713.dir\sl_iostream_retarget_stdio.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_12426307356801131713.dir\sl_iostream_retarget_stdio.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\src\sl_iostream_retarget_stdio.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Provide stdio retargeting for all supported toolchains.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2019 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sl_iostream.h"
     32          #include "sl_status.h"
     33          
     34          #if !defined(__CROSSWORKS_ARM) && defined(__GNUC__)
     35          
     36          #include <sys/stat.h>
     37          #include <stddef.h>
     38          #include "em_device.h"
     39          #include "sl_assert.h"
     40          
     41          int _close(int file);
     42          void _exit(int status);
     43          int _fstat(int file, struct stat *st);
     44          int _getpid(void);
     45          int _isatty(int file);
     46          int _kill(int pid, int sig);
     47          int _lseek(int file, int ptr, int dir);
     48          int _read(int file, char *ptr, int len);
     49          int _write(int file, const char *ptr, int len);
     50          
     51          /**************************************************************************//**
     52           * Close a file.
     53           *
     54           * @param[in] file  File you want to close.
     55           *
     56           * @return  Returns 0 when the file is closed.
     57           *****************************************************************************/
     58          int _close(int file)
     59          {
     60            (void) file;
     61            return 0;
     62          }
     63          
     64          /**************************************************************************//**
     65           * Exit the program.
     66           *
     67           * @param[in] status The value to return to the parent process as the
     68           *            exit status (not used).
     69           *****************************************************************************/
     70          void _exit(int status)
     71          {
     72            (void) status;
     73            while (1) {
     74            }                 // Hang here forever...
     75          }
     76          
     77          /**************************************************************************//**
     78           * Status of an open file.
     79           *
     80           * @param[in] file  Check status for this file.
     81           *
     82           * @param[in] st    Status information.
     83           *
     84           * @return  Returns 0 when st_mode is set to character special.
     85           *****************************************************************************/
     86          int _fstat(int file, struct stat *st)
     87          {
     88            (void) file;
     89            st->st_mode = S_IFCHR;
     90            return 0;
     91          }
     92          
     93          /**************************************************************************//**
     94           * Get process ID.
     95           *
     96           * @return  Return 1 when not implemented.
     97           *****************************************************************************/
     98          int _getpid(void)
     99          {
    100            return 1;
    101          }
    102          
    103          /**************************************************************************//**
    104           * Query whether output stream is a terminal.
    105           *
    106           * @param[in] file  Descriptor for the file.
    107           *
    108           * @return  Returns 1 when query is done.
    109           *****************************************************************************/
    110          int _isatty(int file)
    111          {
    112            (void) file;
    113            return 1;
    114          }
    115          
    116          /**************************************************************************//**
    117           * Send signal to process.
    118           *
    119           * @param[in] pid Process id (not used).
    120           *
    121           * @param[in] sig Signal to send (not used).
    122           *****************************************************************************/
    123          int _kill(int pid, int sig)
    124          {
    125            (void)pid;
    126            (void)sig;
    127            return -1;
    128          }
    129          
    130          /**************************************************************************//**
    131           * Set position in a file.
    132           *
    133           * @param[in] file  Descriptor for the file.
    134           *
    135           * @param[in] ptr   Poiter to the argument offset.
    136           *
    137           * @param[in] dir   Directory whence.
    138           *
    139           * @return  Returns 0 when position is set.
    140           *****************************************************************************/
    141          int _lseek(int file, int ptr, int dir)
    142          {
    143            (void) file;
    144            (void) ptr;
    145            (void) dir;
    146            return 0;
    147          }
    148          
    149          /**************************************************************************//**
    150           * Read from a file.
    151           *
    152           * @param[in] file  Descriptor for the file you want to read from.
    153           *
    154           * @param[in] ptr   Pointer to the chacaters that are beeing read.
    155           *
    156           * @param[in] len   Number of characters to be read.
    157           *
    158           * @return  Number of characters that have been read.
    159           *****************************************************************************/
    160          int _read(int file, char *ptr, int len)
    161          {
    162            size_t bytes_read = 0;
    163          
    164            (void)file;
    165            sl_iostream_read(SL_IOSTREAM_STDIN, ptr, (size_t)len, &bytes_read);
    166          
    167            if (bytes_read == 0) {
    168              return -1;
    169            }
    170          
    171            return (int)bytes_read;
    172          }
    173          
    174          /**************************************************************************//**
    175           * Write to a file.
    176           *
    177           * @param[in] file  Descriptor for the file you want to write to.
    178           *
    179           * @param[in] ptr   Pointer to the text you want to write
    180           *
    181           * @param[in] len   Number of characters to be written.
    182           *
    183           * @return  Number of characters that have been written.
    184           *****************************************************************************/
    185          int _write(int file, const char *ptr, int len)
    186          {
    187            sl_status_t status;
    188          
    189            (void)file;
    190            status = sl_iostream_write(SL_IOSTREAM_STDOUT, ptr, (size_t)len);
    191            switch (status) {
    192              case SL_STATUS_INVALID_STATE:
    193                break;  // Ignore error if the state doesn't allow to write.
    194              default:
    195                EFM_ASSERT(status == SL_STATUS_OK);
    196                break;
    197            }
    198          
    199            return len;
    200          }
    201          
    202          #endif /* !defined( __CROSSWORKS_ARM ) && defined( __GNUC__ ) */
    203          
    204          #if defined(__ICCARM__)
    205          /*******************
    206           *
    207           * Copyright 1998-2003 IAR Systems.  All rights reserved.
    208           *
    209           * $Revision: 38614 $
    210           *
    211           * This is a template implementation of the "__write" function used by
    212           * the standard library.  Replace it with a system-specific
    213           * implementation.
    214           *
    215           * The "__write" function should output "size" number of bytes from
    216           * "buffer" in some application-specific way.  It should return the
    217           * number of characters written, or _LLIO_ERROR on failure.
    218           *
    219           * If "buffer" is zero then __write should perform flushing of
    220           * internal buffers, if any.  In this case "handle" can be -1 to
    221           * indicate that all handles should be flushed.
    222           *
    223           * The template implementation below assumes that the application
    224           * provides the function "MyLowLevelPutchar".  It should return the
    225           * character written, or -1 on failure.
    226           *
    227           ********************/
    228          
    229          #include <yfuns.h>
    230          #include <stdint.h>
    231          #include "sl_common.h"
    232          
    233          _STD_BEGIN
    234          
    235          /**************************************************************************//**
    236           * Transmit buffer to IOStream
    237           *
    238           * @param buffer  Array of characters to send
    239           *
    240           * @param nbytes  Number of bytes to transmit
    241           *
    242           * @return Number of bytes sent
    243           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    244          static int TxBuf(uint8_t *buffer, int nbytes)
    245          {
   \                     TxBuf: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000D             MOVS     R5,R1
    246            sl_status_t status;
    247          
    248            status = sl_iostream_write(SL_IOSTREAM_STDOUT, buffer, nbytes);
   \        0x6   0x002A             MOVS     R2,R5
   \        0x8   0x0031             MOVS     R1,R6
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x.... 0x....      BL       sl_iostream_write
   \       0x10   0x0004             MOVS     R4,R0
    249            switch (status) {
   \       0x12   0x2C02             CMP      R4,#+2
   \       0x14   0xD005             BEQ.N    ??TxBuf_0
    250              case SL_STATUS_INVALID_STATE:
    251                break;
    252              default:
    253                EFM_ASSERT(status == SL_STATUS_OK);
   \                     ??TxBuf_1: (+1)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD003             BEQ.N    ??TxBuf_2
   \       0x1A   0x21FD             MOVS     R1,#+253
   \       0x1C   0x....             LDR.N    R0,??DataTable0
   \       0x1E   0x.... 0x....      BL       assertEFM
    254                break;
    255            }
    256          
    257            return nbytes;
   \                     ??TxBuf_2: (+1)
   \                     ??TxBuf_0: (+1)
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xBD70             POP      {R4-R6,PC}
    258          }
    259          
    260          /**************************************************************************//**
    261           * Write to.
    262           *
    263           * @param[in] handle  Handle
    264           *
    265           * @param[in] buffer  Pointer to the buffer you want to write
    266           *
    267           * @param[in] size    Number of characters to be written.
    268           *
    269           * @return  Number of characters that have been written.
    270           *
    271           * @note  If the __write implementation uses internal buffering, uncomment
    272           *        the following line to ensure that we are called with "buffer" as 0
    273           *        (i.e. flush) when the application terminates.
    274           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    275          size_t __write(int handle, const unsigned char * buffer, size_t size)
    276          {
   \                     __write: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
    277            // Remove the #if #endif pair to enable the implementation
    278          
    279            size_t nChars = 0;
   \        0x8   0x2600             MOVS     R6,#+0
    280          
    281            if (buffer == 0) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??__write_0
    282              // This means that we should flush internal buffers.  Since we
    283              // don't we just return.  (Remember, "handle" == -1 means that all
    284              // handles should be flushed.)
    285              return 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE010             B.N      ??__write_1
    286            }
    287          
    288            // This template only writes to "standard out" and "standard err",
    289            // for all other file handles it returns failure.
    290            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR) {
   \                     ??__write_0: (+1)
   \       0x12   0x2F01             CMP      R7,#+1
   \       0x14   0xD004             BEQ.N    ??__write_2
   \       0x16   0x2F02             CMP      R7,#+2
   \       0x18   0xD002             BEQ.N    ??__write_2
    291              return _LLIO_ERROR;
   \       0x1A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1E   0xE009             B.N      ??__write_1
    292            }
    293          
    294            if (TxBuf((uint8_t *) buffer, size) != size) {
   \                     ??__write_2: (+1)
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       TxBuf
   \       0x28   0x42A8             CMP      R0,R5
   \       0x2A   0xD002             BEQ.N    ??__write_3
    295              return _LLIO_ERROR;
   \       0x2C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x30   0xE000             B.N      ??__write_1
    296            } else {
    297              nChars = size;
   \                     ??__write_3: (+1)
   \       0x32   0x0028             MOVS     R0,R5
    298            }
    299          
    300            return nChars;
   \                     ??__write_1: (+1)
   \       0x34   0xBDF2             POP      {R1,R4-R7,PC}
    301          }
    302          
    303          /**************************************************************************//**
    304           * Read from.
    305           *
    306           * @param[in] handle  Handle
    307           *
    308           * @param[in] buffer   Pointer to the characters that have been read.
    309           *
    310           * @return  Number of characters that have been read.
    311           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    312          size_t __read(int handle, unsigned char * buffer, size_t size)
    313          {
   \                     __read: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    314            size_t bytes_read = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
    315          
    316            // This template only reads from "standard in", for all other file
    317            // handles it returns failure.
    318            if (handle != _LLIO_STDIN) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD002             BEQ.N    ??__read_0
    319              return _LLIO_ERROR;
   \       0x10   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x14   0xE00C             B.N      ??__read_1
    320            }
    321          
    322            sl_iostream_read(SL_IOSTREAM_STDIN, buffer, size, &bytes_read);
   \                     ??__read_0: (+1)
   \       0x16   0x466B             MOV      R3,SP
   \       0x18   0x0032             MOVS     R2,R6
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x.... 0x....      BL       sl_iostream_read
    323            if (bytes_read == 0) {
   \       0x22   0x9800             LDR      R0,[SP, #+0]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD102             BNE.N    ??__read_2
    324              return -1;
   \       0x28   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x2C   0xE000             B.N      ??__read_1
    325            }
    326          
    327            return bytes_read;
   \                     ??__read_2: (+1)
   \       0x2E   0x9800             LDR      R0,[SP, #+0]
   \                     ??__read_1: (+1)
   \       0x30   0xBD76             POP      {R1,R2,R4-R6,PC}
    328          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x73 0x65          DC8 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5C
   \              0x72 0x76    
   \              0x69 0x63    
   \              0x65 0x5C
   \       0x50   0x69 0x6F          DC8 0x69, 0x6F, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D
   \              0x73 0x74    
   \              0x72 0x65    
   \              0x61 0x6D
   \       0x58   0x5C 0x73          DC8 0x5C, 0x73, 0x72, 0x63, 0x5C, 0x73, 0x6C, 0x5F
   \              0x72 0x63    
   \              0x5C 0x73    
   \              0x6C 0x5F
   \       0x60   0x69 0x6F          DC8 0x69, 0x6F, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D
   \              0x73 0x74    
   \              0x72 0x65    
   \              0x61 0x6D
   \       0x68   0x5F 0x72          DC8 0x5F, 0x72, 0x65, 0x74, 0x61, 0x72, 0x67, 0x65
   \              0x65 0x74    
   \              0x61 0x72    
   \              0x67 0x65
   \       0x70   0x74 0x5F          DC8 0x74, 0x5F, 0x73, 0x74, 0x64, 0x69, 0x6F, 0x2E
   \              0x73 0x74    
   \              0x64 0x69    
   \              0x6F 0x2E
   \       0x78   0x63 0x00          DC8 0x63, 0
   \       0x7A                      DS8 2
    329          
    330          _STD_END
    331          
    332          #endif /* defined( __ICCARM__ ) */
    333          
    334          #if defined(__CROSSWORKS_ARM)
    335          
    336          /**************************************************************************//**
    337           * Write a character.
    338           *
    339           * @param[in] ch  character
    340           *
    341           * @return  1
    342           *****************************************************************************/
    343          int __putchar(int ch)
    344          {
    345            sl_status_t status;
    346          
    347            status = sl_iostream_putchar(SL_IOSTREAM_STDOUT, ch);
    348            EFM_ASSERT(status == SL_STATUS_OK);
    349          
    350            return(1);
    351          }
    352          
    353          /**************************************************************************//**
    354           * Read a character.
    355           *
    356           * @return  Character read
    357           *****************************************************************************/
    358          int __getchar(void)
    359          {
    360            int rtn_val = 0;
    361            char c;
    362            sl_status_t status;
    363          
    364            status = sl_iostream_getchar(SL_IOSTREAM_STDIN, &c);
    365            if (status == SL_STATUS_OK) {
    366              rtn_val = 1;
    367            } else {
    368              EFM_ASSERT(status == SL_STATUS_EMPTY);
    369            }
    370          
    371            return(rtn_val);
    372          }
    373          
    374          #endif /* defined( __CROSSWORKS_ARM ) */
    375          
    376          #if defined(__CC_ARM)
    377          /******************************************************************************/
    378          /* RETARGET.C: 'Retarget' layer for target-dependent low-level functions      */
    379          /******************************************************************************/
    380          /* This file is part of the uVision/ARM development tools.                    */
    381          /* Copyright (c) 2005-2006 Keil Software. All rights reserved.                */
    382          /* This software may only be used under the terms of a valid, current,        */
    383          /* end user licence from KEIL for a compatible version of KEIL software       */
    384          /* development tools. Nothing else gives you the right to use this software.  */
    385          /******************************************************************************/
    386          
    387          #include <stdio.h>
    388          
    389          // #pragma import(__use_no_semihosting_swi)
    390          
    391          struct __FILE{
    392            int handle;
    393          };
    394          
    395          //Standard output stream
    396          FILE __stdout;
    397          
    398          /**************************************************************************//**
    399           * Writes character to file
    400           *
    401           * @param[in] f   File
    402           *
    403           * @param[in] ch  Character
    404           *
    405           * @return  Written character
    406           *****************************************************************************/
    407          int fputc(int ch, FILE *f)
    408          {
    409            sl_status_t status;
    410          
    411            status = sl_iostream_putchar(SL_IOSTREAM_STDOUT, ch);
    412            EFM_ASSERT(status == SL_STATUS_OK);
    413          
    414            return(1);
    415          }
    416          
    417          /**************************************************************************//**
    418           * Reads character from file
    419           *
    420           * @param[in] f File
    421           *
    422           * @return  Character
    423           *****************************************************************************/
    424          int fgetc(FILE *f)
    425          {
    426            int rtn_val = 0;
    427            char c;
    428            sl_status_t status;
    429          
    430            status = sl_iostream_getchar(SL_IOSTREAM_STDIN, &c);
    431            if (status == SL_STATUS_OK) {
    432              rtn_val = 1;
    433            } else {
    434              EFM_ASSERT(status == SL_STATUS_EMPTY);
    435            }
    436          
    437            return((int)c);
    438          }
    439          
    440          /**************************************************************************//**
    441           * Tests the error indicator for the stream pointed to by file
    442           *
    443           * @param[in] f File
    444           *
    445           * @return  Returns non-zero if it is set
    446           *****************************************************************************/
    447          int ferror(FILE *f)
    448          {
    449            // Your implementation of ferror
    450            return EOF;
    451          }
    452          
    453          /**************************************************************************//**
    454           * Writes a character to the console
    455           *
    456           * @param[in] ch  Input character
    457           *****************************************************************************/
    458          void _ttywrch(int ch)
    459          {
    460            sl_status_t status;
    461          
    462            status = sl_iostream_putchar(SL_IOSTREAM_STDOUT, ch);
    463            EFM_ASSERT(status == SL_STATUS_OK);
    464          }
    465          
    466          /**************************************************************************//**
    467           * Library exit function. This function is called if stack overflow occurs.
    468           *
    469           * @param[in] return_code Return code
    470           *****************************************************************************/
    471          void _sys_exit(int return_code)
    472          {
    473            label:  goto label; // endless loop
    474          }
    475          #endif /* defined( __CC_ARM ) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TxBuf
        16   -> assertEFM
        16   -> sl_iostream_write
      24   __read
        24   -> sl_iostream_read
      24   __write
        24   -> TxBuf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
     124  ?_0
      38  TxBuf
      50  __read
      54  __write

 
 124 bytes in section .rodata
 146 bytes in section .text
 
 146 bytes of CODE  memory
 124 bytes of CONST memory

Errors: none
Warnings: none
