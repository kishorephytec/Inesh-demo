###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:17
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\src\em_burtc.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_15254289621323374026.dir\em_burtc.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\src\em_burtc.c" -D
#        DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_15254289621323374026.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_15254289621323374026.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_15254289621323374026.dir\em_burtc.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_15254289621323374026.dir\em_burtc.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_15254289621323374026.dir\em_burtc.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\src\em_burtc.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Backup Real Time Counter (BURTC) Peripheral API
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "em_burtc.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void BURTC_SyncWait(void)
   \                     BURTC_SyncWait: (+1)
   \                     ??BURTC_SyncWait_0: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable10
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD003             BEQ.N    ??BURTC_SyncWait_1
   \        0x8   0x....             LDR.N    R0,??DataTable10_1
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD1F7             BNE.N    ??BURTC_SyncWait_0
   \                     ??BURTC_SyncWait_1: (+1)
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void BURTC_Start(void)
   \                     BURTC_Start: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       BURTC_SyncWait
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x....             LDR.N    R0,??DataTable10_2
   \        0xA   0x6001             STR      R1,[R0, #+0]
   \        0xC   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void BURTC_Stop(void)
   \                     BURTC_Stop: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       BURTC_SyncWait
   \        0x6   0x2102             MOVS     R1,#+2
   \        0x8   0x....             LDR.N    R0,??DataTable10_2
   \        0xA   0x6001             STR      R1,[R0, #+0]
   \        0xC   0xBD01             POP      {R0,PC}
     32          #if defined(BURTC_PRESENT)
     33          
     34          /***************************************************************************//**
     35           * @addtogroup burtc BURTC - Backup RTC
     36           * @brief Backup Real Time Counter (BURTC) Peripheral API
     37           * @details
     38           *  This module contains functions to control the BURTC peripheral of Silicon
     39           *  Labs 32-bit MCUs. The Backup Real Time Counter allows timekeeping in all
     40           *  energy modes. The Backup RTC is also available when the system is in backup
     41           *  mode.
     42           * @{
     43           ******************************************************************************/
     44          
     45          /*******************************************************************************
     46           *******************************   DEFINES   ***********************************
     47           ******************************************************************************/
     48          
     49          /*******************************************************************************
     50           **************************   LOCAL FUNCTIONS   ********************************
     51           ******************************************************************************/
     52          
     53          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
     54          /***************************************************************************//**
     55           * @brief Convert dividend to a prescaler logarithmic value. Only works for even
     56           *        numbers equal to 2^n.
     57           * @param[in] div Unscaled dividend,
     58           * @return Base 2 logarithm of input, as used by fixed prescalers.
     59           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     60          __STATIC_INLINE uint32_t divToLog2(uint32_t div)
     61          {
   \                     divToLog2: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     62            uint32_t log2;
     63          
     64            /* Prescaler accepts an argument of 128 or less, valid values being 2^n. */
     65            EFM_ASSERT((div > 0UL) && (div <= 32768UL));
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD003             BEQ.N    ??divToLog2_0
   \        0x8   0xF248 0x0001      MOVW     R0,#+32769
   \        0xC   0x4284             CMP      R4,R0
   \        0xE   0xD303             BCC.N    ??divToLog2_1
   \                     ??divToLog2_0: (+1)
   \       0x10   0x2141             MOVS     R1,#+65
   \       0x12   0x....             LDR.N    R0,??DataTable10_3
   \       0x14   0x.... 0x....      BL       assertEFM
     66          
     67            /* Count leading zeroes and "reverse" result, Cortex-M3 intrinsic. */
     68            log2 = (31UL - __CLZ(div));
   \                     ??divToLog2_1: (+1)
   \       0x18   0xFAB4 0xF084      CLZ      R0,R4
   \       0x1C   0xF1D0 0x001F      RSBS     R0,R0,#+31
     69          
     70            return log2;
   \       0x20   0xBD10             POP      {R4,PC}
     71          }
     72          
     73          /***************************************************************************//**
     74           * @brief
     75           *   Wait for an ongoing sync of register(s) to low frequency domain to complete.
     76           *
     77           * @param[in] mask
     78           *   A bitmask corresponding to SYNCBUSY register defined bits, indicating
     79           *   registers that must complete any ongoing synchronization.
     80           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     81          __STATIC_INLINE void regSync(uint32_t mask)
     82          {
     83          #if defined(_BURTC_FREEZE_MASK)
     84            /* Avoid deadlock if modifying the same register twice when freeze mode is
     85               activated or when a clock is not selected for the BURTC. If a clock is
     86               not selected, then the sync is done once the clock source is set. */
     87            if ((BURTC->FREEZE & BURTC_FREEZE_REGFREEZE)
     88                || ((BURTC->CTRL & _BURTC_CTRL_CLKSEL_MASK) == BURTC_CTRL_CLKSEL_NONE)
     89                || ((BURTC->CTRL & _BURTC_CTRL_RSTEN_MASK) == BURTC_CTRL_RSTEN)) {
     90              return;
     91            }
     92          #endif
     93          
     94            /* Wait for any pending previous write operation to complete */
     95            /* in low frequency domain. This is only required for the Gecko Family. */
     96            while ((BURTC->SYNCBUSY & mask) != 0U) {
   \                     regSync: (+1)
   \                     ??regSync_0: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable10_1
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0x4201             TST      R1,R0
   \        0x6   0xD1FB             BNE.N    ??regSync_0
     97            }
     98          }
   \        0x8   0x4770             BX       LR
     99          /** @endcond */
    100          
    101          /*******************************************************************************
    102           **************************   GLOBAL FUNCTIONS   *******************************
    103           ******************************************************************************/
    104          
    105          /***************************************************************************//**
    106           * @brief Initialize BURTC.
    107           *
    108           * @details
    109           *    Configures the BURTC peripheral.
    110           *
    111           * @note
    112           *   Before initialization, BURTC module must first be enabled by clearing the
    113           *   reset bit in the RMU, i.e.,
    114           * @verbatim
    115           *   RMU_ResetControl(rmuResetBU, rmuResetModeClear);
    116           * @endverbatim
    117           *   Compare channel 0 must be configured outside this function, before
    118           *   initialization if enable is set to true. The counter will always be reset.
    119           *
    120           * @param[in] burtcInit
    121           *   A pointer to the BURTC initialization structure.
    122           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    123          void BURTC_Init(const BURTC_Init_TypeDef *burtcInit)
    124          {
   \                     BURTC_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
    125          #if defined(_SILICON_LABS_32B_SERIES_0)
    126            uint32_t ctrl;
    127            uint32_t presc;
    128          
    129            /* Check initializer structure integrity. */
    130            EFM_ASSERT(burtcInit != (BURTC_Init_TypeDef *) 0);
    131            /* Clock divider must be between 1 and 128, really on the form 2^n. */
    132            EFM_ASSERT((burtcInit->clkDiv >= 1) && (burtcInit->clkDiv <= 128));
    133          
    134            /* Ignored compare bits during low power operation must be less than 7. */
    135            /* Note! Giant Gecko revision C errata, do NOT use LPCOMP=7. */
    136            EFM_ASSERT(burtcInit->lowPowerComp <= 6);
    137            /* You cannot enable the BURTC if mode is set to disabled. */
    138            EFM_ASSERT((burtcInit->enable == false)
    139                       || ((burtcInit->enable == true)
    140                           && (burtcInit->mode != burtcModeDisable)));
    141            /* Low power mode is only available with LFRCO or LFXO as clock source. */
    142            EFM_ASSERT((burtcInit->clkSel != burtcClkSelULFRCO)
    143                       || ((burtcInit->clkSel == burtcClkSelULFRCO)
    144                           && (burtcInit->lowPowerMode == burtcLPDisable)));
    145          
    146            /* Calculate a prescaler value from the clock divider input. */
    147            /* Note! If clock select (clkSel) is ULFRCO, a clock divisor (clkDiv) of
    148               value 1 will select a 2 kHz ULFRCO clock, while any other value will
    149               select a 1 kHz ULFRCO clock source. */
    150            presc = divToLog2(burtcInit->clkDiv);
    151          
    152            /* Make sure all registers are updated simultaneously. */
    153            if (burtcInit->enable) {
    154              BURTC_FreezeEnable(true);
    155            }
    156          
    157            /* Modification of LPMODE register requires sync with potential ongoing
    158             * register updates in LF domain. */
    159            regSync(BURTC_SYNCBUSY_LPMODE);
    160          
    161            /* Configure low power mode. */
    162            BURTC->LPMODE = (uint32_t) (burtcInit->lowPowerMode);
    163          
    164            /* New configuration. */
    165            ctrl = (BURTC_CTRL_RSTEN
    166                    | (burtcInit->mode)
    167                    | (burtcInit->debugRun << _BURTC_CTRL_DEBUGRUN_SHIFT)
    168                    | (burtcInit->compare0Top << _BURTC_CTRL_COMP0TOP_SHIFT)
    169                    | (burtcInit->lowPowerComp << _BURTC_CTRL_LPCOMP_SHIFT)
    170                    | (presc << _BURTC_CTRL_PRESC_SHIFT)
    171                    | (burtcInit->clkSel)
    172                    | (burtcInit->timeStamp << _BURTC_CTRL_BUMODETSEN_SHIFT));
    173          
    174            /* Clear interrupts. */
    175            BURTC_IntClear(0xFFFFFFFF);
    176          
    177            /* Set the new configuration. */
    178            BURTC->CTRL = ctrl;
    179          
    180            /* Enable BURTC and counter. */
    181            if (burtcInit->enable) {
    182              /* To enable BURTC counter, disable reset. */
    183              BURTC_Enable(true);
    184          
    185              /* Clear freeze. */
    186              BURTC_FreezeEnable(false);
    187            }
    188          #elif defined(_SILICON_LABS_32B_SERIES_2)
    189            uint32_t presc;
    190          
    191            presc = divToLog2(burtcInit->clkDiv);
   \        0x4   0x6868             LDR      R0,[R5, #+4]
   \        0x6   0x.... 0x....      BL       divToLog2
   \        0xA   0x0004             MOVS     R4,R0
    192          
    193            if (BURTC->EN != 0U) {
   \        0xC   0x....             LDR.N    R6,??DataTable10
   \        0xE   0x6830             LDR      R0,[R6, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD001             BEQ.N    ??BURTC_Init_0
    194              BURTC_SyncWait();
   \       0x14   0x.... 0x....      BL       BURTC_SyncWait
    195            }
    196            BURTC->EN_CLR = BURTC_EN_EN;
   \                     ??BURTC_Init_0: (+1)
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x....             LDR.N    R0,??DataTable10_4
   \       0x1C   0x6001             STR      R1,[R0, #+0]
    197          #if defined(_BURTC_SYNCBUSY_EN_MASK)
    198            regSync(BURTC_SYNCBUSY_EN);
    199          #elif defined(_BURTC_EN_DISABLING_MASK)
    200            while (BURTC->EN & _BURTC_EN_DISABLING_MASK) {
   \                     ??BURTC_Init_1: (+1)
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x0780             LSLS     R0,R0,#+30
   \       0x22   0xD4FC             BMI.N    ??BURTC_Init_1
    201              /* Wait for disabling to finish */
    202            }
    203          #endif
    204          
    205            BURTC->CFG = (presc << _BURTC_CFG_CNTPRESC_SHIFT)
    206                         | ((burtcInit->compare0Top ? 1UL : 0UL) << _BURTC_CFG_COMPTOP_SHIFT)
    207                         | ((burtcInit->debugRun ? 1UL : 0UL) << _BURTC_CFG_DEBUGRUN_SHIFT);
   \       0x24   0x7A28             LDRB     R0,[R5, #+8]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ.N    ??BURTC_Init_2
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0xE000             B.N      ??BURTC_Init_3
   \                     ??BURTC_Init_2: (+1)
   \       0x2E   0x2100             MOVS     R1,#+0
   \                     ??BURTC_Init_3: (+1)
   \       0x30   0x7868             LDRB     R0,[R5, #+1]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD001             BEQ.N    ??BURTC_Init_4
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE000             B.N      ??BURTC_Init_5
   \                     ??BURTC_Init_4: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??BURTC_Init_5: (+1)
   \       0x3C   0x0049             LSLS     R1,R1,#+1
   \       0x3E   0xEA51 0x1104      ORRS     R1,R1,R4, LSL #+4
   \       0x42   0x4301             ORRS     R1,R0,R1
   \       0x44   0x....             LDR.N    R0,??DataTable10_5
   \       0x46   0x6001             STR      R1,[R0, #+0]
    208            BURTC->EM4WUEN = ((burtcInit->em4comp ? 1UL : 0UL) << _BURTC_EM4WUEN_COMPEM4WUEN_SHIFT)
    209                             | ((burtcInit->em4overflow ? 1UL : 0UL) << _BURTC_EM4WUEN_OFEM4WUEN_SHIFT);
   \       0x48   0x7A68             LDRB     R0,[R5, #+9]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD001             BEQ.N    ??BURTC_Init_6
   \       0x4E   0x2101             MOVS     R1,#+1
   \       0x50   0xE000             B.N      ??BURTC_Init_7
   \                     ??BURTC_Init_6: (+1)
   \       0x52   0x2100             MOVS     R1,#+0
   \                     ??BURTC_Init_7: (+1)
   \       0x54   0x7AA8             LDRB     R0,[R5, #+10]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD001             BEQ.N    ??BURTC_Init_8
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0xE000             B.N      ??BURTC_Init_9
   \                     ??BURTC_Init_8: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \                     ??BURTC_Init_9: (+1)
   \       0x60   0xEA50 0x0041      ORRS     R0,R0,R1, LSL #+1
   \       0x64   0x....             LDR.N    R1,??DataTable10_6
   \       0x66   0x6008             STR      R0,[R1, #+0]
    210            BURTC->EN_SET = BURTC_EN_EN;
   \       0x68   0x2101             MOVS     R1,#+1
   \       0x6A   0x....             LDR.N    R0,??DataTable10_7
   \       0x6C   0x6001             STR      R1,[R0, #+0]
    211            if (burtcInit->start) {
   \       0x6E   0x7828             LDRB     R0,[R5, #+0]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD001             BEQ.N    ??BURTC_Init_10
    212              BURTC_Start();
   \       0x74   0x.... 0x....      BL       BURTC_Start
    213            }
    214          #endif
    215          }
   \                     ??BURTC_Init_10: (+1)
   \       0x78   0xBD70             POP      {R4-R6,PC}
    216          
    217          #if defined(_SILICON_LABS_32B_SERIES_2)
    218          /***************************************************************************//**
    219           * @brief
    220           *   Enable or Disable BURTC peripheral.
    221           *
    222           * @param[in] enable
    223           *   true to enable, false to disable.
    224           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    225          void BURTC_Enable(bool enable)
    226          {
   \                     BURTC_Enable: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    227          #if defined(_BURTC_SYNCBUSY_EN_MASK)
    228            regSync(BURTC_SYNCBUSY_EN);
    229          #endif
    230          
    231            if ((BURTC->EN == 0U) && !enable) {
   \        0x4   0x....             LDR.N    R5,??DataTable10
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD103             BNE.N    ??BURTC_Enable_0
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD016             BEQ.N    ??BURTC_Enable_1
    232              /* Trying to disable BURTC when it's already disabled */
    233              return;
    234            }
    235          
    236            if (BURTC->EN != 0U) {
   \                     ??BURTC_Enable_0: (+1)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??BURTC_Enable_2
    237              /* Modifying the enable bit while synchronization is active will BusFault */
    238              BURTC_SyncWait();
   \       0x1A   0x.... 0x....      BL       BURTC_SyncWait
    239            }
    240          
    241            if (enable) {
   \                     ??BURTC_Enable_2: (+1)
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD003             BEQ.N    ??BURTC_Enable_3
    242              BURTC->EN_SET = BURTC_EN_EN;
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x....             LDR.N    R0,??DataTable10_7
   \       0x2A   0x6001             STR      R1,[R0, #+0]
   \       0x2C   0xE009             B.N      ??BURTC_Enable_4
    243            } else {
    244              BURTC_Stop();
   \                     ??BURTC_Enable_3: (+1)
   \       0x2E   0x.... 0x....      BL       BURTC_Stop
    245              BURTC_SyncWait(); /* Wait for the stop to synchronize */
   \       0x32   0x.... 0x....      BL       BURTC_SyncWait
    246              BURTC->EN_CLR = BURTC_EN_EN;
   \       0x36   0x2101             MOVS     R1,#+1
   \       0x38   0x....             LDR.N    R0,??DataTable10_4
   \       0x3A   0x6001             STR      R1,[R0, #+0]
    247          #if defined(_BURTC_SYNCBUSY_EN_MASK)
    248              regSync(BURTC_SYNCBUSY_EN);
    249          #elif defined(_BURTC_EN_DISABLING_MASK)
    250              while (BURTC->EN & _BURTC_EN_DISABLING_MASK) {
   \                     ??BURTC_Enable_5: (+1)
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x0780             LSLS     R0,R0,#+30
   \       0x40   0xD4FC             BMI.N    ??BURTC_Enable_5
    251                /* Wait for disabling to finish */
    252              }
    253          #endif
    254            }
    255          }
   \                     ??BURTC_Enable_4: (+1)
   \                     ??BURTC_Enable_1: (+1)
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}
    256          #elif defined(_SILICON_LABS_32B_SERIES_0)
    257          /***************************************************************************//**
    258           * @brief
    259           *   Enable or Disable BURTC peripheral reset and start counter
    260           * @param[in] enable
    261           *   If true; asserts reset to BURTC, halts counter, if false; deassert reset
    262           ******************************************************************************/
    263          void BURTC_Enable(bool enable)
    264          {
    265            /* Note! If mode is disabled, BURTC counter will not start */
    266            EFM_ASSERT(((enable == true)
    267                        && ((BURTC->CTRL & _BURTC_CTRL_MODE_MASK)
    268                            != BURTC_CTRL_MODE_DISABLE))
    269                       || (enable == false));
    270            BUS_RegBitWrite(&BURTC->CTRL, _BURTC_CTRL_RSTEN_SHIFT, (uint32_t) !enable);
    271          }
    272          #endif
    273          
    274          /***************************************************************************//**
    275           * @brief Set BURTC compare channel.
    276           *
    277           * @param[in] comp Compare the channel index, must be 0 for current devices.
    278           *
    279           * @param[in] value New compare value.
    280           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    281          void BURTC_CompareSet(unsigned int comp, uint32_t value)
    282          {
   \                     BURTC_CompareSet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    283            (void) comp;  /* Unused parameter when EFM_ASSERT is undefined. */
    284          
    285            EFM_ASSERT(comp == 0U);
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD004             BEQ.N    ??BURTC_CompareSet_0
   \        0xA   0xF240 0x111D      MOVW     R1,#+285
   \        0xE   0x....             LDR.N    R0,??DataTable10_3
   \       0x10   0x.... 0x....      BL       assertEFM
    286          
    287          #if defined(_BURTC_COMP0_MASK)
    288            /* Modification of COMP0 register requires sync with potential ongoing
    289             * register updates in LF domain. */
    290            regSync(BURTC_SYNCBUSY_COMP0);
    291          
    292            /* Configure compare channel 0/. */
    293            BURTC->COMP0 = value;
    294          #else
    295            /* Wait for last potential write to complete. */
    296            regSync(BURTC_SYNCBUSY_COMP);
   \                     ??BURTC_CompareSet_0: (+1)
   \       0x14   0x2010             MOVS     R0,#+16
   \       0x16   0x.... 0x....      BL       regSync
    297          
    298            /* Configure compare channel 0 */
    299            BURTC->COMP = value;
   \       0x1A   0x....             LDR.N    R0,??DataTable10_8
   \       0x1C   0x6005             STR      R5,[R0, #+0]
    300            regSync(BURTC_SYNCBUSY_COMP);
   \       0x1E   0x2010             MOVS     R0,#+16
   \       0x20   0x.... 0x....      BL       regSync
    301          #endif
    302          }
   \       0x24   0xBD31             POP      {R0,R4,R5,PC}
    303          
    304          /***************************************************************************//**
    305           * @brief Get the BURTC compare value.
    306           *
    307           * @param[in] comp Compare the channel index value, must be 0 for Giant/Leopard Gecko.
    308           *
    309           * @return The currently configured value for this compare channel.
    310           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    311          uint32_t BURTC_CompareGet(unsigned int comp)
    312          {
   \                     BURTC_CompareGet: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    313            (void) comp;  /* Unused parameter when EFM_ASSERT is undefined. */
    314          
    315            EFM_ASSERT(comp == 0U);
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD004             BEQ.N    ??BURTC_CompareGet_0
   \        0x8   0xF240 0x113B      MOVW     R1,#+315
   \        0xC   0x....             LDR.N    R0,??DataTable10_3
   \        0xE   0x.... 0x....      BL       assertEFM
    316          #if defined(_BURTC_COMP0_MASK)
    317            return BURTC->COMP0;
    318          #else
    319            return BURTC->COMP;
   \                     ??BURTC_CompareGet_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable10_8
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0xBD10             POP      {R4,PC}
    320          #endif
    321          }
    322          
    323          /***************************************************************************//**
    324           * @brief Reset counter
    325           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    326          void BURTC_CounterReset(void)
    327          {
   \                     BURTC_CounterReset: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    328          #if defined(_BURTC_CTRL_MASK)
    329            /* Set and clear reset bit */
    330            BUS_RegBitWrite(&BURTC->CTRL, _BURTC_CTRL_RSTEN_SHIFT, 1U);
    331            BUS_RegBitWrite(&BURTC->CTRL, _BURTC_CTRL_RSTEN_SHIFT, 0U);
    332          #else
    333            BURTC_Stop();
   \        0x2   0x.... 0x....      BL       BURTC_Stop
    334            BURTC->CNT = 0U;
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x....             LDR.N    R0,??DataTable10_9
   \        0xA   0x6001             STR      R1,[R0, #+0]
    335            BURTC_Start();
   \        0xC   0x.... 0x....      BL       BURTC_Start
    336          #endif
    337          }
   \       0x10   0xBD01             POP      {R0,PC}
    338          
    339          /***************************************************************************//**
    340           * @brief
    341           *   Restore BURTC to reset state.
    342           * @note
    343           *   Before accessing the BURTC, BURSTEN in RMU->CTRL must be cleared.
    344           *   LOCK will not be reset to default value, as this will disable access
    345           *   to core BURTC registers.
    346           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    347          void BURTC_Reset(void)
    348          {
   \                     BURTC_Reset: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    349          #if defined(_SILICON_LABS_32B_SERIES_0)
    350            bool buResetState;
    351          
    352            /* Read reset state, set reset, and restore state. */
    353            buResetState = BUS_RegBitRead(&RMU->CTRL, _RMU_CTRL_BURSTEN_SHIFT);
    354            BUS_RegBitWrite(&RMU->CTRL, _RMU_CTRL_BURSTEN_SHIFT, 1);
    355            BUS_RegBitWrite(&RMU->CTRL, _RMU_CTRL_BURSTEN_SHIFT, buResetState);
    356          #elif defined(_SILICON_LABS_32B_SERIES_2)
    357            if (BURTC->EN != 0U) {
   \        0x2   0x....             LDR.N    R4,??DataTable10
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??BURTC_Reset_0
    358              BURTC_SyncWait();
   \        0xA   0x.... 0x....      BL       BURTC_SyncWait
    359            }
    360            BURTC->EN_SET = BURTC_EN_EN;
   \                     ??BURTC_Reset_0: (+1)
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x....             LDR.N    R0,??DataTable10_7
   \       0x12   0x6001             STR      R1,[R0, #+0]
    361            BURTC_Stop();
   \       0x14   0x.... 0x....      BL       BURTC_Stop
    362            BURTC->CNT     = 0x0;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x....             LDR.N    R0,??DataTable10_9
   \       0x1C   0x6001             STR      R1,[R0, #+0]
    363            BURTC->PRECNT  = 0x0;
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x....             LDR.N    R0,??DataTable10_10
   \       0x22   0x6001             STR      R1,[R0, #+0]
    364            BURTC->COMP    = 0x0;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x....             LDR.N    R0,??DataTable10_8
   \       0x28   0x6001             STR      R1,[R0, #+0]
    365            BURTC->EM4WUEN = _BURTC_EM4WUEN_RESETVALUE;
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x....             LDR.N    R0,??DataTable10_6
   \       0x2E   0x6001             STR      R1,[R0, #+0]
    366            BURTC->IEN     = _BURTC_IEN_RESETVALUE;
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x....             LDR.N    R0,??DataTable10_11
   \       0x34   0x6001             STR      R1,[R0, #+0]
    367            BURTC->IF_CLR  = _BURTC_IF_MASK;
   \       0x36   0x2103             MOVS     R1,#+3
   \       0x38   0x....             LDR.N    R0,??DataTable10_12
   \       0x3A   0x6001             STR      R1,[R0, #+0]
    368            /* Wait for all values to synchronize. BusFaults can happen if we don't
    369             * do this before the enable bit is cleared. */
    370            BURTC_SyncWait();
   \       0x3C   0x.... 0x....      BL       BURTC_SyncWait
    371            BURTC->EN_CLR  = BURTC_EN_EN;
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x....             LDR.N    R0,??DataTable10_4
   \       0x44   0x6001             STR      R1,[R0, #+0]
    372          #if defined(_BURTC_SYNCBUSY_EN_MASK)
    373            while (BURTC->SYNCBUSY != 0U) {
    374              // Wait for the EN=0 to synchronize
    375            }
    376          #elif defined(_BURTC_EN_DISABLING_MASK)
    377            while (BURTC->EN & _BURTC_EN_DISABLING_MASK) {
   \                     ??BURTC_Reset_1: (+1)
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x0780             LSLS     R0,R0,#+30
   \       0x4A   0xD4FC             BMI.N    ??BURTC_Reset_1
    378              /* Wait for disabling to finish */
    379            }
    380          #endif
    381            BURTC->CFG = _BURTC_CFG_RESETVALUE;
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x....             LDR.N    R0,??DataTable10_5
   \       0x50   0x6001             STR      R1,[R0, #+0]
    382          #endif
    383          }
   \       0x52   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x5006'4004        DC32     0x50064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x5006'4028        DC32     0x50064028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x5006'400C        DC32     0x5006400c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x5006'6004        DC32     0x50066004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0x5006'4008        DC32     0x50064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0x5006'4024        DC32     0x50064024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \        0x0   0x5006'5004        DC32     0x50065004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \        0x0   0x5006'4030        DC32     0x50064030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \        0x0   0x5006'4020        DC32     0x50064020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \        0x0   0x5006'401C        DC32     0x5006401c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \        0x0   0x5006'4018        DC32     0x50064018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \        0x0   0x5006'6014        DC32     0x50066014

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x65 0x6D          DC8 0x65, 0x6D, 0x6C, 0x69, 0x62, 0x5C, 0x73, 0x72
   \              0x6C 0x69    
   \              0x62 0x5C    
   \              0x73 0x72
   \       0x50   0x63 0x5C          DC8 0x63, 0x5C, 0x65, 0x6D, 0x5F, 0x62, 0x75, 0x72
   \              0x65 0x6D    
   \              0x5F 0x62    
   \              0x75 0x72
   \       0x58   0x74 0x63          DC8 0x74, 0x63, 0x2E, 0x63, 0
   \              0x2E 0x63    
   \              0x00
   \       0x5D                      DS8 3
    384          
    385          #if defined(_BURTC_CTRL_MASK)
    386          /***************************************************************************//**
    387           * @brief
    388           *   Get the clock frequency of the BURTC.
    389           *
    390           * @return
    391           *   The current frequency in Hz.
    392           ******************************************************************************/
    393          uint32_t BURTC_ClockFreqGet(void)
    394          {
    395            uint32_t clkSel;
    396            uint32_t clkDiv;
    397            uint32_t frequency;
    398          
    399            clkSel = BURTC->CTRL & _BURTC_CTRL_CLKSEL_MASK;
    400            clkDiv = (BURTC->CTRL & _BURTC_CTRL_PRESC_MASK) >> _BURTC_CTRL_PRESC_SHIFT;
    401          
    402            switch (clkSel) {
    403              /** Ultra-low frequency (1 kHz) clock. */
    404              case BURTC_CTRL_CLKSEL_ULFRCO:
    405                if (_BURTC_CTRL_PRESC_DIV1 == clkDiv) {
    406                  frequency = 2000;     /* 2 kHz when clock divisor is 1. */
    407                } else {
    408                  frequency = SystemULFRCOClockGet();  /* 1 kHz when divisor is different
    409                                                          from 1. */
    410                }
    411                break;
    412          
    413              /** Low-frequency RC oscillator. */
    414              case BURTC_CTRL_CLKSEL_LFRCO:
    415                frequency = SystemLFRCOClockGet() / (1 << clkDiv); /* freq=32768/2^clkDiv */
    416                break;
    417          
    418              /** Low-frequency crystal oscillator. */
    419              case BURTC_CTRL_CLKSEL_LFXO:
    420                frequency = SystemLFXOClockGet() / (1 << clkDiv); /* freq=32768/2^clkDiv */
    421                break;
    422          
    423              default:
    424                /* No clock selected for BURTC. */
    425                frequency = 0;
    426            }
    427            return frequency;
    428          }
    429          #endif
    430          
    431          /** @} (end addtogroup burtc) */
    432          
    433          #endif /* BURTC_PRESENT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BURTC_CompareGet
         8   -> assertEFM
      16   BURTC_CompareSet
        16   -> assertEFM
        16   -> regSync
       8   BURTC_CounterReset
         8   -> BURTC_Start
         8   -> BURTC_Stop
      16   BURTC_Enable
        16   -> BURTC_Stop
        16   -> BURTC_SyncWait
      16   BURTC_Init
        16   -> BURTC_Start
        16   -> BURTC_SyncWait
        16   -> divToLog2
       8   BURTC_Reset
         8   -> BURTC_Stop
         8   -> BURTC_SyncWait
       8   BURTC_Start
         8   -> BURTC_SyncWait
       8   BURTC_Stop
         8   -> BURTC_SyncWait
       0   BURTC_SyncWait
       8   divToLog2
         8   -> assertEFM
       0   regSync


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      96  ?_0
      24  BURTC_CompareGet
      38  BURTC_CompareSet
      18  BURTC_CounterReset
      68  BURTC_Enable
     122  BURTC_Init
      84  BURTC_Reset
      14  BURTC_Start
      14  BURTC_Stop
      18  BURTC_SyncWait
      34  divToLog2
      10  regSync

 
  96 bytes in section .rodata
 496 bytes in section .text
 
 496 bytes of CODE  memory
  96 bytes of CONST memory

Errors: none
Warnings: none
