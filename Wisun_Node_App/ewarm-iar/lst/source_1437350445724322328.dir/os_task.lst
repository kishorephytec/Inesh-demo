###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:03
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_task.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_task.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_task.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_task.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir\os_task.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_task.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_task.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Kernel - Task Management
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                       DEPENDENCIES & AVAIL CHECK(S)
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <rtos_description.h>
     25          
     26          #if (defined(RTOS_MODULE_KERNEL_AVAIL))
     27          
     28          /********************************************************************************************************
     29           ********************************************************************************************************
     30           *                                               INCLUDE FILES
     31           ********************************************************************************************************
     32           *******************************************************************************************************/
     33          
     34          #define  MICRIUM_SOURCE
     35          #include "../include/os.h"
     36          #include "os_priv.h"
     37          
     38          #include  <em_core.h>
     39          
     40          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     41          const CPU_CHAR *os_task__c = "$Id: $";
     42          #endif
     43          
     44          /********************************************************************************************************
     45           ********************************************************************************************************
     46           *                                           GLOBAL FUNCTIONS
     47           ********************************************************************************************************
     48           *******************************************************************************************************/
     49          
     50          /********************************************************************************************************
     51           ********************************************************************************************************
     52           *                                       LOCAL GLOBAL VARIABLES
     53           ********************************************************************************************************
     54           *******************************************************************************************************/
     55          
     56          #if  (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
     57          OS_EXT sl_sleeptimer_timer_handle_t OSRoundRobinTimer;
     58          #endif
     59          
     60          /****************************************************************************************************//**
     61           *                                           OSTaskChangePrio()
     62           *
     63           * @brief    Allows you to dynamically change the priority of a task. Note that the new
     64           *           priority MUST be available.
     65           *
     66           * @param    p_tcb       Pointer to the TCB of the task for which to change the priority.
     67           *
     68           * @param    prio_new    The new priority.
     69           *
     70           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
     71           *                       from this function:
     72           *                           - RTOS_ERR_NONE
     73           *                           - RTOS_ERR_INVALID_ARG
     74           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     75          void OSTaskChangePrio(OS_TCB   *p_tcb,
     76                                OS_PRIO  prio_new,
     77                                RTOS_ERR *p_err)
     78          {
   \                     OSTaskChangePrio: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x0015             MOVS     R5,R2
     79          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
     80            OS_PRIO prio_high;
     81          #endif
     82            CORE_DECLARE_IRQ_STATE;
     83          
     84            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSTaskChangePrio_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
     85          
     86            OS_ASSERT_DBG_ERR_SET(((p_tcb == DEF_NULL)
     87                                   || (p_tcb->TaskState != OS_TASK_STATE_DEL)), *p_err, RTOS_ERR_INVALID_STATE,; );
   \                     ??OSTaskChangePrio_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD003             BEQ.N    ??OSTaskChangePrio_1
   \       0x16   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \       0x1A   0x28FF             CMP      R0,#+255
   \       0x1C   0xD001             BEQ.N    ??OSTaskChangePrio_2
   \                     ??OSTaskChangePrio_1: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE000             B.N      ??OSTaskChangePrio_3
   \                     ??OSTaskChangePrio_2: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \                     ??OSTaskChangePrio_3: (+1)
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD10A             BNE.N    ??OSTaskChangePrio_4
   \       0x2A   0x201F             MOVS     R0,#+31
   \       0x2C   0x7028             STRB     R0,[R5, #+0]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x32   0x6068             STR      R0,[R5, #+4]
   \       0x34   0x2057             MOVS     R0,#+87
   \       0x36   0x60A8             STR      R0,[R5, #+8]
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable9
   \       0x3C   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskChangePrio_5: (+1)
   \       0x3E   0xE7FE             B.N      ??OSTaskChangePrio_5
     88          
     89            //                                                               Not allowed to call from an ISR
     90            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSTaskChangePrio_4: (+1)
   \       0x40   0x.... 0x....      BL       CORE_InIrqContext
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD101             BNE.N    ??OSTaskChangePrio_6
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xE000             B.N      ??OSTaskChangePrio_7
   \                     ??OSTaskChangePrio_6: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??OSTaskChangePrio_7: (+1)
   \       0x4E   0xB2C0             UXTB     R0,R0
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD10A             BNE.N    ??OSTaskChangePrio_8
   \       0x54   0x2020             MOVS     R0,#+32
   \       0x56   0x7028             STRB     R0,[R5, #+0]
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x5C   0x6068             STR      R0,[R5, #+4]
   \       0x5E   0x205A             MOVS     R0,#+90
   \       0x60   0x60A8             STR      R0,[R5, #+8]
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable9
   \       0x66   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskChangePrio_9: (+1)
   \       0x68   0xE7FE             B.N      ??OSTaskChangePrio_9
     91          
     92            if (prio_new >= OS_CFG_PRIO_MAX) {
   \                     ??OSTaskChangePrio_8: (+1)
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0xB2C0             UXTB     R0,R0
   \       0x6E   0x2840             CMP      R0,#+64
   \       0x70   0xD30A             BCC.N    ??OSTaskChangePrio_10
     93              RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_ARG);
   \       0x72   0x2008             MOVS     R0,#+8
   \       0x74   0x7028             STRB     R0,[R5, #+0]
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x7A   0x6068             STR      R0,[R5, #+4]
   \       0x7C   0x205D             MOVS     R0,#+93
   \       0x7E   0x60A8             STR      R0,[R5, #+8]
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable9
   \       0x84   0x60E8             STR      R0,[R5, #+12]
     94              return;
   \       0x86   0xE04A             B.N      ??OSTaskChangePrio_11
     95            }
     96          
     97            CORE_ENTER_ATOMIC();
   \                     ??OSTaskChangePrio_10: (+1)
   \       0x88   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x8C   0x0007             MOVS     R7,R0
     98            if (p_tcb == DEF_NULL) {                                      // Are we changing the priority of 'self'?
   \       0x8E   0x2C00             CMP      R4,#+0
   \       0x90   0xD116             BNE.N    ??OSTaskChangePrio_12
     99              if (OSRunning != OS_STATE_OS_RUNNING) {
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \       0x96   0x7800             LDRB     R0,[R0, #+0]
   \       0x98   0x2801             CMP      R0,#+1
   \       0x9A   0xD00D             BEQ.N    ??OSTaskChangePrio_13
    100                CORE_EXIT_ATOMIC();
   \       0x9C   0x0038             MOVS     R0,R7
   \       0x9E   0x.... 0x....      BL       CORE_ExitAtomic
    101                OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_NOT_READY,; )
   \       0xA2   0x2002             MOVS     R0,#+2
   \       0xA4   0x7028             STRB     R0,[R5, #+0]
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0xAA   0x6068             STR      R0,[R5, #+4]
   \       0xAC   0x2065             MOVS     R0,#+101
   \       0xAE   0x60A8             STR      R0,[R5, #+8]
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable9
   \       0xB4   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskChangePrio_14: (+1)
   \       0xB6   0xE7FE             B.N      ??OSTaskChangePrio_14
    102              }
    103              p_tcb = OSTCBCurPtr;
   \                     ??OSTaskChangePrio_13: (+1)
   \       0xB8   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \       0xBC   0x6800             LDR      R0,[R0, #+0]
   \       0xBE   0x0004             MOVS     R4,R0
    104            }
    105          
    106          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    107            p_tcb->BasePrio = prio_new;                                   // Update base priority
   \                     ??OSTaskChangePrio_12: (+1)
   \       0xC0   0xF884 0x8028      STRB     R8,[R4, #+40]
    108          
    109            if (p_tcb->MutexGrpHeadPtr != DEF_NULL) {                     // Owning a mutex?
   \       0xC4   0x6AE0             LDR      R0,[R4, #+44]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD010             BEQ.N    ??OSTaskChangePrio_15
    110              if (prio_new > p_tcb->Prio) {
   \       0xCA   0xF894 0x1027      LDRB     R1,[R4, #+39]
   \       0xCE   0x4640             MOV      R0,R8
   \       0xD0   0xB2C0             UXTB     R0,R0
   \       0xD2   0x4281             CMP      R1,R0
   \       0xD4   0xD20A             BCS.N    ??OSTaskChangePrio_15
    111                prio_high = OS_MutexGrpPrioFindHighest(p_tcb);
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \       0xDC   0x0006             MOVS     R6,R0
    112                if (prio_new > prio_high) {
   \       0xDE   0x0031             MOVS     R1,R6
   \       0xE0   0x4640             MOV      R0,R8
   \       0xE2   0xB2C9             UXTB     R1,R1
   \       0xE4   0xB2C0             UXTB     R0,R0
   \       0xE6   0x4281             CMP      R1,R0
   \       0xE8   0xD200             BCS.N    ??OSTaskChangePrio_15
    113                  prio_new = prio_high;
   \       0xEA   0x46B0             MOV      R8,R6
    114                }
    115              }
    116            }
    117          #endif
    118          
    119            OS_TaskChangePrio(p_tcb, prio_new);
   \                     ??OSTaskChangePrio_15: (+1)
   \       0xEC   0x4641             MOV      R1,R8
   \       0xEE   0xB2C9             UXTB     R1,R1
   \       0xF0   0x0020             MOVS     R0,R4
   \       0xF2   0x.... 0x....      BL       OS_TaskChangePrio
    120          
    121            OS_TRACE_TASK_PRIO_CHANGE(p_tcb, prio_new);
    122          
    123            CORE_EXIT_ATOMIC();
   \       0xF6   0x0038             MOVS     R0,R7
   \       0xF8   0x.... 0x....      BL       CORE_ExitAtomic
    124          
    125            if (OSRunning == OS_STATE_OS_RUNNING) {
   \       0xFC   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \      0x100   0x7800             LDRB     R0,[R0, #+0]
   \      0x102   0x2801             CMP      R0,#+1
   \      0x104   0xD101             BNE.N    ??OSTaskChangePrio_16
    126              OSSched();                                                  // Run highest priority task ready
   \      0x106   0x.... 0x....      BL       OSSched
    127            }
    128          
    129            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSTaskChangePrio_16: (+1)
   \      0x10A   0x2000             MOVS     R0,#+0
   \      0x10C   0x7028             STRB     R0,[R5, #+0]
   \      0x10E   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0x112   0x6068             STR      R0,[R5, #+4]
   \      0x114   0x2081             MOVS     R0,#+129
   \      0x116   0x60A8             STR      R0,[R5, #+8]
   \      0x118   0x.... 0x....      LDR.W    R0,??DataTable9
   \      0x11C   0x60E8             STR      R0,[R5, #+12]
    130          }
   \                     ??OSTaskChangePrio_11: (+1)
   \      0x11E   0xE8BD 0x81F0      POP      {R4-R8,PC}
    131          
    132          /****************************************************************************************************//**
    133           *                                               OSTaskCreate()
    134           *
    135           * @brief    Allows the Kernel to manage the execution of a task. Tasks can either
    136           *           be created prior to the start of multitasking or by a running task. A task cannot be
    137           *           created by an ISR.
    138           *
    139           * @param    p_tcb           Pointer to the task's TCB.
    140           *
    141           * @param    p_name          Pointer to an ASCII string that provides a name for the task.
    142           *
    143           * @param    p_task          Pointer to the task's code.
    144           *
    145           * @param    p_arg           Pointer to an optional data area which can pass parameters to the task
    146           *                           when the task executes. For the task, it believes it was invoked and
    147           *                           passed the argument 'p_arg' as follows:
    148           *                           @verbatim
    149           *                           void Task (void *p_arg)
    150           *                           {
    151           *                               for (;;) {
    152           *                                   Task code;
    153           *                               }
    154           *                           }
    155           *                           @endverbatim
    156           *
    157           * @param    prio            The task's priority. A unique priority MUST be assigned to each task.
    158           *                           The lower the number, the higher the priority.
    159           *
    160           * @param    p_stk_base      Pointer to the base address of the stack (i.e. low address).
    161           *
    162           * @param    stk_limit       The number of stack elements to set as 'watermark' limits for the stack.
    163           *                           This value represents the number of CPU_STK entries left before the stack
    164           *                           is full. For example, specifying 10% of the 'stk_size' value indicates that
    165           *                           the stack limit will be reached when the stack reaches 90% full.
    166           *
    167           * @param    stk_size        The size of the stack in number of elements. If CPU_STK is set to
    168           *                           CPU_INT08U, the 'stk_size' corresponds to the number of bytes available.
    169           *                           If CPU_STK is set to CPU_INT16U, the 'stk_size' contains the number of
    170           *                           16-bit entries available. Finally, if CPU_STK is set to CPU_INT32U, the
    171           *                           'stk_size' contains the number of 32-bit entries available on the stack.
    172           *
    173           * @param    q_size          The maximum number of messages that can be sent to the task.
    174           *
    175           * @param    time_quanta     Amount of time (in ticks) for a time slice when the round-robin between
    176           *                           tasks. Set to 0 to use the default.
    177           *
    178           * @param    p_ext           Pointer to a user-supplied memory location which is used as a TCB
    179           *                           extension. For example, this user memory can hold the contents of
    180           *                           floating-point registers during a context switch, the time each task takes
    181           *                           to execute, the number of times the task has been switched-in, etc.
    182           *
    183           * @param    opt             Contains additional information (or options) about the behavior of the task.
    184           *                           See OS_OPT_TASK_xxx in OS.H. Current choices are:
    185           *                               - OS_OPT_TASK_NONE        No option selected.
    186           *                               - OS_OPT_TASK_STK_CHK     Stack checking to be allowed for the task.
    187           *                               - OS_OPT_TASK_STK_CLR     Clear the stack when the task is created.
    188           *                               - OS_OPT_TASK_SAVE_FP     If the CPU has floating-point registers,
    189           *                                                         save them during a context switch.
    190           *                               - OS_OPT_TASK_NO_TLS      If the caller does not want or need TLS
    191           *                           (Thread Local Storage) support for the task.
    192           *                           If you do not include this option, TLS will
    193           *                           be supported by default.
    194           *
    195           * @param    p_err           Pointer to the variable that will receive one of the following error code(s)
    196           *                           from this function:
    197           *                               - RTOS_ERR_NONE
    198           *                               - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    199           *
    200           * @note     (1) OSTaskCreate() triggers a critical assert when a stack overflow is detected during
    201           *               stack initialization. In this case, some memory may have been corrupted and should
    202           *               be treated as a fatal error.
    203           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    204          void OSTaskCreate(OS_TCB       *p_tcb,
    205                            CPU_CHAR     *p_name,
    206                            OS_TASK_PTR  p_task,
    207                            void         *p_arg,
    208                            OS_PRIO      prio,
    209                            CPU_STK      *p_stk_base,
    210                            CPU_STK_SIZE stk_limit,
    211                            CPU_STK_SIZE stk_size,
    212                            OS_MSG_QTY   q_size,
    213                            OS_TICK      time_quanta,
    214                            void         *p_ext,
    215                            OS_OPT       opt,
    216                            RTOS_ERR     *p_err)
    217          {
   \                     OSTaskCreate: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB083             SUB      SP,SP,#+12
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0xF8DD 0x9048      LDR      R9,[SP, #+72]
   \        0xC   0x9E13             LDR      R6,[SP, #+76]
   \        0xE   0x9D18             LDR      R5,[SP, #+96]
    218            CPU_STK_SIZE i;
    219          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    220            OS_REG_ID reg_nbr;
    221          #endif
    222          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    223            OS_TLS_ID id;
    224          #endif
    225          
    226            CPU_STK *p_sp;
    227            CPU_STK *p_stk_limit;
    228            CORE_DECLARE_IRQ_STATE;
    229          
    230            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD101             BNE.N    ??OSTaskCreate_0
   \       0x14   0x.... 0x....      BL       CPU_SW_Exception
    231          
    232          #ifdef OS_SAFETY_CRITICAL_IEC61508
    233            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    234              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
    235              return;
    236            }
    237          #endif
    238          
    239            //                                                               Not allowed to call from an ISR
    240            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSTaskCreate_0: (+1)
   \       0x18   0x.... 0x....      BL       CORE_InIrqContext
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD101             BNE.N    ??OSTaskCreate_1
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE000             B.N      ??OSTaskCreate_2
   \                     ??OSTaskCreate_1: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \                     ??OSTaskCreate_2: (+1)
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD10A             BNE.N    ??OSTaskCreate_3
   \       0x2C   0x2020             MOVS     R0,#+32
   \       0x2E   0x7028             STRB     R0,[R5, #+0]
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x34   0x6068             STR      R0,[R5, #+4]
   \       0x36   0x20F0             MOVS     R0,#+240
   \       0x38   0x60A8             STR      R0,[R5, #+8]
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x3E   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskCreate_4: (+1)
   \       0x40   0xE7FE             B.N      ??OSTaskCreate_4
    241          
    242            //                                                               User must supply a valid OS_TCB
    243            OS_ASSERT_DBG_ERR_SET((p_tcb != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSTaskCreate_3: (+1)
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD10A             BNE.N    ??OSTaskCreate_5
   \       0x46   0x200A             MOVS     R0,#+10
   \       0x48   0x7028             STRB     R0,[R5, #+0]
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x4E   0x6068             STR      R0,[R5, #+4]
   \       0x50   0x20F3             MOVS     R0,#+243
   \       0x52   0x60A8             STR      R0,[R5, #+8]
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x58   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskCreate_6: (+1)
   \       0x5A   0xE7FE             B.N      ??OSTaskCreate_6
    244          
    245            //                                                               User must supply a valid task
    246            OS_ASSERT_DBG_ERR_SET((p_task != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSTaskCreate_5: (+1)
   \       0x5C   0x9805             LDR      R0,[SP, #+20]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD10A             BNE.N    ??OSTaskCreate_7
   \       0x62   0x200A             MOVS     R0,#+10
   \       0x64   0x7028             STRB     R0,[R5, #+0]
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x6A   0x6068             STR      R0,[R5, #+4]
   \       0x6C   0x20F6             MOVS     R0,#+246
   \       0x6E   0x60A8             STR      R0,[R5, #+8]
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x74   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskCreate_8: (+1)
   \       0x76   0xE7FE             B.N      ??OSTaskCreate_8
    247          
    248            //                                                               User must supply a valid stack base address
    249            OS_ASSERT_DBG_ERR_SET((p_stk_base != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSTaskCreate_7: (+1)
   \       0x78   0x9811             LDR      R0,[SP, #+68]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD10A             BNE.N    ??OSTaskCreate_9
   \       0x7E   0x200A             MOVS     R0,#+10
   \       0x80   0x7028             STRB     R0,[R5, #+0]
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x86   0x6068             STR      R0,[R5, #+4]
   \       0x88   0x20F9             MOVS     R0,#+249
   \       0x8A   0x60A8             STR      R0,[R5, #+8]
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x90   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskCreate_10: (+1)
   \       0x92   0xE7FE             B.N      ??OSTaskCreate_10
    250          
    251            //                                                               User must supply a valid minimum stack size
    252            OS_ASSERT_DBG_ERR_SET((stk_size >= OSCfg_StkSizeMin), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTaskCreate_9: (+1)
   \       0x94   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \       0x98   0x6800             LDR      R0,[R0, #+0]
   \       0x9A   0x4286             CMP      R6,R0
   \       0x9C   0xD20A             BCS.N    ??OSTaskCreate_11
   \       0x9E   0x2008             MOVS     R0,#+8
   \       0xA0   0x7028             STRB     R0,[R5, #+0]
   \       0xA2   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0xA6   0x6068             STR      R0,[R5, #+4]
   \       0xA8   0x20FC             MOVS     R0,#+252
   \       0xAA   0x60A8             STR      R0,[R5, #+8]
   \       0xAC   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0xB0   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskCreate_12: (+1)
   \       0xB2   0xE7FE             B.N      ??OSTaskCreate_12
    253          
    254            //                                                               User must supply a valid stack limit
    255            OS_ASSERT_DBG_ERR_SET((stk_limit < stk_size), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTaskCreate_11: (+1)
   \       0xB4   0x45B1             CMP      R9,R6
   \       0xB6   0xD30A             BCC.N    ??OSTaskCreate_13
   \       0xB8   0x2008             MOVS     R0,#+8
   \       0xBA   0x7028             STRB     R0,[R5, #+0]
   \       0xBC   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0xC0   0x6068             STR      R0,[R5, #+4]
   \       0xC2   0x20FF             MOVS     R0,#+255
   \       0xC4   0x60A8             STR      R0,[R5, #+8]
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0xCA   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskCreate_14: (+1)
   \       0xCC   0xE7FE             B.N      ??OSTaskCreate_14
    256          
    257            //                                                               Priority must be within 0 and OS_CFG_PRIO_MAX-1
    258            OS_ASSERT_DBG_ERR_SET((prio < OS_CFG_PRIO_MAX), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTaskCreate_13: (+1)
   \       0xCE   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \       0xD2   0x2840             CMP      R0,#+64
   \       0xD4   0xD30B             BCC.N    ??OSTaskCreate_15
   \       0xD6   0x2008             MOVS     R0,#+8
   \       0xD8   0x7028             STRB     R0,[R5, #+0]
   \       0xDA   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0xDE   0x6068             STR      R0,[R5, #+4]
   \       0xE0   0xF44F 0x7081      MOV      R0,#+258
   \       0xE4   0x60A8             STR      R0,[R5, #+8]
   \       0xE6   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0xEA   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskCreate_16: (+1)
   \       0xEC   0xE7FE             B.N      ??OSTaskCreate_16
    259          
    260          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    261            //                                                               Q size must be within 0 and OSCfg_MsgPoolSize
    262            OS_ASSERT_DBG_ERR_SET((q_size <= OSCfg_MsgPoolSize), *p_err, RTOS_ERR_INVALID_ARG,; );
    263          #endif
    264          
    265            OS_TaskInitTCB(p_tcb);                                        // Initialize the TCB to default values
   \                     ??OSTaskCreate_15: (+1)
   \       0xEE   0x0020             MOVS     R0,R4
   \       0xF0   0x.... 0x....      BL       OS_TaskInitTCB
    266          
    267            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x7028             STRB     R0,[R5, #+0]
   \       0xF8   0x.... 0x....      LDR.W    R11,??DataTable8
   \       0xFC   0xF8C5 0xB004      STR      R11,[R5, #+4]
   \      0x100   0xF240 0x100B      MOVW     R0,#+267
   \      0x104   0x60A8             STR      R0,[R5, #+8]
   \      0x106   0x.... 0x....      LDR.W    R10,??DataTable10
   \      0x10A   0xF8C5 0xA00C      STR      R10,[R5, #+12]
    268          
    269            //                                                               -------------- CLEAR THE TASK'S STACK --------------
    270            if (((opt & OS_OPT_TASK_STK_CHK) != 0u)                       // See if stack checking has been enabled
    271                || ((opt & OS_OPT_TASK_STK_CLR) != 0u)) {                 // See if stack needs to be cleared
   \      0x10E   0xF8BD 0x005C      LDRH     R0,[SP, #+92]
   \      0x112   0xF010 0x0F03      TST      R0,#0x3
   \      0x116   0xD010             BEQ.N    ??OSTaskCreate_17
    272              if ((opt & OS_OPT_TASK_STK_CLR) != 0u) {
   \      0x118   0xF8BD 0x005C      LDRH     R0,[SP, #+92]
   \      0x11C   0x0780             LSLS     R0,R0,#+30
   \      0x11E   0xD50C             BPL.N    ??OSTaskCreate_17
    273                p_sp = p_stk_base;
   \      0x120   0x9811             LDR      R0,[SP, #+68]
   \      0x122   0x4680             MOV      R8,R0
    274                for (i = 0u; i < stk_size; i++) {                         // Stack grows from HIGH to LOW memory
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0x0007             MOVS     R7,R0
   \                     ??OSTaskCreate_18: (+1)
   \      0x128   0x42B7             CMP      R7,R6
   \      0x12A   0xD206             BCS.N    ??OSTaskCreate_17
    275                  *p_sp = 0u;                                             // Clear from bottom of stack and up!
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    276                  p_sp++;
   \      0x132   0xF118 0x0804      ADDS     R8,R8,#+4
    277                }
   \      0x136   0x1C7F             ADDS     R7,R7,#+1
   \      0x138   0xE7F6             B.N      ??OSTaskCreate_18
    278              }
    279            }
    280            //                                                               ------ INITIALIZE THE STACK FRAME OF THE TASK ------
    281            stk_limit &= ~(CPU_CFG_STK_ALIGN_BYTES - 1u);                 // Align stack limit.
   \                     ??OSTaskCreate_17: (+1)
   \      0x13A   0xEA5F 0x09D9      LSRS     R9,R9,#+3
   \      0x13E   0xEA5F 0x09C9      LSLS     R9,R9,#+3
   \      0x142   0xF8CD 0x9048      STR      R9,[SP, #+72]
    282          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
    283            p_stk_limit = p_stk_base + stk_limit;
   \      0x146   0x9911             LDR      R1,[SP, #+68]
   \      0x148   0x9812             LDR      R0,[SP, #+72]
   \      0x14A   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \      0x14E   0x9002             STR      R0,[SP, #+8]
    284          #else
    285            p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
    286          #endif
    287          
    288            p_sp = OSTaskStkInit(p_task,
    289                                 p_arg,
    290                                 p_stk_base,
    291                                 p_stk_limit,
    292                                 stk_size,
    293                                 opt);
   \      0x150   0xF8BD 0x005C      LDRH     R0,[SP, #+92]
   \      0x154   0x9001             STR      R0,[SP, #+4]
   \      0x156   0x9600             STR      R6,[SP, #+0]
   \      0x158   0x9B02             LDR      R3,[SP, #+8]
   \      0x15A   0x9A11             LDR      R2,[SP, #+68]
   \      0x15C   0x9906             LDR      R1,[SP, #+24]
   \      0x15E   0x9805             LDR      R0,[SP, #+20]
   \      0x160   0x.... 0x....      BL       OSTaskStkInit
   \      0x164   0x4681             MOV      R9,R0
    294          
    295          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)             // Check if we overflown the stack during init
    296            RTOS_ASSERT_CRITICAL_ERR_SET((p_sp >= p_stk_base), *p_err, RTOS_ERR_OS,; );
   \      0x166   0x9811             LDR      R0,[SP, #+68]
   \      0x168   0x4581             CMP      R9,R0
   \      0x16A   0xD20A             BCS.N    ??OSTaskCreate_19
   \      0x16C   0x2032             MOVS     R0,#+50
   \      0x16E   0x7028             STRB     R0,[R5, #+0]
   \      0x170   0xF8C5 0xB004      STR      R11,[R5, #+4]
   \      0x174   0xF44F 0x7094      MOV      R0,#+296
   \      0x178   0x60A8             STR      R0,[R5, #+8]
   \      0x17A   0xF8C5 0xA00C      STR      R10,[R5, #+12]
   \      0x17E   0x.... 0x....      BL       CPU_SW_Exception
    297          #else
    298            RTOS_ASSERT_CRITICAL_ERR_SET((p_sp <= (p_stk_base + stk_size)), *p_err, RTOS_ERR_OS,; );
    299          #endif
    300          
    301          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)                 // Initialize Redzoned stack
    302            OS_TaskStkRedzoneInit(p_stk_base, stk_size);
    303          #endif
    304          
    305            //                                                               ------------ INITIALIZE THE TCB FIELDS -------------
    306          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    307            p_tcb->TaskEntryAddr = p_task;                                // Save task entry point address
    308            p_tcb->TaskEntryArg = p_arg;                                  // Save task entry argument
    309          #endif
    310          
    311          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    312            p_tcb->NamePtr = p_name;                                      // Save task name
    313          #else
    314            (void)&p_name;
   \                     ??OSTaskCreate_19: (+1)
   \      0x182   0xA804             ADD      R0,SP,#+16
    315          #endif
    316          
    317            p_tcb->Prio = prio;                                           // Save the task's priority
   \      0x184   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \      0x188   0xF884 0x0027      STRB     R0,[R4, #+39]
    318          
    319          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    320            p_tcb->BasePrio = prio;                                       // Set the base priority
   \      0x18C   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \      0x190   0xF884 0x0028      STRB     R0,[R4, #+40]
    321          #endif
    322          
    323            p_tcb->StkPtr = p_sp;                                         // Save the new top-of-stack pointer
   \      0x194   0xF8C4 0x9000      STR      R9,[R4, #+0]
    324          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
    325            p_tcb->StkLimitPtr = p_stk_limit;                             // Save the stack limit pointer
   \      0x198   0x9802             LDR      R0,[SP, #+8]
   \      0x19A   0x60A0             STR      R0,[R4, #+8]
    326          #endif
    327          
    328          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    329            p_tcb->TimeQuanta = time_quanta;                              // Save the #ticks for time slice (0 means not sliced)
    330            if (time_quanta == 0u) {
    331              p_tcb->TimeQuantaCtr = (uint64_t)(((uint64_t)OSSchedRoundRobinDfltTimeQuanta * (uint64_t)sl_sleeptimer_get_timer_frequency()) + (OSCfg_TickRate_Hz - 1u)) / OSCfg_TickRate_Hz;
    332            } else {
    333              p_tcb->TimeQuantaCtr = (uint64_t)(((uint64_t)p_tcb->TimeQuanta * (uint64_t)sl_sleeptimer_get_timer_frequency()) + (OSCfg_TickRate_Hz - 1u)) / OSCfg_TickRate_Hz;
    334            }
    335          #else
    336            (void)&time_quanta;
   \      0x19C   0xA815             ADD      R0,SP,#+84
    337          #endif
    338          
    339            p_tcb->ExtPtr = p_ext;                                        // Save pointer to TCB extension
   \      0x19E   0x9816             LDR      R0,[SP, #+88]
   \      0x1A0   0x6060             STR      R0,[R4, #+4]
    340            p_tcb->StkBasePtr = p_stk_base;                               // Save pointer to the base address of the stack
   \      0x1A2   0x9811             LDR      R0,[SP, #+68]
   \      0x1A4   0x6160             STR      R0,[R4, #+20]
    341            p_tcb->StkSize = stk_size;                                    // Save the stack size (in number of CPU_STK elements)
   \      0x1A6   0x6326             STR      R6,[R4, #+48]
    342            p_tcb->Opt = opt;                                             // Save task options
   \      0x1A8   0xF8BD 0x005C      LDRH     R0,[SP, #+92]
   \      0x1AC   0x86A0             STRH     R0,[R4, #+52]
    343          
    344          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    345            for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
   \      0x1AE   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??OSTaskCreate_20: (+1)
   \      0x1B2   0x4640             MOV      R0,R8
   \      0x1B4   0xB2C0             UXTB     R0,R0
   \      0x1B6   0x2803             CMP      R0,#+3
   \      0x1B8   0xDA08             BGE.N    ??OSTaskCreate_21
    346              p_tcb->RegTbl[reg_nbr] = 0u;
   \      0x1BA   0x2000             MOVS     R0,#+0
   \      0x1BC   0x4641             MOV      R1,R8
   \      0x1BE   0xB2C9             UXTB     R1,R1
   \      0x1C0   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \      0x1C4   0x66C8             STR      R0,[R1, #+108]
    347            }
   \      0x1C6   0xF118 0x0801      ADDS     R8,R8,#+1
   \      0x1CA   0xE7F2             B.N      ??OSTaskCreate_20
    348          #endif
    349          
    350          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    351            OS_MsgQInit(&p_tcb->MsgQ,                                     // Initialize the task's message queue
    352                        q_size);
    353          #else
    354            (void)&q_size;
   \                     ??OSTaskCreate_21: (+1)
   \      0x1CC   0xA814             ADD      R0,SP,#+80
    355          #endif
    356          
    357            OSTaskCreateHook(p_tcb);                                      // Call user defined hook
   \      0x1CE   0x0020             MOVS     R0,R4
   \      0x1D0   0x.... 0x....      BL       OSTaskCreateHook
    358          
    359            OS_TRACE_TASK_CREATE(p_tcb);
    360            OS_TRACE_TASK_SEM_CREATE(p_tcb, p_name);
    361          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    362            OS_TRACE_TASK_MSG_Q_CREATE(&p_tcb->MsgQ, p_name);
    363          #endif
    364          
    365          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    366            for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
    367              p_tcb->TLS_Tbl[id] = 0u;
    368            }
    369            OS_TLS_TaskCreate(p_tcb);                                     // Call TLS hook
    370          #endif
    371            //                                                               -------------- ADD TASK TO READY LIST --------------
    372            CORE_ENTER_ATOMIC();
   \      0x1D4   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x1D8   0x4682             MOV      R10,R0
    373            OS_PrioInsert(p_tcb->Prio);
   \      0x1DA   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \      0x1DE   0x.... 0x....      BL       OS_PrioInsert
    374            OS_RdyListInsertTail(p_tcb);
   \      0x1E2   0x0020             MOVS     R0,R4
   \      0x1E4   0x.... 0x....      BL       OS_RdyListInsertTail
    375          
    376          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    377            OS_TaskDbgListAdd(p_tcb);
    378          #endif
    379          
    380            OSTaskQty++;                                                  // Increment the #tasks counter
   \      0x1E8   0x.... 0x....      LDR.W    R1,??DataTable11
   \      0x1EC   0x8808             LDRH     R0,[R1, #+0]
   \      0x1EE   0x1C40             ADDS     R0,R0,#+1
   \      0x1F0   0x8008             STRH     R0,[R1, #+0]
    381          
    382            if (OSRunning != OS_STATE_OS_RUNNING) {                       // Return if multitasking has not started
   \      0x1F2   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \      0x1F6   0x7800             LDRB     R0,[R0, #+0]
   \      0x1F8   0x2801             CMP      R0,#+1
   \      0x1FA   0xD003             BEQ.N    ??OSTaskCreate_22
    383              CORE_EXIT_ATOMIC();
   \      0x1FC   0x4650             MOV      R0,R10
   \      0x1FE   0x.... 0x....      BL       CORE_ExitAtomic
    384              return;
   \      0x202   0xE004             B.N      ??OSTaskCreate_23
    385            }
    386          
    387            CORE_EXIT_ATOMIC();
   \                     ??OSTaskCreate_22: (+1)
   \      0x204   0x4650             MOV      R0,R10
   \      0x206   0x.... 0x....      BL       CORE_ExitAtomic
    388          
    389            OSSched();
   \      0x20A   0x.... 0x....      BL       OSSched
    390          }
   \                     ??OSTaskCreate_23: (+1)
   \      0x20E   0xB007             ADD      SP,SP,#+28
   \      0x210   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    391          
    392          /****************************************************************************************************//**
    393           *                                               OSTaskDel()
    394           *
    395           * @brief    Allows you to delete a task. The calling task can delete itself by specifying a NULL
    396           *           pointer for 'p_tcb'. The deleted task is returned to the dormant state and can
    397           *           be re-activated by creating the deleted task again.
    398           *
    399           * @param    p_tcb   Pointer to the TCB of the task to delete.
    400           *
    401           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    402           *                   from this function:
    403           *                       - RTOS_ERR_NONE
    404           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    405           *                       - RTOS_ERR_INVALID_ARG
    406           *                       - RTOS_ERR_INVALID_STATE
    407           *                       - RTOS_ERR_NOT_READY
    408           *
    409           * @note     (1) 'p_err' is set to RTOS_ERR_NONE before OSSched() to allow the returned err or code
    410           *               to be monitored even for a task that is deleting itself. In this case, 'p_err' MUST
    411           *               point to a global variable that can be accessed by another task.
    412           *******************************************************************************************************/
    413          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    414          void OSTaskDel(OS_TCB   *p_tcb,
    415                         RTOS_ERR *p_err)
    416          {
   \                     OSTaskDel: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
    417          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    418            OS_TCB  *p_tcb_owner;
    419            OS_PRIO prio_new;
    420          #endif
    421          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    422            sl_status_t status;
    423          #endif
    424            CORE_DECLARE_IRQ_STATE;
    425          
    426            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD101             BNE.N    ??OSTaskDel_0
   \        0xC   0x.... 0x....      BL       CPU_SW_Exception
    427          
    428          #ifdef OS_SAFETY_CRITICAL_IEC61508
    429            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    430              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
    431              return;
    432            }
    433          #endif
    434          
    435            //                                                               Not allowed to call from an ISR
    436            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSTaskDel_0: (+1)
   \       0x10   0x.... 0x....      BL       CORE_InIrqContext
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??OSTaskDel_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??OSTaskDel_2
   \                     ??OSTaskDel_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??OSTaskDel_2: (+1)
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD10B             BNE.N    ??OSTaskDel_3
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0x7030             STRB     R0,[R6, #+0]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x2C   0x6070             STR      R0,[R6, #+4]
   \       0x2E   0xF44F 0x70DA      MOV      R0,#+436
   \       0x32   0x60B0             STR      R0,[R6, #+8]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x38   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSTaskDel_4: (+1)
   \       0x3A   0xE7FE             B.N      ??OSTaskDel_4
    437          
    438            //                                                               Make sure kernel is running.
    439            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSTaskDel_3: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \       0x40   0x7800             LDRB     R0,[R0, #+0]
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD00B             BEQ.N    ??OSTaskDel_5
    440              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0x7030             STRB     R0,[R6, #+0]
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x4E   0x6070             STR      R0,[R6, #+4]
   \       0x50   0xF44F 0x70DC      MOV      R0,#+440
   \       0x54   0x60B0             STR      R0,[R6, #+8]
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x5A   0x60F0             STR      R0,[R6, #+12]
    441              return;
   \       0x5C   0xE0C8             B.N      ??OSTaskDel_6
    442            }
    443          
    444            if (p_tcb == DEF_NULL) {                                      // Delete 'Self'?
   \                     ??OSTaskDel_5: (+1)
   \       0x5E   0x2D00             CMP      R5,#+0
   \       0x60   0xD109             BNE.N    ??OSTaskDel_7
    445              CORE_ENTER_ATOMIC();
   \       0x62   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x66   0x4682             MOV      R10,R0
    446              p_tcb = OSTCBCurPtr;                                        // Yes.
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \       0x6C   0x6800             LDR      R0,[R0, #+0]
   \       0x6E   0x0005             MOVS     R5,R0
    447              CORE_EXIT_ATOMIC();
   \       0x70   0x4650             MOV      R0,R10
   \       0x72   0x.... 0x....      BL       CORE_ExitAtomic
    448            }
    449          
    450            CORE_ENTER_ATOMIC();
   \                     ??OSTaskDel_7: (+1)
   \       0x76   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x7A   0x4680             MOV      R8,R0
    451            switch (p_tcb->TaskState) {
   \       0x7C   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD010             BEQ.N    ??OSTaskDel_8
   \       0x84   0x2801             CMP      R0,#+1
   \       0x86   0xD013             BEQ.N    ??OSTaskDel_9
   \       0x88   0x2802             CMP      R0,#+2
   \       0x8A   0xD01B             BEQ.N    ??OSTaskDel_10
   \       0x8C   0x2803             CMP      R0,#+3
   \       0x8E   0xD019             BEQ.N    ??OSTaskDel_10
   \       0x90   0x2804             CMP      R0,#+4
   \       0x92   0xD00C             BEQ.N    ??OSTaskDel_11
   \       0x94   0x2805             CMP      R0,#+5
   \       0x96   0xD00B             BEQ.N    ??OSTaskDel_9
   \       0x98   0x2806             CMP      R0,#+6
   \       0x9A   0xD013             BEQ.N    ??OSTaskDel_10
   \       0x9C   0x2807             CMP      R0,#+7
   \       0x9E   0xD011             BEQ.N    ??OSTaskDel_10
   \       0xA0   0x28FF             CMP      R0,#+255
   \       0xA2   0xD06C             BEQ.N    ??OSTaskDel_12
   \       0xA4   0xE07A             B.N      ??OSTaskDel_13
    452              case OS_TASK_STATE_RDY:
    453                OS_RdyListRemove(p_tcb);
   \                     ??OSTaskDel_8: (+1)
   \       0xA6   0x0028             MOVS     R0,R5
   \       0xA8   0x.... 0x....      BL       OS_RdyListRemove
    454                break;
   \       0xAC   0xE07C             B.N      ??OSTaskDel_14
    455          
    456              case OS_TASK_STATE_SUSPENDED:
    457                break;
   \                     ??OSTaskDel_11: (+1)
   \       0xAE   0xE07B             B.N      ??OSTaskDel_14
    458          
    459              case OS_TASK_STATE_DLY:                                     // Task is only delayed, not on any wait list
    460              case OS_TASK_STATE_DLY_SUSPENDED:
    461          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    462                status = sl_sleeptimer_stop_timer(&p_tcb->TimerHandle);
   \                     ??OSTaskDel_9: (+1)
   \       0xB0   0xF115 0x0044      ADDS     R0,R5,#+68
   \       0xB4   0x.... 0x....      BL       sl_sleeptimer_stop_timer
   \       0xB8   0x0004             MOVS     R4,R0
    463                RTOS_ASSERT_CRITICAL((status == SL_STATUS_OK), RTOS_ERR_FAIL,; );
   \       0xBA   0x2C00             CMP      R4,#+0
   \       0xBC   0xD001             BEQ.N    ??OSTaskDel_15
   \       0xBE   0x.... 0x....      BL       CPU_SW_Exception
    464          #endif
    465                break;
   \                     ??OSTaskDel_15: (+1)
   \       0xC2   0xE071             B.N      ??OSTaskDel_14
    466          
    467              case OS_TASK_STATE_PEND:
    468              case OS_TASK_STATE_PEND_SUSPENDED:
    469              case OS_TASK_STATE_PEND_TIMEOUT:
    470              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    471                switch (p_tcb->PendOn) {                                  // See what we are pending on
   \                     ??OSTaskDel_10: (+1)
   \       0xC4   0xF895 0x0024      LDRB     R0,[R5, #+36]
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD00E             BEQ.N    ??OSTaskDel_16
   \       0xCC   0x2801             CMP      R0,#+1
   \       0xCE   0xD00D             BEQ.N    ??OSTaskDel_17
   \       0xD0   0x2802             CMP      R0,#+2
   \       0xD2   0xD00A             BEQ.N    ??OSTaskDel_16
   \       0xD4   0x2804             CMP      R0,#+4
   \       0xD6   0xD00D             BEQ.N    ??OSTaskDel_18
   \       0xD8   0x2805             CMP      R0,#+5
   \       0xDA   0xD007             BEQ.N    ??OSTaskDel_17
   \       0xDC   0x2806             CMP      R0,#+6
   \       0xDE   0xD005             BEQ.N    ??OSTaskDel_17
   \       0xE0   0x2807             CMP      R0,#+7
   \       0xE2   0xD002             BEQ.N    ??OSTaskDel_16
   \       0xE4   0x2808             CMP      R0,#+8
   \       0xE6   0xD001             BEQ.N    ??OSTaskDel_17
   \       0xE8   0xE035             B.N      ??OSTaskDel_19
    472                  case OS_TASK_PEND_ON_NOTHING:
    473                  case OS_TASK_PEND_ON_TASK_Q:                            // There is no wait list for these two
    474                  case OS_TASK_PEND_ON_TASK_SEM:
    475                    break;
   \                     ??OSTaskDel_16: (+1)
   \       0xEA   0xE036             B.N      ??OSTaskDel_20
    476          
    477                  case OS_TASK_PEND_ON_FLAG:                              // Remove from pend list
    478                  case OS_TASK_PEND_ON_Q:
    479                  case OS_TASK_PEND_ON_SEM:
    480                  case OS_TASK_PEND_ON_COND_VAR:
    481                    OS_PendListRemove(p_tcb);
   \                     ??OSTaskDel_17: (+1)
   \       0xEC   0x0028             MOVS     R0,R5
   \       0xEE   0x.... 0x....      BL       OS_PendListRemove
    482                    break;
   \       0xF2   0xE032             B.N      ??OSTaskDel_20
    483          
    484          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    485                  case OS_TASK_PEND_ON_MUTEX:
    486                    p_tcb_owner = ((OS_MUTEX *)p_tcb->PendObjPtr)->OwnerTCBPtr;
   \                     ??OSTaskDel_18: (+1)
   \       0xF4   0x6A28             LDR      R0,[R5, #+32]
   \       0xF6   0x6900             LDR      R0,[R0, #+16]
   \       0xF8   0x4681             MOV      R9,R0
    487                    prio_new = p_tcb_owner->Prio;
   \       0xFA   0xF899 0x0027      LDRB     R0,[R9, #+39]
   \       0xFE   0x0007             MOVS     R7,R0
    488                    OS_PendListRemove(p_tcb);
   \      0x100   0x0028             MOVS     R0,R5
   \      0x102   0x.... 0x....      BL       OS_PendListRemove
    489                    if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio)
    490                        && (p_tcb_owner->Prio == p_tcb->Prio)) {          // Has the owner inherited a priority?
   \      0x106   0xF899 0x1027      LDRB     R1,[R9, #+39]
   \      0x10A   0xF899 0x0028      LDRB     R0,[R9, #+40]
   \      0x10E   0x4281             CMP      R1,R0
   \      0x110   0xD012             BEQ.N    ??OSTaskDel_21
   \      0x112   0xF899 0x0027      LDRB     R0,[R9, #+39]
   \      0x116   0xF895 0x1027      LDRB     R1,[R5, #+39]
   \      0x11A   0x4288             CMP      R0,R1
   \      0x11C   0xD10C             BNE.N    ??OSTaskDel_21
    491                      prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \      0x11E   0x4648             MOV      R0,R9
   \      0x120   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
    492                      prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
   \      0x124   0xF899 0x2028      LDRB     R2,[R9, #+40]
   \      0x128   0x0001             MOVS     R1,R0
   \      0x12A   0xB2C9             UXTB     R1,R1
   \      0x12C   0x428A             CMP      R2,R1
   \      0x12E   0xD202             BCS.N    ??OSTaskDel_22
   \      0x130   0xF899 0x7028      LDRB     R7,[R9, #+40]
   \      0x134   0xE000             B.N      ??OSTaskDel_21
   \                     ??OSTaskDel_22: (+1)
   \      0x136   0x0007             MOVS     R7,R0
    493                    }
    494                    p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;
   \                     ??OSTaskDel_21: (+1)
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0xF885 0x0024      STRB     R0,[R5, #+36]
    495          
    496                    if (prio_new != p_tcb_owner->Prio) {
   \      0x13E   0x0039             MOVS     R1,R7
   \      0x140   0xF899 0x0027      LDRB     R0,[R9, #+39]
   \      0x144   0xB2C9             UXTB     R1,R1
   \      0x146   0x4281             CMP      R1,R0
   \      0x148   0xD004             BEQ.N    ??OSTaskDel_23
    497                      OS_TaskChangePrio(p_tcb_owner, prio_new);
   \      0x14A   0x0039             MOVS     R1,R7
   \      0x14C   0xB2C9             UXTB     R1,R1
   \      0x14E   0x4648             MOV      R0,R9
   \      0x150   0x.... 0x....      BL       OS_TaskChangePrio
    498                      OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    499                    }
    500                    break;
   \                     ??OSTaskDel_23: (+1)
   \      0x154   0xE001             B.N      ??OSTaskDel_20
    501          #endif
    502          
    503                  default:
    504                    RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \                     ??OSTaskDel_19: (+1)
   \      0x156   0x.... 0x....      BL       CPU_SW_Exception
    505                    break;
    506                }
    507          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    508                if ((p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT)
    509                    || (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED)) {
   \                     ??OSTaskDel_20: (+1)
   \      0x15A   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \      0x15E   0x2803             CMP      R0,#+3
   \      0x160   0xD003             BEQ.N    ??OSTaskDel_24
   \      0x162   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \      0x166   0x2807             CMP      R0,#+7
   \      0x168   0xD108             BNE.N    ??OSTaskDel_25
    510                  status = sl_sleeptimer_stop_timer(&p_tcb->TimerHandle);
   \                     ??OSTaskDel_24: (+1)
   \      0x16A   0xF115 0x0044      ADDS     R0,R5,#+68
   \      0x16E   0x.... 0x....      BL       sl_sleeptimer_stop_timer
   \      0x172   0x0004             MOVS     R4,R0
    511                  RTOS_ASSERT_CRITICAL((status == SL_STATUS_OK), RTOS_ERR_FAIL,; );
   \      0x174   0x2C00             CMP      R4,#+0
   \      0x176   0xD001             BEQ.N    ??OSTaskDel_25
   \      0x178   0x.... 0x....      BL       CPU_SW_Exception
    512                }
    513          #endif
    514                break;
   \                     ??OSTaskDel_25: (+1)
   \      0x17C   0xE014             B.N      ??OSTaskDel_14
    515          
    516              case OS_TASK_STATE_DEL:
    517          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
    518                CORE_EXIT_ATOMIC();
   \                     ??OSTaskDel_12: (+1)
   \      0x17E   0x4640             MOV      R0,R8
   \      0x180   0x.... 0x....      BL       CORE_ExitAtomic
    519                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
   \      0x184   0x201F             MOVS     R0,#+31
   \      0x186   0x7030             STRB     R0,[R6, #+0]
   \      0x188   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0x18C   0x6070             STR      R0,[R6, #+4]
   \      0x18E   0xF240 0x2007      MOVW     R0,#+519
   \      0x192   0x60B0             STR      R0,[R6, #+8]
   \      0x194   0x.... 0x....      LDR.W    R0,??DataTable13
   \      0x198   0x60F0             STR      R0,[R6, #+12]
    520                return;
   \      0x19A   0xE029             B.N      ??OSTaskDel_6
    521                break;                                                    // The break helps avoid fall-through false errors
    522          #endif
    523          
    524              default:
    525                CORE_EXIT_ATOMIC();
   \                     ??OSTaskDel_13: (+1)
   \      0x19C   0x4640             MOV      R0,R8
   \      0x19E   0x.... 0x....      BL       CORE_ExitAtomic
    526                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
   \      0x1A2   0x.... 0x....      BL       CPU_SW_Exception
    527                return;
   \      0x1A6   0xE023             B.N      ??OSTaskDel_6
    528            }
    529          
    530          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    531            if (p_tcb->MutexGrpHeadPtr != DEF_NULL) {
   \                     ??OSTaskDel_14: (+1)
   \      0x1A8   0x6AE8             LDR      R0,[R5, #+44]
   \      0x1AA   0x2800             CMP      R0,#+0
   \      0x1AC   0xD002             BEQ.N    ??OSTaskDel_26
    532              OS_MutexGrpPostAll(p_tcb);
   \      0x1AE   0x0028             MOVS     R0,R5
   \      0x1B0   0x.... 0x....      BL       OS_MutexGrpPostAll
    533            }
    534          #endif
    535          
    536          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    537            (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                           // Free task's message queue messages
    538          #endif
    539          
    540            OSTaskDelHook(p_tcb);                                         // Call user defined hook
   \                     ??OSTaskDel_26: (+1)
   \      0x1B4   0x0028             MOVS     R0,R5
   \      0x1B6   0x.... 0x....      BL       OSTaskDelHook
    541          
    542          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    543            OS_TLS_TaskDel(p_tcb);                                        // Call TLS hook
    544          #endif
    545          
    546          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    547            OS_TaskDbgListRemove(p_tcb);
    548          #endif
    549          
    550            OSTaskQty--;                                                  // One less task being managed
   \      0x1BA   0x.... 0x....      LDR.W    R0,??DataTable11
   \      0x1BE   0x8801             LDRH     R1,[R0, #+0]
   \      0x1C0   0x1E49             SUBS     R1,R1,#+1
   \      0x1C2   0x8001             STRH     R1,[R0, #+0]
    551          
    552            OS_TRACE_TASK_DEL(p_tcb);
    553          
    554          #if (OS_CFG_TASK_STK_REDZONE_EN != DEF_ENABLED)                 // Don't clear the TCB before checking the red-zone
    555            OS_TaskInitTCB(p_tcb);                                        // Initialize the TCB to default values
   \      0x1C4   0x0028             MOVS     R0,R5
   \      0x1C6   0x.... 0x....      BL       OS_TaskInitTCB
    556          #endif
    557            p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;               // Indicate that the task was deleted
   \      0x1CA   0x20FF             MOVS     R0,#+255
   \      0x1CC   0xF885 0x0026      STRB     R0,[R5, #+38]
    558          
    559            CORE_EXIT_ATOMIC();
   \      0x1D0   0x4640             MOV      R0,R8
   \      0x1D2   0x.... 0x....      BL       CORE_ExitAtomic
    560          
    561            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);                          // See Note #1.
   \      0x1D6   0x2000             MOVS     R0,#+0
   \      0x1D8   0x7030             STRB     R0,[R6, #+0]
   \      0x1DA   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0x1DE   0x6070             STR      R0,[R6, #+4]
   \      0x1E0   0xF240 0x2031      MOVW     R0,#+561
   \      0x1E4   0x60B0             STR      R0,[R6, #+8]
   \      0x1E6   0x.... 0x....      LDR.W    R0,??DataTable13
   \      0x1EA   0x60F0             STR      R0,[R6, #+12]
    562          
    563            OSSched();                                                    // Find new highest priority task
   \      0x1EC   0x.... 0x....      BL       OSSched
    564          }
   \                     ??OSTaskDel_6: (+1)
   \      0x1F0   0xE8BD 0x87F0      POP      {R4-R10,PC}
    565          #endif
    566          
    567          /****************************************************************************************************//**
    568           *                                               OSTaskQFlush()
    569           *
    570           * @brief    Flushes the task's internal message queue.
    571           *
    572           * @param    p_tcb   Pointer to the task's TCB. Specifying a NULL pointer indicates that
    573           *                   you wish to flush the message queue of the calling task.
    574           *
    575           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    576           *                   from this function:
    577           *                       - RTOS_ERR_NONE
    578           *                       - RTOS_ERR_NOT_READY
    579           *
    580           * @return   The number of entries freed from the queue.
    581           *
    582           * @note     (1) Use this function with great care. When you flush the queue, you lose the references
    583           *               to what the queue entries are pointing, which can cause 'memory leaks'.
    584           *               In other words, the data being pointed to that is referenced by the queue entries
    585           *               should, most likely, need to be de-allocated (i.e. freed).
    586           *******************************************************************************************************/
    587          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    588          OS_MSG_QTY OSTaskQFlush(OS_TCB   *p_tcb,
    589                                  RTOS_ERR *p_err)
    590          {
    591            OS_MSG_QTY entries;
    592            CORE_DECLARE_IRQ_STATE;
    593          
    594            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
    595          
    596            //                                                               Not allowed to call from an ISR
    597            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
    598          
    599            //                                                               Make sure kernel is running.
    600            if (OSRunning != OS_STATE_OS_RUNNING) {
    601              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    602              return (0u);
    603            }
    604          
    605            if (p_tcb == DEF_NULL) {                                      // Flush message queue of calling task?
    606              CORE_ENTER_ATOMIC();
    607              p_tcb = OSTCBCurPtr;
    608              CORE_EXIT_ATOMIC();
    609            }
    610          
    611            CORE_ENTER_ATOMIC();
    612            entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                       // Return all OS_MSGs to the OS_MSG pool
    613            CORE_EXIT_ATOMIC();
    614            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    615            return (entries);
    616          }
    617          #endif
    618          
    619          /****************************************************************************************************//**
    620           *                                               OSTaskQPend()
    621           *
    622           * @brief    This function causes the current task to wait for a message to be posted to it.
    623           *
    624           * @param    timeout     Optional timeout period (in clock ticks). If non-zero, your task will
    625           *                       wait for a message to arrive up to the amount of time specified by this
    626           *                       argument. If you specify 0, your task will wait forever, or until a
    627           *                       message arrives.
    628           *
    629           * @param    opt         Determines if the user wants to block if the task's queue is empty or
    630           *                       not:
    631           *                           - OS_OPT_PEND_BLOCKING        Task will     block.
    632           *                           - OS_OPT_PEND_NON_BLOCKING    Task will NOT block.
    633           *
    634           * @param    p_msg_size  Pointer to a variable that will receive the size of the message.
    635           *
    636           * @param    p_ts        Pointer to a variable that will receive the timestamp of when the
    637           *                       message was received. If you pass a NULL pointer (i.e. (CPU_TS *)0), you
    638           *                       will not get the timestamp. In other words, passing a NULL pointer is valid
    639           *                       and indicates that you don't need the timestamp.
    640           *
    641           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
    642           *                       from this function:
    643           *                           - RTOS_ERR_NONE
    644           *                           - RTOS_ERR_NOT_FOUND
    645           *                           - RTOS_ERR_WOULD_BLOCK
    646           *                           - RTOS_ERR_OS_SCHED_LOCKED
    647           *                           - RTOS_ERR_ABORT
    648           *                           - RTOS_ERR_TIMEOUT
    649           *                           - RTOS_ERR_NOT_READY
    650           *
    651           * @return   A pointer to the message received or a NULL pointer upon error.
    652           *******************************************************************************************************/
    653          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    654          void *OSTaskQPend(OS_TICK     timeout,
    655                            OS_OPT      opt,
    656                            OS_MSG_SIZE *p_msg_size,
    657                            CPU_TS      *p_ts,
    658                            RTOS_ERR    *p_err)
    659          {
    660            OS_MSG_Q *p_msg_q;
    661            void     *p_void;
    662            CORE_DECLARE_IRQ_STATE;
    663          
    664            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_NULL);
    665          
    666            OS_TRACE_TASK_MSG_Q_PEND_ENTER(&OSTCBCurPtr->MsgQ, timeout, opt, p_msg_size, p_ts);
    667          
    668            //                                                               Not allowed to call from an ISR
    669            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, DEF_NULL);
    670          
    671            //                                                               User must supply a valid destination for msg size
    672            OS_ASSERT_DBG_ERR_SET((p_msg_size != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, DEF_NULL);
    673          
    674            //                                                               Validate 'opt'
    675            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_PEND_BLOCKING)
    676                                   || (opt == OS_OPT_PEND_NON_BLOCKING)), *p_err, RTOS_ERR_INVALID_ARG, DEF_NULL);
    677          
    678            //                                                               Make sure kernel is running.
    679            if (OSRunning != OS_STATE_OS_RUNNING) {
    680              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    681              return (DEF_NULL);
    682            }
    683          
    684            if (p_ts != DEF_NULL) {
    685              *p_ts = 0u;                                                 // Initialize the returned timestamp
    686            }
    687          
    688            CORE_ENTER_ATOMIC();
    689            p_msg_q = &OSTCBCurPtr->MsgQ;                                 // Any message waiting in the message queue?
    690            p_void = OS_MsgQGet(p_msg_q,
    691                                p_msg_size,
    692                                p_ts,
    693                                p_err);
    694            if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {
    695          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
    696          #if (OS_CFG_TS_EN == DEF_ENABLED)
    697              if (p_ts != DEF_NULL) {
    698                OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
    699                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
    700                  OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
    701                }
    702              }
    703          #endif
    704          #endif
    705              CORE_EXIT_ATOMIC();
    706              OS_TRACE_TASK_MSG_Q_PEND(p_msg_q);
    707              OS_TRACE_TASK_MSG_Q_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    708              return (p_void);                                            // Yes, Return oldest message received
    709            }
    710          
    711            if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {                 // Caller wants to block if not available?
    712              RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);                 // No
    713              CORE_EXIT_ATOMIC();
    714              OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    715              OS_TRACE_TASK_MSG_Q_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    716              return (DEF_NULL);
    717            } else {                                                      // Yes
    718              if (OSSchedLockNestingCtr > 0u) {                           // Can't block when the scheduler is locked
    719                CORE_EXIT_ATOMIC();
    720                RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
    721                OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    722                OS_TRACE_TASK_MSG_Q_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    723                return (DEF_NULL);
    724              }
    725            }
    726          
    727            OS_Pend(DEF_NULL,                                             // Block task pending on Message
    728                    OS_TASK_PEND_ON_TASK_Q,
    729                    timeout);
    730            CORE_EXIT_ATOMIC();
    731            OS_TRACE_TASK_MSG_Q_PEND_BLOCK(p_msg_q);
    732            OSSched();                                                    // Find the next highest priority task ready to run
    733          
    734            CORE_ENTER_ATOMIC();
    735            switch (OSTCBCurPtr->PendStatus) {
    736              case OS_STATUS_PEND_OK:                                     // Extract message from TCB (Put there by Post)
    737                p_void = OSTCBCurPtr->MsgPtr;
    738                *p_msg_size = OSTCBCurPtr->MsgSize;
    739          #if (OS_CFG_TS_EN == DEF_ENABLED)
    740                if (p_ts != DEF_NULL) {
    741                  *p_ts = OSTCBCurPtr->TS;
    742          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
    743                  OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
    744                  if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
    745                    OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
    746                  }
    747          #endif
    748                }
    749          #endif
    750                OS_TRACE_TASK_MSG_Q_PEND(p_msg_q);
    751                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    752                break;
    753          
    754              case OS_STATUS_PEND_ABORT:                                  // Indicate that we aborted
    755                p_void = DEF_NULL;
    756                *p_msg_size = 0u;
    757                if (p_ts != DEF_NULL) {
    758                  *p_ts = 0u;
    759                }
    760                OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    761                RTOS_ERR_SET(*p_err, RTOS_ERR_ABORT);
    762                break;
    763          
    764              case OS_STATUS_PEND_TIMEOUT:                                // Indicate that we didn't get event within TO
    765                p_void = DEF_NULL;
    766                *p_msg_size = 0u;
    767          #if (OS_CFG_TS_EN == DEF_ENABLED)
    768                if (p_ts != DEF_NULL) {
    769                  *p_ts = OSTCBCurPtr->TS;
    770                }
    771          #endif
    772                OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    773                RTOS_ERR_SET(*p_err, RTOS_ERR_TIMEOUT);
    774                break;
    775          
    776              case OS_STATUS_PEND_DEL:
    777              default:
    778                OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    779                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, DEF_NULL);
    780            }
    781            CORE_EXIT_ATOMIC();
    782            OS_TRACE_TASK_MSG_Q_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    783            return (p_void);                                              // Return received message
    784          }
    785          #endif
    786          
    787          /****************************************************************************************************//**
    788           *                                           OSTaskQPendAbort()
    789           *
    790           * @brief    Aborts and readies the task specified. Use this function to fault-abort the wait for a
    791           *           message, rather than to normally post the message to the task via OSTaskQPost().
    792           *
    793           * @param    p_tcb   Pointer to the TCB of the task to pend abort.
    794           *
    795           * @param    opt     Provides options for this function:
    796           *                       - OS_OPT_POST_NONE        No option specified.
    797           *                       - OS_OPT_POST_NO_SCHED    Indicates that the scheduler will not be called.
    798           *
    799           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    800           *                   from this function:
    801           *                       - RTOS_ERR_NONE
    802           *                       - RTOS_ERR_NONE_WAITING
    803           *                       - RTOS_ERR_NOT_READY
    804           *
    805           * @return   == DEF_FALSE    If task was not waiting for a message, or upon error.
    806           *           == DEF_TRUE     If task was waiting for a message and was readied and informed.
    807           *******************************************************************************************************/
    808          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    809          CPU_BOOLEAN OSTaskQPendAbort(OS_TCB   *p_tcb,
    810                                       OS_OPT   opt,
    811                                       RTOS_ERR *p_err)
    812          {
    813            CPU_TS ts;
    814            CORE_DECLARE_IRQ_STATE;
    815          
    816            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FALSE);
    817          
    818            //                                                               Not allowed to call from an ISR
    819            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, DEF_FALSE);
    820          
    821            //                                                               Validate 'opt'
    822            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_POST_NONE)
    823                                   || (opt == OS_OPT_POST_NO_SCHED)), *p_err, RTOS_ERR_INVALID_ARG, DEF_FALSE);
    824          
    825            //                                                               Make sure kernel is running.
    826            if (OSRunning != OS_STATE_OS_RUNNING) {
    827              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    828              return (DEF_FALSE);
    829            }
    830          
    831            CORE_ENTER_ATOMIC();
    832          #if (OS_ARG_CHK_EN == DEF_ENABLED)
    833            if ((p_tcb == DEF_NULL)                                       // Pend abort self?
    834                || (p_tcb == OSTCBCurPtr)) {
    835              CORE_EXIT_ATOMIC();                                         // ... doesn't make sense
    836              OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_INVALID_ARG, DEF_FALSE);
    837            }
    838          #endif
    839          
    840            if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {                // Is task waiting for a message?
    841              CORE_EXIT_ATOMIC();                                         // No
    842              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE_WAITING);
    843              return (DEF_FALSE);
    844            }
    845          
    846          #if (OS_CFG_TS_EN == DEF_ENABLED)
    847            ts = OS_TS_GET();                                             // Get timestamp of when the abort occurred
    848          #else
    849            ts = 0u;
    850          #endif
    851            OS_PendAbort(p_tcb,                                           // Abort the pend
    852                         ts,
    853                         OS_STATUS_PEND_ABORT);
    854            CORE_EXIT_ATOMIC();
    855            if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
    856              OSSched();                                                  // Run the scheduler
    857            }
    858            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    859            return (DEF_TRUE);
    860          }
    861          #endif
    862          
    863          /****************************************************************************************************//**
    864           *                                               OSTaskQPost()
    865           *
    866           * @brief    Sends a message to a task.
    867           *
    868           * @param    p_tcb       Pointer to the TCB of the task receiving a message. If you specify a NULL
    869           *                       pointer, the message will be posted to the task's queue of the calling task.
    870           *                       In other words, you'd be posting a message to yourself.
    871           *
    872           * @param    p_void      Pointer to the message to send.
    873           *
    874           * @param    msg_size    The size of the message sent (in bytes).
    875           *
    876           * @param    opt         Specifies whether the post will be FIFO or LIFO:
    877           *                           - OS_OPT_POST_FIFO        Post at the end   of the queue.
    878           *                           - OS_OPT_POST_LIFO        Post at the front of the queue.
    879           *                           - OS_OPT_POST_NO_SCHED    Do not run the scheduler after the post.
    880           *
    881           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
    882           *                       from this function:
    883           *                           - RTOS_ERR_NONE
    884           *                           - RTOS_ERR_WOULD_OVF
    885           *                           - RTOS_ERR_NO_MORE_RSRC
    886           *                           - RTOS_ERR_INVALID_STATE
    887           *                           - RTOS_ERR_NOT_READY
    888           *
    889           * @note     (1) OS_OPT_POST_NO_SCHED can be OR'ed with one of the other two options to prevent the
    890           *               scheduler from being called.
    891           *
    892           * @note     (2) This function may be called from an ISR.
    893           *******************************************************************************************************/
    894          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    895          void OSTaskQPost(OS_TCB      *p_tcb,
    896                           void        *p_void,
    897                           OS_MSG_SIZE msg_size,
    898                           OS_OPT      opt,
    899                           RTOS_ERR    *p_err)
    900          {
    901            CPU_TS ts;
    902            CORE_DECLARE_IRQ_STATE;
    903          
    904            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
    905          
    906            OS_TRACE_TASK_MSG_Q_POST_ENTER(&p_tcb->MsgQ, p_void, msg_size, opt);
    907          
    908            //                                                               Validate 'opt'
    909            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_POST_FIFO)
    910                                   || (opt == OS_OPT_POST_LIFO)
    911                                   || (opt == (OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED))
    912                                   || (opt == (OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED))), *p_err, RTOS_ERR_INVALID_ARG,; );
    913          
    914            //                                                               Make sure kernel is running.
    915            if (OSRunning != OS_STATE_OS_RUNNING) {
    916              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    917              return;
    918            }
    919          
    920          #if (OS_CFG_TS_EN == DEF_ENABLED)
    921            ts = OS_TS_GET();                                             // Get timestamp
    922          #else
    923            ts = 0u;
    924          #endif
    925          
    926            OS_TRACE_TASK_MSG_Q_POST(&p_tcb->MsgQ);
    927          
    928            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);                          // Assume we won't have any errors
    929            CORE_ENTER_ATOMIC();
    930            if (p_tcb == DEF_NULL) {                                      // Post msg to 'self'?
    931              p_tcb = OSTCBCurPtr;
    932            }
    933            switch (p_tcb->TaskState) {
    934              case OS_TASK_STATE_RDY:
    935              case OS_TASK_STATE_DLY:
    936              case OS_TASK_STATE_SUSPENDED:
    937              case OS_TASK_STATE_DLY_SUSPENDED:
    938                OS_MsgQPut(&p_tcb->MsgQ,                                  // Deposit the message in the queue
    939                           p_void,
    940                           msg_size,
    941                           opt,
    942                           ts,
    943                           p_err);
    944                CORE_EXIT_ATOMIC();
    945                break;
    946          
    947              case OS_TASK_STATE_PEND:
    948              case OS_TASK_STATE_PEND_TIMEOUT:
    949              case OS_TASK_STATE_PEND_SUSPENDED:
    950              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    951                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) {            // Is task waiting for a message to be sent to it?
    952                  OS_Post(DEF_NULL,
    953                          p_tcb,
    954                          p_void,
    955                          msg_size,
    956                          ts);
    957                  CORE_EXIT_ATOMIC();
    958                  if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
    959                    OSSched();                                            // Run the scheduler
    960                  }
    961                } else {
    962                  OS_MsgQPut(&p_tcb->MsgQ,                                // No,  Task is pending on something else ...
    963                             p_void,                                      // ... Deposit the message in the task's queue
    964                             msg_size,
    965                             opt,
    966                             ts,
    967                             p_err);
    968                  CORE_EXIT_ATOMIC();
    969                  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    970                    OS_TRACE_TASK_MSG_Q_POST_FAILED(&p_tcb->MsgQ);
    971                  }
    972                }
    973                break;
    974          
    975              case OS_TASK_STATE_DEL:
    976          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
    977                CORE_EXIT_ATOMIC();
    978                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
    979                OS_TRACE_TASK_MSG_Q_POST_FAILED(&p_tcb->MsgQ);
    980                break;
    981          #endif
    982          
    983              default:
    984                CORE_EXIT_ATOMIC();
    985                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
    986            }
    987          
    988            OS_TRACE_TASK_MSG_Q_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
    989          }
    990          #endif
    991          
    992          /****************************************************************************************************//**
    993           *                                               OSTaskRegGet()
    994           *
    995           * @brief    Obtains the current value of a task register. Task registers are application specific
    996           *           and can be used to store task specific values such as 'error numbers' (i.e. errno),
    997           *           statistics, etc.
    998           *
    999           * @param    p_tcb   Pointer to the TCB of the task from which you want to read the register.
   1000           *                   If 'p_tcb' is a NULL pointer, you will get the register of the current task.
   1001           *
   1002           * @param    id      The 'id' of the desired task variable. Note that the 'id' must be less than
   1003           *                   OS_CFG_TASK_REG_TBL_SIZE.
   1004           *
   1005           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1006           *                   from this function:
   1007           *                       - RTOS_ERR_NONE
   1008           *
   1009           * @return   The current value of the task's register, or 0 if an error is detected.
   1010           *******************************************************************************************************/
   1011          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1012          OS_REG OSTaskRegGet(OS_TCB    *p_tcb,
   1013                              OS_REG_ID id,
   1014                              RTOS_ERR  *p_err)
   1015          {
   \                     OSTaskRegGet: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0015             MOVS     R5,R2
   1016            OS_REG value;
   1017            CORE_DECLARE_IRQ_STATE;
   1018          
   1019            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSTaskRegGet_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
   1020          
   1021            OS_ASSERT_DBG_ERR_SET((id < OS_CFG_TASK_REG_TBL_SIZE), *p_err, RTOS_ERR_INVALID_ARG, 0u);
   \                     ??OSTaskRegGet_0: (+1)
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2803             CMP      R0,#+3
   \       0x18   0xDB0B             BLT.N    ??OSTaskRegGet_1
   \       0x1A   0x2008             MOVS     R0,#+8
   \       0x1C   0x7028             STRB     R0,[R5, #+0]
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x22   0x6068             STR      R0,[R5, #+4]
   \       0x24   0xF240 0x30FD      MOVW     R0,#+1021
   \       0x28   0x60A8             STR      R0,[R5, #+8]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable15
   \       0x2E   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskRegGet_2: (+1)
   \       0x30   0xE7FE             B.N      ??OSTaskRegGet_2
   1022          
   1023            CORE_ENTER_ATOMIC();
   \                     ??OSTaskRegGet_1: (+1)
   \       0x32   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x36   0x0007             MOVS     R7,R0
   1024            if (p_tcb == DEF_NULL) {
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD103             BNE.N    ??OSTaskRegGet_3
   1025              p_tcb = OSTCBCurPtr;
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x0004             MOVS     R4,R0
   1026            }
   1027            value = p_tcb->RegTbl[id];
   \                     ??OSTaskRegGet_3: (+1)
   \       0x44   0x0030             MOVS     R0,R6
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \       0x4C   0xF8D0 0x806C      LDR      R8,[R0, #+108]
   1028            CORE_EXIT_ATOMIC();
   \       0x50   0x0038             MOVS     R0,R7
   \       0x52   0x.... 0x....      BL       CORE_ExitAtomic
   1029            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x7028             STRB     R0,[R5, #+0]
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x5E   0x6068             STR      R0,[R5, #+4]
   \       0x60   0xF240 0x4005      MOVW     R0,#+1029
   \       0x64   0x60A8             STR      R0,[R5, #+8]
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable15
   \       0x6A   0x60E8             STR      R0,[R5, #+12]
   1030            return (value);
   \       0x6C   0x4640             MOV      R0,R8
   \       0x6E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1031          }
   1032          #endif
   1033          
   1034          /****************************************************************************************************//**
   1035           *                                               OSTaskRegGetID()
   1036           *
   1037           * @brief    This function obtains a task register ID. This function allows task register IDs
   1038           *           to be allocated dynamically instead of statically.
   1039           *
   1040           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1041           *                   from this function:
   1042           *                       - RTOS_ERR_NONE
   1043           *                       - RTOS_ERR_NO_MORE_RSRC
   1044           *
   1045           * @return   The next available task register 'id' or OS_CFG_TASK_REG_TBL_SIZE if an error is detected.
   1046           *******************************************************************************************************/
   1047          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1048          OS_REG_ID OSTaskRegGetID(RTOS_ERR *p_err)
   1049          {
   \                     OSTaskRegGetID: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1050            OS_REG_ID id;
   1051            CORE_DECLARE_IRQ_STATE;
   1052          
   1053            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, OS_CFG_TASK_REG_TBL_SIZE);
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??OSTaskRegGetID_0
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
   1054          
   1055            CORE_ENTER_ATOMIC();
   \                     ??OSTaskRegGetID_0: (+1)
   \        0xC   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x10   0x0005             MOVS     R5,R0
   1056            if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       // See if we exceeded the number of IDs available
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x16   0x7801             LDRB     R1,[R0, #+0]
   \       0x18   0x2903             CMP      R1,#+3
   \       0x1A   0xDB0F             BLT.N    ??OSTaskRegGetID_1
   1057              CORE_EXIT_ATOMIC();                                         // Yes, cannot allocate more task register IDs
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0x.... 0x....      BL       CORE_ExitAtomic
   1058              RTOS_ERR_SET(*p_err, RTOS_ERR_NO_MORE_RSRC);
   \       0x22   0x2011             MOVS     R0,#+17
   \       0x24   0x7020             STRB     R0,[R4, #+0]
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x2A   0x6060             STR      R0,[R4, #+4]
   \       0x2C   0xF240 0x4022      MOVW     R0,#+1058
   \       0x30   0x60A0             STR      R0,[R4, #+8]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \       0x36   0x60E0             STR      R0,[R4, #+12]
   1059              return (OS_CFG_TASK_REG_TBL_SIZE);
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0xE013             B.N      ??OSTaskRegGetID_2
   1060            }
   1061          
   1062            id = OSTaskRegNextAvailID;                                    // Assign the next available ID
   \                     ??OSTaskRegGetID_1: (+1)
   \       0x3C   0x7806             LDRB     R6,[R0, #+0]
   1063            OSTaskRegNextAvailID++;                                       // Increment available ID for next request
   \       0x3E   0x7801             LDRB     R1,[R0, #+0]
   \       0x40   0x1C49             ADDS     R1,R1,#+1
   \       0x42   0x7001             STRB     R1,[R0, #+0]
   1064            CORE_EXIT_ATOMIC();
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0x.... 0x....      BL       CORE_ExitAtomic
   1065            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x7020             STRB     R0,[R4, #+0]
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x52   0x6060             STR      R0,[R4, #+4]
   \       0x54   0xF240 0x4029      MOVW     R0,#+1065
   \       0x58   0x60A0             STR      R0,[R4, #+8]
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \       0x5E   0x60E0             STR      R0,[R4, #+12]
   1066            return (id);
   \       0x60   0x0030             MOVS     R0,R6
   \       0x62   0xB2C0             UXTB     R0,R0
   \                     ??OSTaskRegGetID_2: (+1)
   \       0x64   0xBD70             POP      {R4-R6,PC}
   1067          }
   1068          #endif
   1069          
   1070          /****************************************************************************************************//**
   1071           *                                               OSTaskRegSet()
   1072           *
   1073           * @brief    Changes the current value of a task register. Task registers are application specific
   1074           *           and can be used to store task specific values such as error numbers (i.e. errno),
   1075           *           statistics, etc.
   1076           *
   1077           * @param    p_tcb   Pointer to the TCB of the task for which you want to set the register.
   1078           *                   If 'p_tcb' is a NULL pointer, change the register of the current task.
   1079           *
   1080           * @param    id      The 'id' of the desired task register. Note that the 'id' must be less than
   1081           *                   OS_CFG_TASK_REG_TBL_SIZE.
   1082           *
   1083           * @param    value   The desired value for the task register.
   1084           *
   1085           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1086           *                   from this function:
   1087           *                       - RTOS_ERR_NONE
   1088           *******************************************************************************************************/
   1089          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1090          void OSTaskRegSet(OS_TCB    *p_tcb,
   1091                            OS_REG_ID id,
   1092                            OS_REG    value,
   1093                            RTOS_ERR  *p_err)
   1094          {
   \                     OSTaskRegSet: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x001D             MOVS     R5,R3
   1095            CORE_DECLARE_IRQ_STATE;
   1096          
   1097            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??OSTaskRegSet_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
   1098          
   1099            OS_ASSERT_DBG_ERR_SET((id < OS_CFG_TASK_REG_TBL_SIZE), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTaskRegSet_0: (+1)
   \       0x14   0x0030             MOVS     R0,R6
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x2803             CMP      R0,#+3
   \       0x1A   0xDB0B             BLT.N    ??OSTaskRegSet_1
   \       0x1C   0x2008             MOVS     R0,#+8
   \       0x1E   0x7028             STRB     R0,[R5, #+0]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x24   0x6068             STR      R0,[R5, #+4]
   \       0x26   0xF240 0x404B      MOVW     R0,#+1099
   \       0x2A   0x60A8             STR      R0,[R5, #+8]
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \       0x30   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskRegSet_2: (+1)
   \       0x32   0xE7FE             B.N      ??OSTaskRegSet_2
   1100          
   1101            CORE_ENTER_ATOMIC();
   \                     ??OSTaskRegSet_1: (+1)
   \       0x34   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x38   0x4680             MOV      R8,R0
   1102            if (p_tcb == DEF_NULL) {
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD103             BNE.N    ??OSTaskRegSet_3
   1103              p_tcb = OSTCBCurPtr;
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \       0x42   0x6800             LDR      R0,[R0, #+0]
   \       0x44   0x0004             MOVS     R4,R0
   1104            }
   1105            p_tcb->RegTbl[id] = value;
   \                     ??OSTaskRegSet_3: (+1)
   \       0x46   0x0030             MOVS     R0,R6
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \       0x4E   0x66C7             STR      R7,[R0, #+108]
   1106            CORE_EXIT_ATOMIC();
   \       0x50   0x4640             MOV      R0,R8
   \       0x52   0x.... 0x....      BL       CORE_ExitAtomic
   1107            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x7028             STRB     R0,[R5, #+0]
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x5E   0x6068             STR      R0,[R5, #+4]
   \       0x60   0xF240 0x4053      MOVW     R0,#+1107
   \       0x64   0x60A8             STR      R0,[R5, #+8]
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \       0x6A   0x60E8             STR      R0,[R5, #+12]
   1108          }
   \       0x6C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1109          #endif
   1110          
   1111          /****************************************************************************************************//**
   1112           *                                               OSTaskResume()
   1113           *
   1114           * @brief    Resumes a previously suspended task. This is the only call that removes an explicit
   1115           *           task suspension.
   1116           *
   1117           * @param    p_tcb   Pointer to the TCB of the task to resume.
   1118           *
   1119           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1120           *                   from this function:
   1121           *                       - RTOS_ERR_NONE
   1122           *                       - RTOS_ERR_INVALID_STATE
   1123           *******************************************************************************************************/
   1124          #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1125          void OSTaskResume(OS_TCB   *p_tcb,
   1126                            RTOS_ERR *p_err)
   1127          {
   \                     OSTaskResume: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1128            CORE_DECLARE_IRQ_STATE;
   1129          
   1130            OS_TRACE_TASK_RESUME_ENTER(p_tcb);
   1131          
   1132            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD101             BNE.N    ??OSTaskResume_0
   \        0xC   0x.... 0x....      BL       CPU_SW_Exception
   1133          
   1134            //                                                               Not allowed to call from an ISR
   1135            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSTaskResume_0: (+1)
   \       0x10   0x.... 0x....      BL       CORE_InIrqContext
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??OSTaskResume_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??OSTaskResume_2
   \                     ??OSTaskResume_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??OSTaskResume_2: (+1)
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD10B             BNE.N    ??OSTaskResume_3
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0x7028             STRB     R0,[R5, #+0]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x2C   0x6068             STR      R0,[R5, #+4]
   \       0x2E   0xF240 0x406F      MOVW     R0,#+1135
   \       0x32   0x60A8             STR      R0,[R5, #+8]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \       0x38   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskResume_4: (+1)
   \       0x3A   0xE7FE             B.N      ??OSTaskResume_4
   1136          
   1137          #if (OS_ARG_CHK_EN == DEF_ENABLED)
   1138            if (OSRunning != OS_STATE_OS_RUNNING) {                       // Make sure kernel is running
   \                     ??OSTaskResume_3: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \       0x40   0x7800             LDRB     R0,[R0, #+0]
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD00B             BEQ.N    ??OSTaskResume_5
   1139              OS_TRACE_TASK_RESUME_EXIT(RTOS_ERR_NOT_READY);
   1140              OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_NOT_READY,; );
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0x7028             STRB     R0,[R5, #+0]
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x4E   0x6068             STR      R0,[R5, #+4]
   \       0x50   0xF240 0x4074      MOVW     R0,#+1140
   \       0x54   0x60A8             STR      R0,[R5, #+8]
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \       0x5A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskResume_6: (+1)
   \       0x5C   0xE7FE             B.N      ??OSTaskResume_6
   1141            }
   1142          #endif
   1143          
   1144            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSTaskResume_5: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x7028             STRB     R0,[R5, #+0]
   \       0x62   0x.... 0x....      LDR.W    R7,??DataTable8
   \       0x66   0x606F             STR      R7,[R5, #+4]
   \       0x68   0xF44F 0x608F      MOV      R0,#+1144
   \       0x6C   0x60A8             STR      R0,[R5, #+8]
   \       0x6E   0x.... 0x....      LDR.W    R8,??DataTable15_3
   \       0x72   0xF8C5 0x800C      STR      R8,[R5, #+12]
   1145            CORE_ENTER_ATOMIC();
   \       0x76   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x7A   0x0006             MOVS     R6,R0
   1146          #if (OS_ARG_CHK_EN == DEF_ENABLED)
   1147            if ((p_tcb == DEF_NULL)                                       // We cannot resume 'self'
   1148                || (p_tcb == OSTCBCurPtr)) {
   \       0x7C   0x2C00             CMP      R4,#+0
   \       0x7E   0xD004             BEQ.N    ??OSTaskResume_7
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \       0x84   0x6800             LDR      R0,[R0, #+0]
   \       0x86   0x4284             CMP      R4,R0
   \       0x88   0xD10B             BNE.N    ??OSTaskResume_8
   1149              CORE_EXIT_ATOMIC();
   \                     ??OSTaskResume_7: (+1)
   \       0x8A   0x0030             MOVS     R0,R6
   \       0x8C   0x.... 0x....      BL       CORE_ExitAtomic
   1150              OS_TRACE_TASK_RESUME_EXIT(RTOS_ERR_INVALID_ARG);
   1151              OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_INVALID_ARG,; );
   \       0x90   0x2008             MOVS     R0,#+8
   \       0x92   0x7028             STRB     R0,[R5, #+0]
   \       0x94   0x606F             STR      R7,[R5, #+4]
   \       0x96   0xF240 0x407F      MOVW     R0,#+1151
   \       0x9A   0x60A8             STR      R0,[R5, #+8]
   \       0x9C   0xF8C5 0x800C      STR      R8,[R5, #+12]
   \                     ??OSTaskResume_9: (+1)
   \       0xA0   0xE7FE             B.N      ??OSTaskResume_9
   1152            }
   1153          #endif
   1154          
   1155            switch (p_tcb->TaskState) {
   \                     ??OSTaskResume_8: (+1)
   \       0xA2   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0x2803             CMP      R0,#+3
   \       0xAA   0xD90A             BLS.N    ??OSTaskResume_10
   \       0xAC   0x1F00             SUBS     R0,R0,#+4
   \       0xAE   0xD014             BEQ.N    ??OSTaskResume_11
   \       0xB0   0x1E40             SUBS     R0,R0,#+1
   \       0xB2   0xD025             BEQ.N    ??OSTaskResume_12
   \       0xB4   0x1E40             SUBS     R0,R0,#+1
   \       0xB6   0xD033             BEQ.N    ??OSTaskResume_13
   \       0xB8   0x1E40             SUBS     R0,R0,#+1
   \       0xBA   0xD041             BEQ.N    ??OSTaskResume_14
   \       0xBC   0x38F8             SUBS     R0,R0,#+248
   \       0xBE   0xD04F             BEQ.N    ??OSTaskResume_15
   \       0xC0   0xE05A             B.N      ??OSTaskResume_16
   1156              case OS_TASK_STATE_RDY:
   1157              case OS_TASK_STATE_DLY:
   1158              case OS_TASK_STATE_PEND:
   1159              case OS_TASK_STATE_PEND_TIMEOUT:
   1160                CORE_EXIT_ATOMIC();
   \                     ??OSTaskResume_10: (+1)
   \       0xC2   0x0030             MOVS     R0,R6
   \       0xC4   0x.... 0x....      BL       CORE_ExitAtomic
   1161                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
   \       0xC8   0x201F             MOVS     R0,#+31
   \       0xCA   0x7028             STRB     R0,[R5, #+0]
   \       0xCC   0x606F             STR      R7,[R5, #+4]
   \       0xCE   0xF240 0x4089      MOVW     R0,#+1161
   \       0xD2   0x60A8             STR      R0,[R5, #+8]
   \       0xD4   0xF8C5 0x800C      STR      R8,[R5, #+12]
   1162                break;
   \       0xD8   0xE053             B.N      ??OSTaskResume_17
   1163          
   1164              case OS_TASK_STATE_SUSPENDED:
   1165                p_tcb->SuspendCtr--;
   \                     ??OSTaskResume_11: (+1)
   \       0xDA   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \       0xDE   0x1E40             SUBS     R0,R0,#+1
   \       0xE0   0xF884 0x008C      STRB     R0,[R4, #+140]
   1166                if (p_tcb->SuspendCtr == 0u) {
   \       0xE4   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD105             BNE.N    ??OSTaskResume_18
   1167                  p_tcb->TaskState = OS_TASK_STATE_RDY;
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0xF884 0x0026      STRB     R0,[R4, #+38]
   1168                  OS_RdyListInsert(p_tcb);                                // Insert the task in the ready list
   \       0xF2   0x0020             MOVS     R0,R4
   \       0xF4   0x.... 0x....      BL       OS_RdyListInsert
   1169                  OS_TRACE_TASK_RESUME(p_tcb);
   1170                }
   1171                CORE_EXIT_ATOMIC();
   \                     ??OSTaskResume_18: (+1)
   \       0xF8   0x0030             MOVS     R0,R6
   \       0xFA   0x.... 0x....      BL       CORE_ExitAtomic
   1172                break;
   \       0xFE   0xE040             B.N      ??OSTaskResume_17
   1173          
   1174              case OS_TASK_STATE_DLY_SUSPENDED:
   1175                p_tcb->SuspendCtr--;
   \                     ??OSTaskResume_12: (+1)
   \      0x100   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \      0x104   0x1E40             SUBS     R0,R0,#+1
   \      0x106   0xF884 0x008C      STRB     R0,[R4, #+140]
   1176                if (p_tcb->SuspendCtr == 0u) {
   \      0x10A   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD102             BNE.N    ??OSTaskResume_19
   1177                  p_tcb->TaskState = OS_TASK_STATE_DLY;
   \      0x112   0x2001             MOVS     R0,#+1
   \      0x114   0xF884 0x0026      STRB     R0,[R4, #+38]
   1178                }
   1179                CORE_EXIT_ATOMIC();
   \                     ??OSTaskResume_19: (+1)
   \      0x118   0x0030             MOVS     R0,R6
   \      0x11A   0x.... 0x....      BL       CORE_ExitAtomic
   1180                break;
   \      0x11E   0xE030             B.N      ??OSTaskResume_17
   1181          
   1182              case OS_TASK_STATE_PEND_SUSPENDED:
   1183                p_tcb->SuspendCtr--;
   \                     ??OSTaskResume_13: (+1)
   \      0x120   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \      0x124   0x1E40             SUBS     R0,R0,#+1
   \      0x126   0xF884 0x008C      STRB     R0,[R4, #+140]
   1184                if (p_tcb->SuspendCtr == 0u) {
   \      0x12A   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD102             BNE.N    ??OSTaskResume_20
   1185                  p_tcb->TaskState = OS_TASK_STATE_PEND;
   \      0x132   0x2002             MOVS     R0,#+2
   \      0x134   0xF884 0x0026      STRB     R0,[R4, #+38]
   1186                }
   1187                CORE_EXIT_ATOMIC();
   \                     ??OSTaskResume_20: (+1)
   \      0x138   0x0030             MOVS     R0,R6
   \      0x13A   0x.... 0x....      BL       CORE_ExitAtomic
   1188                break;
   \      0x13E   0xE020             B.N      ??OSTaskResume_17
   1189          
   1190              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1191                p_tcb->SuspendCtr--;
   \                     ??OSTaskResume_14: (+1)
   \      0x140   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \      0x144   0x1E40             SUBS     R0,R0,#+1
   \      0x146   0xF884 0x008C      STRB     R0,[R4, #+140]
   1192                if (p_tcb->SuspendCtr == 0u) {
   \      0x14A   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD102             BNE.N    ??OSTaskResume_21
   1193                  p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   \      0x152   0x2003             MOVS     R0,#+3
   \      0x154   0xF884 0x0026      STRB     R0,[R4, #+38]
   1194                }
   1195                CORE_EXIT_ATOMIC();
   \                     ??OSTaskResume_21: (+1)
   \      0x158   0x0030             MOVS     R0,R6
   \      0x15A   0x.... 0x....      BL       CORE_ExitAtomic
   1196                break;
   \      0x15E   0xE010             B.N      ??OSTaskResume_17
   1197          
   1198              case OS_TASK_STATE_DEL:
   1199          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
   1200                CORE_EXIT_ATOMIC();
   \                     ??OSTaskResume_15: (+1)
   \      0x160   0x0030             MOVS     R0,R6
   \      0x162   0x.... 0x....      BL       CORE_ExitAtomic
   1201                OS_TRACE_TASK_RESUME_EXIT(RTOS_ERR_INVALID_STATE);
   1202                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
   \      0x166   0x201F             MOVS     R0,#+31
   \      0x168   0x7028             STRB     R0,[R5, #+0]
   \      0x16A   0x606F             STR      R7,[R5, #+4]
   \      0x16C   0xF240 0x40B2      MOVW     R0,#+1202
   \      0x170   0x60A8             STR      R0,[R5, #+8]
   \      0x172   0xF8C5 0x800C      STR      R8,[R5, #+12]
   1203                return;
   \      0x176   0xE006             B.N      ??OSTaskResume_22
   1204          #endif
   1205          
   1206              default:
   1207                CORE_EXIT_ATOMIC();
   \                     ??OSTaskResume_16: (+1)
   \      0x178   0x0030             MOVS     R0,R6
   \      0x17A   0x.... 0x....      BL       CORE_ExitAtomic
   1208                OS_TRACE_TASK_RESUME_EXIT(RTOS_ERR_OS);
   1209                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \      0x17E   0x.... 0x....      BL       CPU_SW_Exception
   1210            }
   1211          
   1212            OSSched();
   \                     ??OSTaskResume_17: (+1)
   \      0x182   0x.... 0x....      BL       OSSched
   1213          
   1214            OS_TRACE_TASK_RESUME_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1215          }
   \                     ??OSTaskResume_22: (+1)
   \      0x186   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1216          #endif
   1217          
   1218          /****************************************************************************************************//**
   1219           *                                               OSTaskSemPend()
   1220           *
   1221           * @brief    Blocks the current task until a signal is sent by another task or ISR.
   1222           *
   1223           * @param    timeout     The amount of time you will wait for the signal.
   1224           *
   1225           * @param    opt         Determines if the user wants to block if a semaphore post was not received:
   1226           *                           - OS_OPT_PEND_BLOCKING        Task will     block.
   1227           *                           - OS_OPT_PEND_NON_BLOCKING    Task will NOT block.
   1228           *
   1229           * @param    p_ts        Pointer to a variable that will receive the timestamp of when the
   1230           *                       semaphore was posted or pend aborted.
   1231           *                       If you pass a NULL pointer (i.e. (CPU_TS *)0), you will not get the
   1232           *                       timestamp. In other words, passing a NULL pointer is valid and indicates
   1233           *                       that you don't need the timestamp.
   1234           *
   1235           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
   1236           *                       from this function:
   1237           *                           - RTOS_ERR_NONE
   1238           *                           - RTOS_ERR_WOULD_BLOCK
   1239           *                           - RTOS_ERR_OS_SCHED_LOCKED
   1240           *                           - RTOS_ERR_ABORT
   1241           *                           - RTOS_ERR_TIMEOUT
   1242           *                           - RTOS_ERR_NOT_READY
   1243           *
   1244           * @return   The current count of signals the task received, 0 if none.
   1245           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1246          OS_SEM_CTR OSTaskSemPend(OS_TICK  timeout,
   1247                                   OS_OPT   opt,
   1248                                   CPU_TS   *p_ts,
   1249                                   RTOS_ERR *p_err)
   1250          {
   \                     OSTaskSemPend: (+1)
   \        0x0   0xE92D 0x43F4      PUSH     {R2,R4-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x001C             MOVS     R4,R3
   1251            OS_SEM_CTR ctr;
   1252            CORE_DECLARE_IRQ_STATE;
   1253          
   1254          #if (OS_CFG_TS_EN == DEF_DISABLED)
   1255            (void)&p_ts;                                                  // Prevent compiler warning for not using 'ts'
   \        0xA   0x4668             MOV      R0,SP
   1256          #endif
   1257          
   1258            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD101             BNE.N    ??OSTaskSemPend_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
   1259          
   1260            OS_TRACE_TASK_SEM_PEND_ENTER(OSTCBCurPtr, timeout, opt, p_ts);
   1261          
   1262            //                                                               Not allowed to call from an ISR
   1263            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSTaskSemPend_0: (+1)
   \       0x14   0x.... 0x....      BL       CORE_InIrqContext
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??OSTaskSemPend_1
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE000             B.N      ??OSTaskSemPend_2
   \                     ??OSTaskSemPend_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSemPend_2: (+1)
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD10A             BNE.N    ??OSTaskSemPend_3
   \       0x28   0x2020             MOVS     R0,#+32
   \       0x2A   0x7020             STRB     R0,[R4, #+0]
   \       0x2C   0x....             LDR.N    R0,??DataTable8
   \       0x2E   0x6060             STR      R0,[R4, #+4]
   \       0x30   0xF240 0x40EF      MOVW     R0,#+1263
   \       0x34   0x60A0             STR      R0,[R4, #+8]
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \       0x3A   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTaskSemPend_4: (+1)
   \       0x3C   0xE7FE             B.N      ??OSTaskSemPend_4
   1264          
   1265            //                                                               Validate 'opt'
   1266            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_PEND_BLOCKING)
   1267                                   || (opt == OS_OPT_PEND_NON_BLOCKING)), *p_err, RTOS_ERR_INVALID_ARG, 0u);
   \                     ??OSTaskSemPend_3: (+1)
   \       0x3E   0x0030             MOVS     R0,R6
   \       0x40   0xB280             UXTH     R0,R0
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD004             BEQ.N    ??OSTaskSemPend_5
   \       0x46   0x0030             MOVS     R0,R6
   \       0x48   0xB280             UXTH     R0,R0
   \       0x4A   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x4E   0xD101             BNE.N    ??OSTaskSemPend_6
   \                     ??OSTaskSemPend_5: (+1)
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xE000             B.N      ??OSTaskSemPend_7
   \                     ??OSTaskSemPend_6: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSemPend_7: (+1)
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD10A             BNE.N    ??OSTaskSemPend_8
   \       0x5C   0x2008             MOVS     R0,#+8
   \       0x5E   0x7020             STRB     R0,[R4, #+0]
   \       0x60   0x....             LDR.N    R0,??DataTable8
   \       0x62   0x6060             STR      R0,[R4, #+4]
   \       0x64   0xF240 0x40F3      MOVW     R0,#+1267
   \       0x68   0x60A0             STR      R0,[R4, #+8]
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \       0x6E   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTaskSemPend_9: (+1)
   \       0x70   0xE7FE             B.N      ??OSTaskSemPend_9
   1268          
   1269            //                                                               Make sure kernel is running.
   1270            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSTaskSemPend_8: (+1)
   \       0x72   0x....             LDR.N    R0,??DataTable8_1
   \       0x74   0x7800             LDRB     R0,[R0, #+0]
   \       0x76   0x2801             CMP      R0,#+1
   \       0x78   0xD00B             BEQ.N    ??OSTaskSemPend_10
   1271              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x7A   0x2002             MOVS     R0,#+2
   \       0x7C   0x7020             STRB     R0,[R4, #+0]
   \       0x7E   0x....             LDR.N    R0,??DataTable8
   \       0x80   0x6060             STR      R0,[R4, #+4]
   \       0x82   0xF240 0x40F7      MOVW     R0,#+1271
   \       0x86   0x60A0             STR      R0,[R4, #+8]
   \       0x88   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \       0x8C   0x60E0             STR      R0,[R4, #+12]
   1272              return (0u);
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xE08C             B.N      ??OSTaskSemPend_11
   1273            }
   1274          
   1275            CORE_ENTER_ATOMIC();
   \                     ??OSTaskSemPend_10: (+1)
   \       0x92   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x96   0x0007             MOVS     R7,R0
   1276            if (OSTCBCurPtr->SemCtr > 0u) {                               // See if task already been signaled
   \       0x98   0x.... 0x....      LDR.W    R8,??DataTable9_1
   \       0x9C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xA0   0x6B80             LDR      R0,[R0, #+56]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD019             BEQ.N    ??OSTaskSemPend_12
   1277              OSTCBCurPtr->SemCtr--;
   \       0xA6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xAA   0x6B80             LDR      R0,[R0, #+56]
   \       0xAC   0x1E40             SUBS     R0,R0,#+1
   \       0xAE   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xB2   0x6388             STR      R0,[R1, #+56]
   1278              ctr = OSTCBCurPtr->SemCtr;
   \       0xB4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xB8   0xF8D0 0x8038      LDR      R8,[R0, #+56]
   1279          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1280              if (p_ts != DEF_NULL) {
   1281                *p_ts = OSTCBCurPtr->TS;
   1282              }
   1283          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   1284          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1285              OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   1286              if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   1287                OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   1288              }
   1289          #endif
   1290          #endif
   1291          #endif
   1292              CORE_EXIT_ATOMIC();
   \       0xBC   0x0038             MOVS     R0,R7
   \       0xBE   0x.... 0x....      BL       CORE_ExitAtomic
   1293              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x7020             STRB     R0,[R4, #+0]
   \       0xC6   0x....             LDR.N    R0,??DataTable8
   \       0xC8   0x6060             STR      R0,[R4, #+4]
   \       0xCA   0xF240 0x500D      MOVW     R0,#+1293
   \       0xCE   0x60A0             STR      R0,[R4, #+8]
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \       0xD4   0x60E0             STR      R0,[R4, #+12]
   1294              OS_TRACE_TASK_SEM_PEND(OSTCBCurPtr);
   1295              OS_TRACE_TASK_SEM_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1296              return (ctr);
   \       0xD6   0x4640             MOV      R0,R8
   \       0xD8   0xE068             B.N      ??OSTaskSemPend_11
   1297            }
   1298          
   1299            if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {                 // Caller wants to block if not available?
   \                     ??OSTaskSemPend_12: (+1)
   \       0xDA   0x0030             MOVS     R0,R6
   \       0xDC   0xB280             UXTH     R0,R0
   \       0xDE   0x0400             LSLS     R0,R0,#+16
   \       0xE0   0xD50E             BPL.N    ??OSTaskSemPend_13
   1300              CORE_EXIT_ATOMIC();
   \       0xE2   0x0038             MOVS     R0,R7
   \       0xE4   0x.... 0x....      BL       CORE_ExitAtomic
   1301          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1302              if (p_ts != DEF_NULL) {
   1303                *p_ts = 0u;
   1304              }
   1305          #endif
   1306              RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);                 // No
   \       0xE8   0x201D             MOVS     R0,#+29
   \       0xEA   0x7020             STRB     R0,[R4, #+0]
   \       0xEC   0x....             LDR.N    R0,??DataTable8
   \       0xEE   0x6060             STR      R0,[R4, #+4]
   \       0xF0   0xF240 0x501A      MOVW     R0,#+1306
   \       0xF4   0x60A0             STR      R0,[R4, #+8]
   \       0xF6   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \       0xFA   0x60E0             STR      R0,[R4, #+12]
   1307              OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1308              OS_TRACE_TASK_SEM_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1309              return (0u);
   \       0xFC   0x2000             MOVS     R0,#+0
   \       0xFE   0xE055             B.N      ??OSTaskSemPend_11
   1310            } else {                                                      // Yes
   1311              if (OSSchedLockNestingCtr > 0u) {                           // Can't pend when the scheduler is locked
   \                     ??OSTaskSemPend_13: (+1)
   \      0x100   0x.... 0x....      LDR.W    R0,??DataTable15_6
   \      0x104   0x7800             LDRB     R0,[R0, #+0]
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD00E             BEQ.N    ??OSTaskSemPend_14
   1312          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1313                if (p_ts != DEF_NULL) {
   1314                  *p_ts = 0u;
   1315                }
   1316          #endif
   1317                CORE_EXIT_ATOMIC();
   \      0x10A   0x0038             MOVS     R0,R7
   \      0x10C   0x.... 0x....      BL       CORE_ExitAtomic
   1318                RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
   \      0x110   0x202D             MOVS     R0,#+45
   \      0x112   0x7020             STRB     R0,[R4, #+0]
   \      0x114   0x....             LDR.N    R0,??DataTable8
   \      0x116   0x6060             STR      R0,[R4, #+4]
   \      0x118   0xF240 0x5026      MOVW     R0,#+1318
   \      0x11C   0x60A0             STR      R0,[R4, #+8]
   \      0x11E   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \      0x122   0x60E0             STR      R0,[R4, #+12]
   1319                OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1320                OS_TRACE_TASK_SEM_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1321                return (0u);
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0xE041             B.N      ??OSTaskSemPend_11
   1322              }
   1323            }
   1324          
   1325            OS_Pend(DEF_NULL,                                             // Block task pending on Signal
   1326                    OS_TASK_PEND_ON_TASK_SEM,
   1327                    timeout);
   \                     ??OSTaskSemPend_14: (+1)
   \      0x128   0x002A             MOVS     R2,R5
   \      0x12A   0x2107             MOVS     R1,#+7
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0x.... 0x....      BL       OS_Pend
   1328            CORE_EXIT_ATOMIC();
   \      0x132   0x0038             MOVS     R0,R7
   \      0x134   0x.... 0x....      BL       CORE_ExitAtomic
   1329            OS_TRACE_TASK_SEM_PEND_BLOCK(OSTCBCurPtr);
   1330            OSSched();                                                    // Find next highest priority task ready to run
   \      0x138   0x.... 0x....      BL       OSSched
   1331          
   1332            CORE_ENTER_ATOMIC();
   \      0x13C   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x140   0x4681             MOV      R9,R0
   1333            switch (OSTCBCurPtr->PendStatus) {                            // See if we timed-out or aborted
   \      0x142   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x146   0xF890 0x0025      LDRB     R0,[R0, #+37]
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD004             BEQ.N    ??OSTaskSemPend_15
   \      0x14E   0x2801             CMP      R0,#+1
   \      0x150   0xD00D             BEQ.N    ??OSTaskSemPend_16
   \      0x152   0x2803             CMP      R0,#+3
   \      0x154   0xD016             BEQ.N    ??OSTaskSemPend_17
   \      0x156   0xE020             B.N      ??OSTaskSemPend_18
   1334              case OS_STATUS_PEND_OK:
   1335          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1336                if (p_ts != DEF_NULL) {
   1337                  *p_ts = OSTCBCurPtr->TS;
   1338          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   1339          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1340                  OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   1341                  if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   1342                    OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   1343                  }
   1344          #endif
   1345          #endif
   1346                }
   1347          #endif
   1348                OS_TRACE_TASK_SEM_PEND(OSTCBCurPtr);
   1349                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSTaskSemPend_15: (+1)
   \      0x158   0x2000             MOVS     R0,#+0
   \      0x15A   0x7020             STRB     R0,[R4, #+0]
   \      0x15C   0x....             LDR.N    R0,??DataTable8
   \      0x15E   0x6060             STR      R0,[R4, #+4]
   \      0x160   0xF240 0x5045      MOVW     R0,#+1349
   \      0x164   0x60A0             STR      R0,[R4, #+8]
   \      0x166   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \      0x16A   0x60E0             STR      R0,[R4, #+12]
   1350                break;
   \      0x16C   0xE017             B.N      ??OSTaskSemPend_19
   1351          
   1352              case OS_STATUS_PEND_ABORT:
   1353          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1354                if (p_ts != DEF_NULL) {
   1355                  *p_ts = OSTCBCurPtr->TS;
   1356                }
   1357          #endif
   1358                OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1359                RTOS_ERR_SET(*p_err, RTOS_ERR_ABORT);                     // Indicate that we aborted
   \                     ??OSTaskSemPend_16: (+1)
   \      0x16E   0x2021             MOVS     R0,#+33
   \      0x170   0x7020             STRB     R0,[R4, #+0]
   \      0x172   0x....             LDR.N    R0,??DataTable8
   \      0x174   0x6060             STR      R0,[R4, #+4]
   \      0x176   0xF240 0x504F      MOVW     R0,#+1359
   \      0x17A   0x60A0             STR      R0,[R4, #+8]
   \      0x17C   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \      0x180   0x60E0             STR      R0,[R4, #+12]
   1360                break;
   \      0x182   0xE00C             B.N      ??OSTaskSemPend_19
   1361          
   1362              case OS_STATUS_PEND_TIMEOUT:
   1363          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1364                if (p_ts != DEF_NULL) {
   1365                  *p_ts = 0u;
   1366                }
   1367          #endif
   1368                OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1369                RTOS_ERR_SET(*p_err, RTOS_ERR_TIMEOUT);                   // Indicate that we didn't get event within TO
   \                     ??OSTaskSemPend_17: (+1)
   \      0x184   0x2022             MOVS     R0,#+34
   \      0x186   0x7020             STRB     R0,[R4, #+0]
   \      0x188   0x....             LDR.N    R0,??DataTable8
   \      0x18A   0x6060             STR      R0,[R4, #+4]
   \      0x18C   0xF240 0x5059      MOVW     R0,#+1369
   \      0x190   0x60A0             STR      R0,[R4, #+8]
   \      0x192   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \      0x196   0x60E0             STR      R0,[R4, #+12]
   1370                break;
   \      0x198   0xE001             B.N      ??OSTaskSemPend_19
   1371          
   1372              case OS_STATUS_PEND_DEL:
   1373              default:
   1374                OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1375                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, 0u);
   \                     ??OSTaskSemPend_18: (+1)
   \      0x19A   0x.... 0x....      BL       CPU_SW_Exception
   1376            }
   1377            ctr = OSTCBCurPtr->SemCtr;
   \                     ??OSTaskSemPend_19: (+1)
   \      0x19E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1A2   0x6B87             LDR      R7,[R0, #+56]
   1378            CORE_EXIT_ATOMIC();
   \      0x1A4   0x4648             MOV      R0,R9
   \      0x1A6   0x.... 0x....      BL       CORE_ExitAtomic
   1379            OS_TRACE_TASK_SEM_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1380            return (ctr);
   \      0x1AA   0x0038             MOVS     R0,R7
   \                     ??OSTaskSemPend_11: (+1)
   \      0x1AC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1381          }
   1382          
   1383          /****************************************************************************************************//**
   1384           *                                           OSTaskSemPendAbort()
   1385           *
   1386           * @brief    Aborts and readies the task specified. This function should be used to
   1387           *           fault-abort the wait for a signal, rather than to normally post the signal to the task via
   1388           *           OSTaskSemPost().
   1389           *
   1390           * @param    p_tcb   Pointer to the TCB of the task to pend abort.
   1391           *
   1392           * @param    opt     Provides options for this function:
   1393           *                       - OS_OPT_POST_NONE        No option selected.
   1394           *                       - OS_OPT_POST_NO_SCHED    Indicates that the scheduler will not be called.
   1395           *
   1396           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1397           *                   from this function:
   1398           *                       - RTOS_ERR_NONE
   1399           *                       - RTOS_ERR_NONE_WAITING
   1400           *
   1401           * @return   == DEF_FALSE    If task was not waiting for a message, or upon error.
   1402           *           == DEF_TRUE     If task was waiting for a message and was readied and informed.
   1403           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1404          CPU_BOOLEAN OSTaskSemPendAbort(OS_TCB   *p_tcb,
   1405                                         OS_OPT   opt,
   1406                                         RTOS_ERR *p_err)
   1407          {
   \                     OSTaskSemPendAbort: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0015             MOVS     R5,R2
   1408            CPU_TS ts;
   1409            CORE_DECLARE_IRQ_STATE;
   1410          
   1411            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FALSE);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSTaskSemPendAbort_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
   1412          
   1413            //                                                               Not allowed to call from an ISR
   1414            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, DEF_FALSE);
   \                     ??OSTaskSemPendAbort_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_InIrqContext
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??OSTaskSemPendAbort_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??OSTaskSemPendAbort_2
   \                     ??OSTaskSemPendAbort_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSemPendAbort_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10A             BNE.N    ??OSTaskSemPendAbort_3
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   \       0x2A   0x....             LDR.N    R0,??DataTable8
   \       0x2C   0x6068             STR      R0,[R5, #+4]
   \       0x2E   0xF240 0x5086      MOVW     R0,#+1414
   \       0x32   0x60A8             STR      R0,[R5, #+8]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \       0x38   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskSemPendAbort_4: (+1)
   \       0x3A   0xE7FE             B.N      ??OSTaskSemPendAbort_4
   1415          
   1416            //                                                               Make sure kernel is running.
   1417            OS_ASSERT_DBG_ERR_SET((OSRunning == OS_STATE_OS_RUNNING), *p_err, RTOS_ERR_NOT_READY, DEF_FALSE);
   \                     ??OSTaskSemPendAbort_3: (+1)
   \       0x3C   0x....             LDR.N    R0,??DataTable8_1
   \       0x3E   0x7800             LDRB     R0,[R0, #+0]
   \       0x40   0x2801             CMP      R0,#+1
   \       0x42   0xD00A             BEQ.N    ??OSTaskSemPendAbort_5
   \       0x44   0x2002             MOVS     R0,#+2
   \       0x46   0x7028             STRB     R0,[R5, #+0]
   \       0x48   0x....             LDR.N    R0,??DataTable8
   \       0x4A   0x6068             STR      R0,[R5, #+4]
   \       0x4C   0xF240 0x5089      MOVW     R0,#+1417
   \       0x50   0x60A8             STR      R0,[R5, #+8]
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \       0x56   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskSemPendAbort_6: (+1)
   \       0x58   0xE7FE             B.N      ??OSTaskSemPendAbort_6
   1418          
   1419            //                                                               Validate 'opt'
   1420            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_POST_NONE)
   1421                                   || (opt == OS_OPT_POST_NO_SCHED)), *p_err, RTOS_ERR_INVALID_ARG, DEF_FALSE);
   \                     ??OSTaskSemPendAbort_5: (+1)
   \       0x5A   0x0030             MOVS     R0,R6
   \       0x5C   0xB280             UXTH     R0,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD004             BEQ.N    ??OSTaskSemPendAbort_7
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0xB280             UXTH     R0,R0
   \       0x66   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x6A   0xD101             BNE.N    ??OSTaskSemPendAbort_8
   \                     ??OSTaskSemPendAbort_7: (+1)
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xE000             B.N      ??OSTaskSemPendAbort_9
   \                     ??OSTaskSemPendAbort_8: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSemPendAbort_9: (+1)
   \       0x72   0xB2C0             UXTB     R0,R0
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD10A             BNE.N    ??OSTaskSemPendAbort_10
   \       0x78   0x2008             MOVS     R0,#+8
   \       0x7A   0x7028             STRB     R0,[R5, #+0]
   \       0x7C   0x....             LDR.N    R0,??DataTable8
   \       0x7E   0x6068             STR      R0,[R5, #+4]
   \       0x80   0xF240 0x508D      MOVW     R0,#+1421
   \       0x84   0x60A8             STR      R0,[R5, #+8]
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \       0x8A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskSemPendAbort_11: (+1)
   \       0x8C   0xE7FE             B.N      ??OSTaskSemPendAbort_11
   1422          
   1423            CORE_ENTER_ATOMIC();
   \                     ??OSTaskSemPendAbort_10: (+1)
   \       0x8E   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x92   0x0007             MOVS     R7,R0
   1424          #if (OS_ARG_CHK_EN == DEF_ENABLED)
   1425            if ((p_tcb == DEF_NULL)                                       // Pend abort self?
   1426                || (p_tcb == OSTCBCurPtr)) {
   \       0x94   0x2C00             CMP      R4,#+0
   \       0x96   0xD003             BEQ.N    ??OSTaskSemPendAbort_12
   \       0x98   0x....             LDR.N    R0,??DataTable9_1
   \       0x9A   0x6800             LDR      R0,[R0, #+0]
   \       0x9C   0x4284             CMP      R4,R0
   \       0x9E   0xD10D             BNE.N    ??OSTaskSemPendAbort_13
   1427              CORE_EXIT_ATOMIC();                                         // ... doesn't make sense!
   \                     ??OSTaskSemPendAbort_12: (+1)
   \       0xA0   0x0038             MOVS     R0,R7
   \       0xA2   0x.... 0x....      BL       CORE_ExitAtomic
   1428              OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_INVALID_ARG, DEF_FALSE);
   \       0xA6   0x2008             MOVS     R0,#+8
   \       0xA8   0x7028             STRB     R0,[R5, #+0]
   \       0xAA   0x....             LDR.N    R0,??DataTable8
   \       0xAC   0x6068             STR      R0,[R5, #+4]
   \       0xAE   0xF240 0x5094      MOVW     R0,#+1428
   \       0xB2   0x60A8             STR      R0,[R5, #+8]
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \       0xB8   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskSemPendAbort_14: (+1)
   \       0xBA   0xE7FE             B.N      ??OSTaskSemPendAbort_14
   1429            }
   1430          #endif
   1431          
   1432            if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {              // Is task waiting for a signal?
   \                     ??OSTaskSemPendAbort_13: (+1)
   \       0xBC   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \       0xC0   0x2807             CMP      R0,#+7
   \       0xC2   0xD00E             BEQ.N    ??OSTaskSemPendAbort_15
   1433              CORE_EXIT_ATOMIC();
   \       0xC4   0x0038             MOVS     R0,R7
   \       0xC6   0x.... 0x....      BL       CORE_ExitAtomic
   1434              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE_WAITING);
   \       0xCA   0x2024             MOVS     R0,#+36
   \       0xCC   0x7028             STRB     R0,[R5, #+0]
   \       0xCE   0x....             LDR.N    R0,??DataTable8
   \       0xD0   0x6068             STR      R0,[R5, #+4]
   \       0xD2   0xF240 0x509A      MOVW     R0,#+1434
   \       0xD6   0x60A8             STR      R0,[R5, #+8]
   \       0xD8   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \       0xDC   0x60E8             STR      R0,[R5, #+12]
   1435              return (DEF_FALSE);
   \       0xDE   0x2000             MOVS     R0,#+0
   \       0xE0   0xE020             B.N      ??OSTaskSemPendAbort_16
   1436            }
   1437            CORE_EXIT_ATOMIC();
   \                     ??OSTaskSemPendAbort_15: (+1)
   \       0xE2   0x0038             MOVS     R0,R7
   \       0xE4   0x.... 0x....      BL       CORE_ExitAtomic
   1438          
   1439            CORE_ENTER_ATOMIC();
   \       0xE8   0x.... 0x....      BL       CORE_EnterAtomic
   \       0xEC   0x4680             MOV      R8,R0
   1440          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1441            ts = OS_TS_GET();
   1442          #else
   1443            ts = 0u;
   \       0xEE   0xF05F 0x0900      MOVS     R9,#+0
   1444          #endif
   1445            OS_PendAbort(p_tcb,                                           // Abort the pend
   1446                         ts,
   1447                         OS_STATUS_PEND_ABORT);
   \       0xF2   0x2201             MOVS     R2,#+1
   \       0xF4   0x4649             MOV      R1,R9
   \       0xF6   0x0020             MOVS     R0,R4
   \       0xF8   0x.... 0x....      BL       OS_PendAbort
   1448            CORE_EXIT_ATOMIC();
   \       0xFC   0x4640             MOV      R0,R8
   \       0xFE   0x.... 0x....      BL       CORE_ExitAtomic
   1449            if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \      0x102   0x0030             MOVS     R0,R6
   \      0x104   0xB280             UXTH     R0,R0
   \      0x106   0x0400             LSLS     R0,R0,#+16
   \      0x108   0xD401             BMI.N    ??OSTaskSemPendAbort_17
   1450              OSSched();                                                  // Run the scheduler
   \      0x10A   0x.... 0x....      BL       OSSched
   1451            }
   1452            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSTaskSemPendAbort_17: (+1)
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0x7028             STRB     R0,[R5, #+0]
   \      0x112   0x....             LDR.N    R0,??DataTable8
   \      0x114   0x6068             STR      R0,[R5, #+4]
   \      0x116   0xF240 0x50AC      MOVW     R0,#+1452
   \      0x11A   0x60A8             STR      R0,[R5, #+8]
   \      0x11C   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \      0x120   0x60E8             STR      R0,[R5, #+12]
   1453            return (DEF_TRUE);
   \      0x122   0x2001             MOVS     R0,#+1
   \                     ??OSTaskSemPendAbort_16: (+1)
   \      0x124   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1454          }
   1455          
   1456          /****************************************************************************************************//**
   1457           *                                               OSTaskSemPost()
   1458           *
   1459           * @brief    Signals a task waiting for a signal.
   1460           *
   1461           * @param    p_tcb   The pointer to the TCB of the task to signal. A NULL pointer indicates that
   1462           *                   you are sending a signal to yourself.
   1463           *
   1464           * @param    opt     Determines the type of POST performed:
   1465           *                       - OS_OPT_POST_NONE        No option.
   1466           *                       - OS_OPT_POST_NO_SCHED    Do not call the scheduler.
   1467           *
   1468           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1469           *                   from this function:
   1470           *                       - RTOS_ERR_NONE
   1471           *                       - RTOS_ERR_WOULD_OVF
   1472           *                       - RTOS_ERR_INVALID_STATE
   1473           *                       - RTOS_ERR_NOT_READY
   1474           *
   1475           * @return   The current value of the task's signal counter, or 0 if called from an ISR.
   1476           *
   1477           * @note     (1) This function may be called from an ISR.
   1478           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1479          OS_SEM_CTR OSTaskSemPost(OS_TCB   *p_tcb,
   1480                                   OS_OPT   opt,
   1481                                   RTOS_ERR *p_err)
   1482          {
   \                     OSTaskSemPost: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x0015             MOVS     R5,R2
   1483            OS_SEM_CTR ctr;
   1484            CPU_TS     ts;
   1485            CORE_DECLARE_IRQ_STATE;
   1486          
   1487            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSTaskSemPost_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
   1488          
   1489            OS_TRACE_TASK_SEM_POST_ENTER(p_tcb, opt);
   1490          
   1491            //                                                               Validate 'opt'
   1492            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_POST_NONE)
   1493                                   || (opt == OS_OPT_POST_NO_SCHED)), *p_err, RTOS_ERR_INVALID_ARG, 0u);
   \                     ??OSTaskSemPost_0: (+1)
   \       0x12   0x4658             MOV      R0,R11
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD004             BEQ.N    ??OSTaskSemPost_1
   \       0x1A   0x4658             MOV      R0,R11
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x22   0xD101             BNE.N    ??OSTaskSemPost_2
   \                     ??OSTaskSemPost_1: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE000             B.N      ??OSTaskSemPost_3
   \                     ??OSTaskSemPost_2: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSemPost_3: (+1)
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD10B             BNE.N    ??OSTaskSemPost_4
   \       0x30   0x2008             MOVS     R0,#+8
   \       0x32   0x7028             STRB     R0,[R5, #+0]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x38   0x6068             STR      R0,[R5, #+4]
   \       0x3A   0xF240 0x50D5      MOVW     R0,#+1493
   \       0x3E   0x60A8             STR      R0,[R5, #+8]
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \       0x44   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskSemPost_5: (+1)
   \       0x46   0xE7FE             B.N      ??OSTaskSemPost_5
   1494          
   1495            //                                                               Make sure kernel is running.
   1496            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSTaskSemPost_4: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable15_10
   \       0x4C   0x7800             LDRB     R0,[R0, #+0]
   \       0x4E   0x2801             CMP      R0,#+1
   \       0x50   0xD00C             BEQ.N    ??OSTaskSemPost_6
   1497              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x52   0x2002             MOVS     R0,#+2
   \       0x54   0x7028             STRB     R0,[R5, #+0]
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x5A   0x6068             STR      R0,[R5, #+4]
   \       0x5C   0xF240 0x50D9      MOVW     R0,#+1497
   \       0x60   0x60A8             STR      R0,[R5, #+8]
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \       0x66   0x60E8             STR      R0,[R5, #+12]
   1498              return (0u);
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xE08A             B.N      ??OSTaskSemPost_7
   1499            }
   1500          
   1501          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1502            ts = OS_TS_GET();                                             // Get timestamp
   1503          #else
   1504            ts = 0u;
   \                     ??OSTaskSemPost_6: (+1)
   \       0x6C   0x2600             MOVS     R6,#+0
   1505          #endif
   1506          
   1507            OS_TRACE_TASK_SEM_POST(p_tcb);
   1508          
   1509            CORE_ENTER_ATOMIC();
   \       0x6E   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x72   0x0007             MOVS     R7,R0
   1510            if (p_tcb == DEF_NULL) {                                      // Post signal to 'self'?
   \       0x74   0x2C00             CMP      R4,#+0
   \       0x76   0xD102             BNE.N    ??OSTaskSemPost_8
   1511              p_tcb = OSTCBCurPtr;
   \       0x78   0x....             LDR.N    R0,??DataTable9_1
   \       0x7A   0x6800             LDR      R0,[R0, #+0]
   \       0x7C   0x0004             MOVS     R4,R0
   1512            }
   1513          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1514            p_tcb->TS = ts;
   1515          #endif
   1516            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);                          // Assume we won't have any errors
   \                     ??OSTaskSemPost_8: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x7028             STRB     R0,[R5, #+0]
   \       0x82   0x.... 0x....      LDR.W    R8,??DataTable15_8
   \       0x86   0xF8C5 0x8004      STR      R8,[R5, #+4]
   \       0x8A   0xF240 0x50EC      MOVW     R0,#+1516
   \       0x8E   0x60A8             STR      R0,[R5, #+8]
   \       0x90   0x.... 0x....      LDR.W    R9,??DataTable15_9
   \       0x94   0xF8C5 0x900C      STR      R9,[R5, #+12]
   1517            ctr = 0u;
   \       0x98   0xF05F 0x0A00      MOVS     R10,#+0
   1518            switch (p_tcb->TaskState) {
   \       0x9C   0xF894 0x1026      LDRB     R1,[R4, #+38]
   \       0xA0   0x2900             CMP      R1,#+0
   \       0xA2   0x2901             CMP      R1,#+1
   \       0xA4   0xD90B             BLS.N    ??OSTaskSemPost_9
   \       0xA6   0x1E89             SUBS     R1,R1,#+2
   \       0xA8   0x2901             CMP      R1,#+1
   \       0xAA   0xD923             BLS.N    ??OSTaskSemPost_10
   \       0xAC   0x1E89             SUBS     R1,R1,#+2
   \       0xAE   0x2901             CMP      R1,#+1
   \       0xB0   0xD905             BLS.N    ??OSTaskSemPost_9
   \       0xB2   0x1E89             SUBS     R1,R1,#+2
   \       0xB4   0x2901             CMP      R1,#+1
   \       0xB6   0xD91D             BLS.N    ??OSTaskSemPost_10
   \       0xB8   0x39F9             SUBS     R1,R1,#+249
   \       0xBA   0xD04D             BEQ.N    ??OSTaskSemPost_11
   \       0xBC   0xE05B             B.N      ??OSTaskSemPost_12
   1519              case OS_TASK_STATE_RDY:
   1520              case OS_TASK_STATE_DLY:
   1521              case OS_TASK_STATE_SUSPENDED:
   1522              case OS_TASK_STATE_DLY_SUSPENDED:
   1523                switch (sizeof(OS_SEM_CTR)) {
   1524                  case 1u:
   1525                    if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
   1526                      CORE_EXIT_ATOMIC();
   1527                      RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   1528                      OS_TRACE_TASK_SEM_POST_FAILED(p_tcb);
   1529                      OS_TRACE_TASK_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1530                      return (0u);
   1531                    }
   1532                    break;
   1533          
   1534                  case 2u:
   1535                    if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
   1536                      CORE_EXIT_ATOMIC();
   1537                      RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   1538                      OS_TRACE_TASK_SEM_POST_FAILED(p_tcb);
   1539                      OS_TRACE_TASK_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1540                      return (0u);
   1541                    }
   1542                    break;
   1543          
   1544                  case 4u:
   1545                    if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
   \                     ??OSTaskSemPost_9: (+1)
   \       0xBE   0x6BA0             LDR      R0,[R4, #+56]
   \       0xC0   0xF110 0x0F01      CMN      R0,#+1
   \       0xC4   0xD10D             BNE.N    ??OSTaskSemPost_13
   1546                      CORE_EXIT_ATOMIC();
   \       0xC6   0x0038             MOVS     R0,R7
   \       0xC8   0x.... 0x....      BL       CORE_ExitAtomic
   1547                      RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   \       0xCC   0x201E             MOVS     R0,#+30
   \       0xCE   0x7028             STRB     R0,[R5, #+0]
   \       0xD0   0xF8C5 0x8004      STR      R8,[R5, #+4]
   \       0xD4   0xF240 0x600B      MOVW     R0,#+1547
   \       0xD8   0x60A8             STR      R0,[R5, #+8]
   \       0xDA   0xF8C5 0x900C      STR      R9,[R5, #+12]
   1548                      OS_TRACE_TASK_SEM_POST_FAILED(p_tcb);
   1549                      OS_TRACE_TASK_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1550                      return (0u);
   \       0xDE   0x2000             MOVS     R0,#+0
   \       0xE0   0xE04F             B.N      ??OSTaskSemPost_7
   1551                    }
   1552                    break;
   1553          
   1554                  default:
   1555                    break;
   1556                }
   1557                p_tcb->SemCtr++;                                          // Task signaled is not pending on anything
   \                     ??OSTaskSemPost_13: (+1)
   \       0xE2   0x6BA0             LDR      R0,[R4, #+56]
   \       0xE4   0x1C40             ADDS     R0,R0,#+1
   \       0xE6   0x63A0             STR      R0,[R4, #+56]
   1558                ctr = p_tcb->SemCtr;
   \       0xE8   0x6BA0             LDR      R0,[R4, #+56]
   \       0xEA   0x4682             MOV      R10,R0
   1559                CORE_EXIT_ATOMIC();
   \       0xEC   0x0038             MOVS     R0,R7
   \       0xEE   0x.... 0x....      BL       CORE_ExitAtomic
   1560                break;
   \       0xF2   0xE045             B.N      ??OSTaskSemPost_14
   1561          
   1562              case OS_TASK_STATE_PEND:
   1563              case OS_TASK_STATE_PEND_TIMEOUT:
   1564              case OS_TASK_STATE_PEND_SUSPENDED:
   1565              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1566                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {          // Is task signaled waiting for a signal?
   \                     ??OSTaskSemPost_10: (+1)
   \       0xF4   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \       0xF8   0x2807             CMP      R0,#+7
   \       0xFA   0xD112             BNE.N    ??OSTaskSemPost_15
   1567                  OS_Post(DEF_NULL,                                       // Task is pending on signal
   1568                          p_tcb,
   1569                          DEF_NULL,
   1570                          0u,
   1571                          ts);
   \       0xFC   0x9600             STR      R6,[SP, #+0]
   \       0xFE   0x2300             MOVS     R3,#+0
   \      0x100   0x2200             MOVS     R2,#+0
   \      0x102   0x0021             MOVS     R1,R4
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0x.... 0x....      BL       OS_Post
   1572                  ctr = p_tcb->SemCtr;
   \      0x10A   0x6BA0             LDR      R0,[R4, #+56]
   \      0x10C   0x4682             MOV      R10,R0
   1573                  CORE_EXIT_ATOMIC();
   \      0x10E   0x0038             MOVS     R0,R7
   \      0x110   0x.... 0x....      BL       CORE_ExitAtomic
   1574                  if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \      0x114   0x4658             MOV      R0,R11
   \      0x116   0xB280             UXTH     R0,R0
   \      0x118   0x0400             LSLS     R0,R0,#+16
   \      0x11A   0xD41C             BMI.N    ??OSTaskSemPost_16
   1575                    OSSched();                                            // Run the scheduler
   \      0x11C   0x.... 0x....      BL       OSSched
   \      0x120   0xE019             B.N      ??OSTaskSemPost_16
   1576                  }
   1577                } else {
   1578                  switch (sizeof(OS_SEM_CTR)) {
   1579                    case 1u:
   1580                      if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
   1581                        CORE_EXIT_ATOMIC();
   1582                        RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   1583                        OS_TRACE_TASK_SEM_POST_FAILED(p_tcb);
   1584                        OS_TRACE_TASK_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1585                        return (0u);
   1586                      }
   1587                      break;
   1588          
   1589                    case 2u:
   1590                      if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
   1591                        CORE_EXIT_ATOMIC();
   1592                        RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   1593                        OS_TRACE_TASK_SEM_POST_FAILED(p_tcb);
   1594                        OS_TRACE_TASK_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1595                        return (0u);
   1596                      }
   1597                      break;
   1598          
   1599                    case 4u:
   1600                      if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
   \                     ??OSTaskSemPost_15: (+1)
   \      0x122   0x6BA0             LDR      R0,[R4, #+56]
   \      0x124   0xF110 0x0F01      CMN      R0,#+1
   \      0x128   0xD10D             BNE.N    ??OSTaskSemPost_17
   1601                        CORE_EXIT_ATOMIC();
   \      0x12A   0x0038             MOVS     R0,R7
   \      0x12C   0x.... 0x....      BL       CORE_ExitAtomic
   1602                        RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   \      0x130   0x201E             MOVS     R0,#+30
   \      0x132   0x7028             STRB     R0,[R5, #+0]
   \      0x134   0xF8C5 0x8004      STR      R8,[R5, #+4]
   \      0x138   0xF240 0x6042      MOVW     R0,#+1602
   \      0x13C   0x60A8             STR      R0,[R5, #+8]
   \      0x13E   0xF8C5 0x900C      STR      R9,[R5, #+12]
   1603                        OS_TRACE_TASK_SEM_POST_FAILED(p_tcb);
   1604                        OS_TRACE_TASK_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1605                        return (0u);
   \      0x142   0x2000             MOVS     R0,#+0
   \      0x144   0xE01D             B.N      ??OSTaskSemPost_7
   1606                      }
   1607                      break;
   1608          
   1609                    default:
   1610                      break;
   1611                  }
   1612                  p_tcb->SemCtr++;                                        // No,  Task signaled is NOT pending on semaphore ...
   \                     ??OSTaskSemPost_17: (+1)
   \      0x146   0x6BA0             LDR      R0,[R4, #+56]
   \      0x148   0x1C40             ADDS     R0,R0,#+1
   \      0x14A   0x63A0             STR      R0,[R4, #+56]
   1613                  ctr = p_tcb->SemCtr;                                    // ... it must be waiting on something else
   \      0x14C   0x6BA0             LDR      R0,[R4, #+56]
   \      0x14E   0x4682             MOV      R10,R0
   1614                  CORE_EXIT_ATOMIC();
   \      0x150   0x0038             MOVS     R0,R7
   \      0x152   0x.... 0x....      BL       CORE_ExitAtomic
   1615                }
   1616                break;
   \                     ??OSTaskSemPost_16: (+1)
   \      0x156   0xE013             B.N      ??OSTaskSemPost_14
   1617          
   1618              case OS_TASK_STATE_DEL:
   1619          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
   1620                CORE_EXIT_ATOMIC();
   \                     ??OSTaskSemPost_11: (+1)
   \      0x158   0x0038             MOVS     R0,R7
   \      0x15A   0x.... 0x....      BL       CORE_ExitAtomic
   1621                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
   \      0x15E   0x201F             MOVS     R0,#+31
   \      0x160   0x7028             STRB     R0,[R5, #+0]
   \      0x162   0xF8C5 0x8004      STR      R8,[R5, #+4]
   \      0x166   0xF240 0x6055      MOVW     R0,#+1621
   \      0x16A   0x60A8             STR      R0,[R5, #+8]
   \      0x16C   0xF8C5 0x900C      STR      R9,[R5, #+12]
   1622                OS_TRACE_TASK_SEM_POST_FAILED(p_tcb);
   1623                ctr = 0u;
   \      0x170   0x2000             MOVS     R0,#+0
   \      0x172   0x4682             MOV      R10,R0
   1624                break;
   \      0x174   0xE004             B.N      ??OSTaskSemPost_14
   1625          #endif
   1626          
   1627              default:
   1628                CORE_EXIT_ATOMIC();
   \                     ??OSTaskSemPost_12: (+1)
   \      0x176   0x0038             MOVS     R0,R7
   \      0x178   0x.... 0x....      BL       CORE_ExitAtomic
   1629                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, 0u);
   \      0x17C   0x.... 0x....      BL       CPU_SW_Exception
   1630            }
   1631          
   1632            OS_TRACE_TASK_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1633          
   1634            return (ctr);
   \                     ??OSTaskSemPost_14: (+1)
   \      0x180   0x4650             MOV      R0,R10
   \                     ??OSTaskSemPost_7: (+1)
   \      0x182   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1635          }
   1636          
   1637          /****************************************************************************************************//**
   1638           *                                               OSTaskSemSet()
   1639           *
   1640           * @brief    Clears the signal counter.
   1641           *
   1642           * @param    p_tcb   Pointer to the TCB of the task to clear the counter. If you specify a
   1643           *                   NULL pointer, the signal counter of the current task will be cleared.
   1644           *
   1645           * @param    cnt     The desired value of the semaphore counter.
   1646           *
   1647           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1648           *                   from this function:
   1649           *                       - RTOS_ERR_NONE
   1650           *                       - RTOS_ERR_OS_TASK_WAITING
   1651           *
   1652           * @return   The value of the signal counter before being set, or 0 on error.
   1653           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1654          OS_SEM_CTR OSTaskSemSet(OS_TCB     *p_tcb,
   1655                                  OS_SEM_CTR cnt,
   1656                                  RTOS_ERR   *p_err)
   1657          {
   \                     OSTaskSemSet: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0015             MOVS     R5,R2
   1658            OS_SEM_CTR ctr;
   1659            CORE_DECLARE_IRQ_STATE;
   1660          
   1661            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSTaskSemSet_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
   1662          
   1663            //                                                               Not allowed to call from an ISR
   1664            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSTaskSemSet_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_InIrqContext
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??OSTaskSemSet_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??OSTaskSemSet_2
   \                     ??OSTaskSemSet_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSemSet_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10B             BNE.N    ??OSTaskSemSet_3
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x2E   0x6068             STR      R0,[R5, #+4]
   \       0x30   0xF44F 0x60D0      MOV      R0,#+1664
   \       0x34   0x60A8             STR      R0,[R5, #+8]
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \       0x3A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskSemSet_4: (+1)
   \       0x3C   0xE7FE             B.N      ??OSTaskSemSet_4
   1665          
   1666            CORE_ENTER_ATOMIC();
   \                     ??OSTaskSemSet_3: (+1)
   \       0x3E   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x42   0x0007             MOVS     R7,R0
   1667            if (p_tcb == DEF_NULL) {
   \       0x44   0x2C00             CMP      R4,#+0
   \       0x46   0xD103             BNE.N    ??OSTaskSemSet_5
   1668              p_tcb = OSTCBCurPtr;
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0x0004             MOVS     R4,R0
   1669            }
   1670          
   1671            if (((p_tcb->TaskState   & OS_TASK_STATE_PEND) != 0u)         // Not allowed when a task is waiting.
   1672                && (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM)) {
   \                     ??OSTaskSemSet_5: (+1)
   \       0x50   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \       0x54   0x0780             LSLS     R0,R0,#+30
   \       0x56   0xD513             BPL.N    ??OSTaskSemSet_6
   \       0x58   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \       0x5C   0x2807             CMP      R0,#+7
   \       0x5E   0xD10F             BNE.N    ??OSTaskSemSet_6
   1673              CORE_EXIT_ATOMIC();
   \       0x60   0x0038             MOVS     R0,R7
   \       0x62   0x.... 0x....      BL       CORE_ExitAtomic
   1674              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_TASK_WAITING);
   \       0x66   0x202E             MOVS     R0,#+46
   \       0x68   0x7028             STRB     R0,[R5, #+0]
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x6E   0x6068             STR      R0,[R5, #+4]
   \       0x70   0xF240 0x608A      MOVW     R0,#+1674
   \       0x74   0x60A8             STR      R0,[R5, #+8]
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \       0x7A   0x60E8             STR      R0,[R5, #+12]
   1675              return (0u);
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xE011             B.N      ??OSTaskSemSet_7
   1676            }
   1677          
   1678            ctr = p_tcb->SemCtr;
   \                     ??OSTaskSemSet_6: (+1)
   \       0x80   0xF8D4 0x8038      LDR      R8,[R4, #+56]
   1679            p_tcb->SemCtr = (OS_SEM_CTR)cnt;
   \       0x84   0x63A6             STR      R6,[R4, #+56]
   1680            CORE_EXIT_ATOMIC();
   \       0x86   0x0038             MOVS     R0,R7
   \       0x88   0x.... 0x....      BL       CORE_ExitAtomic
   1681            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x7028             STRB     R0,[R5, #+0]
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x94   0x6068             STR      R0,[R5, #+4]
   \       0x96   0xF240 0x6091      MOVW     R0,#+1681
   \       0x9A   0x60A8             STR      R0,[R5, #+8]
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \       0xA0   0x60E8             STR      R0,[R5, #+12]
   1682            return (ctr);
   \       0xA2   0x4640             MOV      R0,R8
   \                     ??OSTaskSemSet_7: (+1)
   \       0xA4   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1683          }
   1684          
   1685          /****************************************************************************************************//**
   1686           *                                               OSTaskStkChk()
   1687           *
   1688           * @brief    Calculates the amount of free memory left on the specified task's stack.
   1689           *
   1690           * @param    p_tcb   Pointer to the TCB of the task to check. If you specify a NULL pointer,
   1691           *                   you are specifying that you want to check the stack of the current task.
   1692           *
   1693           * @param    p_free  Pointer to a variable that will receive the number of free 'entries' on
   1694           *                   the task's stack.
   1695           *
   1696           * @param    p_used  Pointer to a variable that will receive the number of used 'entries' on
   1697           *                   the task's stack.
   1698           *
   1699           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1700           *                   from this function:
   1701           *                       - RTOS_ERR_NONE
   1702           *                       - RTOS_ERR_INVALID_ARG
   1703           *                       - RTOS_ERR_NOT_SUPPORTED
   1704           *
   1705           * @note     (1) Options OS_OPT_TASK_STK_CHK and OS_OPT_TASK_STK_CLR should be set in OSTaskCreate() call
   1706           *           in order to use OSTaskStkChk(). See OS_OPT_TASK_xxx in os.h.
   1707           *******************************************************************************************************/
   1708          
   1709          #if (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1710          void OSTaskStkChk(OS_TCB       *p_tcb,
   1711                            CPU_STK_SIZE *p_free,
   1712                            CPU_STK_SIZE *p_used,
   1713                            RTOS_ERR     *p_err)
   1714          {
   \                     OSTaskStkChk: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1715            CPU_STK_SIZE free_stk;
   1716            CPU_STK      *p_stk;
   1717            CORE_DECLARE_IRQ_STATE;
   1718          
   1719            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xC   0x2F00             CMP      R7,#+0
   \        0xE   0xD101             BNE.N    ??OSTaskStkChk_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
   1720          
   1721            //                                                               Not allowed to call from an ISR
   1722            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSTaskStkChk_0: (+1)
   \       0x14   0x.... 0x....      BL       CORE_InIrqContext
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??OSTaskStkChk_1
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE000             B.N      ??OSTaskStkChk_2
   \                     ??OSTaskStkChk_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \                     ??OSTaskStkChk_2: (+1)
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD10B             BNE.N    ??OSTaskStkChk_3
   \       0x28   0x2020             MOVS     R0,#+32
   \       0x2A   0x7038             STRB     R0,[R7, #+0]
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x30   0x6078             STR      R0,[R7, #+4]
   \       0x32   0xF240 0x60BA      MOVW     R0,#+1722
   \       0x36   0x60B8             STR      R0,[R7, #+8]
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \       0x3C   0x60F8             STR      R0,[R7, #+12]
   \                     ??OSTaskStkChk_4: (+1)
   \       0x3E   0xE7FE             B.N      ??OSTaskStkChk_4
   1723          
   1724            //                                                               User must specify valid destinations for the sizes
   1725            OS_ASSERT_DBG_ERR_SET((p_free != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSTaskStkChk_3: (+1)
   \       0x40   0x2D00             CMP      R5,#+0
   \       0x42   0xD10B             BNE.N    ??OSTaskStkChk_5
   \       0x44   0x200A             MOVS     R0,#+10
   \       0x46   0x7038             STRB     R0,[R7, #+0]
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x4C   0x6078             STR      R0,[R7, #+4]
   \       0x4E   0xF240 0x60BD      MOVW     R0,#+1725
   \       0x52   0x60B8             STR      R0,[R7, #+8]
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \       0x58   0x60F8             STR      R0,[R7, #+12]
   \                     ??OSTaskStkChk_6: (+1)
   \       0x5A   0xE7FE             B.N      ??OSTaskStkChk_6
   1726          
   1727            OS_ASSERT_DBG_ERR_SET((p_used != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSTaskStkChk_5: (+1)
   \       0x5C   0x2E00             CMP      R6,#+0
   \       0x5E   0xD10B             BNE.N    ??OSTaskStkChk_7
   \       0x60   0x200A             MOVS     R0,#+10
   \       0x62   0x7038             STRB     R0,[R7, #+0]
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x68   0x6078             STR      R0,[R7, #+4]
   \       0x6A   0xF240 0x60BF      MOVW     R0,#+1727
   \       0x6E   0x60B8             STR      R0,[R7, #+8]
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \       0x74   0x60F8             STR      R0,[R7, #+12]
   \                     ??OSTaskStkChk_8: (+1)
   \       0x76   0xE7FE             B.N      ??OSTaskStkChk_8
   1728          
   1729            CORE_ENTER_ATOMIC();
   \                     ??OSTaskStkChk_7: (+1)
   \       0x78   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x7C   0x4680             MOV      R8,R0
   1730            if (p_tcb == DEF_NULL) {                                      // Check the stack of the current task?
   \       0x7E   0x2C00             CMP      R4,#+0
   \       0x80   0xD103             BNE.N    ??OSTaskStkChk_9
   1731              p_tcb = OSTCBCurPtr;                                        // Yes
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \       0x86   0x6800             LDR      R0,[R0, #+0]
   \       0x88   0x0004             MOVS     R4,R0
   1732            }
   1733          
   1734            if (p_tcb->StkPtr == DEF_NULL) {                              // Make sure task exist
   \                     ??OSTaskStkChk_9: (+1)
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD112             BNE.N    ??OSTaskStkChk_10
   1735              CORE_EXIT_ATOMIC();
   \       0x90   0x4640             MOV      R0,R8
   \       0x92   0x.... 0x....      BL       CORE_ExitAtomic
   1736              *p_free = 0u;
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0x6028             STR      R0,[R5, #+0]
   1737              *p_used = 0u;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x6030             STR      R0,[R6, #+0]
   1738              RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_ARG);
   \       0x9E   0x2008             MOVS     R0,#+8
   \       0xA0   0x7038             STRB     R0,[R7, #+0]
   \       0xA2   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0xA6   0x6078             STR      R0,[R7, #+4]
   \       0xA8   0xF240 0x60CA      MOVW     R0,#+1738
   \       0xAC   0x60B8             STR      R0,[R7, #+8]
   \       0xAE   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \       0xB2   0x60F8             STR      R0,[R7, #+12]
   1739              return;
   \       0xB4   0xE030             B.N      ??OSTaskStkChk_11
   1740            }
   1741          
   1742            if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == 0u) {               // Make sure stack checking option is set
   \                     ??OSTaskStkChk_10: (+1)
   \       0xB6   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \       0xBA   0x07C0             LSLS     R0,R0,#+31
   \       0xBC   0xD412             BMI.N    ??OSTaskStkChk_12
   1743              CORE_EXIT_ATOMIC();
   \       0xBE   0x4640             MOV      R0,R8
   \       0xC0   0x.... 0x....      BL       CORE_ExitAtomic
   1744              *p_free = 0u;
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0x6028             STR      R0,[R5, #+0]
   1745              *p_used = 0u;
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0x6030             STR      R0,[R6, #+0]
   1746              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_SUPPORTED);
   \       0xCC   0x2007             MOVS     R0,#+7
   \       0xCE   0x7038             STRB     R0,[R7, #+0]
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0xD4   0x6078             STR      R0,[R7, #+4]
   \       0xD6   0xF240 0x60D2      MOVW     R0,#+1746
   \       0xDA   0x60B8             STR      R0,[R7, #+8]
   \       0xDC   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \       0xE0   0x60F8             STR      R0,[R7, #+12]
   1747              return;
   \       0xE2   0xE019             B.N      ??OSTaskStkChk_11
   1748            }
   1749            CORE_EXIT_ATOMIC();
   \                     ??OSTaskStkChk_12: (+1)
   \       0xE4   0x4640             MOV      R0,R8
   \       0xE6   0x.... 0x....      BL       CORE_ExitAtomic
   1750          
   1751            free_stk = 0u;
   \       0xEA   0x2200             MOVS     R2,#+0
   1752          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   1753            p_stk = p_tcb->StkBasePtr;                                    // Start at the lowest memory and go up
   \       0xEC   0x6961             LDR      R1,[R4, #+20]
   1754          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   1755            p_stk += OS_CFG_TASK_STK_REDZONE_DEPTH;
   1756          #endif
   1757            while (*p_stk == 0u) {                                        // Compute the number of zero entries on the stk
   \                     ??OSTaskStkChk_13: (+1)
   \       0xEE   0x6808             LDR      R0,[R1, #+0]
   \       0xF0   0x2800             CMP      R0,#+0
   \       0xF2   0xD102             BNE.N    ??OSTaskStkChk_14
   1758              p_stk++;
   \       0xF4   0x1D09             ADDS     R1,R1,#+4
   1759              free_stk++;
   \       0xF6   0x1C52             ADDS     R2,R2,#+1
   \       0xF8   0xE7F9             B.N      ??OSTaskStkChk_13
   1760            }
   1761          #else
   1762            p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;              // Start at the highest memory and go down
   1763          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   1764            p_stk -= OS_CFG_TASK_STK_REDZONE_DEPTH;
   1765          #endif
   1766            while (*p_stk == 0u) {
   1767              free_stk++;
   1768              p_stk--;
   1769            }
   1770          #endif
   1771            *p_free = free_stk;
   \                     ??OSTaskStkChk_14: (+1)
   \       0xFA   0x602A             STR      R2,[R5, #+0]
   1772            *p_used = (p_tcb->StkSize - free_stk);                        // Compute number of entries used on the stack
   \       0xFC   0x6B20             LDR      R0,[R4, #+48]
   \       0xFE   0x1A80             SUBS     R0,R0,R2
   \      0x100   0x6030             STR      R0,[R6, #+0]
   1773            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x102   0x2000             MOVS     R0,#+0
   \      0x104   0x7038             STRB     R0,[R7, #+0]
   \      0x106   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \      0x10A   0x6078             STR      R0,[R7, #+4]
   \      0x10C   0xF240 0x60ED      MOVW     R0,#+1773
   \      0x110   0x60B8             STR      R0,[R7, #+8]
   \      0x112   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \      0x116   0x60F8             STR      R0,[R7, #+12]
   1774          }
   \                     ??OSTaskStkChk_11: (+1)
   \      0x118   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1775          #endif
   1776          
   1777          /****************************************************************************************************//**
   1778           *                                           OSTaskStkRedzoneChk()
   1779           *
   1780           * @brief    Verifies a task's stack redzone.
   1781           *
   1782           * @param    p_tcb   Pointer to the TCB of the task to check or null for the current task.
   1783           *
   1784           * @return   == DEF_FAIL     If the stack is     corrupted.
   1785           *           == DEF_OK       If the stack is NOT corrupted.
   1786           *
   1787           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1788           *******************************************************************************************************/
   1789          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   1790          CPU_BOOLEAN OSTaskStkRedzoneChk(OS_TCB *p_tcb)
   1791          {
   1792            CPU_BOOLEAN stk_status;
   1793          
   1794            if (p_tcb == DEF_NULL) {
   1795              p_tcb = OSTCBCurPtr;
   1796            }
   1797            //                                                               Check if SP is valid:
   1798            //                                                               StkBase <= SP < (StkBase + StkSize)
   1799            if ((p_tcb->StkPtr < p_tcb->StkBasePtr)
   1800                || (p_tcb->StkPtr >= (p_tcb->StkBasePtr + p_tcb->StkSize))) {
   1801              return (DEF_FAIL);
   1802            }
   1803          
   1804            stk_status = OS_TaskStkRedzoneChk(p_tcb->StkBasePtr, p_tcb->StkSize);
   1805          
   1806            return (stk_status);
   1807          }
   1808          #endif
   1809          
   1810          /****************************************************************************************************//**
   1811           *                                               OSTaskSuspend()
   1812           *
   1813           * @brief    This function is called to suspend a task. The task can be the calling task if 'p_tcb' is
   1814           *           a NULL pointer or the pointer to the TCB of the calling task.
   1815           *
   1816           * @param    p_tcb   Pointer to the TCB of the task to resume.
   1817           *                   If p_tcb is a NULL pointer, suspend the current task.
   1818           *
   1819           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1820           *                   from this function:
   1821           *                       - RTOS_ERR_NONE
   1822           *                       - RTOS_ERR_WOULD_OVF
   1823           *                       - RTOS_ERR_OS
   1824           *                       - RTOS_ERR_NOT_READY
   1825           *                       - RTOS_ERR_INVALID_STATE
   1826           *                       - RTOS_ERR_OS_SCHED_LOCKED
   1827           *******************************************************************************************************/
   1828          #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1829          void OSTaskSuspend(OS_TCB   *p_tcb,
   1830                             RTOS_ERR *p_err)
   1831          {
   \                     OSTaskSuspend: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1832            CORE_DECLARE_IRQ_STATE;
   1833          
   1834            OS_TRACE_TASK_SUSPEND_ENTER(p_tcb);
   1835          
   1836            //                                                               Not allowed to call from an ISR
   1837            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \        0x8   0x.... 0x....      BL       CORE_InIrqContext
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??OSTaskSuspend_0
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE000             B.N      ??OSTaskSuspend_1
   \                     ??OSTaskSuspend_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSuspend_1: (+1)
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD10B             BNE.N    ??OSTaskSuspend_2
   \       0x1C   0x2020             MOVS     R0,#+32
   \       0x1E   0x7028             STRB     R0,[R5, #+0]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x24   0x6068             STR      R0,[R5, #+4]
   \       0x26   0xF240 0x702D      MOVW     R0,#+1837
   \       0x2A   0x60A8             STR      R0,[R5, #+8]
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \       0x30   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSTaskSuspend_3: (+1)
   \       0x32   0xE7FE             B.N      ??OSTaskSuspend_3
   1838          
   1839            OS_TRACE_TASK_SUSPEND(p_tcb);
   1840          
   1841            CORE_ENTER_ATOMIC();
   \                     ??OSTaskSuspend_2: (+1)
   \       0x34   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x38   0x0006             MOVS     R6,R0
   1842            if (p_tcb == DEF_NULL) {                                      // See if specified to suspend self
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD116             BNE.N    ??OSTaskSuspend_4
   1843              if (OSRunning != OS_STATE_OS_RUNNING) {                     // Can't suspend self when the kernel isn't running
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable15_10
   \       0x42   0x7800             LDRB     R0,[R0, #+0]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD00E             BEQ.N    ??OSTaskSuspend_5
   1844                CORE_EXIT_ATOMIC();
   \       0x48   0x0030             MOVS     R0,R6
   \       0x4A   0x.... 0x....      BL       CORE_ExitAtomic
   1845                OS_TRACE_TASK_RESUME_EXIT(RTOS_ERR_NOT_READY);
   1846                RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x4E   0x2002             MOVS     R0,#+2
   \       0x50   0x7028             STRB     R0,[R5, #+0]
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x56   0x6068             STR      R0,[R5, #+4]
   \       0x58   0xF240 0x7036      MOVW     R0,#+1846
   \       0x5C   0x60A8             STR      R0,[R5, #+8]
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \       0x62   0x60E8             STR      R0,[R5, #+12]
   1847                return;
   \       0x64   0xE08D             B.N      ??OSTaskSuspend_6
   1848              }
   1849              p_tcb = OSTCBCurPtr;
   \                     ??OSTaskSuspend_5: (+1)
   \       0x66   0x....             LDR.N    R0,??DataTable15_4
   \       0x68   0x6800             LDR      R0,[R0, #+0]
   \       0x6A   0x0004             MOVS     R4,R0
   1850            }
   1851          
   1852            if (p_tcb == OSTCBCurPtr) {
   \                     ??OSTaskSuspend_4: (+1)
   \       0x6C   0x....             LDR.N    R0,??DataTable15_4
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0x4284             CMP      R4,R0
   \       0x72   0xD110             BNE.N    ??OSTaskSuspend_7
   1853              if (OSSchedLockNestingCtr > 0u) {                           // Can't suspend when the scheduler is locked
   \       0x74   0x....             LDR.N    R0,??DataTable15_6
   \       0x76   0x7800             LDRB     R0,[R0, #+0]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD00C             BEQ.N    ??OSTaskSuspend_7
   1854                CORE_EXIT_ATOMIC();
   \       0x7C   0x0030             MOVS     R0,R6
   \       0x7E   0x.... 0x....      BL       CORE_ExitAtomic
   1855                OS_TRACE_TASK_RESUME_EXIT(RTOS_ERR_OS_SCHED_LOCKED);
   1856                RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
   \       0x82   0x202D             MOVS     R0,#+45
   \       0x84   0x7028             STRB     R0,[R5, #+0]
   \       0x86   0x....             LDR.N    R0,??DataTable15_8
   \       0x88   0x6068             STR      R0,[R5, #+4]
   \       0x8A   0xF44F 0x60E8      MOV      R0,#+1856
   \       0x8E   0x60A8             STR      R0,[R5, #+8]
   \       0x90   0x....             LDR.N    R0,??DataTable15_13
   \       0x92   0x60E8             STR      R0,[R5, #+12]
   1857                return;
   \       0x94   0xE075             B.N      ??OSTaskSuspend_6
   1858              }
   1859            }
   1860          
   1861            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSTaskSuspend_7: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0x7028             STRB     R0,[R5, #+0]
   \       0x9A   0x....             LDR.N    R7,??DataTable15_8
   \       0x9C   0x606F             STR      R7,[R5, #+4]
   \       0x9E   0xF240 0x7045      MOVW     R0,#+1861
   \       0xA2   0x60A8             STR      R0,[R5, #+8]
   \       0xA4   0x.... 0x....      LDR.W    R8,??DataTable15_13
   \       0xA8   0xF8C5 0x800C      STR      R8,[R5, #+12]
   1862            switch (p_tcb->TaskState) {
   \       0xAC   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD00B             BEQ.N    ??OSTaskSuspend_8
   \       0xB4   0x1E40             SUBS     R0,R0,#+1
   \       0xB6   0xD016             BEQ.N    ??OSTaskSuspend_9
   \       0xB8   0x1E40             SUBS     R0,R0,#+1
   \       0xBA   0xD01E             BEQ.N    ??OSTaskSuspend_10
   \       0xBC   0x1E40             SUBS     R0,R0,#+1
   \       0xBE   0xD026             BEQ.N    ??OSTaskSuspend_11
   \       0xC0   0x1E40             SUBS     R0,R0,#+1
   \       0xC2   0x2803             CMP      R0,#+3
   \       0xC4   0xD92D             BLS.N    ??OSTaskSuspend_12
   \       0xC6   0x38FB             SUBS     R0,R0,#+251
   \       0xC8   0xD044             BEQ.N    ??OSTaskSuspend_13
   \       0xCA   0xE04F             B.N      ??OSTaskSuspend_14
   1863              case OS_TASK_STATE_RDY:
   1864                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OSTaskSuspend_8: (+1)
   \       0xCC   0x2004             MOVS     R0,#+4
   \       0xCE   0xF884 0x0026      STRB     R0,[R4, #+38]
   1865                p_tcb->SuspendCtr = 1u;
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0xF884 0x008C      STRB     R0,[R4, #+140]
   1866                OS_RdyListRemove(p_tcb);
   \       0xD8   0x0020             MOVS     R0,R4
   \       0xDA   0x.... 0x....      BL       OS_RdyListRemove
   1867                OS_TRACE_TASK_SUSPEND(p_tcb);
   1868                CORE_EXIT_ATOMIC();
   \       0xDE   0x0030             MOVS     R0,R6
   \       0xE0   0x.... 0x....      BL       CORE_ExitAtomic
   1869                break;
   \       0xE4   0xE047             B.N      ??OSTaskSuspend_15
   1870          
   1871              case OS_TASK_STATE_DLY:
   1872                p_tcb->TaskState = OS_TASK_STATE_DLY_SUSPENDED;
   \                     ??OSTaskSuspend_9: (+1)
   \       0xE6   0x2005             MOVS     R0,#+5
   \       0xE8   0xF884 0x0026      STRB     R0,[R4, #+38]
   1873                p_tcb->SuspendCtr = 1u;
   \       0xEC   0x2001             MOVS     R0,#+1
   \       0xEE   0xF884 0x008C      STRB     R0,[R4, #+140]
   1874                CORE_EXIT_ATOMIC();
   \       0xF2   0x0030             MOVS     R0,R6
   \       0xF4   0x.... 0x....      BL       CORE_ExitAtomic
   1875                break;
   \       0xF8   0xE03D             B.N      ??OSTaskSuspend_15
   1876          
   1877              case OS_TASK_STATE_PEND:
   1878                p_tcb->TaskState = OS_TASK_STATE_PEND_SUSPENDED;
   \                     ??OSTaskSuspend_10: (+1)
   \       0xFA   0x2006             MOVS     R0,#+6
   \       0xFC   0xF884 0x0026      STRB     R0,[R4, #+38]
   1879                p_tcb->SuspendCtr = 1u;
   \      0x100   0x2001             MOVS     R0,#+1
   \      0x102   0xF884 0x008C      STRB     R0,[R4, #+140]
   1880                CORE_EXIT_ATOMIC();
   \      0x106   0x0030             MOVS     R0,R6
   \      0x108   0x.... 0x....      BL       CORE_ExitAtomic
   1881                break;
   \      0x10C   0xE033             B.N      ??OSTaskSuspend_15
   1882          
   1883              case OS_TASK_STATE_PEND_TIMEOUT:
   1884                p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
   \                     ??OSTaskSuspend_11: (+1)
   \      0x10E   0x2007             MOVS     R0,#+7
   \      0x110   0xF884 0x0026      STRB     R0,[R4, #+38]
   1885                p_tcb->SuspendCtr = 1u;
   \      0x114   0x2001             MOVS     R0,#+1
   \      0x116   0xF884 0x008C      STRB     R0,[R4, #+140]
   1886                CORE_EXIT_ATOMIC();
   \      0x11A   0x0030             MOVS     R0,R6
   \      0x11C   0x.... 0x....      BL       CORE_ExitAtomic
   1887                break;
   \      0x120   0xE029             B.N      ??OSTaskSuspend_15
   1888          
   1889              case OS_TASK_STATE_SUSPENDED:
   1890              case OS_TASK_STATE_DLY_SUSPENDED:
   1891              case OS_TASK_STATE_PEND_SUSPENDED:
   1892              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1893                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)-1) {
   \                     ??OSTaskSuspend_12: (+1)
   \      0x122   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \      0x126   0x28FF             CMP      R0,#+255
   \      0x128   0xD10B             BNE.N    ??OSTaskSuspend_16
   1894                  CORE_EXIT_ATOMIC();
   \      0x12A   0x0030             MOVS     R0,R6
   \      0x12C   0x.... 0x....      BL       CORE_ExitAtomic
   1895                  OS_TRACE_TASK_SUSPEND_EXIT(RTOS_ERR_WOULD_OVF);
   1896                  RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   \      0x130   0x201E             MOVS     R0,#+30
   \      0x132   0x7028             STRB     R0,[R5, #+0]
   \      0x134   0x606F             STR      R7,[R5, #+4]
   \      0x136   0xF44F 0x60ED      MOV      R0,#+1896
   \      0x13A   0x60A8             STR      R0,[R5, #+8]
   \      0x13C   0xF8C5 0x800C      STR      R8,[R5, #+12]
   1897                  return;
   \      0x140   0xE01F             B.N      ??OSTaskSuspend_6
   1898                }
   1899                p_tcb->SuspendCtr++;
   \                     ??OSTaskSuspend_16: (+1)
   \      0x142   0xF894 0x008C      LDRB     R0,[R4, #+140]
   \      0x146   0x1C40             ADDS     R0,R0,#+1
   \      0x148   0xF884 0x008C      STRB     R0,[R4, #+140]
   1900                CORE_EXIT_ATOMIC();
   \      0x14C   0x0030             MOVS     R0,R6
   \      0x14E   0x.... 0x....      BL       CORE_ExitAtomic
   1901                break;
   \      0x152   0xE010             B.N      ??OSTaskSuspend_15
   1902          
   1903              case OS_TASK_STATE_DEL:
   1904          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
   1905                CORE_EXIT_ATOMIC();
   \                     ??OSTaskSuspend_13: (+1)
   \      0x154   0x0030             MOVS     R0,R6
   \      0x156   0x.... 0x....      BL       CORE_ExitAtomic
   1906                OS_TRACE_TASK_SUSPEND_EXIT(RTOS_ERR_INVALID_STATE);
   1907                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
   \      0x15A   0x201F             MOVS     R0,#+31
   \      0x15C   0x7028             STRB     R0,[R5, #+0]
   \      0x15E   0x606F             STR      R7,[R5, #+4]
   \      0x160   0xF240 0x7073      MOVW     R0,#+1907
   \      0x164   0x60A8             STR      R0,[R5, #+8]
   \      0x166   0xF8C5 0x800C      STR      R8,[R5, #+12]
   1908                return;
   \      0x16A   0xE00A             B.N      ??OSTaskSuspend_6
   1909          #endif
   1910          
   1911              default:
   1912                CORE_EXIT_ATOMIC();
   \                     ??OSTaskSuspend_14: (+1)
   \      0x16C   0x0030             MOVS     R0,R6
   \      0x16E   0x.... 0x....      BL       CORE_ExitAtomic
   1913                OS_TRACE_TASK_SUSPEND_EXIT(RTOS_ERR_OS);
   1914                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \      0x172   0x.... 0x....      BL       CPU_SW_Exception
   1915            }
   1916          
   1917            if (OSRunning == OS_STATE_OS_RUNNING) {                       // Only schedule when the kernel is running
   \                     ??OSTaskSuspend_15: (+1)
   \      0x176   0x....             LDR.N    R0,??DataTable15_10
   \      0x178   0x7800             LDRB     R0,[R0, #+0]
   \      0x17A   0x2801             CMP      R0,#+1
   \      0x17C   0xD101             BNE.N    ??OSTaskSuspend_17
   1918              OSSched();
   \      0x17E   0x.... 0x....      BL       OSSched
   1919              OS_TRACE_TASK_SUSPEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
   1920            }
   1921          }
   \                     ??OSTaskSuspend_17: (+1)
   \                     ??OSTaskSuspend_6: (+1)
   \      0x182   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1922          #endif
   1923          
   1924          /****************************************************************************************************//**
   1925           *                                           OSTaskTimeQuantaSet()
   1926           *
   1927           * @brief    Changes the value of the task's specific time slice.
   1928           *
   1929           * @param    p_tcb           Pointer to the TCB of the task to change. If you specify an NULL
   1930           *                           pointer, the current task is assumed.
   1931           *
   1932           * @param    time_quanta     The number of ticks before the CPU is taken away when round-robin
   1933           *                           scheduling is enabled.
   1934           *
   1935           * @param    p_err           Pointer to the variable that will receive one of the following error code(s)
   1936           *                           from this function:
   1937           *                               - RTOS_ERR_NONE
   1938           *
   1939           * @note     (1) If the task referenced by p_tcb is currently running, then the remaining time until
   1940           *               the quanta expires is updated with the new time_quanta only if the new time_quanta
   1941           *               is greater than the remaining time of the previous quanta.
   1942           *******************************************************************************************************/
   1943          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
   1944          void OSTaskTimeQuantaSet(OS_TCB   *p_tcb,
   1945                                   OS_TICK  time_quanta,
   1946                                   RTOS_ERR *p_err)
   1947          {
   1948            uint32_t time_remain;
   1949            CORE_DECLARE_IRQ_STATE;
   1950          
   1951            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   1952          
   1953            //                                                               Not allowed to call from an ISR
   1954            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   1955          
   1956            if (OSSchedRoundRobinEn != DEF_TRUE) {                        // Make sure round-robin has been enabled
   1957              return;
   1958            }
   1959          
   1960            CORE_ENTER_ATOMIC();
   1961            if (p_tcb == DEF_NULL) {
   1962              p_tcb = OSTCBCurPtr;
   1963            }
   1964          
   1965            if (time_quanta == 0u) {
   1966              p_tcb->TimeQuanta = (uint64_t)(((uint64_t)OSSchedRoundRobinDfltTimeQuanta * (uint64_t)sl_sleeptimer_get_timer_frequency()) + (OSCfg_TickRate_Hz - 1u)) / OSCfg_TickRate_Hz;
   1967            } else {
   1968              p_tcb->TimeQuanta = (uint64_t)(((uint64_t)(time_quanta) * (uint64_t)sl_sleeptimer_get_timer_frequency()) + (OSCfg_TickRate_Hz - 1u)) / OSCfg_TickRate_Hz;
   1969            }
   1970          
   1971            if (p_tcb == OSTCBCurPtr) {
   1972              //                                                             p_tcb belongs to a task that is in running state.
   1973              sl_status_t status;
   1974              status = sl_sleeptimer_get_timer_time_remaining(&OSRoundRobinTimer, &time_remain);
   1975              if (status == SL_STATUS_OK) {
   1976                time_remain = DEF_MAX(time_remain, p_tcb->TimeQuanta);
   1977                //                                                           Only stop/restart the sleep timer if needed
   1978                if (p_tcb->TimeQuantaCtr != time_remain) {
   1979                  p_tcb->TimeQuantaCtr = time_remain;
   1980                  sl_sleeptimer_stop_timer(&OSRoundRobinTimer);
   1981                  OS_SchedRoundRobinRestartTimer(p_tcb);
   1982                }
   1983              }
   1984            } else {
   1985              //                                                             p_tcb is for a task that is NOT in running state.
   1986              p_tcb->TimeQuantaCtr = DEF_MAX(p_tcb->TimeQuantaCtr, p_tcb->TimeQuanta);
   1987            }
   1988          
   1989            CORE_EXIT_ATOMIC();
   1990            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   1991          }
   1992          #endif
   1993          
   1994          /********************************************************************************************************
   1995           ********************************************************************************************************
   1996           *                                           INTERNAL FUNCTIONS
   1997           ********************************************************************************************************
   1998           *******************************************************************************************************/
   1999          
   2000          /****************************************************************************************************//**
   2001           *                                           OS_TaskDbgListAdd()
   2002           *
   2003           * @brief    Add a task to the task debug list.
   2004           *
   2005           * @param    p_tcb   Pointer to the TCB to add.
   2006           *
   2007           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2008           *******************************************************************************************************/
   2009          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2010          void OS_TaskDbgListAdd(OS_TCB *p_tcb)
   2011          {
   2012            p_tcb->DbgPrevPtr = DEF_NULL;
   2013            if (OSTaskDbgListPtr == DEF_NULL) {
   2014              p_tcb->DbgNextPtr = DEF_NULL;
   2015            } else {
   2016              p_tcb->DbgNextPtr = OSTaskDbgListPtr;
   2017              OSTaskDbgListPtr->DbgPrevPtr = p_tcb;
   2018            }
   2019            OSTaskDbgListPtr = p_tcb;
   2020          }
   2021          
   2022          /****************************************************************************************************//**
   2023           *                                           OS_TaskDbgListRemove()
   2024           *
   2025           * @brief    Remove a task from the task debug list.
   2026           *
   2027           * @param    p_tcb   Pointer to the TCB to remove.
   2028           *
   2029           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2030           *******************************************************************************************************/
   2031          void OS_TaskDbgListRemove(OS_TCB *p_tcb)
   2032          {
   2033            OS_TCB *p_tcb_next;
   2034            OS_TCB *p_tcb_prev;
   2035          
   2036            p_tcb_prev = p_tcb->DbgPrevPtr;
   2037            p_tcb_next = p_tcb->DbgNextPtr;
   2038          
   2039            if (p_tcb_prev == DEF_NULL) {
   2040              OSTaskDbgListPtr = p_tcb_next;
   2041              if (p_tcb_next != DEF_NULL) {
   2042                p_tcb_next->DbgPrevPtr = DEF_NULL;
   2043              }
   2044              p_tcb->DbgNextPtr = DEF_NULL;
   2045            } else if (p_tcb_next == DEF_NULL) {
   2046              p_tcb_prev->DbgNextPtr = DEF_NULL;
   2047              p_tcb->DbgPrevPtr = DEF_NULL;
   2048            } else {
   2049              p_tcb_prev->DbgNextPtr = p_tcb_next;
   2050              p_tcb_next->DbgPrevPtr = p_tcb_prev;
   2051              p_tcb->DbgNextPtr = DEF_NULL;
   2052              p_tcb->DbgPrevPtr = DEF_NULL;
   2053            }
   2054          }
   2055          #endif
   2056          
   2057          /****************************************************************************************************//**
   2058           *                                               OS_TaskInit()
   2059           *
   2060           * @brief    This function is called by OSInit() to initialize the task management.
   2061           *
   2062           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from this function:
   2063           *                       - RTOS_ERR_NONE
   2064           *
   2065           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2066           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2067          void OS_TaskInit(RTOS_ERR *p_err)
   2068          {
   2069          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2070            OSTaskDbgListPtr = DEF_NULL;
   2071          #endif
   2072          
   2073            OSTaskQty = 0u;                                               // Clear the number of tasks
   \                     OS_TaskInit: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x....             LDR.N    R1,??DataTable15_14
   \        0x4   0x800A             STRH     R2,[R1, #+0]
   2074          
   2075          #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) || (OS_CFG_DBG_EN == DEF_ENABLED))
   2076            OSTaskCtxSwCtr = 0u;                                          // Clear the context switch counter
   2077          #endif
   2078          
   2079            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x7001             STRB     R1,[R0, #+0]
   \        0xA   0x....             LDR.N    R1,??DataTable15_8
   \        0xC   0x6041             STR      R1,[R0, #+4]
   \        0xE   0xF640 0x011F      MOVW     R1,#+2079
   \       0x12   0x6081             STR      R1,[R0, #+8]
   \       0x14   0x....             LDR.N    R1,??DataTable15_15
   \       0x16   0x60C1             STR      R1,[R0, #+12]
   2080          }
   \       0x18   0x4770             BX       LR
   2081          
   2082          /****************************************************************************************************//**
   2083           *                                               OS_TaskInitTCB()
   2084           *
   2085           * @brief    This function is called to initialize a TCB to default values.
   2086           *
   2087           * @param    p_tcb   Pointer to the TCB to initialize.
   2088           *
   2089           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2090           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2091          void OS_TaskInitTCB(OS_TCB *p_tcb)
   2092          {
   \                     OS_TaskInitTCB: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2093            *p_tcb = (OS_TCB){ 0 };
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x219C             MOVS     R1,#+156
   \        0x8   0x.... 0x....      BL       __aeabi_memclr4
   2094          
   2095          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   2096            OS_REG_ID reg_id;
   2097          #endif
   2098          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   2099            OS_TLS_ID id;
   2100          #endif
   2101          
   2102            p_tcb->StkPtr = DEF_NULL;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6020             STR      R0,[R4, #+0]
   2103          
   2104            p_tcb->StkLimitPtr = DEF_NULL;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x60A0             STR      R0,[R4, #+8]
   2105          
   2106            p_tcb->ExtPtr = DEF_NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6060             STR      R0,[R4, #+4]
   2107          
   2108            p_tcb->NextPtr = DEF_NULL;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x60E0             STR      R0,[R4, #+12]
   2109            p_tcb->PrevPtr = DEF_NULL;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x6120             STR      R0,[R4, #+16]
   2110          
   2111          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2112            p_tcb->NamePtr = (CPU_CHAR *)((void *)"?Task");
   2113          #endif
   2114          
   2115          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
   2116            p_tcb->StkBasePtr = DEF_NULL;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6160             STR      R0,[R4, #+20]
   2117          #endif
   2118          
   2119          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2120            p_tcb->TaskEntryAddr = 0u;
   2121            p_tcb->TaskEntryArg = DEF_NULL;
   2122          #endif
   2123          
   2124          #if (OS_CFG_TS_EN == DEF_ENABLED)
   2125            p_tcb->TS = 0u;
   2126          #endif
   2127          
   2128          #if (OS_MSG_EN == DEF_ENABLED)
   2129            p_tcb->MsgPtr = DEF_NULL;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6660             STR      R0,[R4, #+100]
   2130            p_tcb->MsgSize = 0u;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF8A4 0x0068      STRH     R0,[R4, #+104]
   2131          #endif
   2132          
   2133          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
   2134            OS_MsgQInit(&p_tcb->MsgQ,
   2135                        0u);
   2136          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   2137            p_tcb->MsgQPendTime = 0u;
   2138            p_tcb->MsgQPendTimeMax = 0u;
   2139          #endif
   2140          #endif
   2141          
   2142          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   2143            p_tcb->FlagsPend = 0u;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x67A0             STR      R0,[R4, #+120]
   2144            p_tcb->FlagsOpt = 0u;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF8A4 0x0080      STRH     R0,[R4, #+128]
   2145            p_tcb->FlagsRdy = 0u;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x67E0             STR      R0,[R4, #+124]
   2146          #endif
   2147          
   2148          #if (OS_CFG_MON_EN == DEF_ENABLED)
   2149            p_tcb->MonData.p_eval_data = DEF_NULL;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xF8C4 0x0084      STR      R0,[R4, #+132]
   2150            p_tcb->MonData.p_on_eval = DEF_NULL;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xF8C4 0x0088      STR      R0,[R4, #+136]
   2151          #endif
   2152          
   2153          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   2154            for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??OS_TaskInitTCB_0: (+1)
   \       0x4A   0x0001             MOVS     R1,R0
   \       0x4C   0xB2C9             UXTB     R1,R1
   \       0x4E   0x2903             CMP      R1,#+3
   \       0x50   0xDA07             BGE.N    ??OS_TaskInitTCB_1
   2155              p_tcb->RegTbl[reg_id] = 0u;
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0x0002             MOVS     R2,R0
   \       0x56   0xB2D2             UXTB     R2,R2
   \       0x58   0xEB04 0x0282      ADD      R2,R4,R2, LSL #+2
   \       0x5C   0x66D1             STR      R1,[R2, #+108]
   2156            }
   \       0x5E   0x1C40             ADDS     R0,R0,#+1
   \       0x60   0xE7F3             B.N      ??OS_TaskInitTCB_0
   2157          #endif
   2158          
   2159          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   2160            for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
   2161              p_tcb->TLS_Tbl[id] = 0u;
   2162            }
   2163          #endif
   2164          
   2165            p_tcb->SemCtr = 0u;
   \                     ??OS_TaskInitTCB_1: (+1)
   \       0x62   0x2100             MOVS     R1,#+0
   \       0x64   0x63A1             STR      R1,[R4, #+56]
   2166          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   2167            p_tcb->SemPendTime = 0u;
   2168            p_tcb->SemPendTimeMax = 0u;
   2169          #endif
   2170          
   2171            p_tcb->StkSize = 0u;
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0x6321             STR      R1,[R4, #+48]
   2172          
   2173          #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
   2174            p_tcb->SuspendCtr = 0u;
   \       0x6A   0x2100             MOVS     R1,#+0
   \       0x6C   0xF884 0x108C      STRB     R1,[R4, #+140]
   2175          #endif
   2176          
   2177          #if (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED)
   2178            p_tcb->StkFree = 0u;
   \       0x70   0x2100             MOVS     R1,#+0
   \       0x72   0xF8C4 0x1094      STR      R1,[R4, #+148]
   2179            p_tcb->StkUsed = 0u;
   \       0x76   0x2100             MOVS     R1,#+0
   \       0x78   0xF8C4 0x1090      STR      R1,[R4, #+144]
   2180          #endif
   2181          
   2182            p_tcb->Opt = 0u;
   \       0x7C   0x2100             MOVS     R1,#+0
   \       0x7E   0x86A1             STRH     R1,[R4, #+52]
   2183          
   2184          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   2185            p_tcb->TickCtrPrev = 0u;
   \       0x80   0x2100             MOVS     R1,#+0
   \       0x82   0x6421             STR      R1,[R4, #+64]
   2186            p_tcb->IsTickCtrPrevValid = DEF_NO;
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0xF884 0x103C      STRB     R1,[R4, #+60]
   2187          #endif
   2188          
   2189          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
   2190            p_tcb->TimeQuanta = 0u;
   2191            p_tcb->TimeQuantaCtr = 0u;
   2192          #endif
   2193          
   2194          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   2195            p_tcb->CPUUsage = 0u;
   2196            p_tcb->CPUUsageMax = 0u;
   2197            p_tcb->CtxSwCtr = 0u;
   2198            p_tcb->CyclesDelta = 0u;
   2199          #if (OS_CFG_TS_EN == DEF_ENABLED)
   2200            p_tcb->CyclesStart = OS_TS_GET();                             // Read the current timestamp and save
   2201          #else
   2202            p_tcb->CyclesStart = 0u;
   2203          #endif
   2204            p_tcb->CyclesTotal = 0u;
   2205          #endif
   2206          
   2207            p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;
   \       0x8A   0x2100             MOVS     R1,#+0
   \       0x8C   0xF884 0x1024      STRB     R1,[R4, #+36]
   2208            p_tcb->PendStatus = OS_STATUS_PEND_OK;
   \       0x90   0x2100             MOVS     R1,#+0
   \       0x92   0xF884 0x1025      STRB     R1,[R4, #+37]
   2209            p_tcb->TaskState = OS_TASK_STATE_RDY;
   \       0x96   0x2100             MOVS     R1,#+0
   \       0x98   0xF884 0x1026      STRB     R1,[R4, #+38]
   2210          
   2211            p_tcb->Prio = OS_PRIO_INIT;
   \       0x9C   0x2140             MOVS     R1,#+64
   \       0x9E   0xF884 0x1027      STRB     R1,[R4, #+39]
   2212          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2213            p_tcb->BasePrio = OS_PRIO_INIT;
   \       0xA2   0x2140             MOVS     R1,#+64
   \       0xA4   0xF884 0x1028      STRB     R1,[R4, #+40]
   2214            p_tcb->MutexGrpHeadPtr = DEF_NULL;
   \       0xA8   0x2100             MOVS     R1,#+0
   \       0xAA   0x62E1             STR      R1,[R4, #+44]
   2215          #endif
   2216          
   2217          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2218            p_tcb->DbgPrevPtr = DEF_NULL;
   2219            p_tcb->DbgNextPtr = DEF_NULL;
   2220            p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
   2221          #endif
   2222          
   2223          #if (OS_CFG_ERRNO_EN == 1)
   2224            p_tcb->local_errno = 0;
   \       0xAC   0x2100             MOVS     R1,#+0
   \       0xAE   0xF8C4 0x1098      STR      R1,[R4, #+152]
   2225          #endif
   2226          }
   \       0xB2   0xBD10             POP      {R4,PC}
   2227          
   2228          /****************************************************************************************************//**
   2229           *                                               OS_TaskReturn()
   2230           *
   2231           * @brief    This function is called if a task accidentally returns without deleting itself. In other
   2232           *           words, a task should either be an infinite loop or delete itself if it's done.
   2233           *
   2234           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2235           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2236          void OS_TaskReturn(void)
   2237          {
   \                     OS_TaskReturn: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   2238          #if ((OS_CFG_TASK_DEL_EN == DEF_ENABLED) || (OS_CFG_TICK_EN == DEF_ENABLED))
   2239            RTOS_ERR err;
   2240          #endif
   2241          
   2242            OSTaskReturnHook(OSTCBCurPtr);                                // Call hook to let user decide on what to do
   \        0x2   0x....             LDR.N    R0,??DataTable15_4
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x.... 0x....      BL       OSTaskReturnHook
   2243          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
   2244            OSTaskDel(DEF_NULL,                                           // Delete task if it accidentally returns!
   2245                      &err);
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x.... 0x....      BL       OSTaskDel
   2246          #else
   2247          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   2248            while (DEF_TRUE) {
   2249              OSTimeDly(DEF_INT_16U_MAX_VAL,
   2250                        OS_OPT_TIME_DLY,
   2251                        &err);
   2252              (void)err;
   2253            }
   2254          #else
   2255            CPU_SW_EXCEPTION(; );
   2256          #endif
   2257          #endif
   2258          }
   \       0x12   0xB005             ADD      SP,SP,#+20
   \       0x14   0xBD00             POP      {PC}
   2259          
   2260          /****************************************************************************************************//**
   2261           *                                           OS_TaskStkRedzoneChk()
   2262           *
   2263           * @brief    Verify a task's stack redzone.
   2264           *
   2265           * @param    p_base      Pointer to the base of the stack.
   2266           *
   2267           * @param    stk_size    The size of the stack.
   2268           *
   2269           * @return   == DEF_FAIL     If the stack is     corrupted.
   2270           *           == DEF_OK       If the stack is NOT corrupted.
   2271           *
   2272           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2273           *******************************************************************************************************/
   2274          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   2275          CPU_BOOLEAN OS_TaskStkRedzoneChk(CPU_STK      *p_base,
   2276                                           CPU_STK_SIZE stk_size)
   2277          {
   2278            CPU_INT32U i;
   2279          
   2280          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   2281            (void)&stk_size;                                              // Prevent compiler warning for not using 'stk_size'
   2282          
   2283            for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2284              if (*p_base != (CPU_STK)OS_STACK_CHECK_VAL) {
   2285                return (DEF_FAIL);
   2286              }
   2287              p_base++;
   2288            }
   2289          #else
   2290            p_base = p_base + stk_size - 1u;
   2291            for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2292              if (*p_base != (CPU_STK)OS_STACK_CHECK_VAL) {
   2293                return (DEF_FAIL);
   2294              }
   2295              p_base--;
   2296            }
   2297          #endif
   2298          
   2299            return (DEF_OK);
   2300          }
   2301          #endif
   2302          
   2303          /****************************************************************************************************//**
   2304           *                                           OS_TaskStkRedzoneInit()
   2305           *
   2306           * @brief    This functions is used to initialize a stack with Redzone checking.
   2307           *
   2308           * @param    p_base      Pointer to the base of the stack.
   2309           *
   2310           * @param    stk_size    The size of the stack.
   2311           *
   2312           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2313           *******************************************************************************************************/
   2314          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   2315          void OS_TaskStkRedzoneInit(CPU_STK      *p_base,
   2316                                     CPU_STK_SIZE stk_size)
   2317          {
   2318            CPU_STK_SIZE i;
   2319          
   2320          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   2321            (void)&stk_size;                                              // Prevent compiler warning for not using 'stk_size'
   2322          
   2323            for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2324              *(p_base + i) = (CPU_STK)OS_STACK_CHECK_VAL;
   2325            }
   2326          #else
   2327            for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2328              *(p_base + stk_size - 1u - i) = (CPU_STK)OS_STACK_CHECK_VAL;
   2329            }
   2330          #endif
   2331          }
   2332          #endif
   2333          
   2334          /****************************************************************************************************//**
   2335           *                                           OS_TaskChangePrio()
   2336           *
   2337           * @brief    This function is called by the Kernel to perform the actual operation of changing a task's
   2338           *           priority. Priority inheritance is updated if necessary.
   2339           *
   2340           * @param    p_tcb       Pointer to the TCB of the task to change the priority.
   2341           *
   2342           * @param    prio_new    The new priority to give to the task.
   2343           *
   2344           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2345           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2346          void OS_TaskChangePrio(OS_TCB  *p_tcb,
   2347                                 OS_PRIO prio_new)
   2348          {
   \                     OS_TaskChangePrio: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2349            OS_TCB *p_tcb_owner;
   2350          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2351            OS_PRIO prio_cur;
   2352          #endif
   2353          
   2354            do {
   2355              p_tcb_owner = DEF_NULL;
   \                     ??OS_TaskChangePrio_0: (+1)
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x0006             MOVS     R6,R0
   2356          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2357              prio_cur = p_tcb->Prio;
   \        0xA   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \        0xE   0x0007             MOVS     R7,R0
   2358          #endif
   2359              switch (p_tcb->TaskState) {
   \       0x10   0xF894 0x1026      LDRB     R1,[R4, #+38]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD00D             BEQ.N    ??OS_TaskChangePrio_1
   \       0x18   0x1E49             SUBS     R1,R1,#+1
   \       0x1A   0xD020             BEQ.N    ??OS_TaskChangePrio_2
   \       0x1C   0x1E49             SUBS     R1,R1,#+1
   \       0x1E   0x2901             CMP      R1,#+1
   \       0x20   0xD920             BLS.N    ??OS_TaskChangePrio_3
   \       0x22   0x1E89             SUBS     R1,R1,#+2
   \       0x24   0x2901             CMP      R1,#+1
   \       0x26   0xD91A             BLS.N    ??OS_TaskChangePrio_2
   \       0x28   0x1E89             SUBS     R1,R1,#+2
   \       0x2A   0x2901             CMP      R1,#+1
   \       0x2C   0xD91A             BLS.N    ??OS_TaskChangePrio_3
   \       0x2E   0x39F9             SUBS     R1,R1,#+249
   \       0x30   0xD063             BEQ.N    ??OS_TaskChangePrio_4
   \       0x32   0xE063             B.N      ??OS_TaskChangePrio_5
   2360                case OS_TASK_STATE_RDY:
   2361                  OS_RdyListRemove(p_tcb);                                // Remove from current priority
   \                     ??OS_TaskChangePrio_1: (+1)
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       OS_RdyListRemove
   2362                  p_tcb->Prio = prio_new;                                 // Set new task priority
   \       0x3A   0xF884 0x5027      STRB     R5,[R4, #+39]
   2363                  OS_PrioInsert(p_tcb->Prio);
   \       0x3E   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \       0x42   0x.... 0x....      BL       OS_PrioInsert
   2364                  if (p_tcb == OSTCBCurPtr) {
   \       0x46   0x....             LDR.N    R0,??DataTable15_4
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0x4284             CMP      R4,R0
   \       0x4C   0xD103             BNE.N    ??OS_TaskChangePrio_6
   2365                    OS_RdyListInsertHead(p_tcb);
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       OS_RdyListInsertHead
   \       0x54   0xE002             B.N      ??OS_TaskChangePrio_7
   2366                  } else {
   2367                    OS_RdyListInsertTail(p_tcb);
   \                     ??OS_TaskChangePrio_6: (+1)
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       OS_RdyListInsertTail
   2368                  }
   2369                  break;
   \                     ??OS_TaskChangePrio_7: (+1)
   \       0x5C   0xE050             B.N      ??OS_TaskChangePrio_8
   2370          
   2371                case OS_TASK_STATE_DLY:                                   // Nothing to do except change the priority in the OS_TCB
   2372                case OS_TASK_STATE_SUSPENDED:
   2373                case OS_TASK_STATE_DLY_SUSPENDED:
   2374                  p_tcb->Prio = prio_new;                                 // Set new task priority
   \                     ??OS_TaskChangePrio_2: (+1)
   \       0x5E   0xF884 0x5027      STRB     R5,[R4, #+39]
   2375                  break;
   \       0x62   0xE04D             B.N      ??OS_TaskChangePrio_8
   2376          
   2377                case OS_TASK_STATE_PEND:
   2378                case OS_TASK_STATE_PEND_TIMEOUT:
   2379                case OS_TASK_STATE_PEND_SUSPENDED:
   2380                case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2381                  p_tcb->Prio = prio_new;                                 // Set new task priority
   \                     ??OS_TaskChangePrio_3: (+1)
   \       0x64   0xF884 0x5027      STRB     R5,[R4, #+39]
   2382                  switch (p_tcb->PendOn) {                                // What to do depends on what we are pending on
   \       0x68   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \       0x6C   0x2801             CMP      R0,#+1
   \       0x6E   0xD00B             BEQ.N    ??OS_TaskChangePrio_9
   \       0x70   0x2802             CMP      R0,#+2
   \       0x72   0xD03E             BEQ.N    ??OS_TaskChangePrio_10
   \       0x74   0x2804             CMP      R0,#+4
   \       0x76   0xD00B             BEQ.N    ??OS_TaskChangePrio_11
   \       0x78   0x2805             CMP      R0,#+5
   \       0x7A   0xD005             BEQ.N    ??OS_TaskChangePrio_9
   \       0x7C   0x2806             CMP      R0,#+6
   \       0x7E   0xD003             BEQ.N    ??OS_TaskChangePrio_9
   \       0x80   0x2807             CMP      R0,#+7
   \       0x82   0xD036             BEQ.N    ??OS_TaskChangePrio_10
   \       0x84   0x2808             CMP      R0,#+8
   \       0x86   0xD135             BNE.N    ??OS_TaskChangePrio_12
   2383                    case OS_TASK_PEND_ON_FLAG:
   2384                    case OS_TASK_PEND_ON_Q:
   2385                    case OS_TASK_PEND_ON_SEM:
   2386                    case OS_TASK_PEND_ON_COND_VAR:
   2387                      OS_PendListChangePrio(p_tcb);
   \                     ??OS_TaskChangePrio_9: (+1)
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x.... 0x....      BL       OS_PendListChangePrio
   2388                      break;
   \       0x8E   0xE033             B.N      ??OS_TaskChangePrio_13
   2389          
   2390                    case OS_TASK_PEND_ON_MUTEX:
   2391          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2392                      OS_PendListChangePrio(p_tcb);
   \                     ??OS_TaskChangePrio_11: (+1)
   \       0x90   0x0020             MOVS     R0,R4
   \       0x92   0x.... 0x....      BL       OS_PendListChangePrio
   2393                      p_tcb_owner = ((OS_MUTEX *)p_tcb->PendObjPtr)->OwnerTCBPtr;
   \       0x96   0x6A20             LDR      R0,[R4, #+32]
   \       0x98   0x6900             LDR      R0,[R0, #+16]
   \       0x9A   0x0006             MOVS     R6,R0
   2394                      if (prio_cur > prio_new) {                          // Are we increasing the priority?
   \       0x9C   0x0029             MOVS     R1,R5
   \       0x9E   0x0038             MOVS     R0,R7
   \       0xA0   0xB2C9             UXTB     R1,R1
   \       0xA2   0xB2C0             UXTB     R0,R0
   \       0xA4   0x4281             CMP      R1,R0
   \       0xA6   0xD208             BCS.N    ??OS_TaskChangePrio_14
   2395                        if (p_tcb_owner->Prio <= prio_new) {              // Yes, do we need to give this prio to the owner?
   \       0xA8   0x0029             MOVS     R1,R5
   \       0xAA   0xF896 0x0027      LDRB     R0,[R6, #+39]
   \       0xAE   0xB2C9             UXTB     R1,R1
   \       0xB0   0x4281             CMP      R1,R0
   \       0xB2   0xD31D             BCC.N    ??OS_TaskChangePrio_15
   2396                          p_tcb_owner = DEF_NULL;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x0006             MOVS     R6,R0
   \       0xB8   0xE01A             B.N      ??OS_TaskChangePrio_15
   2397                        } else {
   2398                          OS_TRACE_MUTEX_TASK_PRIO_INHERIT(p_tcb_owner, prio_new);
   2399                        }
   2400                      } else {
   2401                        if (p_tcb_owner->Prio == prio_cur) {              // No, is it required to check for a lower prio?
   \                     ??OS_TaskChangePrio_14: (+1)
   \       0xBA   0xF896 0x1027      LDRB     R1,[R6, #+39]
   \       0xBE   0x0038             MOVS     R0,R7
   \       0xC0   0xB2C0             UXTB     R0,R0
   \       0xC2   0x4281             CMP      R1,R0
   \       0xC4   0xD114             BNE.N    ??OS_TaskChangePrio_15
   2402                          prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \       0xC6   0x0030             MOVS     R0,R6
   \       0xC8   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   2403                          prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
   \       0xCC   0xF896 0x2028      LDRB     R2,[R6, #+40]
   \       0xD0   0x0001             MOVS     R1,R0
   \       0xD2   0xB2C9             UXTB     R1,R1
   \       0xD4   0x428A             CMP      R2,R1
   \       0xD6   0xD202             BCS.N    ??OS_TaskChangePrio_16
   \       0xD8   0xF896 0x5028      LDRB     R5,[R6, #+40]
   \       0xDC   0xE000             B.N      ??OS_TaskChangePrio_17
   \                     ??OS_TaskChangePrio_16: (+1)
   \       0xDE   0x0005             MOVS     R5,R0
   2404                          if (prio_new == p_tcb_owner->Prio) {
   \                     ??OS_TaskChangePrio_17: (+1)
   \       0xE0   0x0029             MOVS     R1,R5
   \       0xE2   0xF896 0x0027      LDRB     R0,[R6, #+39]
   \       0xE6   0xB2C9             UXTB     R1,R1
   \       0xE8   0x4281             CMP      R1,R0
   \       0xEA   0xD101             BNE.N    ??OS_TaskChangePrio_15
   2405                            p_tcb_owner = DEF_NULL;
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0x0006             MOVS     R6,R0
   2406                          } else {
   2407                            OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, prio_new);
   2408                          }
   2409                        }
   2410                      }
   2411          #endif
   2412                      break;
   \                     ??OS_TaskChangePrio_15: (+1)
   \       0xF0   0xE002             B.N      ??OS_TaskChangePrio_13
   2413          
   2414                    case OS_TASK_PEND_ON_TASK_Q:
   2415                    case OS_TASK_PEND_ON_TASK_SEM:
   2416                      break;
   \                     ??OS_TaskChangePrio_10: (+1)
   \       0xF2   0xE001             B.N      ??OS_TaskChangePrio_13
   2417          
   2418                    default:
   2419                      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \                     ??OS_TaskChangePrio_12: (+1)
   \       0xF4   0x.... 0x....      BL       CPU_SW_Exception
   2420                  }
   2421                  break;
   \                     ??OS_TaskChangePrio_13: (+1)
   \       0xF8   0xE002             B.N      ??OS_TaskChangePrio_8
   2422          
   2423                case OS_TASK_STATE_DEL:
   2424          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
   2425                  return;
   \                     ??OS_TaskChangePrio_4: (+1)
   \       0xFA   0xE005             B.N      ??OS_TaskChangePrio_18
   2426          #endif
   2427          
   2428                default:
   2429                  RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \                     ??OS_TaskChangePrio_5: (+1)
   \       0xFC   0x.... 0x....      BL       CPU_SW_Exception
   2430              }
   2431              p_tcb = p_tcb_owner;
   \                     ??OS_TaskChangePrio_8: (+1)
   \      0x100   0x0034             MOVS     R4,R6
   2432            } while (p_tcb != DEF_NULL);
   \      0x102   0x2C00             CMP      R4,#+0
   \      0x104   0xF47F 0xAF7F      BNE.W    ??OS_TaskChangePrio_0
   2433          }
   \                     ??OS_TaskChangePrio_18: (+1)
   \      0x108   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     `OSTaskChangePrio::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     `OSTaskCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     `OSTaskDel::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x....'....        DC32     `OSTaskRegGet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x....'....        DC32     `OSTaskRegGetID::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x....'....        DC32     `OSTaskRegSet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x....'....        DC32     `OSTaskResume::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0x....'....        DC32     `OSTaskSemPend::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \        0x0   0x....'....        DC32     `OSTaskSemPendAbort::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \        0x0   0x....'....        DC32     `OSTaskSemPost::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \        0x0   0x....'....        DC32     `OSTaskSemSet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \        0x0   0x....'....        DC32     `OSTaskStkChk::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \        0x0   0x....'....        DC32     `OSTaskSuspend::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \        0x0   0x....'....        DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \        0x0   0x....'....        DC32     `OS_TaskInit::__func__`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x6B, 0x65, 0x72, 0x6E, 0x65
   \              0x5C 0x6B    
   \              0x65 0x72    
   \              0x6E 0x65
   \       0x58   0x6C 0x5C          DC8 0x6C, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65
   \       0x60   0x5C 0x6F          DC8 0x5C, 0x6F, 0x73, 0x5F, 0x74, 0x61, 0x73, 0x6B
   \              0x73 0x5F    
   \              0x74 0x61    
   \              0x73 0x6B
   \       0x68   0x2E 0x63          DC8 0x2E, 0x63, 0
   \              0x00
   \       0x6B                      DS8 1
   2434          
   2435          /********************************************************************************************************
   2436           ********************************************************************************************************
   2437           *                                   DEPENDENCIES & AVAIL CHECK(S) END
   2438           ********************************************************************************************************
   2439           *******************************************************************************************************/
   2440          
   2441          #endif // (defined(RTOS_MODULE_KERNEL_AVAIL))

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTaskChangePrio
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CORE_InIrqContext
        24   -> CPU_SW_Exception
        24   -> OSSched
        24   -> OS_MutexGrpPrioFindHighest
        24   -> OS_TaskChangePrio
      64   OSTaskCreate
        64   -> CORE_EnterAtomic
        64   -> CORE_ExitAtomic
        64   -> CORE_InIrqContext
        64   -> CPU_SW_Exception
        64   -> OSSched
        64   -> OSTaskCreateHook
        64   -> OSTaskStkInit
        64   -> OS_PrioInsert
        64   -> OS_RdyListInsertTail
        64   -> OS_TaskInitTCB
      32   OSTaskDel
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> CORE_InIrqContext
        32   -> CPU_SW_Exception
        32   -> OSSched
        32   -> OSTaskDelHook
        32   -> OS_MutexGrpPostAll
        32   -> OS_MutexGrpPrioFindHighest
        32   -> OS_PendListRemove
        32   -> OS_RdyListRemove
        32   -> OS_TaskChangePrio
        32   -> OS_TaskInitTCB
        32   -> sl_sleeptimer_stop_timer
      24   OSTaskRegGet
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CPU_SW_Exception
      16   OSTaskRegGetID
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> CPU_SW_Exception
      24   OSTaskRegSet
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CPU_SW_Exception
      24   OSTaskResume
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CORE_InIrqContext
        24   -> CPU_SW_Exception
        24   -> OSSched
        24   -> OS_RdyListInsert
      32   OSTaskSemPend
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> CORE_InIrqContext
        32   -> CPU_SW_Exception
        32   -> OSSched
        32   -> OS_Pend
      32   OSTaskSemPendAbort
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> CORE_InIrqContext
        32   -> CPU_SW_Exception
        32   -> OSSched
        32   -> OS_PendAbort
      40   OSTaskSemPost
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> CPU_SW_Exception
        40   -> OSSched
        40   -> OS_Post
      24   OSTaskSemSet
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CORE_InIrqContext
        24   -> CPU_SW_Exception
      24   OSTaskStkChk
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CORE_InIrqContext
        24   -> CPU_SW_Exception
      24   OSTaskSuspend
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CORE_InIrqContext
        24   -> CPU_SW_Exception
        24   -> OSSched
        24   -> OS_RdyListRemove
      24   OS_TaskChangePrio
        24   -> CPU_SW_Exception
        24   -> OS_MutexGrpPrioFindHighest
        24   -> OS_PendListChangePrio
        24   -> OS_PrioInsert
        24   -> OS_RdyListInsertHead
        24   -> OS_RdyListInsertTail
        24   -> OS_RdyListRemove
       0   OS_TaskInit
       8   OS_TaskInitTCB
         8   -> __aeabi_memclr4
      24   OS_TaskReturn
        24   -> OSTaskDel
        24   -> OSTaskReturnHook


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable11
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
     108  ?_0
     290  OSTaskChangePrio
     532  OSTaskCreate
     500  OSTaskDel
     114  OSTaskRegGet
     102  OSTaskRegGetID
     112  OSTaskRegSet
     394  OSTaskResume
     432  OSTaskSemPend
     296  OSTaskSemPendAbort
     390  OSTaskSemPost
     168  OSTaskSemSet
     284  OSTaskStkChk
     390  OSTaskSuspend
     266  OS_TaskChangePrio
      26  OS_TaskInit
     180  OS_TaskInitTCB
      22  OS_TaskReturn
     380  -- Other

 
   488 bytes in section .rodata
 4'598 bytes in section .text
 
 4'598 bytes of CODE  memory
   488 bytes of CONST memory

Errors: none
Warnings: none
