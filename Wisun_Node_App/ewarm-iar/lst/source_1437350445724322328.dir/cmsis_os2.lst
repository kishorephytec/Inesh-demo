###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:52:59
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\cmsis_os2.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\cmsis_os2.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\cmsis_os2.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\cmsis_os2.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir\cmsis_os2.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\cmsis_os2.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\cmsis_os2.c
      1          /***************************************************************************//**
      2           * @file cmsis_os2.c
      3           * @brief CMSIS-RTOS2 -> MicriumOS Emulation Layer
      4           ******************************************************************************/
      5          
      6          /***************************************************************************//**
      7           * # License
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     13           * software is Third Party Software licensed by Silicon Labs from a third party
     14           * and is governed by the sections of the MSLA applicable to Third Party
     15           * Software and the additional terms set forth below.
     16           *
     17           ******************************************************************************/
     18          
     19          /***************************************************************************//**
     20           * Copyright (c) , Arm Limited and affiliates.
     21           * SPDX-License-Identifier: Apache-2.0
     22           *
     23           * Licensed under the Apache License, Version 2.0 (the "License");
     24           * you may not use this file except in compliance with the License.
     25           * You may obtain a copy of the License at
     26           *
     27           *     http://www.apache.org/licenses/LICENSE-2.0
     28           *
     29           * Unless required by applicable law or agreed to in writing, software
     30           * distributed under the License is distributed on an "AS IS" BASIS,
     31           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     32           * See the License for the specific language governing permissions and
     33           * limitations under the License.
     34           ******************************************************************************/
     35          
     36          /*
     37           ****************************************************************************************************
     38           ****************************************************************************************************
     39           *                                         I N C L U D E S
     40           ****************************************************************************************************
     41           ****************************************************************************************************
     42           */
     43          
     44          #include <string.h>
     45          #include <stdlib.h>
     46          
     47          #include "kernel/include/os.h"
     48          #include "em_core.h"
     49          #include "rtos_err.h"
     50          #include "cmsis_os2.h"
     51          #include "sl_cmsis_os2_common.h"
     52          #include "common/source/rtos/rtos_utils_priv.h"
     53          #include "sl_sleeptimer.h"
     54          
     55          /*
     56           ****************************************************************************************************
     57           ****************************************************************************************************
     58           *                                      F I L E   G L O B A L S
     59           ****************************************************************************************************
     60           ****************************************************************************************************
     61           */
     62          
     63          #define CMSIS_DEFAULT_STACK_SIZE 1024u
     64          #define RTOS_MODULE_CUR RTOS_CFG_MODULE_KERNEL
     65          
     66          #if defined CMSIS_RTOS2_TIMER_TASK_EN && (CMSIS_RTOS2_TIMER_TASK_EN == DEF_ENABLED)
     67          
     68          #ifndef CMSIS_RTOS2_TIMER_TASK_STACK_SIZE
     69          #error CMSIS Timer task stack size not configured
     70          #endif
     71          
     72          #ifndef CMSIS_RTOS2_TIMER_TASK_PRIO
     73          #error CMSIS Timer task priority not configured
     74          #endif
     75          
     76          #ifndef CMSIS_RTOS2_TIMER_TASK_QUEUE_SIZE
     77          #error CMSIS Timer task queue size not configured
     78          #endif
     79          
     80          static OS_TCB   timer_task_tcb;
     81          static CPU_STK  timer_task_stack[CMSIS_RTOS2_TIMER_TASK_STACK_SIZE];
     82          static OS_Q     timer_msg_queue;
     83          
     84          #endif
     85          
     86          /********************************************************************************************************
     87           ********************************************************************************************************
     88           *                                 L O C A L   F U N C T I O N S
     89           ********************************************************************************************************
     90           *******************************************************************************************************/
     91          #if defined CMSIS_RTOS2_TIMER_TASK_EN && (CMSIS_RTOS2_TIMER_TASK_EN == DEF_ENABLED)
     92          
     93          static void sleeptimer_callback(sl_sleeptimer_timer_handle_t *handle, void *data)
     94          {
     95            RTOS_ERR err;
     96            (void)handle;
     97          
     98            OSQPost(&timer_msg_queue,
     99                    (void *)data,
    100                    sizeof(void *),
    101                    OS_OPT_POST_FIFO,
    102                    &err
    103                    );
    104            RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(err) == RTOS_ERR_NONE), RTOS_ERR_CODE_GET(err),; );
    105          }
    106          
    107          static void timer_task(void *arg)
    108          {
    109            RTOS_ERR err;
    110            OS_MSG_SIZE size;
    111            osTimer_t *p_tmr;
    112            (void)arg;
    113          
    114            while (1) {
    115              p_tmr = (osTimer_t *)OSQPend(&timer_msg_queue,
    116                                           0,
    117                                           OS_OPT_PEND_BLOCKING,
    118                                           &size,
    119                                           NULL,
    120                                           &err);
    121              if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
    122                continue;
    123              }
    124          
    125              if (p_tmr != NULL) {
    126                p_tmr->callback(p_tmr->callback_data);
    127              }
    128            }
    129          }
    130          #endif
    131          
    132          /********************************************************************************************************
    133           ********************************************************************************************************
    134           *                                 G L O B A L   F U N C T I O N S
    135           ********************************************************************************************************
    136           *******************************************************************************************************/
    137          
    138          /*
    139           ****************************************************************************************************
    140           ****************************************************************************************************
    141           *                            I N F O R M A T I O N   A N D   C O N T R O L
    142           ****************************************************************************************************
    143           ****************************************************************************************************
    144           */
    145          
    146          /*
    147           ****************************************************************************************************
    148           *                                       osKernelInitialize()
    149           *
    150           * Description: The function 'osKernelInitialize()' initializes the RTOS Kernel.  Before it is successfully
    151           *              executed, only the functions 'osKernelGetInfo()' and 'osKernelGetState()' may be called.
    152           *
    153           * Arguments  : None
    154           *
    155           * Returns    : osOK             in case of success.
    156           *              osError          if an unspecific error occurred.
    157           *              osErrorISR       if called from an Interrupt Service Routine.
    158           *              osErrorNoMemory  if no memory could be reserved for the operation.
    159           *
    160           * Note(s)    : 1) This function CANNOT be called from an ISR
    161           ****************************************************************************************************
    162           */

   \                                 In section .text, align 2, keep-with-next
    163          osStatus_t  osKernelInitialize(void)
    164          {
   \                     osKernelInitialize: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    165            RTOS_ERR   err;
    166          
    167            if (OSRunning == OS_STATE_OS_RUNNING) {
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable11
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD109             BNE.N    ??osKernelInitialize_0
    168              if (CORE_InIrqContext() == true) {
   \        0xC   0x.... 0x....      BL       CORE_InIrqContext
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD102             BNE.N    ??osKernelInitialize_1
    169                return osErrorISR;
   \       0x14   0xF07F 0x0005      MVNS     R0,#+5
   \       0x18   0xE014             B.N      ??osKernelInitialize_2
    170              } else {
    171                return osError;
   \                     ??osKernelInitialize_1: (+1)
   \       0x1A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1E   0xE011             B.N      ??osKernelInitialize_2
    172              }
    173            }
    174          
    175            OSInit(&err);
   \                     ??osKernelInitialize_0: (+1)
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x.... 0x....      BL       OSInit
    176          
    177            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x26   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD002             BEQ.N    ??osKernelInitialize_3
    178              return osError;
   \       0x2E   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x32   0xE007             B.N      ??osKernelInitialize_2
    179            }
    180          
    181          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    182            OSSchedRoundRobinCfg(DEF_TRUE, 0, &err);
    183          #endif
    184          
    185            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \                     ??osKernelInitialize_3: (+1)
   \       0x34   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD002             BEQ.N    ??osKernelInitialize_4
    186              return osError;
   \       0x3C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x40   0xE000             B.N      ??osKernelInitialize_2
    187            }
    188          
    189          #if defined CMSIS_RTOS2_TIMER_TASK_EN && (CMSIS_RTOS2_TIMER_TASK_EN == DEF_ENABLED)
    190            OSTaskCreate(&timer_task_tcb,
    191                         "CMSIS RTOS2 Timer Task",
    192                         timer_task,
    193                         (void *)0,
    194                         CMSIS_RTOS2_TIMER_TASK_PRIO,
    195                         &timer_task_stack[0],
    196                         ((CMSIS_RTOS2_TIMER_TASK_STACK_SIZE * 10u) / 100u),
    197                         CMSIS_RTOS2_TIMER_TASK_STACK_SIZE,
    198                         0,
    199                         0,
    200                         (void *)0,
    201                         OS_OPT_TASK_STK_CHK + OS_OPT_TASK_STK_CLR,
    202                         &err);
    203            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
    204              return osError;
    205            }
    206          
    207            OSQCreate(&timer_msg_queue,
    208                      "CMSIS RTOS2 Timer Queue",
    209                      CMSIS_RTOS2_TIMER_TASK_QUEUE_SIZE,
    210                      &err);
    211            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
    212              return osError;
    213            }
    214          
    215          #endif
    216            return osOK;
   \                     ??osKernelInitialize_4: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \                     ??osKernelInitialize_2: (+1)
   \       0x44   0xB005             ADD      SP,SP,#+20
   \       0x46   0xBD00             POP      {PC}
    217          }
    218          
    219          /*
    220           ****************************************************************************************************
    221           *                                       osKernelGetInfo()
    222           *
    223           * Description: The function 'osKernelGetInfo()' retrieves the API and kernel version of the underlying
    224           *              RTOS kernel and a human readable identifier string for the kernel.  It can be safely
    225           *              called before the RTOS is initialized or started (call to 'osKernelInitialize()' or
    226           *              'osKernelStart()').
    227           *
    228           * Arguments  : version          pointer to a buffer for retrieving the version information.
    229           *                               Format (decimal):
    230           *                                 MMmmmrrrr
    231           *                                    MM  : Major
    232           *                                    mmm : Minor
    233           *                                    rrrr: Revision
    234           *
    235           *              id_buf           pointer to the buffer for retrieving kernel identification string.
    236           *
    237           *              id_size          size    of the buffer for the kernel identification string
    238           *
    239           * Returns    : osOK             in case of success.
    240           *              osError          if an unspecific error occurred.
    241           *
    242           * Note(s)    : None
    243           ****************************************************************************************************
    244           */

   \                                 In section .text, align 2, keep-with-next
    245          osStatus_t  osKernelGetInfo(osVersion_t   *version,
    246                                      char          *id_buf,
    247                                      uint32_t      id_size)
    248          {
   \                     osKernelGetInfo: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
    249            CPU_INT16U  os_version;
    250            RTOS_ERR    err;
    251            uint32_t    os_major;
    252            uint32_t    os_minor;
    253            uint32_t    os_revision;
    254          
    255            if (id_buf == (char *)0) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??osKernelGetInfo_0
    256              return osError;
   \        0xE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x12   0xE032             B.N      ??osKernelGetInfo_1
    257            }
    258          
    259            if (id_size < 20u) {
   \                     ??osKernelGetInfo_0: (+1)
   \       0x14   0x2E14             CMP      R6,#+20
   \       0x16   0xD202             BCS.N    ??osKernelGetInfo_2
    260              return osError;
   \       0x18   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1C   0xE02D             B.N      ??osKernelGetInfo_1
    261            }
    262          
    263            os_version = OSVersion(&err);
   \                     ??osKernelGetInfo_2: (+1)
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x.... 0x....      BL       OSVersion
   \       0x24   0x0007             MOVS     R7,R0
    264          
    265            os_major = os_version / 10000u;
   \       0x26   0x0039             MOVS     R1,R7
   \       0x28   0xB289             UXTH     R1,R1
   \       0x2A   0xF242 0x7010      MOVW     R0,#+10000
   \       0x2E   0xFBB1 0xF8F0      UDIV     R8,R1,R0
    266            os_minor = (os_version - os_major * 10000u) / 100u;
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x36   0xFB00 0xF008      MUL      R0,R0,R8
   \       0x3A   0xFA10 0xF187      UXTAH    R1,R0,R7
   \       0x3E   0x2064             MOVS     R0,#+100
   \       0x40   0xFBB1 0xF9F0      UDIV     R9,R1,R0
    267            os_revision = os_version % 100u;
   \       0x44   0x46BA             MOV      R10,R7
   \       0x46   0xFA1F 0xFA8A      UXTH     R10,R10
   \       0x4A   0x2164             MOVS     R1,#+100
   \       0x4C   0xFBBA 0xF0F1      UDIV     R0,R10,R1
   \       0x50   0xFB01 0xAA10      MLS      R10,R1,R0,R10
    268            version->api = (os_major * 10000000u)
    269                           + (os_minor *    10000u)
    270                           +  os_revision;
   \       0x54   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \       0x58   0xF242 0x7010      MOVW     R0,#+10000
   \       0x5C   0xFB00 0xF009      MUL      R0,R0,R9
   \       0x60   0xFB01 0x0108      MLA      R1,R1,R8,R0
   \       0x64   0xEB1A 0x0101      ADDS     R1,R10,R1
   \       0x68   0x6029             STR      R1,[R5, #+0]
    271            version->kernel = version->api;
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x6068             STR      R0,[R5, #+4]
    272          
    273            strcpy(id_buf, "MicriumOS");
   \       0x6E   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0x.... 0x....      BL       strcpy
    274          
    275            return osOK;
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??osKernelGetInfo_1: (+1)
   \       0x7A   0xB004             ADD      SP,SP,#+16
   \       0x7C   0xE8BD 0x87F0      POP      {R4-R10,PC}
    276          }
    277          
    278          /*
    279           ****************************************************************************************************
    280           *                                       osKernelGetState()
    281           *
    282           * Description: The function 'osKernelGetState()' returns the current state of the kernel and can be
    283           *              safely called before the RTOS is initialized or started (call to 'osKernelInitialize()'
    284           *              or 'osKernelStart()').
    285           *
    286           *              In case it fails it will return 'osKernelError', otherwise it returns the kernel state
    287           *              (refer to 'osKernelState_t' for the list of kernel states).
    288           *
    289           * Arguments  : None
    290           *
    291           * Returns    : osKernelInactive        The kernel is not ready yet
    292           *              osKernelReady           The kernel is not running yet
    293           *              osKernelRunning         The kernel is initialized and running
    294           *              osKernelLocked          The kernel was locked by 'OSKernelLock()'
    295           *              osKernelSuspended       The kernel was suspended by 'OSKernelSuspend()'    (NOT SUPPORTED)
    296           *              osKernelError           An error occurred
    297           *              osKernelReserved        Prevents enum down-size compiler optimization
    298           *
    299           * Note(s)    : None
    300           ****************************************************************************************************
    301           */

   \                                 In section .text, align 2, keep-with-next
    302          osKernelState_t  osKernelGetState(void)
    303          {
    304            if (OSInitialized == DEF_TRUE) {
   \                     osKernelGetState: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD10F             BNE.N    ??osKernelGetState_0
    305              if (OSRunning == OS_STATE_OS_RUNNING) {
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable11
   \        0xE   0x7800             LDRB     R0,[R0, #+0]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD108             BNE.N    ??osKernelGetState_1
    306                if (OSSchedLockNestingCtr > 0u) {
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \       0x18   0x7800             LDRB     R0,[R0, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??osKernelGetState_2
    307                  return osKernelLocked;
   \       0x1E   0x2003             MOVS     R0,#+3
   \       0x20   0xE004             B.N      ??osKernelGetState_3
    308                } else {
    309                  return osKernelRunning;
   \                     ??osKernelGetState_2: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0xE002             B.N      ??osKernelGetState_3
    310                }
    311              } else {
    312                return osKernelReady;
   \                     ??osKernelGetState_1: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE000             B.N      ??osKernelGetState_3
    313              }
    314            }
    315          
    316            return osKernelInactive;
   \                     ??osKernelGetState_0: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??osKernelGetState_3: (+1)
   \       0x2C   0x4770             BX       LR
    317          }
    318          
    319          /*
    320           ****************************************************************************************************
    321           *                                         osKernelStart()
    322           *
    323           * Description: The function 'osKernelStart()' starts the RTOS kernel and begins thread switching.
    324           *              It will not return to its calling function in case of success.  Before it is successfully
    325           *              executed, only the functions 'osKernelGetInfo()', 'osKernelGetState()', and object creation
    326           *              functions ('osXxxNew()') may be called.
    327           *
    328           *              At least one initial thread should be created prior 'osKernelStart()', see 'osThreadNew()'.
    329           *
    330           * Arguments  : None
    331           *
    332           * Returns    : osError                 If an unspecified error occurs
    333           *              osErrorISR              If called from an ISR
    334           *
    335           * Note(s)    : 1) This function cannot be called from Interrupt Service Routines
    336           *
    337           *              2) This function should not be called because MicriumOS should already be initialized.
    338           *
    339           *              3) CMSIS-RTOS2 requires atleast 56 priority levels. OS_CFG_PRIO_MAX must be >= 56.
    340           ****************************************************************************************************
    341           */

   \                                 In section .text, align 2, keep-with-next
    342          osStatus_t  osKernelStart(void)
    343          {
   \                     osKernelStart: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    344            RTOS_ERR  err;
    345          
    346            if (CORE_InIrqContext() == true) {
   \        0x2   0x.... 0x....      BL       CORE_InIrqContext
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD102             BNE.N    ??osKernelStart_0
    347              return osErrorISR;
   \        0xA   0xF07F 0x0005      MVNS     R0,#+5
   \        0xE   0xE00C             B.N      ??osKernelStart_1
    348            }
    349          
    350            if (OSRunning == OS_STATE_OS_RUNNING) {
   \                     ??osKernelStart_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \       0x14   0x7800             LDRB     R0,[R0, #+0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD102             BNE.N    ??osKernelStart_2
    351              return osError;
   \       0x1A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1E   0xE004             B.N      ??osKernelStart_1
    352            }
    353          
    354          #if OS_CFG_PRIO_MAX >= osMinNumPriority
    355            OSStart(&err);
   \                     ??osKernelStart_2: (+1)
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x.... 0x....      BL       OSStart
    356          
    357            (void)err;   // There is no point in checking the error here
    358                         // because the function will not return in case of success
    359          
    360            return osError;
   \       0x26   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??osKernelStart_1: (+1)
   \       0x2A   0xB005             ADD      SP,SP,#+20
   \       0x2C   0xBD00             POP      {PC}
    361          #else
    362            (void)err;
    363            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);   // CMSIS-RTOS2 requires atleast 56 priority levels
    364            return osError;
    365          #endif
    366          }
    367          
    368          /*
    369           ****************************************************************************************************
    370           *                                         osKernelLock()
    371           *
    372           * Description: The function 'osKernelLock()' allows to lock all task switches.  It returns the previous
    373           *              value of the lock state (1 if it was locked, 0 if it was unlocked), or a negative number
    374           *              representing an error code otherwise (refer to 'osStatus_t').
    375           *
    376           * Arguments  : None
    377           *
    378           * Returns    : osError                 If an unspecified error occurs
    379           *              osErrorISR              If called from an ISR
    380           *
    381           * Note(s)    : 1) This function cannot be called from Interrupt Service Routines
    382           *
    383           *              2) The MicriumOS equivalent function can be called from an ISR.
    384           ****************************************************************************************************
    385           */

   \                                 In section .text, align 2, keep-with-next
    386          int32_t  osKernelLock(void)
    387          {
   \                     osKernelLock: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    388            RTOS_ERR  err;
    389          
    390            if (CORE_InIrqContext() == true) {
   \        0x2   0x.... 0x....      BL       CORE_InIrqContext
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD102             BNE.N    ??osKernelLock_0
    391              return osErrorISR;
   \        0xA   0xF07F 0x0005      MVNS     R0,#+5
   \        0xE   0xE011             B.N      ??osKernelLock_1
    392            }
    393          
    394            if (OSSchedLockNestingCtr > 0u) {
   \                     ??osKernelLock_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \       0x14   0x7800             LDRB     R0,[R0, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??osKernelLock_2
    395              return 1u;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE00A             B.N      ??osKernelLock_1
    396            }
    397          
    398            OSSchedLock(&err);
   \                     ??osKernelLock_2: (+1)
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x.... 0x....      BL       OSSchedLock
    399          
    400            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x24   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??osKernelLock_3
    401              return osError;
   \       0x2C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x30   0xE000             B.N      ??osKernelLock_1
    402            }
    403          
    404            return 0u;
   \                     ??osKernelLock_3: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??osKernelLock_1: (+1)
   \       0x34   0xB005             ADD      SP,SP,#+20
   \       0x36   0xBD00             POP      {PC}
    405          }
    406          
    407          /*
    408           ****************************************************************************************************
    409           *                                         osKernelUnlock()
    410           *
    411           * Description: The function 'osKernelUnlock()' resumes from 'osKernelLock()'.  It returns the previous
    412           *              value of the lock state (1 if it was locked, 0 if it was unlocked), or a negative number
    413           *              representing an error code otherwise (refer to 'osStatus_t').
    414           *
    415           * Arguments  : None
    416           *
    417           * Returns    : osError                 If an unspecified error occurs
    418           *              osErrorISR              If called from an ISR
    419           *
    420           * Note(s)    : 1) This function cannot be called from Interrupt Service Routines
    421           *
    422           *              2) The MicriumOS equivalent function can be called from an ISR.
    423           *
    424           *              3) MicriumOS supports multiple lock levels but CMSIS-RTOS doesn't
    425           ****************************************************************************************************
    426           */

   \                                 In section .text, align 2, keep-with-next
    427          int32_t  osKernelUnlock(void)
    428          {
   \                     osKernelUnlock: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
    429            OS_NESTING_CTR  ctr;
    430            RTOS_ERR        err;
    431          
    432            if (CORE_InIrqContext() == true) {
   \        0x2   0x.... 0x....      BL       CORE_InIrqContext
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD102             BNE.N    ??osKernelUnlock_0
    433              return osErrorISR;
   \        0xA   0xF07F 0x0005      MVNS     R0,#+5
   \        0xE   0xE014             B.N      ??osKernelUnlock_1
    434            }
    435          
    436            ctr = OSSchedLockNestingCtr;                    // Get the current value of the lock counter
   \                     ??osKernelUnlock_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \       0x14   0x7804             LDRB     R4,[R0, #+0]
    437          
    438            if (ctr > 1u) {                                 // CMSIS-RTOS only supports 1 lock level
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x2802             CMP      R0,#+2
   \       0x1C   0xD301             BCC.N    ??osKernelUnlock_2
    439              ctr = 1u;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x0004             MOVS     R4,R0
    440            }
    441          
    442            OSSchedUnlock(&err);
   \                     ??osKernelUnlock_2: (+1)
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x.... 0x....      BL       OSSchedUnlock
    443            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x28   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD002             BEQ.N    ??osKernelUnlock_3
    444              return osError;
   \       0x30   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x34   0xE001             B.N      ??osKernelUnlock_1
    445            }
    446          
    447            return ctr;
   \                     ??osKernelUnlock_3: (+1)
   \       0x36   0xB2E4             UXTB     R4,R4
   \       0x38   0x0020             MOVS     R0,R4
   \                     ??osKernelUnlock_1: (+1)
   \       0x3A   0xB004             ADD      SP,SP,#+16
   \       0x3C   0xBD10             POP      {R4,PC}
    448          }
    449          
    450          /*
    451           ****************************************************************************************************
    452           *                                         osKernelRestoreLock()
    453           *
    454           * Description: The function 'osKernelRestoreLock()' restores the previous lock state after 'osKernelLock()'
    455           *              or 'osKernelUnlock()'.
    456           *
    457           *              The argument lock specifies the lock state as obtained by 'osKernelLock()' or 'osKernelUnlock()'.
    458           *
    459           *              The function returns the new value of the lock state (1 if it was locked, 0 if it was unlocked),
    460           *              or a negative number representing an error code otherwise (refer to 'osStatus_t').
    461           *
    462           * Arguments  : lock                    new lock state: 1 == locked, 0 == not locked
    463           *
    464           * Returns    : osError                 If an unspecified error occurs
    465           *              osErrorISR              If called from an ISR
    466           *
    467           * Note(s)    : 1) This function cannot be called from Interrupt Service Routines
    468           *
    469           *              2) There are no MicriumOS equivalent function to emulate this behavior.
    470           ****************************************************************************************************
    471           */

   \                                 In section .text, align 2, keep-with-next
    472          int32_t  osKernelRestoreLock(int32_t  lock)
    473          {
   \                     osKernelRestoreLock: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    474            int32_t  new_state;
    475            RTOS_ERR   err;
    476          
    477            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD102             BNE.N    ??osKernelRestoreLock_0
    478              return osErrorISR;
   \        0xC   0xF07F 0x0005      MVNS     R0,#+5
   \       0x10   0xE012             B.N      ??osKernelRestoreLock_1
    479            }
    480          
    481            if (lock > 0) {
   \                     ??osKernelRestoreLock_0: (+1)
   \       0x12   0x2C01             CMP      R4,#+1
   \       0x14   0xDB04             BLT.N    ??osKernelRestoreLock_2
    482              OSSchedLock(&err);
   \       0x16   0x4668             MOV      R0,SP
   \       0x18   0x.... 0x....      BL       OSSchedLock
    483              new_state = 1u;
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0xE003             B.N      ??osKernelRestoreLock_3
    484            } else {
    485              OSSchedUnlock(&err);
   \                     ??osKernelRestoreLock_2: (+1)
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x.... 0x....      BL       OSSchedUnlock
    486              new_state = 0u;
   \       0x26   0x2100             MOVS     R1,#+0
    487            }
    488          
    489            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \                     ??osKernelRestoreLock_3: (+1)
   \       0x28   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD002             BEQ.N    ??osKernelRestoreLock_4
    490              return osError;
   \       0x30   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x34   0xE000             B.N      ??osKernelRestoreLock_1
    491            }
    492          
    493            return new_state;
   \                     ??osKernelRestoreLock_4: (+1)
   \       0x36   0x0008             MOVS     R0,R1
   \                     ??osKernelRestoreLock_1: (+1)
   \       0x38   0xB004             ADD      SP,SP,#+16
   \       0x3A   0xBD10             POP      {R4,PC}
    494          }
    495          
    496          /*
    497           ****************************************************************************************************
    498           *                                          osKernelSuspend()
    499           *
    500           * Description: CMSIS-RTOS provides extension for tick-less operation which is useful for applications
    501           *              that use extensively low-power modes where the SysTick timer is also disabled.  To provide
    502           *              a time-tick in such power-saving modes a wake-up timer is used to derive timer intervals.
    503           *              The function 'osKernelSuspend()' suspends the RTX kernel scheduler and thus enables sleep
    504           *              modes.
    505           *
    506           *              The return value can be used to determine the amount of system ticks until the next
    507           *              tick-based kernel event will occure, i.e. a delayed thread becomed ready again. It is
    508           *              recommended to set up the low power timer to generate a wake-up interrupt based on this
    509           *              return value.
    510           *
    511           * Arguments  : None
    512           *
    513           * Returns    : time in 'ticks', for how long the system can sleep or power-down
    514           *
    515           * Note(s)    : 1) This function cannot be called from Interrupt Service Routines
    516           *
    517           *              2) There are no MicriumOS equivalent function to emulate this behavior.
    518           ****************************************************************************************************
    519           */

   \                                 In section .text, align 2, keep-with-next
    520          uint32_t  osKernelSuspend(void)
    521          {
   \                     osKernelSuspend: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    522            if (CORE_InIrqContext() == true) {
   \        0x2   0x.... 0x....      BL       CORE_InIrqContext
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??osKernelSuspend_0
    523              return 0u;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE000             B.N      ??osKernelSuspend_1
    524            }
    525          
    526            return 0u;
   \                     ??osKernelSuspend_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??osKernelSuspend_1: (+1)
   \       0x10   0xBD02             POP      {R1,PC}
    527          }
    528          
    529          /*
    530           ****************************************************************************************************
    531           *                                          osKernelResume()
    532           *
    533           * Description: CMSIS-RTOS provides extension for tick-less operation which is useful for applications
    534           *              that use extensively low-power modes where the SysTick timer is also disabled.  To provide
    535           *              a time-tick in such power-saving modes a wake-up timer is used to derive timer intervals.
    536           *              The function 'osKernelSuspend()' suspends the RTX kernel scheduler and thus enables sleep
    537           *              modes.
    538           *
    539           * Arguments  : time in 'ticks', for how long the system can sleep or power-down
    540           *
    541           * Returns    : None
    542           *
    543           * Note(s)    : 1) This function cannot be called from Interrupt Service Routines
    544           *
    545           *              2) There are no MicriumOS equivalent function to emulate this behavior.
    546           ****************************************************************************************************
    547           */

   \                                 In section .text, align 2, keep-with-next
    548          void  osKernelResume(uint32_t  sleep_ticks)
    549          {
   \                     osKernelResume: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    550            (void)sleep_ticks;
    551          
    552            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD0FF             BEQ.N    ??osKernelResume_0
    553              return;
    554            }
    555          }
   \                     ??osKernelResume_1: (+1)
   \                     ??osKernelResume_0: (+1)
   \        0xC   0xBD10             POP      {R4,PC}
    556          
    557          /*
    558           ****************************************************************************************************
    559           *                                     osKernelGetTickCount()
    560           *
    561           * Description: The function 'osKernelGetTickCount()' returns the current RTOS kernel tick count.
    562           *
    563           * Arguments  : None
    564           *
    565           * Returns    : the kernel current tick count
    566           *
    567           * Note(s)    : None
    568           ****************************************************************************************************
    569           */

   \                                 In section .text, align 2, keep-with-next
    570          uint32_t  osKernelGetTickCount(void)
    571          {
   \                     osKernelGetTickCount: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    572          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    573            RTOS_ERR err;
    574            OS_TICK ticks;
    575          
    576            ticks = OSTimeGet(&err);
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x.... 0x....      BL       OSTimeGet
    577            (void)err;   // CMSIS RTOS API does not give us a way to propagate errors here
    578          
    579            return ticks;
   \        0x8   0xB005             ADD      SP,SP,#+20
   \        0xA   0xBD00             POP      {PC}
    580          #else
    581            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
    582            return 0u;
    583          #endif //#if (OS_CFG_TICK_EN == DEF_ENABLED)
    584          }
    585          
    586          /*
    587           ****************************************************************************************************
    588           *                                     osKernelGetTickFreq()
    589           *
    590           * Description: The function 'osKernelGetTickFreq()' returns the frequency of the current RTOS kernel tick.
    591           *
    592           * Arguments  : None
    593           *
    594           * Returns    : the kernel tick frequency in Hz
    595           *
    596           * Note(s)    : None
    597           ****************************************************************************************************
    598           */

   \                                 In section .text, align 2, keep-with-next
    599          uint32_t  osKernelGetTickFreq(void)
    600          {
   \                     osKernelGetTickFreq: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    601          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    602            uint32_t  tick_freq;
    603            RTOS_ERR  err;
    604          
    605            tick_freq = OSTimeTickRateHzGet(&err);
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x.... 0x....      BL       OSTimeTickRateHzGet
    606          
    607            return tick_freq;
   \        0x8   0xB005             ADD      SP,SP,#+20
   \        0xA   0xBD00             POP      {PC}
    608          #else
    609            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
    610            return 0u;
    611          #endif
    612          }
    613          
    614          /*
    615           ****************************************************************************************************
    616           *                                    osKernelGetSysTimerCount()
    617           *
    618           * Description: The function 'osKernelGetSysTimerCount() returns the current RTOS kernel system timer
    619           *              as a 32-bit value.  The value is a rolling 32-bit counter that is composed of the kernel
    620           *              system interrupt timer value and the counter that counts these interrupts (RTOS kernel ticks).
    621           *
    622           *              This function allows the implementation of very short timeout checks below the RTOS tick
    623           *              granularity.  Such checks might be required when checking for a busy status in a device
    624           *              or peripheral initialization routine.
    625           *
    626           * Arguments  : None
    627           *
    628           * Returns    : the kernel timer tick count
    629           ****************************************************************************************************
    630           */

   \                                 In section .text, align 2, keep-with-next
    631          uint32_t  osKernelGetSysTimerCount(void)
    632          {
   \                     osKernelGetSysTimerCount: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    633          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    634            uint32_t ticks;
    635          
    636            ticks = sl_sleeptimer_get_tick_count();
   \        0x2   0x.... 0x....      BL       sl_sleeptimer_get_tick_count
    637          
    638            return ticks;
   \        0x6   0xBD02             POP      {R1,PC}
    639          #else
    640            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
    641            return 0u;
    642          #endif
    643          }
    644          
    645          /*
    646           ****************************************************************************************************
    647           *                                    osKernelGetSysTimerFreq()
    648           *
    649           * Description: The function 'osKernelGetSysTimerFreq()' returns the frequency of the current RTOS
    650           *              kernel system timer.
    651           *
    652           * Arguments  : None
    653           *
    654           * Returns    : the kernel system timer frequency in Hz
    655           ****************************************************************************************************
    656           */

   \                                 In section .text, align 2, keep-with-next
    657          uint32_t  osKernelGetSysTimerFreq(void)
    658          {
   \                     osKernelGetSysTimerFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    659          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    660            uint32_t  tick_freq;
    661          
    662            tick_freq = sl_sleeptimer_get_timer_frequency();
   \        0x2   0x.... 0x....      BL       sl_sleeptimer_get_timer_frequency
    663          
    664            return tick_freq;
   \        0x6   0xBD02             POP      {R1,PC}
    665          #else
    666            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
    667            return 0u;
    668          #endif
    669          }
    670          
    671          /*
    672           ****************************************************************************************************
    673           ****************************************************************************************************
    674           *                                     G E N E R I C   W A I T
    675           ****************************************************************************************************
    676           ****************************************************************************************************
    677           */
    678          
    679          /*
    680           ****************************************************************************************************
    681           *                                             osDelay()
    682           *
    683           * Description: The function 'osDelay()' waits for a time period specified in kernel ticks.  For a value
    684           *              of 1 the system waits until the next timer tick occurs.  The actual time delay may be up
    685           *              to one timer tick less than specified, i.e. calling 'osDelay(1)' right before the next
    686           *              system tick occurs the thread is rescheduled immediately.
    687           *
    688           *              The delayed thread is put into the BLOCKED state and a context switch occurs immediately.
    689           *              The thread is automatically put back to the READY state after the given amount of ticks
    690           *              has elapsed. If the thread will have the highest priority in READY state it will being
    691           *              scheduled immediately.
    692           *
    693           * Arguments  : ticks       is the amount of time (in ticks) that the task will be blocked
    694           *
    695           * Returns    : osOK        if the call is successful
    696           *              osErrorISR  if called from an ISR
    697           *
    698           * Note(s)    : 1) This function CANNOT be called from an ISR
    699           ****************************************************************************************************
    700           */

   \                                 In section .text, align 2, keep-with-next
    701          osStatus_t  osDelay(uint32_t  ticks)
    702          {
   \                     osDelay: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    703          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    704            RTOS_ERR  err;
    705          
    706            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD102             BNE.N    ??osDelay_0
    707              return osErrorISR;
   \        0xC   0xF07F 0x0005      MVNS     R0,#+5
   \       0x10   0xE00C             B.N      ??osDelay_1
    708            }
    709          
    710            OSTimeDly((OS_TICK)ticks, OS_OPT_TIME_DLY, &err);
   \                     ??osDelay_0: (+1)
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       OSTimeDly
    711          
    712            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x1C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD002             BEQ.N    ??osDelay_2
    713              return osError;
   \       0x24   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x28   0xE000             B.N      ??osDelay_1
    714            }
    715          
    716            return osOK;
   \                     ??osDelay_2: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??osDelay_1: (+1)
   \       0x2C   0xB004             ADD      SP,SP,#+16
   \       0x2E   0xBD10             POP      {R4,PC}
    717          #else
    718            (void)ticks;
    719            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
    720            return osError;
    721          #endif // #if (OS_CFG_TICK_EN == DEF_ENABLED)
    722          }
    723          
    724          /*
    725           ****************************************************************************************************
    726           *                                           osDelayUntil()
    727           *
    728           * Description: The function 'osDelayUntil()' waits until an absolute time (specified in kernel ticks)
    729           *              is reached.
    730           *
    731           *              The corner case when the kernel tick counter overflows is handled by 'osDelayUntil()'.
    732           *              Thus it is absolutely legal to provide a value which is lower than the current tick
    733           *              value, i.e. returned by 'osKernelGetTickCount()'.  Typically as a user you do not have
    734           *              to take care about the overflow.  The only limitation you have to have in mind is that
    735           *              the maximum delay is limited to 0x7FFFFFFF ticks.
    736           *
    737           *              The delayed thread is put into the BLOCKED state and a context switch occurs immediately.
    738           *              The thread is automatically put back to the READY state when the given time is reached.
    739           *              If the thread will have the highest priority in READY state it will being scheduled immediately.
    740           *
    741           * Arguments  : ticks       is the absolute time (in ticks) at which the task will wake up.
    742           *
    743           * Returns    : osOK        if the call is successful
    744           *              osParameter if time cannot be handled (out of bounds)
    745           *              osErrorISR  if called from an ISR
    746           *
    747           * Note(s)    : 1) This function CANNOT be called from an ISR
    748           ****************************************************************************************************
    749           */

   \                                 In section .text, align 2, keep-with-next
    750          osStatus_t  osDelayUntil(uint32_t  ticks)
    751          {
   \                     osDelayUntil: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
    752          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    753            RTOS_ERR err;
    754            OS_TICK  until;
    755          
    756            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osDelayUntil_0
    757              return osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE025             B.N      ??osDelayUntil_1
    758            }
    759          
    760            until = ticks - OSTimeGet(&err);
   \                     ??osDelayUntil_0: (+1)
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x.... 0x....      BL       OSTimeGet
   \       0x1A   0x0005             MOVS     R5,R0
   \       0x1C   0x1B65             SUBS     R5,R4,R5
    761          
    762            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x1E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD002             BEQ.N    ??osDelayUntil_2
    763              return osError;
   \       0x26   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x2A   0xE019             B.N      ??osDelayUntil_1
    764            }
    765          
    766            if (until > 0x7FFFFFF0u) {                      // Allow for 16 ticks of latency
   \                     ??osDelayUntil_2: (+1)
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x30   0x4285             CMP      R5,R0
   \       0x32   0xD301             BCC.N    ??osDelayUntil_3
    767              until = 0u;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x0005             MOVS     R5,R0
    768            }
    769          
    770            OSTimeDly((OS_TICK)until, OS_OPT_TIME_DLY, &err);
   \                     ??osDelayUntil_3: (+1)
   \       0x38   0x466A             MOV      R2,SP
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x.... 0x....      BL       OSTimeDly
    771          
    772            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x42   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD002             BEQ.N    ??osDelayUntil_4
    773              return osErrorParameter;
   \       0x4A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x4E   0xE007             B.N      ??osDelayUntil_1
    774            }
    775          
    776            switch (RTOS_ERR_CODE_GET(err)) {
   \                     ??osDelayUntil_4: (+1)
   \       0x50   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD101             BNE.N    ??osDelayUntil_5
    777              case RTOS_ERR_NONE:
    778                return osOK;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xE001             B.N      ??osDelayUntil_1
    779          
    780              case RTOS_ERR_INVALID_ARG:
    781              case RTOS_ERR_OS_SCHED_LOCKED:
    782              default:
    783                return osErrorParameter;
   \                     ??osDelayUntil_5: (+1)
   \       0x5C   0xF07F 0x0003      MVNS     R0,#+3
   \                     ??osDelayUntil_1: (+1)
   \       0x60   0xB005             ADD      SP,SP,#+20
   \       0x62   0xBD30             POP      {R4,R5,PC}
    784            }
    785          #else
    786            (void)ticks;
    787            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
    788            return osError;
    789          #endif // #if (OS_CFG_TICK_EN == DEF_ENABLED)
    790          }
    791          
    792          /*
    793           ****************************************************************************************************
    794           ****************************************************************************************************
    795           *                                      E V E N T   F L A G S
    796           ****************************************************************************************************
    797           ****************************************************************************************************
    798           */
    799          
    800          /*
    801           ****************************************************************************************************
    802           *                                         osEventFlagsNew()
    803           *
    804           * Description: The function 'osEventFlagsNew()' creates a new event flags object that is used to send
    805           *              events across threads and returns the pointer to the event flags object identifier or
    806           *              NULL in case of an error.  It can be safely called before the RTOS is started
    807           *              (call to 'osKernelStart()'), but not before it is initialized (call to 'osKernelInitialize()').
    808           *
    809           *              The parameter 'attr' sets the event flags attributes (refer to 'osEventFlagsAttr_t').
    810           *              Default attributes will be used if set to NULL, i.e. kernel memory allocation is used for
    811           *              the event control block.
    812           *
    813           * Arguments  : attr     sets the event flags attributes or default values if NULL
    814           *
    815           *                       .name        is an ASCII string used to name the mutex
    816           *
    817           *                       .attr_bits   Not currently used, MUST be set to 0
    818           *
    819           *                       .cb_mem      Pointer to storage area for the event flags control block
    820           *
    821           *                       .cb_size     Size of the memory storage for the event flags control block
    822           *
    823           * Returns    : The event flags ID
    824           *
    825           * Note(s)    : 1) The event flags control block is assumed to be of type 'osEentFlags_t' which for the
    826           *                 CMSIS-RTOS adaptation layer is defined as an OS_FLAG_GRP in MicriumOS.
    827           ****************************************************************************************************
    828           */

   \                                 In section .text, align 2, keep-with-next
    829          osEventFlagsId_t  osEventFlagsNew(const  osEventFlagsAttr_t *attr)
    830          {
   \                     osEventFlagsNew: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
    831          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
    832            osEventFlags_t *p_flags;
    833            CPU_CHAR       *p_name;
    834            RTOS_ERR        err;
    835          
    836            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??osEventFlagsNew_0
    837              return (osEventFlagsId_t)0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE042             B.N      ??osEventFlagsNew_1
    838            }
    839          
    840            p_name = (CPU_CHAR *)"EventFlags";
   \                     ??osEventFlagsNew_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R6,??DataTable14
    841            if (attr == 0) {
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD10A             BNE.N    ??osEventFlagsNew_2
    842              p_flags = (osEventFlags_t *)malloc(sizeof(osEventFlags_t));
   \       0x18   0x2018             MOVS     R0,#+24
   \       0x1A   0x.... 0x....      BL       malloc
   \       0x1E   0x0004             MOVS     R4,R0
    843              if (p_flags == (osEventFlags_t *)0) {
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD101             BNE.N    ??osEventFlagsNew_3
    844                return (osEventFlagsId_t)0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE036             B.N      ??osEventFlagsNew_1
    845              }
    846              p_flags->dyn_alloc = DEF_TRUE;
   \                     ??osEventFlagsNew_3: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x7420             STRB     R0,[R4, #+16]
   \       0x2C   0xE01E             B.N      ??osEventFlagsNew_4
    847            } else {
    848              if (attr->cb_mem == (void *)0) {
   \                     ??osEventFlagsNew_2: (+1)
   \       0x2E   0x68A8             LDR      R0,[R5, #+8]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD10A             BNE.N    ??osEventFlagsNew_5
    849                p_flags = (osEventFlags_t *)malloc(sizeof(osEventFlags_t));
   \       0x34   0x2018             MOVS     R0,#+24
   \       0x36   0x.... 0x....      BL       malloc
   \       0x3A   0x0004             MOVS     R4,R0
    850                if (p_flags == (osEventFlags_t *)0) {
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD101             BNE.N    ??osEventFlagsNew_6
    851                  return (osEventFlagsId_t)0;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xE028             B.N      ??osEventFlagsNew_1
    852                }
    853                p_flags->dyn_alloc = DEF_TRUE;
   \                     ??osEventFlagsNew_6: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x7420             STRB     R0,[R4, #+16]
   \       0x48   0xE00B             B.N      ??osEventFlagsNew_7
    854              } else {
    855                if (attr->cb_size < sizeof(osEventFlags_t) || (uint32_t)attr->cb_mem % sizeof(CPU_ALIGN)) {
   \                     ??osEventFlagsNew_5: (+1)
   \       0x4A   0x68E8             LDR      R0,[R5, #+12]
   \       0x4C   0x2818             CMP      R0,#+24
   \       0x4E   0xD303             BCC.N    ??osEventFlagsNew_8
   \       0x50   0x7A28             LDRB     R0,[R5, #+8]
   \       0x52   0xF010 0x0F03      TST      R0,#0x3
   \       0x56   0xD001             BEQ.N    ??osEventFlagsNew_9
    856                  return (osEventFlagsId_t)0;
   \                     ??osEventFlagsNew_8: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xE01C             B.N      ??osEventFlagsNew_1
    857                }
    858                p_flags = (osEventFlags_t*)attr->cb_mem;
   \                     ??osEventFlagsNew_9: (+1)
   \       0x5C   0x68AC             LDR      R4,[R5, #+8]
    859                p_flags->dyn_alloc = DEF_FALSE;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x7420             STRB     R0,[R4, #+16]
    860              }
    861              if (attr->name != (const char *)0) {
   \                     ??osEventFlagsNew_7: (+1)
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD001             BEQ.N    ??osEventFlagsNew_4
    862                p_name = (CPU_CHAR *)attr->name;
   \       0x68   0x6828             LDR      R0,[R5, #+0]
   \       0x6A   0x0006             MOVS     R6,R0
    863              }
    864            }
    865          
    866            p_flags->flags = 0;
   \                     ??osEventFlagsNew_4: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x6160             STR      R0,[R4, #+20]
    867          
    868            OSFlagCreate(&p_flags->flag_grp, p_name, p_flags->flags, &err);
   \       0x70   0x466B             MOV      R3,SP
   \       0x72   0x6962             LDR      R2,[R4, #+20]
   \       0x74   0x0031             MOVS     R1,R6
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0x.... 0x....      BL       OSFlagCreate
    869          
    870            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x7C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD007             BEQ.N    ??osEventFlagsNew_10
    871              if (p_flags->dyn_alloc == DEF_TRUE) {
   \       0x84   0x7C20             LDRB     R0,[R4, #+16]
   \       0x86   0x2801             CMP      R0,#+1
   \       0x88   0xD102             BNE.N    ??osEventFlagsNew_11
    872                free(p_flags);
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x.... 0x....      BL       free
    873              }
    874              return (osEventFlagsId_t)0;
   \                     ??osEventFlagsNew_11: (+1)
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xE000             B.N      ??osEventFlagsNew_1
    875            }
    876          
    877            return (osEventFlagsId_t)p_flags;
   \                     ??osEventFlagsNew_10: (+1)
   \       0x94   0x0020             MOVS     R0,R4
   \                     ??osEventFlagsNew_1: (+1)
   \       0x96   0xB004             ADD      SP,SP,#+16
   \       0x98   0xBD70             POP      {R4-R6,PC}
    878          #else
    879            (void)attr;
    880            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, (osEventFlagsId_t)0);
    881            return (osEventFlagsId_t)0;
    882          #endif
    883          }
    884          
    885          /*
    886           ****************************************************************************************************
    887           *                                         osEventFlagsSet()
    888           *
    889           * Description: The function 'osEventFlagsSet()' sets the event flags specified by the parameter 'flags'
    890           *              in an event flags object specified by parameter 'ef_id'.  All threads waiting for the
    891           *              flag set will be notified to resume from BLOCKED state.
    892           *
    893           *              The function returns the event flags stored in the event control block or an error code
    894           *              (highest bit is set, refer to Flags Functions Error Codes).
    895           *
    896           * Arguments  : ef_id    Is the events flags ID
    897           *
    898           *              flags    The flags to set
    899           *
    900           * Returns    : The new state of the event flags
    901           *              osFlagsErrorUnknown     unspecified error.
    902           *              osFlagsErrorParameter   parameter ef_id does not identify a valid event flags object or flags has highest bit set.
    903           *              osFlagsErrorResource    the event flags object is in an invalid state.
    904           *
    905           * Note(s)    : None
    906           ****************************************************************************************************
    907           */

   \                                 In section .text, align 2, keep-with-next
    908          uint32_t  osEventFlagsSet(osEventFlagsId_t  ef_id,
    909                                    uint32_t          flags)
    910          {
   \                     osEventFlagsSet: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000F             MOVS     R7,R1
    911          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
    912            osEventFlags_t *p_flags;
    913            OS_FLAG_GRP    *p_grp;
    914            OS_TCB         *p_tcb;
    915            RTOS_ERR        err;
    916            uint32_t        rdy_flags;
    917            uint32_t        new_flags;
    918            uint32_t        ret_flags;
    919            CORE_DECLARE_IRQ_STATE;
    920          
    921            p_flags = (osEventFlags_t *)ef_id;
   \        0xA   0x465E             MOV      R6,R11
    922            if (p_flags == (osEventFlags_t *)0) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD102             BNE.N    ??osEventFlagsSet_0
    923              return osFlagsErrorParameter;
   \       0x10   0xF07F 0x0003      MVNS     R0,#+3
   \       0x14   0xE045             B.N      ??osEventFlagsSet_1
    924            }
    925            p_grp = &p_flags->flag_grp;
   \                     ??osEventFlagsSet_0: (+1)
   \       0x16   0x46B0             MOV      R8,R6
    926          
    927            if ((flags & 0x80000000u) == 0x80000000u) {                    // MSB cannot be set
   \       0x18   0x2F00             CMP      R7,#+0
   \       0x1A   0xD502             BPL.N    ??osEventFlagsSet_2
    928              return osFlagsErrorParameter;
   \       0x1C   0xF07F 0x0003      MVNS     R0,#+3
   \       0x20   0xE03F             B.N      ??osEventFlagsSet_1
    929            }
    930          
    931            CORE_ENTER_ATOMIC();
   \                     ??osEventFlagsSet_2: (+1)
   \       0x22   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x26   0x4681             MOV      R9,R0
    932          
    933            p_flags->flags |= flags;
   \       0x28   0x6970             LDR      R0,[R6, #+20]
   \       0x2A   0x4338             ORRS     R0,R7,R0
   \       0x2C   0x6170             STR      R0,[R6, #+20]
    934            new_flags = p_flags->flags;                                   // New flags after set
   \       0x2E   0xF8D6 0xA014      LDR      R10,[R6, #+20]
    935          
    936            p_tcb = p_grp->PendList.HeadPtr;                              // Loop over pending tasks
   \       0x32   0xF8D8 0x5004      LDR      R5,[R8, #+4]
    937            while (p_tcb != DEF_NULL) {
   \                     ??osEventFlagsSet_3: (+1)
   \       0x36   0x2D00             CMP      R5,#+0
   \       0x38   0xD022             BEQ.N    ??osEventFlagsSet_4
    938              if (p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_CONSUME) {           // Pender might consume the flags?
   \       0x3A   0xF8B5 0x0080      LDRH     R0,[R5, #+128]
   \       0x3E   0x05C0             LSLS     R0,R0,#+23
   \       0x40   0xD51C             BPL.N    ??osEventFlagsSet_5
    939                switch (p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK) {
   \       0x42   0xF895 0x0080      LDRB     R0,[R5, #+128]
   \       0x46   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x4A   0xB2C0             UXTB     R0,R0
   \       0x4C   0x2804             CMP      R0,#+4
   \       0x4E   0xD002             BEQ.N    ??osEventFlagsSet_6
   \       0x50   0x2808             CMP      R0,#+8
   \       0x52   0xD00A             BEQ.N    ??osEventFlagsSet_7
   \       0x54   0xE012             B.N      ??osEventFlagsSet_8
    940                  case OS_OPT_PEND_FLAG_SET_ALL:                          // -> Pender waiting for all flags to be set
    941                    rdy_flags = (new_flags & p_tcb->FlagsPend);
   \                     ??osEventFlagsSet_6: (+1)
   \       0x56   0x6FA8             LDR      R0,[R5, #+120]
   \       0x58   0xEA10 0x000A      ANDS     R0,R0,R10
   \       0x5C   0x0004             MOVS     R4,R0
    942                    if (rdy_flags == p_tcb->FlagsPend) {                  //    -> Pender will really consume?
   \       0x5E   0x6FA8             LDR      R0,[R5, #+120]
   \       0x60   0x4284             CMP      R4,R0
   \       0x62   0xD101             BNE.N    ??osEventFlagsSet_9
    943                      new_flags &= ~rdy_flags;                            //    -> Simulate the consumption
   \       0x64   0xEA3A 0x0A04      BICS     R10,R10,R4
    944                    }
    945                    break;
   \                     ??osEventFlagsSet_9: (+1)
   \       0x68   0xE008             B.N      ??osEventFlagsSet_5
    946          
    947                  case OS_OPT_PEND_FLAG_SET_ANY:                          // -> Pender waiting for any flags to be set
    948                    rdy_flags = (new_flags & p_tcb->FlagsPend);
   \                     ??osEventFlagsSet_7: (+1)
   \       0x6A   0x6FA8             LDR      R0,[R5, #+120]
   \       0x6C   0xEA10 0x000A      ANDS     R0,R0,R10
   \       0x70   0x0004             MOVS     R4,R0
    949                    if (rdy_flags != 0u) {                                //    -> Pender will really consume?
   \       0x72   0x2C00             CMP      R4,#+0
   \       0x74   0xD001             BEQ.N    ??osEventFlagsSet_10
    950                      new_flags &= ~rdy_flags;                            //    -> Simulate the consumption
   \       0x76   0xEA3A 0x0A04      BICS     R10,R10,R4
    951                    }
    952                    break;
   \                     ??osEventFlagsSet_10: (+1)
   \       0x7A   0xE7FF             B.N      ??osEventFlagsSet_5
    953          
    954                  default:
    955                    break;
    956                }
    957              }
    958              p_tcb = p_tcb->PendNextPtr;                                 // Point to next task waiting for event flag(s)
   \                     ??osEventFlagsSet_8: (+1)
   \                     ??osEventFlagsSet_5: (+1)
   \       0x7C   0x69AD             LDR      R5,[R5, #+24]
   \       0x7E   0xE7DA             B.N      ??osEventFlagsSet_3
    959            }
    960          
    961            CORE_EXIT_ATOMIC();
   \                     ??osEventFlagsSet_4: (+1)
   \       0x80   0x4648             MOV      R0,R9
   \       0x82   0x.... 0x....      BL       CORE_ExitAtomic
    962          
    963            OSFlagPost(p_grp, flags, OS_OPT_POST_FLAG_SET, &err);
   \       0x86   0x466B             MOV      R3,SP
   \       0x88   0x2200             MOVS     R2,#+0
   \       0x8A   0x0039             MOVS     R1,R7
   \       0x8C   0x4640             MOV      R0,R8
   \       0x8E   0x.... 0x....      BL       OSFlagPost
    964          
    965            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x92   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD101             BNE.N    ??osEventFlagsSet_11
    966              case RTOS_ERR_NONE:
    967                ret_flags = new_flags;
   \       0x9A   0x4650             MOV      R0,R10
    968                break;
   \       0x9C   0xE001             B.N      ??osEventFlagsSet_12
    969          
    970              default:
    971                ret_flags = osFlagsErrorResource;
   \                     ??osEventFlagsSet_11: (+1)
   \       0x9E   0xF07F 0x0002      MVNS     R0,#+2
    972                break;
    973            }
    974            return ret_flags;
   \                     ??osEventFlagsSet_12: (+1)
   \                     ??osEventFlagsSet_1: (+1)
   \       0xA2   0xB005             ADD      SP,SP,#+20
   \       0xA4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    975          #else
    976            (void)ef_id;
    977            (void)flags;
    978            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osFlagsErrorUnknown);
    979            return osFlagsErrorUnknown;
    980          #endif
    981          }
    982          
    983          /*
    984           ****************************************************************************************************
    985           *                                        osEventFlagsClear()
    986           *
    987           * Description: The function 'osEventFlagsClear()' clears the event flags specified by the parameter 'flags'
    988           *              in an event flags object specified by parameter 'ef_id'.
    989           *
    990           *              The function returns the event flags stored in the event control block prior to clearing
    991           *              the flags or an error code (highest bit is set, refer to Flags Functions Error Codes).
    992           *
    993           * Arguments  : ef_id    Is the events flags ID
    994           *
    995           *              flags    The flags to clear
    996           *
    997           * Returns    : osFlagsErrorUnknown     unspecified error.
    998           *              osFlagsErrorParameter   parameter ef_id does not identify a valid event flags
    999           *                                      object or flags has highest bit set.
   1000           *              osFlagsErrorResource    the event flags object is in an invalid state.
   1001           *
   1002           * Note(s)    : None
   1003           ****************************************************************************************************
   1004           */

   \                                 In section .text, align 2, keep-with-next
   1005          uint32_t  osEventFlagsClear(osEventFlagsId_t  ef_id,
   1006                                      uint32_t          flags)
   1007          {
   \                     osEventFlagsClear: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   1008          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   1009            osEventFlags_t *p_flags;
   1010            RTOS_ERR        err;
   1011            uint32_t        old_flags;
   1012            CORE_DECLARE_IRQ_STATE;
   1013          
   1014            p_flags = (osEventFlags_t *)ef_id;
   \        0x8   0x002C             MOVS     R4,R5
   1015            if (p_flags == (osEventFlags_t *)0) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??osEventFlagsClear_0
   1016              return osFlagsErrorParameter;
   \        0xE   0xF07F 0x0003      MVNS     R0,#+3
   \       0x12   0xE018             B.N      ??osEventFlagsClear_1
   1017            }
   1018          
   1019            CORE_ENTER_ATOMIC();
   \                     ??osEventFlagsClear_0: (+1)
   \       0x14   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x18   0x0007             MOVS     R7,R0
   1020            old_flags = p_flags->flags;                                   // Get previous value of flags
   \       0x1A   0xF8D4 0x8014      LDR      R8,[R4, #+20]
   1021            p_flags->flags &= ~flags;
   \       0x1E   0x6960             LDR      R0,[R4, #+20]
   \       0x20   0x43B0             BICS     R0,R0,R6
   \       0x22   0x6160             STR      R0,[R4, #+20]
   1022            CORE_EXIT_ATOMIC();
   \       0x24   0x0038             MOVS     R0,R7
   \       0x26   0x.... 0x....      BL       CORE_ExitAtomic
   1023          
   1024            OSFlagPost(&p_flags->flag_grp, flags, OS_OPT_POST_FLAG_CLR, &err);
   \       0x2A   0x466B             MOV      R3,SP
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x0031             MOVS     R1,R6
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       OSFlagPost
   1025          
   1026            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x36   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD002             BEQ.N    ??osEventFlagsClear_2
   1027              old_flags = osFlagsErrorUnknown;
   \       0x3E   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x42   0x4680             MOV      R8,R0
   1028            }
   1029          
   1030            return old_flags;
   \                     ??osEventFlagsClear_2: (+1)
   \       0x44   0x4640             MOV      R0,R8
   \                     ??osEventFlagsClear_1: (+1)
   \       0x46   0xB004             ADD      SP,SP,#+16
   \       0x48   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1031          #else
   1032            (void)ef_id;
   1033            (void)flags;
   1034            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osFlagsErrorUnknown);
   1035            return osFlagsErrorUnknown;
   1036          #endif
   1037          }
   1038          
   1039          /*
   1040           ****************************************************************************************************
   1041           *                                         osEventFlagsGet()
   1042           *
   1043           * Description: The function 'osEventFlagsGet()' gets the current state of the event flags in an event
   1044           *              flags object specified by parameter 'ef_id'.
   1045           *
   1046           * Arguments  : ef_id    Is the events flags ID
   1047           *
   1048           *              flags    The flags to clear
   1049           *
   1050           * Returns    : osFlagsErrorUnknown     unspecified error.
   1051           *              osFlagsErrorParameter   parameter ef_id does not identify a valid event flags object or flags has highest bit set.
   1052           *              osFlagsErrorResource    the event flags object is in an invalid state.
   1053           *
   1054           * Note(s)    : None
   1055           ****************************************************************************************************
   1056           */

   \                                 In section .text, align 2, keep-with-next
   1057          uint32_t  osEventFlagsGet(osEventFlagsId_t  ef_id)
   1058          {
   \                     osEventFlagsGet: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   1059          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   1060            osEventFlags_t *p_flags;
   1061            uint32_t        flags;
   1062          
   1063            p_flags = (osEventFlags_t *)ef_id;
   \        0x2   0x0011             MOVS     R1,R2
   1064            if (p_flags == (osEventFlags_t *)0) {
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??osEventFlagsGet_0
   1065              return 0u;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE000             B.N      ??osEventFlagsGet_1
   1066            }
   1067          
   1068            flags = (uint32_t)p_flags->flags;                             // Get current value of flags
   \                     ??osEventFlagsGet_0: (+1)
   \        0xC   0x6948             LDR      R0,[R1, #+20]
   1069            return flags;
   \                     ??osEventFlagsGet_1: (+1)
   \        0xE   0x4770             BX       LR
   1070          #else
   1071            (void)ef_id;
   1072            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osFlagsErrorUnknown);
   1073            return osFlagsErrorUnknown;
   1074          #endif
   1075          }
   1076          
   1077          /*
   1078           ****************************************************************************************************
   1079           *                                         osEventFlagsWait()
   1080           *
   1081           * Description: The function 'osEventFlagsWait()' suspends the execution of the currently RUNNING thread
   1082           *              until any or all event flags specified by the parameter 'flags' in the event object
   1083           *              specified by parameter 'ef_id' are set.  When these event flags are already set, the
   1084           *              function returns instantly.  Otherwise, the thread is put into the state BLOCKED.
   1085           *
   1086           * Arguments  : ef_id    Is the events flags ID
   1087           *
   1088           *              flags    The desired flag(s) to wait for
   1089           *
   1090           *              options
   1091           *                       osFlagsWaitAny                   Wait for any flag (default).
   1092           *                       osFlagsWaitAny | osFlagsNoClear  Wait for any flag  specified but do not consume
   1093           *                       osFlagsWaitAll                   Wait for all flags.
   1094           *                       osFlagsWaitAll | osFlagsNoClear  Wait for all flags specified but do not consume
   1095           *
   1096           *              timeout
   1097           *                       The parameter timeout specifies how long the system waits for event flags.
   1098           *                       While the system waits, the thread that is calling this function is put into the
   1099           *                       BLOCKED state.  The parameter timeout can have the following values:
   1100           *
   1101           *                       when timeout is 0,                       the function returns instantly (i.e. try semantics).
   1102           *                       when timeout is set to 'osWaitForever'   the function will wait for an infinite time until
   1103           *                                                                the event flags become available (i.e. wait semantics).
   1104           *                       all other values                         specify a time in kernel ticks for a timeout
   1105           *                                                                (i.e. timed-wait semantics).
   1106           *
   1107           * Returns    : The
   1108           *              osFlagsErrorUnknown          unspecified error.
   1109           *              osFlagsErrorTimeout          awaited flags have not been set in the given time.
   1110           *              osFlagsErrorResource         awaited flags have not been set when no timeout was specified.
   1111           *              osFlagsErrorParameter        parameter 'ef_id' does not identify a valid event flags object or flags has highest bit set.
   1112           *
   1113           * Note(s)    : 1) May be called from Interrupt Service Routines if the parameter timeout is set to 0.
   1114           *
   1115           *              2) MicriumOS does NOT return the flags prior to clearing but instead, the flags that
   1116           *                 made the task ready-to-run.
   1117           ****************************************************************************************************
   1118           */

   \                                 In section .text, align 2, keep-with-next
   1119          uint32_t  osEventFlagsWait(osEventFlagsId_t  ef_id,
   1120                                     uint32_t          flags,
   1121                                     uint32_t          options,
   1122                                     uint32_t          timeout)
   1123          {
   \                     osEventFlagsWait: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x0006             MOVS     R6,R0
   \        0x8   0x000F             MOVS     R7,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x001C             MOVS     R4,R3
   1124          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   1125            osEventFlags_t *p_flags;
   1126            OS_TICK         os_timeout;
   1127            OS_OPT          opt;
   1128            RTOS_ERR        err;
   1129            CPU_TS          ts;
   1130            uint32_t        rtn_flags;
   1131            CORE_DECLARE_IRQ_STATE;
   1132          
   1133            p_flags = (osEventFlags_t *)ef_id;
   \        0xE   0x9602             STR      R6,[SP, #+8]
   1134            if (p_flags == (osEventFlags_t *)0) {
   \       0x10   0x9802             LDR      R0,[SP, #+8]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??osEventFlagsWait_0
   1135              return osFlagsErrorParameter;
   \       0x16   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1A   0xE06B             B.N      ??osEventFlagsWait_1
   1136            }
   1137          
   1138            if ((flags & 0x80000000u) == 0x80000000u) {                    // MSB cannot be set
   \                     ??osEventFlagsWait_0: (+1)
   \       0x1C   0x2F00             CMP      R7,#+0
   \       0x1E   0xD502             BPL.N    ??osEventFlagsWait_2
   1139              return osFlagsErrorParameter;
   \       0x20   0xF07F 0x0003      MVNS     R0,#+3
   \       0x24   0xE066             B.N      ??osEventFlagsWait_1
   1140            }
   1141            opt = OS_OPT_PEND_BLOCKING;
   \                     ??osEventFlagsWait_2: (+1)
   \       0x26   0xF05F 0x0900      MOVS     R9,#+0
   1142            if (timeout == osWaitForever) {                                // Convert CMSIS-RTOS timeout to MicriumOS
   \       0x2A   0xF114 0x0F01      CMN      R4,#+1
   \       0x2E   0xD109             BNE.N    ??osEventFlagsWait_3
   1143              if (CORE_InIrqContext() == true) {
   \       0x30   0x.... 0x....      BL       CORE_InIrqContext
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD102             BNE.N    ??osEventFlagsWait_4
   1144                return osFlagsErrorParameter;
   \       0x38   0xF07F 0x0003      MVNS     R0,#+3
   \       0x3C   0xE05A             B.N      ??osEventFlagsWait_1
   1145              }
   1146              os_timeout = 0u;                                             // 0 for MicriumOS means forever
   \                     ??osEventFlagsWait_4: (+1)
   \       0x3E   0xF05F 0x0B00      MOVS     R11,#+0
   \       0x42   0xE00F             B.N      ??osEventFlagsWait_5
   1147            } else if (timeout == 0u) {
   \                     ??osEventFlagsWait_3: (+1)
   \       0x44   0x2C00             CMP      R4,#+0
   \       0x46   0xD105             BNE.N    ??osEventFlagsWait_6
   1148              opt = OS_OPT_PEND_NON_BLOCKING;                              // No timeout, non-blocking
   \       0x48   0xF44F 0x4000      MOV      R0,#+32768
   \       0x4C   0x4681             MOV      R9,R0
   1149              os_timeout = 0u;                                             // timeout for MicriumOS in non-blocking mode is ignored
   \       0x4E   0xF05F 0x0B00      MOVS     R11,#+0
   \       0x52   0xE007             B.N      ??osEventFlagsWait_5
   1150            } else {
   1151              if (CORE_InIrqContext() == true) {
   \                     ??osEventFlagsWait_6: (+1)
   \       0x54   0x.... 0x....      BL       CORE_InIrqContext
   \       0x58   0x2801             CMP      R0,#+1
   \       0x5A   0xD102             BNE.N    ??osEventFlagsWait_7
   1152                return osFlagsErrorParameter;
   \       0x5C   0xF07F 0x0003      MVNS     R0,#+3
   \       0x60   0xE048             B.N      ??osEventFlagsWait_1
   1153              }
   1154              os_timeout = (OS_TICK)timeout;
   \                     ??osEventFlagsWait_7: (+1)
   \       0x62   0x46A3             MOV      R11,R4
   1155            }
   1156          
   1157            if (options & osFlagsWaitAll) {
   \                     ??osEventFlagsWait_5: (+1)
   \       0x64   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \       0x68   0xD502             BPL.N    ??osEventFlagsWait_8
   1158              opt |= OS_OPT_PEND_FLAG_SET_ALL;
   \       0x6A   0xF059 0x0904      ORRS     R9,R9,#0x4
   \       0x6E   0xE001             B.N      ??osEventFlagsWait_9
   1159            } else {
   1160              opt |= OS_OPT_PEND_FLAG_SET_ANY;
   \                     ??osEventFlagsWait_8: (+1)
   \       0x70   0xF059 0x0908      ORRS     R9,R9,#0x8
   1161            }
   1162          
   1163            if (!(options & osFlagsNoClear)) {
   \                     ??osEventFlagsWait_9: (+1)
   \       0x74   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \       0x78   0xD401             BMI.N    ??osEventFlagsWait_10
   1164              opt |= OS_OPT_PEND_FLAG_CONSUME;
   \       0x7A   0xF459 0x7980      ORRS     R9,R9,#0x100
   1165            }
   1166          
   1167            OSFlagPend(&p_flags->flag_grp, (OS_FLAGS)flags, os_timeout, opt, &ts, &err);
   \                     ??osEventFlagsWait_10: (+1)
   \       0x7E   0xA804             ADD      R0,SP,#+16
   \       0x80   0x9001             STR      R0,[SP, #+4]
   \       0x82   0xA803             ADD      R0,SP,#+12
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x464B             MOV      R3,R9
   \       0x88   0xB29B             UXTH     R3,R3
   \       0x8A   0x465A             MOV      R2,R11
   \       0x8C   0x0039             MOVS     R1,R7
   \       0x8E   0x9802             LDR      R0,[SP, #+8]
   \       0x90   0x.... 0x....      BL       OSFlagPend
   1168          
   1169            CORE_ENTER_ATOMIC();
   \       0x94   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x98   0x4682             MOV      R10,R0
   1170            rtn_flags = p_flags->flags;
   \       0x9A   0x9802             LDR      R0,[SP, #+8]
   \       0x9C   0x6945             LDR      R5,[R0, #+20]
   1171            if (!(options & osFlagsNoClear)) {
   \       0x9E   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \       0xA2   0xD404             BMI.N    ??osEventFlagsWait_11
   1172              p_flags->flags &= ~flags;
   \       0xA4   0x9802             LDR      R0,[SP, #+8]
   \       0xA6   0x6941             LDR      R1,[R0, #+20]
   \       0xA8   0x43B9             BICS     R1,R1,R7
   \       0xAA   0x9802             LDR      R0,[SP, #+8]
   \       0xAC   0x6141             STR      R1,[R0, #+20]
   1173            }
   1174            CORE_EXIT_ATOMIC();
   \                     ??osEventFlagsWait_11: (+1)
   \       0xAE   0x4650             MOV      R0,R10
   \       0xB0   0x.... 0x....      BL       CORE_ExitAtomic
   1175          
   1176            switch (RTOS_ERR_CODE_GET(err)) {
   \       0xB4   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD00A             BEQ.N    ??osEventFlagsWait_12
   \       0xBC   0x281D             CMP      R0,#+29
   \       0xBE   0xD00D             BEQ.N    ??osEventFlagsWait_13
   \       0xC0   0x2821             CMP      R0,#+33
   \       0xC2   0xD012             BEQ.N    ??osEventFlagsWait_14
   \       0xC4   0x2822             CMP      R0,#+34
   \       0xC6   0xD006             BEQ.N    ??osEventFlagsWait_15
   \       0xC8   0x282D             CMP      R0,#+45
   \       0xCA   0xD00E             BEQ.N    ??osEventFlagsWait_14
   \       0xCC   0x2831             CMP      R0,#+49
   \       0xCE   0xD00C             BEQ.N    ??osEventFlagsWait_14
   \       0xD0   0xE00E             B.N      ??osEventFlagsWait_16
   1177              case RTOS_ERR_NONE:
   1178                return rtn_flags;
   \                     ??osEventFlagsWait_12: (+1)
   \       0xD2   0x0028             MOVS     R0,R5
   \       0xD4   0xE00E             B.N      ??osEventFlagsWait_1
   1179          
   1180              case RTOS_ERR_TIMEOUT:
   1181                return osFlagsErrorTimeout;
   \                     ??osEventFlagsWait_15: (+1)
   \       0xD6   0xF07F 0x0001      MVNS     R0,#+1
   \       0xDA   0xE00B             B.N      ??osEventFlagsWait_1
   1182          
   1183              case RTOS_ERR_WOULD_BLOCK:
   1184                if (rtn_flags != (uint32_t)0u) {
   \                     ??osEventFlagsWait_13: (+1)
   \       0xDC   0x2D00             CMP      R5,#+0
   \       0xDE   0xD001             BEQ.N    ??osEventFlagsWait_17
   1185                  return rtn_flags;
   \       0xE0   0x0028             MOVS     R0,R5
   \       0xE2   0xE007             B.N      ??osEventFlagsWait_1
   1186                } else {
   1187                  return osFlagsErrorResource;
   \                     ??osEventFlagsWait_17: (+1)
   \       0xE4   0xF07F 0x0002      MVNS     R0,#+2
   \       0xE8   0xE004             B.N      ??osEventFlagsWait_1
   1188                }
   1189          
   1190              case RTOS_ERR_OS_OBJ_DEL:
   1191              case RTOS_ERR_OS_SCHED_LOCKED:
   1192              case RTOS_ERR_ABORT:
   1193                return osFlagsErrorResource;
   \                     ??osEventFlagsWait_14: (+1)
   \       0xEA   0xF07F 0x0002      MVNS     R0,#+2
   \       0xEE   0xE001             B.N      ??osEventFlagsWait_1
   1194          
   1195              default:
   1196                return osFlagsErrorUnknown;
   \                     ??osEventFlagsWait_16: (+1)
   \       0xF0   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??osEventFlagsWait_1: (+1)
   \       0xF4   0xB009             ADD      SP,SP,#+36
   \       0xF6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1197            }
   1198          #else
   1199            (void)ef_id;
   1200            (void)flags;
   1201            (void)options;
   1202            (void)timeout;
   1203            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osFlagsErrorUnknown);
   1204            return osFlagsErrorUnknown;
   1205          #endif
   1206          }
   1207          
   1208          /*
   1209           ****************************************************************************************************
   1210           *                                        osEventFlagsDelete()
   1211           *
   1212           * Description: The function 'osEventFlagsDelete()' deletes the event flags object specified by parameter
   1213           *              'ef_id' and releases the internal memory obtained for the event flags handling.
   1214           *
   1215           *              After this call, the 'ef_id' is no longer valid and cannot be used.  This can cause starvation
   1216           *              of threads that are waiting for flags of this event object.  The 'ef_id' may be created again
   1217           *              using the function 'osEventFlagsNew()'.
   1218           *
   1219           * Arguments  : ef_id                   Is the ID of the events flags to delete
   1220           *
   1221           * Returns    : osOK                    the specified event flags object was deleted
   1222           *              osErrorISR              the function was called from an ISR
   1223           *              osErrorParameter        parameter 'ef_id' does not identify a valid event flags object
   1224           *              osErrorResource         the event flags object is in an invalid state.
   1225           *
   1226           * Note(s)    : 1) This function cannot be called from an ISR.
   1227           ****************************************************************************************************
   1228           */

   \                                 In section .text, align 2, keep-with-next
   1229          osStatus_t  osEventFlagsDelete(osEventFlagsId_t  ef_id)
   1230          {
   \                     osEventFlagsDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   1231          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   1232            osEventFlags_t *p_flags;
   1233            RTOS_ERR        err;
   1234          
   1235            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osEventFlagsDelete_0
   1236              return osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE018             B.N      ??osEventFlagsDelete_1
   1237            }
   1238          
   1239            p_flags = (osEventFlags_t *)ef_id;
   \                     ??osEventFlagsDelete_0: (+1)
   \       0x14   0x002C             MOVS     R4,R5
   1240            if (p_flags == (osEventFlags_t *)0) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osEventFlagsDelete_2
   1241              return osErrorParameter;
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE012             B.N      ??osEventFlagsDelete_1
   1242            }
   1243          
   1244            OSFlagDel(&p_flags->flag_grp, OS_OPT_DEL_ALWAYS, &err);
   \                     ??osEventFlagsDelete_2: (+1)
   \       0x20   0x466A             MOV      R2,SP
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       OSFlagDel
   1245          
   1246            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x2A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??osEventFlagsDelete_3
   1247              case RTOS_ERR_NONE:
   1248                if (p_flags->dyn_alloc == DEF_TRUE) {
   \       0x32   0x7C20             LDRB     R0,[R4, #+16]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD102             BNE.N    ??osEventFlagsDelete_4
   1249                  free(p_flags);
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       free
   1250                }
   1251                return osOK;
   \                     ??osEventFlagsDelete_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE001             B.N      ??osEventFlagsDelete_1
   1252          
   1253              case RTOS_ERR_OS_ILLEGAL_RUN_TIME:
   1254              case RTOS_ERR_OS_TASK_WAITING:
   1255              default:
   1256                return osErrorResource;
   \                     ??osEventFlagsDelete_3: (+1)
   \       0x42   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osEventFlagsDelete_1: (+1)
   \       0x46   0xB005             ADD      SP,SP,#+20
   \       0x48   0xBD30             POP      {R4,R5,PC}
   1257            }
   1258          #else
   1259            (void)ef_id;
   1260            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osFlagsErrorUnknown);
   1261            return osError;
   1262          #endif
   1263          }
   1264          
   1265          /*
   1266           ****************************************************************************************************
   1267           *                                        osEventFlagsGetName()
   1268           *
   1269           * Description: The function 'osEventFlagsGetName()' gets the name of the event flags object specified
   1270           *              by parameter 'ef_id'.
   1271           *
   1272           * Arguments  : ef_id    Is the events flags ID
   1273           *
   1274           * Returns    : A pointer to the name   upon success
   1275           *              NULL                    upon failure
   1276           *
   1277           * Note(s)    : 1) This function cannot be called from an ISR
   1278           ****************************************************************************************************
   1279           */

   \                                 In section .text, align 2, keep-with-next
   1280          const  char  *osEventFlagsGetName(osEventFlagsId_t  ef_id)
   1281          {
   \                     osEventFlagsGetName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1282          #if (OS_CFG_FLAG_EN == DEF_ENABLED) && (OS_CFG_DBG_EN == DEF_ENABLED)
   1283            osEventFlags_t *p_flags;
   1284            CPU_CHAR       *p_name;
   1285          
   1286            p_flags = (osEventFlags_t *)ef_id;
   1287            if (p_flags == (osEventFlags_t *)0) {
   1288              return 0u;
   1289            }
   1290          
   1291            p_name = p_flags->flag_grp.NamePtr;   // Get name of the event flags
   1292            return p_name;
   1293          #else
   1294            (void)ef_id;
   1295            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   1296            return 0u;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   1297          #endif
   1298          }
   1299          
   1300          /*
   1301           ****************************************************************************************************
   1302           ****************************************************************************************************
   1303           *                         M U T U A L   E X C L U S I O N   S E M A P H O R E S
   1304           ****************************************************************************************************
   1305           ****************************************************************************************************
   1306           */
   1307          
   1308          /*
   1309           ****************************************************************************************************
   1310           *                                            osMutexNew()
   1311           *
   1312           * Description: The function 'osMutexNew()' creates and initializes a new mutex object and returns the
   1313           *              pointer to the mutex object identifier or NULL in case of an error.  It can be safely
   1314           *              called before the RTOS is started (call to 'osKernelStart()'), but not before it is
   1315           *              initialized (call to 'osKernelInitialize()').
   1316           *
   1317           *              The parameter 'attr' sets the mutex object attributes (refer to 'osMutexAttr_t').
   1318           *              Default attributes will be used if set to NULL.
   1319           *
   1320           * Arguments  : attr     sets the mutex attributes or default values if NULL
   1321           *
   1322           *                       .name        is an ASCII string used to name the mutex
   1323           *
   1324           *                       .attr_bits   can have the following attributes:
   1325           *
   1326           *                                    osMutexRecursive
   1327           *                                    osMutexPrioInherit
   1328           *                                    osMutexRobust
   1329           *
   1330           *                       .cb_mem      Pointer to storage area for the mutex control block
   1331           *
   1332           *                       .cb_size     Size of the memory storage for the mutex control block
   1333           *
   1334           * Returns    : The mutex ID
   1335           *
   1336           * Note(s)    : 1) MicriumOS does NOT support the osMutexRobust attribute.  The user must explicitely
   1337           *                 release ownership of the mutex before deleting a task.
   1338           *
   1339           *              2) MicriumOS mutexes are always recursive and support priority inheritance.  Those
   1340           *                 attributes cannot be disabled.
   1341           *
   1342           *              3) The memory control block is assumed to be of type 'osMutex_t' which for the CMSIS-RTOS
   1343           *                 adaptation layer is defined as an OS_MUTEX in MicriumOS.
   1344           ****************************************************************************************************
   1345           */

   \                                 In section .text, align 2, keep-with-next
   1346          osMutexId_t  osMutexNew(const  osMutexAttr_t  *attr)
   1347          {
   \                     osMutexNew: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1348          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   1349            osMutex_t    *p_mutex;
   1350            CPU_CHAR     *p_name;
   1351            RTOS_ERR      err;
   1352          
   1353            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??osMutexNew_0
   1354              return (osMutexId_t)0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE049             B.N      ??osMutexNew_1
   1355            }
   1356          
   1357            p_name = (CPU_CHAR *)"Mutex";
   \                     ??osMutexNew_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R6,??DataTable17
   1358            if (attr == 0) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD10A             BNE.N    ??osMutexNew_2
   1359              p_mutex = (osMutex_t *)malloc(sizeof(osMutex_t));
   \       0x18   0x201C             MOVS     R0,#+28
   \       0x1A   0x.... 0x....      BL       malloc
   \       0x1E   0x0005             MOVS     R5,R0
   1360              if (p_mutex == (osMutex_t *)0) {
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD101             BNE.N    ??osMutexNew_3
   1361                return (osMutexId_t)0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE03D             B.N      ??osMutexNew_1
   1362              }
   1363              p_mutex->dyn_alloc = DEF_TRUE;
   \                     ??osMutexNew_3: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x7628             STRB     R0,[R5, #+24]
   \       0x2C   0xE01E             B.N      ??osMutexNew_4
   1364            } else {
   1365              if (attr->cb_mem == (void *)0) {
   \                     ??osMutexNew_2: (+1)
   \       0x2E   0x68A0             LDR      R0,[R4, #+8]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD10A             BNE.N    ??osMutexNew_5
   1366                p_mutex = (osMutex_t*)malloc(sizeof(osMutex_t));
   \       0x34   0x201C             MOVS     R0,#+28
   \       0x36   0x.... 0x....      BL       malloc
   \       0x3A   0x0005             MOVS     R5,R0
   1367                if (p_mutex == (osMutex_t*)0) {
   \       0x3C   0x2D00             CMP      R5,#+0
   \       0x3E   0xD101             BNE.N    ??osMutexNew_6
   1368                  return (osMutexId_t)0;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xE02F             B.N      ??osMutexNew_1
   1369                }
   1370                p_mutex->dyn_alloc = DEF_TRUE;
   \                     ??osMutexNew_6: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x7628             STRB     R0,[R5, #+24]
   \       0x48   0xE00B             B.N      ??osMutexNew_7
   1371              } else {
   1372                if (attr->cb_size < sizeof(osMutex_t) || (uint32_t)attr->cb_mem % sizeof(CPU_ALIGN)) {
   \                     ??osMutexNew_5: (+1)
   \       0x4A   0x68E0             LDR      R0,[R4, #+12]
   \       0x4C   0x281C             CMP      R0,#+28
   \       0x4E   0xD303             BCC.N    ??osMutexNew_8
   \       0x50   0x7A20             LDRB     R0,[R4, #+8]
   \       0x52   0xF010 0x0F03      TST      R0,#0x3
   \       0x56   0xD001             BEQ.N    ??osMutexNew_9
   1373                  return (osMutexId_t)0;
   \                     ??osMutexNew_8: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xE023             B.N      ??osMutexNew_1
   1374                }
   1375                p_mutex = (osMutex_t *)attr->cb_mem;
   \                     ??osMutexNew_9: (+1)
   \       0x5C   0x68A5             LDR      R5,[R4, #+8]
   1376                p_mutex->dyn_alloc = DEF_FALSE;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x7628             STRB     R0,[R5, #+24]
   1377              }
   1378              if (attr->name != (const char *)0) {
   \                     ??osMutexNew_7: (+1)
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD001             BEQ.N    ??osMutexNew_4
   1379                p_name = (CPU_CHAR *)attr->name;
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x0006             MOVS     R6,R0
   1380              }
   1381            }
   1382          
   1383            OSMutexCreate(&p_mutex->mutex, p_name, &err);
   \                     ??osMutexNew_4: (+1)
   \       0x6C   0x466A             MOV      R2,SP
   \       0x6E   0x0031             MOVS     R1,R6
   \       0x70   0x0028             MOVS     R0,R5
   \       0x72   0x.... 0x....      BL       OSMutexCreate
   1384          
   1385            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x76   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD007             BEQ.N    ??osMutexNew_10
   1386              if (p_mutex->dyn_alloc == DEF_TRUE) {
   \       0x7E   0x7E28             LDRB     R0,[R5, #+24]
   \       0x80   0x2801             CMP      R0,#+1
   \       0x82   0xD102             BNE.N    ??osMutexNew_11
   1387                free(p_mutex);
   \       0x84   0x0028             MOVS     R0,R5
   \       0x86   0x.... 0x....      BL       free
   1388              }
   1389              return (osMutexId_t)0;
   \                     ??osMutexNew_11: (+1)
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xE00A             B.N      ??osMutexNew_1
   1390            }
   1391          
   1392            if (attr != NULL && (attr->attr_bits & osMutexRecursive)) {
   \                     ??osMutexNew_10: (+1)
   \       0x8E   0x2C00             CMP      R4,#+0
   \       0x90   0xD005             BEQ.N    ??osMutexNew_12
   \       0x92   0x7920             LDRB     R0,[R4, #+4]
   \       0x94   0x07C0             LSLS     R0,R0,#+31
   \       0x96   0xD502             BPL.N    ??osMutexNew_12
   1393              p_mutex->recursive = DEF_TRUE;
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0x7668             STRB     R0,[R5, #+25]
   \       0x9C   0xE001             B.N      ??osMutexNew_13
   1394            } else {
   1395              p_mutex->recursive = DEF_FALSE;
   \                     ??osMutexNew_12: (+1)
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x7668             STRB     R0,[R5, #+25]
   1396            }
   1397          
   1398            return (osMutexId_t)p_mutex;
   \                     ??osMutexNew_13: (+1)
   \       0xA2   0x0028             MOVS     R0,R5
   \                     ??osMutexNew_1: (+1)
   \       0xA4   0xB004             ADD      SP,SP,#+16
   \       0xA6   0xBD70             POP      {R4-R6,PC}
   1399          #else
   1400            (void)attr;
   1401            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, (osMutexId_t)0);
   1402            return (osMutexId_t)0;
   1403          #endif
   1404          }
   1405          
   1406          /*
   1407           ****************************************************************************************************
   1408           *                                           osMutexGetName()
   1409           *
   1410           * Description: The function 'osMutexGetName()' returns the pointer to the name string of the mutex
   1411           *              identified by parameter 'mutex_id' or NULL in case of an error.
   1412           *
   1413           * Arguments  : mutex_id     is the mutex ID returned by 'osMutexNew()'
   1414           *
   1415           * Returns    : A pointer to the ASCII string containing the name of the mutex.
   1416           *              NULL             upon error
   1417           *
   1418           * Note(s)    : 1) This function CANNOT be called from an ISR
   1419           ****************************************************************************************************
   1420           */

   \                                 In section .text, align 2, keep-with-next
   1421          const  char  *osMutexGetName(osMutexId_t  mutex_id)
   1422          {
   \                     osMutexGetName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1423          #if (OS_CFG_MUTEX_EN == DEF_ENABLED) && (OS_CFG_DBG_EN == DEF_ENABLED)
   1424            osMutex_t    *p_mutex;
   1425          
   1426            if (CORE_InIrqContext() == true) {
   1427              return NULL;
   1428            }
   1429          
   1430            p_mutex = (osMutex_t *)mutex_id;
   1431            if (p_mutex == (osMutex_t *)0) {
   1432              return NULL;
   1433            }
   1434          
   1435            return p_mutex->mutex.NamePtr;
   1436          #else
   1437            (void)mutex_id;
   1438            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, NULL);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   1439            return NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   1440          #endif
   1441          }
   1442          
   1443          /*
   1444           ****************************************************************************************************
   1445           *                                            osMutexAcquire()
   1446           *
   1447           * Description: The blocking function 'osMutexAcquire()' waits until a mutex object specified by parameter
   1448           *              mutex_id becomes available.  If no other thread has obtained the mutex, the function
   1449           *              instantly returns and blocks the mutex object.
   1450           *
   1451           *              The parameter timeout specifies how long the system waits to acquire the mutex.  While
   1452           *              the system waits, the thread that is calling this function is put into the BLOCKED state.
   1453           *              The parameter timeout can have the following values:
   1454           *
   1455           * Arguments  : mutex_id         is the mutex ID returned by 'osMutexNew()'
   1456           *
   1457           *              timeout          when timeout is 0, the function returns instantly (i.e. try semantics).
   1458           *                               when timeout is set to osWaitForever the function will wait for an infinite
   1459           *                                   time until the mutex becomes available (i.e. wait semantics).
   1460           *                               all other values specify a time in kernel ticks for a timeout
   1461           *                                   (i.e. timed-wait semantics).Timeout Value or 0 in case of no time-out.
   1462           *
   1463           * Returns    : osOK             the token has been obtained and the token count decremented.
   1464           *              osErrorTimeout   the token could not be obtained in the given time.
   1465           *              osErrorResource  the token could not be obtained when no timeout was specified.
   1466           *              osErrorParameter the parameter semaphore_id is NULL or invalid.
   1467           *              osErrorISR       cannot be called from an ISR
   1468           *
   1469           * Note(s)    : 1) This function CANNOT be called from an ISR
   1470           ****************************************************************************************************
   1471           */

   \                                 In section .text, align 2, keep-with-next
   1472          osStatus_t  osMutexAcquire(osMutexId_t  mutex_id,
   1473                                     uint32_t     timeout)
   1474          {
   \                     osMutexAcquire: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
   1475          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   1476            OS_OPT      opt;
   1477            osMutex_t  *p_mutex;
   1478            RTOS_ERR    err;
   1479            CPU_TS      ts;
   1480          
   1481            if (CORE_InIrqContext() == true) {
   \        0x8   0x.... 0x....      BL       CORE_InIrqContext
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD102             BNE.N    ??osMutexAcquire_0
   1482              return osErrorISR;
   \       0x10   0xF07F 0x0005      MVNS     R0,#+5
   \       0x14   0xE030             B.N      ??osMutexAcquire_1
   1483            }
   1484          
   1485            p_mutex = (osMutex_t *)mutex_id;
   \                     ??osMutexAcquire_0: (+1)
   \       0x16   0x0035             MOVS     R5,R6
   1486            if (p_mutex == (osMutex_t *)0) {
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD102             BNE.N    ??osMutexAcquire_2
   1487              return osErrorParameter;
   \       0x1C   0xF07F 0x0003      MVNS     R0,#+3
   \       0x20   0xE02A             B.N      ??osMutexAcquire_1
   1488            }
   1489            if (timeout == 0u) {
   \                     ??osMutexAcquire_2: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD102             BNE.N    ??osMutexAcquire_3
   1490              opt = OS_OPT_PEND_NON_BLOCKING;
   \       0x26   0xF44F 0x4700      MOV      R7,#+32768
   \       0x2A   0xE000             B.N      ??osMutexAcquire_4
   1491            } else {
   1492              opt = OS_OPT_PEND_BLOCKING;
   \                     ??osMutexAcquire_3: (+1)
   \       0x2C   0x2700             MOVS     R7,#+0
   1493            }
   1494          
   1495            if (timeout == osWaitForever) {
   \                     ??osMutexAcquire_4: (+1)
   \       0x2E   0xF114 0x0F01      CMN      R4,#+1
   \       0x32   0xD101             BNE.N    ??osMutexAcquire_5
   1496              timeout = 0u;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x0004             MOVS     R4,R0
   1497            }
   1498          
   1499            OSMutexPend(&p_mutex->mutex, (OS_TICK)timeout, opt, &ts, &err);
   \                     ??osMutexAcquire_5: (+1)
   \       0x38   0xA802             ADD      R0,SP,#+8
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0xAB01             ADD      R3,SP,#+4
   \       0x3E   0x003A             MOVS     R2,R7
   \       0x40   0xB292             UXTH     R2,R2
   \       0x42   0x0021             MOVS     R1,R4
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0x.... 0x....      BL       OSMutexPend
   1500          
   1501            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x4A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD00B             BEQ.N    ??osMutexAcquire_6
   \       0x52   0x2822             CMP      R0,#+34
   \       0x54   0xD00B             BEQ.N    ??osMutexAcquire_7
   \       0x56   0x2823             CMP      R0,#+35
   \       0x58   0xD10C             BNE.N    ??osMutexAcquire_8
   1502              case RTOS_ERR_IS_OWNER:
   1503                if (p_mutex->recursive == DEF_FALSE) {
   \                     ??osMutexAcquire_9: (+1)
   \       0x5A   0x7E68             LDRB     R0,[R5, #+25]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD102             BNE.N    ??osMutexAcquire_10
   1504                  return osErrorResource;
   \       0x60   0xF07F 0x0002      MVNS     R0,#+2
   \       0x64   0xE008             B.N      ??osMutexAcquire_1
   1505                }
   1506                return osOK;
   \                     ??osMutexAcquire_10: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE006             B.N      ??osMutexAcquire_1
   1507          
   1508              case RTOS_ERR_NONE:
   1509                return osOK;
   \                     ??osMutexAcquire_6: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xE004             B.N      ??osMutexAcquire_1
   1510          
   1511              case RTOS_ERR_TIMEOUT:
   1512                return osErrorTimeout;
   \                     ??osMutexAcquire_7: (+1)
   \       0x6E   0xF07F 0x0001      MVNS     R0,#+1
   \       0x72   0xE001             B.N      ??osMutexAcquire_1
   1513          
   1514              case RTOS_ERR_OS_OBJ_DEL:
   1515              case RTOS_ERR_WOULD_OVF:
   1516              case RTOS_ERR_OS_SCHED_LOCKED:
   1517              case RTOS_ERR_ABORT:
   1518              case RTOS_ERR_WOULD_BLOCK:
   1519              default:
   1520                return osErrorResource;
   \                     ??osMutexAcquire_8: (+1)
   \       0x74   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osMutexAcquire_1: (+1)
   \       0x78   0xB007             ADD      SP,SP,#+28
   \       0x7A   0xBDF0             POP      {R4-R7,PC}
   1521            }
   1522          #else
   1523            (void)mutex_id;
   1524            (void)timeout;
   1525            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   1526            return osError;
   1527          #endif
   1528          }
   1529          
   1530          /*
   1531           ****************************************************************************************************
   1532           *                                            osMutexRelease()
   1533           *
   1534           * Description: The function 'osMutexRelease()' releases a mutex specified by parameter 'mutex_id'.
   1535           *              Other threads that currently wait for this mutex will be put into the READY state.
   1536           *
   1537           * Arguments  : mutex_id         is the mutex ID returned by 'osMutexNew()'
   1538           *
   1539           * Returns    : osOK             the mutex has been released and the count incremented.
   1540           *              osErrorResource  the mutex could not be released
   1541           *              osErrorParameter the parameter mutex_id is NULL or invalid.
   1542           *              osErrorISR       if called from an ISR
   1543           *
   1544           * Note(s)    : 1) This function CANNOT be called from an ISR
   1545           *
   1546           *              2) MicriumOS always allows mutex nesting and thus that feature cannot be disabled.
   1547           ****************************************************************************************************
   1548           */

   \                                 In section .text, align 2, keep-with-next
   1549          osStatus_t  osMutexRelease(osMutexId_t  mutex_id)
   1550          {
   \                     osMutexRelease: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   1551          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   1552            osMutex_t    *p_mutex;
   1553            RTOS_ERR      err;
   1554          
   1555            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osMutexRelease_0
   1556              return osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE014             B.N      ??osMutexRelease_1
   1557            }
   1558          
   1559            p_mutex = (osMutex_t *)mutex_id;
   \                     ??osMutexRelease_0: (+1)
   \       0x14   0x002C             MOVS     R4,R5
   1560          
   1561            if (p_mutex == (osMutex_t *)0) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osMutexRelease_2
   1562              return osErrorParameter;
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE00E             B.N      ??osMutexRelease_1
   1563            }
   1564          
   1565            OSMutexPost(&p_mutex->mutex, OS_OPT_POST_NONE, &err);
   \                     ??osMutexRelease_2: (+1)
   \       0x20   0x466A             MOV      R2,SP
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       OSMutexPost
   1566          
   1567            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x2A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD001             BEQ.N    ??osMutexRelease_3
   \       0x32   0x2823             CMP      R0,#+35
   \       0x34   0xD101             BNE.N    ??osMutexRelease_4
   1568              case RTOS_ERR_NONE:
   1569              case RTOS_ERR_IS_OWNER:
   1570                return osOK;
   \                     ??osMutexRelease_3: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE001             B.N      ??osMutexRelease_1
   1571          
   1572              case RTOS_ERR_OWNERSHIP:
   1573              default:
   1574                return osErrorResource;
   \                     ??osMutexRelease_4: (+1)
   \       0x3A   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osMutexRelease_1: (+1)
   \       0x3E   0xB005             ADD      SP,SP,#+20
   \       0x40   0xBD30             POP      {R4,R5,PC}
   1575            }
   1576          #else
   1577            (void)mutex_id;
   1578            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   1579            return osError;
   1580          #endif
   1581          }
   1582          
   1583          /*
   1584           ****************************************************************************************************
   1585           *                                        osMutexGetOwner()
   1586           *
   1587           * Description: The function 'osMutexGetOwner()' returns the thread ID of the thread that acquired a
   1588           *              mutex specified by parameter 'mutex_id'.  In case of an error or if the mutex is not
   1589           *              blocked by any thread, it returns NULL.
   1590           *
   1591           * Arguments  : mutex_id     is the mutex ID returned by 'osMutexNew()'
   1592           *
   1593           * Returns    : the theard ID of the mutex owner
   1594           *
   1595           * Note(s)    : None
   1596           ****************************************************************************************************
   1597           */

   \                                 In section .text, align 2, keep-with-next
   1598          osThreadId_t  osMutexGetOwner(osMutexId_t  mutex_id)
   1599          {
   \                     osMutexGetOwner: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   1600          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   1601            osMutex_t  *p_mutex;
   1602            osThread_t *p_thread;
   1603          
   1604            p_mutex = (osMutex_t *)mutex_id;
   \        0x4   0x003C             MOVS     R4,R7
   1605          
   1606            if (p_mutex == (osMutex_t *)0) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??osMutexGetOwner_0
   1607              return 0u;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE007             B.N      ??osMutexGetOwner_1
   1608            }
   1609          
   1610            CORE_DECLARE_IRQ_STATE;
   1611            CORE_ENTER_CRITICAL();
   \                     ??osMutexGetOwner_0: (+1)
   \        0xE   0x.... 0x....      BL       CORE_EnterCritical
   \       0x12   0x0005             MOVS     R5,R0
   1612            p_thread = (osThread_t *)p_mutex->mutex.OwnerTCBPtr;
   \       0x14   0x6926             LDR      R6,[R4, #+16]
   1613            CORE_EXIT_CRITICAL();
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x.... 0x....      BL       CORE_ExitCritical
   1614            return (osThreadId_t)p_thread;
   \       0x1C   0x0030             MOVS     R0,R6
   \                     ??osMutexGetOwner_1: (+1)
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}
   1615          #else
   1616            (void)mutex_id;
   1617            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
   1618            return 0u;
   1619          #endif
   1620          }
   1621          
   1622          /*
   1623           ****************************************************************************************************
   1624           *                                            osMutexDelete()
   1625           *
   1626           * Description: The function 'osMutexDelete()' deletes a mutex object specified by parameter 'mutex_id'.
   1627           *              It releases internal memory obtained for mutex handling.  After this call, the 'mutex_id'
   1628           *              is no longer valid and cannot be used.
   1629           *
   1630           *              The mutex may be created again using the function 'osMutexNew()'.
   1631           *
   1632           * Arguments  : mutex_id         is the mutex ID returned by 'osMutexNew()'
   1633           *
   1634           * Returns    : osOK             the mutex object has been deleted.
   1635           *              osErrorParameter the parameter mutex_id is NULL or invalid.
   1636           *              osErrorResource  the mutex is in an invalid state.
   1637           *              osErrorISR       osMutexDelete() cannot be called from interrupt service routines.
   1638           *
   1639           * Note(s)    : 1) This function CANNOT be called from an ISR
   1640           ****************************************************************************************************
   1641           */

   \                                 In section .text, align 2, keep-with-next
   1642          osStatus_t  osMutexDelete(osMutexId_t  mutex_id)
   1643          {
   \                     osMutexDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   1644          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   1645            osMutex_t  *p_mutex;
   1646            RTOS_ERR    err;
   1647          
   1648            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osMutexDelete_0
   1649              return osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE018             B.N      ??osMutexDelete_1
   1650            }
   1651          
   1652            p_mutex = (osMutex_t *)mutex_id;
   \                     ??osMutexDelete_0: (+1)
   \       0x14   0x002C             MOVS     R4,R5
   1653            if (p_mutex == (osMutex_t *)0) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osMutexDelete_2
   1654              return osErrorParameter;
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE012             B.N      ??osMutexDelete_1
   1655            }
   1656          
   1657            OSMutexDel(&p_mutex->mutex, OS_OPT_DEL_ALWAYS, &err);
   \                     ??osMutexDelete_2: (+1)
   \       0x20   0x466A             MOV      R2,SP
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       OSMutexDel
   1658          
   1659            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x2A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??osMutexDelete_3
   1660              case RTOS_ERR_NONE:
   1661                if (p_mutex->dyn_alloc == DEF_TRUE) {
   \       0x32   0x7E20             LDRB     R0,[R4, #+24]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD102             BNE.N    ??osMutexDelete_4
   1662                  free(p_mutex);
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       free
   1663                }
   1664                return osOK;
   \                     ??osMutexDelete_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE001             B.N      ??osMutexDelete_1
   1665          
   1666              case RTOS_ERR_OS_ILLEGAL_RUN_TIME:
   1667              case RTOS_ERR_OS_TASK_WAITING:
   1668              default:
   1669                return osErrorResource;
   \                     ??osMutexDelete_3: (+1)
   \       0x42   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osMutexDelete_1: (+1)
   \       0x46   0xB005             ADD      SP,SP,#+20
   \       0x48   0xBD30             POP      {R4,R5,PC}
   1670            }
   1671          #else
   1672            (void)mutex_id;
   1673            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   1674            return osError;
   1675          #endif
   1676          }
   1677          
   1678          /*
   1679           ****************************************************************************************************
   1680           ****************************************************************************************************
   1681           *                               S E M A P H O R E   M A N A G E M E N T
   1682           ****************************************************************************************************
   1683           ****************************************************************************************************
   1684           */
   1685          
   1686          /*
   1687           ****************************************************************************************************
   1688           *                                        osSemaphoreNew()
   1689           *
   1690           * Description: The function 'osSemaphoreNew()' creates and initializes a semaphore object that is used
   1691           *              to manage access to shared resources and returns the pointer to the semaphore object
   1692           *              identifier or NULL in case of an error.
   1693           *
   1694           *              It can be safely called before the RTOS is started (call to 'osKernelStart()'), but not
   1695           *              before it is initialized (call to 'osKernelInitialize()').
   1696           *
   1697           *              The parameter 'max_count' specifies the maximum number of available tokens.  A 'max_count'
   1698           *              value of 1 creates a binary semaphore.
   1699           *
   1700           *              The parameter 'initial_count' sets the initial number of available tokens.
   1701           *
   1702           *              The parameter 'attr' specifies additional semaphore attributes.  Default attributes will
   1703           *              be used if set to NULL.
   1704           *
   1705           * Arguments  : max_count       maximum number of available tokens.
   1706           *
   1707           *              initial_count   initial number of available tokens.
   1708           *
   1709           *              attr            semaphore attributes; NULL: default values.
   1710           *
   1711           * Returns    : semaphore ID for reference by other functions or NULL in case of error.
   1712           *
   1713           * Note(s)    : 1) This function CANNOT be called from an ISR
   1714           *
   1715           *              2) MicriumOS does not support a maximum count so the first argument is ignored.
   1716           ****************************************************************************************************
   1717           */

   \                                 In section .text, align 2, keep-with-next
   1718          osSemaphoreId_t  osSemaphoreNew(uint32_t                   max_count,
   1719                                          uint32_t                   initial_count,
   1720                                          const  osSemaphoreAttr_t   *attr)
   1721          {
   \                     osSemaphoreNew: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x0016             MOVS     R6,R2
   1722          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   1723            osSemaphore_t *p_sem;
   1724            CPU_CHAR      *p_name;
   1725            RTOS_ERR       err;
   1726          
   1727            if (CORE_InIrqContext() == true) {
   \        0xA   0x.... 0x....      BL       CORE_InIrqContext
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD101             BNE.N    ??osSemaphoreNew_0
   1728              return (osSemaphoreId_t)0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE044             B.N      ??osSemaphoreNew_1
   1729            }
   1730          
   1731            if (max_count == 0u) {
   \                     ??osSemaphoreNew_0: (+1)
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD101             BNE.N    ??osSemaphoreNew_2
   1732              return (osSemaphoreId_t)0;   // Cannot specify a 0 value for max count
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE040             B.N      ??osSemaphoreNew_1
   1733            }
   1734          
   1735            p_name = (CPU_CHAR *)"Semaphore";
   \                     ??osSemaphoreNew_2: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R7,??DataTable18
   1736            if (attr == 0) {
   \       0x22   0x2E00             CMP      R6,#+0
   \       0x24   0xD10A             BNE.N    ??osSemaphoreNew_3
   1737              p_sem = (osSemaphore_t *)malloc(sizeof(osSemaphore_t));
   \       0x26   0x2018             MOVS     R0,#+24
   \       0x28   0x.... 0x....      BL       malloc
   \       0x2C   0x0004             MOVS     R4,R0
   1738              if (p_sem == (osSemaphore_t *)0) {
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD101             BNE.N    ??osSemaphoreNew_4
   1739                return (osSemaphoreId_t)0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE034             B.N      ??osSemaphoreNew_1
   1740              }
   1741              p_sem->dyn_alloc = DEF_TRUE;
   \                     ??osSemaphoreNew_4: (+1)
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0x7420             STRB     R0,[R4, #+16]
   \       0x3A   0xE01E             B.N      ??osSemaphoreNew_5
   1742            } else {
   1743              if (attr->cb_mem == (void *)0) {
   \                     ??osSemaphoreNew_3: (+1)
   \       0x3C   0x68B0             LDR      R0,[R6, #+8]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD10A             BNE.N    ??osSemaphoreNew_6
   1744                p_sem = (osSemaphore_t *)malloc(sizeof(osSemaphore_t));
   \       0x42   0x2018             MOVS     R0,#+24
   \       0x44   0x.... 0x....      BL       malloc
   \       0x48   0x0004             MOVS     R4,R0
   1745                if (p_sem == (osSemaphore_t *)0) {
   \       0x4A   0x2C00             CMP      R4,#+0
   \       0x4C   0xD101             BNE.N    ??osSemaphoreNew_7
   1746                  return (osSemaphoreId_t)0;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xE026             B.N      ??osSemaphoreNew_1
   1747                }
   1748                p_sem->dyn_alloc = DEF_TRUE;
   \                     ??osSemaphoreNew_7: (+1)
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0x7420             STRB     R0,[R4, #+16]
   \       0x56   0xE00B             B.N      ??osSemaphoreNew_8
   1749              } else {
   1750                if (attr->cb_size < sizeof(osSemaphore_t) || (uint32_t)attr->cb_mem % sizeof(CPU_ALIGN)) {
   \                     ??osSemaphoreNew_6: (+1)
   \       0x58   0x68F0             LDR      R0,[R6, #+12]
   \       0x5A   0x2818             CMP      R0,#+24
   \       0x5C   0xD303             BCC.N    ??osSemaphoreNew_9
   \       0x5E   0x7A30             LDRB     R0,[R6, #+8]
   \       0x60   0xF010 0x0F03      TST      R0,#0x3
   \       0x64   0xD001             BEQ.N    ??osSemaphoreNew_10
   1751                  return (osSemaphoreId_t)0;
   \                     ??osSemaphoreNew_9: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE01A             B.N      ??osSemaphoreNew_1
   1752                }
   1753                p_sem = (osSemaphore_t *)attr->cb_mem;
   \                     ??osSemaphoreNew_10: (+1)
   \       0x6A   0x68B4             LDR      R4,[R6, #+8]
   1754                p_sem->dyn_alloc = DEF_FALSE;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x7420             STRB     R0,[R4, #+16]
   1755              }
   1756              if (attr->name != (const char *)0) {
   \                     ??osSemaphoreNew_8: (+1)
   \       0x70   0x6830             LDR      R0,[R6, #+0]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD001             BEQ.N    ??osSemaphoreNew_5
   1757                p_name = (CPU_CHAR *)attr->name;
   \       0x76   0x6830             LDR      R0,[R6, #+0]
   \       0x78   0x0007             MOVS     R7,R0
   1758              }
   1759            }
   1760          
   1761            OSSemCreate(&p_sem->sem, p_name, initial_count, &err);
   \                     ??osSemaphoreNew_5: (+1)
   \       0x7A   0x466B             MOV      R3,SP
   \       0x7C   0x4642             MOV      R2,R8
   \       0x7E   0x0039             MOVS     R1,R7
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0x.... 0x....      BL       OSSemCreate
   1762          
   1763            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x86   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD007             BEQ.N    ??osSemaphoreNew_11
   1764              if (p_sem->dyn_alloc == DEF_TRUE) {
   \       0x8E   0x7C20             LDRB     R0,[R4, #+16]
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD102             BNE.N    ??osSemaphoreNew_12
   1765                free(p_sem);
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0x.... 0x....      BL       free
   1766              }
   1767              return (osSemaphoreId_t)0;
   \                     ??osSemaphoreNew_12: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xE000             B.N      ??osSemaphoreNew_1
   1768            }
   1769          
   1770            return (osSemaphoreId_t)p_sem;
   \                     ??osSemaphoreNew_11: (+1)
   \       0x9E   0x0020             MOVS     R0,R4
   \                     ??osSemaphoreNew_1: (+1)
   \       0xA0   0xB004             ADD      SP,SP,#+16
   \       0xA2   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1771          #else
   1772            (void)max_count;
   1773            (void)initial_count;
   1774            (void)attr;
   1775            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, (osSemaphoreId_t)0);
   1776            return (osSemaphoreId_t)0;
   1777          #endif
   1778          }
   1779          
   1780          /*
   1781           ****************************************************************************************************
   1782           *                                        osSemaphoreGetName()
   1783           *
   1784           * Description: The function 'osSemaphoreGetName()' returns the pointer to the name string of the semaphore
   1785           *              identified by parameter 'semaphore_id' or NULL in case of an error.
   1786           *
   1787           * Arguments  : semaphore_id     is the semaphore ID returned by 'osSemaphoreNew()'
   1788           *
   1789           * Returns    : A pointer to the ASCII string containing the name of the semaphore.
   1790           *              NULL             upon error
   1791           *
   1792           * Note(s)    : 1) This function CANNOT be called from an ISR
   1793           ****************************************************************************************************
   1794           */

   \                                 In section .text, align 2, keep-with-next
   1795          const  char  *osSemaphoreGetName(osSemaphoreId_t  semaphore_id)
   1796          {
   \                     osSemaphoreGetName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1797          #if (OS_CFG_SEM_EN == DEF_ENABLED) && (OS_CFG_DBG_EN == DEF_ENABLED)
   1798            osSemaphore_t *p_sem;
   1799          
   1800            if (CORE_InIrqContext() == true) {
   1801              return NULL;
   1802            }
   1803            p_sem = (osSemaphore_t *)semaphore_id;
   1804            if (p_sem == (osSemaphore_t *)0) {
   1805              return NULL;
   1806            }
   1807          
   1808            return p_sem->sem.NamePtr;
   1809          #else
   1810            (void)semaphore_id;
   1811            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, NULL);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   1812            return NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   1813          #endif
   1814          }
   1815          
   1816          /*
   1817           ****************************************************************************************************
   1818           *                                        osSemaphoreAcquire()
   1819           *
   1820           * Description: The blocking function 'osSemaphoreAcquire() waits until a token of the semaphore object
   1821           *              specified by parameter 'semaphore_id' becomes available.  If a token is available, the
   1822           *              function instantly returns and decrements the token count.
   1823           *
   1824           *              The parameter timeout specifies how long the system waits to acquire the token. While the
   1825           *              system waits, the thread that is calling this function is put into the BLOCKED state.
   1826           *              The parameter timeout can have the following values:
   1827           *
   1828           *              when timeout is 0, the function returns instantly (i.e. try semantics).
   1829           *
   1830           *              when timeout is set to 'osWaitForever' the function will wait for an infinite time until
   1831           *              the semaphore becomes available (i.e. wait semantics).
   1832           *
   1833           *              all other values specify a time in kernel ticks for a timeout (i.e. timed-wait semantics).
   1834           *
   1835           * Arguments  : semaphore_id     is the semaphore ID returned by 'osSemaphoreNew()'
   1836           *
   1837           *              timeout          Timeout Value or 0 in case of no time-out.
   1838           *
   1839           * Returns    : osOK             the token has been obtained and the token count decremented.
   1840           *              osErrorTimeout   the token could not be obtained in the given time.
   1841           *              osErrorResource  the token could not be obtained when no timeout was specified.
   1842           *              osErrorParameter the parameter semaphore_id is NULL or invalid.
   1843           *
   1844           * Note(s)    : 1) This function CANNOT be called from an ISR if you specify an NON-Zero timeout
   1845           ****************************************************************************************************
   1846           */

   \                                 In section .text, align 2, keep-with-next
   1847          osStatus_t  osSemaphoreAcquire(osSemaphoreId_t  semaphore_id,
   1848                                         uint32_t         timeout)
   1849          {
   \                     osSemaphoreAcquire: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
   1850          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   1851            osSemaphore_t *p_sem;
   1852            RTOS_ERR       err;
   1853            CPU_TS         ts;
   1854          
   1855            p_sem = (osSemaphore_t *)semaphore_id;
   \        0x8   0x0035             MOVS     R5,R6
   1856            if (p_sem == (osSemaphore_t *)0) {
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD102             BNE.N    ??osSemaphoreAcquire_0
   1857              return osErrorParameter;
   \        0xE   0xF07F 0x0003      MVNS     R0,#+3
   \       0x12   0xE02D             B.N      ??osSemaphoreAcquire_1
   1858            }
   1859            if (timeout == 0u) {
   \                     ??osSemaphoreAcquire_0: (+1)
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD109             BNE.N    ??osSemaphoreAcquire_2
   1860              OSSemPend(&p_sem->sem, (OS_TICK)0u, OS_OPT_PEND_NON_BLOCKING, &ts, &err);
   \       0x18   0xA802             ADD      R0,SP,#+8
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0xAB01             ADD      R3,SP,#+4
   \       0x1E   0xF44F 0x4200      MOV      R2,#+32768
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       OSSemPend
   \       0x2A   0xE013             B.N      ??osSemaphoreAcquire_3
   1861            } else {
   1862              if (CORE_InIrqContext() == true) {
   \                     ??osSemaphoreAcquire_2: (+1)
   \       0x2C   0x.... 0x....      BL       CORE_InIrqContext
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD102             BNE.N    ??osSemaphoreAcquire_4
   1863                return osErrorParameter;
   \       0x34   0xF07F 0x0003      MVNS     R0,#+3
   \       0x38   0xE01A             B.N      ??osSemaphoreAcquire_1
   1864              } else {
   1865                if (timeout == osWaitForever) {
   \                     ??osSemaphoreAcquire_4: (+1)
   \       0x3A   0xF114 0x0F01      CMN      R4,#+1
   \       0x3E   0xD101             BNE.N    ??osSemaphoreAcquire_5
   1866                  timeout = 0u;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x0004             MOVS     R4,R0
   1867                }
   1868                OSSemPend(&p_sem->sem, (OS_TICK)timeout, OS_OPT_PEND_BLOCKING, &ts, &err);
   \                     ??osSemaphoreAcquire_5: (+1)
   \       0x44   0xA802             ADD      R0,SP,#+8
   \       0x46   0x9000             STR      R0,[SP, #+0]
   \       0x48   0xAB01             ADD      R3,SP,#+4
   \       0x4A   0x2200             MOVS     R2,#+0
   \       0x4C   0x0021             MOVS     R1,R4
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0x.... 0x....      BL       OSSemPend
   1869              }
   1870            }
   1871          
   1872            switch (RTOS_ERR_CODE_GET(err)) {
   \                     ??osSemaphoreAcquire_3: (+1)
   \       0x54   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD002             BEQ.N    ??osSemaphoreAcquire_6
   \       0x5C   0x2822             CMP      R0,#+34
   \       0x5E   0xD002             BEQ.N    ??osSemaphoreAcquire_7
   \       0x60   0xE004             B.N      ??osSemaphoreAcquire_8
   1873              case RTOS_ERR_NONE:
   1874                return osOK;
   \                     ??osSemaphoreAcquire_6: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xE004             B.N      ??osSemaphoreAcquire_1
   1875          
   1876              case RTOS_ERR_TIMEOUT:
   1877                return osErrorTimeout;
   \                     ??osSemaphoreAcquire_7: (+1)
   \       0x66   0xF07F 0x0001      MVNS     R0,#+1
   \       0x6A   0xE001             B.N      ??osSemaphoreAcquire_1
   1878          
   1879              case RTOS_ERR_ABORT:
   1880              case RTOS_ERR_OS_SCHED_LOCKED:
   1881              case RTOS_ERR_WOULD_BLOCK:
   1882              case RTOS_ERR_OS_OBJ_DEL:
   1883              default:
   1884                return osErrorResource;
   \                     ??osSemaphoreAcquire_8: (+1)
   \       0x6C   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osSemaphoreAcquire_1: (+1)
   \       0x70   0xB006             ADD      SP,SP,#+24
   \       0x72   0xBD70             POP      {R4-R6,PC}
   1885            }
   1886          #else
   1887            (void)semaphore_id;
   1888            (void)timeout;
   1889            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   1890            return osError;
   1891          #endif
   1892          }
   1893          
   1894          /*
   1895           ****************************************************************************************************
   1896           *                                        osSemaphoreRelease()
   1897           *
   1898           * Description: The function 'osSemaphoreRelease()' releases a token of the semaphore object specified
   1899           *              by parameter 'semaphore_id'.  Tokens can only be released up to the maximum count
   1900           *              specified at creation time, see 'osSemaphoreNew()'.  Other threads that currently wait
   1901           *              for a token of this semaphore object will be put into the READY state.
   1902           *
   1903           * Arguments  : semaphore_id     is the semaphore ID returned by 'osSemaphoreNew()'
   1904           *
   1905           * Returns    : osOK             the token has been released and the count incremented.
   1906           *              osErrorResource  the token could not be released (maximum token count has been reached).
   1907           *              osErrorParameter the parameter semaphore_id is NULL or invalid.
   1908           *
   1909           * Note(s)    : None
   1910           ****************************************************************************************************
   1911           */

   \                                 In section .text, align 2, keep-with-next
   1912          osStatus_t  osSemaphoreRelease(osSemaphoreId_t  semaphore_id)
   1913          {
   \                     osSemaphoreRelease: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   1914          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   1915            osSemaphore_t *p_sem;
   1916            RTOS_ERR       err;
   1917          
   1918            p_sem = (osSemaphore_t *)semaphore_id;
   \        0x6   0x002C             MOVS     R4,R5
   1919            if (p_sem == (osSemaphore_t *)0) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD102             BNE.N    ??osSemaphoreRelease_0
   1920              return osErrorParameter;
   \        0xC   0xF07F 0x0003      MVNS     R0,#+3
   \       0x10   0xE00C             B.N      ??osSemaphoreRelease_1
   1921            }
   1922            (void)OSSemPost(&p_sem->sem, OS_OPT_POST_1, &err);
   \                     ??osSemaphoreRelease_0: (+1)
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       OSSemPost
   1923          
   1924            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x1C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??osSemaphoreRelease_2
   1925              case RTOS_ERR_NONE:
   1926                return osOK;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE001             B.N      ??osSemaphoreRelease_1
   1927          
   1928              case RTOS_ERR_WOULD_OVF:
   1929              default:
   1930                return osErrorResource;
   \                     ??osSemaphoreRelease_2: (+1)
   \       0x28   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osSemaphoreRelease_1: (+1)
   \       0x2C   0xB005             ADD      SP,SP,#+20
   \       0x2E   0xBD30             POP      {R4,R5,PC}
   1931            }
   1932          #else
   1933            (void)semaphore_id;
   1934            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   1935            return osError;
   1936          #endif
   1937          }
   1938          
   1939          /*
   1940           ****************************************************************************************************
   1941           *                                        osSemaphoreGetCount()
   1942           *
   1943           * Description: The function 'osSemaphoreGetCount()' returns the number of available tokens of the
   1944           *              semaphore object specified by parameter 'semaphore_id'.
   1945           *
   1946           *              In case of an error it returns 0.
   1947           *
   1948           * Arguments  : semaphore_id     is the semaphore ID returned by 'osSemaphoreNew()'
   1949           *
   1950           * Returns    : the number of tokens available
   1951           *
   1952           * Note(s)    : None
   1953           ****************************************************************************************************
   1954           */

   \                                 In section .text, align 2, keep-with-next
   1955          uint32_t  osSemaphoreGetCount(osSemaphoreId_t  semaphore_id)
   1956          {
   \                     osSemaphoreGetCount: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   1957          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   1958            osSemaphore_t *p_sem;
   1959            uint32_t       count;
   1960          
   1961            p_sem = (osSemaphore_t*)semaphore_id;
   \        0x4   0x003C             MOVS     R4,R7
   1962          
   1963            if (p_sem == (osSemaphore_t *)0) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??osSemaphoreGetCount_0
   1964              return 0u;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE007             B.N      ??osSemaphoreGetCount_1
   1965            }
   1966          
   1967            CORE_DECLARE_IRQ_STATE;
   1968            CORE_ENTER_CRITICAL();
   \                     ??osSemaphoreGetCount_0: (+1)
   \        0xE   0x.... 0x....      BL       CORE_EnterCritical
   \       0x12   0x0005             MOVS     R5,R0
   1969            count = p_sem->sem.Ctr;
   \       0x14   0x68E6             LDR      R6,[R4, #+12]
   1970            CORE_EXIT_CRITICAL();
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x.... 0x....      BL       CORE_ExitCritical
   1971            return count;
   \       0x1C   0x0030             MOVS     R0,R6
   \                     ??osSemaphoreGetCount_1: (+1)
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}
   1972          #else
   1973            (void)semaphore_id;
   1974            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
   1975            return 0u;
   1976          #endif
   1977          }
   1978          
   1979          /*
   1980           ****************************************************************************************************
   1981           *                                        osSemaphoreDelete()
   1982           *
   1983           * Description: The function 'osSemaphoreDelete()' deletes a semaphore object specified by parameter
   1984           *              'semaphore_id'.  It releases internal memory obtained for semaphore handling.  After
   1985           *              this call, the 'semaphore_id' is no longer valid and cannot be used.
   1986           *
   1987           *              The semaphore may be created again using the function 'osSemaphoreNew()'.
   1988           *
   1989           * Arguments  : semaphore_id     is the semaphore ID returned by 'osSemaphoreNew()'
   1990           *
   1991           * Returns    : osOK             the semaphore object has been deleted.
   1992           *              osErrorParameter the parameter semaphore_id is NULL or invalid.
   1993           *              osErrorResource  the semaphore is in an invalid state.
   1994           *              osErrorISR       osSemaphoreDelete() cannot be called from interrupt service routines.
   1995           *
   1996           *
   1997           * Note(s)    : 1) This function CANNOT be called from an ISR
   1998           ****************************************************************************************************
   1999           */

   \                                 In section .text, align 2, keep-with-next
   2000          osStatus_t  osSemaphoreDelete(osSemaphoreId_t  semaphore_id)
   2001          {
   \                     osSemaphoreDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   2002          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   2003            osSemaphore_t *p_sem;
   2004            RTOS_ERR       err;
   2005          
   2006            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osSemaphoreDelete_0
   2007              return osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE018             B.N      ??osSemaphoreDelete_1
   2008            }
   2009          
   2010            p_sem = (osSemaphore_t *)semaphore_id;
   \                     ??osSemaphoreDelete_0: (+1)
   \       0x14   0x002C             MOVS     R4,R5
   2011          
   2012            if (p_sem == (osSemaphore_t *)0) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osSemaphoreDelete_2
   2013              return osErrorParameter;
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE012             B.N      ??osSemaphoreDelete_1
   2014            }
   2015          
   2016            OSSemDel(&p_sem->sem, OS_OPT_DEL_ALWAYS, &err);
   \                     ??osSemaphoreDelete_2: (+1)
   \       0x20   0x466A             MOV      R2,SP
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       OSSemDel
   2017          
   2018            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x2A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??osSemaphoreDelete_3
   2019              case RTOS_ERR_NONE:
   2020                if (p_sem->dyn_alloc == DEF_TRUE) {
   \       0x32   0x7C20             LDRB     R0,[R4, #+16]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD102             BNE.N    ??osSemaphoreDelete_4
   2021                  free(p_sem);
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       free
   2022                }
   2023                return osOK;
   \                     ??osSemaphoreDelete_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE001             B.N      ??osSemaphoreDelete_1
   2024          
   2025              case RTOS_ERR_OS_ILLEGAL_RUN_TIME:
   2026              case RTOS_ERR_OS_TASK_WAITING:
   2027              default:
   2028                return osErrorResource;
   \                     ??osSemaphoreDelete_3: (+1)
   \       0x42   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osSemaphoreDelete_1: (+1)
   \       0x46   0xB005             ADD      SP,SP,#+20
   \       0x48   0xBD30             POP      {R4,R5,PC}
   2029            }
   2030          #else
   2031            (void)semaphore_id;
   2032            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   2033            return osError;
   2034          #endif
   2035          }
   2036          
   2037          /*
   2038           ****************************************************************************************************
   2039           ****************************************************************************************************
   2040           *                                 T A S K   M A N A G E M E N T
   2041           ****************************************************************************************************
   2042           ****************************************************************************************************
   2043           */
   2044          
   2045          /*
   2046           ****************************************************************************************************
   2047           *                                          osThreadNew()
   2048           *
   2049           * Description: The function 'osThreadNew()' starts a thread function by adding it to the list of active
   2050           *              threads and sets it to state READY. Arguments for the thread function are passed using
   2051           *              the parameter pointer *argument. When the priority of the created thread function is
   2052           *              higher than the current RUNNING thread, the created thread function starts instantly
   2053           *              and becomes the new RUNNING thread.
   2054           *
   2055           *              Thread attributes are defined with the parameter pointer 'attr'.  Attributes include
   2056           *              settings for thread priority, stack size, or memory allocation.
   2057           *
   2058           * Arguments  : func             is a pointer to the task code
   2059           *
   2060           *              argument         is a pointer to an argument that is passed to the task when the task
   2061           *                               starts execution.
   2062           *
   2063           *              attr             attribute structure passed to the task creation code.
   2064           *                               specifying NULL assumes defaults.
   2065           *
   2066           *                               Thread attributes are:
   2067           *
   2068           *                               .name         name of the thread
   2069           *                               .attr_bits    values:
   2070           *                                             osThreadDetached     (default)    0x00000000
   2071           *                                             osThreadJoinable                  0x00000001
   2072           *                               .cb_mem       pointer to TCB
   2073           *                                                (allocated dynamically if NULL or not specified)
   2074           *                               .cb_size      size of the TCB (in bytes)
   2075           *                               .stack_mem    pointer to the base address of the stack
   2076           *                                                (allocated dynamically if NULL or not specified)
   2077           *                               .stack_size   size of stack (in bytes)
   2078           *                                                (defaults to CMSIS_DEFAULT_STACK_SIZE bytes
   2079           *                                                 if 0 specified or not specified)
   2080           *                               .priority     Thread priority (0 = lowest, 55 = highest)
   2081           *                               .tz_module    TrustZone Module Identified
   2082           *                               .reserved     Must be 0
   2083           *
   2084           * Returns    : The thread ID                           upon success
   2085           *              NULL                                    upon error
   2086           *
   2087           * Note(s)    : 1) '.tz_module'  is ignored in this implementation
   2088           *
   2089           *              2) if '.cb_mem' is specified it must point to MicriumOS OS_TCB.
   2090           *                 also, '.cb_size' MUST be declared as 'sizeof(OS_TCB)'
   2091           *
   2092           *              3) 'attr_bits' are not supported and tasks are always assumed to be 'detached'
   2093           ****************************************************************************************************
   2094           */

   \                                 In section .text, align 2, keep-with-next
   2095          osThreadId_t  osThreadNew(osThreadFunc_t          func,
   2096                                    void                    *argument,
   2097                                    const  osThreadAttr_t   *attr)
   2098          {
   \                     osThreadNew: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x0016             MOVS     R6,R2
   2099            osThread_t   *p_thread;
   2100            CPU_STK      *p_stk_base;
   2101            uint32_t      stk_size_in_bytes;
   2102            CPU_CHAR     *p_name;
   2103            OS_PRIO       prio;
   2104            RTOS_ERR      err;
   2105          
   2106            if (CORE_InIrqContext() == true) {
   \        0xC   0x.... 0x....      BL       CORE_InIrqContext
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD101             BNE.N    ??osThreadNew_0
   2107              return (osThreadId_t)0;          // Can't create a thread from an ISR
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE104             B.N      ??osThreadNew_1
   2108            }
   2109            if (func == (osThreadFunc_t)0) {                                             // Make sure a thread is specified
   \                     ??osThreadNew_0: (+1)
   \       0x18   0x0038             MOVS     R0,R7
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD101             BNE.N    ??osThreadNew_2
   2110              return (osThreadId_t)0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xE0FF             B.N      ??osThreadNew_1
   2111            }
   2112            p_name = (CPU_CHAR *)"TaskName?";
   \                     ??osThreadNew_2: (+1)
   \       0x22   0x.... 0x....      LDR.W    R9,??DataTable18_1
   2113            if (attr == 0) {
   \       0x26   0x2E00             CMP      R6,#+0
   \       0x28   0xD11E             BNE.N    ??osThreadNew_3
   2114              p_thread = (osThread_t *)malloc(sizeof(osThread_t));
   \       0x2A   0x20CC             MOVS     R0,#+204
   \       0x2C   0x.... 0x....      BL       malloc
   \       0x30   0x0005             MOVS     R5,R0
   2115              if (p_thread == (osThread_t *)0) {
   \       0x32   0x2D00             CMP      R5,#+0
   \       0x34   0xD101             BNE.N    ??osThreadNew_4
   2116                return (osThreadId_t)0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE0F3             B.N      ??osThreadNew_1
   2117              } else {
   2118                p_thread->obj_dyn_alloc = DEF_TRUE;
   \                     ??osThreadNew_4: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xF885 0x00C4      STRB     R0,[R5, #+196]
   2119                p_stk_base = (CPU_STK *)malloc(CMSIS_DEFAULT_STACK_SIZE);
   \       0x40   0xF44F 0x6080      MOV      R0,#+1024
   \       0x44   0x.... 0x....      BL       malloc
   \       0x48   0x0004             MOVS     R4,R0
   2120                if (p_stk_base == (CPU_STK *)0) {
   \       0x4A   0x2C00             CMP      R4,#+0
   \       0x4C   0xD104             BNE.N    ??osThreadNew_5
   2121                  free(p_thread);
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0x.... 0x....      BL       free
   2122                  return (osThreadId_t)0;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xE0E4             B.N      ??osThreadNew_1
   2123                }
   2124                p_thread->stack_dyn_alloc = DEF_TRUE;
   \                     ??osThreadNew_5: (+1)
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xF885 0x00C5      STRB     R0,[R5, #+197]
   2125                stk_size_in_bytes = CMSIS_DEFAULT_STACK_SIZE;
   \       0x5E   0xF44F 0x6B80      MOV      R11,#+1024
   2126                prio = (OS_PRIO)(osPriorityRealtime7 - osPriorityNormal);
   \       0x62   0xF05F 0x0A1F      MOVS     R10,#+31
   \       0x66   0xE08E             B.N      ??osThreadNew_6
   2127              }
   2128            } else {
   2129              if (attr->cb_mem == (void *)0) {
   \                     ??osThreadNew_3: (+1)
   \       0x68   0x68B0             LDR      R0,[R6, #+8]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD10B             BNE.N    ??osThreadNew_7
   2130                p_thread = (osThread_t *)malloc(sizeof(osThread_t));
   \       0x6E   0x20CC             MOVS     R0,#+204
   \       0x70   0x.... 0x....      BL       malloc
   \       0x74   0x0005             MOVS     R5,R0
   2131                if (p_thread == (osThread_t *)0) {
   \       0x76   0x2D00             CMP      R5,#+0
   \       0x78   0xD101             BNE.N    ??osThreadNew_8
   2132                  return (osThreadId_t)0;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xE0D1             B.N      ??osThreadNew_1
   2133                }
   2134                p_thread->obj_dyn_alloc = DEF_TRUE;
   \                     ??osThreadNew_8: (+1)
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0xF885 0x00C4      STRB     R0,[R5, #+196]
   \       0x84   0xE00C             B.N      ??osThreadNew_9
   2135              } else {
   2136                if (attr->cb_size < sizeof(osThread_t) || (uint32_t)attr->cb_mem % sizeof(CPU_ALIGN)) {
   \                     ??osThreadNew_7: (+1)
   \       0x86   0x68F0             LDR      R0,[R6, #+12]
   \       0x88   0x28CC             CMP      R0,#+204
   \       0x8A   0xD303             BCC.N    ??osThreadNew_10
   \       0x8C   0x7A30             LDRB     R0,[R6, #+8]
   \       0x8E   0xF010 0x0F03      TST      R0,#0x3
   \       0x92   0xD001             BEQ.N    ??osThreadNew_11
   2137                  return (osThreadId_t)0;
   \                     ??osThreadNew_10: (+1)
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0xE0C4             B.N      ??osThreadNew_1
   2138                }
   2139                p_thread = attr->cb_mem;
   \                     ??osThreadNew_11: (+1)
   \       0x98   0x68B5             LDR      R5,[R6, #+8]
   2140                p_thread->obj_dyn_alloc = DEF_FALSE;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xF885 0x00C4      STRB     R0,[R5, #+196]
   2141              }
   2142              if (attr->stack_size == 0u) {
   \                     ??osThreadNew_9: (+1)
   \       0xA0   0x6970             LDR      R0,[R6, #+20]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD115             BNE.N    ??osThreadNew_12
   2143                p_stk_base = (CPU_STK *)malloc(CMSIS_DEFAULT_STACK_SIZE);
   \       0xA6   0xF44F 0x6080      MOV      R0,#+1024
   \       0xAA   0x.... 0x....      BL       malloc
   \       0xAE   0x0004             MOVS     R4,R0
   2144                if (p_stk_base == (CPU_STK *)0) {
   \       0xB0   0x2C00             CMP      R4,#+0
   \       0xB2   0xD108             BNE.N    ??osThreadNew_13
   2145                  if (p_thread->obj_dyn_alloc == DEF_TRUE) {
   \       0xB4   0xF895 0x00C4      LDRB     R0,[R5, #+196]
   \       0xB8   0x2801             CMP      R0,#+1
   \       0xBA   0xD102             BNE.N    ??osThreadNew_14
   2146                    free(p_thread);
   \       0xBC   0x0028             MOVS     R0,R5
   \       0xBE   0x.... 0x....      BL       free
   2147                  }
   2148                  return (osThreadId_t)0;
   \                     ??osThreadNew_14: (+1)
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0xE0AD             B.N      ??osThreadNew_1
   2149                }
   2150                stk_size_in_bytes = CMSIS_DEFAULT_STACK_SIZE;
   \                     ??osThreadNew_13: (+1)
   \       0xC6   0xF44F 0x6B80      MOV      R11,#+1024
   2151                p_thread->stack_dyn_alloc = DEF_TRUE;
   \       0xCA   0x2001             MOVS     R0,#+1
   \       0xCC   0xF885 0x00C5      STRB     R0,[R5, #+197]
   \       0xD0   0xE030             B.N      ??osThreadNew_15
   2152              } else if ((attr->stack_size != 0u)
   2153                         && (attr->stack_mem == NULL)) {
   \                     ??osThreadNew_12: (+1)
   \       0xD2   0x6970             LDR      R0,[R6, #+20]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD017             BEQ.N    ??osThreadNew_16
   \       0xD8   0x6930             LDR      R0,[R6, #+16]
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD114             BNE.N    ??osThreadNew_16
   2154                stk_size_in_bytes = attr->stack_size;
   \       0xDE   0xF8D6 0xB014      LDR      R11,[R6, #+20]
   2155                p_stk_base = (CPU_STK *)malloc(stk_size_in_bytes);
   \       0xE2   0x4658             MOV      R0,R11
   \       0xE4   0x.... 0x....      BL       malloc
   \       0xE8   0x0004             MOVS     R4,R0
   2156                if (p_stk_base == (CPU_STK *)0) {
   \       0xEA   0x2C00             CMP      R4,#+0
   \       0xEC   0xD108             BNE.N    ??osThreadNew_17
   2157                  if (p_thread->obj_dyn_alloc == DEF_TRUE) {
   \       0xEE   0xF895 0x00C4      LDRB     R0,[R5, #+196]
   \       0xF2   0x2801             CMP      R0,#+1
   \       0xF4   0xD102             BNE.N    ??osThreadNew_18
   2158                    free(p_thread);
   \       0xF6   0x0028             MOVS     R0,R5
   \       0xF8   0x.... 0x....      BL       free
   2159                  }
   2160                  return (osThreadId_t)0;
   \                     ??osThreadNew_18: (+1)
   \       0xFC   0x2000             MOVS     R0,#+0
   \       0xFE   0xE090             B.N      ??osThreadNew_1
   2161                }
   2162                p_thread->stack_dyn_alloc = DEF_TRUE;
   \                     ??osThreadNew_17: (+1)
   \      0x100   0x2001             MOVS     R0,#+1
   \      0x102   0xF885 0x00C5      STRB     R0,[R5, #+197]
   \      0x106   0xE015             B.N      ??osThreadNew_15
   2163              } else {
   2164                if (attr->stack_mem == NULL || ((uint32_t)attr->stack_mem % CPU_CFG_STK_ALIGN_BYTES)) {
   \                     ??osThreadNew_16: (+1)
   \      0x108   0x6930             LDR      R0,[R6, #+16]
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD003             BEQ.N    ??osThreadNew_19
   \      0x10E   0x7C30             LDRB     R0,[R6, #+16]
   \      0x110   0xF010 0x0F07      TST      R0,#0x7
   \      0x114   0xD008             BEQ.N    ??osThreadNew_20
   2165                  if (p_thread->obj_dyn_alloc == DEF_TRUE) {
   \                     ??osThreadNew_19: (+1)
   \      0x116   0xF895 0x00C4      LDRB     R0,[R5, #+196]
   \      0x11A   0x2801             CMP      R0,#+1
   \      0x11C   0xD102             BNE.N    ??osThreadNew_21
   2166                    free(p_thread);
   \      0x11E   0x0028             MOVS     R0,R5
   \      0x120   0x.... 0x....      BL       free
   2167                  }
   2168                  return (osThreadId_t)0;
   \                     ??osThreadNew_21: (+1)
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0xE07C             B.N      ??osThreadNew_1
   2169                }
   2170                p_stk_base = (CPU_STK *)attr->stack_mem;
   \                     ??osThreadNew_20: (+1)
   \      0x128   0x6934             LDR      R4,[R6, #+16]
   2171                stk_size_in_bytes = attr->stack_size;
   \      0x12A   0xF8D6 0xB014      LDR      R11,[R6, #+20]
   2172                p_thread->stack_dyn_alloc = DEF_FALSE;
   \      0x12E   0x2000             MOVS     R0,#+0
   \      0x130   0xF885 0x00C5      STRB     R0,[R5, #+197]
   2173              }
   2174              if (attr->name != (const char *)0) {
   \                     ??osThreadNew_15: (+1)
   \      0x134   0x6830             LDR      R0,[R6, #+0]
   \      0x136   0x2800             CMP      R0,#+0
   \      0x138   0xD001             BEQ.N    ??osThreadNew_22
   2175                p_name = (CPU_CHAR *)attr->name;
   \      0x13A   0x6830             LDR      R0,[R6, #+0]
   \      0x13C   0x4681             MOV      R9,R0
   2176              }
   2177              if (attr->priority == osPriorityNone) {
   \                     ??osThreadNew_22: (+1)
   \      0x13E   0x69B0             LDR      R0,[R6, #+24]
   \      0x140   0x2800             CMP      R0,#+0
   \      0x142   0xD102             BNE.N    ??osThreadNew_23
   2178                prio = (OS_PRIO)(osPriorityRealtime7 - osPriorityNormal);
   \      0x144   0xF05F 0x0A1F      MOVS     R10,#+31
   \      0x148   0xE01D             B.N      ??osThreadNew_6
   2179              } else {
   2180                if (attr->priority == osPriorityError) {
   \                     ??osThreadNew_23: (+1)
   \      0x14A   0x69B0             LDR      R0,[R6, #+24]
   \      0x14C   0xF110 0x0F01      CMN      R0,#+1
   \      0x150   0xD102             BNE.N    ??osThreadNew_24
   2181                  prio = (OS_PRIO)(OS_CFG_PRIO_MAX);                          // Set to an invalid priority level for MicriumOS
   \      0x152   0xF05F 0x0A40      MOVS     R10,#+64
   \      0x156   0xE016             B.N      ??osThreadNew_6
   2182                } else {
   2183                  if (attr->priority > osPriorityRealtime7) {
   \                     ??osThreadNew_24: (+1)
   \      0x158   0x69B0             LDR      R0,[R6, #+24]
   \      0x15A   0x2838             CMP      R0,#+56
   \      0x15C   0xDB0F             BLT.N    ??osThreadNew_25
   2184                    if (p_thread->stack_dyn_alloc == DEF_TRUE) {
   \      0x15E   0xF895 0x00C5      LDRB     R0,[R5, #+197]
   \      0x162   0x2801             CMP      R0,#+1
   \      0x164   0xD102             BNE.N    ??osThreadNew_26
   2185                      free(p_stk_base);
   \      0x166   0x0020             MOVS     R0,R4
   \      0x168   0x.... 0x....      BL       free
   2186                    }
   2187                    if (p_thread->obj_dyn_alloc == DEF_TRUE) {
   \                     ??osThreadNew_26: (+1)
   \      0x16C   0xF895 0x00C4      LDRB     R0,[R5, #+196]
   \      0x170   0x2801             CMP      R0,#+1
   \      0x172   0xD102             BNE.N    ??osThreadNew_27
   2188                      free(p_thread);
   \      0x174   0x0028             MOVS     R0,R5
   \      0x176   0x.... 0x....      BL       free
   2189                    }
   2190                    return (osThreadId_t)0;
   \                     ??osThreadNew_27: (+1)
   \      0x17A   0x2000             MOVS     R0,#+0
   \      0x17C   0xE051             B.N      ??osThreadNew_1
   2191                  }
   2192                  prio = (OS_PRIO)(osPriorityRealtime7 - attr->priority);
   \                     ??osThreadNew_25: (+1)
   \      0x17E   0xF8D6 0xA018      LDR      R10,[R6, #+24]
   \      0x182   0xF1DA 0x0A37      RSBS     R10,R10,#+55
   2193                }
   2194              }
   2195            }
   2196          
   2197          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   2198            // Create thread flags
   2199            OSFlagCreate(&p_thread->flag_grp, "ThreadFlags", 0, &err);
   \                     ??osThreadNew_6: (+1)
   \      0x186   0xAB09             ADD      R3,SP,#+36
   \      0x188   0x2200             MOVS     R2,#+0
   \      0x18A   0x.... 0x....      LDR.W    R1,??DataTable18_2
   \      0x18E   0xF115 0x009C      ADDS     R0,R5,#+156
   \      0x192   0x.... 0x....      BL       OSFlagCreate
   2200          
   2201            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \      0x196   0xF89D 0x0024      LDRB     R0,[SP, #+36]
   \      0x19A   0x2800             CMP      R0,#+0
   \      0x19C   0xD00F             BEQ.N    ??osThreadNew_28
   2202              if (p_thread->stack_dyn_alloc == DEF_TRUE) {
   \      0x19E   0xF895 0x00C5      LDRB     R0,[R5, #+197]
   \      0x1A2   0x2801             CMP      R0,#+1
   \      0x1A4   0xD102             BNE.N    ??osThreadNew_29
   2203                free(p_stk_base);
   \      0x1A6   0x0020             MOVS     R0,R4
   \      0x1A8   0x.... 0x....      BL       free
   2204              }
   2205              if (p_thread->obj_dyn_alloc == DEF_TRUE) {
   \                     ??osThreadNew_29: (+1)
   \      0x1AC   0xF895 0x00C4      LDRB     R0,[R5, #+196]
   \      0x1B0   0x2801             CMP      R0,#+1
   \      0x1B2   0xD102             BNE.N    ??osThreadNew_30
   2206                free(p_thread);
   \      0x1B4   0x0028             MOVS     R0,R5
   \      0x1B6   0x.... 0x....      BL       free
   2207              }
   2208              return (osThreadId_t)0;
   \                     ??osThreadNew_30: (+1)
   \      0x1BA   0x2000             MOVS     R0,#+0
   \      0x1BC   0xE031             B.N      ??osThreadNew_1
   2209            }
   2210          #endif
   2211          
   2212            // Round down the stack size to a multiple of the cpu stack size
   2213            stk_size_in_bytes -= (stk_size_in_bytes % CPU_CFG_STK_ALIGN_BYTES);
   \                     ??osThreadNew_28: (+1)
   \      0x1BE   0xF01B 0x0007      ANDS     R0,R11,#0x7
   \      0x1C2   0xEBBB 0x0B00      SUBS     R11,R11,R0
   2214          
   2215            OSTaskCreate(&p_thread->tcb, p_name, func, argument, prio, p_stk_base, 0,
   2216                         stk_size_in_bytes / sizeof(CPU_STK), 0u, 0u, 0u,
   2217                         OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_SAVE_FP,
   2218                         &err);
   \      0x1C6   0xA809             ADD      R0,SP,#+36
   \      0x1C8   0x9008             STR      R0,[SP, #+32]
   \      0x1CA   0x2007             MOVS     R0,#+7
   \      0x1CC   0x9007             STR      R0,[SP, #+28]
   \      0x1CE   0x2000             MOVS     R0,#+0
   \      0x1D0   0x9006             STR      R0,[SP, #+24]
   \      0x1D2   0x2000             MOVS     R0,#+0
   \      0x1D4   0x9005             STR      R0,[SP, #+20]
   \      0x1D6   0x2000             MOVS     R0,#+0
   \      0x1D8   0x9004             STR      R0,[SP, #+16]
   \      0x1DA   0x4658             MOV      R0,R11
   \      0x1DC   0x0880             LSRS     R0,R0,#+2
   \      0x1DE   0x9003             STR      R0,[SP, #+12]
   \      0x1E0   0x2000             MOVS     R0,#+0
   \      0x1E2   0x9002             STR      R0,[SP, #+8]
   \      0x1E4   0x9401             STR      R4,[SP, #+4]
   \      0x1E6   0x4650             MOV      R0,R10
   \      0x1E8   0xB2C0             UXTB     R0,R0
   \      0x1EA   0x9000             STR      R0,[SP, #+0]
   \      0x1EC   0x4643             MOV      R3,R8
   \      0x1EE   0x003A             MOVS     R2,R7
   \      0x1F0   0x4649             MOV      R1,R9
   \      0x1F2   0x0028             MOVS     R0,R5
   \      0x1F4   0x.... 0x....      BL       OSTaskCreate
   2219          
   2220            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \      0x1F8   0xF89D 0x0024      LDRB     R0,[SP, #+36]
   \      0x1FC   0x2800             CMP      R0,#+0
   \      0x1FE   0xD00F             BEQ.N    ??osThreadNew_31
   2221              if (p_thread->stack_dyn_alloc == DEF_TRUE) {
   \      0x200   0xF895 0x00C5      LDRB     R0,[R5, #+197]
   \      0x204   0x2801             CMP      R0,#+1
   \      0x206   0xD102             BNE.N    ??osThreadNew_32
   2222                free(p_stk_base);
   \      0x208   0x0020             MOVS     R0,R4
   \      0x20A   0x.... 0x....      BL       free
   2223              }
   2224              if (p_thread->obj_dyn_alloc == DEF_TRUE) {
   \                     ??osThreadNew_32: (+1)
   \      0x20E   0xF895 0x00C4      LDRB     R0,[R5, #+196]
   \      0x212   0x2801             CMP      R0,#+1
   \      0x214   0xD102             BNE.N    ??osThreadNew_33
   2225                free(p_thread);
   \      0x216   0x0028             MOVS     R0,R5
   \      0x218   0x.... 0x....      BL       free
   2226              }
   2227              return (osThreadId_t)0;
   \                     ??osThreadNew_33: (+1)
   \      0x21C   0x2000             MOVS     R0,#+0
   \      0x21E   0xE000             B.N      ??osThreadNew_1
   2228            }
   2229          
   2230            return (osThreadId_t)p_thread;
   \                     ??osThreadNew_31: (+1)
   \      0x220   0x0028             MOVS     R0,R5
   \                     ??osThreadNew_1: (+1)
   \      0x222   0xB00D             ADD      SP,SP,#+52
   \      0x224   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2231          }
   2232          
   2233          /*
   2234           ****************************************************************************************************
   2235           *                                          osThreadGetName()
   2236           *
   2237           * Description: The function osThreadGetName returns the pointer to the name string of the thread
   2238           *              identified by parameter 'thread_id' or NULL in case of an error.
   2239           *
   2240           * Arguments  : thread_id        is the thread ID returned by osThreadNew() when the thread is created
   2241           *
   2242           * Returns    : A pointer to the ASCII string containing the name of the thread.
   2243           *              NULL             upon error
   2244           *
   2245           * Note(s)    : 1) This function CANNOT be called from an ISR
   2246           ****************************************************************************************************
   2247           */

   \                                 In section .text, align 2, keep-with-next
   2248          const  char  *osThreadGetName(osThreadId_t  thread_id)
   2249          {
   \                     osThreadGetName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2250          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2251            osThread_t *p_thread;
   2252          
   2253            p_thread = (osThread_t *)thread_id;
   2254            if (p_thread == (osThread_t *)0) {
   2255              return NULL;
   2256            } else {
   2257              return p_thread->tcb.NamePtr;
   2258            }
   2259          #else
   2260            (void)thread_id;
   2261            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, NULL);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   2262            return NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   2263          #endif
   2264          }
   2265          
   2266          /*
   2267           ****************************************************************************************************
   2268           *                                          osThreadGetId()
   2269           *
   2270           * Description: The function 'osThreadGetId()' returns the thread object ID of the currently running
   2271           *              thread or NULL in case of an error.
   2272           *
   2273           * Arguments  : None
   2274           *
   2275           * Returns    : The thread ID
   2276           *              NULL             upon error
   2277           ****************************************************************************************************
   2278           */

   \                                 In section .text, align 2, keep-with-next
   2279          osThreadId_t  osThreadGetId(void)
   2280          {
   2281            if (OSRunning == OS_STATE_OS_RUNNING) {
   \                     osThreadGetId: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x2801             CMP      R0,#+1
   \        0x6   0xD103             BNE.N    ??osThreadGetId_0
   2282              return (osThreadId_t)OSTCBCurPtr;
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0xE000             B.N      ??osThreadGetId_1
   2283            }
   2284          
   2285            return (osThreadId_t)0;
   \                     ??osThreadGetId_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??osThreadGetId_1: (+1)
   \       0x12   0x4770             BX       LR
   2286          }
   2287          
   2288          /*
   2289           ****************************************************************************************************
   2290           *                                         osThreadGetState()
   2291           *
   2292           * Description: The function osThreadGetState() returns the state of the thread identified by parameter
   2293           *              'thread_id'.  In case it fails or if it is called from an ISR, it will return
   2294           *              osThreadError, otherwise it returns the thread state (refer to 'osThreadState_t' for
   2295           *              the list of thread states).
   2296           *
   2297           * Arguments  : thread_id   is the ID of the desired thread
   2298           *
   2299           * Returns    : The thread state (see below)
   2300           *
   2301           * Note(s)    : 1) This function CANNOT be called from an ISR
   2302           ****************************************************************************************************
   2303           */

   \                                 In section .text, align 2, keep-with-next
   2304          osThreadState_t  osThreadGetState(osThreadId_t  thread_id)
   2305          {
   \                     osThreadGetState: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2306            osThread_t      *p_thread;
   2307            osThreadState_t  state;
   2308          
   2309            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD102             BNE.N    ??osThreadGetState_0
   2310              return osThreadError;
   \        0xC   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x10   0xE01E             B.N      ??osThreadGetState_1
   2311            }
   2312            p_thread = (osThread_t *)thread_id;
   \                     ??osThreadGetState_0: (+1)
   \       0x12   0x0021             MOVS     R1,R4
   2313            if (p_thread == (osThread_t *)0) {
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD102             BNE.N    ??osThreadGetState_2
   2314              return osThreadError;
   \       0x18   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x1C   0xE018             B.N      ??osThreadGetState_1
   2315            }
   2316          
   2317            if (OSRunning == OS_STATE_OS_RUNNING) {
   \                     ??osThreadGetState_2: (+1)
   \       0x1E   0x....             LDR.N    R0,??DataTable12_5
   \       0x20   0x7800             LDRB     R0,[R0, #+0]
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD112             BNE.N    ??osThreadGetState_3
   2318              switch (p_thread->tcb.TaskState) {
   \       0x26   0xF891 0x2026      LDRB     R2,[R1, #+38]
   \       0x2A   0x2A00             CMP      R2,#+0
   \       0x2C   0xD005             BEQ.N    ??osThreadGetState_4
   \       0x2E   0x1E52             SUBS     R2,R2,#+1
   \       0x30   0x2A06             CMP      R2,#+6
   \       0x32   0xD906             BLS.N    ??osThreadGetState_5
   \       0x34   0x3AFE             SUBS     R2,R2,#+254
   \       0x36   0xD002             BEQ.N    ??osThreadGetState_6
   \       0x38   0xE005             B.N      ??osThreadGetState_7
   2319                case OS_TASK_STATE_RDY:
   2320                  state = osThreadReady;
   \                     ??osThreadGetState_4: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   2321                  break;
   \       0x3C   0xE008             B.N      ??osThreadGetState_8
   2322          
   2323                case OS_TASK_STATE_DEL:
   2324                  state = osThreadInactive;
   \                     ??osThreadGetState_6: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   2325                  break;
   \       0x40   0xE006             B.N      ??osThreadGetState_8
   2326          
   2327                case OS_TASK_STATE_DLY:
   2328                case OS_TASK_STATE_PEND:
   2329                case OS_TASK_STATE_PEND_TIMEOUT:
   2330                case OS_TASK_STATE_SUSPENDED:
   2331                case OS_TASK_STATE_DLY_SUSPENDED:
   2332                case OS_TASK_STATE_PEND_SUSPENDED:
   2333                case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2334                  state = osThreadBlocked;
   \                     ??osThreadGetState_5: (+1)
   \       0x42   0x2003             MOVS     R0,#+3
   2335                  break;
   \       0x44   0xE004             B.N      ??osThreadGetState_8
   2336          
   2337                default:
   2338                  state = osThreadError;
   \                     ??osThreadGetState_7: (+1)
   \       0x46   0xF05F 0x30FF      MOVS     R0,#+4294967295
   2339                  break;
   \       0x4A   0xE001             B.N      ??osThreadGetState_8
   2340              }
   2341            } else {
   2342              state = osThreadError;
   \                     ??osThreadGetState_3: (+1)
   \       0x4C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   2343            }
   2344            return state;
   \                     ??osThreadGetState_8: (+1)
   \                     ??osThreadGetState_1: (+1)
   \       0x50   0xBD10             POP      {R4,PC}
   2345          }
   2346          
   2347          /*
   2348           ****************************************************************************************************
   2349           *                                        osThreadSetPriority()
   2350           *
   2351           * Description: The function 'osThreadSetPriority()' changes the priority of an active thread specified
   2352           *              by the parameter 'thread_id' to the priority specified by the parameter 'priority'.
   2353           *
   2354           * Arguments  : thread_id        is the thread ID
   2355           *
   2356           *              priority         is the desired new priority for the specified thread
   2357           *
   2358           * Returns    : osOK               the priority of the specified thread has been changed
   2359           *              osErrorParameter   an invalid parameter was specified
   2360           *              osErrorResource    the thread is in an invalid state
   2361           *              osErrorISR         if called from an ISR
   2362           *
   2363           * Note(s)    : 1) This function CANNOT be called from an ISR
   2364           ****************************************************************************************************
   2365           */

   \                                 In section .text, align 2, keep-with-next
   2366          osStatus_t  osThreadSetPriority(osThreadId_t  thread_id,
   2367                                          osPriority_t  priority)
   2368          {
   \                     osThreadSetPriority: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   2369            OS_PRIO     prio;
   2370            osThread_t *p_thread;
   2371            RTOS_ERR    err;
   2372          
   2373            if (CORE_InIrqContext() == true) {
   \        0x8   0x.... 0x....      BL       CORE_InIrqContext
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD102             BNE.N    ??osThreadSetPriority_0
   2374              return osErrorISR;
   \       0x10   0xF07F 0x0005      MVNS     R0,#+5
   \       0x14   0xE026             B.N      ??osThreadSetPriority_1
   2375            }
   2376            if (thread_id == (osThreadId_t)0) {
   \                     ??osThreadSetPriority_0: (+1)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osThreadSetPriority_2
   2377              return osErrorParameter;
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE021             B.N      ??osThreadSetPriority_1
   2378            }
   2379            if (priority == osPriorityError) {
   \                     ??osThreadSetPriority_2: (+1)
   \       0x20   0xF115 0x0F01      CMN      R5,#+1
   \       0x24   0xD102             BNE.N    ??osThreadSetPriority_3
   2380              return osErrorParameter;
   \       0x26   0xF07F 0x0003      MVNS     R0,#+3
   \       0x2A   0xE01B             B.N      ??osThreadSetPriority_1
   2381            }
   2382            if (priority > osPriorityRealtime7) {
   \                     ??osThreadSetPriority_3: (+1)
   \       0x2C   0x2D38             CMP      R5,#+56
   \       0x2E   0xDB02             BLT.N    ??osThreadSetPriority_4
   2383              return osErrorParameter;
   \       0x30   0xF07F 0x0003      MVNS     R0,#+3
   \       0x34   0xE016             B.N      ??osThreadSetPriority_1
   2384            }
   2385            prio = (OS_PRIO)(osPriorityRealtime7 - priority);
   \                     ??osThreadSetPriority_4: (+1)
   \       0x36   0xF1D5 0x0637      RSBS     R6,R5,#+55
   2386            p_thread = (osThread_t *)thread_id;
   \       0x3A   0x0027             MOVS     R7,R4
   2387          
   2388            OSTaskChangePrio(&p_thread->tcb, prio, &err);
   \       0x3C   0x466A             MOV      R2,SP
   \       0x3E   0x0031             MOVS     R1,R6
   \       0x40   0xB2C9             UXTB     R1,R1
   \       0x42   0x0038             MOVS     R0,R7
   \       0x44   0x.... 0x....      BL       OSTaskChangePrio
   2389          
   2390            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x48   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD002             BEQ.N    ??osThreadSetPriority_5
   \       0x50   0x2808             CMP      R0,#+8
   \       0x52   0xD002             BEQ.N    ??osThreadSetPriority_6
   \       0x54   0xE004             B.N      ??osThreadSetPriority_7
   2391              case RTOS_ERR_NONE:
   2392                return osOK;
   \                     ??osThreadSetPriority_5: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xE004             B.N      ??osThreadSetPriority_1
   2393          
   2394              case RTOS_ERR_INVALID_ARG:
   2395                return osErrorParameter;
   \                     ??osThreadSetPriority_6: (+1)
   \       0x5A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x5E   0xE001             B.N      ??osThreadSetPriority_1
   2396          
   2397              default:
   2398                return osErrorResource;
   \                     ??osThreadSetPriority_7: (+1)
   \       0x60   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osThreadSetPriority_1: (+1)
   \       0x64   0xB005             ADD      SP,SP,#+20
   \       0x66   0xBDF0             POP      {R4-R7,PC}
   2399            }
   2400          }
   2401          
   2402          /*
   2403           ****************************************************************************************************
   2404           *                                        osThreadGetPriority()
   2405           *
   2406           * Description: The function 'osThreadGetPriority()' returns the priority of an active thread specified
   2407           *              by the parameter 'thread_id'.
   2408           *
   2409           * Arguments  : None
   2410           *
   2411           * Returns    : The thread ID        upon success
   2412           *              osPriorityError      upon error
   2413           *
   2414           * Note(s)    : 1) This function CANNOT be called from an ISR
   2415           ****************************************************************************************************
   2416           */

   \                                 In section .text, align 2, keep-with-next
   2417          osPriority_t  osThreadGetPriority(osThreadId_t  thread_id)
   2418          {
   \                     osThreadGetPriority: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2419            osPriority_t   priority;
   2420            osThread_t    *p_thread;
   2421          
   2422            if (OSRunning != OS_STATE_OS_RUNNING) {
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD002             BEQ.N    ??osThreadGetPriority_0
   2423              return osPriorityError;
   \        0xE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x12   0xE010             B.N      ??osThreadGetPriority_1
   2424            }
   2425            if (CORE_InIrqContext() == true) {
   \                     ??osThreadGetPriority_0: (+1)
   \       0x14   0x.... 0x....      BL       CORE_InIrqContext
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD102             BNE.N    ??osThreadGetPriority_2
   2426              return osPriorityError;
   \       0x1C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x20   0xE009             B.N      ??osThreadGetPriority_1
   2427            }
   2428            p_thread = (osThread_t *)thread_id;
   \                     ??osThreadGetPriority_2: (+1)
   \       0x22   0x0021             MOVS     R1,R4
   2429            if (p_thread == (osThread_t *)0) {
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD102             BNE.N    ??osThreadGetPriority_3
   2430              return osPriorityError;
   \       0x28   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x2C   0xE003             B.N      ??osThreadGetPriority_1
   2431            }
   2432            priority = (osPriority_t)((OS_PRIO)osPriorityRealtime7 - p_thread->tcb.Prio);
   \                     ??osThreadGetPriority_3: (+1)
   \       0x2E   0xF891 0x0027      LDRB     R0,[R1, #+39]
   \       0x32   0xF1D0 0x0037      RSBS     R0,R0,#+55
   2433            return priority;
   \                     ??osThreadGetPriority_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   2434          }
   2435          
   2436          /*
   2437           ****************************************************************************************************
   2438           *                                        osThreadYield()
   2439           *
   2440           * Description: The function 'osThreadYield()' passes control to the next thread with the same priority
   2441           *              that is in the READY state. I f there is no other thread with the same priority in state
   2442           *              READY, then the current thread continues execution and no thread switch occurs.
   2443           *
   2444           *              'osThreadYield()' does not set the thread to state BLOCKED.  Thus no thread with a lower
   2445           *              priority will be scheduled even if threads in state READY are available.
   2446           *
   2447           * Arguments  : None
   2448           *
   2449           * Returns    : osOK        control has passed to the next thread
   2450           *              osError     an unspecified error occurred
   2451           *              osErrorISR  if called from an ISR
   2452           *
   2453           * Note(s)    : 1) This function CANNOT be called from an ISR
   2454           ****************************************************************************************************
   2455           */

   \                                 In section .text, align 2, keep-with-next
   2456          osStatus_t  osThreadYield(void)
   2457          {
   \                     osThreadYield: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2458          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
   2459            RTOS_ERR  err;
   2460          
   2461            if (CORE_InIrqContext() == true) {
   2462              return osErrorISR;
   2463            }
   2464            OSSchedRoundRobinYield(&err);
   2465          
   2466            switch (RTOS_ERR_CODE_GET(err)) {
   2467              case RTOS_ERR_NONE:
   2468                return osOK;
   2469          
   2470              case RTOS_ERR_NOT_AVAIL:
   2471              case RTOS_ERR_NONE_WAITING:
   2472              case RTOS_ERR_OS_SCHED_LOCKED:
   2473              default:
   2474                return osError;
   2475            }
   2476          #else
   2477            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   \        0x2   0x.... 0x....      BL       CPU_SW_Exception
   2478            return osError;
   \        0x6   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \        0xA   0xBD02             POP      {R1,PC}
   2479          #endif
   2480          }
   2481          
   2482          /*
   2483           ****************************************************************************************************
   2484           *                                        osThreadSuspend()
   2485           *
   2486           * Description: The function 'osThreadSuspend()' suspends the execution of the thread identified by
   2487           *              parameter 'thread_id'.  The thread is put into the BLOCKED state (osThreadBlocked).
   2488           *              Suspending the running thread will cause a context switch to another thread in READY
   2489           *              state immediately.  The suspended thread is not executed until explicitly resumed
   2490           *              by the function 'osThreadResume()'.
   2491           *
   2492           *              Threads that are already BLOCKED are removed from any wait list and become ready when
   2493           *              they are resumed.  Thus it is not recommended to suspend an already blocked thread.
   2494           *
   2495           * Arguments  : thread_id    is the ID of the thread
   2496           *
   2497           * Returns    : osOK                the thread has been suspended successfully.
   2498           *              osErrorParameter    thread_id is NULL or invalid.
   2499           *              osErrorResource     the thread is in an invalid state.
   2500           *              osErrorISR          the function osThreadSuspend cannot be called from interrupt service routines.
   2501           *
   2502           * Note(s)    : 1) This function CANNOT be called from an ISR
   2503           ****************************************************************************************************
   2504           */

   \                                 In section .text, align 2, keep-with-next
   2505          osStatus_t  osThreadSuspend(osThreadId_t  thread_id)
   2506          {
   \                     osThreadSuspend: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   2507            RTOS_ERR     err;
   2508            osThread_t  *p_thread;
   2509          
   2510            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osThreadSuspend_0
   2511              return osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE011             B.N      ??osThreadSuspend_1
   2512            }
   2513          
   2514            p_thread = (osThread_t *)thread_id;
   \                     ??osThreadSuspend_0: (+1)
   \       0x14   0x002C             MOVS     R4,R5
   2515            if (p_thread == (osThread_t *)0) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osThreadSuspend_2
   2516              return osErrorParameter;
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE00B             B.N      ??osThreadSuspend_1
   2517            }
   2518          
   2519            OSTaskSuspend(&p_thread->tcb, &err);
   \                     ??osThreadSuspend_2: (+1)
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       OSTaskSuspend
   2520          
   2521            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x28   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD101             BNE.N    ??osThreadSuspend_3
   2522              case RTOS_ERR_NONE:
   2523                return osOK;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xE001             B.N      ??osThreadSuspend_1
   2524          
   2525              case RTOS_ERR_OS:
   2526              case RTOS_ERR_NOT_READY:
   2527              case RTOS_ERR_WOULD_OVF:
   2528              case RTOS_ERR_INVALID_STATE:
   2529              case RTOS_ERR_OS_SCHED_LOCKED:
   2530              default:
   2531                return osErrorResource;
   \                     ??osThreadSuspend_3: (+1)
   \       0x34   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osThreadSuspend_1: (+1)
   \       0x38   0xB005             ADD      SP,SP,#+20
   \       0x3A   0xBD30             POP      {R4,R5,PC}
   2532            }
   2533          }
   2534          
   2535          /*
   2536           ****************************************************************************************************
   2537           *                                        osThreadResume()
   2538           *
   2539           * Description: The function 'osThreadResume()' puts the thread identified by parameter 'thread_id'
   2540           *              (which has to be in BLOCKED state) back to the READY state.  If the resumed thread
   2541           *              has a higher priority than the running thread a context switch occurs immediately.
   2542           *
   2543           *              The thread becomes ready regardless of the reason why the thread was blocked.  Thus
   2544           *              it is not recommended to resume a thread not suspended by 'osThreadSuspend()'.
   2545           *
   2546           *              Functions that will put a thread into BLOCKED state are:
   2547           *
   2548           *                 'osEventFlagsWait()' and 'osThreadFlagsWait()',
   2549           *                 'osDelay()'          and 'osDelayUntil()',
   2550           *                 'osMutexAcquire()'   and 'osSemaphoreAcquire()',
   2551           *                 'osMessageQueueGet()'
   2552           *                 'osMemoryPoolAlloc(),
   2553           *                 'osThreadJoin()'         Function NOT supported
   2554           *                 'osThreadSuspend()'
   2555           *
   2556           * Arguments  : thread_id    is the ID of the thread
   2557           *
   2558           * Returns    : osOK                the thread has been resumed successfully.
   2559           *              osErrorParameter    thread_id is NULL or invalid.
   2560           *              osErrorResource     the thread is in an invalid state.
   2561           *              osErrorISR          the function osThreadSuspend cannot be called from interrupt service routines.
   2562           *
   2563           * Note(s)    : 1) This function CANNOT be called from an ISR
   2564           *
   2565           *              2) MicriumOS cannot emulate this function exactly as described above.  In fact,
   2566           *                 MicriumOS doesn't cancel pending on an object.  The suspension is simply removed if
   2567           *                 the task was suspended by 'osThreadSuspend()'.
   2568           ****************************************************************************************************
   2569           */

   \                                 In section .text, align 2, keep-with-next
   2570          osStatus_t  osThreadResume(osThreadId_t  thread_id)
   2571          {
   \                     osThreadResume: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   2572            RTOS_ERR    err;
   2573            osThread_t *p_thread;
   2574          
   2575            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osThreadResume_0
   2576              return osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE011             B.N      ??osThreadResume_1
   2577            }
   2578          
   2579            p_thread = (osThread_t *)thread_id;
   \                     ??osThreadResume_0: (+1)
   \       0x14   0x002C             MOVS     R4,R5
   2580          
   2581            if (p_thread == (osThread_t *)0) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osThreadResume_2
   2582              return osErrorParameter;
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE00B             B.N      ??osThreadResume_1
   2583            }
   2584          
   2585            OSTaskResume(&p_thread->tcb, &err);
   \                     ??osThreadResume_2: (+1)
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       OSTaskResume
   2586          
   2587            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x28   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD101             BNE.N    ??osThreadResume_3
   2588              case RTOS_ERR_NONE:
   2589                return osOK;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xE001             B.N      ??osThreadResume_1
   2590          
   2591              case RTOS_ERR_INVALID_STATE:
   2592              default:
   2593                return osErrorResource;
   \                     ??osThreadResume_3: (+1)
   \       0x34   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osThreadResume_1: (+1)
   \       0x38   0xB005             ADD      SP,SP,#+20
   \       0x3A   0xBD30             POP      {R4,R5,PC}
   2594            }
   2595          }
   2596          /*
   2597           ****************************************************************************************************
   2598           *                                        osThreadDetach()
   2599           *
   2600           * Description: The function 'osThreadDetach()' changes the attribute of a thread (specified by 'thread_id')
   2601           *              to 'osThreadDetached'.  Detached threads are not joinable with 'osThreadJoin()'.
   2602           *
   2603           *              When a detached thread is terminated, all resources are returned to the system.
   2604           *
   2605           *              The behavior of 'osThreadDetach()' on an already detached thread is undefined.
   2606           *
   2607           * Arguments  : thread_id    is the ID of the thread
   2608           *
   2609           * Returns    : osOK                the thread has been detached successfully.
   2610           *              osErrorParameter    thread_id is NULL or invalid.
   2611           *              osErrorResource     the thread is in an invalid state.
   2612           *              osErrorISR          the function osThreadSuspend cannot be called from interrupt service routines.
   2613           *
   2614           * Note(s)    : 1) This function CANNOT be called from an ISR
   2615           *
   2616           *              2) MicriumOS DOES NOT support this functionality
   2617           ****************************************************************************************************
   2618           */

   \                                 In section .text, align 2, keep-with-next
   2619          osStatus_t  osThreadDetach(osThreadId_t  thread_id)
   2620          {
   \                     osThreadDetach: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2621            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD102             BNE.N    ??osThreadDetach_0
   2622              return osErrorISR;
   \        0xC   0xF07F 0x0005      MVNS     R0,#+5
   \       0x10   0xE008             B.N      ??osThreadDetach_1
   2623            }
   2624          
   2625            if (thread_id == (osThreadId_t)0) {
   \                     ??osThreadDetach_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD102             BNE.N    ??osThreadDetach_2
   2626              return osErrorParameter;
   \       0x16   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1A   0xE003             B.N      ??osThreadDetach_1
   2627            }
   2628          
   2629            (void)thread_id;
   2630            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, osError);
   \                     ??osThreadDetach_2: (+1)
   \       0x1C   0x.... 0x....      BL       CPU_SW_Exception
   2631            return osError;
   \       0x20   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??osThreadDetach_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   2632          }
   2633          
   2634          /*
   2635           ****************************************************************************************************
   2636           *                                        osThreadJoin()
   2637           *
   2638           * Description: The function 'osThreadJoin()' waits for the thread specified by 'thread_id' to terminate.
   2639           *
   2640           *              If that thread has already terminated, then 'osThreadJoin()' returns immediately.
   2641           *
   2642           *              The thread must be joinable.  By default threads are created with the attribute 'osThreadDetached'.
   2643           *
   2644           * Arguments  : thread_id    is the ID of the thread
   2645           *
   2646           * Returns    : osOK                the thread has been joined successfully.
   2647           *              osErrorParameter    thread_id is NULL or invalid.
   2648           *              osErrorResource     the thread is in an invalid state.
   2649           *              osErrorISR          the function osThreadSuspend cannot be called from interrupt service routines.
   2650           *
   2651           * Note(s)    : 1) This function CANNOT be called from an ISR
   2652           *
   2653           *              2) MicriumOS DOES NOT support this functionality
   2654           ****************************************************************************************************
   2655           */

   \                                 In section .text, align 2, keep-with-next
   2656          osStatus_t  osThreadJoin(osThreadId_t  thread_id)
   2657          {
   \                     osThreadJoin: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2658            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD102             BNE.N    ??osThreadJoin_0
   2659              return osErrorISR;
   \        0xC   0xF07F 0x0005      MVNS     R0,#+5
   \       0x10   0xE008             B.N      ??osThreadJoin_1
   2660            }
   2661          
   2662            if (thread_id == (osThreadId_t)0) {
   \                     ??osThreadJoin_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD102             BNE.N    ??osThreadJoin_2
   2663              return osErrorParameter;
   \       0x16   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1A   0xE003             B.N      ??osThreadJoin_1
   2664            }
   2665          
   2666            (void)thread_id;
   2667            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, osError);
   \                     ??osThreadJoin_2: (+1)
   \       0x1C   0x.... 0x....      BL       CPU_SW_Exception
   2668            return osError;
   \       0x20   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??osThreadJoin_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   2669          }
   2670          
   2671          /*
   2672           ****************************************************************************************************
   2673           *                                        osThreadExit()
   2674           *
   2675           * Description: The function 'osThreadExit()' terminates the calling thread.
   2676           *
   2677           *              This allows the thread to be synchronized with 'osThreadJoin()'.
   2678           *
   2679           * Arguments  : None
   2680           *
   2681           * Returns    : None
   2682           *
   2683           * Note(s)    : 1) This function CANNOT be called from an ISR
   2684           ****************************************************************************************************
   2685           */

   \                                 In section .text, align 2, keep-with-next
   2686          void  osThreadExit(void)
   2687          {
   \                     osThreadExit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   2688            RTOS_ERR  err;
   2689          
   2690            if (CORE_InIrqContext() == false) {
   \        0x2   0x.... 0x....      BL       CORE_InIrqContext
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD103             BNE.N    ??osThreadExit_0
   2691              OSTaskDel((OS_TCB *)0, &err);
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x.... 0x....      BL       OSTaskDel
   2692            }
   2693            for (;; ) {
   \                     ??osThreadExit_0: (+1)
   \       0x12   0xE7FE             B.N      ??osThreadExit_0
   2694              ;       // This function cannot return
   2695            }
   2696          }
   2697          
   2698          /*
   2699           ****************************************************************************************************
   2700           *                                        osThreadTerminate()
   2701           *
   2702           * Description: The function 'osThreadTerminate()' removes the thread specified by parameter 'thread_id'
   2703           *              from the list of active threads.  If the thread is currently RUNNING, the thread
   2704           *              terminates and the execution continues with the next READY thread.
   2705           *
   2706           *              If no such thread exists, the function will not terminate the running thread, but return
   2707           *              'osErrorResource'.
   2708           *
   2709           * Arguments  : thread_id    is the ID of the thread
   2710           *
   2711           * Returns    : osOK                the thread has been joined successfully.
   2712           *              osErrorParameter    thread_id is NULL or invalid.
   2713           *              osErrorResource     the thread is in an invalid state.
   2714           *              osErrorISR          the function osThreadSuspend cannot be called from interrupt service routines.
   2715           *
   2716           * Note(s)    : 1) This function CANNOT be called from an ISR
   2717           ****************************************************************************************************
   2718           */

   \                                 In section .text, align 2, keep-with-next
   2719          osStatus_t  osThreadTerminate(osThreadId_t  thread_id)
   2720          {
   \                     osThreadTerminate: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   2721            osThread_t   *p_thread;
   2722            CPU_STK      *p_stk_base;
   2723            RTOS_ERR      err;
   2724          
   2725            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD102             BNE.N    ??osThreadTerminate_0
   2726              return osErrorISR;
   \        0xC   0xF07F 0x0005      MVNS     R0,#+5
   \       0x10   0xE026             B.N      ??osThreadTerminate_1
   2727            }
   2728          
   2729            p_thread = (osThread_t *)thread_id;
   \                     ??osThreadTerminate_0: (+1)
   \       0x12   0x002C             MOVS     R4,R5
   2730          
   2731            if (p_thread == (osThread_t *)0) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD102             BNE.N    ??osThreadTerminate_2
   2732              return osErrorParameter;
   \       0x18   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1C   0xE020             B.N      ??osThreadTerminate_1
   2733            }
   2734          
   2735            p_stk_base = p_thread->tcb.StkBasePtr;
   \                     ??osThreadTerminate_2: (+1)
   \       0x1E   0x6966             LDR      R6,[R4, #+20]
   2736          
   2737            OSTaskDel(&p_thread->tcb, &err);
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       OSTaskDel
   2738          
   2739            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x28   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD002             BEQ.N    ??osThreadTerminate_3
   \       0x30   0x2808             CMP      R0,#+8
   \       0x32   0xD010             BEQ.N    ??osThreadTerminate_4
   \       0x34   0xE012             B.N      ??osThreadTerminate_5
   2740              case RTOS_ERR_NONE:
   2741                if (p_thread->stack_dyn_alloc == DEF_TRUE) {
   \                     ??osThreadTerminate_3: (+1)
   \       0x36   0xF894 0x00C5      LDRB     R0,[R4, #+197]
   \       0x3A   0x2801             CMP      R0,#+1
   \       0x3C   0xD102             BNE.N    ??osThreadTerminate_6
   2742                  free(p_stk_base);
   \       0x3E   0x0030             MOVS     R0,R6
   \       0x40   0x.... 0x....      BL       free
   2743                }
   2744                if (p_thread->obj_dyn_alloc == DEF_TRUE) {
   \                     ??osThreadTerminate_6: (+1)
   \       0x44   0xF894 0x00C4      LDRB     R0,[R4, #+196]
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD102             BNE.N    ??osThreadTerminate_7
   2745                  free(p_thread);
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       free
   2746                }
   2747                return osOK;
   \                     ??osThreadTerminate_7: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xE004             B.N      ??osThreadTerminate_1
   2748          
   2749              case RTOS_ERR_INVALID_ARG:
   2750                return osErrorParameter;
   \                     ??osThreadTerminate_4: (+1)
   \       0x56   0xF07F 0x0003      MVNS     R0,#+3
   \       0x5A   0xE001             B.N      ??osThreadTerminate_1
   2751          
   2752              case RTOS_ERR_INVALID_STATE:
   2753              case RTOS_ERR_OS_ILLEGAL_RUN_TIME:
   2754              default:
   2755                return osErrorResource;
   \                     ??osThreadTerminate_5: (+1)
   \       0x5C   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osThreadTerminate_1: (+1)
   \       0x60   0xB004             ADD      SP,SP,#+16
   \       0x62   0xBD70             POP      {R4-R6,PC}
   2756            }
   2757          }
   2758          
   2759          /*
   2760           ****************************************************************************************************
   2761           *                                        osThreadGetStackSize()
   2762           *
   2763           * Description: The function 'osThreadGetStackSize()' returns the  stack size of the thread specified
   2764           *              by parameter 'thread_id'. In case of an error, it returns 0.
   2765           *
   2766           * Arguments  : thread_id    is the ID of the thread
   2767           *
   2768           * Returns    : The stack size (in bytes)
   2769           *
   2770           * Note(s)    : 1) This function CANNOT be called from an ISR
   2771           ****************************************************************************************************
   2772           */

   \                                 In section .text, align 2, keep-with-next
   2773          uint32_t  osThreadGetStackSize(osThreadId_t  thread_id)
   2774          {
   \                     osThreadGetStackSize: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   2775            osThread_t *p_thread;
   2776            uint32_t    stk_size;
   2777          
   2778            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??osThreadGetStackSize_0
   2779              return 0u;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE00D             B.N      ??osThreadGetStackSize_1
   2780            }
   2781          
   2782            p_thread = (osThread_t *)thread_id;
   \                     ??osThreadGetStackSize_0: (+1)
   \       0x10   0x002C             MOVS     R4,R5
   2783          
   2784            if (p_thread == (osThread_t *)0) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD101             BNE.N    ??osThreadGetStackSize_2
   2785              return 0u;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE008             B.N      ??osThreadGetStackSize_1
   2786            }
   2787          
   2788            CORE_DECLARE_IRQ_STATE;
   2789            CORE_ENTER_CRITICAL();
   \                     ??osThreadGetStackSize_2: (+1)
   \       0x1A   0x.... 0x....      BL       CORE_EnterCritical
   \       0x1E   0x0006             MOVS     R6,R0
   2790            stk_size = (uint32_t)p_thread->tcb.StkSize * sizeof(CPU_STK);
   \       0x20   0x6B20             LDR      R0,[R4, #+48]
   \       0x22   0x0087             LSLS     R7,R0,#+2
   2791            CORE_EXIT_CRITICAL();
   \       0x24   0x0030             MOVS     R0,R6
   \       0x26   0x.... 0x....      BL       CORE_ExitCritical
   2792            return stk_size;
   \       0x2A   0x0038             MOVS     R0,R7
   \                     ??osThreadGetStackSize_1: (+1)
   \       0x2C   0xBDF2             POP      {R1,R4-R7,PC}
   2793          }
   2794          
   2795          /*
   2796           ****************************************************************************************************
   2797           *                                        osThreadGetStackSpace()
   2798           *
   2799           * Description: The function 'osThreadGetStackSize()' returns the unused stack space still available
   2800           *              for the thread specified by parameter 'thread_id'. In case of an error, it returns 0.
   2801           *
   2802           * Arguments  : thread_id    is the ID of the thread
   2803           *
   2804           * Returns    : The stack size (in bytes)
   2805           *
   2806           * Note(s)    : 1) This function CANNOT be called from an ISR
   2807           *              2) This function will likely return an incorrect value if called for the currently running task
   2808           ****************************************************************************************************
   2809           */

   \                                 In section .text, align 2, keep-with-next
   2810          uint32_t  osThreadGetStackSpace(osThreadId_t  thread_id)
   2811          {
   \                     osThreadGetStackSpace: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   2812          #if (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED)
   2813            osThread_t *p_thread;
   2814            uint32_t    free_space;
   2815          
   2816            if (CORE_InIrqContext() == true) {
   \        0x4   0x.... 0x....      BL       CORE_InIrqContext
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??osThreadGetStackSpace_0
   2817              return 0u;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE010             B.N      ??osThreadGetStackSpace_1
   2818            }
   2819          
   2820            p_thread = (osThread_t *)thread_id;
   \                     ??osThreadGetStackSpace_0: (+1)
   \       0x10   0x002C             MOVS     R4,R5
   2821          
   2822            if (p_thread == (osThread_t *)0) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD101             BNE.N    ??osThreadGetStackSpace_2
   2823              return 0u;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE00B             B.N      ??osThreadGetStackSpace_1
   2824            }
   2825          
   2826            CORE_DECLARE_IRQ_STATE;
   2827            CORE_ENTER_CRITICAL();
   \                     ??osThreadGetStackSpace_2: (+1)
   \       0x1A   0x.... 0x....      BL       CORE_EnterCritical
   \       0x1E   0x0006             MOVS     R6,R0
   2828            free_space = (uint32_t)(p_thread->tcb.StkSize - p_thread->tcb.StkUsed) * sizeof(CPU_STK);
   \       0x20   0x6B21             LDR      R1,[R4, #+48]
   \       0x22   0xF8D4 0x0090      LDR      R0,[R4, #+144]
   \       0x26   0x1A09             SUBS     R1,R1,R0
   \       0x28   0x008F             LSLS     R7,R1,#+2
   2829            CORE_EXIT_CRITICAL();
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0x.... 0x....      BL       CORE_ExitCritical
   2830            return free_space;
   \       0x30   0x0038             MOVS     R0,R7
   \                     ??osThreadGetStackSpace_1: (+1)
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}
   2831          #else
   2832            (void)thread_id;
   2833            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
   2834            return 0u;
   2835          #endif
   2836          }
   2837          
   2838          /*
   2839           ****************************************************************************************************
   2840           *                                        osThreadGetCount()
   2841           *
   2842           * Description: The function 'osThreadGetCount()' returns the number of active threads or 0 in case of an error.
   2843           *
   2844           * Arguments  : None
   2845           *
   2846           * Returns    : The number of active tasks
   2847           *
   2848           * Note(s)    : 1) This function CANNOT be called from an ISR
   2849           ****************************************************************************************************
   2850           */

   \                                 In section .text, align 2, keep-with-next
   2851          uint32_t  osThreadGetCount(void)
   2852          {
   \                     osThreadGetCount: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2853            if (CORE_InIrqContext() == true) {
   \        0x2   0x.... 0x....      BL       CORE_InIrqContext
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??osThreadGetCount_0
   2854              return 0u;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE002             B.N      ??osThreadGetCount_1
   2855            }
   2856            return (uint32_t)OSTaskQty;
   \                     ??osThreadGetCount_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \       0x12   0x8800             LDRH     R0,[R0, #+0]
   \                     ??osThreadGetCount_1: (+1)
   \       0x14   0xBD02             POP      {R1,PC}
   2857          }
   2858          
   2859          /*
   2860           ****************************************************************************************************
   2861           *                                        osThreadEnumerate()
   2862           *
   2863           * Description: The function 'osThreadEnumerate()' returns the number of enumerated threads or 0 in case
   2864           *              of an error.
   2865           *
   2866           * Arguments  : thread_array      pointer to array for retrieving thread IDs.
   2867           *              array_items       maximum number of items in array for retrieving thread IDs.
   2868           *
   2869           * Returns    : The number of active tasks
   2870           *
   2871           * Note(s)    : 1) This function CANNOT be called from an ISR
   2872           *              2) This feature require OS_CFG_DBG_EN
   2873           ****************************************************************************************************
   2874           */

   \                                 In section .text, align 2, keep-with-next
   2875          uint32_t  osThreadEnumerate(osThreadId_t   *thread_array,
   2876                                      uint32_t       array_items)
   2877          {
   \                     osThreadEnumerate: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   2878          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2879            OS_TCB   *p_tcb;
   2880            uint32_t  items;
   2881          
   2882            if (CORE_InIrqContext() == true) {
   2883              return 0u;
   2884            }
   2885            items = 0u;
   2886          
   2887            CORE_DECLARE_IRQ_STATE;
   2888            CORE_ENTER_CRITICAL();
   2889            p_tcb = OSTaskDbgListPtr;
   2890            while ((p_tcb != (OS_TCB *)0) && (items < array_items)) {
   2891              *thread_array = p_tcb;
   2892              thread_array++;
   2893              p_tcb = p_tcb->DbgNextPtr;
   2894              items++;
   2895            }
   2896            CORE_EXIT_CRITICAL();
   2897            return items;
   2898          #else
   2899            (void)thread_array;
   2900            (void)array_items;
   2901            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
   \        0x6   0x.... 0x....      BL       CPU_SW_Exception
   2902            return 0u;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD32             POP      {R1,R4,R5,PC}
   2903          #endif
   2904          }
   2905          
   2906          /*
   2907           ****************************************************************************************************
   2908           ****************************************************************************************************
   2909           *                                     T H R E A D   F L A G S
   2910           ****************************************************************************************************
   2911           ****************************************************************************************************
   2912           */
   2913          
   2914          /*
   2915           ****************************************************************************************************
   2916           *                                        osThreadFlagsSet()
   2917           *
   2918           * Description: Thread Flags are a more specialized version of the Event Flags.  See Event Flags.
   2919           *              While Event Flags can be used to globally signal a number of threads, thread flags are
   2920           *              only sent to a single specific thread.  Every thread instance can receive thread flags
   2921           *              without any additional allocation of a thread flags object.
   2922           *
   2923           * Arguments  : thread_id              is the desired theard ID
   2924           *
   2925           *              flags                  are the flags to set
   2926           *                                     the upper bit (i.e. bit 31, is not allowed to be set)
   2927           *
   2928           * Returns    : osFlagsErrorUnknown    unspecified error.
   2929           *              osFlagsErrorParameter  parameter 'thread_id' is not a valid thread or flags has highest bit set.
   2930           *              osFlagsErrorResource   the thread is in invalid state.
   2931           *
   2932           * Note(s)    : None
   2933           ****************************************************************************************************
   2934           */

   \                                 In section .text, align 2, keep-with-next
   2935          uint32_t  osThreadFlagsSet(osThreadId_t  thread_id,
   2936                                     uint32_t      flags)
   2937          {
   \                     osThreadFlagsSet: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000F             MOVS     R7,R1
   2938          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   2939            RTOS_ERR      err;
   2940            osThread_t   *p_thread;
   2941            OS_FLAG_GRP  *p_grp;
   2942            OS_TCB       *p_tcb;
   2943            uint32_t      rdy_flags;
   2944            uint32_t      new_flags;
   2945            uint32_t      ret_flags;
   2946            CORE_DECLARE_IRQ_STATE;
   2947          
   2948            p_thread = (osThread_t*)thread_id;
   \        0xA   0x465E             MOV      R6,R11
   2949            if (p_thread == (osThread_t *)0) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD102             BNE.N    ??osThreadFlagsSet_0
   2950              return osFlagsErrorParameter;
   \       0x10   0xF07F 0x0003      MVNS     R0,#+3
   \       0x14   0xE048             B.N      ??osThreadFlagsSet_1
   2951            }
   2952            p_grp = &p_thread->flag_grp;
   \                     ??osThreadFlagsSet_0: (+1)
   \       0x16   0xF116 0x089C      ADDS     R8,R6,#+156
   2953          
   2954            if ((flags & 0x80000000u) == 0x80000000u) {          // Upper bit is not allowed to be set
   \       0x1A   0x2F00             CMP      R7,#+0
   \       0x1C   0xD502             BPL.N    ??osThreadFlagsSet_2
   2955              return osFlagsErrorParameter;
   \       0x1E   0xF07F 0x0003      MVNS     R0,#+3
   \       0x22   0xE041             B.N      ??osThreadFlagsSet_1
   2956            }
   2957          
   2958            CORE_ENTER_ATOMIC();
   \                     ??osThreadFlagsSet_2: (+1)
   \       0x24   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x28   0x4681             MOV      R9,R0
   2959          
   2960            new_flags = p_grp->Flags |= flags;                            // New flags after set
   \       0x2A   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x2E   0x4338             ORRS     R0,R7,R0
   \       0x30   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \       0x34   0xF8D8 0xA00C      LDR      R10,[R8, #+12]
   2961          
   2962            p_tcb = p_grp->PendList.HeadPtr;                              // Loop over pending tasks
   \       0x38   0xF8D8 0x5004      LDR      R5,[R8, #+4]
   2963            while (p_tcb != DEF_NULL) {
   \                     ??osThreadFlagsSet_3: (+1)
   \       0x3C   0x2D00             CMP      R5,#+0
   \       0x3E   0xD022             BEQ.N    ??osThreadFlagsSet_4
   2964              if (p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_CONSUME) {           // Pender might consume the flags?
   \       0x40   0xF8B5 0x0080      LDRH     R0,[R5, #+128]
   \       0x44   0x05C0             LSLS     R0,R0,#+23
   \       0x46   0xD51C             BPL.N    ??osThreadFlagsSet_5
   2965                switch (p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK) {
   \       0x48   0xF895 0x0080      LDRB     R0,[R5, #+128]
   \       0x4C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x2804             CMP      R0,#+4
   \       0x54   0xD002             BEQ.N    ??osThreadFlagsSet_6
   \       0x56   0x2808             CMP      R0,#+8
   \       0x58   0xD00A             BEQ.N    ??osThreadFlagsSet_7
   \       0x5A   0xE012             B.N      ??osThreadFlagsSet_8
   2966                  case OS_OPT_PEND_FLAG_SET_ALL:                          // -> Pender waiting for all flags to be set
   2967                    rdy_flags = (new_flags & p_tcb->FlagsPend);
   \                     ??osThreadFlagsSet_6: (+1)
   \       0x5C   0x6FA8             LDR      R0,[R5, #+120]
   \       0x5E   0xEA10 0x000A      ANDS     R0,R0,R10
   \       0x62   0x0004             MOVS     R4,R0
   2968                    if (rdy_flags == p_tcb->FlagsPend) {                  //    -> Pender will really consume?
   \       0x64   0x6FA8             LDR      R0,[R5, #+120]
   \       0x66   0x4284             CMP      R4,R0
   \       0x68   0xD101             BNE.N    ??osThreadFlagsSet_9
   2969                      new_flags &= ~rdy_flags;                            //    -> Simulate the consumption
   \       0x6A   0xEA3A 0x0A04      BICS     R10,R10,R4
   2970                    }
   2971                    break;
   \                     ??osThreadFlagsSet_9: (+1)
   \       0x6E   0xE008             B.N      ??osThreadFlagsSet_5
   2972          
   2973                  case OS_OPT_PEND_FLAG_SET_ANY:                          // -> Pender waiting for any flags to be set
   2974                    rdy_flags = (new_flags & p_tcb->FlagsPend);
   \                     ??osThreadFlagsSet_7: (+1)
   \       0x70   0x6FA8             LDR      R0,[R5, #+120]
   \       0x72   0xEA10 0x000A      ANDS     R0,R0,R10
   \       0x76   0x0004             MOVS     R4,R0
   2975                    if (rdy_flags != 0u) {                                //    -> Pender will really consume?
   \       0x78   0x2C00             CMP      R4,#+0
   \       0x7A   0xD001             BEQ.N    ??osThreadFlagsSet_10
   2976                      new_flags &= ~rdy_flags;                            //    -> Simulate the consumption
   \       0x7C   0xEA3A 0x0A04      BICS     R10,R10,R4
   2977                    }
   2978                    break;
   \                     ??osThreadFlagsSet_10: (+1)
   \       0x80   0xE7FF             B.N      ??osThreadFlagsSet_5
   2979          
   2980                  default:
   2981                    break;
   2982                }
   2983              }
   2984              p_tcb = p_tcb->PendNextPtr;                                 // Point to next task waiting for event flag(s)
   \                     ??osThreadFlagsSet_8: (+1)
   \                     ??osThreadFlagsSet_5: (+1)
   \       0x82   0x69AD             LDR      R5,[R5, #+24]
   \       0x84   0xE7DA             B.N      ??osThreadFlagsSet_3
   2985            }
   2986          
   2987            CORE_EXIT_ATOMIC();
   \                     ??osThreadFlagsSet_4: (+1)
   \       0x86   0x4648             MOV      R0,R9
   \       0x88   0x.... 0x....      BL       CORE_ExitAtomic
   2988          
   2989            OSFlagPost(p_grp, (OS_FLAGS)flags, OS_OPT_POST_FLAG_SET, &err);
   \       0x8C   0x466B             MOV      R3,SP
   \       0x8E   0x2200             MOVS     R2,#+0
   \       0x90   0x0039             MOVS     R1,R7
   \       0x92   0x4640             MOV      R0,R8
   \       0x94   0x.... 0x....      BL       OSFlagPost
   2990          
   2991            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x98   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD101             BNE.N    ??osThreadFlagsSet_11
   2992              case RTOS_ERR_NONE:
   2993                ret_flags = new_flags;
   \       0xA0   0x4650             MOV      R0,R10
   2994                break;
   \       0xA2   0xE001             B.N      ??osThreadFlagsSet_12
   2995          
   2996              default:
   2997                ret_flags = osFlagsErrorResource;
   \                     ??osThreadFlagsSet_11: (+1)
   \       0xA4   0xF07F 0x0002      MVNS     R0,#+2
   2998                break;
   2999            }
   3000            return ret_flags;
   \                     ??osThreadFlagsSet_12: (+1)
   \                     ??osThreadFlagsSet_1: (+1)
   \       0xA8   0xB005             ADD      SP,SP,#+20
   \       0xAA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3001          #else
   3002            (void)thread_id;
   3003            (void)flags;
   3004            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osFlagsErrorUnknown);
   3005            return osFlagsErrorUnknown;
   3006          #endif
   3007          }
   3008          
   3009          /*
   3010           ****************************************************************************************************
   3011           *                                        osThreadFlagsClear()
   3012           *
   3013           * Description: The function 'osThreadFlagsClear()' clears the specified flags for the currently running
   3014           *              thread.  It returns the flags before clearing, or an error code if highest bit is set
   3015           *              (refer to Flags Functions Error Codes).
   3016           *
   3017           * Arguments  : flags                  are the flags to clear
   3018           *
   3019           * Returns    : osFlagsErrorUnknown    unspecified error, i.e. not called from a running threads context.
   3020           *              osFlagsErrorParameter  parameter flags has highest bit set.
   3021           *
   3022           * Note(s)    : 1) This function CANNOT be called from an ISR
   3023           ****************************************************************************************************
   3024           */

   \                                 In section .text, align 2, keep-with-next
   3025          uint32_t  osThreadFlagsClear(uint32_t  flags)
   3026          {
   \                     osThreadFlagsClear: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   3027          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   3028            osThread_t   *p_thread;
   3029            OS_FLAG_GRP  *p_grp;
   3030            RTOS_ERR      err;
   3031            uint32_t      old_flags;
   3032          
   3033            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osThreadFlagsClear_0
   3034              return (uint32_t)osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE011             B.N      ??osThreadFlagsClear_1
   3035            }
   3036          
   3037            if ((flags & 0x80000000u) == 0x80000000u) {          // Upper bit is not allowed to be set
   \                     ??osThreadFlagsClear_0: (+1)
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD502             BPL.N    ??osThreadFlagsClear_2
   3038              return osFlagsErrorParameter;
   \       0x18   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1C   0xE00C             B.N      ??osThreadFlagsClear_1
   3039            }
   3040          
   3041            p_thread = (osThread_t*)OSTCBCurPtr;
   \                     ??osThreadFlagsClear_2: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \       0x22   0x6807             LDR      R7,[R0, #+0]
   3042            p_grp = &p_thread->flag_grp;
   \       0x24   0xF117 0x059C      ADDS     R5,R7,#+156
   3043            old_flags = p_grp->Flags;
   \       0x28   0x68EE             LDR      R6,[R5, #+12]
   3044            (void)OSFlagPost(p_grp, (OS_FLAGS)flags, OS_OPT_POST_FLAG_CLR, &err);
   \       0x2A   0x466B             MOV      R3,SP
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x0021             MOVS     R1,R4
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x.... 0x....      BL       OSFlagPost
   3045          
   3046            return old_flags;
   \       0x36   0x0030             MOVS     R0,R6
   \                     ??osThreadFlagsClear_1: (+1)
   \       0x38   0xB005             ADD      SP,SP,#+20
   \       0x3A   0xBDF0             POP      {R4-R7,PC}
   3047          #else
   3048            (void)flags;
   3049            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osFlagsErrorUnknown);
   3050            return osFlagsErrorUnknown;
   3051          #endif
   3052          }
   3053          
   3054          /*
   3055           ****************************************************************************************************
   3056           *                                        osThreadFlagsGet()
   3057           *
   3058           * Description: The function 'osThreadFlagsGet()' returns the flags currently set for the currently
   3059           *              running thread.  If called without a active and currently running thread
   3060           *              'osThreadFlagsGet()' return zero.
   3061           *
   3062           * Arguments  : None
   3063           *
   3064           * Returns    : the flags
   3065           *
   3066           * Note(s)    : 1) This function CANNOT be called from an ISR
   3067           ****************************************************************************************************
   3068           */

   \                                 In section .text, align 2, keep-with-next
   3069          uint32_t  osThreadFlagsGet(void)
   3070          {
   \                     osThreadFlagsGet: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3071          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   3072            osThread_t   *p_thread;
   3073            OS_FLAG_GRP  *p_grp;
   3074            uint32_t      flags;
   3075          
   3076            if (CORE_InIrqContext() == true) {
   \        0x2   0x.... 0x....      BL       CORE_InIrqContext
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD102             BNE.N    ??osThreadFlagsGet_0
   3077              return (uint32_t)osErrorISR;
   \        0xA   0xF07F 0x0005      MVNS     R0,#+5
   \        0xE   0xE005             B.N      ??osThreadFlagsGet_1
   3078            }
   3079          
   3080            p_thread = (osThread_t*)OSTCBCurPtr;
   \                     ??osThreadFlagsGet_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   3081            p_grp = &p_thread->flag_grp;
   \       0x16   0xF112 0x019C      ADDS     R1,R2,#+156
   3082            flags = p_grp->Flags;
   \       0x1A   0x68C8             LDR      R0,[R1, #+12]
   3083          
   3084            return flags;
   \                     ??osThreadFlagsGet_1: (+1)
   \       0x1C   0xBD02             POP      {R1,PC}
   3085          #else
   3086            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osFlagsErrorUnknown);
   3087            return osFlagsErrorUnknown;
   3088          #endif
   3089          }
   3090          
   3091          /*
   3092           ****************************************************************************************************
   3093           *                                        osThreadFlagsWait()
   3094           *
   3095           * Description: The function 'osThreadFlagsWait()' suspends the execution of the currently RUNNING
   3096           *              thread until any or all of the thread flags specified with the parameter flags are set.
   3097           *
   3098           *              When these thread flags are already set, the function returns instantly.  Otherwise the
   3099           *              thread is put into the state BLOCKED.
   3100           *
   3101           * Arguments  : flags                  are the flags to wait for
   3102           *
   3103           *              options                wait for:
   3104           *                                         osFlagsWaitAny
   3105           *                                         osFlagsWaitAnyNoClear
   3106           *                                         osFlagsWaitAll
   3107           *                                         osFlagsWaitAllNoClear
   3108           *
   3109           *              timeout                the amount of time to wait for the desired flags
   3110           *
   3111           * Returns    : osFlagsErrorUnknown    unspecified error, i.e. not called from a running threads context.
   3112           *              osFlagsErrorTimeout    awaited flags have not been set in the given time.
   3113           *              osFlagsErrorResource   awaited flags have not been set when no timeout was specified.
   3114           *              osFlagsErrorParameter  Parameter flags has highest bit set.
   3115           *
   3116           * Note(s)    : 1) This function CANNOT be called from an ISR
   3117           ****************************************************************************************************
   3118           */

   \                                 In section .text, align 2, keep-with-next
   3119          uint32_t  osThreadFlagsWait(uint32_t   flags,
   3120                                      uint32_t   options,
   3121                                      uint32_t   timeout)
   3122          {
   \                     osThreadFlagsWait: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0014             MOVS     R4,R2
   3123          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   3124            osThread_t   *p_thread;
   3125            OS_FLAG_GRP  *p_grp;
   3126            RTOS_ERR      err;
   3127            OS_TICK       os_timeout;
   3128            OS_OPT        opt;
   3129            CPU_TS        ts;
   3130            uint32_t      old_flags;
   3131            uint32_t      rdy_flags;
   3132            uint32_t      rtn_flags;
   3133          
   3134            if (CORE_InIrqContext() == true) {
   \        0xC   0x.... 0x....      BL       CORE_InIrqContext
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD102             BNE.N    ??osThreadFlagsWait_0
   3135              return (uint32_t)osErrorISR;
   \       0x14   0xF07F 0x0005      MVNS     R0,#+5
   \       0x18   0xE049             B.N      ??osThreadFlagsWait_1
   3136            }
   3137          
   3138            if ((flags & 0x80000000u) == 0x80000000u) {                           // Upper bit is not
   \                     ??osThreadFlagsWait_0: (+1)
   \       0x1A   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x1E   0xD502             BPL.N    ??osThreadFlagsWait_2
   3139                                                                                  // allowed to be set
   3140              return osFlagsErrorParameter;
   \       0x20   0xF07F 0x0003      MVNS     R0,#+3
   \       0x24   0xE043             B.N      ??osThreadFlagsWait_1
   3141            }
   3142          
   3143            if (timeout == osWaitForever) {
   \                     ??osThreadFlagsWait_2: (+1)
   \       0x26   0xF114 0x0F01      CMN      R4,#+1
   \       0x2A   0xD102             BNE.N    ??osThreadFlagsWait_3
   3144              opt = OS_OPT_PEND_BLOCKING;
   \       0x2C   0x2700             MOVS     R7,#+0
   3145              os_timeout = 0u;                                                    // Specifying 0 in MicriumOS
   \       0x2E   0x2600             MOVS     R6,#+0
   \       0x30   0xE007             B.N      ??osThreadFlagsWait_4
   3146                                                                                  // means wait forever w/ blocking
   3147            } else if (timeout == 0u) {
   \                     ??osThreadFlagsWait_3: (+1)
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD103             BNE.N    ??osThreadFlagsWait_5
   3148              opt = OS_OPT_PEND_NON_BLOCKING;
   \       0x36   0xF44F 0x4700      MOV      R7,#+32768
   3149              os_timeout = 0u;                                                    // The timeout parameter is
   \       0x3A   0x2600             MOVS     R6,#+0
   \       0x3C   0xE001             B.N      ??osThreadFlagsWait_4
   3150                                                                                  // ignored by MicriumOS in
   3151                                                                                  // non-blocking mode
   3152            } else {
   3153              opt = OS_OPT_PEND_BLOCKING;
   \                     ??osThreadFlagsWait_5: (+1)
   \       0x3E   0x2700             MOVS     R7,#+0
   3154              os_timeout = timeout;
   \       0x40   0x0026             MOVS     R6,R4
   3155            }
   3156          
   3157            if (options & osFlagsWaitAll) {
   \                     ??osThreadFlagsWait_4: (+1)
   \       0x42   0x07E8             LSLS     R0,R5,#+31
   \       0x44   0xD502             BPL.N    ??osThreadFlagsWait_6
   3158              opt |= OS_OPT_PEND_FLAG_SET_ALL;
   \       0x46   0xF057 0x0704      ORRS     R7,R7,#0x4
   \       0x4A   0xE001             B.N      ??osThreadFlagsWait_7
   3159            } else {
   3160              opt |= OS_OPT_PEND_FLAG_SET_ANY;
   \                     ??osThreadFlagsWait_6: (+1)
   \       0x4C   0xF057 0x0708      ORRS     R7,R7,#0x8
   3161            }
   3162          
   3163            if (!(options & osFlagsNoClear)) {
   \                     ??osThreadFlagsWait_7: (+1)
   \       0x50   0x07A8             LSLS     R0,R5,#+30
   \       0x52   0xD401             BMI.N    ??osThreadFlagsWait_8
   3164              opt |= OS_OPT_PEND_FLAG_CONSUME;
   \       0x54   0xF457 0x7780      ORRS     R7,R7,#0x100
   3165            }
   3166          
   3167            p_thread = (osThread_t *)OSTCBCurPtr;
   \                     ??osThreadFlagsWait_8: (+1)
   \       0x58   0x....             LDR.N    R0,??DataTable18_3
   \       0x5A   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   3168            p_grp = &p_thread->flag_grp;
   \       0x5E   0xF118 0x099C      ADDS     R9,R8,#+156
   3169            old_flags = p_grp->Flags;                                              // Get flags
   \       0x62   0xF8D9 0xA00C      LDR      R10,[R9, #+12]
   3170          
   3171            rdy_flags = (uint32_t)OSFlagPend(p_grp, (OS_FLAGS)flags, os_timeout, opt, &ts, &err);
   \       0x66   0xA803             ADD      R0,SP,#+12
   \       0x68   0x9001             STR      R0,[SP, #+4]
   \       0x6A   0xA802             ADD      R0,SP,#+8
   \       0x6C   0x9000             STR      R0,[SP, #+0]
   \       0x6E   0x003B             MOVS     R3,R7
   \       0x70   0xB29B             UXTH     R3,R3
   \       0x72   0x0032             MOVS     R2,R6
   \       0x74   0x4659             MOV      R1,R11
   \       0x76   0x4648             MOV      R0,R9
   \       0x78   0x.... 0x....      BL       OSFlagPend
   \       0x7C   0x0001             MOVS     R1,R0
   3172            rtn_flags = rdy_flags | old_flags;
   \       0x7E   0xEA5A 0x0201      ORRS     R2,R10,R1
   3173          
   3174            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x82   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD006             BEQ.N    ??osThreadFlagsWait_9
   \       0x8A   0x281D             CMP      R0,#+29
   \       0x8C   0xD006             BEQ.N    ??osThreadFlagsWait_10
   \       0x8E   0x2822             CMP      R0,#+34
   \       0x90   0xD10B             BNE.N    ??osThreadFlagsWait_11
   3175              case RTOS_ERR_TIMEOUT:
   3176                return osFlagsErrorTimeout;
   \                     ??osThreadFlagsWait_12: (+1)
   \       0x92   0xF07F 0x0001      MVNS     R0,#+1
   \       0x96   0xE00A             B.N      ??osThreadFlagsWait_1
   3177          
   3178              case RTOS_ERR_NONE:
   3179                return rtn_flags;
   \                     ??osThreadFlagsWait_9: (+1)
   \       0x98   0x0010             MOVS     R0,R2
   \       0x9A   0xE008             B.N      ??osThreadFlagsWait_1
   3180          
   3181              case RTOS_ERR_WOULD_BLOCK:
   3182                if (rdy_flags != (uint32_t)0u) {
   \                     ??osThreadFlagsWait_10: (+1)
   \       0x9C   0x2900             CMP      R1,#+0
   \       0x9E   0xD001             BEQ.N    ??osThreadFlagsWait_13
   3183                  return rtn_flags;
   \       0xA0   0x0010             MOVS     R0,R2
   \       0xA2   0xE004             B.N      ??osThreadFlagsWait_1
   3184                } else {
   3185                  return osFlagsErrorResource;
   \                     ??osThreadFlagsWait_13: (+1)
   \       0xA4   0xF07F 0x0002      MVNS     R0,#+2
   \       0xA8   0xE001             B.N      ??osThreadFlagsWait_1
   3186                }
   3187          
   3188              case RTOS_ERR_OS_OBJ_DEL:
   3189              case RTOS_ERR_OS_SCHED_LOCKED:
   3190              case RTOS_ERR_ABORT:
   3191              default:
   3192                return osFlagsErrorResource;
   \                     ??osThreadFlagsWait_11: (+1)
   \       0xAA   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osThreadFlagsWait_1: (+1)
   \       0xAE   0xB007             ADD      SP,SP,#+28
   \       0xB0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3193            }
   3194          #else
   3195            (void)flags;
   3196            (void)options;
   3197            (void)timeout;
   3198            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osFlagsErrorUnknown);
   3199            return osFlagsErrorUnknown;
   3200          #endif
   3201          }
   3202          
   3203          /*
   3204           ****************************************************************************************************
   3205           ****************************************************************************************************
   3206           *                                  T I M E R   M A N A G E M E N T
   3207           ***************************************************************************************************/
   3208          /****************************************************************************************************
   3209           *                                           osTimerNew()
   3210           *
   3211           * Description: The function 'osTimerNew()' creates an one-shot or periodic timer and associates it with
   3212           *              a callback function with argument.  The timer is in stopped state until it is started
   3213           *              with 'osTimerStart()'.  The function can be safely called before the RTOS is started
   3214           *              (call to 'osKernelStart()'), but not before it is initialized (call to 'osKernelInitialize()').
   3215           *
   3216           *              The function 'osTimerNew()' returns the pointer to the timer object identifier or NULL
   3217           *              in case of an error.
   3218           *
   3219           * Arguments  : func            pointer to function that will be called when the timer expires
   3220           *
   3221           *              type            the type of timer created:
   3222           *                                  osTimerOnce      A one-shot timer
   3223           *                                  osTimerPeriodic  A periodic timer
   3224           *
   3225           *              argument        a pointer to arguments passed to the callback function (func) when the
   3226           *                                  timer expires.
   3227           *
   3228           *              attr            timer attributes or NULL to use default values
   3229           *
   3230           * Returns    : timer ID for reference by other functions or NULL in case of error.
   3231           *
   3232           * Note(s)    : 1) This function CANNOT be called from an ISR
   3233           ****************************************************************************************************
   3234           */

   \                                 In section .text, align 2, keep-with-next
   3235          osTimerId_t  osTimerNew(osTimerFunc_t          func,
   3236                                  osTimerType_t          type,
   3237                                  void                   *argument,
   3238                                  const  osTimerAttr_t   *attr)
   3239          {
   \                     osTimerNew: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001E             MOVS     R6,R3
   3240          #if defined CMSIS_RTOS2_TIMER_TASK_EN && (CMSIS_RTOS2_TIMER_TASK_EN == DEF_ENABLED)
   3241            osTimer_t    *p_tmr;
   3242            const char   *p_name;
   3243          
   3244            if (CORE_InIrqContext() == true) {
   3245              return (osTimerId_t)0;
   3246            }
   3247          
   3248            if (func == (osTimerFunc_t)0) {                                   // Caller must specify a callback
   3249              return (osTimerId_t)0;
   3250            }
   3251          
   3252            p_name = "Timer";
   3253            if (attr == NULL) {
   3254              p_tmr = (osTimer_t *)malloc(sizeof(osTimer_t));
   3255              if (p_tmr == (osTimer_t *)0) {
   3256                return (osTimerId_t)0;
   3257              }
   3258              p_tmr->dyn_alloc = DEF_TRUE;
   3259            } else {
   3260              if (attr->cb_mem == (void *)0) {
   3261                p_tmr = (osTimer_t *)malloc(sizeof(osTimer_t));
   3262                if (p_tmr == (osTimer_t *)0) {
   3263                  return (osTimerId_t)0;
   3264                }
   3265                p_tmr->dyn_alloc = DEF_TRUE;
   3266              } else {
   3267                if (attr->cb_size < sizeof(osTimer_t) || (uint32_t)attr->cb_mem % sizeof(CPU_ALIGN)) {
   3268                  return (osTimerId_t)0;
   3269                }
   3270                p_tmr = (osTimer_t *)attr->cb_mem;
   3271                p_tmr->dyn_alloc = DEF_FALSE;
   3272              }
   3273              if (attr->name != (const char *)0) {
   3274                p_name = attr->name;
   3275              }
   3276            }
   3277          
   3278            p_tmr->type = type;
   3279            p_tmr->name = p_name;
   3280            p_tmr->callback = func;
   3281            p_tmr->callback_data = argument;
   3282          
   3283            return (osTimerId_t)p_tmr;
   3284          #else
   3285            (void)func;
   3286            (void)type;
   3287            (void)argument;
   3288            (void)attr;
   3289            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, (osTimerId_t)0);
   \        0xA   0x.... 0x....      BL       CPU_SW_Exception
   3290            return (osTimerId_t)0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBDF2             POP      {R1,R4-R7,PC}
   3291          #endif
   3292          }
   3293          
   3294          /*
   3295           ****************************************************************************************************
   3296           *                                          osTimerGetName()
   3297           *
   3298           * Description: The function 'osTimerGetName()' returns the pointer to the name string of the timer
   3299           *              identified by parameter 'timer_id' or NULL in case of an error.
   3300           *
   3301           * Arguments  : timer_id      is the timer ID returned by 'osTimerNew()'
   3302           *
   3303           * Returns    : A pointer to the ASCII string containing the name of the timer.
   3304           *              NULL             upon error
   3305           *
   3306           * Note(s)    : 1) This function CANNOT be called from an ISR
   3307           ****************************************************************************************************
   3308           */

   \                                 In section .text, align 2, keep-with-next
   3309          const  char  *osTimerGetName(osTimerId_t  timer_id)
   3310          {
   \                     osTimerGetName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3311          #if defined CMSIS_RTOS2_TIMER_TASK_EN && (CMSIS_RTOS2_TIMER_TASK_EN == DEF_ENABLED) && (OS_CFG_DBG_EN == DEF_ENABLED)
   3312            osTimer_t *p_tmr;
   3313          
   3314            if (CORE_InIrqContext() == true) {
   3315              return NULL;
   3316            }
   3317            p_tmr = (osTimer_t *)timer_id;
   3318            if (p_tmr == (osTimer_t *)0) {
   3319              return NULL;
   3320            }
   3321          
   3322            return p_tmr->name;
   3323          #else
   3324            (void)timer_id;
   3325            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, NULL);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3326            return NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   3327          #endif
   3328          }
   3329          
   3330          /*
   3331           ****************************************************************************************************
   3332           *                                          osTimerStart()
   3333           *
   3334           * Description: The function 'osTimerStart()' starts or restarts a timer specified by the parameter
   3335           *              'timer_id'.  The parameter ticks specifies the value of the timer in time ticks.
   3336           *
   3337           * Arguments  : timer_id           is the timer ID returned by 'osTimerNew()'
   3338           *
   3339           *              ticks              is the one shot delay (osTimerOnce) or
   3340           *                                 the period of timer repeat (osTimerPeriodic)
   3341           *
   3342           * Returns    : osOK               the specified timer has been started or restarted.
   3343           *              osErrorISR         osTimerStart() cannot be called from interrupt service routines.
   3344           *              osErrorParameter   parameter 'timer_id' is either NULL or invalid or ticks is incorrect.
   3345           *              osErrorResource    the timer is in an invalid state.
   3346           *
   3347           * Note(s)    : 1) This function CANNOT be called from an ISR
   3348           ****************************************************************************************************
   3349           */

   \                                 In section .text, align 2, keep-with-next
   3350          osStatus_t  osTimerStart(osTimerId_t  timer_id,
   3351                                   uint32_t     ticks)
   3352          {
   \                     osTimerStart: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   3353          #if defined CMSIS_RTOS2_TIMER_TASK_EN && (CMSIS_RTOS2_TIMER_TASK_EN == DEF_ENABLED)
   3354            osTimer_t   *p_tmr;
   3355            sl_status_t status;
   3356            uint32_t    delay;
   3357          
   3358            if (CORE_InIrqContext() == true) {
   3359              return osErrorISR;
   3360            }
   3361          
   3362            if (ticks == 0u) {                                                // Cannot be 0 ticks
   3363              return osErrorParameter;
   3364            }
   3365          
   3366            p_tmr = (osTimer_t *)timer_id;
   3367          
   3368            if (p_tmr ==  (osTimer_t *)0) {
   3369              return osErrorParameter;
   3370            }
   3371          
   3372            // Convert from OS tick to sleeptimer ticks
   3373            delay = (uint64_t)(((uint64_t)ticks * (uint64_t)sl_sleeptimer_get_timer_frequency()) + ((uint64_t)OSCfg_TickRate_Hz - 1u)) / OSCfg_TickRate_Hz;
   3374          
   3375            if (p_tmr->type == osTimerOnce) {
   3376              status = sl_sleeptimer_start_timer(&p_tmr->handle, delay, sleeptimer_callback, (void *)p_tmr, 0, 0);
   3377            } else {
   3378              status = sl_sleeptimer_start_periodic_timer(&p_tmr->handle, delay, sleeptimer_callback, (void *)p_tmr, 0, 0);
   3379            }
   3380            if (status == SL_STATUS_OK) {
   3381              return osOK;
   3382            } else {
   3383              return osErrorResource;
   3384            }
   3385          
   3386          #else
   3387            (void)timer_id;
   3388            (void)ticks;
   3389            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   \        0x6   0x.... 0x....      BL       CPU_SW_Exception
   3390            return osError;
   \        0xA   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
   3391          #endif
   3392          }
   3393          
   3394          /*
   3395           ****************************************************************************************************
   3396           *                                          osTimerStop()
   3397           *
   3398           * Description: The function 'osTimerStop()' stops the timer specified by the parameter 'timer_id'.
   3399           *
   3400           * Arguments  : timer_id           is the timer ID returned by 'osTimerNew()'
   3401           *
   3402           * Returns    : osOK               the specified timer has been stopped
   3403           *              osErrorISR         osTimerStop() cannot be called from interrupt service routines.
   3404           *              osErrorParameter   parameter 'timer_id' is either NULL or invalid or ticks is incorrect.
   3405           *              osErrorResource    the timer is in an invalid state.
   3406           *
   3407           * Note(s)    : 1) This function CANNOT be called from an ISR
   3408           ****************************************************************************************************
   3409           */

   \                                 In section .text, align 2, keep-with-next
   3410          osStatus_t  osTimerStop(osTimerId_t  timer_id)
   3411          {
   \                     osTimerStop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3412          #if defined CMSIS_RTOS2_TIMER_TASK_EN && (CMSIS_RTOS2_TIMER_TASK_EN == DEF_ENABLED)
   3413            osTimer_t *p_tmr;
   3414            sl_status_t status;
   3415          
   3416            if (CORE_InIrqContext() == true) {
   3417              return osErrorISR;
   3418            }
   3419          
   3420            p_tmr = (osTimer_t *)timer_id;
   3421            if (p_tmr == (osTimer_t *)0) {
   3422              return osErrorParameter;
   3423            }
   3424          
   3425            status = sl_sleeptimer_stop_timer(&p_tmr->handle);
   3426            if (status == SL_STATUS_OK) {
   3427              return osOK;
   3428            } else {
   3429              return osErrorResource;
   3430            }
   3431          
   3432          #else
   3433            (void)timer_id;
   3434            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3435            return osError;
   \        0x8   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \        0xC   0xBD10             POP      {R4,PC}
   3436          #endif
   3437          }
   3438          
   3439          /*
   3440           ****************************************************************************************************
   3441           *                                        osTimerIsRunning()
   3442           *
   3443           * Description: The function 'osTimerIsRunning()' checks whether a timer specified by parameter 'timer_id'
   3444           *              is running.
   3445           *
   3446           * Arguments  : timer_id           is the timer ID returned by 'osTimerNew()'
   3447           *
   3448           * Returns    : 1                  if the timer is running
   3449           *              0                  if stopped or an error occurs
   3450           *
   3451           * Note(s)    : 1) This function CANNOT be called from an ISR
   3452           ****************************************************************************************************
   3453           */

   \                                 In section .text, align 2, keep-with-next
   3454          uint32_t  osTimerIsRunning(osTimerId_t  timer_id)
   3455          {
   \                     osTimerIsRunning: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3456          #if defined CMSIS_RTOS2_TIMER_TASK_EN && (CMSIS_RTOS2_TIMER_TASK_EN == DEF_ENABLED)
   3457            osTimer_t  *p_tmr;
   3458            sl_status_t status;
   3459            bool        running;
   3460          
   3461            if (CORE_InIrqContext() == true) {
   3462              return 0u;
   3463            }
   3464          
   3465            p_tmr = (osTimer_t*)timer_id;
   3466            if (p_tmr == (osTimer_t*)0) {
   3467              return 0u;
   3468            }
   3469          
   3470            status = sl_sleeptimer_is_timer_running(&p_tmr->handle, &running);
   3471          
   3472            if (status != SL_STATUS_OK) {
   3473              return 0u;
   3474            }
   3475          
   3476            return (uint32_t)running;
   3477          
   3478          #else
   3479            (void)timer_id;
   3480            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, 0u);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3481            return 0u;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   3482          #endif
   3483          }
   3484          
   3485          /*
   3486           ****************************************************************************************************
   3487           *                                           osTimerDelete()
   3488           *
   3489           * Description: The function 'osTimerDelete()' deletes the timer object specified by parameter 'timer_id'.
   3490           *
   3491           * Arguments  : timer_id         is the timer ID returned by 'osTimerNew()'
   3492           *
   3493           * Returns    : osOK             the timer object has been deleted.
   3494           *              osErrorParameter the parameter timer_id is NULL or invalid.
   3495           *              osErrorResource  the timer is in an invalid state.
   3496           *              osErrorISR       osTimerDelete() cannot be called from interrupt service routines.
   3497           *
   3498           *
   3499           * Note(s)    : 1) This function CANNOT be called from an ISR
   3500           ****************************************************************************************************
   3501           */

   \                                 In section .text, align 2, keep-with-next
   3502          osStatus_t  osTimerDelete(osTimerId_t  timer_id)
   3503          {
   \                     osTimerDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3504          #if defined CMSIS_RTOS2_TIMER_TASK_EN && (CMSIS_RTOS2_TIMER_TASK_EN == DEF_ENABLED)
   3505            osTimer_t   *p_tmr;
   3506          
   3507            if (CORE_InIrqContext() == true) {
   3508              return osErrorISR;
   3509            }
   3510          
   3511            p_tmr = (osTimer_t *)timer_id;
   3512            if (p_tmr == (osTimer_t *)0) {
   3513              return osErrorParameter;
   3514            }
   3515          
   3516            sl_sleeptimer_stop_timer(&p_tmr->handle);
   3517          
   3518            if (p_tmr->dyn_alloc == DEF_TRUE) {
   3519              free(p_tmr);
   3520            }
   3521            return osOK;
   3522          
   3523          #else
   3524            (void)timer_id;
   3525            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, osError);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3526            return osError;
   \        0x8   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \        0xC   0xBD10             POP      {R4,PC}
   3527          #endif
   3528          }
   3529          
   3530          /*
   3531           ****************************************************************************************************
   3532           ****************************************************************************************************
   3533           *                               M E M O R Y   P O O L   M A N A G E M E N T
   3534           ****************************************************************************************************
   3535           ****************************************************************************************************
   3536           */
   3537          
   3538          /*
   3539           ****************************************************************************************************
   3540           *                                           osMemoryPoolNew()
   3541           *
   3542           * Description: The function 'osMemoryPoolNew()' creates and initializes a memory pool object and returns
   3543           *              the pointer to the memory pool object identifier or NULL in case of an error.
   3544           *
   3545           *              It can be safely called before the RTOS is started (call to 'osKernelStart()'), but not
   3546           *              before it is initialized (call to 'osKernelInitialize()').
   3547           *
   3548           * Arguments  : block_count            maximum number of memory blocks in memory pool.
   3549           *              block_size             memory block size in bytes.
   3550           *              attr                   memory pool attributes.  If NULL, use default values.
   3551           *
   3552           * Returns    : Memory Pool ID for reference by other functions or NULL in case of error.
   3553           *
   3554           * Note(s)    : 1) MicriumOS DOES NOT support this functionality
   3555           ****************************************************************************************************
   3556           */

   \                                 In section .text, align 2, keep-with-next
   3557          osMemoryPoolId_t osMemoryPoolNew(uint32_t block_count,
   3558                                           uint32_t block_size,
   3559                                           const osMemoryPoolAttr_t *attr)
   3560          {
   \                     osMemoryPoolNew: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   3561            (void)block_count;
   3562            (void)block_size;
   3563            (void)attr;
   3564            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, NULL);
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
   3565            return NULL;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xBD70             POP      {R4-R6,PC}
   3566          }
   3567          
   3568          /*
   3569           ****************************************************************************************************
   3570           *                                       osMemoryPoolGetName()
   3571           *
   3572           * Description: The function 'osMemoryPoolName()' returns the pointer to the name string of the memory
   3573           *              pool identified by parameter 'mp_id' or NULL in case of an error.
   3574           *
   3575           * Arguments  : mp_id      is the memory pool ID returned by 'osMemoryPoolNew()'
   3576           *
   3577           * Returns    : A pointer to the ASCII string containing the name of the memory pool.
   3578           *              NULL             upon error
   3579           *
   3580           * Note(s)    : 1) MicriumOS DOES NOT support this functionality
   3581           ****************************************************************************************************
   3582           */

   \                                 In section .text, align 2, keep-with-next
   3583          const char * osMemoryPoolGetName(osMemoryPoolId_t mp_id)
   3584          {
   \                     osMemoryPoolGetName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3585            (void)mp_id;
   3586            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, NULL);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3587            return NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   3588          }
   3589          
   3590          /*
   3591           ****************************************************************************************************
   3592           *                                       osMemoryPoolAlloc()
   3593           *
   3594           * Description: The blocking function 'osMemoryPoolAlloc()' allocates the memory pool parameter 'mp_id'
   3595           *              and returns a pointer to the address of the allocated memory or 0 in case of an error.
   3596           *
   3597           *              The parameter 'timeout' specifies how long the system waits to allocate the memory.
   3598           *              While the system waits, the thread that is calling this function is put into the
   3599           *              BLOCKED state.  The thread will become READY as soon as at least one block of memory
   3600           *              gets available.
   3601           *
   3602           * Arguments  : mp_id      is the memory pool ID returned by 'osMemoryPoolNew()'
   3603           *
   3604           *              timeout    when timeout is 0, the function returns instantly (i.e. try semantics).
   3605           *                         when timeout is set to 'osWaitForever' the function will wait for an infinite
   3606           *                            time until the memory is allocated (i.e. wait semantics).
   3607           *                         all other values specify a time in kernel ticks for a timeout
   3608           *                            (i.e. timed-wait semantics).
   3609           *
   3610           * Returns    : The result is the pointer to the memory block allocated, or NULL if no memory is available.
   3611           *
   3612           * Note(s)    : 1) MicriumOS DOES NOT support this functionality
   3613           ****************************************************************************************************
   3614           */

   \                                 In section .text, align 2, keep-with-next
   3615          void * osMemoryPoolAlloc(osMemoryPoolId_t mp_id,
   3616                                   uint32_t timeout)
   3617          {
   \                     osMemoryPoolAlloc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   3618            (void)mp_id;
   3619            (void)timeout;
   3620            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, NULL);
   \        0x6   0x.... 0x....      BL       CPU_SW_Exception
   3621            return NULL;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD32             POP      {R1,R4,R5,PC}
   3622          }
   3623          
   3624          /*
   3625           ****************************************************************************************************
   3626           *                                       osMemoryPoolFree()
   3627           *
   3628           * Description: The function 'osMemoryPoolFree()' frees the memory pool block specified by the parameter
   3629           *              'block' in the memory pool object specified by the parameter 'mp_id'.  The memory block
   3630           *              is put back to the list of available blocks.
   3631           *
   3632           *              If another thread is waiting for memory to become available the thread is put to READY state.
   3633           *
   3634           * Arguments  : mp_id      is the memory pool ID returned by 'osMemoryPoolNew()'
   3635           *
   3636           *              block      address of the allocated memory block to be returned to the memory pool.
   3637           *
   3638           * Returns    : osOK                the memory has been freed.
   3639           *              osErrorParameter    parameter mp_id is NULL or invalid, block points to invalid memory.
   3640           *              osErrorResource     the memory pool is in an invalid state.
   3641           *
   3642           * Note(s)    : 1) MicriumOS DOES NOT support this functionality
   3643           ****************************************************************************************************
   3644           */

   \                                 In section .text, align 2, keep-with-next
   3645          osStatus_t osMemoryPoolFree(osMemoryPoolId_t mp_id,
   3646                                      void *block)
   3647          {
   \                     osMemoryPoolFree: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   3648            (void)mp_id;
   3649            (void)block;
   3650            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, NULL);
   \        0x6   0x.... 0x....      BL       CPU_SW_Exception
   3651            return osError;
   \        0xA   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
   3652          }
   3653          
   3654          /*
   3655           ****************************************************************************************************
   3656           *                                     osMemoryPoolGetCapacity()
   3657           *
   3658           * Description: The function 'osMemoryPoolGetCapacity()' returns the maximum number of memory blocks
   3659           *              in the memory pool object specified by parameter 'mp_id' or 0 in case of an error.
   3660           *
   3661           * Arguments  : mp_id      is the memory pool ID returned by 'osMemoryPoolNew()'
   3662           *
   3663           * Returns    : Maximum number of memory blocks
   3664           *
   3665           * Note(s)    : 1) MicriumOS DOES NOT support this functionality
   3666           ****************************************************************************************************
   3667           */

   \                                 In section .text, align 2, keep-with-next
   3668          uint32_t osMemoryPoolGetCapacity(osMemoryPoolId_t mp_id)
   3669          {
   \                     osMemoryPoolGetCapacity: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3670            (void)mp_id;
   3671            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, 0);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3672            return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   3673          }
   3674          
   3675          /*
   3676           ****************************************************************************************************
   3677           *                                 osMemoryPoolGetBlockSize()
   3678           *
   3679           * Description: The function 'osMemoryPoolGetBlockSize()' returns the memory block size in bytes in
   3680           *              the memory pool object specified by parameter 'mp_id' or 0 in case of an error.
   3681           *
   3682           * Arguments  : mp_id      is the memory pool ID returned by 'osMemoryPoolNew()'
   3683           *
   3684           * Returns    : Size (in bytes) of each block
   3685           *              0  upon error
   3686           *
   3687           * Note(s)    : 1) MicriumOS DOES NOT support this functionality
   3688           ****************************************************************************************************
   3689           */

   \                                 In section .text, align 2, keep-with-next
   3690          uint32_t osMemoryPoolGetBlockSize(osMemoryPoolId_t mp_id)
   3691          {
   \                     osMemoryPoolGetBlockSize: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3692            (void)mp_id;
   3693            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, 0);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3694            return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   3695          }
   3696          
   3697          /*
   3698           ****************************************************************************************************
   3699           *                                    osMemoryPoolGetCount()
   3700           *
   3701           * Description: The function 'osMemoryPoolGetCount()' returns the number of memory blocks used in the
   3702           *              memory pool object specified by parameter 'mp_id' or 0 in case of an error.
   3703           *
   3704           * Arguments  : mp_id      is the memory pool ID returned by 'osMemoryPoolNew()'
   3705           *
   3706           * Returns    : number of memory blocks used.
   3707           *              0  upon error
   3708           *
   3709           * Note(s)    : 1) MicriumOS DOES NOT support this functionality
   3710           ****************************************************************************************************
   3711           */

   \                                 In section .text, align 2, keep-with-next
   3712          uint32_t osMemoryPoolGetCount(osMemoryPoolId_t mp_id)
   3713          {
   \                     osMemoryPoolGetCount: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3714            (void)mp_id;
   3715            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, 0);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3716            return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   3717          }
   3718          
   3719          /*
   3720           ****************************************************************************************************
   3721           *                                    osMemoryPoolGetSpace()
   3722           *
   3723           * Description: The function 'osMemoryPoolGetSpace()' returns the number of memory blocks available
   3724           *              in the memory pool object specified by parameter 'mp_id' or 0 in case of an error.
   3725           *
   3726           * Arguments  : mp_id      is the memory pool ID returned by 'osMemoryPoolNew()'
   3727           *
   3728           * Returns    : number of memory blocks available.
   3729           *              0  upon error
   3730           *
   3731           * Note(s)    : 1) MicriumOS DOES NOT support this functionality
   3732           ****************************************************************************************************
   3733           */

   \                                 In section .text, align 2, keep-with-next
   3734          uint32_t osMemoryPoolGetSpace(osMemoryPoolId_t mp_id)
   3735          {
   \                     osMemoryPoolGetSpace: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3736            (void)mp_id;
   3737            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, 0);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3738            return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   3739          }
   3740          
   3741          /*
   3742           ****************************************************************************************************
   3743           *                                       osMemoryPoolDelete()
   3744           *
   3745           * Description: The function 'osMemoryPoolDelete()' deletes a memory pool object specified by parameter
   3746           *              'mp_id'.  It releases internal memory obtained for memory pool handling.
   3747           *
   3748           *              After this call, the 'mp_id' is no longer valid and cannot be used.  The memory pool
   3749           *              may be created again using the function 'osMemoryPoolNew()'.
   3750           *
   3751           * Arguments  : mp_id              is the memory pool ID returned by 'osMemoryPoolNew()'
   3752           *
   3753           * Returns    : osOK               the memory pool object has been deleted.
   3754           *              osErrorParameter   parameter mp_id is NULL or invalid.
   3755           *              osErrorResource    the memory pool is in an invalid state.
   3756           *              osErrorISR         'osMemoryPoolDelete()' cannot be called from an ISR
   3757           *
   3758           * Note(s)    : 1) MicriumOS DOES NOT support this functionality
   3759           ****************************************************************************************************
   3760           */

   \                                 In section .text, align 2, keep-with-next
   3761          osStatus_t osMemoryPoolDelete(osMemoryPoolId_t mp_id)
   3762          {
   \                     osMemoryPoolDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3763            (void)mp_id;
   3764            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, osError);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3765            return osError;
   \        0x8   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \        0xC   0xBD10             POP      {R4,PC}
   3766          }
   3767          
   3768          /*
   3769           ****************************************************************************************************
   3770           ****************************************************************************************************
   3771           *                          M E S S A G E   Q U E U E   M A N A G E M E N T
   3772           ****************************************************************************************************
   3773           ****************************************************************************************************
   3774           */
   3775          
   3776          /*
   3777           ****************************************************************************************************
   3778           *                                          osMessageQueueNew()
   3779           *
   3780           * Description: The function 'osMessageQueueNew()' creates and initializes a message queue object.
   3781           *              The function returns a message queue object identifier or NULL in case of an error.
   3782           *
   3783           *              The function can be called after kernel initialization with 'osKernelInitialize()'.
   3784           *              It is possible to create message queue objects before the RTOS kernel is started with
   3785           *              'osKernelStart()'.
   3786           *
   3787           *              The total amount of memory required for the message queue data is at least 'msg_count * msg_size'.
   3788           *              The 'msg_size' is rounded up to a double even number to ensure 32-bit alignment of the memory blocks.
   3789           *
   3790           *              The memory blocks allocated from the message queue have a fixed size defined with the parameter 'msg_size'.
   3791           *
   3792           * Arguments  : msg_count        is the maximum number of messages in the queue
   3793           *
   3794           *              msg_size         maximum message size (in bytes)
   3795           *
   3796           *              attr             attribute structure passed to the message queue creation code.
   3797           *                               specifying NULL assumes defaults.
   3798           *
   3799           *                               Message queue attributes are:
   3800           *
   3801           *                               .name         name of the message queue
   3802           *                               .attr_bits    reserved (should be 0)
   3803           *                               .cb_mem       pointer to message queue control block
   3804           *                                                (allocated dynamically if NULL or not specified)
   3805           *                               .cb_size      size of the message queue control block (in bytes)
   3806           *                               .mq_mem       pointer to storage of messages
   3807           *                                                (allocated dynamically if NULL or not specified)
   3808           *                               .mq_size      size of each message (in bytes)
   3809           *                                                (the minimum is 'msg_count' * 'msg_size')
   3810           *
   3811           * Returns    : The message queue ID           upon success
   3812           *              NULL                           upon error
   3813           ****************************************************************************************************
   3814           */

   \                                 In section .text, align 2, keep-with-next
   3815          osMessageQueueId_t osMessageQueueNew(uint32_t msg_count,
   3816                                               uint32_t msg_size,
   3817                                               const osMessageQueueAttr_t *attr)
   3818          {
   \                     osMessageQueueNew: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0016             MOVS     R6,R2
   3819          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   3820            osMessageQueue_t   *p_msgqueue;
   3821            CPU_CHAR           *p_name;
   3822            RTOS_ERR            err;
   3823          
   3824            if (CORE_InIrqContext() == true) {
   \        0xA   0x.... 0x....      BL       CORE_InIrqContext
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD101             BNE.N    ??osMessageQueueNew_0
   3825              return (osMessageQueueId_t)0;                                              // Can't create a msgqueue from an ISR
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE0E3             B.N      ??osMessageQueueNew_1
   3826            }
   3827            if (msg_count == 0) {                                                        // Validate msg_count
   \                     ??osMessageQueueNew_0: (+1)
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD101             BNE.N    ??osMessageQueueNew_2
   3828              return (osMessageQueueId_t)0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE0DF             B.N      ??osMessageQueueNew_1
   3829            }
   3830            if (msg_size == 0) {                                                         // Validate msg_size
   \                     ??osMessageQueueNew_2: (+1)
   \       0x1E   0x2F00             CMP      R7,#+0
   \       0x20   0xD101             BNE.N    ??osMessageQueueNew_3
   3831              return (osMessageQueueId_t)0;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xE0DB             B.N      ??osMessageQueueNew_1
   3832            } else {
   3833              msg_size = (msg_size + sizeof(CPU_ALIGN) - 1) & ~(sizeof(CPU_ALIGN) - 1);        // Align to 4 bytes
   \                     ??osMessageQueueNew_3: (+1)
   \       0x26   0x1CFF             ADDS     R7,R7,#+3
   \       0x28   0x08BF             LSRS     R7,R7,#+2
   \       0x2A   0x00BF             LSLS     R7,R7,#+2
   3834            }
   3835            p_name = (CPU_CHAR *)"QueueName?";
   \       0x2C   0x.... 0x....      LDR.W    R8,??DataTable18_6
   3836            if (attr == 0) {
   \       0x30   0x2E00             CMP      R6,#+0
   \       0x32   0xD11B             BNE.N    ??osMessageQueueNew_4
   3837              p_msgqueue = (osMessageQueue_t *)malloc(sizeof(osMessageQueue_t));
   \       0x34   0x203C             MOVS     R0,#+60
   \       0x36   0x.... 0x....      BL       malloc
   \       0x3A   0x0004             MOVS     R4,R0
   3838              if (p_msgqueue == (osMessageQueue_t *)0) {
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD101             BNE.N    ??osMessageQueueNew_5
   3839                return (osMessageQueueId_t)0;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xE0CC             B.N      ??osMessageQueueNew_1
   3840              } else {
   3841                p_msgqueue->obj_dyn_alloc = DEF_TRUE;
   \                     ??osMessageQueueNew_5: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xF884 0x0024      STRB     R0,[R4, #+36]
   3842                p_msgqueue->buf = (uint8_t *) malloc(msg_size * msg_count);
   \       0x4A   0xFB05 0xF007      MUL      R0,R5,R7
   \       0x4E   0x.... 0x....      BL       malloc
   \       0x52   0x6220             STR      R0,[R4, #+32]
   3843                if (p_msgqueue->buf == (uint8_t *)0) {
   \       0x54   0x6A20             LDR      R0,[R4, #+32]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD104             BNE.N    ??osMessageQueueNew_6
   3844                  free(p_msgqueue);
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       free
   3845                  return (osMessageQueueId_t)0;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xE0BC             B.N      ??osMessageQueueNew_1
   3846                }
   3847                p_msgqueue->buf_dyn_alloc = DEF_TRUE;
   \                     ??osMessageQueueNew_6: (+1)
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xF884 0x0025      STRB     R0,[R4, #+37]
   \       0x6A   0xE07A             B.N      ??osMessageQueueNew_7
   3848              }
   3849            } else {
   3850              if (attr->cb_mem == (void *)0) {
   \                     ??osMessageQueueNew_4: (+1)
   \       0x6C   0x68B0             LDR      R0,[R6, #+8]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD10B             BNE.N    ??osMessageQueueNew_8
   3851                p_msgqueue = (osMessageQueue_t *)malloc(sizeof(osMessageQueue_t));
   \       0x72   0x203C             MOVS     R0,#+60
   \       0x74   0x.... 0x....      BL       malloc
   \       0x78   0x0004             MOVS     R4,R0
   3852                if (p_msgqueue == (osMessageQueue_t *)0) {
   \       0x7A   0x2C00             CMP      R4,#+0
   \       0x7C   0xD101             BNE.N    ??osMessageQueueNew_9
   3853                  return (osMessageQueueId_t)0;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xE0AD             B.N      ??osMessageQueueNew_1
   3854                }
   3855                p_msgqueue->obj_dyn_alloc = DEF_TRUE;
   \                     ??osMessageQueueNew_9: (+1)
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xF884 0x0024      STRB     R0,[R4, #+36]
   \       0x88   0xE00C             B.N      ??osMessageQueueNew_10
   3856              } else {
   3857                if (attr->cb_size < sizeof(osMessageQueue_t) || (uint32_t)attr->cb_mem % sizeof(CPU_ALIGN)) {
   \                     ??osMessageQueueNew_8: (+1)
   \       0x8A   0x68F0             LDR      R0,[R6, #+12]
   \       0x8C   0x283C             CMP      R0,#+60
   \       0x8E   0xD303             BCC.N    ??osMessageQueueNew_11
   \       0x90   0x7A30             LDRB     R0,[R6, #+8]
   \       0x92   0xF010 0x0F03      TST      R0,#0x3
   \       0x96   0xD001             BEQ.N    ??osMessageQueueNew_12
   3858                  return (osMessageQueueId_t)0;
   \                     ??osMessageQueueNew_11: (+1)
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0xE0A0             B.N      ??osMessageQueueNew_1
   3859                }
   3860                p_msgqueue = attr->cb_mem;
   \                     ??osMessageQueueNew_12: (+1)
   \       0x9C   0x68B4             LDR      R4,[R6, #+8]
   3861                p_msgqueue->obj_dyn_alloc = DEF_FALSE;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xF884 0x0024      STRB     R0,[R4, #+36]
   3862              }
   3863              if (attr->mq_size == 0u) {
   \                     ??osMessageQueueNew_10: (+1)
   \       0xA4   0x6970             LDR      R0,[R6, #+20]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD114             BNE.N    ??osMessageQueueNew_13
   3864                p_msgqueue->buf = (uint8_t *)malloc(msg_size * msg_count);
   \       0xAA   0xFB05 0xF007      MUL      R0,R5,R7
   \       0xAE   0x.... 0x....      BL       malloc
   \       0xB2   0x6220             STR      R0,[R4, #+32]
   3865                if (p_msgqueue->buf == (uint8_t *)0) {
   \       0xB4   0x6A20             LDR      R0,[R4, #+32]
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD108             BNE.N    ??osMessageQueueNew_14
   3866                  if (p_msgqueue->obj_dyn_alloc == DEF_TRUE) {
   \       0xBA   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \       0xBE   0x2801             CMP      R0,#+1
   \       0xC0   0xD102             BNE.N    ??osMessageQueueNew_15
   3867                    free(p_msgqueue);
   \       0xC2   0x0020             MOVS     R0,R4
   \       0xC4   0x.... 0x....      BL       free
   3868                  }
   3869                  return (osMessageQueueId_t)0;
   \                     ??osMessageQueueNew_15: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0xE088             B.N      ??osMessageQueueNew_1
   3870                }
   3871                p_msgqueue->buf_dyn_alloc = DEF_TRUE;
   \                     ??osMessageQueueNew_14: (+1)
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xF884 0x0025      STRB     R0,[R4, #+37]
   \       0xD2   0xE041             B.N      ??osMessageQueueNew_16
   3872              } else if ((attr->mq_size != 0u) && (attr->mq_mem == NULL)) {
   \                     ??osMessageQueueNew_13: (+1)
   \       0xD4   0x6970             LDR      R0,[R6, #+20]
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD024             BEQ.N    ??osMessageQueueNew_17
   \       0xDA   0x6930             LDR      R0,[R6, #+16]
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD121             BNE.N    ??osMessageQueueNew_17
   3873                if (attr->mq_size < msg_size * msg_count) {
   \       0xE0   0x6971             LDR      R1,[R6, #+20]
   \       0xE2   0xFB05 0xF007      MUL      R0,R5,R7
   \       0xE6   0x4281             CMP      R1,R0
   \       0xE8   0xD208             BCS.N    ??osMessageQueueNew_18
   3874                  if (p_msgqueue->obj_dyn_alloc == DEF_TRUE) {
   \       0xEA   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \       0xEE   0x2801             CMP      R0,#+1
   \       0xF0   0xD102             BNE.N    ??osMessageQueueNew_19
   3875                    free(p_msgqueue);
   \       0xF2   0x0020             MOVS     R0,R4
   \       0xF4   0x.... 0x....      BL       free
   3876                  }
   3877                  return (osMessageQueueId_t)0;
   \                     ??osMessageQueueNew_19: (+1)
   \       0xF8   0x2000             MOVS     R0,#+0
   \       0xFA   0xE070             B.N      ??osMessageQueueNew_1
   3878                }
   3879                p_msgqueue->buf = (uint8_t *)malloc(attr->mq_size);
   \                     ??osMessageQueueNew_18: (+1)
   \       0xFC   0x6970             LDR      R0,[R6, #+20]
   \       0xFE   0x.... 0x....      BL       malloc
   \      0x102   0x6220             STR      R0,[R4, #+32]
   3880                if (p_msgqueue->buf == (uint8_t *)0) {
   \      0x104   0x6A20             LDR      R0,[R4, #+32]
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD108             BNE.N    ??osMessageQueueNew_20
   3881                  if (p_msgqueue->obj_dyn_alloc == DEF_TRUE) {
   \      0x10A   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \      0x10E   0x2801             CMP      R0,#+1
   \      0x110   0xD102             BNE.N    ??osMessageQueueNew_21
   3882                    free(p_msgqueue);
   \      0x112   0x0020             MOVS     R0,R4
   \      0x114   0x.... 0x....      BL       free
   3883                  }
   3884                  return (osMessageQueueId_t)0;
   \                     ??osMessageQueueNew_21: (+1)
   \      0x118   0x2000             MOVS     R0,#+0
   \      0x11A   0xE060             B.N      ??osMessageQueueNew_1
   3885                }
   3886                p_msgqueue->buf_dyn_alloc = DEF_TRUE;
   \                     ??osMessageQueueNew_20: (+1)
   \      0x11C   0x2001             MOVS     R0,#+1
   \      0x11E   0xF884 0x0025      STRB     R0,[R4, #+37]
   \      0x122   0xE019             B.N      ??osMessageQueueNew_16
   3887              } else {
   3888                if (attr->mq_mem == NULL
   3889                    || attr->mq_size < msg_size * msg_count
   3890                    || (uint32_t)attr->mq_mem % sizeof(CPU_ALIGN)) {
   \                     ??osMessageQueueNew_17: (+1)
   \      0x124   0x6930             LDR      R0,[R6, #+16]
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD008             BEQ.N    ??osMessageQueueNew_22
   \      0x12A   0x6971             LDR      R1,[R6, #+20]
   \      0x12C   0xFB05 0xF007      MUL      R0,R5,R7
   \      0x130   0x4281             CMP      R1,R0
   \      0x132   0xD303             BCC.N    ??osMessageQueueNew_22
   \      0x134   0x7C30             LDRB     R0,[R6, #+16]
   \      0x136   0xF010 0x0F03      TST      R0,#0x3
   \      0x13A   0xD008             BEQ.N    ??osMessageQueueNew_23
   3891                  if (p_msgqueue->obj_dyn_alloc == DEF_TRUE) {
   \                     ??osMessageQueueNew_22: (+1)
   \      0x13C   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \      0x140   0x2801             CMP      R0,#+1
   \      0x142   0xD102             BNE.N    ??osMessageQueueNew_24
   3892                    free(p_msgqueue);
   \      0x144   0x0020             MOVS     R0,R4
   \      0x146   0x.... 0x....      BL       free
   3893                  }
   3894                  return (osMessageQueueId_t)0;
   \                     ??osMessageQueueNew_24: (+1)
   \      0x14A   0x2000             MOVS     R0,#+0
   \      0x14C   0xE047             B.N      ??osMessageQueueNew_1
   3895                }
   3896                p_msgqueue->buf = (uint8_t *)attr->mq_mem;
   \                     ??osMessageQueueNew_23: (+1)
   \      0x14E   0x6930             LDR      R0,[R6, #+16]
   \      0x150   0x6220             STR      R0,[R4, #+32]
   3897                p_msgqueue->buf_dyn_alloc = DEF_FALSE;
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0xF884 0x0025      STRB     R0,[R4, #+37]
   3898              }
   3899              if (attr->name != (const char *)0) {
   \                     ??osMessageQueueNew_16: (+1)
   \      0x158   0x6830             LDR      R0,[R6, #+0]
   \      0x15A   0x2800             CMP      R0,#+0
   \      0x15C   0xD001             BEQ.N    ??osMessageQueueNew_7
   3900                p_name = (CPU_CHAR *)attr->name;
   \      0x15E   0x6830             LDR      R0,[R6, #+0]
   \      0x160   0x4680             MOV      R8,R0
   3901              }
   3902            }
   3903            p_msgqueue->msg_count  = msg_count;
   \                     ??osMessageQueueNew_7: (+1)
   \      0x162   0x62A5             STR      R5,[R4, #+40]
   3904            p_msgqueue->msg_size   = msg_size;
   \      0x164   0x62E7             STR      R7,[R4, #+44]
   3905            p_msgqueue->msg_queued = 0;
   \      0x166   0x2000             MOVS     R0,#+0
   \      0x168   0x6320             STR      R0,[R4, #+48]
   3906            p_msgqueue->msg_head   = 0;
   \      0x16A   0x2000             MOVS     R0,#+0
   \      0x16C   0x6360             STR      R0,[R4, #+52]
   3907            p_msgqueue->msg_tail   = 0;
   \      0x16E   0x2000             MOVS     R0,#+0
   \      0x170   0x63A0             STR      R0,[R4, #+56]
   3908          
   3909            OSSemCreate(&p_msgqueue->sem_put, p_name, msg_count, &err);
   \      0x172   0x466B             MOV      R3,SP
   \      0x174   0x002A             MOVS     R2,R5
   \      0x176   0x4641             MOV      R1,R8
   \      0x178   0x0020             MOVS     R0,R4
   \      0x17A   0x.... 0x....      BL       OSSemCreate
   3910          
   3911            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \      0x17E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x182   0x2800             CMP      R0,#+0
   \      0x184   0xD00F             BEQ.N    ??osMessageQueueNew_25
   3912              if (p_msgqueue->buf_dyn_alloc == DEF_TRUE) {
   \      0x186   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \      0x18A   0x2801             CMP      R0,#+1
   \      0x18C   0xD102             BNE.N    ??osMessageQueueNew_26
   3913                free(p_msgqueue->buf);
   \      0x18E   0x6A20             LDR      R0,[R4, #+32]
   \      0x190   0x.... 0x....      BL       free
   3914              }
   3915              if (p_msgqueue->obj_dyn_alloc == DEF_TRUE) {
   \                     ??osMessageQueueNew_26: (+1)
   \      0x194   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \      0x198   0x2801             CMP      R0,#+1
   \      0x19A   0xD102             BNE.N    ??osMessageQueueNew_27
   3916                free(p_msgqueue);
   \      0x19C   0x0020             MOVS     R0,R4
   \      0x19E   0x.... 0x....      BL       free
   3917              }
   3918              return (osMessageQueueId_t)0;
   \                     ??osMessageQueueNew_27: (+1)
   \      0x1A2   0x2000             MOVS     R0,#+0
   \      0x1A4   0xE01B             B.N      ??osMessageQueueNew_1
   3919            }
   3920          
   3921            OSSemCreate(&p_msgqueue->sem_get, p_name, 0, &err);
   \                     ??osMessageQueueNew_25: (+1)
   \      0x1A6   0x466B             MOV      R3,SP
   \      0x1A8   0x2200             MOVS     R2,#+0
   \      0x1AA   0x4641             MOV      R1,R8
   \      0x1AC   0xF114 0x0010      ADDS     R0,R4,#+16
   \      0x1B0   0x.... 0x....      BL       OSSemCreate
   3922          
   3923            if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \      0x1B4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x1B8   0x2800             CMP      R0,#+0
   \      0x1BA   0xD00F             BEQ.N    ??osMessageQueueNew_28
   3924              if (p_msgqueue->buf_dyn_alloc == DEF_TRUE) {
   \      0x1BC   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \      0x1C0   0x2801             CMP      R0,#+1
   \      0x1C2   0xD102             BNE.N    ??osMessageQueueNew_29
   3925                free(p_msgqueue->buf);
   \      0x1C4   0x6A20             LDR      R0,[R4, #+32]
   \      0x1C6   0x.... 0x....      BL       free
   3926              }
   3927              if (p_msgqueue->obj_dyn_alloc == DEF_TRUE) {
   \                     ??osMessageQueueNew_29: (+1)
   \      0x1CA   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \      0x1CE   0x2801             CMP      R0,#+1
   \      0x1D0   0xD102             BNE.N    ??osMessageQueueNew_30
   3928                free(p_msgqueue);
   \      0x1D2   0x0020             MOVS     R0,R4
   \      0x1D4   0x.... 0x....      BL       free
   3929              }
   3930              return (osMessageQueueId_t)0;
   \                     ??osMessageQueueNew_30: (+1)
   \      0x1D8   0x2000             MOVS     R0,#+0
   \      0x1DA   0xE000             B.N      ??osMessageQueueNew_1
   3931            }
   3932          
   3933            return (osMessageQueueId_t)p_msgqueue;
   \                     ??osMessageQueueNew_28: (+1)
   \      0x1DC   0x0020             MOVS     R0,R4
   \                     ??osMessageQueueNew_1: (+1)
   \      0x1DE   0xB004             ADD      SP,SP,#+16
   \      0x1E0   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3934          #else
   3935            (void) msg_count;
   3936            (void) msg_size;
   3937            (void) attr;
   3938            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, (osMessageQueueId_t)0);
   3939            return (osMessageQueueId_t)0;
   3940          #endif
   3941          }
   3942          
   3943          /*
   3944           ****************************************************************************************************
   3945           *                                         osMessageQueueGetName()
   3946           *
   3947           * Description: The function 'osMessageQueueGetName()' returns the pointer to the name string of the
   3948           *              message queue identified by parameter 'mq_id' or NULL in case of an error.
   3949           *
   3950           * Arguments  : mq_id       is the message queue ID returned by 'osMessageQueueNew()'
   3951           *
   3952           * Returns    : A pointer to the ASCII string containing the name of the mutex.
   3953           *              NULL             upon error
   3954           ****************************************************************************************************
   3955           */

   \                                 In section .text, align 2, keep-with-next
   3956          const char * osMessageQueueGetName(osMessageQueueId_t mq_id)
   3957          {
   \                     osMessageQueueGetName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3958          #if (OS_CFG_SEM_EN == DEF_ENABLED) && (OS_CFG_DBG_EN == DEF_ENABLED)
   3959            osMessageQueue_t   *p_msgqueue;
   3960          
   3961            if (CORE_InIrqContext() == true) {
   3962              return NULL;
   3963            }
   3964            p_msgqueue = (osMessageQueue_t *)mq_id;
   3965            if (p_msgqueue == (osMessageQueue_t *)0) {
   3966              return NULL;
   3967            }
   3968          
   3969            return p_msgqueue->sem_put.NamePtr;
   3970          #else
   3971            (void)mq_id;
   3972            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, NULL);
   \        0x4   0x.... 0x....      BL       CPU_SW_Exception
   3973            return NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
   3974          #endif
   3975          }
   3976          
   3977          /*
   3978           ****************************************************************************************************
   3979           *                                         osMessageQueuePut()
   3980           *
   3981           * Description: The blocking function 'osMessageQueuePut()' puts the message pointed to by 'msg_ptr'
   3982           *              into the message queue specified by parameter 'mq_id'.
   3983           *
   3984           *              The parameter 'msg_prio' is used to sort message according their priority
   3985           *              (higher numbers indicate a higher priority) on insertion.
   3986           *
   3987           *              The parameter 'timeout' specifies how long the system waits to put the message into
   3988           *              the queue.  While the system waits, the thread that is calling this function is put
   3989           *              into the BLOCKED state. The parameter timeout can have the following values:
   3990           *
   3991           *              when timeout is 0, the function returns instantly (i.e. try semantics).
   3992           *              when timeout is set to osWaitForever the function will wait for an infinite time
   3993           *                  until the message is delivered (i.e. wait semantics).
   3994           *              all other values specify a time in kernel ticks for a timeout (i.e. timed-wait semantics).
   3995           *
   3996           * Arguments  : mq_id       is the message queue ID returned by 'osMessageQueueNew()'
   3997           *
   3998           *              msg_ptr     pointer to message to send
   3999           *
   4000           *              msg_prio    priority of message sent
   4001           *
   4002           *              timeout     when timeout is 0, the function returns instantly (i.e. try semantics).
   4003           *                          when timeout is set to 'osWaitForever()' the function will wait for an
   4004           *                              infinite time until the message is delivered (i.e. wait semantics).
   4005           *                          all other values specify a time in kernel ticks for a timeout
   4006           *                              (i.e. timed-wait semantics).
   4007           *
   4008           * Returns    : osOK             the message has been put in the queue
   4009           *              osErrorTimeout   the message could not be put into the queue within the timeout specified
   4010           *              osErrorParameter the parameter 'mq_id' is NULL or invalid.
   4011           *              osErrorResource  not enough space in the queue
   4012           ****************************************************************************************************
   4013           */

   \                                 In section .text, align 2, keep-with-next
   4014          osStatus_t osMessageQueuePut(osMessageQueueId_t mq_id,
   4015                                       const void *msg_ptr,
   4016                                       uint8_t msg_prio,
   4017                                       uint32_t timeout)
   4018          {
   \                     osMessageQueuePut: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x001C             MOVS     R4,R3
   4019          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   4020            osMessageQueue_t   *p_msgqueue;
   4021            CPU_TS              ts;
   4022            RTOS_ERR            err;
   4023            uint32_t            msg_id, msg_size;
   4024            CORE_DECLARE_IRQ_STATE;
   4025          
   4026            (void) msg_prio;
   4027          
   4028            p_msgqueue = (osMessageQueue_t *)mq_id;
   \        0xE   0x4655             MOV      R5,R10
   4029            if (p_msgqueue == (osMessageQueue_t *)0) {
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD102             BNE.N    ??osMessageQueuePut_0
   4030              return osErrorParameter;
   \       0x14   0xF07F 0x0003      MVNS     R0,#+3
   \       0x18   0xE059             B.N      ??osMessageQueuePut_1
   4031            }
   4032          
   4033            if (timeout == 0u) {
   \                     ??osMessageQueuePut_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD109             BNE.N    ??osMessageQueuePut_2
   4034              OSSemPend(&p_msgqueue->sem_put, (OS_TICK)0u, OS_OPT_PEND_NON_BLOCKING, &ts, &err);
   \       0x1E   0xA804             ADD      R0,SP,#+16
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0xAB01             ADD      R3,SP,#+4
   \       0x24   0xF44F 0x4200      MOV      R2,#+32768
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x.... 0x....      BL       OSSemPend
   \       0x30   0xE00E             B.N      ??osMessageQueuePut_3
   4035            } else {
   4036              if (CORE_InIrqContext() == true) {
   \                     ??osMessageQueuePut_2: (+1)
   \       0x32   0x.... 0x....      BL       CORE_InIrqContext
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD102             BNE.N    ??osMessageQueuePut_4
   4037                return osErrorParameter;
   \       0x3A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x3E   0xE046             B.N      ??osMessageQueuePut_1
   4038              } else {
   4039                OSSemPend(&p_msgqueue->sem_put, (OS_TICK)timeout, OS_OPT_PEND_BLOCKING, &ts, &err);
   \                     ??osMessageQueuePut_4: (+1)
   \       0x40   0xA804             ADD      R0,SP,#+16
   \       0x42   0x9000             STR      R0,[SP, #+0]
   \       0x44   0xAB01             ADD      R3,SP,#+4
   \       0x46   0x2200             MOVS     R2,#+0
   \       0x48   0x0021             MOVS     R1,R4
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0x.... 0x....      BL       OSSemPend
   4040              }
   4041            }
   4042          
   4043            switch (RTOS_ERR_CODE_GET(err)) {
   \                     ??osMessageQueuePut_3: (+1)
   \       0x50   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD002             BEQ.N    ??osMessageQueuePut_5
   \       0x58   0x2822             CMP      R0,#+34
   \       0x5A   0xD02E             BEQ.N    ??osMessageQueuePut_6
   \       0x5C   0xE030             B.N      ??osMessageQueuePut_7
   4044              case RTOS_ERR_NONE:
   4045                break;
   4046          
   4047              case RTOS_ERR_TIMEOUT:
   4048                return osErrorTimeout;
   4049          
   4050              case RTOS_ERR_ABORT:
   4051              case RTOS_ERR_OS_SCHED_LOCKED:
   4052              case RTOS_ERR_WOULD_BLOCK:
   4053              case RTOS_ERR_OS_OBJ_DEL:
   4054              default:
   4055                return osErrorResource;
   4056            }
   4057          
   4058            CORE_ENTER_ATOMIC();
   \                     ??osMessageQueuePut_5: (+1)
   \       0x5E   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x62   0x4680             MOV      R8,R0
   4059            msg_id   = p_msgqueue->msg_head;
   \       0x64   0x6B68             LDR      R0,[R5, #+52]
   \       0x66   0x9003             STR      R0,[SP, #+12]
   4060            msg_size = p_msgqueue->msg_size;
   \       0x68   0xF8D5 0x902C      LDR      R9,[R5, #+44]
   4061            p_msgqueue->msg_head = (p_msgqueue->msg_head + 1) %  p_msgqueue->msg_count;
   \       0x6C   0x6B6A             LDR      R2,[R5, #+52]
   \       0x6E   0x1C52             ADDS     R2,R2,#+1
   \       0x70   0x6AA8             LDR      R0,[R5, #+40]
   \       0x72   0xFBB2 0xF1F0      UDIV     R1,R2,R0
   \       0x76   0xFB00 0x2211      MLS      R2,R0,R1,R2
   \       0x7A   0x636A             STR      R2,[R5, #+52]
   4062            memcpy(&p_msgqueue->buf[msg_id * msg_size], msg_ptr, msg_size);
   \       0x7C   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0x80   0x9600             STR      R6,[SP, #+0]
   \       0x82   0x6A29             LDR      R1,[R5, #+32]
   \       0x84   0x9803             LDR      R0,[SP, #+12]
   \       0x86   0xFB09 0xF000      MUL      R0,R9,R0
   \       0x8A   0xEB01 0x0B00      ADD      R11,R1,R0
   \       0x8E   0x9A02             LDR      R2,[SP, #+8]
   \       0x90   0x9900             LDR      R1,[SP, #+0]
   \       0x92   0x4658             MOV      R0,R11
   \       0x94   0x.... 0x....      BL       __aeabi_memcpy
   4063            p_msgqueue->msg_queued++;
   \       0x98   0x6B28             LDR      R0,[R5, #+48]
   \       0x9A   0x1C40             ADDS     R0,R0,#+1
   \       0x9C   0x6328             STR      R0,[R5, #+48]
   4064            CORE_EXIT_ATOMIC();
   \       0x9E   0x4640             MOV      R0,R8
   \       0xA0   0x.... 0x....      BL       CORE_ExitAtomic
   4065          
   4066            OSSemPost(&p_msgqueue->sem_get, OS_OPT_POST_1, &err);
   \       0xA4   0xAA04             ADD      R2,SP,#+16
   \       0xA6   0x2100             MOVS     R1,#+0
   \       0xA8   0xF115 0x0010      ADDS     R0,R5,#+16
   \       0xAC   0x.... 0x....      BL       OSSemPost
   4067          
   4068            switch (RTOS_ERR_CODE_GET(err)) {
   \       0xB0   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD108             BNE.N    ??osMessageQueuePut_8
   \       0xB8   0xE005             B.N      ??osMessageQueuePut_9
   \                     ??osMessageQueuePut_6: (+1)
   \       0xBA   0xF07F 0x0001      MVNS     R0,#+1
   \       0xBE   0xE006             B.N      ??osMessageQueuePut_1
   \                     ??osMessageQueuePut_7: (+1)
   \       0xC0   0xF07F 0x0002      MVNS     R0,#+2
   \       0xC4   0xE003             B.N      ??osMessageQueuePut_1
   4069              case RTOS_ERR_NONE:
   4070                return osOK;
   \                     ??osMessageQueuePut_9: (+1)
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0xE001             B.N      ??osMessageQueuePut_1
   4071          
   4072              case RTOS_ERR_WOULD_OVF:
   4073              default:
   4074                return osErrorResource;
   \                     ??osMessageQueuePut_8: (+1)
   \       0xCA   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osMessageQueuePut_1: (+1)
   \       0xCE   0xB009             ADD      SP,SP,#+36
   \       0xD0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4075            }
   4076          #else
   4077            (void)mq_id;
   4078            (void)msg_ptr;
   4079            (void)msg_prio;
   4080            (void)timeout;
   4081            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, osError);
   4082            return osError;
   4083          #endif
   4084          }
   4085          
   4086          /*
   4087           ****************************************************************************************************
   4088           *                                          osMessageQueueGet()
   4089           *
   4090           * Description: The function 'osMessageQueueGet()' retrieves a message from the message queue specified
   4091           *              by the parameter 'mq_id' and saves it to the buffer pointed to by the parameter 'msg_ptr'.
   4092           *
   4093           *              The message priority is stored to parameter 'msg_prio' if not token{NULL}.
   4094           *
   4095           *              The parameter 'timeout' specifies how long the system waits to retrieve the message from
   4096           *              the queue.  While the system waits, the thread that is calling this function is put into
   4097           *              the BLOCKED state.  The parameter 'timeout' can have the following values:
   4098           *
   4099           *
   4100           *
   4101           *
   4102           * Arguments  : mq_id            the message queue ID
   4103           *
   4104           *              msg_ptr          a pointer to where the message will be placed
   4105           *
   4106           *              msg_prio         a pointer to where the message priority will be deposited to.
   4107           *
   4108           *              timeout          when timeout is 0, the function returns instantly (i.e. try semantics).
   4109           *
   4110           *                               when timeout is set to 'osWaitForever' the function will wait for an infinite
   4111           *                                   time until the message is retrieved (i.e. wait semantics).
   4112           *
   4113           *                               all other values specify a time in kernel ticks for a timeout
   4114           *                                   (i.e. timed-wait semantics).
   4115           *
   4116           * Returns    : osOK             the message has been retrieved from the queue.
   4117           *              osErrorTimeout   the message could not be retrieved from the queue in the given time
   4118           *                                   (timed-wait semantics).
   4119           *              osErrorResource  nothing to get from the queue (try semantics).
   4120           *              osErrorParameter parameter 'mq_id' is NULL or invalid, non-zero timeout specified in an ISR.
   4121           ****************************************************************************************************
   4122           */

   \                                 In section .text, align 2, keep-with-next
   4123          osStatus_t osMessageQueueGet(osMessageQueueId_t mq_id,
   4124                                       void *msg_ptr,
   4125                                       uint8_t *msg_prio,
   4126                                       uint32_t timeout)
   4127          {
   \                     osMessageQueueGet: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000F             MOVS     R7,R1
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0x001D             MOVS     R5,R3
   4128          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   4129            osMessageQueue_t   *p_msgqueue;
   4130            CPU_TS              ts;
   4131            RTOS_ERR            err;
   4132            uint32_t            msg_id, msg_size;
   4133            CORE_DECLARE_IRQ_STATE;
   4134          
   4135            (void) msg_prio;
   4136          
   4137            p_msgqueue = (osMessageQueue_t *)mq_id;
   \        0xE   0x4656             MOV      R6,R10
   4138            if (p_msgqueue == (osMessageQueue_t *)0) {
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD102             BNE.N    ??osMessageQueueGet_0
   4139              return osErrorParameter;
   \       0x14   0xF07F 0x0003      MVNS     R0,#+3
   \       0x18   0xE05E             B.N      ??osMessageQueueGet_1
   4140            }
   4141          
   4142            if (timeout == 0u) {
   \                     ??osMessageQueueGet_0: (+1)
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD10A             BNE.N    ??osMessageQueueGet_2
   4143              OSSemPend(&p_msgqueue->sem_get, (OS_TICK)0u, OS_OPT_PEND_NON_BLOCKING, &ts, &err);
   \       0x1E   0xA804             ADD      R0,SP,#+16
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0xAB01             ADD      R3,SP,#+4
   \       0x24   0xF44F 0x4200      MOV      R2,#+32768
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0xF116 0x0010      ADDS     R0,R6,#+16
   \       0x2E   0x.... 0x....      BL       OSSemPend
   \       0x32   0xE00F             B.N      ??osMessageQueueGet_3
   4144            } else {
   4145              if (CORE_InIrqContext() == true) {
   \                     ??osMessageQueueGet_2: (+1)
   \       0x34   0x.... 0x....      BL       CORE_InIrqContext
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD102             BNE.N    ??osMessageQueueGet_4
   4146                return osErrorParameter;
   \       0x3C   0xF07F 0x0003      MVNS     R0,#+3
   \       0x40   0xE04A             B.N      ??osMessageQueueGet_1
   4147              } else {
   4148                OSSemPend(&p_msgqueue->sem_get, (OS_TICK)timeout, OS_OPT_PEND_BLOCKING, &ts, &err);
   \                     ??osMessageQueueGet_4: (+1)
   \       0x42   0xA804             ADD      R0,SP,#+16
   \       0x44   0x9000             STR      R0,[SP, #+0]
   \       0x46   0xAB01             ADD      R3,SP,#+4
   \       0x48   0x2200             MOVS     R2,#+0
   \       0x4A   0x0029             MOVS     R1,R5
   \       0x4C   0xF116 0x0010      ADDS     R0,R6,#+16
   \       0x50   0x.... 0x....      BL       OSSemPend
   4149              }
   4150            }
   4151          
   4152            switch (RTOS_ERR_CODE_GET(err)) {
   \                     ??osMessageQueueGet_3: (+1)
   \       0x54   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD002             BEQ.N    ??osMessageQueueGet_5
   \       0x5C   0x2822             CMP      R0,#+34
   \       0x5E   0xD023             BEQ.N    ??osMessageQueueGet_6
   \       0x60   0xE025             B.N      ??osMessageQueueGet_7
   4153              case RTOS_ERR_NONE:
   4154                break;
   4155          
   4156              case RTOS_ERR_TIMEOUT:
   4157                return osErrorTimeout;
   4158          
   4159              case RTOS_ERR_ABORT:
   4160              case RTOS_ERR_OS_SCHED_LOCKED:
   4161              case RTOS_ERR_WOULD_BLOCK:
   4162              case RTOS_ERR_OS_OBJ_DEL:
   4163              default:
   4164                return osErrorResource;
   4165            }
   4166          
   4167            CORE_ENTER_ATOMIC();
   \                     ??osMessageQueueGet_5: (+1)
   \       0x62   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x66   0x4680             MOV      R8,R0
   4168            msg_id   = p_msgqueue->msg_tail;
   \       0x68   0x6BB0             LDR      R0,[R6, #+56]
   \       0x6A   0x9003             STR      R0,[SP, #+12]
   4169            msg_size = p_msgqueue->msg_size;
   \       0x6C   0xF8D6 0x902C      LDR      R9,[R6, #+44]
   4170            p_msgqueue->msg_tail = (p_msgqueue->msg_tail + 1) %  p_msgqueue->msg_count;
   \       0x70   0x6BB2             LDR      R2,[R6, #+56]
   \       0x72   0x1C52             ADDS     R2,R2,#+1
   \       0x74   0x6AB0             LDR      R0,[R6, #+40]
   \       0x76   0xFBB2 0xF1F0      UDIV     R1,R2,R0
   \       0x7A   0xFB00 0x2211      MLS      R2,R0,R1,R2
   \       0x7E   0x63B2             STR      R2,[R6, #+56]
   4171            memcpy(msg_ptr, &p_msgqueue->buf[msg_id * msg_size], msg_size);
   \       0x80   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0x84   0x6A31             LDR      R1,[R6, #+32]
   \       0x86   0x9803             LDR      R0,[SP, #+12]
   \       0x88   0xFB09 0xF000      MUL      R0,R9,R0
   \       0x8C   0x4408             ADD      R0,R1,R0
   \       0x8E   0x9000             STR      R0,[SP, #+0]
   \       0x90   0x46BB             MOV      R11,R7
   \       0x92   0x9A02             LDR      R2,[SP, #+8]
   \       0x94   0x9900             LDR      R1,[SP, #+0]
   \       0x96   0x4658             MOV      R0,R11
   \       0x98   0x.... 0x....      BL       __aeabi_memcpy
   4172            p_msgqueue->msg_queued--;
   \       0x9C   0x6B30             LDR      R0,[R6, #+48]
   \       0x9E   0x1E40             SUBS     R0,R0,#+1
   \       0xA0   0x6330             STR      R0,[R6, #+48]
   4173            if (msg_prio != NULL) {
   \       0xA2   0x2C00             CMP      R4,#+0
   \       0xA4   0xD008             BEQ.N    ??osMessageQueueGet_8
   \       0xA6   0xE005             B.N      ??osMessageQueueGet_9
   \                     ??osMessageQueueGet_6: (+1)
   \       0xA8   0xF07F 0x0001      MVNS     R0,#+1
   \       0xAC   0xE014             B.N      ??osMessageQueueGet_1
   \                     ??osMessageQueueGet_7: (+1)
   \       0xAE   0xF07F 0x0002      MVNS     R0,#+2
   \       0xB2   0xE011             B.N      ??osMessageQueueGet_1
   4174              *msg_prio = 0;
   \                     ??osMessageQueueGet_9: (+1)
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x7020             STRB     R0,[R4, #+0]
   4175            }
   4176            CORE_EXIT_ATOMIC();
   \                     ??osMessageQueueGet_8: (+1)
   \       0xB8   0x4640             MOV      R0,R8
   \       0xBA   0x.... 0x....      BL       CORE_ExitAtomic
   4177          
   4178            OSSemPost(&p_msgqueue->sem_put, OS_OPT_POST_1, &err);
   \       0xBE   0xAA04             ADD      R2,SP,#+16
   \       0xC0   0x2100             MOVS     R1,#+0
   \       0xC2   0x0030             MOVS     R0,R6
   \       0xC4   0x.... 0x....      BL       OSSemPost
   4179          
   4180            switch (RTOS_ERR_CODE_GET(err)) {
   \       0xC8   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD101             BNE.N    ??osMessageQueueGet_10
   4181              case RTOS_ERR_NONE:
   4182                return osOK;
   \       0xD0   0x2000             MOVS     R0,#+0
   \       0xD2   0xE001             B.N      ??osMessageQueueGet_1
   4183          
   4184              case RTOS_ERR_WOULD_OVF:
   4185              default:
   4186                return osErrorResource;
   \                     ??osMessageQueueGet_10: (+1)
   \       0xD4   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osMessageQueueGet_1: (+1)
   \       0xD8   0xB009             ADD      SP,SP,#+36
   \       0xDA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   4187            }
   4188          #else
   4189            (void)mq_id;
   4190            (void)msg_ptr;
   4191            (void)msg_prio;
   4192            (void)timeout;
   4193            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, osError);
   4194            return osError;
   4195          #endif
   4196          }
   4197          
   4198          /*
   4199           ****************************************************************************************************
   4200           *                                      osMessageQueueGetCapacity()
   4201           *
   4202           * Description: The function 'osMessageQueueGetCapacity()' returns the maximum number of messages in
   4203           *              the message queue object specified by parameter 'mq_id' or 0 in case of an error.
   4204           *
   4205           * Arguments  : mq_id       is the message queue ID returned by 'osMessageQueueNew()'
   4206           *
   4207           * Returns    : The maximum number of messages
   4208           *              0             upon error
   4209           ****************************************************************************************************
   4210           */

   \                                 In section .text, align 2, keep-with-next
   4211          uint32_t osMessageQueueGetCapacity(osMessageQueueId_t mq_id)
   4212          {
   \                     osMessageQueueGetCapacity: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   4213          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   4214            osMessageQueue_t   *p_msgqueue;
   4215          
   4216            p_msgqueue = (osMessageQueue_t *)mq_id;
   \        0x2   0x0011             MOVS     R1,R2
   4217            if (p_msgqueue == (osMessageQueue_t *)0) {
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??osMessageQueueGetCapacity_0
   4218              return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE000             B.N      ??osMessageQueueGetCapacity_1
   4219            }
   4220          
   4221            return p_msgqueue->msg_count;
   \                     ??osMessageQueueGetCapacity_0: (+1)
   \        0xC   0x6A88             LDR      R0,[R1, #+40]
   \                     ??osMessageQueueGetCapacity_1: (+1)
   \        0xE   0x4770             BX       LR
   4222          #else
   4223            (void)mq_id;
   4224            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, 0);
   4225            return 0;
   4226          #endif
   4227          }
   4228          
   4229          /*
   4230           ****************************************************************************************************
   4231           *                                     osMessageQueueGetMsgSize()
   4232           *
   4233           * Description: The function 'osMessageQueueGetMsgSize()' returns the maximum message size in bytes
   4234           *              for the message queue object specified by parameter 'mq_id' or 0 in case of an error.
   4235           *
   4236           * Arguments  : mq_id       is the message queue ID returned by 'osMessageQueueNew()'
   4237           *
   4238           * Returns    : The maximum message size (in bytes)
   4239           *              0             upon error
   4240           ****************************************************************************************************
   4241           */

   \                                 In section .text, align 2, keep-with-next
   4242          uint32_t osMessageQueueGetMsgSize(osMessageQueueId_t mq_id)
   4243          {
   \                     osMessageQueueGetMsgSize: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   4244          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   4245            osMessageQueue_t   *p_msgqueue;
   4246          
   4247            p_msgqueue = (osMessageQueue_t *)mq_id;
   \        0x2   0x0011             MOVS     R1,R2
   4248            if (p_msgqueue == (osMessageQueue_t *)0) {
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??osMessageQueueGetMsgSize_0
   4249              return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE000             B.N      ??osMessageQueueGetMsgSize_1
   4250            }
   4251          
   4252            return p_msgqueue->msg_size;
   \                     ??osMessageQueueGetMsgSize_0: (+1)
   \        0xC   0x6AC8             LDR      R0,[R1, #+44]
   \                     ??osMessageQueueGetMsgSize_1: (+1)
   \        0xE   0x4770             BX       LR
   4253          #else
   4254            (void)mq_id;
   4255            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, 0);
   4256            return 0;
   4257          #endif
   4258          }
   4259          
   4260          /*
   4261           ****************************************************************************************************
   4262           *                                     osMessageQueueGetCount()
   4263           *
   4264           * Description: The function 'osMessageQueueGetCount()' returns the number of queued messages in the
   4265           *              message queue object specified by parameter 'mq_id' or 0 in case of an error.
   4266           *
   4267           * Arguments  : mq_id       is the message queue ID returned by 'osMessageQueueNew()'
   4268           *
   4269           * Returns    : The number of messages in the queue
   4270           *              0             upon error
   4271           ****************************************************************************************************
   4272           */

   \                                 In section .text, align 2, keep-with-next
   4273          uint32_t osMessageQueueGetCount(osMessageQueueId_t mq_id)
   4274          {
   \                     osMessageQueueGetCount: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   4275          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   4276            osMessageQueue_t   *p_msgqueue;
   4277          
   4278            p_msgqueue = (osMessageQueue_t *)mq_id;
   \        0x2   0x0011             MOVS     R1,R2
   4279            if (p_msgqueue == (osMessageQueue_t *)0) {
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??osMessageQueueGetCount_0
   4280              return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE000             B.N      ??osMessageQueueGetCount_1
   4281            }
   4282          
   4283            return p_msgqueue->msg_queued;
   \                     ??osMessageQueueGetCount_0: (+1)
   \        0xC   0x6B08             LDR      R0,[R1, #+48]
   \                     ??osMessageQueueGetCount_1: (+1)
   \        0xE   0x4770             BX       LR
   4284          #else
   4285            (void)mq_id;
   4286            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, 0);
   4287            return 0;
   4288          #endif
   4289          }
   4290          
   4291          /*
   4292           ****************************************************************************************************
   4293           *                                     osMessageQueueGetSpace()
   4294           *
   4295           * Description: The function 'osMessageQueueGetSpace()' returns the number available slots for messages
   4296           *              in the message queue object specified by parameter 'mq_id' or 0 in case of an error.
   4297           *
   4298           * Arguments  : mq_id       is the message queue ID returned by 'osMessageQueueNew()'
   4299           *
   4300           * Returns    : The number of available slots in the queue
   4301           *              0             upon error
   4302           ****************************************************************************************************
   4303           */

   \                                 In section .text, align 2, keep-with-next
   4304          uint32_t osMessageQueueGetSpace(osMessageQueueId_t mq_id)
   4305          {
   \                     osMessageQueueGetSpace: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   4306          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   4307            osMessageQueue_t   *p_msgqueue;
   4308          
   4309            p_msgqueue = (osMessageQueue_t *)mq_id;
   \        0x2   0x0011             MOVS     R1,R2
   4310            if (p_msgqueue == (osMessageQueue_t *)0) {
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??osMessageQueueGetSpace_0
   4311              return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE002             B.N      ??osMessageQueueGetSpace_1
   4312            }
   4313          
   4314            return p_msgqueue->msg_count - p_msgqueue->msg_queued;
   \                     ??osMessageQueueGetSpace_0: (+1)
   \        0xC   0x6A88             LDR      R0,[R1, #+40]
   \        0xE   0x6B09             LDR      R1,[R1, #+48]
   \       0x10   0x1A40             SUBS     R0,R0,R1
   \                     ??osMessageQueueGetSpace_1: (+1)
   \       0x12   0x4770             BX       LR
   4315          #else
   4316            (void)mq_id;
   4317            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, 0);
   4318            return 0;
   4319          #endif
   4320          }
   4321          
   4322          /*
   4323           ****************************************************************************************************
   4324           *                                       osMessageQueueReset()
   4325           *
   4326           * Description: The function 'osMessageQueueReset()' resets the message queue specified by the parameter
   4327           *              'mq_id'.
   4328           *
   4329           * Arguments  : mq_id             is the message queue ID returned by 'osMessageQueueNew()'
   4330           *
   4331           * Returns    : osOK              the queue has been reset
   4332           *              osErrorParameter  parameter 'mq_id' is NULL or invalid.
   4333           *              osErrorResource   the message queue is in an invalid state.
   4334           *              osErrorISR        'osMessageQueueReset()' cannot be called from interrupt service routines.
   4335           ****************************************************************************************************
   4336           */

   \                                 In section .text, align 2, keep-with-next
   4337          osStatus_t osMessageQueueReset(osMessageQueueId_t mq_id)
   4338          {
   \                     osMessageQueueReset: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x0005             MOVS     R5,R0
   4339          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   4340            osMessageQueue_t   *p_msgqueue;
   4341            CPU_TS              ts;
   4342            RTOS_ERR            err;
   4343            CORE_DECLARE_IRQ_STATE;
   4344          
   4345            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osMessageQueueReset_0
   4346              return osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE037             B.N      ??osMessageQueueReset_1
   4347            }
   4348          
   4349            p_msgqueue = (osMessageQueue_t *)mq_id;
   \                     ??osMessageQueueReset_0: (+1)
   \       0x14   0x002C             MOVS     R4,R5
   4350            if (p_msgqueue == (osMessageQueue_t *)0) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osMessageQueueReset_2
   4351              return osErrorParameter;
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE031             B.N      ??osMessageQueueReset_1
   4352            }
   4353          
   4354            while (p_msgqueue->msg_queued != 0) {
   \                     ??osMessageQueueReset_2: (+1)
   \       0x20   0x6B20             LDR      R0,[R4, #+48]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD026             BEQ.N    ??osMessageQueueReset_3
   4355              OSSemPend(&p_msgqueue->sem_get, (OS_TICK)0u, OS_OPT_PEND_BLOCKING, &ts, &err);
   \       0x26   0xA802             ADD      R0,SP,#+8
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0xAB01             ADD      R3,SP,#+4
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0x34   0x.... 0x....      BL       OSSemPend
   4356              if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x38   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD119             BNE.N    ??osMessageQueueReset_3
   4357                break;
   4358              }
   4359              CORE_ENTER_ATOMIC();
   \                     ??osMessageQueueReset_4: (+1)
   \       0x40   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x44   0x0006             MOVS     R6,R0
   4360              p_msgqueue->msg_queued--;
   \       0x46   0x6B20             LDR      R0,[R4, #+48]
   \       0x48   0x1E40             SUBS     R0,R0,#+1
   \       0x4A   0x6320             STR      R0,[R4, #+48]
   4361              p_msgqueue->msg_tail = (p_msgqueue->msg_tail + 1) % p_msgqueue->msg_count;
   \       0x4C   0x6BA2             LDR      R2,[R4, #+56]
   \       0x4E   0x1C52             ADDS     R2,R2,#+1
   \       0x50   0x6AA0             LDR      R0,[R4, #+40]
   \       0x52   0xFBB2 0xF1F0      UDIV     R1,R2,R0
   \       0x56   0xFB00 0x2211      MLS      R2,R0,R1,R2
   \       0x5A   0x63A2             STR      R2,[R4, #+56]
   4362              CORE_EXIT_ATOMIC();
   \       0x5C   0x0030             MOVS     R0,R6
   \       0x5E   0x.... 0x....      BL       CORE_ExitAtomic
   4363              OSSemPost(&p_msgqueue->sem_put, OS_OPT_POST_1, &err);
   \       0x62   0xAA02             ADD      R2,SP,#+8
   \       0x64   0x2100             MOVS     R1,#+0
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x.... 0x....      BL       OSSemPost
   4364              if (RTOS_ERR_CODE_GET(err) != RTOS_ERR_NONE) {
   \       0x6C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD0D5             BEQ.N    ??osMessageQueueReset_2
   4365                break;
   4366              }
   4367            }
   4368          
   4369            switch (RTOS_ERR_CODE_GET(err)) {
   \                     ??osMessageQueueReset_3: (+1)
   \       0x74   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD101             BNE.N    ??osMessageQueueReset_5
   4370              case RTOS_ERR_NONE:
   4371                return osOK;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xE001             B.N      ??osMessageQueueReset_1
   4372          
   4373              default:
   4374                return osErrorResource;
   \                     ??osMessageQueueReset_5: (+1)
   \       0x80   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osMessageQueueReset_1: (+1)
   \       0x84   0xB006             ADD      SP,SP,#+24
   \       0x86   0xBD70             POP      {R4-R6,PC}
   4375            }
   4376          #else
   4377            (void)mq_id;
   4378            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, osError);
   4379            return osError;
   4380          #endif
   4381          }
   4382          
   4383          /*
   4384           ****************************************************************************************************
   4385           *                                       osMessageQueueDelete()
   4386           *
   4387           * Description: The function 'osMessageQueueDelete() deletes a message queue object specified by
   4388           *              parameter 'mq_id'.  It releases internal memory obtained for message queue handling.
   4389           *
   4390           *              After this call, the 'mq_id' is no longer valid and cannot be used.
   4391           *
   4392           *              The message queue may be created again using the function 'osMessageQueueNew()'.
   4393           *
   4394           * Arguments  : mq_id             is the message queue ID returned by 'osMessageQueueNew()'
   4395           *
   4396           * Returns    : osOK              the message queue object has been deleted.
   4397           *              osErrorParameter  parameter 'mq_id' is NULL or invalid.
   4398           *              osErrorResource   the message queue is in an invalid state.
   4399           *              osErrorISR        'osMessageQueueDelete()' cannot be called from interrupt service routines.
   4400           ****************************************************************************************************
   4401           */

   \                                 In section .text, align 2, keep-with-next
   4402          osStatus_t osMessageQueueDelete(osMessageQueueId_t mq_id)
   4403          {
   \                     osMessageQueueDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   4404          #if (OS_CFG_SEM_EN == DEF_ENABLED)
   4405            osMessageQueue_t  *p_msgqueue;
   4406            RTOS_ERR           err;
   4407          
   4408            if (CORE_InIrqContext() == true) {
   \        0x6   0x.... 0x....      BL       CORE_InIrqContext
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD102             BNE.N    ??osMessageQueueDelete_0
   4409              return osErrorISR;
   \        0xE   0xF07F 0x0005      MVNS     R0,#+5
   \       0x12   0xE026             B.N      ??osMessageQueueDelete_1
   4410            }
   4411          
   4412            p_msgqueue = (osMessageQueue_t *)mq_id;
   \                     ??osMessageQueueDelete_0: (+1)
   \       0x14   0x002C             MOVS     R4,R5
   4413            if (p_msgqueue == (osMessageQueue_t *)0) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osMessageQueueDelete_2
   4414              return osErrorParameter;
   \       0x1A   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1E   0xE020             B.N      ??osMessageQueueDelete_1
   4415            }
   4416          
   4417            OSSemDel(&p_msgqueue->sem_put, OS_OPT_DEL_ALWAYS, &err);
   \                     ??osMessageQueueDelete_2: (+1)
   \       0x20   0x466A             MOV      R2,SP
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       OSSemDel
   4418            OSSemDel(&p_msgqueue->sem_get, OS_OPT_DEL_ALWAYS, &err);
   \       0x2A   0x466A             MOV      R2,SP
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0x32   0x.... 0x....      BL       OSSemDel
   4419          
   4420            switch (RTOS_ERR_CODE_GET(err)) {
   \       0x36   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD10F             BNE.N    ??osMessageQueueDelete_3
   4421              case RTOS_ERR_NONE:
   4422                if (p_msgqueue->buf_dyn_alloc == DEF_TRUE) {
   \       0x3E   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD102             BNE.N    ??osMessageQueueDelete_4
   4423                  free(p_msgqueue->buf);
   \       0x46   0x6A20             LDR      R0,[R4, #+32]
   \       0x48   0x.... 0x....      BL       free
   4424                }
   4425                if (p_msgqueue->obj_dyn_alloc == DEF_TRUE) {
   \                     ??osMessageQueueDelete_4: (+1)
   \       0x4C   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD102             BNE.N    ??osMessageQueueDelete_5
   4426                  free(p_msgqueue);
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       free
   4427                }
   4428                return osOK;
   \                     ??osMessageQueueDelete_5: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE001             B.N      ??osMessageQueueDelete_1
   4429          
   4430              default:
   4431                return osErrorResource;
   \                     ??osMessageQueueDelete_3: (+1)
   \       0x5E   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??osMessageQueueDelete_1: (+1)
   \       0x62   0xB005             ADD      SP,SP,#+20
   \       0x64   0xBD30             POP      {R4,R5,PC}
   4432            }
   4433          #else
   4434            (void)mq_id;
   4435            RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_SUPPORTED, osError);
   4436            return osError;
   4437          #endif
   4438          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0xFFFF'D8F0        DC32     0xffffd8f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x0098'9680        DC32     0x989680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     OSInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x7FFF'FFF1        DC32     0x7ffffff1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \        0x0   0x....'....        DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x4D 0x69          DC8 "MicriumOS"
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x4F    
   \              0x53 0x00
   \        0xA                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x45 0x76          DC8 "EventFlags"
   \              0x65 0x6E    
   \              0x74 0x46    
   \              0x6C 0x61    
   \              0x67 0x73    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x4D 0x75          DC8 "Mutex"
   \              0x74 0x65    
   \              0x78 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x53 0x65          DC8 "Semaphore"
   \              0x6D 0x61    
   \              0x70 0x68    
   \              0x6F 0x72    
   \              0x65 0x00
   \        0xA                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x54 0x61          DC8 "TaskName?"
   \              0x73 0x6B    
   \              0x4E 0x61    
   \              0x6D 0x65    
   \              0x3F 0x00
   \        0xA                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x54 0x68          DC8 "ThreadFlags"
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x46 0x6C    
   \              0x61 0x67    
   \              0x73 0x00

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x51 0x75          DC8 "QueueName?"
   \              0x65 0x75    
   \              0x65 0x4E    
   \              0x61 0x6D    
   \              0x65 0x3F    
   \              0x00
   \        0xB                      DS8 1

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   osDelay
        24   -> CORE_InIrqContext
        24   -> OSTimeDly
      32   osDelayUntil
        32   -> CORE_InIrqContext
        32   -> OSTimeDly
        32   -> OSTimeGet
      40   osEventFlagsClear
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> OSFlagPost
      32   osEventFlagsDelete
        32   -> CORE_InIrqContext
        32   -> OSFlagDel
        32   -> free
       0   osEventFlagsGet
       8   osEventFlagsGetName
         8   -> CPU_SW_Exception
      32   osEventFlagsNew
        32   -> CORE_InIrqContext
        32   -> OSFlagCreate
        32   -> free
        32   -> malloc
      56   osEventFlagsSet
        56   -> CORE_EnterAtomic
        56   -> CORE_ExitAtomic
        56   -> OSFlagPost
      72   osEventFlagsWait
        72   -> CORE_EnterAtomic
        72   -> CORE_ExitAtomic
        72   -> CORE_InIrqContext
        72   -> OSFlagPend
      48   osKernelGetInfo
        48   -> OSVersion
        48   -> strcpy
       0   osKernelGetState
       8   osKernelGetSysTimerCount
         8   -> sl_sleeptimer_get_tick_count
       8   osKernelGetSysTimerFreq
         8   -> sl_sleeptimer_get_timer_frequency
      24   osKernelGetTickCount
        24   -> OSTimeGet
      24   osKernelGetTickFreq
        24   -> OSTimeTickRateHzGet
      24   osKernelInitialize
        24   -> CORE_InIrqContext
        24   -> OSInit
      24   osKernelLock
        24   -> CORE_InIrqContext
        24   -> OSSchedLock
      24   osKernelRestoreLock
        24   -> CORE_InIrqContext
        24   -> OSSchedLock
        24   -> OSSchedUnlock
       8   osKernelResume
         8   -> CORE_InIrqContext
      24   osKernelStart
        24   -> CORE_InIrqContext
        24   -> OSStart
       8   osKernelSuspend
         8   -> CORE_InIrqContext
      24   osKernelUnlock
        24   -> CORE_InIrqContext
        24   -> OSSchedUnlock
      16   osMemoryPoolAlloc
        16   -> CPU_SW_Exception
       8   osMemoryPoolDelete
         8   -> CPU_SW_Exception
      16   osMemoryPoolFree
        16   -> CPU_SW_Exception
       8   osMemoryPoolGetBlockSize
         8   -> CPU_SW_Exception
       8   osMemoryPoolGetCapacity
         8   -> CPU_SW_Exception
       8   osMemoryPoolGetCount
         8   -> CPU_SW_Exception
       8   osMemoryPoolGetName
         8   -> CPU_SW_Exception
       8   osMemoryPoolGetSpace
         8   -> CPU_SW_Exception
      16   osMemoryPoolNew
        16   -> CPU_SW_Exception
      32   osMessageQueueDelete
        32   -> CORE_InIrqContext
        32   -> OSSemDel
        32   -> free
      72   osMessageQueueGet
        72   -> CORE_EnterAtomic
        72   -> CORE_ExitAtomic
        72   -> CORE_InIrqContext
        72   -> OSSemPend
        72   -> OSSemPost
        72   -> __aeabi_memcpy
       0   osMessageQueueGetCapacity
       0   osMessageQueueGetCount
       0   osMessageQueueGetMsgSize
       8   osMessageQueueGetName
         8   -> CPU_SW_Exception
       0   osMessageQueueGetSpace
      40   osMessageQueueNew
        40   -> CORE_InIrqContext
        40   -> OSSemCreate
        40   -> free
        40   -> malloc
      72   osMessageQueuePut
        72   -> CORE_EnterAtomic
        72   -> CORE_ExitAtomic
        72   -> CORE_InIrqContext
        72   -> OSSemPend
        72   -> OSSemPost
        72   -> __aeabi_memcpy
      40   osMessageQueueReset
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> CORE_InIrqContext
        40   -> OSSemPend
        40   -> OSSemPost
      48   osMutexAcquire
        48   -> CORE_InIrqContext
        48   -> OSMutexPend
      32   osMutexDelete
        32   -> CORE_InIrqContext
        32   -> OSMutexDel
        32   -> free
       8   osMutexGetName
         8   -> CPU_SW_Exception
      24   osMutexGetOwner
        24   -> CORE_EnterCritical
        24   -> CORE_ExitCritical
      32   osMutexNew
        32   -> CORE_InIrqContext
        32   -> OSMutexCreate
        32   -> free
        32   -> malloc
      32   osMutexRelease
        32   -> CORE_InIrqContext
        32   -> OSMutexPost
      40   osSemaphoreAcquire
        40   -> CORE_InIrqContext
        40   -> OSSemPend
      32   osSemaphoreDelete
        32   -> CORE_InIrqContext
        32   -> OSSemDel
        32   -> free
      24   osSemaphoreGetCount
        24   -> CORE_EnterCritical
        24   -> CORE_ExitCritical
       8   osSemaphoreGetName
         8   -> CPU_SW_Exception
      40   osSemaphoreNew
        40   -> CORE_InIrqContext
        40   -> OSSemCreate
        40   -> free
        40   -> malloc
      32   osSemaphoreRelease
        32   -> OSSemPost
       8   osThreadDetach
         8   -> CORE_InIrqContext
         8   -> CPU_SW_Exception
      16   osThreadEnumerate
        16   -> CPU_SW_Exception
      24   osThreadExit
        24   -> CORE_InIrqContext
        24   -> OSTaskDel
      40   osThreadFlagsClear
        40   -> CORE_InIrqContext
        40   -> OSFlagPost
       8   osThreadFlagsGet
         8   -> CORE_InIrqContext
      56   osThreadFlagsSet
        56   -> CORE_EnterAtomic
        56   -> CORE_ExitAtomic
        56   -> OSFlagPost
      64   osThreadFlagsWait
        64   -> CORE_InIrqContext
        64   -> OSFlagPend
       8   osThreadGetCount
         8   -> CORE_InIrqContext
       0   osThreadGetId
       8   osThreadGetName
         8   -> CPU_SW_Exception
       8   osThreadGetPriority
         8   -> CORE_InIrqContext
      24   osThreadGetStackSize
        24   -> CORE_EnterCritical
        24   -> CORE_ExitCritical
        24   -> CORE_InIrqContext
      24   osThreadGetStackSpace
        24   -> CORE_EnterCritical
        24   -> CORE_ExitCritical
        24   -> CORE_InIrqContext
       8   osThreadGetState
         8   -> CORE_InIrqContext
       8   osThreadJoin
         8   -> CORE_InIrqContext
         8   -> CPU_SW_Exception
      88   osThreadNew
        88   -> CORE_InIrqContext
        88   -> OSFlagCreate
        88   -> OSTaskCreate
        88   -> free
        88   -> malloc
      32   osThreadResume
        32   -> CORE_InIrqContext
        32   -> OSTaskResume
      40   osThreadSetPriority
        40   -> CORE_InIrqContext
        40   -> OSTaskChangePrio
      32   osThreadSuspend
        32   -> CORE_InIrqContext
        32   -> OSTaskSuspend
      32   osThreadTerminate
        32   -> CORE_InIrqContext
        32   -> OSTaskDel
        32   -> free
       8   osThreadYield
         8   -> CPU_SW_Exception
       8   osTimerDelete
         8   -> CPU_SW_Exception
       8   osTimerGetName
         8   -> CPU_SW_Exception
       8   osTimerIsRunning
         8   -> CPU_SW_Exception
      24   osTimerNew
        24   -> CPU_SW_Exception
      16   osTimerStart
        16   -> CPU_SW_Exception
       8   osTimerStop
         8   -> CPU_SW_Exception


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
      12  ?_0
      12  ?_1
       8  ?_2
      12  ?_3
      12  ?_4
      12  ?_5
      12  ?_6
      48  osDelay
     100  osDelayUntil
      76  osEventFlagsClear
      74  osEventFlagsDelete
      16  osEventFlagsGet
      12  osEventFlagsGetName
     154  osEventFlagsNew
     168  osEventFlagsSet
     250  osEventFlagsWait
     128  osKernelGetInfo
      46  osKernelGetState
       8  osKernelGetSysTimerCount
       8  osKernelGetSysTimerFreq
      12  osKernelGetTickCount
      12  osKernelGetTickFreq
      72  osKernelInitialize
      56  osKernelLock
      60  osKernelRestoreLock
      14  osKernelResume
      46  osKernelStart
      18  osKernelSuspend
      62  osKernelUnlock
      14  osMemoryPoolAlloc
      14  osMemoryPoolDelete
      16  osMemoryPoolFree
      12  osMemoryPoolGetBlockSize
      12  osMemoryPoolGetCapacity
      12  osMemoryPoolGetCount
      12  osMemoryPoolGetName
      12  osMemoryPoolGetSpace
      16  osMemoryPoolNew
     102  osMessageQueueDelete
     222  osMessageQueueGet
      16  osMessageQueueGetCapacity
      16  osMessageQueueGetCount
      16  osMessageQueueGetMsgSize
      12  osMessageQueueGetName
      20  osMessageQueueGetSpace
     484  osMessageQueueNew
     212  osMessageQueuePut
     136  osMessageQueueReset
     124  osMutexAcquire
      74  osMutexDelete
      12  osMutexGetName
      32  osMutexGetOwner
     168  osMutexNew
      66  osMutexRelease
     116  osSemaphoreAcquire
      74  osSemaphoreDelete
      32  osSemaphoreGetCount
      12  osSemaphoreGetName
     166  osSemaphoreNew
      48  osSemaphoreRelease
      38  osThreadDetach
      14  osThreadEnumerate
      20  osThreadExit
      60  osThreadFlagsClear
      30  osThreadFlagsGet
     174  osThreadFlagsSet
     180  osThreadFlagsWait
      22  osThreadGetCount
      20  osThreadGetId
      12  osThreadGetName
      56  osThreadGetPriority
      46  osThreadGetStackSize
      52  osThreadGetStackSpace
      82  osThreadGetState
      38  osThreadJoin
     552  osThreadNew
      60  osThreadResume
     104  osThreadSetPriority
      60  osThreadSuspend
     100  osThreadTerminate
      12  osThreadYield
      14  osTimerDelete
      12  osTimerGetName
      12  osTimerIsRunning
      18  osTimerNew
      16  osTimerStart
      14  osTimerStop

 
    80 bytes in section .rodata
 5'606 bytes in section .text
 
 5'606 bytes of CODE  memory
    80 bytes of CONST memory

Errors: none
Warnings: none
