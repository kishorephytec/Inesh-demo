###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:01
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_sem.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_sem.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_sem.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_sem.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir\os_sem.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_sem.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_sem.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Kernel - Semaphore Management
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                       DEPENDENCIES & AVAIL CHECK(S)
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <rtos_description.h>
     25          
     26          #if (defined(RTOS_MODULE_KERNEL_AVAIL))
     27          
     28          /********************************************************************************************************
     29           ********************************************************************************************************
     30           *                                               INCLUDE FILES
     31           ********************************************************************************************************
     32           *******************************************************************************************************/
     33          
     34          #define  MICRIUM_SOURCE
     35          #include "../include/os.h"
     36          #include "os_priv.h"
     37          
     38          #include  <em_core.h>
     39          
     40          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     41          const CPU_CHAR *os_sem__c = "$Id: $";
     42          #endif
     43          
     44          /********************************************************************************************************
     45           ********************************************************************************************************
     46           *                                           GLOBAL FUNCTIONS
     47           ********************************************************************************************************
     48           *******************************************************************************************************/
     49          
     50          #if (OS_CFG_SEM_EN == DEF_ENABLED)
     51          /****************************************************************************************************//**
     52           *                                               OSSemCreate()
     53           *
     54           * @brief    Creates a semaphore.
     55           *
     56           * @param    p_sem   Pointer to the semaphore to initialize. Your application is responsible
     57           *                   for allocating storage for the semaphore.
     58           *
     59           * @param    p_name  Pointer to the name to assign to the semaphore.
     60           *
     61           * @param    cnt     The initial value for the semaphore.
     62           *                   If used to share resources, you should initialize to the number of resources
     63           *                   available.
     64           *                   If used to signal the occurrence of event(s), you should initialize to 0.
     65           *
     66           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
     67           *                   from this function:
     68           *                       - RTOS_ERR_NONE
     69           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
     70           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     71          void OSSemCreate(OS_SEM     *p_sem,
     72                           CPU_CHAR   *p_name,
     73                           OS_SEM_CTR cnt,
     74                           RTOS_ERR   *p_err)
     75          {
   \                     OSSemCreate: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0016             MOVS     R6,R2
   \        0x6   0x001D             MOVS     R5,R3
     76            CORE_DECLARE_IRQ_STATE;
     77          
     78            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD101             BNE.N    ??OSSemCreate_0
   \        0xC   0x.... 0x....      BL       CPU_SW_Exception
     79          
     80          #ifdef OS_SAFETY_CRITICAL_IEC61508
     81            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     82              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
     83              return;
     84            }
     85          #endif
     86          
     87            //                                                               Not allowed to call from an ISR
     88            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSSemCreate_0: (+1)
   \       0x10   0x.... 0x....      BL       CORE_InIrqContext
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??OSSemCreate_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??OSSemCreate_2
   \                     ??OSSemCreate_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??OSSemCreate_2: (+1)
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD10A             BNE.N    ??OSSemCreate_3
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0x7028             STRB     R0,[R5, #+0]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x2C   0x6068             STR      R0,[R5, #+4]
   \       0x2E   0x2058             MOVS     R0,#+88
   \       0x30   0x60A8             STR      R0,[R5, #+8]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0x36   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemCreate_4: (+1)
   \       0x38   0xE7FE             B.N      ??OSSemCreate_4
     89          
     90            //                                                               Validate 'p_sem'
     91            OS_ASSERT_DBG_ERR_SET((p_sem != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSSemCreate_3: (+1)
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD10A             BNE.N    ??OSSemCreate_5
   \       0x3E   0x200A             MOVS     R0,#+10
   \       0x40   0x7028             STRB     R0,[R5, #+0]
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x46   0x6068             STR      R0,[R5, #+4]
   \       0x48   0x205B             MOVS     R0,#+91
   \       0x4A   0x60A8             STR      R0,[R5, #+8]
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0x50   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemCreate_6: (+1)
   \       0x52   0xE7FE             B.N      ??OSSemCreate_6
     92          
     93            CORE_ENTER_ATOMIC();
   \                     ??OSSemCreate_5: (+1)
   \       0x54   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x58   0x0007             MOVS     R7,R0
     94          
     95            *p_sem = (OS_SEM){ 0 };
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x2110             MOVS     R1,#+16
   \       0x5E   0x.... 0x....      BL       __aeabi_memclr4
     96          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
     97            p_sem->Type = OS_OBJ_TYPE_SEM;                                // Mark the data structure as a semaphore
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x66   0x6020             STR      R0,[R4, #+0]
     98          #endif
     99            p_sem->Ctr = cnt;                                             // Set semaphore value
   \       0x68   0x60E6             STR      R6,[R4, #+12]
    100          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    101            p_sem->NamePtr = p_name;                                      // Save the name of the semaphore
    102          #else
    103            (void)&p_name;
   \       0x6A   0x4668             MOV      R0,SP
    104          #endif
    105            OS_PendListInit(&p_sem->PendList);                            // Initialize the waiting list
   \       0x6C   0x1D20             ADDS     R0,R4,#+4
   \       0x6E   0x.... 0x....      BL       OS_PendListInit
    106          
    107          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    108            OS_SemDbgListAdd(p_sem);
    109            OSSemQty++;
    110          #endif
    111          
    112            OS_TRACE_SEM_CREATE(p_sem, p_name);
    113          
    114            CORE_EXIT_ATOMIC();
   \       0x72   0x0038             MOVS     R0,R7
   \       0x74   0x.... 0x....      BL       CORE_ExitAtomic
    115            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x7028             STRB     R0,[R5, #+0]
   \       0x7C   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x80   0x6068             STR      R0,[R5, #+4]
   \       0x82   0x2073             MOVS     R0,#+115
   \       0x84   0x60A8             STR      R0,[R5, #+8]
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0x8A   0x60E8             STR      R0,[R5, #+12]
    116          }
   \       0x8C   0xBDF1             POP      {R0,R4-R7,PC}
    117          
    118          /****************************************************************************************************//**
    119           *                                               OSSemDel()
    120           *
    121           * @brief    Deletes a semaphore.
    122           *
    123           * @param    p_sem   Pointer to the semaphore to delete.
    124           *
    125           * @param    opt     Determines delete options as follows:
    126           *                       - OS_OPT_DEL_NO_PEND  Deletes the semaphore ONLY if there are no pending tasks.
    127           *                       - OS_OPT_DEL_ALWAYS   Deletes the semaphore even if tasks are waiting.
    128           *                   In this case, all the pending tasks will be readied.
    129           *
    130           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    131           *                   from this function:
    132           *                       - RTOS_ERR_NONE
    133           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    134           *                       - RTOS_ERR_OS_TASK_WAITING
    135           *                       - RTOS_ERR_NOT_READY
    136           *
    137           * @return   == 0    If there were no tasks waiting on the semaphore, or upon error.
    138           *           >  0    If one or more tasks waiting on the semaphore that are now readied and informed.
    139           *
    140           * @note     (1) Use this function with care. Tasks that would normally expect the presence of
    141           *               the semaphore MUST check the return code of OSSemPend().
    142           *
    143           * @note     (2) Because ALL tasks pending on the semaphore will be readied, be careful with
    144           *               applications where the semaphore is used for mutual exclusion because the resource(s)
    145           *               will no longer be guarded by the semaphore.
    146           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    147          OS_OBJ_QTY OSSemDel(OS_SEM   *p_sem,
    148                              OS_OPT   opt,
    149                              RTOS_ERR *p_err)
    150          {
   \                     OSSemDel: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x0015             MOVS     R5,R2
    151            OS_OBJ_QTY   nbr_tasks;
    152            OS_PEND_LIST *p_pend_list;
    153            OS_TCB       *p_tcb;
    154            CPU_TS       ts;
    155            CORE_DECLARE_IRQ_STATE;
    156          
    157            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSSemDel_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    158          
    159            OS_TRACE_SEM_DEL_ENTER(p_sem, opt);
    160          
    161          #ifdef OS_SAFETY_CRITICAL_IEC61508
    162            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    163              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
    164              return (0u);
    165            }
    166          #endif
    167          
    168            //                                                               Not allowed to call from an ISR
    169            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSSemDel_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_InIrqContext
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??OSSemDel_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??OSSemDel_2
   \                     ??OSSemDel_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??OSSemDel_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10A             BNE.N    ??OSSemDel_3
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x2E   0x6068             STR      R0,[R5, #+4]
   \       0x30   0x20A9             MOVS     R0,#+169
   \       0x32   0x60A8             STR      R0,[R5, #+8]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x38   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemDel_4: (+1)
   \       0x3A   0xE7FE             B.N      ??OSSemDel_4
    170          
    171            //                                                               Validate 'p_sem'
    172            OS_ASSERT_DBG_ERR_SET((p_sem != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??OSSemDel_3: (+1)
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD10A             BNE.N    ??OSSemDel_5
   \       0x40   0x200A             MOVS     R0,#+10
   \       0x42   0x7028             STRB     R0,[R5, #+0]
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x48   0x6068             STR      R0,[R5, #+4]
   \       0x4A   0x20AC             MOVS     R0,#+172
   \       0x4C   0x60A8             STR      R0,[R5, #+8]
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x52   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemDel_6: (+1)
   \       0x54   0xE7FE             B.N      ??OSSemDel_6
    173          
    174            //                                                               Validate object type
    175            OS_ASSERT_DBG_ERR_SET((p_sem->Type == OS_OBJ_TYPE_SEM), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
   \                     ??OSSemDel_5: (+1)
   \       0x56   0x6821             LDR      R1,[R4, #+0]
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x5C   0x4281             CMP      R1,R0
   \       0x5E   0xD00A             BEQ.N    ??OSSemDel_7
   \       0x60   0x200C             MOVS     R0,#+12
   \       0x62   0x7028             STRB     R0,[R5, #+0]
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x68   0x6068             STR      R0,[R5, #+4]
   \       0x6A   0x20AF             MOVS     R0,#+175
   \       0x6C   0x60A8             STR      R0,[R5, #+8]
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x72   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemDel_8: (+1)
   \       0x74   0xE7FE             B.N      ??OSSemDel_8
    176          
    177            //                                                               Make sure kernel is running.
    178            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSSemDel_7: (+1)
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \       0x7A   0x7800             LDRB     R0,[R0, #+0]
   \       0x7C   0x2801             CMP      R0,#+1
   \       0x7E   0xD00B             BEQ.N    ??OSSemDel_9
    179              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x80   0x2002             MOVS     R0,#+2
   \       0x82   0x7028             STRB     R0,[R5, #+0]
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x88   0x6068             STR      R0,[R5, #+4]
   \       0x8A   0x20B3             MOVS     R0,#+179
   \       0x8C   0x60A8             STR      R0,[R5, #+8]
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x92   0x60E8             STR      R0,[R5, #+12]
    180              return (0u);
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0xE064             B.N      ??OSSemDel_10
    181            }
    182          
    183            CORE_ENTER_ATOMIC();
   \                     ??OSSemDel_9: (+1)
   \       0x98   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x9C   0x4680             MOV      R8,R0
    184            p_pend_list = &p_sem->PendList;
   \       0x9E   0xF114 0x0904      ADDS     R9,R4,#+4
    185            nbr_tasks = 0u;
   \       0xA2   0xF05F 0x0A00      MOVS     R10,#+0
    186            switch (opt) {
   \       0xA6   0x4658             MOV      R0,R11
   \       0xA8   0xB280             UXTH     R0,R0
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD002             BEQ.N    ??OSSemDel_11
   \       0xAE   0x2801             CMP      R0,#+1
   \       0xB0   0xD023             BEQ.N    ??OSSemDel_12
   \       0xB2   0xE046             B.N      ??OSSemDel_13
    187              case OS_OPT_DEL_NO_PEND:                                    // Delete semaphore only if no task waiting
    188                if (p_pend_list->HeadPtr == DEF_NULL) {
   \                     ??OSSemDel_11: (+1)
   \       0xB4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD110             BNE.N    ??OSSemDel_14
    189          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    190                  OS_SemDbgListRemove(p_sem);
    191                  OSSemQty--;
    192          #endif
    193                  OS_TRACE_SEM_DEL(p_sem);
    194                  OS_SemClr(p_sem);
   \       0xBC   0x0020             MOVS     R0,R4
   \       0xBE   0x.... 0x....      BL       OS_SemClr
    195                  CORE_EXIT_ATOMIC();
   \       0xC2   0x4640             MOV      R0,R8
   \       0xC4   0x.... 0x....      BL       CORE_ExitAtomic
    196                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0x7028             STRB     R0,[R5, #+0]
   \       0xCC   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0xD0   0x6068             STR      R0,[R5, #+4]
   \       0xD2   0x20C4             MOVS     R0,#+196
   \       0xD4   0x60A8             STR      R0,[R5, #+8]
   \       0xD6   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0xDA   0x60E8             STR      R0,[R5, #+12]
   \       0xDC   0xE00C             B.N      ??OSSemDel_15
    197                } else {
    198                  CORE_EXIT_ATOMIC();
   \                     ??OSSemDel_14: (+1)
   \       0xDE   0x4640             MOV      R0,R8
   \       0xE0   0x.... 0x....      BL       CORE_ExitAtomic
    199                  RTOS_ERR_SET(*p_err, RTOS_ERR_OS_TASK_WAITING);
   \       0xE4   0x202E             MOVS     R0,#+46
   \       0xE6   0x7028             STRB     R0,[R5, #+0]
   \       0xE8   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0xEC   0x6068             STR      R0,[R5, #+4]
   \       0xEE   0x20C7             MOVS     R0,#+199
   \       0xF0   0x60A8             STR      R0,[R5, #+8]
   \       0xF2   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0xF6   0x60E8             STR      R0,[R5, #+12]
    200                }
    201                break;
   \                     ??OSSemDel_15: (+1)
   \       0xF8   0xE031             B.N      ??OSSemDel_16
    202          
    203              case OS_OPT_DEL_ALWAYS:                                     // Always delete the semaphore
    204          #if (OS_CFG_TS_EN == DEF_ENABLED)
    205                ts = OS_TS_GET();                                         // Get local time stamp so all tasks get the same time
    206          #else
    207                ts = 0u;
   \                     ??OSSemDel_12: (+1)
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0x0007             MOVS     R7,R0
    208          #endif
    209                while (p_pend_list->HeadPtr != DEF_NULL) {                // Remove all tasks on the pend list
   \                     ??OSSemDel_17: (+1)
   \       0xFE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD00A             BEQ.N    ??OSSemDel_18
    210                  p_tcb = p_pend_list->HeadPtr;
   \      0x106   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x10A   0x0006             MOVS     R6,R0
    211                  OS_PendAbort(p_tcb,
    212                               ts,
    213                               OS_STATUS_PEND_DEL);
   \      0x10C   0x2202             MOVS     R2,#+2
   \      0x10E   0x0039             MOVS     R1,R7
   \      0x110   0x0030             MOVS     R0,R6
   \      0x112   0x.... 0x....      BL       OS_PendAbort
    214                  nbr_tasks++;
   \      0x116   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x11A   0xE7F0             B.N      ??OSSemDel_17
    215                }
    216          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    217                OS_SemDbgListRemove(p_sem);
    218                OSSemQty--;
    219          #endif
    220                OS_TRACE_SEM_DEL(p_sem);
    221                OS_SemClr(p_sem);
   \                     ??OSSemDel_18: (+1)
   \      0x11C   0x0020             MOVS     R0,R4
   \      0x11E   0x.... 0x....      BL       OS_SemClr
    222                CORE_EXIT_ATOMIC();
   \      0x122   0x4640             MOV      R0,R8
   \      0x124   0x.... 0x....      BL       CORE_ExitAtomic
    223                OSSched();                                                // Find highest priority task ready to run
   \      0x128   0x.... 0x....      BL       OSSched
    224                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0x7028             STRB     R0,[R5, #+0]
   \      0x130   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x134   0x6068             STR      R0,[R5, #+4]
   \      0x136   0x20E0             MOVS     R0,#+224
   \      0x138   0x60A8             STR      R0,[R5, #+8]
   \      0x13A   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \      0x13E   0x60E8             STR      R0,[R5, #+12]
    225                break;
   \      0x140   0xE00D             B.N      ??OSSemDel_16
    226          
    227              default:
    228                CORE_EXIT_ATOMIC();
   \                     ??OSSemDel_13: (+1)
   \      0x142   0x4640             MOV      R0,R8
   \      0x144   0x.... 0x....      BL       CORE_ExitAtomic
    229                OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_INVALID_ARG, 0u);
   \      0x148   0x2008             MOVS     R0,#+8
   \      0x14A   0x7028             STRB     R0,[R5, #+0]
   \      0x14C   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x150   0x6068             STR      R0,[R5, #+4]
   \      0x152   0x20E5             MOVS     R0,#+229
   \      0x154   0x60A8             STR      R0,[R5, #+8]
   \      0x156   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \      0x15A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemDel_19: (+1)
   \      0x15C   0xE7FE             B.N      ??OSSemDel_19
    230            }
    231          
    232            OS_TRACE_SEM_DEL_EXIT(RTOS_ERR_CODE_GET(*p_err));
    233          
    234            return (nbr_tasks);
   \                     ??OSSemDel_16: (+1)
   \      0x15E   0x4650             MOV      R0,R10
   \      0x160   0xB280             UXTH     R0,R0
   \                     ??OSSemDel_10: (+1)
   \      0x162   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    235          }
    236          
    237          /****************************************************************************************************//**
    238           *                                               OSSemPend()
    239           *
    240           * @brief    Waits for a semaphore.
    241           *
    242           * @param    p_sem       Pointer to the semaphore.
    243           *
    244           * @param    timeout     Optional timeout period (in clock ticks). If non-zero, your task will
    245           *                       wait for the resource up to the amount of time (in 'ticks') specified by this
    246           *                       argument. If you enter 0, your task will wait forever at the specified
    247           *                       semaphore, or until the resource becomes available (or the event occurs).
    248           *
    249           * @param    opt         Determines whether the user wants to block if the semaphore is available or not:
    250           *                           - OS_OPT_PEND_BLOCKING        Task will     block.
    251           *                           - OS_OPT_PEND_NON_BLOCKING    Task will NOT block.
    252           *
    253           * @param    p_ts        Pointer to a variable that receives the timestamp of when the semaphore was
    254           *                       posted or pending aborted or the semaphore deleted. If you pass a
    255           *                       NULL pointer (i.e. (CPU_TS*)0), you will not get the timestamp. In other
    256           *                       words, passing a NULL pointer is valid and indicates that you don't need the
    257           *                       timestamp.
    258           *
    259           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
    260           *                       from this function:
    261           *                           - RTOS_ERR_NONE
    262           *                           - RTOS_ERR_OS_OBJ_DEL
    263           *                           - RTOS_ERR_WOULD_BLOCK
    264           *                           - RTOS_ERR_OS_SCHED_LOCKED
    265           *                           - RTOS_ERR_ABORT
    266           *                           - RTOS_ERR_TIMEOUT
    267           *                           - RTOS_ERR_NOT_READY
    268           *                           - RTOS_ERR_INVALID_STATE
    269           *
    270           * @return   The current value of the semaphore counter, or 0 if not available.
    271           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    272          OS_SEM_CTR OSSemPend(OS_SEM   *p_sem,
    273                               OS_TICK  timeout,
    274                               OS_OPT   opt,
    275                               CPU_TS   *p_ts,
    276                               RTOS_ERR *p_err)
    277          {
   \                     OSSemPend: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x9D08             LDR      R5,[SP, #+32]
    278            OS_SEM_CTR ctr;
    279            CORE_DECLARE_IRQ_STATE;
    280          
    281          #if (OS_CFG_TS_EN == DEF_DISABLED)
    282            (void)&p_ts;                                                  // Prevent compiler warning for not using 'ts'
   \        0xC   0x4668             MOV      R0,SP
    283          #endif
    284          
    285            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD101             BNE.N    ??OSSemPend_0
   \       0x12   0x.... 0x....      BL       CPU_SW_Exception
    286          
    287            OS_TRACE_SEM_PEND_ENTER(p_sem, timeout, opt, p_ts);
    288          
    289            //                                                               Not allowed to call from an ISR
    290            OS_ASSERT_DBG_ERR_SET(( (opt & OS_OPT_PEND_NON_BLOCKING)
    291                                    || !(CORE_InIrqContext())), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSSemPend_0: (+1)
   \       0x16   0x0438             LSLS     R0,R7,#+16
   \       0x18   0xD403             BMI.N    ??OSSemPend_1
   \       0x1A   0x.... 0x....      BL       CORE_InIrqContext
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??OSSemPend_2
   \                     ??OSSemPend_1: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xE000             B.N      ??OSSemPend_3
   \                     ??OSSemPend_2: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \                     ??OSSemPend_3: (+1)
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD10B             BNE.N    ??OSSemPend_4
   \       0x2E   0x2020             MOVS     R0,#+32
   \       0x30   0x7028             STRB     R0,[R5, #+0]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x36   0x6068             STR      R0,[R5, #+4]
   \       0x38   0xF240 0x1023      MOVW     R0,#+291
   \       0x3C   0x60A8             STR      R0,[R5, #+8]
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0x42   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemPend_5: (+1)
   \       0x44   0xE7FE             B.N      ??OSSemPend_5
    292          
    293            //                                                               Validate 'p_sem'
    294            OS_ASSERT_DBG_ERR_SET((p_sem != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??OSSemPend_4: (+1)
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD10B             BNE.N    ??OSSemPend_6
   \       0x4A   0x200A             MOVS     R0,#+10
   \       0x4C   0x7028             STRB     R0,[R5, #+0]
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x52   0x6068             STR      R0,[R5, #+4]
   \       0x54   0xF44F 0x7093      MOV      R0,#+294
   \       0x58   0x60A8             STR      R0,[R5, #+8]
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0x5E   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemPend_7: (+1)
   \       0x60   0xE7FE             B.N      ??OSSemPend_7
    295          
    296            //                                                               Validate 'opt'
    297            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_PEND_BLOCKING)
    298                                   || (opt == OS_OPT_PEND_NON_BLOCKING)), *p_err, RTOS_ERR_INVALID_ARG, 0u);
   \                     ??OSSemPend_6: (+1)
   \       0x62   0x0038             MOVS     R0,R7
   \       0x64   0xB280             UXTH     R0,R0
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD004             BEQ.N    ??OSSemPend_8
   \       0x6A   0x0038             MOVS     R0,R7
   \       0x6C   0xB280             UXTH     R0,R0
   \       0x6E   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x72   0xD101             BNE.N    ??OSSemPend_9
   \                     ??OSSemPend_8: (+1)
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE000             B.N      ??OSSemPend_10
   \                     ??OSSemPend_9: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??OSSemPend_10: (+1)
   \       0x7A   0xB2C0             UXTB     R0,R0
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD10B             BNE.N    ??OSSemPend_11
   \       0x80   0x2008             MOVS     R0,#+8
   \       0x82   0x7028             STRB     R0,[R5, #+0]
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x88   0x6068             STR      R0,[R5, #+4]
   \       0x8A   0xF44F 0x7095      MOV      R0,#+298
   \       0x8E   0x60A8             STR      R0,[R5, #+8]
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0x94   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemPend_12: (+1)
   \       0x96   0xE7FE             B.N      ??OSSemPend_12
    299          
    300            //                                                               Validate object type
    301            OS_ASSERT_DBG_ERR_SET((p_sem->Type == OS_OBJ_TYPE_SEM), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
   \                     ??OSSemPend_11: (+1)
   \       0x98   0x6821             LDR      R1,[R4, #+0]
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x9E   0x4281             CMP      R1,R0
   \       0xA0   0xD00B             BEQ.N    ??OSSemPend_13
   \       0xA2   0x200C             MOVS     R0,#+12
   \       0xA4   0x7028             STRB     R0,[R5, #+0]
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0xAA   0x6068             STR      R0,[R5, #+4]
   \       0xAC   0xF240 0x102D      MOVW     R0,#+301
   \       0xB0   0x60A8             STR      R0,[R5, #+8]
   \       0xB2   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0xB6   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemPend_14: (+1)
   \       0xB8   0xE7FE             B.N      ??OSSemPend_14
    302          
    303            //                                                               Not allowed to pend in atomic/critical sections
    304            OS_ASSERT_DBG_ERR_SET(( (opt & OS_OPT_PEND_NON_BLOCKING)
    305                                    || !CORE_IrqIsDisabled()), *p_err, RTOS_ERR_INVALID_STATE, 0u);
   \                     ??OSSemPend_13: (+1)
   \       0xBA   0x0438             LSLS     R0,R7,#+16
   \       0xBC   0xD403             BMI.N    ??OSSemPend_15
   \       0xBE   0x.... 0x....      BL       CORE_IrqIsDisabled
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD101             BNE.N    ??OSSemPend_16
   \                     ??OSSemPend_15: (+1)
   \       0xC6   0x2001             MOVS     R0,#+1
   \       0xC8   0xE000             B.N      ??OSSemPend_17
   \                     ??OSSemPend_16: (+1)
   \       0xCA   0x2000             MOVS     R0,#+0
   \                     ??OSSemPend_17: (+1)
   \       0xCC   0xB2C0             UXTB     R0,R0
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD10B             BNE.N    ??OSSemPend_18
   \       0xD2   0x201F             MOVS     R0,#+31
   \       0xD4   0x7028             STRB     R0,[R5, #+0]
   \       0xD6   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0xDA   0x6068             STR      R0,[R5, #+4]
   \       0xDC   0xF240 0x1031      MOVW     R0,#+305
   \       0xE0   0x60A8             STR      R0,[R5, #+8]
   \       0xE2   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0xE6   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemPend_19: (+1)
   \       0xE8   0xE7FE             B.N      ??OSSemPend_19
    306          
    307            //                                                               Make sure kernel is running.
    308            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSSemPend_18: (+1)
   \       0xEA   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \       0xEE   0x7800             LDRB     R0,[R0, #+0]
   \       0xF0   0x2801             CMP      R0,#+1
   \       0xF2   0xD00C             BEQ.N    ??OSSemPend_20
    309              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0xF4   0x2002             MOVS     R0,#+2
   \       0xF6   0x7028             STRB     R0,[R5, #+0]
   \       0xF8   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0xFC   0x6068             STR      R0,[R5, #+4]
   \       0xFE   0xF240 0x1035      MOVW     R0,#+309
   \      0x102   0x60A8             STR      R0,[R5, #+8]
   \      0x104   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \      0x108   0x60E8             STR      R0,[R5, #+12]
    310              return (0u);
   \      0x10A   0x2000             MOVS     R0,#+0
   \      0x10C   0xE09A             B.N      ??OSSemPend_21
    311            }
    312          
    313            CORE_ENTER_ATOMIC();
   \                     ??OSSemPend_20: (+1)
   \      0x10E   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x112   0x4680             MOV      R8,R0
    314            if (p_sem->Ctr > 0u) {                                        // Resource available?
   \      0x114   0x68E0             LDR      R0,[R4, #+12]
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD014             BEQ.N    ??OSSemPend_22
    315              p_sem->Ctr--;                                               // Yes, caller may proceed
   \      0x11A   0x68E0             LDR      R0,[R4, #+12]
   \      0x11C   0x1E40             SUBS     R0,R0,#+1
   \      0x11E   0x60E0             STR      R0,[R4, #+12]
    316          #if (OS_CFG_TS_EN == DEF_ENABLED)
    317              if (p_ts != DEF_NULL) {
    318                *p_ts = p_sem->TS;                                        // get timestamp of last post
    319              }
    320          #endif
    321              ctr = p_sem->Ctr;
   \      0x120   0xF8D4 0x900C      LDR      R9,[R4, #+12]
    322              CORE_EXIT_ATOMIC();
   \      0x124   0x4640             MOV      R0,R8
   \      0x126   0x.... 0x....      BL       CORE_ExitAtomic
    323              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x12A   0x2000             MOVS     R0,#+0
   \      0x12C   0x7028             STRB     R0,[R5, #+0]
   \      0x12E   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x132   0x6068             STR      R0,[R5, #+4]
   \      0x134   0xF240 0x1043      MOVW     R0,#+323
   \      0x138   0x60A8             STR      R0,[R5, #+8]
   \      0x13A   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \      0x13E   0x60E8             STR      R0,[R5, #+12]
    324              OS_TRACE_SEM_PEND(p_sem);
    325              OS_TRACE_SEM_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    326              return (ctr);
   \      0x140   0x4648             MOV      R0,R9
   \      0x142   0xE07F             B.N      ??OSSemPend_21
    327            }
    328          
    329            if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {                 // Caller wants to block if not available?
   \                     ??OSSemPend_22: (+1)
   \      0x144   0x0038             MOVS     R0,R7
   \      0x146   0xB280             UXTH     R0,R0
   \      0x148   0x0400             LSLS     R0,R0,#+16
   \      0x14A   0xD511             BPL.N    ??OSSemPend_23
    330          #if (OS_CFG_TS_EN == DEF_ENABLED)
    331              if (p_ts != DEF_NULL) {
    332                *p_ts = 0u;
    333              }
    334          #endif
    335              ctr = p_sem->Ctr;                                           // No
   \      0x14C   0xF8D4 0x900C      LDR      R9,[R4, #+12]
    336              CORE_EXIT_ATOMIC();
   \      0x150   0x4640             MOV      R0,R8
   \      0x152   0x.... 0x....      BL       CORE_ExitAtomic
    337              RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);
   \      0x156   0x201D             MOVS     R0,#+29
   \      0x158   0x7028             STRB     R0,[R5, #+0]
   \      0x15A   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x15E   0x6068             STR      R0,[R5, #+4]
   \      0x160   0xF240 0x1051      MOVW     R0,#+337
   \      0x164   0x60A8             STR      R0,[R5, #+8]
   \      0x166   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \      0x16A   0x60E8             STR      R0,[R5, #+12]
    338              OS_TRACE_SEM_PEND_FAILED(p_sem);
    339              OS_TRACE_SEM_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    340              return (ctr);
   \      0x16C   0x4648             MOV      R0,R9
   \      0x16E   0xE069             B.N      ??OSSemPend_21
    341            } else {                                                      // Yes
    342              if (OSSchedLockNestingCtr > 0u) {                           // Can't pend when the scheduler is locked
   \                     ??OSSemPend_23: (+1)
   \      0x170   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \      0x174   0x7800             LDRB     R0,[R0, #+0]
   \      0x176   0x2800             CMP      R0,#+0
   \      0x178   0xD00F             BEQ.N    ??OSSemPend_24
    343          #if (OS_CFG_TS_EN == DEF_ENABLED)
    344                if (p_ts != DEF_NULL) {
    345                  *p_ts = 0u;
    346                }
    347          #endif
    348                CORE_EXIT_ATOMIC();
   \      0x17A   0x4640             MOV      R0,R8
   \      0x17C   0x.... 0x....      BL       CORE_ExitAtomic
    349                RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
   \      0x180   0x202D             MOVS     R0,#+45
   \      0x182   0x7028             STRB     R0,[R5, #+0]
   \      0x184   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x188   0x6068             STR      R0,[R5, #+4]
   \      0x18A   0xF240 0x105D      MOVW     R0,#+349
   \      0x18E   0x60A8             STR      R0,[R5, #+8]
   \      0x190   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \      0x194   0x60E8             STR      R0,[R5, #+12]
    350                OS_TRACE_SEM_PEND_FAILED(p_sem);
    351                OS_TRACE_SEM_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    352                return (0u);
   \      0x196   0x2000             MOVS     R0,#+0
   \      0x198   0xE054             B.N      ??OSSemPend_21
    353              }
    354            }
    355          
    356            OS_Pend((OS_PEND_OBJ *)((void *)p_sem),                       // Block task pending on Semaphore
    357                    OS_TASK_PEND_ON_SEM,
    358                    timeout);
   \                     ??OSSemPend_24: (+1)
   \      0x19A   0x0032             MOVS     R2,R6
   \      0x19C   0x2106             MOVS     R1,#+6
   \      0x19E   0x0020             MOVS     R0,R4
   \      0x1A0   0x.... 0x....      BL       OS_Pend
    359            CORE_EXIT_ATOMIC();
   \      0x1A4   0x4640             MOV      R0,R8
   \      0x1A6   0x.... 0x....      BL       CORE_ExitAtomic
    360            OS_TRACE_SEM_PEND_BLOCK(p_sem);
    361            OSSched();                                                    // Find the next highest priority task ready to run
   \      0x1AA   0x.... 0x....      BL       OSSched
    362          
    363            CORE_ENTER_ATOMIC();
   \      0x1AE   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x1B2   0x4681             MOV      R9,R0
    364            switch (OSTCBCurPtr->PendStatus) {
   \      0x1B4   0x.... 0x....      LDR.W    R0,??DataTable6_7
   \      0x1B8   0x6800             LDR      R0,[R0, #+0]
   \      0x1BA   0xF890 0x0025      LDRB     R0,[R0, #+37]
   \      0x1BE   0x2800             CMP      R0,#+0
   \      0x1C0   0xD005             BEQ.N    ??OSSemPend_25
   \      0x1C2   0x2802             CMP      R0,#+2
   \      0x1C4   0xD027             BEQ.N    ??OSSemPend_26
   \      0x1C6   0xD30E             BCC.N    ??OSSemPend_27
   \      0x1C8   0x2803             CMP      R0,#+3
   \      0x1CA   0xD018             BEQ.N    ??OSSemPend_28
   \      0x1CC   0xE02F             B.N      ??OSSemPend_29
    365              case OS_STATUS_PEND_OK:                                     // We got the semaphore
    366          #if (OS_CFG_TS_EN == DEF_ENABLED)
    367                if (p_ts != DEF_NULL) {
    368                  *p_ts = OSTCBCurPtr->TS;
    369                }
    370          #endif
    371                OS_TRACE_SEM_PEND(p_sem);
    372                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSSemPend_25: (+1)
   \      0x1CE   0x2000             MOVS     R0,#+0
   \      0x1D0   0x7028             STRB     R0,[R5, #+0]
   \      0x1D2   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x1D6   0x6068             STR      R0,[R5, #+4]
   \      0x1D8   0xF44F 0x70BA      MOV      R0,#+372
   \      0x1DC   0x60A8             STR      R0,[R5, #+8]
   \      0x1DE   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \      0x1E2   0x60E8             STR      R0,[R5, #+12]
    373                break;
   \      0x1E4   0xE028             B.N      ??OSSemPend_30
    374          
    375              case OS_STATUS_PEND_ABORT:                                  // Indicate that we aborted
    376          #if (OS_CFG_TS_EN == DEF_ENABLED)
    377                if (p_ts != DEF_NULL) {
    378                  *p_ts = OSTCBCurPtr->TS;
    379                }
    380          #endif
    381                OS_TRACE_SEM_PEND_FAILED(p_sem);
    382                RTOS_ERR_SET(*p_err, RTOS_ERR_ABORT);
   \                     ??OSSemPend_27: (+1)
   \      0x1E6   0x2021             MOVS     R0,#+33
   \      0x1E8   0x7028             STRB     R0,[R5, #+0]
   \      0x1EA   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x1EE   0x6068             STR      R0,[R5, #+4]
   \      0x1F0   0xF44F 0x70BF      MOV      R0,#+382
   \      0x1F4   0x60A8             STR      R0,[R5, #+8]
   \      0x1F6   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \      0x1FA   0x60E8             STR      R0,[R5, #+12]
    383                break;
   \      0x1FC   0xE01C             B.N      ??OSSemPend_30
    384          
    385              case OS_STATUS_PEND_TIMEOUT:                                // Indicate that we didn't get semaphore within timeout
    386          #if (OS_CFG_TS_EN == DEF_ENABLED)
    387                if (p_ts != DEF_NULL) {
    388                  *p_ts = 0u;
    389                }
    390          #endif
    391                OS_TRACE_SEM_PEND_FAILED(p_sem);
    392                RTOS_ERR_SET(*p_err, RTOS_ERR_TIMEOUT);
   \                     ??OSSemPend_28: (+1)
   \      0x1FE   0x2022             MOVS     R0,#+34
   \      0x200   0x7028             STRB     R0,[R5, #+0]
   \      0x202   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x206   0x6068             STR      R0,[R5, #+4]
   \      0x208   0xF44F 0x70C4      MOV      R0,#+392
   \      0x20C   0x60A8             STR      R0,[R5, #+8]
   \      0x20E   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \      0x212   0x60E8             STR      R0,[R5, #+12]
    393                break;
   \      0x214   0xE010             B.N      ??OSSemPend_30
    394          
    395              case OS_STATUS_PEND_DEL:                                    // Indicate that object pended on has been deleted
    396          #if (OS_CFG_TS_EN == DEF_ENABLED)
    397                if (p_ts != DEF_NULL) {
    398                  *p_ts = OSTCBCurPtr->TS;
    399                }
    400          #endif
    401                OS_TRACE_SEM_PEND_FAILED(p_sem);
    402                RTOS_ERR_SET(*p_err, RTOS_ERR_OS_OBJ_DEL);
   \                     ??OSSemPend_26: (+1)
   \      0x216   0x2031             MOVS     R0,#+49
   \      0x218   0x7028             STRB     R0,[R5, #+0]
   \      0x21A   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x21E   0x6068             STR      R0,[R5, #+4]
   \      0x220   0xF44F 0x70C9      MOV      R0,#+402
   \      0x224   0x60A8             STR      R0,[R5, #+8]
   \      0x226   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \      0x22A   0x60E8             STR      R0,[R5, #+12]
    403                break;
   \      0x22C   0xE004             B.N      ??OSSemPend_30
    404          
    405              default:
    406                CORE_EXIT_ATOMIC();
   \                     ??OSSemPend_29: (+1)
   \      0x22E   0x4648             MOV      R0,R9
   \      0x230   0x.... 0x....      BL       CORE_ExitAtomic
    407                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, 0u);
   \      0x234   0x.... 0x....      BL       CPU_SW_Exception
    408                OS_TRACE_SEM_PEND_FAILED(p_sem);
    409                OS_TRACE_SEM_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    410            }
    411            ctr = p_sem->Ctr;
   \                     ??OSSemPend_30: (+1)
   \      0x238   0xF8D4 0x800C      LDR      R8,[R4, #+12]
    412            CORE_EXIT_ATOMIC();
   \      0x23C   0x4648             MOV      R0,R9
   \      0x23E   0x.... 0x....      BL       CORE_ExitAtomic
    413            OS_TRACE_SEM_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    414            return (ctr);
   \      0x242   0x4640             MOV      R0,R8
   \                     ??OSSemPend_21: (+1)
   \      0x244   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    415          }
    416          
    417          /****************************************************************************************************//**
    418           *                                               OSSemPendAbort()
    419           *
    420           * @brief    Aborts and readies any tasks currently waiting on a semaphore. Rather than signal the
    421           *           semaphore via OSSemPost(), use this function to fault-abort the wait on the semaphore.
    422           *
    423           * @param    p_sem   Pointer to the semaphore.
    424           *
    425           * @param    opt     Determines the type of ABORT performed:
    426           *                       - OS_OPT_PEND_ABORT_1     ABORT waits for a single task (HPT) waiting on
    427           *                                                 the semaphore.
    428           *                       - OS_OPT_PEND_ABORT_ALL   ABORT waits for ALL tasks that are waiting on
    429           *                                                 the semaphore.
    430           *                       - OS_OPT_POST_NO_SCHED    Do not call the scheduler.
    431           *
    432           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    433           *                   from this function:
    434           *                       - RTOS_ERR_NONE
    435           *                       - RTOS_ERR_NONE_WAITING
    436           *                       - RTOS_ERR_NOT_READY
    437           *
    438           * @return   == 0    If no tasks were waiting on the semaphore, or upon error.
    439           *           >  0    If one or more tasks waiting on the semaphore are now readied and informed.
    440           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    441          OS_OBJ_QTY OSSemPendAbort(OS_SEM   *p_sem,
    442                                    OS_OPT   opt,
    443                                    RTOS_ERR *p_err)
    444          {
   \                     OSSemPendAbort: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x0015             MOVS     R5,R2
    445            OS_PEND_LIST *p_pend_list;
    446            OS_TCB       *p_tcb;
    447            CPU_TS       ts;
    448            OS_OBJ_QTY   nbr_tasks;
    449            CORE_DECLARE_IRQ_STATE;
    450          
    451            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSSemPendAbort_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    452          
    453            //                                                               Not allowed to call from an ISR
    454            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSSemPendAbort_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_InIrqContext
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??OSSemPendAbort_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??OSSemPendAbort_2
   \                     ??OSSemPendAbort_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??OSSemPendAbort_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10B             BNE.N    ??OSSemPendAbort_3
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x2E   0x6068             STR      R0,[R5, #+4]
   \       0x30   0xF44F 0x70E3      MOV      R0,#+454
   \       0x34   0x60A8             STR      R0,[R5, #+8]
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable6_8
   \       0x3A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemPendAbort_4: (+1)
   \       0x3C   0xE7FE             B.N      ??OSSemPendAbort_4
    455          
    456            //                                                               Validate 'p_sem'
    457            OS_ASSERT_DBG_ERR_SET((p_sem != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??OSSemPendAbort_3: (+1)
   \       0x3E   0x2C00             CMP      R4,#+0
   \       0x40   0xD10B             BNE.N    ??OSSemPendAbort_5
   \       0x42   0x200A             MOVS     R0,#+10
   \       0x44   0x7028             STRB     R0,[R5, #+0]
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x4A   0x6068             STR      R0,[R5, #+4]
   \       0x4C   0xF240 0x10C9      MOVW     R0,#+457
   \       0x50   0x60A8             STR      R0,[R5, #+8]
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable6_8
   \       0x56   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemPendAbort_6: (+1)
   \       0x58   0xE7FE             B.N      ??OSSemPendAbort_6
    458          
    459            //                                                               Validate 'opt'
    460            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_PEND_ABORT_1)
    461                                   || (opt == OS_OPT_PEND_ABORT_ALL)
    462                                   || (opt == (OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED))
    463                                   || (opt == (OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED))), *p_err, RTOS_ERR_INVALID_ARG, 0u);
   \                     ??OSSemPendAbort_5: (+1)
   \       0x5A   0x4658             MOV      R0,R11
   \       0x5C   0xB280             UXTH     R0,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD00E             BEQ.N    ??OSSemPendAbort_7
   \       0x62   0x4658             MOV      R0,R11
   \       0x64   0xB280             UXTH     R0,R0
   \       0x66   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x6A   0xD009             BEQ.N    ??OSSemPendAbort_7
   \       0x6C   0x4658             MOV      R0,R11
   \       0x6E   0xB280             UXTH     R0,R0
   \       0x70   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x74   0xD004             BEQ.N    ??OSSemPendAbort_7
   \       0x76   0x4658             MOV      R0,R11
   \       0x78   0xB280             UXTH     R0,R0
   \       0x7A   0xF5B0 0x4F01      CMP      R0,#+33024
   \       0x7E   0xD101             BNE.N    ??OSSemPendAbort_8
   \                     ??OSSemPendAbort_7: (+1)
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0xE000             B.N      ??OSSemPendAbort_9
   \                     ??OSSemPendAbort_8: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \                     ??OSSemPendAbort_9: (+1)
   \       0x86   0xB2C0             UXTB     R0,R0
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD10A             BNE.N    ??OSSemPendAbort_10
   \       0x8C   0x2008             MOVS     R0,#+8
   \       0x8E   0x7028             STRB     R0,[R5, #+0]
   \       0x90   0x....             LDR.N    R0,??DataTable6
   \       0x92   0x6068             STR      R0,[R5, #+4]
   \       0x94   0xF240 0x10CF      MOVW     R0,#+463
   \       0x98   0x60A8             STR      R0,[R5, #+8]
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable6_8
   \       0x9E   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemPendAbort_11: (+1)
   \       0xA0   0xE7FE             B.N      ??OSSemPendAbort_11
    464          
    465            //                                                               Validate object type
    466            OS_ASSERT_DBG_ERR_SET((p_sem->Type == OS_OBJ_TYPE_SEM), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
   \                     ??OSSemPendAbort_10: (+1)
   \       0xA2   0x6821             LDR      R1,[R4, #+0]
   \       0xA4   0x....             LDR.N    R0,??DataTable6_2
   \       0xA6   0x4281             CMP      R1,R0
   \       0xA8   0xD009             BEQ.N    ??OSSemPendAbort_12
   \       0xAA   0x200C             MOVS     R0,#+12
   \       0xAC   0x7028             STRB     R0,[R5, #+0]
   \       0xAE   0x....             LDR.N    R0,??DataTable6
   \       0xB0   0x6068             STR      R0,[R5, #+4]
   \       0xB2   0xF44F 0x70E9      MOV      R0,#+466
   \       0xB6   0x60A8             STR      R0,[R5, #+8]
   \       0xB8   0x....             LDR.N    R0,??DataTable6_8
   \       0xBA   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemPendAbort_13: (+1)
   \       0xBC   0xE7FE             B.N      ??OSSemPendAbort_13
    467          
    468            //                                                               Make sure kernel is running.
    469            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSSemPendAbort_12: (+1)
   \       0xBE   0x....             LDR.N    R0,??DataTable6_4
   \       0xC0   0x7800             LDRB     R0,[R0, #+0]
   \       0xC2   0x2801             CMP      R0,#+1
   \       0xC4   0xD00A             BEQ.N    ??OSSemPendAbort_14
    470              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0xC6   0x2002             MOVS     R0,#+2
   \       0xC8   0x7028             STRB     R0,[R5, #+0]
   \       0xCA   0x....             LDR.N    R0,??DataTable6
   \       0xCC   0x6068             STR      R0,[R5, #+4]
   \       0xCE   0xF44F 0x70EB      MOV      R0,#+470
   \       0xD2   0x60A8             STR      R0,[R5, #+8]
   \       0xD4   0x....             LDR.N    R0,??DataTable6_8
   \       0xD6   0x60E8             STR      R0,[R5, #+12]
    471              return (0u);
   \       0xD8   0x2000             MOVS     R0,#+0
   \       0xDA   0xE041             B.N      ??OSSemPendAbort_15
    472            }
    473          
    474            CORE_ENTER_ATOMIC();
   \                     ??OSSemPendAbort_14: (+1)
   \       0xDC   0x.... 0x....      BL       CORE_EnterAtomic
   \       0xE0   0x0007             MOVS     R7,R0
    475            p_pend_list = &p_sem->PendList;
   \       0xE2   0xF114 0x0804      ADDS     R8,R4,#+4
    476            if (p_pend_list->HeadPtr == DEF_NULL) {                       // Any task waiting on semaphore?
   \       0xE6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xEA   0x2800             CMP      R0,#+0
   \       0xEC   0xD10D             BNE.N    ??OSSemPendAbort_16
    477              CORE_EXIT_ATOMIC();                                         // No
   \       0xEE   0x0038             MOVS     R0,R7
   \       0xF0   0x.... 0x....      BL       CORE_ExitAtomic
    478              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE_WAITING);
   \       0xF4   0x2024             MOVS     R0,#+36
   \       0xF6   0x7028             STRB     R0,[R5, #+0]
   \       0xF8   0x....             LDR.N    R0,??DataTable6
   \       0xFA   0x6068             STR      R0,[R5, #+4]
   \       0xFC   0xF44F 0x70EF      MOV      R0,#+478
   \      0x100   0x60A8             STR      R0,[R5, #+8]
   \      0x102   0x....             LDR.N    R0,??DataTable6_8
   \      0x104   0x60E8             STR      R0,[R5, #+12]
    479              return (0u);
   \      0x106   0x2000             MOVS     R0,#+0
   \      0x108   0xE02A             B.N      ??OSSemPendAbort_15
    480            }
    481          
    482            nbr_tasks = 0u;
   \                     ??OSSemPendAbort_16: (+1)
   \      0x10A   0xF05F 0x0900      MOVS     R9,#+0
    483          #if (OS_CFG_TS_EN == DEF_ENABLED)
    484            ts = OS_TS_GET();                                             // Get local time stamp so all tasks get the same time
    485          #else
    486            ts = 0u;
   \      0x10E   0xF05F 0x0A00      MOVS     R10,#+0
    487          #endif
    488            while (p_pend_list->HeadPtr != DEF_NULL) {
   \                     ??OSSemPendAbort_17: (+1)
   \      0x112   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD00E             BEQ.N    ??OSSemPendAbort_18
    489              p_tcb = p_pend_list->HeadPtr;
   \      0x11A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x11E   0x0006             MOVS     R6,R0
    490              OS_PendAbort(p_tcb,
    491                           ts,
    492                           OS_STATUS_PEND_ABORT);
   \      0x120   0x2201             MOVS     R2,#+1
   \      0x122   0x4651             MOV      R1,R10
   \      0x124   0x0030             MOVS     R0,R6
   \      0x126   0x.... 0x....      BL       OS_PendAbort
    493              nbr_tasks++;
   \      0x12A   0xF119 0x0901      ADDS     R9,R9,#+1
    494              if (opt != OS_OPT_PEND_ABORT_ALL) {                         // Pend abort all tasks waiting?
   \      0x12E   0x4658             MOV      R0,R11
   \      0x130   0xB280             UXTH     R0,R0
   \      0x132   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x136   0xD0EC             BEQ.N    ??OSSemPendAbort_17
    495                break;                                                    // No
    496              }
    497            }
    498            CORE_EXIT_ATOMIC();
   \                     ??OSSemPendAbort_18: (+1)
   \      0x138   0x0038             MOVS     R0,R7
   \      0x13A   0x.... 0x....      BL       CORE_ExitAtomic
    499          
    500            if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \      0x13E   0x4658             MOV      R0,R11
   \      0x140   0xB280             UXTH     R0,R0
   \      0x142   0x0400             LSLS     R0,R0,#+16
   \      0x144   0xD401             BMI.N    ??OSSemPendAbort_19
    501              OSSched();                                                  // Run the scheduler
   \      0x146   0x.... 0x....      BL       OSSched
    502            }
    503          
    504            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSSemPendAbort_19: (+1)
   \      0x14A   0x2000             MOVS     R0,#+0
   \      0x14C   0x7028             STRB     R0,[R5, #+0]
   \      0x14E   0x....             LDR.N    R0,??DataTable6
   \      0x150   0x6068             STR      R0,[R5, #+4]
   \      0x152   0xF44F 0x70FC      MOV      R0,#+504
   \      0x156   0x60A8             STR      R0,[R5, #+8]
   \      0x158   0x....             LDR.N    R0,??DataTable6_8
   \      0x15A   0x60E8             STR      R0,[R5, #+12]
    505            return (nbr_tasks);
   \      0x15C   0x4648             MOV      R0,R9
   \      0x15E   0xB280             UXTH     R0,R0
   \                     ??OSSemPendAbort_15: (+1)
   \      0x160   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    506          }
    507          
    508          /****************************************************************************************************//**
    509           *                                               OSSemPost()
    510           *
    511           * @brief    Signals a semaphore.
    512           *
    513           * @param    p_sem   Pointer to the semaphore.
    514           *
    515           * @param    opt     Determines the type of POST performed:
    516           *                       - OS_OPT_POST_1           POST and ready only the highest priority task waiting
    517           *                                                 on semaphore (if tasks are waiting).
    518           *                       - OS_OPT_POST_ALL         POST to ALL tasks that are waiting on the semaphore.
    519           *                       - OS_OPT_POST_NO_SCHED    Do not call the scheduler.
    520           *
    521           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    522           *                   from this function:
    523           *                       - RTOS_ERR_NONE
    524           *                       - RTOS_ERR_WOULD_OVF
    525           *                       - RTOS_ERR_NOT_READY
    526           *
    527           * @return   The current value of the semaphore counter or 0 upon error.
    528           *
    529           * @note     (1) OS_OPT_POST_NO_SCHED can be OR'ed with one of the other two options to prevent the
    530           *               scheduler from being called.
    531           *
    532           * @note     (2) This function may be called from an ISR.
    533           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    534          OS_SEM_CTR OSSemPost(OS_SEM   *p_sem,
    535                               OS_OPT   opt,
    536                               RTOS_ERR *p_err)
    537          {
   \                     OSSemPost: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x0016             MOVS     R6,R2
    538            OS_SEM_CTR   ctr;
    539            OS_PEND_LIST *p_pend_list;
    540            OS_TCB       *p_tcb;
    541            OS_TCB       *p_tcb_next;
    542            CPU_TS       ts;
    543            CORE_DECLARE_IRQ_STATE;
    544          
    545            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD101             BNE.N    ??OSSemPost_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    546          
    547            OS_TRACE_SEM_POST_ENTER(p_sem, opt);
    548          
    549            //                                                               Validate 'p_sem'
    550            OS_ASSERT_DBG_ERR_SET((p_sem != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??OSSemPost_0: (+1)
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD109             BNE.N    ??OSSemPost_1
   \       0x16   0x200A             MOVS     R0,#+10
   \       0x18   0x7030             STRB     R0,[R6, #+0]
   \       0x1A   0x....             LDR.N    R0,??DataTable6
   \       0x1C   0x6070             STR      R0,[R6, #+4]
   \       0x1E   0xF240 0x2026      MOVW     R0,#+550
   \       0x22   0x60B0             STR      R0,[R6, #+8]
   \       0x24   0x....             LDR.N    R0,??DataTable6_9
   \       0x26   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSSemPost_2: (+1)
   \       0x28   0xE7FE             B.N      ??OSSemPost_2
    551          
    552            //                                                               Validate 'opt'
    553            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_POST_1)
    554                                   || (opt == OS_OPT_POST_ALL)
    555                                   || (opt == (OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED))
    556                                   || (opt == (OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED))), *p_err, RTOS_ERR_INVALID_ARG, 0u);
   \                     ??OSSemPost_1: (+1)
   \       0x2A   0x4658             MOV      R0,R11
   \       0x2C   0xB280             UXTH     R0,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD00E             BEQ.N    ??OSSemPost_3
   \       0x32   0x4658             MOV      R0,R11
   \       0x34   0xB280             UXTH     R0,R0
   \       0x36   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x3A   0xD009             BEQ.N    ??OSSemPost_3
   \       0x3C   0x4658             MOV      R0,R11
   \       0x3E   0xB280             UXTH     R0,R0
   \       0x40   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x44   0xD004             BEQ.N    ??OSSemPost_3
   \       0x46   0x4658             MOV      R0,R11
   \       0x48   0xB280             UXTH     R0,R0
   \       0x4A   0xF5B0 0x4F02      CMP      R0,#+33280
   \       0x4E   0xD101             BNE.N    ??OSSemPost_4
   \                     ??OSSemPost_3: (+1)
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xE000             B.N      ??OSSemPost_5
   \                     ??OSSemPost_4: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??OSSemPost_5: (+1)
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD109             BNE.N    ??OSSemPost_6
   \       0x5C   0x2008             MOVS     R0,#+8
   \       0x5E   0x7030             STRB     R0,[R6, #+0]
   \       0x60   0x....             LDR.N    R0,??DataTable6
   \       0x62   0x6070             STR      R0,[R6, #+4]
   \       0x64   0xF44F 0x700B      MOV      R0,#+556
   \       0x68   0x60B0             STR      R0,[R6, #+8]
   \       0x6A   0x....             LDR.N    R0,??DataTable6_9
   \       0x6C   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSSemPost_7: (+1)
   \       0x6E   0xE7FE             B.N      ??OSSemPost_7
    557          
    558            //                                                               Validate object type
    559            OS_ASSERT_DBG_ERR_SET((p_sem->Type == OS_OBJ_TYPE_SEM), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
   \                     ??OSSemPost_6: (+1)
   \       0x70   0x6828             LDR      R0,[R5, #+0]
   \       0x72   0x....             LDR.N    R1,??DataTable6_2
   \       0x74   0x4288             CMP      R0,R1
   \       0x76   0xD009             BEQ.N    ??OSSemPost_8
   \       0x78   0x200C             MOVS     R0,#+12
   \       0x7A   0x7030             STRB     R0,[R6, #+0]
   \       0x7C   0x....             LDR.N    R0,??DataTable6
   \       0x7E   0x6070             STR      R0,[R6, #+4]
   \       0x80   0xF240 0x202F      MOVW     R0,#+559
   \       0x84   0x60B0             STR      R0,[R6, #+8]
   \       0x86   0x....             LDR.N    R0,??DataTable6_9
   \       0x88   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSSemPost_9: (+1)
   \       0x8A   0xE7FE             B.N      ??OSSemPost_9
    560          
    561            //                                                               Make sure kernel is running.
    562            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSSemPost_8: (+1)
   \       0x8C   0x....             LDR.N    R0,??DataTable6_4
   \       0x8E   0x7800             LDRB     R0,[R0, #+0]
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD00A             BEQ.N    ??OSSemPost_10
    563              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x94   0x2002             MOVS     R0,#+2
   \       0x96   0x7030             STRB     R0,[R6, #+0]
   \       0x98   0x....             LDR.N    R0,??DataTable6
   \       0x9A   0x6070             STR      R0,[R6, #+4]
   \       0x9C   0xF240 0x2033      MOVW     R0,#+563
   \       0xA0   0x60B0             STR      R0,[R6, #+8]
   \       0xA2   0x....             LDR.N    R0,??DataTable6_9
   \       0xA4   0x60F0             STR      R0,[R6, #+12]
    564              return (0u);
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xE054             B.N      ??OSSemPost_11
    565            }
    566          
    567          #if (OS_CFG_TS_EN == DEF_ENABLED)
    568            ts = OS_TS_GET();                                             // Get timestamp
    569          #else
    570            ts = 0u;
   \                     ??OSSemPost_10: (+1)
   \       0xAA   0xF05F 0x0800      MOVS     R8,#+0
    571          #endif
    572          
    573            OS_TRACE_SEM_POST(p_sem);
    574          
    575            CORE_ENTER_ATOMIC();
   \       0xAE   0x.... 0x....      BL       CORE_EnterAtomic
   \       0xB2   0x4681             MOV      R9,R0
    576            p_pend_list = &p_sem->PendList;
   \       0xB4   0xF115 0x0A04      ADDS     R10,R5,#+4
    577            if (p_pend_list->HeadPtr == DEF_NULL) {                       // Any task waiting on semaphore?
   \       0xB8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD123             BNE.N    ??OSSemPost_12
    578              if (p_sem->Ctr == (OS_SEM_CTR)-1) {
   \       0xC0   0x68E8             LDR      R0,[R5, #+12]
   \       0xC2   0xF110 0x0F01      CMN      R0,#+1
   \       0xC6   0xD10D             BNE.N    ??OSSemPost_13
    579                CORE_EXIT_ATOMIC();
   \       0xC8   0x4648             MOV      R0,R9
   \       0xCA   0x.... 0x....      BL       CORE_ExitAtomic
    580                RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   \       0xCE   0x201E             MOVS     R0,#+30
   \       0xD0   0x7030             STRB     R0,[R6, #+0]
   \       0xD2   0x....             LDR.N    R0,??DataTable6
   \       0xD4   0x6070             STR      R0,[R6, #+4]
   \       0xD6   0xF44F 0x7011      MOV      R0,#+580
   \       0xDA   0x60B0             STR      R0,[R6, #+8]
   \       0xDC   0x....             LDR.N    R0,??DataTable6_9
   \       0xDE   0x60F0             STR      R0,[R6, #+12]
    581                OS_TRACE_SEM_POST_FAILED(p_sem);
    582                OS_TRACE_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
    583                return (0u);
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xE037             B.N      ??OSSemPost_11
    584              }
    585              p_sem->Ctr++;                                               // No
   \                     ??OSSemPost_13: (+1)
   \       0xE4   0x68E8             LDR      R0,[R5, #+12]
   \       0xE6   0x1C40             ADDS     R0,R0,#+1
   \       0xE8   0x60E8             STR      R0,[R5, #+12]
    586              ctr = p_sem->Ctr;
   \       0xEA   0x68EC             LDR      R4,[R5, #+12]
    587          #if (OS_CFG_TS_EN == DEF_ENABLED)
    588              p_sem->TS = ts;                                             // Save timestamp in semaphore control block
    589          #endif
    590              CORE_EXIT_ATOMIC();
   \       0xEC   0x4648             MOV      R0,R9
   \       0xEE   0x.... 0x....      BL       CORE_ExitAtomic
    591              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0x7030             STRB     R0,[R6, #+0]
   \       0xF6   0x....             LDR.N    R0,??DataTable6
   \       0xF8   0x6070             STR      R0,[R6, #+4]
   \       0xFA   0xF240 0x204F      MOVW     R0,#+591
   \       0xFE   0x60B0             STR      R0,[R6, #+8]
   \      0x100   0x....             LDR.N    R0,??DataTable6_9
   \      0x102   0x60F0             STR      R0,[R6, #+12]
    592              OS_TRACE_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
    593              return (ctr);
   \      0x104   0x0020             MOVS     R0,R4
   \      0x106   0xE025             B.N      ??OSSemPost_11
    594            }
    595          
    596            p_tcb = p_pend_list->HeadPtr;
   \                     ??OSSemPost_12: (+1)
   \      0x108   0xF8DA 0x4000      LDR      R4,[R10, #+0]
    597            while (p_tcb != DEF_NULL) {
   \                     ??OSSemPost_14: (+1)
   \      0x10C   0x2C00             CMP      R4,#+0
   \      0x10E   0xD00E             BEQ.N    ??OSSemPost_15
    598              p_tcb_next = p_tcb->PendNextPtr;
   \      0x110   0x69A0             LDR      R0,[R4, #+24]
   \      0x112   0x0007             MOVS     R7,R0
    599              OS_Post((OS_PEND_OBJ *)((void *)p_sem),
    600                      p_tcb,
    601                      DEF_NULL,
    602                      0u,
    603                      ts);
   \      0x114   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x118   0x2300             MOVS     R3,#+0
   \      0x11A   0x2200             MOVS     R2,#+0
   \      0x11C   0x0021             MOVS     R1,R4
   \      0x11E   0x0028             MOVS     R0,R5
   \      0x120   0x.... 0x....      BL       OS_Post
    604              if ((opt & OS_OPT_POST_ALL) == 0) {                         // Post to all tasks waiting?
   \      0x124   0xEA5F 0x508B      LSLS     R0,R11,#+22
   \      0x128   0xD501             BPL.N    ??OSSemPost_15
    605                break;                                                    // No
    606              }
    607              p_tcb = p_tcb_next;
   \                     ??OSSemPost_16: (+1)
   \      0x12A   0x003C             MOVS     R4,R7
   \      0x12C   0xE7EE             B.N      ??OSSemPost_14
    608            }
    609            CORE_EXIT_ATOMIC();
   \                     ??OSSemPost_15: (+1)
   \      0x12E   0x4648             MOV      R0,R9
   \      0x130   0x.... 0x....      BL       CORE_ExitAtomic
    610            if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \      0x134   0x4658             MOV      R0,R11
   \      0x136   0xB280             UXTH     R0,R0
   \      0x138   0x0400             LSLS     R0,R0,#+16
   \      0x13A   0xD401             BMI.N    ??OSSemPost_17
    611              OSSched();                                                  // Run the scheduler
   \      0x13C   0x.... 0x....      BL       OSSched
    612            }
    613            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSSemPost_17: (+1)
   \      0x140   0x2000             MOVS     R0,#+0
   \      0x142   0x7030             STRB     R0,[R6, #+0]
   \      0x144   0x....             LDR.N    R0,??DataTable6
   \      0x146   0x6070             STR      R0,[R6, #+4]
   \      0x148   0xF240 0x2065      MOVW     R0,#+613
   \      0x14C   0x60B0             STR      R0,[R6, #+8]
   \      0x14E   0x....             LDR.N    R0,??DataTable6_9
   \      0x150   0x60F0             STR      R0,[R6, #+12]
    614            OS_TRACE_SEM_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
    615          
    616            return (0u);
   \      0x152   0x2000             MOVS     R0,#+0
   \                     ??OSSemPost_11: (+1)
   \      0x154   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    617          }
    618          
    619          /****************************************************************************************************//**
    620           *                                               OSSemSet()
    621           *
    622           * @brief    Sets the semaphore count to the value specified as an argument. Typically
    623           *           this value would be 0, but you can set the semaphore to any value.
    624           *           Typically, you would use this function when a semaphore acts as a signaling mechanism
    625           *           and you want to reset the count value.
    626           *
    627           * @param    p_sem   Pointer to the semaphore.
    628           *
    629           * @param    cnt     The new value for the semaphore count. You would pass 0 to reset the semaphore
    630           *                   count.
    631           *
    632           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    633           *                   from this function:
    634           *                       - RTOS_ERR_NONE
    635           *                       - RTOS_ERR_OS_TASK_WAITING
    636           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    637          void OSSemSet(OS_SEM     *p_sem,
    638                        OS_SEM_CTR cnt,
    639                        RTOS_ERR   *p_err)
    640          {
   \                     OSSemSet: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x0015             MOVS     R5,R2
    641            OS_PEND_LIST *p_pend_list;
    642            CORE_DECLARE_IRQ_STATE;
    643          
    644            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSSemSet_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    645          
    646            //                                                               Not allowed to call from an ISR
    647            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSSemSet_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_InIrqContext
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??OSSemSet_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??OSSemSet_2
   \                     ??OSSemSet_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??OSSemSet_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD109             BNE.N    ??OSSemSet_3
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   \       0x2A   0x....             LDR.N    R0,??DataTable6
   \       0x2C   0x6068             STR      R0,[R5, #+4]
   \       0x2E   0xF240 0x2087      MOVW     R0,#+647
   \       0x32   0x60A8             STR      R0,[R5, #+8]
   \       0x34   0x....             LDR.N    R0,??DataTable6_10
   \       0x36   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemSet_4: (+1)
   \       0x38   0xE7FE             B.N      ??OSSemSet_4
    648          
    649            //                                                               Validate 'p_sem'
    650            OS_ASSERT_DBG_ERR_SET((p_sem != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSSemSet_3: (+1)
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD109             BNE.N    ??OSSemSet_5
   \       0x3E   0x200A             MOVS     R0,#+10
   \       0x40   0x7028             STRB     R0,[R5, #+0]
   \       0x42   0x....             LDR.N    R0,??DataTable6
   \       0x44   0x6068             STR      R0,[R5, #+4]
   \       0x46   0xF240 0x208A      MOVW     R0,#+650
   \       0x4A   0x60A8             STR      R0,[R5, #+8]
   \       0x4C   0x....             LDR.N    R0,??DataTable6_10
   \       0x4E   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemSet_6: (+1)
   \       0x50   0xE7FE             B.N      ??OSSemSet_6
    651          
    652            //                                                               Validate object type
    653            OS_ASSERT_DBG_ERR_SET((p_sem->Type == OS_OBJ_TYPE_SEM), *p_err, RTOS_ERR_INVALID_TYPE,; );
   \                     ??OSSemSet_5: (+1)
   \       0x52   0x6821             LDR      R1,[R4, #+0]
   \       0x54   0x....             LDR.N    R0,??DataTable6_2
   \       0x56   0x4281             CMP      R1,R0
   \       0x58   0xD009             BEQ.N    ??OSSemSet_7
   \       0x5A   0x200C             MOVS     R0,#+12
   \       0x5C   0x7028             STRB     R0,[R5, #+0]
   \       0x5E   0x....             LDR.N    R0,??DataTable6
   \       0x60   0x6068             STR      R0,[R5, #+4]
   \       0x62   0xF240 0x208D      MOVW     R0,#+653
   \       0x66   0x60A8             STR      R0,[R5, #+8]
   \       0x68   0x....             LDR.N    R0,??DataTable6_10
   \       0x6A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSSemSet_8: (+1)
   \       0x6C   0xE7FE             B.N      ??OSSemSet_8
    654          
    655            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSSemSet_7: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x7028             STRB     R0,[R5, #+0]
   \       0x72   0x....             LDR.N    R7,??DataTable6
   \       0x74   0x606F             STR      R7,[R5, #+4]
   \       0x76   0xF240 0x208F      MOVW     R0,#+655
   \       0x7A   0x60A8             STR      R0,[R5, #+8]
   \       0x7C   0x.... 0x....      LDR.W    R8,??DataTable6_10
   \       0x80   0xF8C5 0x800C      STR      R8,[R5, #+12]
    656            CORE_ENTER_ATOMIC();
   \       0x84   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x88   0x4681             MOV      R9,R0
    657            if (p_sem->Ctr > 0u) {                                        // See if semaphore already has a count
   \       0x8A   0x68E0             LDR      R0,[R4, #+12]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD002             BEQ.N    ??OSSemSet_9
    658              p_sem->Ctr = cnt;                                           // Yes, set it to the new value specified.
   \       0x90   0xF8C4 0xA00C      STR      R10,[R4, #+12]
   \       0x94   0xE00F             B.N      ??OSSemSet_10
    659            } else {
    660              p_pend_list = &p_sem->PendList;                             // No
   \                     ??OSSemSet_9: (+1)
   \       0x96   0x1D20             ADDS     R0,R4,#+4
   \       0x98   0x0006             MOVS     R6,R0
    661              if (p_pend_list->HeadPtr == DEF_NULL) {                     // See if task(s) waiting?
   \       0x9A   0x6830             LDR      R0,[R6, #+0]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD102             BNE.N    ??OSSemSet_11
    662                p_sem->Ctr = cnt;                                         // No, OK to set the value
   \       0xA0   0xF8C4 0xA00C      STR      R10,[R4, #+12]
   \       0xA4   0xE007             B.N      ??OSSemSet_10
    663              } else {
    664                RTOS_ERR_SET(*p_err, RTOS_ERR_OS_TASK_WAITING);
   \                     ??OSSemSet_11: (+1)
   \       0xA6   0x202E             MOVS     R0,#+46
   \       0xA8   0x7028             STRB     R0,[R5, #+0]
   \       0xAA   0x606F             STR      R7,[R5, #+4]
   \       0xAC   0xF44F 0x7026      MOV      R0,#+664
   \       0xB0   0x60A8             STR      R0,[R5, #+8]
   \       0xB2   0xF8C5 0x800C      STR      R8,[R5, #+12]
    665              }
    666            }
    667            CORE_EXIT_ATOMIC();
   \                     ??OSSemSet_10: (+1)
   \       0xB6   0x4648             MOV      R0,R9
   \       0xB8   0x.... 0x....      BL       CORE_ExitAtomic
    668          }
   \       0xBC   0xE8BD 0x87F0      POP      {R4-R10,PC}
    669          
    670          /********************************************************************************************************
    671           ********************************************************************************************************
    672           *                                           INTERNAL FUNCTIONS
    673           ********************************************************************************************************
    674           *******************************************************************************************************/
    675          
    676          /****************************************************************************************************//**
    677           *                                               OS_SemClr()
    678           *
    679           * @brief    This function is called by OSSemDel() to clear the contents of a semaphore.
    680           *
    681           * @param    p_sem   Pointer to the semaphore to clear.
    682           *
    683           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    684           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    685          void OS_SemClr(OS_SEM *p_sem)
    686          {
   \                     OS_SemClr: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    687          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    688            p_sem->Type = OS_OBJ_TYPE_NONE;                               // Mark the data structure as a NONE
   \        0x4   0x....             LDR.N    R0,??DataTable6_11
   \        0x6   0x6020             STR      R0,[R4, #+0]
    689          #endif
    690            p_sem->Ctr = 0u;                                              // Set semaphore value
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x60E0             STR      R0,[R4, #+12]
    691          #if (OS_CFG_TS_EN == DEF_ENABLED)
    692            p_sem->TS = 0u;                                               // Clear the time stamp
    693          #endif
    694          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    695            p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
    696          #endif
    697            OS_PendListInit(&p_sem->PendList);                            // Initialize the waiting list
   \        0xC   0x1D20             ADDS     R0,R4,#+4
   \        0xE   0x.... 0x....      BL       OS_PendListInit
    698          }
   \       0x12   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     `OSSemCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x414D'4553        DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x....'....        DC32     `OSSemDel::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x....'....        DC32     `OSSemPend::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \        0x0   0x....'....        DC32     `OSSemPendAbort::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \        0x0   0x....'....        DC32     `OSSemPost::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \        0x0   0x....'....        DC32     `OSSemSet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \        0x0   0x454E'4F4E        DC32     0x454e4f4e

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x6B, 0x65, 0x72, 0x6E, 0x65
   \              0x5C 0x6B    
   \              0x65 0x72    
   \              0x6E 0x65
   \       0x58   0x6C 0x5C          DC8 0x6C, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65
   \       0x60   0x5C 0x6F          DC8 0x5C, 0x6F, 0x73, 0x5F, 0x73, 0x65, 0x6D, 0x2E
   \              0x73 0x5F    
   \              0x73 0x65    
   \              0x6D 0x2E
   \       0x68   0x63 0x00          DC8 0x63, 0
   \       0x6A                      DS8 2
    699          
    700          /****************************************************************************************************//**
    701           *                                           OS_SemDbgListAdd()
    702           *
    703           * @brief    Add a semaphore to the semaphore debug list.
    704           *
    705           * @param    p_sem   Pointer to the semaphore to add.
    706           *
    707           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    708           *******************************************************************************************************/
    709          
    710          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    711          void OS_SemDbgListAdd(OS_SEM *p_sem)
    712          {
    713            p_sem->DbgNamePtr = (CPU_CHAR *)((void *)" ");
    714            p_sem->DbgPrevPtr = DEF_NULL;
    715            if (OSSemDbgListPtr == DEF_NULL) {
    716              p_sem->DbgNextPtr = DEF_NULL;
    717            } else {
    718              p_sem->DbgNextPtr = OSSemDbgListPtr;
    719              OSSemDbgListPtr->DbgPrevPtr = p_sem;
    720            }
    721            OSSemDbgListPtr = p_sem;
    722          }
    723          
    724          /****************************************************************************************************//**
    725           *                                           OS_SemDbgListRemove()
    726           *
    727           * @brief    Remove a semaphore from the semaphore debug list.
    728           *
    729           * @param    p_sem   Pointer to the semaphore to remove.
    730           *
    731           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    732           *******************************************************************************************************/
    733          void OS_SemDbgListRemove(OS_SEM *p_sem)
    734          {
    735            OS_SEM *p_sem_next;
    736            OS_SEM *p_sem_prev;
    737          
    738            p_sem_prev = p_sem->DbgPrevPtr;
    739            p_sem_next = p_sem->DbgNextPtr;
    740          
    741            if (p_sem_prev == DEF_NULL) {
    742              OSSemDbgListPtr = p_sem_next;
    743              if (p_sem_next != DEF_NULL) {
    744                p_sem_next->DbgPrevPtr = DEF_NULL;
    745              }
    746              p_sem->DbgNextPtr = DEF_NULL;
    747            } else if (p_sem_next == DEF_NULL) {
    748              p_sem_prev->DbgNextPtr = DEF_NULL;
    749              p_sem->DbgPrevPtr = DEF_NULL;
    750            } else {
    751              p_sem_prev->DbgNextPtr = p_sem_next;
    752              p_sem_next->DbgPrevPtr = p_sem_prev;
    753              p_sem->DbgNextPtr = DEF_NULL;
    754              p_sem->DbgPrevPtr = DEF_NULL;
    755            }
    756          }
    757          #endif
    758          #endif
    759          
    760          /********************************************************************************************************
    761           ********************************************************************************************************
    762           *                                   DEPENDENCIES & AVAIL CHECK(S) END
    763           ********************************************************************************************************
    764           *******************************************************************************************************/
    765          
    766          #endif // (defined(RTOS_MODULE_KERNEL_AVAIL))

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSSemCreate
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CORE_InIrqContext
        24   -> CPU_SW_Exception
        24   -> OS_PendListInit
        24   -> __aeabi_memclr4
      40   OSSemDel
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> CORE_InIrqContext
        40   -> CPU_SW_Exception
        40   -> OSSched
        40   -> OS_PendAbort
        40   -> OS_SemClr
      32   OSSemPend
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> CORE_InIrqContext
        32   -> CORE_IrqIsDisabled
        32   -> CPU_SW_Exception
        32   -> OSSched
        32   -> OS_Pend
      40   OSSemPendAbort
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> CORE_InIrqContext
        40   -> CPU_SW_Exception
        40   -> OSSched
        40   -> OS_PendAbort
      40   OSSemPost
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> CPU_SW_Exception
        40   -> OSSched
        40   -> OS_Post
      32   OSSemSet
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> CORE_InIrqContext
        32   -> CPU_SW_Exception
       8   OS_SemClr
         8   -> OS_PendListInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
     108  ?_0
     142  OSSemCreate
     358  OSSemDel
     584  OSSemPend
     356  OSSemPendAbort
     344  OSSemPost
     192  OSSemSet
      20  OS_SemClr
      92  -- Other

 
   200 bytes in section .rodata
 2'044 bytes in section .text
 
 2'044 bytes of CODE  memory
   200 bytes of CONST memory

Errors: none
Warnings: none
