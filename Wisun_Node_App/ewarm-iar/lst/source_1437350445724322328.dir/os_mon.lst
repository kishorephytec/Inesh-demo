###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:02
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_mon.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_mon.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_mon.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_mon.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir\os_mon.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_mon.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_mon.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Kernel - Monitor Management
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                       DEPENDENCIES & AVAIL CHECK(S)
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <rtos_description.h>
     25          
     26          #if (defined(RTOS_MODULE_KERNEL_AVAIL))
     27          
     28          /********************************************************************************************************
     29           ********************************************************************************************************
     30           *                                               INCLUDE FILES
     31           ********************************************************************************************************
     32           *******************************************************************************************************/
     33          
     34          #define  MICRIUM_SOURCE
     35          #include "../include/os.h"
     36          #include "os_priv.h"
     37          
     38          #include  <em_core.h>
     39          
     40          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     41          const CPU_CHAR *os_mon__c = "$Id: $";
     42          #endif
     43          
     44          /********************************************************************************************************
     45           ********************************************************************************************************
     46           *                                           GLOBAL FUNCTIONS
     47           ********************************************************************************************************
     48           *******************************************************************************************************/
     49          
     50          #if (OS_CFG_MON_EN == DEF_ENABLED)
     51          /****************************************************************************************************//**
     52           *                                               OSMonCreate()
     53           *
     54           * @brief    Creates a monitor.
     55           *
     56           * @param    p_mon       Pointer to the monitor to initialize. Your application is responsible for
     57           *                       allocating storage space for the monitor.
     58           *
     59           * @param    p_name      Pointer to the name to assign to this monitor.
     60           *
     61           * @param    p_mon_data  Pointer to the monitor's global data.
     62           *
     63           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
     64           *                       from this function:
     65           *                           - RTOS_ERR_NONE
     66           *                           - RTOS_ERR_OS_ILLEGAL_RUN_TIME
     67           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     68          void OSMonCreate(OS_MON   *p_mon,
     69                           CPU_CHAR *p_name,
     70                           void     *p_mon_data,
     71                           RTOS_ERR *p_err)
     72          {
   \                     OSMonCreate: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0015             MOVS     R5,R2
   \        0x6   0x001E             MOVS     R6,R3
     73            CORE_DECLARE_IRQ_STATE;
     74          
     75            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD101             BNE.N    ??OSMonCreate_0
   \        0xC   0x.... 0x....      BL       CPU_SW_Exception
     76          
     77          #ifdef OS_SAFETY_CRITICAL_IEC61508
     78            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     79              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
     80              return;
     81            }
     82          #endif
     83          
     84            //                                                               Not allowed to call from an ISR
     85            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSMonCreate_0: (+1)
   \       0x10   0x.... 0x....      BL       CORE_InIrqContext
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??OSMonCreate_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??OSMonCreate_2
   \                     ??OSMonCreate_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??OSMonCreate_2: (+1)
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD10A             BNE.N    ??OSMonCreate_3
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0x7030             STRB     R0,[R6, #+0]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable3
   \       0x2C   0x6070             STR      R0,[R6, #+4]
   \       0x2E   0x2055             MOVS     R0,#+85
   \       0x30   0x60B0             STR      R0,[R6, #+8]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \       0x36   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSMonCreate_4: (+1)
   \       0x38   0xE7FE             B.N      ??OSMonCreate_4
     86          
     87            //                                                               Validate 'p_mon'
     88            OS_ASSERT_DBG_ERR_SET((p_mon != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSMonCreate_3: (+1)
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD10A             BNE.N    ??OSMonCreate_5
   \       0x3E   0x200A             MOVS     R0,#+10
   \       0x40   0x7030             STRB     R0,[R6, #+0]
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable3
   \       0x46   0x6070             STR      R0,[R6, #+4]
   \       0x48   0x2058             MOVS     R0,#+88
   \       0x4A   0x60B0             STR      R0,[R6, #+8]
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \       0x50   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSMonCreate_6: (+1)
   \       0x52   0xE7FE             B.N      ??OSMonCreate_6
     89          
     90            CORE_ENTER_ATOMIC();
   \                     ??OSMonCreate_5: (+1)
   \       0x54   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x58   0x0007             MOVS     R7,R0
     91          
     92            *p_mon = (OS_MON){ 0 };
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x2110             MOVS     R1,#+16
   \       0x5E   0x.... 0x....      BL       __aeabi_memclr4
     93          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
     94            p_mon->Type = OS_OBJ_TYPE_MON;                                // Mark the data structure as a monitor
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \       0x66   0x6020             STR      R0,[R4, #+0]
     95          #endif
     96          
     97          #if (OS_CFG_DBG_EN == DEF_ENABLED)
     98            p_mon->NamePtr = p_name;                                      // Save the name of the monitor
     99          #else
    100            (void)&p_name;
   \       0x68   0x4668             MOV      R0,SP
    101          #endif
    102          
    103            OS_PendListInit(&p_mon->PendList);
   \       0x6A   0x1D20             ADDS     R0,R4,#+4
   \       0x6C   0x.... 0x....      BL       OS_PendListInit
    104          
    105          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    106            OS_MonDbgListAdd(p_mon);
    107            OSMonQty++;
    108          #endif
    109          
    110            if (p_mon_data != DEF_NULL) {
   \       0x70   0x2D00             CMP      R5,#+0
   \       0x72   0xD000             BEQ.N    ??OSMonCreate_7
    111              p_mon->MonDataPtr = p_mon_data;
   \       0x74   0x60E5             STR      R5,[R4, #+12]
    112            }
    113          
    114            CORE_EXIT_ATOMIC();
   \                     ??OSMonCreate_7: (+1)
   \       0x76   0x0038             MOVS     R0,R7
   \       0x78   0x.... 0x....      BL       CORE_ExitAtomic
    115          
    116            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x7030             STRB     R0,[R6, #+0]
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable3
   \       0x84   0x6070             STR      R0,[R6, #+4]
   \       0x86   0x2074             MOVS     R0,#+116
   \       0x88   0x60B0             STR      R0,[R6, #+8]
   \       0x8A   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \       0x8E   0x60F0             STR      R0,[R6, #+12]
    117          }
   \       0x90   0xBDF1             POP      {R0,R4-R7,PC}
    118          
    119          /****************************************************************************************************//**
    120           *                                               OSMonDel()
    121           *
    122           * @brief    This function deletes a monitor.
    123           *
    124           * @param    p_mon   Pointer to the monitor to delete.
    125           *
    126           * @param    opt     Determines delete options as follows:
    127           *                       - OS_OPT_DEL_NO_PEND  Deletes the monitor ONLY if there are no tasks pending.
    128           *                       - OS_OPT_DEL_ALWAYS   Deletes the monitor even if there are tasks waiting.
    129           *                   In this case, all pending tasks will be ready.
    130           *
    131           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    132           *                   from this function:
    133           *                       - RTOS_ERR_NONE
    134           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    135           *                       - RTOS_ERR_OS_TASK_WAITING
    136           *                       - RTOS_ERR_NOT_READY
    137           *
    138           * @return   == 0    If there were no tasks waiting on the monitor, or upon error.
    139           *           >  0    If one or more tasks are waiting on the monitor are now ready and informed.
    140           *
    141           * @note     (1) Use this function with care. Tasks that would normally expect the presence of
    142           *               the monitor MUST check the return code of OSMonOp().
    143           *
    144           * @note     (2) Because ALL tasks pending on the monitor will be ready, be careful in applications
    145           *               where the monitor is used for mutual exclusion because the resource(s) will no longer
    146           *               be guarded by the monitor.
    147           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    148          OS_OBJ_QTY OSMonDel(OS_MON   *p_mon,
    149                              OS_OPT   opt,
    150                              RTOS_ERR *p_err)
    151          {
   \                     OSMonDel: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x0015             MOVS     R5,R2
    152            OS_OBJ_QTY   nbr_tasks;
    153            OS_PEND_LIST *p_pend_list;
    154            OS_TCB       *p_tcb;
    155            CORE_DECLARE_IRQ_STATE;
    156          
    157            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSMonDel_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    158          
    159          #ifdef OS_SAFETY_CRITICAL_IEC61508
    160            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    161              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
    162              return (0u);
    163            }
    164          #endif
    165          
    166            //                                                               Not allowed to call from an ISR
    167            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSMonDel_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_InIrqContext
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??OSMonDel_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??OSMonDel_2
   \                     ??OSMonDel_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??OSMonDel_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10A             BNE.N    ??OSMonDel_3
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable3
   \       0x2E   0x6068             STR      R0,[R5, #+4]
   \       0x30   0x20A7             MOVS     R0,#+167
   \       0x32   0x60A8             STR      R0,[R5, #+8]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \       0x38   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSMonDel_4: (+1)
   \       0x3A   0xE7FE             B.N      ??OSMonDel_4
    168          
    169            //                                                               Make sure kernel is running.
    170            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSMonDel_3: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \       0x40   0x7800             LDRB     R0,[R0, #+0]
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD00B             BEQ.N    ??OSMonDel_5
    171              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0x7028             STRB     R0,[R5, #+0]
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable3
   \       0x4E   0x6068             STR      R0,[R5, #+4]
   \       0x50   0x20AB             MOVS     R0,#+171
   \       0x52   0x60A8             STR      R0,[R5, #+8]
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \       0x58   0x60E8             STR      R0,[R5, #+12]
    172              return (0u);
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE072             B.N      ??OSMonDel_6
    173            }
    174          
    175            //                                                               Validate 'p_mon'
    176            OS_ASSERT_DBG_ERR_SET((p_mon != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??OSMonDel_5: (+1)
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xD108             BNE.N    ??OSMonDel_7
   \       0x62   0x200A             MOVS     R0,#+10
   \       0x64   0x7028             STRB     R0,[R5, #+0]
   \       0x66   0x....             LDR.N    R0,??DataTable3
   \       0x68   0x6068             STR      R0,[R5, #+4]
   \       0x6A   0x20B0             MOVS     R0,#+176
   \       0x6C   0x60A8             STR      R0,[R5, #+8]
   \       0x6E   0x....             LDR.N    R0,??DataTable3_3
   \       0x70   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSMonDel_8: (+1)
   \       0x72   0xE7FE             B.N      ??OSMonDel_8
    177          
    178            //                                                               Validate object type
    179            OS_ASSERT_DBG_ERR_SET((p_mon->Type == OS_OBJ_TYPE_MON), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
   \                     ??OSMonDel_7: (+1)
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x....             LDR.N    R0,??DataTable3_2
   \       0x78   0x4281             CMP      R1,R0
   \       0x7A   0xD008             BEQ.N    ??OSMonDel_9
   \       0x7C   0x200C             MOVS     R0,#+12
   \       0x7E   0x7028             STRB     R0,[R5, #+0]
   \       0x80   0x....             LDR.N    R0,??DataTable3
   \       0x82   0x6068             STR      R0,[R5, #+4]
   \       0x84   0x20B3             MOVS     R0,#+179
   \       0x86   0x60A8             STR      R0,[R5, #+8]
   \       0x88   0x....             LDR.N    R0,??DataTable3_3
   \       0x8A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSMonDel_10: (+1)
   \       0x8C   0xE7FE             B.N      ??OSMonDel_10
    180          
    181            CORE_ENTER_ATOMIC();
   \                     ??OSMonDel_9: (+1)
   \       0x8E   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x92   0x0007             MOVS     R7,R0
    182            p_pend_list = &p_mon->PendList;
   \       0x94   0xF114 0x0804      ADDS     R8,R4,#+4
    183            nbr_tasks = 0u;
   \       0x98   0xF05F 0x0900      MOVS     R9,#+0
    184            switch (opt) {
   \       0x9C   0x4650             MOV      R0,R10
   \       0x9E   0xB280             UXTH     R0,R0
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD002             BEQ.N    ??OSMonDel_11
   \       0xA4   0x2801             CMP      R0,#+1
   \       0xA6   0xD01F             BEQ.N    ??OSMonDel_12
   \       0xA8   0xE03E             B.N      ??OSMonDel_13
    185              case OS_OPT_DEL_NO_PEND:                                    // Delete monitor only if no task waiting
    186                if (p_pend_list->HeadPtr == DEF_NULL) {
   \                     ??OSMonDel_11: (+1)
   \       0xAA   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD10E             BNE.N    ??OSMonDel_14
    187           #if (OS_CFG_DBG_EN == DEF_ENABLED)
    188                  OS_MonDbgListRemove(p_mon);
    189                  OSMonQty--;
    190           #endif
    191                  OS_MonClr(p_mon);
   \       0xB2   0x0020             MOVS     R0,R4
   \       0xB4   0x.... 0x....      BL       OS_MonClr
    192                  CORE_EXIT_ATOMIC();
   \       0xB8   0x0038             MOVS     R0,R7
   \       0xBA   0x.... 0x....      BL       CORE_ExitAtomic
    193                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0x7028             STRB     R0,[R5, #+0]
   \       0xC2   0x....             LDR.N    R0,??DataTable3
   \       0xC4   0x6068             STR      R0,[R5, #+4]
   \       0xC6   0x20C1             MOVS     R0,#+193
   \       0xC8   0x60A8             STR      R0,[R5, #+8]
   \       0xCA   0x....             LDR.N    R0,??DataTable3_3
   \       0xCC   0x60E8             STR      R0,[R5, #+12]
   \       0xCE   0xE00A             B.N      ??OSMonDel_15
    194                } else {
    195                  CORE_EXIT_ATOMIC();
   \                     ??OSMonDel_14: (+1)
   \       0xD0   0x0038             MOVS     R0,R7
   \       0xD2   0x.... 0x....      BL       CORE_ExitAtomic
    196                  RTOS_ERR_SET(*p_err, RTOS_ERR_OS_TASK_WAITING);
   \       0xD6   0x202E             MOVS     R0,#+46
   \       0xD8   0x7028             STRB     R0,[R5, #+0]
   \       0xDA   0x....             LDR.N    R0,??DataTable3
   \       0xDC   0x6068             STR      R0,[R5, #+4]
   \       0xDE   0x20C4             MOVS     R0,#+196
   \       0xE0   0x60A8             STR      R0,[R5, #+8]
   \       0xE2   0x....             LDR.N    R0,??DataTable3_3
   \       0xE4   0x60E8             STR      R0,[R5, #+12]
    197                }
    198                break;
   \                     ??OSMonDel_15: (+1)
   \       0xE6   0xE02B             B.N      ??OSMonDel_16
    199          
    200              case OS_OPT_DEL_ALWAYS:                                     // Always delete the monitor
    201                while (p_pend_list->HeadPtr != DEF_NULL) {                // Remove all tasks on the pend list
   \                     ??OSMonDel_12: (+1)
   \       0xE8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD00A             BEQ.N    ??OSMonDel_17
    202                  p_tcb = p_pend_list->HeadPtr;
   \       0xF0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xF4   0x0006             MOVS     R6,R0
    203                  OS_PendAbort(p_tcb,
    204                               0,
    205                               OS_STATUS_PEND_DEL);
   \       0xF6   0x2202             MOVS     R2,#+2
   \       0xF8   0x2100             MOVS     R1,#+0
   \       0xFA   0x0030             MOVS     R0,R6
   \       0xFC   0x.... 0x....      BL       OS_PendAbort
    206                  nbr_tasks++;
   \      0x100   0xF119 0x0901      ADDS     R9,R9,#+1
   \      0x104   0xE7F0             B.N      ??OSMonDel_12
    207                }
    208           #if (OS_CFG_DBG_EN == DEF_ENABLED)
    209                OS_MonDbgListRemove(p_mon);
    210                OSMonQty--;
    211           #endif
    212                OS_MonClr(p_mon);
   \                     ??OSMonDel_17: (+1)
   \      0x106   0x0020             MOVS     R0,R4
   \      0x108   0x.... 0x....      BL       OS_MonClr
    213                CORE_EXIT_ATOMIC();
   \      0x10C   0x0038             MOVS     R0,R7
   \      0x10E   0x.... 0x....      BL       CORE_ExitAtomic
    214                OSSched();                                                // Find highest priority task ready to run
   \      0x112   0x.... 0x....      BL       OSSched
    215                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x116   0x2000             MOVS     R0,#+0
   \      0x118   0x7028             STRB     R0,[R5, #+0]
   \      0x11A   0x....             LDR.N    R0,??DataTable3
   \      0x11C   0x6068             STR      R0,[R5, #+4]
   \      0x11E   0x20D7             MOVS     R0,#+215
   \      0x120   0x60A8             STR      R0,[R5, #+8]
   \      0x122   0x....             LDR.N    R0,??DataTable3_3
   \      0x124   0x60E8             STR      R0,[R5, #+12]
    216                break;
   \      0x126   0xE00B             B.N      ??OSMonDel_16
    217          
    218              default:
    219                CORE_EXIT_ATOMIC();
   \                     ??OSMonDel_13: (+1)
   \      0x128   0x0038             MOVS     R0,R7
   \      0x12A   0x.... 0x....      BL       CORE_ExitAtomic
    220                OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_INVALID_ARG, 0u);
   \      0x12E   0x2008             MOVS     R0,#+8
   \      0x130   0x7028             STRB     R0,[R5, #+0]
   \      0x132   0x....             LDR.N    R0,??DataTable3
   \      0x134   0x6068             STR      R0,[R5, #+4]
   \      0x136   0x20DC             MOVS     R0,#+220
   \      0x138   0x60A8             STR      R0,[R5, #+8]
   \      0x13A   0x....             LDR.N    R0,??DataTable3_3
   \      0x13C   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSMonDel_18: (+1)
   \      0x13E   0xE7FE             B.N      ??OSMonDel_18
    221            }
    222            return (nbr_tasks);
   \                     ??OSMonDel_16: (+1)
   \      0x140   0x4648             MOV      R0,R9
   \      0x142   0xB280             UXTH     R0,R0
   \                     ??OSMonDel_6: (+1)
   \      0x144   0xE8BD 0x87F0      POP      {R4-R10,PC}
    223          }
    224          
    225          /****************************************************************************************************//**
    226           *                                                   OSMonOp()
    227           *
    228           * @brief    Performs an operation on a monitor.
    229           *
    230           * @param    p_mon       Pointer to the monitor.
    231           *
    232           * @param    timeout     Optional timeout to be applied if the monitor blocks (pending).
    233           *
    234           * @param    p_arg       Argument of the monitor.
    235           *
    236           * @param    p_on_enter  Callback called at the entry of OSMonOp().
    237           *
    238           * @param    p_on_eval   Callback to be registered as the monitor's evaluation function.
    239           *
    240           * @param    opt         Possible option :
    241           *                           - OS_OPT_POST_NO_SCHED    Do not call the scheduler.
    242           *
    243           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
    244           *                       from this function:
    245           *                           - RTOS_ERR_NONE
    246           *                           - RTOS_ERR_OS_OBJ_DEL
    247           *                           - RTOS_ERR_ABORT
    248           *                           - RTOS_ERR_TIMEOUT
    249           *                           - RTOS_ERR_NOT_READY
    250           *                           - RTOS_ERR_INVALID_STATE
    251           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    252          void OSMonOp(OS_MON              *p_mon,
    253                       OS_TICK             timeout,
    254                       void                *p_arg,
    255                       OS_MON_ON_ENTER_PTR p_on_enter,
    256                       OS_MON_ON_EVAL_PTR  p_on_eval,
    257                       OS_OPT              opt,
    258                       RTOS_ERR            *p_err)
    259          {
   \                     OSMonOp: (+1)
   \        0x0   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x4693             MOV      R11,R2
   \        0xA   0x9F12             LDR      R7,[SP, #+72]
   \        0xC   0x9E14             LDR      R6,[SP, #+80]
    260            CPU_INT32U   op_res;
    261            CPU_INT32U   mon_res;
    262            OS_PEND_LIST *p_pend_list;
    263            OS_TCB       *p_tcb;
    264            OS_TCB       *p_tcb_next;
    265            void         *p_eval_data;
    266            CPU_BOOLEAN  sched;
    267            CORE_DECLARE_IRQ_STATE;
    268          
    269            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xE   0x2E00             CMP      R6,#+0
   \       0x10   0xD101             BNE.N    ??OSMonOp_0
   \       0x12   0x.... 0x....      BL       CPU_SW_Exception
    270          
    271            //                                                               Make sure kernel is running.
    272            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSMonOp_0: (+1)
   \       0x16   0x....             LDR.N    R0,??DataTable3_4
   \       0x18   0x7800             LDRB     R0,[R0, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD009             BEQ.N    ??OSMonOp_1
    273              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x7030             STRB     R0,[R6, #+0]
   \       0x22   0x....             LDR.N    R0,??DataTable3
   \       0x24   0x6070             STR      R0,[R6, #+4]
   \       0x26   0xF240 0x1011      MOVW     R0,#+273
   \       0x2A   0x60B0             STR      R0,[R6, #+8]
   \       0x2C   0x....             LDR.N    R0,??DataTable3_5
   \       0x2E   0x60F0             STR      R0,[R6, #+12]
    274              return;
   \       0x30   0xE0EC             B.N      ??OSMonOp_2
    275            }
    276          
    277            //                                                               Validate 'p_mon'
    278            OS_ASSERT_DBG_ERR_SET((p_mon != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSMonOp_1: (+1)
   \       0x32   0x2D00             CMP      R5,#+0
   \       0x34   0xD109             BNE.N    ??OSMonOp_3
   \       0x36   0x200A             MOVS     R0,#+10
   \       0x38   0x7030             STRB     R0,[R6, #+0]
   \       0x3A   0x....             LDR.N    R0,??DataTable3
   \       0x3C   0x6070             STR      R0,[R6, #+4]
   \       0x3E   0xF44F 0x708B      MOV      R0,#+278
   \       0x42   0x60B0             STR      R0,[R6, #+8]
   \       0x44   0x....             LDR.N    R0,??DataTable3_5
   \       0x46   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSMonOp_4: (+1)
   \       0x48   0xE7FE             B.N      ??OSMonOp_4
    279          
    280            //                                                               Validate object type
    281            OS_ASSERT_DBG_ERR_SET((p_mon->Type == OS_OBJ_TYPE_MON), *p_err, RTOS_ERR_INVALID_TYPE,; );
   \                     ??OSMonOp_3: (+1)
   \       0x4A   0x6829             LDR      R1,[R5, #+0]
   \       0x4C   0x....             LDR.N    R0,??DataTable3_2
   \       0x4E   0x4281             CMP      R1,R0
   \       0x50   0xD009             BEQ.N    ??OSMonOp_5
   \       0x52   0x200C             MOVS     R0,#+12
   \       0x54   0x7030             STRB     R0,[R6, #+0]
   \       0x56   0x....             LDR.N    R0,??DataTable3
   \       0x58   0x6070             STR      R0,[R6, #+4]
   \       0x5A   0xF240 0x1019      MOVW     R0,#+281
   \       0x5E   0x60B0             STR      R0,[R6, #+8]
   \       0x60   0x....             LDR.N    R0,??DataTable3_5
   \       0x62   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSMonOp_6: (+1)
   \       0x64   0xE7FE             B.N      ??OSMonOp_6
    282          
    283            //                                                               Not allowed in atomic/critical sections
    284            OS_ASSERT_DBG_ERR_SET((!CORE_IrqIsDisabled()), *p_err, RTOS_ERR_INVALID_STATE,; );
   \                     ??OSMonOp_5: (+1)
   \       0x66   0x.... 0x....      BL       CORE_IrqIsDisabled
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD101             BNE.N    ??OSMonOp_7
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0xE000             B.N      ??OSMonOp_8
   \                     ??OSMonOp_7: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \                     ??OSMonOp_8: (+1)
   \       0x74   0xB2C0             UXTB     R0,R0
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD109             BNE.N    ??OSMonOp_9
   \       0x7A   0x201F             MOVS     R0,#+31
   \       0x7C   0x7030             STRB     R0,[R6, #+0]
   \       0x7E   0x....             LDR.N    R0,??DataTable3
   \       0x80   0x6070             STR      R0,[R6, #+4]
   \       0x82   0xF44F 0x708E      MOV      R0,#+284
   \       0x86   0x60B0             STR      R0,[R6, #+8]
   \       0x88   0x....             LDR.N    R0,??DataTable3_5
   \       0x8A   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSMonOp_10: (+1)
   \       0x8C   0xE7FE             B.N      ??OSMonOp_10
    285          
    286            sched = DEF_NO;
   \                     ??OSMonOp_9: (+1)
   \       0x8E   0xF05F 0x0800      MOVS     R8,#+0
    287          
    288            CORE_ENTER_ATOMIC();
   \       0x92   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x96   0x9002             STR      R0,[SP, #+8]
    289          
    290            if (p_on_enter != DEF_NULL) {
   \       0x98   0x9808             LDR      R0,[SP, #+32]
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD005             BEQ.N    ??OSMonOp_11
    291              op_res = (*p_on_enter)(p_mon, p_arg);
   \       0x9E   0x4659             MOV      R1,R11
   \       0xA0   0x0028             MOVS     R0,R5
   \       0xA2   0x9A08             LDR      R2,[SP, #+32]
   \       0xA4   0x4790             BLX      R2
   \       0xA6   0x4681             MOV      R9,R0
   \       0xA8   0xE001             B.N      ??OSMonOp_12
    292            } else {
    293              op_res = OS_MON_RES_BLOCK | OS_MON_RES_STOP_EVAL;
   \                     ??OSMonOp_11: (+1)
   \       0xAA   0xF05F 0x0903      MOVS     R9,#+3
    294            }
    295          
    296            if (DEF_BIT_IS_SET(op_res, OS_MON_RES_BLOCK) == DEF_YES) {
   \                     ??OSMonOp_12: (+1)
   \       0xAE   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \       0xB2   0xD506             BPL.N    ??OSMonOp_13
    297              OS_Pend((OS_PEND_OBJ *)(p_mon),                             // Block task pending on Condition Variable
    298                      OS_TASK_PEND_ON_COND_VAR,
    299                      timeout);
   \       0xB4   0x9A07             LDR      R2,[SP, #+28]
   \       0xB6   0x2108             MOVS     R1,#+8
   \       0xB8   0x0028             MOVS     R0,R5
   \       0xBA   0x.... 0x....      BL       OS_Pend
    300          
    301              sched = DEF_YES;
   \       0xBE   0x2001             MOVS     R0,#+1
   \       0xC0   0x4680             MOV      R8,R0
    302            }
    303          
    304            OSTCBCurPtr->MonData.p_eval_data = p_arg;
   \                     ??OSMonOp_13: (+1)
   \       0xC2   0x.... 0x....      LDR.W    R10,??DataTable3_6
   \       0xC6   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xCA   0xF8C0 0xB084      STR      R11,[R0, #+132]
    305            OSTCBCurPtr->MonData.p_on_eval = p_on_eval;
   \       0xCE   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xD2   0xF8C0 0x7088      STR      R7,[R0, #+136]
    306          
    307            if (DEF_BIT_IS_CLR(op_res, OS_MON_RES_STOP_EVAL) == DEF_YES) {
   \       0xD6   0x4648             MOV      R0,R9
   \       0xD8   0x0840             LSRS     R0,R0,#+1
   \       0xDA   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xDE   0xF090 0x0001      EORS     R0,R0,#0x1
   \       0xE2   0x2801             CMP      R0,#+1
   \       0xE4   0xD13E             BNE.N    ??OSMonOp_14
    308              p_pend_list = &p_mon->PendList;
   \       0xE6   0x1D28             ADDS     R0,R5,#+4
   \       0xE8   0x9003             STR      R0,[SP, #+12]
    309              if (p_pend_list->HeadPtr != DEF_NULL) {
   \       0xEA   0x9803             LDR      R0,[SP, #+12]
   \       0xEC   0x6800             LDR      R0,[R0, #+0]
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD038             BEQ.N    ??OSMonOp_14
    310                p_tcb = p_pend_list->HeadPtr;
   \       0xF2   0x9803             LDR      R0,[SP, #+12]
   \       0xF4   0x6800             LDR      R0,[R0, #+0]
   \       0xF6   0x0004             MOVS     R4,R0
    311                while (p_tcb != DEF_NULL) {
   \                     ??OSMonOp_15: (+1)
   \       0xF8   0x2C00             CMP      R4,#+0
   \       0xFA   0xD033             BEQ.N    ??OSMonOp_14
    312                  p_tcb_next = p_tcb->PendNextPtr;
   \       0xFC   0x69A0             LDR      R0,[R4, #+24]
   \       0xFE   0x9005             STR      R0,[SP, #+20]
    313          
    314                  p_on_eval = p_tcb->MonData.p_on_eval;
   \      0x100   0xF8D4 0x0088      LDR      R0,[R4, #+136]
   \      0x104   0x0007             MOVS     R7,R0
    315                  p_eval_data = p_tcb->MonData.p_eval_data;
   \      0x106   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \      0x10A   0x9004             STR      R0,[SP, #+16]
    316          
    317                  if (p_on_eval != DEF_NULL) {
   \      0x10C   0x0038             MOVS     R0,R7
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD005             BEQ.N    ??OSMonOp_16
    318                    mon_res = (*p_on_eval)(p_mon, p_eval_data, p_arg);
   \      0x112   0x465A             MOV      R2,R11
   \      0x114   0x9904             LDR      R1,[SP, #+16]
   \      0x116   0x0028             MOVS     R0,R5
   \      0x118   0x47B8             BLX      R7
   \      0x11A   0x9001             STR      R0,[SP, #+4]
   \      0x11C   0xE001             B.N      ??OSMonOp_17
    319                  } else {
    320                    mon_res = OS_MON_RES_STOP_EVAL;
   \                     ??OSMonOp_16: (+1)
   \      0x11E   0x2002             MOVS     R0,#+2
   \      0x120   0x9001             STR      R0,[SP, #+4]
    321                  }
    322          
    323                  if (DEF_BIT_IS_CLR(mon_res, OS_MON_RES_BLOCK) == DEF_YES) {
   \                     ??OSMonOp_17: (+1)
   \      0x122   0x9801             LDR      R0,[SP, #+4]
   \      0x124   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x128   0xF090 0x0001      EORS     R0,R0,#0x1
   \      0x12C   0x2801             CMP      R0,#+1
   \      0x12E   0xD112             BNE.N    ??OSMonOp_18
    324                    OS_Post((OS_PEND_OBJ *)(p_mon), p_tcb, DEF_NULL, 0u, 0u);
   \      0x130   0x2000             MOVS     R0,#+0
   \      0x132   0x9000             STR      R0,[SP, #+0]
   \      0x134   0x2300             MOVS     R3,#+0
   \      0x136   0x2200             MOVS     R2,#+0
   \      0x138   0x0021             MOVS     R1,R4
   \      0x13A   0x0028             MOVS     R0,R5
   \      0x13C   0x.... 0x....      BL       OS_Post
    325                    if (DEF_BIT_IS_CLR(opt, OS_OPT_POST_NO_SCHED) == DEF_YES) {
   \      0x140   0xF8BD 0x004C      LDRH     R0,[SP, #+76]
   \      0x144   0xB280             UXTH     R0,R0
   \      0x146   0x0BC0             LSRS     R0,R0,#+15
   \      0x148   0xF090 0x0001      EORS     R0,R0,#0x1
   \      0x14C   0xB280             UXTH     R0,R0
   \      0x14E   0x2801             CMP      R0,#+1
   \      0x150   0xD101             BNE.N    ??OSMonOp_18
    326                      sched = DEF_YES;
   \      0x152   0x2001             MOVS     R0,#+1
   \      0x154   0x4680             MOV      R8,R0
    327                    }
    328                  }
    329          
    330                  if (DEF_BIT_IS_SET(mon_res, OS_MON_RES_STOP_EVAL) == DEF_YES) {
   \                     ??OSMonOp_18: (+1)
   \      0x156   0x9801             LDR      R0,[SP, #+4]
   \      0x158   0x0840             LSRS     R0,R0,#+1
   \      0x15A   0x07C0             LSLS     R0,R0,#+31
   \      0x15C   0xD402             BMI.N    ??OSMonOp_14
    331                    break;
    332                  }
    333          
    334                  p_tcb = p_tcb_next;
   \                     ??OSMonOp_19: (+1)
   \      0x15E   0x9805             LDR      R0,[SP, #+20]
   \      0x160   0x0004             MOVS     R4,R0
   \      0x162   0xE7C9             B.N      ??OSMonOp_15
    335                }
    336              }
    337            }
    338          
    339            CORE_EXIT_ATOMIC();
   \                     ??OSMonOp_14: (+1)
   \      0x164   0x9802             LDR      R0,[SP, #+8]
   \      0x166   0x.... 0x....      BL       CORE_ExitAtomic
    340          
    341            if (sched == DEF_YES) {
   \      0x16A   0x4640             MOV      R0,R8
   \      0x16C   0xB2C0             UXTB     R0,R0
   \      0x16E   0x2801             CMP      R0,#+1
   \      0x170   0xD101             BNE.N    ??OSMonOp_20
    342              OSSched();                                                  // Find the next highest priority task ready to run
   \      0x172   0x.... 0x....      BL       OSSched
    343            }
    344          
    345            if (DEF_BIT_IS_SET(op_res, OS_MON_RES_BLOCK) == DEF_YES) {
   \                     ??OSMonOp_20: (+1)
   \      0x176   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \      0x17A   0xD53E             BPL.N    ??OSMonOp_21
    346              OS_STATUS status;
    347          
    348              CORE_ENTER_ATOMIC();
   \      0x17C   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x180   0x9002             STR      R0,[SP, #+8]
    349              status = OSTCBCurPtr->PendStatus;
   \      0x182   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x186   0xF890 0xA025      LDRB     R10,[R0, #+37]
    350              CORE_EXIT_ATOMIC();
   \      0x18A   0x9802             LDR      R0,[SP, #+8]
   \      0x18C   0x.... 0x....      BL       CORE_ExitAtomic
    351          
    352              switch (status) {
   \      0x190   0x4650             MOV      R0,R10
   \      0x192   0xB2C0             UXTB     R0,R0
   \      0x194   0x2800             CMP      R0,#+0
   \      0x196   0xD005             BEQ.N    ??OSMonOp_22
   \      0x198   0x2802             CMP      R0,#+2
   \      0x19A   0xD021             BEQ.N    ??OSMonOp_23
   \      0x19C   0xD30C             BCC.N    ??OSMonOp_24
   \      0x19E   0x2803             CMP      R0,#+3
   \      0x1A0   0xD014             BEQ.N    ??OSMonOp_25
   \      0x1A2   0xE027             B.N      ??OSMonOp_26
    353                case OS_STATUS_PEND_OK:                                   // We got the monitor
    354                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSMonOp_22: (+1)
   \      0x1A4   0x2000             MOVS     R0,#+0
   \      0x1A6   0x7030             STRB     R0,[R6, #+0]
   \      0x1A8   0x....             LDR.N    R0,??DataTable3
   \      0x1AA   0x6070             STR      R0,[R6, #+4]
   \      0x1AC   0xF44F 0x70B1      MOV      R0,#+354
   \      0x1B0   0x60B0             STR      R0,[R6, #+8]
   \      0x1B2   0x....             LDR.N    R0,??DataTable3_5
   \      0x1B4   0x60F0             STR      R0,[R6, #+12]
    355                  break;
   \      0x1B6   0xE029             B.N      ??OSMonOp_27
    356          
    357                case OS_STATUS_PEND_ABORT:                                // Indicate that we aborted
    358                  RTOS_ERR_SET(*p_err, RTOS_ERR_ABORT);
   \                     ??OSMonOp_24: (+1)
   \      0x1B8   0x2021             MOVS     R0,#+33
   \      0x1BA   0x7030             STRB     R0,[R6, #+0]
   \      0x1BC   0x....             LDR.N    R0,??DataTable3
   \      0x1BE   0x6070             STR      R0,[R6, #+4]
   \      0x1C0   0xF44F 0x70B3      MOV      R0,#+358
   \      0x1C4   0x60B0             STR      R0,[R6, #+8]
   \      0x1C6   0x....             LDR.N    R0,??DataTable3_5
   \      0x1C8   0x60F0             STR      R0,[R6, #+12]
    359                  break;
   \      0x1CA   0xE01F             B.N      ??OSMonOp_27
    360          
    361                case OS_STATUS_PEND_TIMEOUT:                              // Indicate that we didn't get monitor within timeout
    362                  RTOS_ERR_SET(*p_err, RTOS_ERR_TIMEOUT);
   \                     ??OSMonOp_25: (+1)
   \      0x1CC   0x2022             MOVS     R0,#+34
   \      0x1CE   0x7030             STRB     R0,[R6, #+0]
   \      0x1D0   0x....             LDR.N    R0,??DataTable3
   \      0x1D2   0x6070             STR      R0,[R6, #+4]
   \      0x1D4   0xF44F 0x70B5      MOV      R0,#+362
   \      0x1D8   0x60B0             STR      R0,[R6, #+8]
   \      0x1DA   0x....             LDR.N    R0,??DataTable3_5
   \      0x1DC   0x60F0             STR      R0,[R6, #+12]
    363                  break;
   \      0x1DE   0xE015             B.N      ??OSMonOp_27
    364          
    365                case OS_STATUS_PEND_DEL:                                  // Indicate that object pended on has been deleted
    366                  RTOS_ERR_SET(*p_err, RTOS_ERR_OS_OBJ_DEL);
   \                     ??OSMonOp_23: (+1)
   \      0x1E0   0x2031             MOVS     R0,#+49
   \      0x1E2   0x7030             STRB     R0,[R6, #+0]
   \      0x1E4   0x....             LDR.N    R0,??DataTable3
   \      0x1E6   0x6070             STR      R0,[R6, #+4]
   \      0x1E8   0xF44F 0x70B7      MOV      R0,#+366
   \      0x1EC   0x60B0             STR      R0,[R6, #+8]
   \      0x1EE   0x....             LDR.N    R0,??DataTable3_5
   \      0x1F0   0x60F0             STR      R0,[R6, #+12]
    367                  break;
   \      0x1F2   0xE00B             B.N      ??OSMonOp_27
    368          
    369                default:
    370                  RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \                     ??OSMonOp_26: (+1)
   \      0x1F4   0x.... 0x....      BL       CPU_SW_Exception
   \      0x1F8   0xE008             B.N      ??OSMonOp_27
    371              }
    372            } else {
    373              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSMonOp_21: (+1)
   \      0x1FA   0x2000             MOVS     R0,#+0
   \      0x1FC   0x7030             STRB     R0,[R6, #+0]
   \      0x1FE   0x....             LDR.N    R0,??DataTable3
   \      0x200   0x6070             STR      R0,[R6, #+4]
   \      0x202   0xF240 0x1075      MOVW     R0,#+373
   \      0x206   0x60B0             STR      R0,[R6, #+8]
   \      0x208   0x....             LDR.N    R0,??DataTable3_5
   \      0x20A   0x60F0             STR      R0,[R6, #+12]
    374            }
    375          }
   \                     ??OSMonOp_27: (+1)
   \                     ??OSMonOp_2: (+1)
   \      0x20C   0xB009             ADD      SP,SP,#+36
   \      0x20E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    376          
    377          /********************************************************************************************************
    378           ********************************************************************************************************
    379           *                                           INTERNAL FUNCTIONS
    380           ********************************************************************************************************
    381           *******************************************************************************************************/
    382          
    383          /****************************************************************************************************//**
    384           *                                               OS_MonClr()
    385           *
    386           * @brief    This function is called by OSMonDel() to clear the contents of the monitor.
    387           *
    388           * @param    p_mon   Pointer to the monitor to clear.
    389           *
    390           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    391           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    392          void OS_MonClr(OS_MON *p_mon)
    393          {
   \                     OS_MonClr: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    394          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    395            p_mon->Type = OS_OBJ_TYPE_NONE;                               // Mark the data structure as a NONE
   \        0x4   0x....             LDR.N    R0,??DataTable3_7
   \        0x6   0x6020             STR      R0,[R4, #+0]
    396          #endif
    397            p_mon->MonDataPtr = DEF_NULL;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x60E0             STR      R0,[R4, #+12]
    398          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    399            p_mon->NamePtr = (CPU_CHAR *)((void *)"?MON");
    400          #endif
    401            OS_PendListInit(&p_mon->PendList);                            // Initialize the waiting list
   \        0xC   0x1D20             ADDS     R0,R4,#+4
   \        0xE   0x.... 0x....      BL       OS_PendListInit
    402          }
   \       0x12   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     `OSMonCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x204E'4F4D        DC32     0x204e4f4d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     `OSMonDel::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x....'....        DC32     `OSMonOp::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x454E'4F4E        DC32     0x454e4f4e

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x6B, 0x65, 0x72, 0x6E, 0x65
   \              0x5C 0x6B    
   \              0x65 0x72    
   \              0x6E 0x65
   \       0x58   0x6C 0x5C          DC8 0x6C, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65
   \       0x60   0x5C 0x6F          DC8 0x5C, 0x6F, 0x73, 0x5F, 0x6D, 0x6F, 0x6E, 0x2E
   \              0x73 0x5F    
   \              0x6D 0x6F    
   \              0x6E 0x2E
   \       0x68   0x63 0x00          DC8 0x63, 0
   \       0x6A                      DS8 2
    403          
    404          /****************************************************************************************************//**
    405           *                                           OS_MonDbgListAdd()
    406           *
    407           * @brief    Add a monitor to the monitor debug list.
    408           *
    409           * @param    p_mon   Pointer to the monitor to add.
    410           *
    411           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    412           *******************************************************************************************************/
    413          
    414          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    415          void OS_MonDbgListAdd(OS_MON *p_mon)
    416          {
    417            p_mon->DbgNamePtr = (CPU_CHAR *)((void *)" ");
    418            p_mon->DbgPrevPtr = DEF_NULL;
    419            if (OSMonDbgListPtr == DEF_NULL) {
    420              p_mon->DbgNextPtr = DEF_NULL;
    421            } else {
    422              p_mon->DbgNextPtr = OSMonDbgListPtr;
    423              OSMonDbgListPtr->DbgPrevPtr = p_mon;
    424            }
    425            OSMonDbgListPtr = p_mon;
    426          }
    427          
    428          /****************************************************************************************************//**
    429           *                                           OS_MonDbgListRemove()
    430           *
    431           * @brief    Remove a monitor from the monitor debug list.
    432           *
    433           * @param    p_mon   Pointer to the monitor to remove.
    434           *
    435           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    436           *******************************************************************************************************/
    437          void OS_MonDbgListRemove(OS_MON *p_mon)
    438          {
    439            OS_MON *p_mon_next;
    440            OS_MON *p_mon_prev;
    441          
    442            p_mon_prev = p_mon->DbgPrevPtr;
    443            p_mon_next = p_mon->DbgNextPtr;
    444          
    445            if (p_mon_prev == DEF_NULL) {
    446              OSMonDbgListPtr = p_mon_next;
    447              if (p_mon_next != DEF_NULL) {
    448                p_mon_next->DbgPrevPtr = DEF_NULL;
    449              }
    450              p_mon->DbgNextPtr = DEF_NULL;
    451            } else if (p_mon_next == DEF_NULL) {
    452              p_mon_prev->DbgNextPtr = DEF_NULL;
    453              p_mon->DbgPrevPtr = DEF_NULL;
    454            } else {
    455              p_mon_prev->DbgNextPtr = p_mon_next;
    456              p_mon_next->DbgPrevPtr = p_mon_prev;
    457              p_mon->DbgNextPtr = DEF_NULL;
    458              p_mon->DbgPrevPtr = DEF_NULL;
    459            }
    460          }
    461          #endif
    462          #endif
    463          
    464          /********************************************************************************************************
    465           ********************************************************************************************************
    466           *                                   DEPENDENCIES & AVAIL CHECK(S) END
    467           ********************************************************************************************************
    468           *******************************************************************************************************/
    469          
    470          #endif // (defined(RTOS_MODULE_KERNEL_AVAIL))

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSMonCreate
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CORE_InIrqContext
        24   -> CPU_SW_Exception
        24   -> OS_PendListInit
        24   -> __aeabi_memclr4
      32   OSMonDel
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> CORE_InIrqContext
        32   -> CPU_SW_Exception
        32   -> OSSched
        32   -> OS_MonClr
        32   -> OS_PendAbort
      72   OSMonOp
        72   -- Indirect call
        72   -> CORE_EnterAtomic
        72   -> CORE_ExitAtomic
        72   -> CORE_IrqIsDisabled
        72   -> CPU_SW_Exception
        72   -> OSSched
        72   -> OS_Pend
        72   -> OS_Post
       8   OS_MonClr
         8   -> OS_PendListInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
     108  ?_0
     146  OSMonCreate
     328  OSMonDel
     530  OSMonOp
      20  OS_MonClr
      48  -- Other

 
   156 bytes in section .rodata
 1'056 bytes in section .text
 
 1'056 bytes of CODE  memory
   156 bytes of CONST memory

Errors: none
Warnings: none
