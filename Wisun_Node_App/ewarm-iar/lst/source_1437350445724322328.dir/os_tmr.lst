###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:04
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_tmr.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_tmr.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_tmr.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_tmr.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir\os_tmr.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_tmr.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_tmr.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Kernel - Timer Management
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                       DEPENDENCIES & AVAIL CHECK(S)
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <rtos_description.h>
     25          
     26          #if (defined(RTOS_MODULE_KERNEL_AVAIL))
     27          
     28          /********************************************************************************************************
     29           ********************************************************************************************************
     30           *                                               INCLUDE FILES
     31           ********************************************************************************************************
     32           *******************************************************************************************************/
     33          
     34          #define  MICRIUM_SOURCE
     35          #include "../include/os.h"
     36          #include "os_priv.h"
     37          
     38          #include  <em_core.h>
     39          
     40          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     41          const CPU_CHAR *os_tmr__c = "$Id: $";
     42          #endif
     43          
     44          /********************************************************************************************************
     45           ********************************************************************************************************
     46           *                                       LOCAL FUNCTION PROTOTYPES
     47           ********************************************************************************************************
     48           *******************************************************************************************************/
     49          
     50          #if (OS_CFG_TMR_EN == DEF_ENABLED)
     51          
     52          static void OS_TmrLock(void);
     53          static void OS_TmrUnlock(void);
     54          
     55          /********************************************************************************************************
     56           ********************************************************************************************************
     57           *                                           GLOBAL FUNCTIONS
     58           ********************************************************************************************************
     59           *******************************************************************************************************/
     60          
     61          /****************************************************************************************************//**
     62           *                                               OSTmrCreate()
     63           *
     64           * @brief    Called by your application code to create a timer.
     65           *
     66           * @param    p_tmr           Pointer to the timer to create. Your application is responsible
     67           *                           for allocating storage for the timer.
     68           *
     69           * @param    p_name          Pointer to an ASCII string that names the timer (useful for debugging)
     70           *
     71           * @param    dly             Initial delay.
     72           *                           If the timer is configured for ONE-SHOT mode, this is the timeout used.
     73           *                           If the timer is configured for PERIODIC mode, this is the first timeout
     74           *                           to wait for before the timer starts entering periodic mode.
     75           *
     76           * @param    period          The 'period' being repeated for the timer.
     77           *                           If you specified 'OS_OPT_TMR_PERIODIC' as an option, when the timer
     78           *                           expires, it will automatically restart with the same period.
     79           *
     80           * @param    opt             Specifies either:
     81           *                               - OS_OPT_TMR_ONE_SHOT     The timer counts down only once.
     82           *                               - OS_OPT_TMR_PERIODIC     The timer counts down and then reloads itself.
     83           *
     84           * @param    p_callback      Pointer to a callback function that will be called when the timer
     85           *                           expires. The callback function must be declared as follows:
     86           *                           @verbatim
     87           *                           void  MyCallback (OS_TMR  *p_tmr, void  *p_arg);
     88           *                           @endverbatim
     89           *                           @param    p_callback_arg  Pointer to an argument that is passed to the callback function when it is
     90           *                           called.
     91           *
     92           * @param    p_err           Pointer to the variable that will receive one of the following error code(s)
     93           *                           from this function:
     94           *                               - RTOS_ERR_NONE
     95           *                               - RTOS_ERR_OS_ILLEGAL_RUN_TIME
     96           *
     97           * @note     (1) This function only creates the timer. In other words, the timer is not started when
     98           *               created. To start the timer, call OSTmrStart().
     99           *******************************************************************************************************/
    100          void OSTmrCreate(OS_TMR              *p_tmr,
    101                           CPU_CHAR            *p_name,
    102                           OS_TICK             dly,
    103                           OS_TICK             period,
    104                           OS_OPT              opt,
    105                           OS_TMR_CALLBACK_PTR p_callback,
    106                           void                *p_callback_arg,
    107                           RTOS_ERR            *p_err)
    108          {
    109            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
    110          
    111          #ifdef OS_SAFETY_CRITICAL_IEC61508
    112            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    113              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
    114              return;
    115            }
    116          #endif
    117          
    118            //                                                               Not allowed to call from an ISR
    119            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
    120          
    121            //                                                               Validate 'p_tmr'
    122            OS_ASSERT_DBG_ERR_SET((p_tmr != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
    123          
    124          #if (OS_ARG_CHK_EN == DEF_ENABLED)
    125            switch (opt) {                                                // Validate 'opt'
    126              case OS_OPT_TMR_PERIODIC:
    127                OS_ASSERT_DBG_ERR_SET((period > 0u), *p_err, RTOS_ERR_INVALID_ARG,; );
    128          
    129                //                                                           No point in a periodic timer without a callback
    130                OS_ASSERT_DBG_ERR_SET((p_callback != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
    131                break;
    132          
    133              case OS_OPT_TMR_ONE_SHOT:
    134                OS_ASSERT_DBG_ERR_SET((dly > 0u), *p_err, RTOS_ERR_INVALID_ARG,; );
    135                break;
    136          
    137              default:
    138                OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_INVALID_ARG,; );
    139            }
    140          #endif
    141          
    142            if (OSRunning == OS_STATE_OS_RUNNING) {                       // Only lock when the kernel is running
    143              OS_TmrLock();
    144            }
    145          
    146            *p_tmr = (OS_TMR){ 0 };                                       // Initialize the timer fields
    147            p_tmr->State = OS_TMR_STATE_STOPPED;
    148          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    149            p_tmr->Type = OS_OBJ_TYPE_TMR;
    150          #endif
    151          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    152            p_tmr->NamePtr = p_name;
    153          #else
    154            (void)&p_name;
    155          #endif
    156            p_tmr->Dly = dly;
    157            p_tmr->Period = period;
    158            p_tmr->Opt = opt;
    159            p_tmr->CallbackPtr = p_callback;
    160            p_tmr->CallbackPtrArg = p_callback_arg;
    161          
    162          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    163            OS_TmrDbgListAdd(p_tmr);
    164          #endif
    165          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    166            OSTmrQty++;                                                   // Keep track of the number of timers created
    167          #endif
    168          
    169            if (OSRunning == OS_STATE_OS_RUNNING) {
    170              OS_TmrUnlock();
    171            }
    172          
    173            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    174          }
    175          
    176          /*****************************************************************************************************//**
    177           *                                               OSTmrDel()
    178           *
    179           * @brief    Called by your application code to delete a timer.
    180           *
    181           * @param    p_tmr   Pointer to the timer to stop and delete.
    182           *
    183           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    184           *                   from this function:
    185           *                       - RTOS_ERR_NONE
    186           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    187           *                       - RTOS_ERR_NOT_INIT
    188           *                       - RTOS_ERR_NOT_READY
    189           *
    190           * @return   == DEF_TRUE     If the timer was deleted.
    191           *           == DEF_FALSE    If the timer was not deleted or upon an error.
    192           *******************************************************************************************************/
    193          CPU_BOOLEAN OSTmrDel(OS_TMR   *p_tmr,
    194                               RTOS_ERR *p_err)
    195          {
    196            CPU_BOOLEAN success = DEF_FALSE;
    197          
    198            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FALSE);
    199          
    200          #ifdef OS_SAFETY_CRITICAL_IEC61508
    201            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    202              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
    203              return (DEF_FALSE);
    204            }
    205          #endif
    206          
    207            //                                                               Not allowed to call from an ISR
    208            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, DEF_FALSE);
    209          
    210            //                                                               Validate 'p_tmr'
    211            OS_ASSERT_DBG_ERR_SET((p_tmr != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, DEF_FALSE);
    212          
    213            //                                                               Validate object type
    214            OS_ASSERT_DBG_ERR_SET((p_tmr->Type == OS_OBJ_TYPE_TMR), *p_err, RTOS_ERR_INVALID_TYPE, DEF_FALSE);
    215          
    216            //                                                               Make sure kernel is running.
    217            if (OSRunning != OS_STATE_OS_RUNNING) {
    218              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    219              return (DEF_FALSE);
    220            }
    221          
    222            OS_TmrLock();
    223          
    224          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    225            OS_TmrDbgListRemove(p_tmr);
    226          #endif
    227          
    228            switch (p_tmr->State) {
    229              case OS_TMR_STATE_RUNNING:
    230                OS_TmrUnlink(p_tmr);                                      // Remove from the list
    231                OS_TmrClr(p_tmr);
    232          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    233                OSTmrQty--;                                               // One less timer
    234          #endif
    235                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    236                success = DEF_TRUE;
    237                break;
    238          
    239              case OS_TMR_STATE_STOPPED:                                  // Timer has not started or ...
    240              case OS_TMR_STATE_COMPLETED:                                // ... timer has completed the ONE-SHOT time
    241                OS_TmrClr(p_tmr);                                         // Clear timer fields
    242          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    243                OSTmrQty--;                                               // One less timer
    244          #endif
    245                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    246                success = DEF_TRUE;
    247                break;
    248          
    249              case OS_TMR_STATE_UNUSED:                                   // Already deleted
    250                RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_INIT);
    251                success = DEF_FALSE;
    252                break;
    253          
    254              default:
    255                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, DEF_FALSE);
    256                break;
    257            }
    258          
    259            OS_TmrUnlock();
    260          
    261            return (success);
    262          }
    263          
    264          /*****************************************************************************************************//**
    265           *                                               OSTmrRemainGet()
    266           *
    267           * @brief    Called to get the number of ticks before a timer times out.
    268           *
    269           * @param    p_tmr   Pointer to the timer to obtain the remaining time from.
    270           *
    271           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    272           *                   from this function:
    273           *                       - RTOS_ERR_NONE
    274           *                       - RTOS_ERR_NOT_INIT
    275           *                       - RTOS_ERR_NOT_READY
    276           *
    277           * @return   The time remaining for the timer to expire. The time represents 'timer' increments. In
    278           *           other words, if OS_TmrTask() is signaled every 1/10 of a second, the returned value
    279           *           represents the number of 1/10 of a second remaining before the timer expires.
    280           *******************************************************************************************************/
    281          OS_TICK OSTmrRemainGet(OS_TMR   *p_tmr,
    282                                 RTOS_ERR *p_err)
    283          {
    284            OS_TICK remain;
    285          
    286            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
    287          
    288            //                                                               Not allowed to call from an ISR
    289            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
    290          
    291            //                                                               Validate 'p_tmr'
    292            OS_ASSERT_DBG_ERR_SET((p_tmr != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
    293          
    294            //                                                               Validate object type
    295            OS_ASSERT_DBG_ERR_SET((p_tmr->Type == OS_OBJ_TYPE_TMR), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
    296          
    297            //                                                               Make sure kernel is running.
    298            if (OSRunning != OS_STATE_OS_RUNNING) {
    299              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    300              return (0u);
    301            }
    302          
    303            OS_TmrLock();
    304            remain = 0u;
    305            switch (p_tmr->State) {
    306              case OS_TMR_STATE_RUNNING:
    307                remain = p_tmr->Remain;
    308                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    309                break;
    310          
    311              case OS_TMR_STATE_STOPPED:                                  // It's assumed that the timer has not started yet
    312                if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
    313                  if (p_tmr->Dly == 0u) {
    314                    remain = p_tmr->Period;
    315                  } else {
    316                    remain = p_tmr->Dly;
    317                  }
    318                } else {
    319                  remain = p_tmr->Dly;
    320                }
    321                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    322                break;
    323          
    324              case OS_TMR_STATE_COMPLETED:                                // Only ONE-SHOT that timed out can be in this state
    325                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    326                break;
    327          
    328              case OS_TMR_STATE_UNUSED:
    329                RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_INIT);
    330                break;
    331          
    332              default:
    333                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, 0u);
    334                break;
    335            }
    336          
    337            OS_TmrUnlock();
    338          
    339            return (remain);
    340          }
    341          
    342          /*****************************************************************************************************//**
    343           *                                               OSTmrSet()
    344           *
    345           * @brief    Called by your application code to set a timer.
    346           *
    347           * @param    p_tmr           Pointer to the timer to set.
    348           *
    349           * @param    dly             Initial delay.
    350           *                           If the timer is configured for ONE-SHOT mode, this is the timeout used.
    351           *                           If the timer is configured for PERIODIC mode, this is the first timeout
    352           *                           to wait for before the timer starts entering periodic mode.
    353           *
    354           * @param    period          The 'period' being repeated for the timer.
    355           *                           If you specified 'OS_OPT_TMR_PERIODIC' as an option, when the timer
    356           *                           expires, it will automatically restart with the same period.
    357           *
    358           * @param    p_callback      Pointer to a callback function that will be called when the timer
    359           *                           expires. The callback function must be declared as follows:
    360           *                           void  MyCallback (OS_TMR  *p_tmr, void  *p_arg);
    361           *
    362           * @param    p_callback_arg  Pointer to an argument that is passed to the callback function when it is
    363           *                           called.
    364           *
    365           * @param    p_err           Pointer to the variable that will receive one of the following error code(s)
    366           *                           from this function:
    367           *                               - RTOS_ERR_NONE
    368           *                               - RTOS_ERR_NOT_READY
    369           *
    370           * @note     (1) This function can be called on a running timer. The change to the delay and period
    371           *               will only take effect after the current period or delay has passed. Change to the
    372           *               callback will take effect immediately.
    373           *******************************************************************************************************/
    374          void OSTmrSet(OS_TMR              *p_tmr,
    375                        OS_TICK             dly,
    376                        OS_TICK             period,
    377                        OS_TMR_CALLBACK_PTR p_callback,
    378                        void                *p_callback_arg,
    379                        RTOS_ERR            *p_err)
    380          {
    381            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
    382          
    383            //                                                               Not allowed to call from an ISR
    384            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
    385          
    386            //                                                               Validate 'p_tmr'
    387            OS_ASSERT_DBG_ERR_SET((p_tmr != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
    388          
    389            //                                                               Validate object type
    390            OS_ASSERT_DBG_ERR_SET((p_tmr->Type == OS_OBJ_TYPE_TMR), *p_err, RTOS_ERR_INVALID_TYPE,; );
    391          
    392            //                                                               Make sure kernel is running.
    393            if (OSRunning != OS_STATE_OS_RUNNING) {
    394              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    395              return;
    396            }
    397          
    398          #if (OS_ARG_CHK_EN == DEF_ENABLED)
    399            switch (p_tmr->Opt) {
    400              case OS_OPT_TMR_PERIODIC:
    401                OS_ASSERT_DBG_ERR_SET((period > 0u), *p_err, RTOS_ERR_INVALID_ARG,; );
    402          
    403                // No point in a periodic timer without a callback
    404                OS_ASSERT_DBG_ERR_SET((p_callback != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
    405                break;
    406          
    407              case OS_OPT_TMR_ONE_SHOT:
    408                OS_ASSERT_DBG_ERR_SET((dly > 0u), *p_err, RTOS_ERR_INVALID_ARG,; );
    409                break;
    410          
    411              default:
    412                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_ARG,; );
    413            }
    414          #endif
    415          
    416            OS_TmrLock();
    417          
    418            p_tmr->Dly = dly;
    419            p_tmr->Period = period;
    420            p_tmr->CallbackPtr = p_callback;
    421            p_tmr->CallbackPtrArg = p_callback_arg;
    422          
    423            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    424          
    425            OS_TmrUnlock();
    426          }
    427          
    428          /*****************************************************************************************************//**
    429           *                                               OSTmrStart()
    430           *
    431           * @brief    Called by your application code to start a timer.
    432           *
    433           * @param    p_tmr   Pointer to the timer to start.
    434           *
    435           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from this function:
    436           *                       - RTOS_ERR_NONE
    437           *                       - RTOS_ERR_NOT_INIT
    438           *                       - RTOS_ERR_NOT_READY
    439           *
    440           * @return   DEF_TRUE     If the timer was started.
    441           *           DEF_FALSE    If the timer was not started or upon an error.
    442           *
    443           * @note     (1) When starting/restarting a timer, regardless if it is in PERIODIC or ONE-SHOT mode,
    444           *               the timer is linked to the timer list with the OS_OPT_LINK_DLY option. This option
    445           *               sets the initial expiration time for the timer. For timers in PERIODIC mode,
    446           *               subsequent expiration times are handled by the OS_TmrTask().
    447           *******************************************************************************************************/
    448          CPU_BOOLEAN OSTmrStart(OS_TMR   *p_tmr,
    449                                 RTOS_ERR *p_err)
    450          {
    451            OS_TMR      *p_next;
    452            CPU_BOOLEAN success;
    453          
    454            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FALSE);
    455          
    456            //                                                               Not allowed to call from an ISR
    457            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, DEF_FALSE);
    458          
    459            //                                                               Validate 'p_tmr'
    460            OS_ASSERT_DBG_ERR_SET((p_tmr != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, DEF_FALSE);
    461          
    462            //                                                               Validate object type
    463            OS_ASSERT_DBG_ERR_SET((p_tmr->Type == OS_OBJ_TYPE_TMR), *p_err, RTOS_ERR_INVALID_TYPE, DEF_FALSE);
    464          
    465            //                                                               Make sure kernel is running.
    466            if (OSRunning != OS_STATE_OS_RUNNING) {
    467              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    468              return (DEF_FALSE);
    469            }
    470          
    471            OS_TmrLock();
    472            success = DEF_FALSE;
    473            switch (p_tmr->State) {
    474              case OS_TMR_STATE_RUNNING:                                  // Restart the timer
    475                if (p_tmr->Dly == 0u) {
    476                  p_tmr->Remain = p_tmr->Period;
    477                } else {
    478                  p_tmr->Remain = p_tmr->Dly;
    479                }
    480                success = DEF_TRUE;
    481                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    482                break;
    483          
    484              case OS_TMR_STATE_STOPPED:                                  // Start the timer
    485              case OS_TMR_STATE_COMPLETED:
    486                p_tmr->State = OS_TMR_STATE_RUNNING;
    487                if (p_tmr->Dly == 0u) {
    488                  p_tmr->Remain = p_tmr->Period;
    489                } else {
    490                  p_tmr->Remain = p_tmr->Dly;
    491                }
    492                if (OSTmrListPtr == DEF_NULL) {                           // Link into timer list
    493                  p_tmr->NextPtr = DEF_NULL;                              // This is the first timer in the list
    494                  p_tmr->PrevPtr = DEF_NULL;
    495                  OSTmrListPtr = p_tmr;
    496          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    497                  OSTmrListEntries = 1u;
    498          #endif
    499                } else {
    500                  p_next = OSTmrListPtr;                                  // Insert at the beginning of the list
    501                  p_tmr->NextPtr = OSTmrListPtr;
    502                  p_tmr->PrevPtr = DEF_NULL;
    503                  p_next->PrevPtr = p_tmr;
    504                  OSTmrListPtr = p_tmr;
    505          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    506                  OSTmrListEntries++;
    507          #endif
    508                }
    509                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    510                success = DEF_TRUE;
    511                break;
    512          
    513              case OS_TMR_STATE_UNUSED:                                   // Timer not created
    514                RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_INIT);
    515                success = DEF_FALSE;
    516                break;
    517          
    518              default:
    519                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, DEF_FALSE);
    520            }
    521          
    522            OS_TmrUnlock();
    523          
    524            return (success);
    525          }
    526          
    527          /*****************************************************************************************************//**
    528           *                                               OSTmrStateGet()
    529           *
    530           * @brief    Called to determine what state the timer is in:
    531           *           - OS_TMR_STATE_UNUSED     The timer has not been created.
    532           *           - OS_TMR_STATE_STOPPED    The timer has been created but has not been started or has
    533           *                                     been stopped.
    534           *           - OS_TMR_STATE_COMPLETED  The timer is in ONE-SHOT mode and has completed it's timeout.
    535           *           - OS_TMR_SATE_RUNNING     The timer is currently running.
    536           *
    537           * @param    p_tmr   Pointer to the timer.
    538           *
    539           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    540           *                   from this function:
    541           *                       - RTOS_ERR_NONE
    542           *                       - RTOS_ERR_NOT_READY
    543           *
    544           * @return   The current state of the timer (see description).
    545           *******************************************************************************************************/
    546          OS_STATE OSTmrStateGet(OS_TMR   *p_tmr,
    547                                 RTOS_ERR *p_err)
    548          {
    549            OS_STATE state;
    550          
    551            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, OS_TMR_STATE_UNUSED);
    552          
    553            //                                                               Not allowed to call from an ISR
    554            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, OS_TMR_STATE_UNUSED);
    555          
    556            //                                                               Validate 'p_tmr'
    557            OS_ASSERT_DBG_ERR_SET((p_tmr != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, OS_TMR_STATE_UNUSED);
    558          
    559            //                                                               Validate object type
    560            OS_ASSERT_DBG_ERR_SET((p_tmr->Type == OS_OBJ_TYPE_TMR), *p_err, RTOS_ERR_INVALID_TYPE, OS_TMR_STATE_UNUSED);
    561          
    562            //                                                               Make sure kernel is running.
    563            if (OSRunning != OS_STATE_OS_RUNNING) {
    564              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    565              return (OS_TMR_STATE_UNUSED);
    566            }
    567          
    568            OS_TmrLock();
    569          
    570            state = p_tmr->State;
    571            switch (state) {
    572              case OS_TMR_STATE_UNUSED:
    573              case OS_TMR_STATE_STOPPED:
    574              case OS_TMR_STATE_COMPLETED:
    575              case OS_TMR_STATE_RUNNING:
    576                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    577                break;
    578          
    579              default:
    580                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, 0u);
    581                break;
    582            }
    583          
    584            OS_TmrUnlock();
    585          
    586            return (state);
    587          }
    588          
    589          /*****************************************************************************************************//**
    590           *                                               OSTmrStop()
    591           *
    592           * @brief    Called by your application code to stop a timer.
    593           *
    594           * @param    p_tmr           Pointer to the timer to stop.
    595           *
    596           * @param    opt             Allows you to specify an option to this functions which can be:
    597           *                               - OS_OPT_TMR_NONE             Stop the timer.
    598           *                               - OS_OPT_TMR_CALLBACK         Stop the timer and execute the callback
    599           *                           function, pass it the callback argument
    600           *                           specified when the timer was created.
    601           *                               - OS_OPT_TMR_CALLBACK_ARG     Stop the timer and execute the callback
    602           *                           function, pass it the callback argument
    603           *                           specified in THIS function call.
    604           *
    605           * @param    p_callback_arg  Pointer to a 'new' callback argument that can be passed to the
    606           *                           callback function instead of the timer's callback argument. In other words,
    607           *                           use 'callback_arg' passed in THIS function INSTEAD of p_tmr->OSTmrCallbackArg
    608           *
    609           * @param    p_err           Pointer to the variable that will receive one of the following error code(s)
    610           *                           from this function:
    611           *                               - RTOS_ERR_NONE
    612           *                               - RTOS_ERR_NOT_INIT
    613           *                               - RTOS_ERR_INVALID_ARG
    614           *                               - RTOS_ERR_INVALID_STATE
    615           *                               - RTOS_ERR_NOT_READY
    616           *
    617           * @return   DEF_TRUE     If we stop the timer (if the timer is already stopped, it returns as
    618           *                       DEF_TRUE).
    619           *           DEF_FALSE    If the timer is not stopped.
    620           *******************************************************************************************************/
    621          CPU_BOOLEAN OSTmrStop(OS_TMR   *p_tmr,
    622                                OS_OPT   opt,
    623                                void     *p_callback_arg,
    624                                RTOS_ERR *p_err)
    625          {
    626            OS_TMR_CALLBACK_PTR p_fnct;
    627            CPU_BOOLEAN         success;
    628          
    629            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FALSE);             // Validate 'p_err'
    630          
    631            //                                                               Not allowed to call from an ISR
    632            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, DEF_FALSE);
    633          
    634            //                                                               Validate 'p_tmr'
    635            OS_ASSERT_DBG_ERR_SET((p_tmr != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, DEF_FALSE);
    636          
    637            //                                                               Validate object type
    638            OS_ASSERT_DBG_ERR_SET((p_tmr->Type == OS_OBJ_TYPE_TMR), *p_err, RTOS_ERR_INVALID_TYPE, DEF_FALSE);
    639          
    640            //                                                               Make sure kernel is running.
    641            if (OSRunning != OS_STATE_OS_RUNNING) {
    642              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
    643              return (DEF_FALSE);
    644            }
    645          
    646            OS_TmrLock();
    647            success = DEF_FALSE;
    648            switch (p_tmr->State) {
    649              case OS_TMR_STATE_RUNNING:
    650                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    651                switch (opt) {
    652                  case OS_OPT_TMR_CALLBACK:
    653                    OS_TmrUnlink(p_tmr);                                  // Remove from timer list
    654                    p_fnct = p_tmr->CallbackPtr;                          // Execute callback function ...
    655                    if (p_fnct != DEF_NULL) {                             // ... if available
    656                      (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg);    // Use callback arg when timer was created
    657                    } else {
    658                      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_ARG);
    659                    }
    660                    break;
    661          
    662                  case OS_OPT_TMR_CALLBACK_ARG:
    663                    OS_TmrUnlink(p_tmr);                                  // Remove from timer list
    664                    p_fnct = p_tmr->CallbackPtr;                          // Execute callback function if available ...
    665                    if (p_fnct != DEF_NULL) {
    666                      (*p_fnct)((void *)p_tmr, p_callback_arg);           // .. using the 'callback_arg' provided in call
    667                    } else {
    668                      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_ARG);
    669                    }
    670                    break;
    671          
    672                  case OS_OPT_TMR_NONE:
    673                    OS_TmrUnlink(p_tmr);                                  // Remove from timer list
    674                    break;
    675          
    676                  default:
    677                    OS_TmrUnlock();
    678                    OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_INVALID_ARG, DEF_FALSE);
    679                }
    680                success = DEF_TRUE;
    681                break;
    682          
    683              case OS_TMR_STATE_COMPLETED:                                // Timer has already completed the ONE-SHOT or
    684              case OS_TMR_STATE_STOPPED:                                  // ... timer has not started yet.
    685                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
    686                success = DEF_TRUE;
    687                break;
    688          
    689              case OS_TMR_STATE_UNUSED:                                   // Timer was not created
    690                RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_INIT);
    691                success = DEF_FALSE;
    692                break;
    693          
    694              default:
    695                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, DEF_FALSE);
    696            }
    697          
    698            OS_TmrUnlock();
    699          
    700            return (success);
    701          }
    702          
    703          /********************************************************************************************************
    704           ********************************************************************************************************
    705           *                                           INTERNAL FUNCTIONS
    706           ********************************************************************************************************
    707           *******************************************************************************************************/
    708          
    709          /*****************************************************************************************************//**
    710           *                                               OS_TmrClr()
    711           *
    712           * @brief    Called to clear all timer fields.
    713           *
    714           * @param    p_tmr   Pointer to the timer to clear.
    715           *
    716           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    717           *******************************************************************************************************/
    718          void OS_TmrClr(OS_TMR *p_tmr)
    719          {
    720            p_tmr->State = OS_TMR_STATE_UNUSED;                           // Clear timer fields
    721          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    722            p_tmr->Type = OS_OBJ_TYPE_NONE;
    723          #endif
    724          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    725            p_tmr->NamePtr = (CPU_CHAR *)((void *)"?TMR");
    726          #endif
    727            p_tmr->Dly = 0u;
    728            p_tmr->Remain = 0u;
    729            p_tmr->Period = 0u;
    730            p_tmr->Opt = 0u;
    731            p_tmr->CallbackPtr = DEF_NULL;
    732            p_tmr->CallbackPtrArg = DEF_NULL;
    733            p_tmr->NextPtr = DEF_NULL;
    734            p_tmr->PrevPtr = DEF_NULL;
    735          }
    736          
    737          /*****************************************************************************************************//**
    738           *                                           OS_TmrDbgListAdd()
    739           *
    740           * @brief    Add a timer to timer debug list.
    741           *
    742           * @param    p_tmr   Pointer to the timer to add.
    743           *
    744           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    745           *******************************************************************************************************/
    746          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    747          void OS_TmrDbgListAdd(OS_TMR *p_tmr)
    748          {
    749            p_tmr->DbgPrevPtr = DEF_NULL;
    750            if (OSTmrDbgListPtr == DEF_NULL) {
    751              p_tmr->DbgNextPtr = DEF_NULL;
    752            } else {
    753              p_tmr->DbgNextPtr = OSTmrDbgListPtr;
    754              OSTmrDbgListPtr->DbgPrevPtr = p_tmr;
    755            }
    756            OSTmrDbgListPtr = p_tmr;
    757          }
    758          
    759          /*****************************************************************************************************//**
    760           *                                           OS_TmrDbgListRemove()
    761           *
    762           * @brief    Remove a timer to timer debug list.
    763           *
    764           * @param    p_tmr   Pointer to the timer to remove.
    765           *
    766           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    767           *******************************************************************************************************/
    768          void OS_TmrDbgListRemove(OS_TMR *p_tmr)
    769          {
    770            OS_TMR *p_tmr_next;
    771            OS_TMR *p_tmr_prev;
    772          
    773            p_tmr_prev = p_tmr->DbgPrevPtr;
    774            p_tmr_next = p_tmr->DbgNextPtr;
    775          
    776            if (p_tmr_prev == DEF_NULL) {
    777              OSTmrDbgListPtr = p_tmr_next;
    778              if (p_tmr_next != DEF_NULL) {
    779                p_tmr_next->DbgPrevPtr = DEF_NULL;
    780              }
    781              p_tmr->DbgNextPtr = DEF_NULL;
    782            } else if (p_tmr_next == DEF_NULL) {
    783              p_tmr_prev->DbgNextPtr = DEF_NULL;
    784              p_tmr->DbgPrevPtr = DEF_NULL;
    785            } else {
    786              p_tmr_prev->DbgNextPtr = p_tmr_next;
    787              p_tmr_next->DbgPrevPtr = p_tmr_prev;
    788              p_tmr->DbgNextPtr = DEF_NULL;
    789              p_tmr->DbgPrevPtr = DEF_NULL;
    790            }
    791          }
    792          #endif
    793          
    794          /*****************************************************************************************************//**
    795           *                                               OS_TmrInit()
    796           *
    797           * @brief    Called by OSInit() to initialize the timer manager module.
    798           *
    799           * @param    p_err   Pointer to the variable that will receive one of the following error code(s) from this function:
    800           *                       - RTOS_ERR_NONE
    801           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    802           *
    803           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    804           *******************************************************************************************************/
    805          void OS_TmrInit(RTOS_ERR *p_err)
    806          {
    807            OS_RATE_HZ tick_rate;
    808          
    809          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    810            OSTmrDbgListPtr = DEF_NULL;
    811          #endif
    812          
    813            OSTmrListPtr = DEF_NULL;                                      // Create an empty timer list
    814          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    815            OSTmrListEntries = 0u;
    816          #endif
    817          
    818            tick_rate = OSTimeTickRateHzGet(p_err);
    819            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    820              return;
    821            }
    822          
    823            if (OSCfg_TmrTaskRate_Hz > 0u) {
    824              OSTmrUpdateCnt = tick_rate / OSCfg_TmrTaskRate_Hz;
    825            } else {
    826              OSTmrUpdateCnt = tick_rate / 10u;
    827            }
    828            OSTmrUpdateCtr = OSTmrUpdateCnt;
    829          
    830            OSTmrTickCtr = 0u;
    831          
    832          #if (OS_CFG_TS_EN == DEF_ENABLED)
    833            OSTmrTaskTimeMax = 0u;
    834          #endif
    835          
    836          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    837            OSMutexCreate(&OSTmrMutex,                                    // Use a mutex to protect the timers
    838                          (CPU_CHAR *)"OS Tmr Mutex",
    839                          p_err);
    840            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    841              return;
    842            }
    843          #endif
    844          
    845            //                                                               -------------- CREATE THE TIMER TASK ---------------
    846            OSTaskCreate(&OSTmrTaskTCB,
    847                         (CPU_CHAR *)((void *)"Kernel's Timer Task"),
    848                         OS_TmrTask,
    849                         DEF_NULL,
    850                         OSCfg_TmrTaskPrio,
    851                         OSCfg_TmrTaskStkBasePtr,
    852                         OSCfg_TmrTaskStkLimit,
    853                         OSCfg_TmrTaskStkSize,
    854                         0u,
    855                         0u,
    856                         DEF_NULL,
    857                         (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
    858                         p_err);
    859          }
    860          
    861          /*****************************************************************************************************//**
    862           *                                               OS_TmrUnlink()
    863           *
    864           * @brief    Called to remove the timer from the timer list.
    865           *
    866           * @param    p_tmr   Pointer to the timer to remove.
    867           *
    868           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    869           *******************************************************************************************************/
    870          void OS_TmrUnlink(OS_TMR *p_tmr)
    871          {
    872            OS_TMR *p_tmr1;
    873            OS_TMR *p_tmr2;
    874          
    875            if (OSTmrListPtr == p_tmr) {                                  // See if timer to remove is at the beginning of list
    876              p_tmr1 = p_tmr->NextPtr;
    877              OSTmrListPtr = p_tmr1;
    878              if (p_tmr1 != DEF_NULL) {
    879                p_tmr1->PrevPtr = DEF_NULL;
    880              }
    881            } else {
    882              p_tmr1 = p_tmr->PrevPtr;                                    // Remove timer from somewhere in the list
    883              p_tmr2 = p_tmr->NextPtr;
    884              p_tmr1->NextPtr = p_tmr2;
    885              if (p_tmr2 != DEF_NULL) {
    886                p_tmr2->PrevPtr = p_tmr1;
    887              }
    888            }
    889            p_tmr->State = OS_TMR_STATE_STOPPED;
    890            p_tmr->NextPtr = DEF_NULL;
    891            p_tmr->PrevPtr = DEF_NULL;
    892          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    893            OSTmrListEntries--;
    894          #endif
    895          }
    896          
    897          /*****************************************************************************************************//**
    898           *                                               OS_TmrTask()
    899           *
    900           * @brief    This task is created by OS_TmrInit().
    901           *
    902           * @param    p_arg   Argument passed to the task when the task is created (unused).
    903           *
    904           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    905           *******************************************************************************************************/
    906          void OS_TmrTask(void *p_arg)
    907          {
    908            RTOS_ERR            err;
    909            OS_TMR_CALLBACK_PTR p_fnct;
    910            OS_TMR              *p_tmr;
    911            OS_TMR              *p_tmr_next;
    912          #if (OS_CFG_TS_EN == DEF_ENABLED)
    913            CPU_TS ts_start;
    914            CPU_TS ts_delta;
    915          #endif
    916          
    917            (void)p_arg;                                                  // Not using 'p_arg', prevent compiler warning
    918            while (DEF_ON) {
    919              OSTimeDly(OSTmrUpdateCnt, OS_OPT_TIME_DLY, &err);
    920              (void)err;
    921          
    922              OS_TmrLock();
    923          #if (OS_CFG_TS_EN == DEF_ENABLED)
    924              ts_start = OS_TS_GET();
    925          #endif
    926              OSTmrTickCtr++;                                             // Increment the current time
    927              p_tmr = OSTmrListPtr;
    928              while (p_tmr != DEF_NULL) {                                 // Update all the timers in the list
    929                OSSchedLock(&err);
    930                (void)&err;
    931                p_tmr_next = p_tmr->NextPtr;
    932                p_tmr->Remain--;
    933                if (p_tmr->Remain == 0u) {
    934                  if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
    935                    p_tmr->Remain = p_tmr->Period;                        // Reload the time remaining
    936                  } else {
    937                    OS_TmrUnlink(p_tmr);                                  // Remove from list
    938                    p_tmr->State = OS_TMR_STATE_COMPLETED;                // Indicate that the timer has completed
    939                  }
    940                  p_fnct = p_tmr->CallbackPtr;                            // Execute callback function if available
    941                  if (p_fnct != 0u) {
    942                    (*p_fnct)((void *)p_tmr,
    943                              p_tmr->CallbackPtrArg);
    944                  }
    945                }
    946                p_tmr = p_tmr_next;
    947                OSSchedUnlock(&err);
    948                (void)&err;
    949              }
    950          
    951          #if (OS_CFG_TS_EN == DEF_ENABLED)
    952              ts_delta = OS_TS_GET() - ts_start;                          // Measure execution time of timer task
    953              if (OSTmrTaskTimeMax < ts_delta) {
    954                OSTmrTaskTimeMax = ts_delta;
    955              }
    956          #endif
    957          
    958              OS_TmrUnlock();
    959            }
    960          }
    961          
    962          /********************************************************************************************************
    963           ********************************************************************************************************
    964           *                                           LOCAL FUNCTIONS
    965           ********************************************************************************************************
    966           *******************************************************************************************************/
    967          
    968          /*****************************************************************************************************//**
    969           *                                               OS_TmrLock()
    970           *
    971           * @brief    This function is used to lock the timer processing code. The preferred method is to use
    972           *           a mutex in order to avoid locking the scheduler and also, to avoid calling callback
    973           *           functions while the scheduler is locked.
    974           *
    975           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    976           *******************************************************************************************************/
    977          static void OS_TmrLock(void)
    978          {
    979            RTOS_ERR err;
    980          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    981            CPU_TS ts;
    982          
    983            OSMutexPend(&OSTmrMutex,                                      // Use a mutex to protect the timers
    984                        0u,
    985                        OS_OPT_PEND_BLOCKING,
    986                        &ts,
    987                        &err);
    988          #else
    989            OSSchedLock(&err);                                            // Lock the scheduler to protect the timers
    990          #endif
    991            (void)&err;
    992          }
    993          
    994          /*****************************************************************************************************//**
    995           *                                               OS_TmrUnlock()
    996           *
    997           * @brief    This function is used to unlock the timer processing code. The preferred method is to use
    998           *           a mutex in order to avoid locking the scheduler and also, to avoid calling callback
    999           *           functions while the scheduler is locked.
   1000           *
   1001           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1002           *******************************************************************************************************/
   1003          static void OS_TmrUnlock(void)
   1004          {
   1005            RTOS_ERR err;
   1006          
   1007          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   1008            OSMutexPost(&OSTmrMutex,                                      // Use a mutex to protect the timers
   1009                        OS_OPT_POST_NONE,
   1010                        &err);
   1011          #else
   1012            OSSchedUnlock(&err);                                          // Lock the scheduler to protect the timers
   1013          #endif
   1014            (void)&err;
   1015          }
   1016          #endif
   1017          
   1018          /********************************************************************************************************
   1019           ********************************************************************************************************
   1020           *                                   DEPENDENCIES & AVAIL CHECK(S) END
   1021           ********************************************************************************************************
   1022           *******************************************************************************************************/
   1023          
   1024          #endif // (defined(RTOS_MODULE_KERNEL_AVAIL))


 
 
 0 bytes of memory

Errors: none
Warnings: none
