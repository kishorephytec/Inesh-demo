###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:03
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_time.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_time.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_time.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_time.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir\os_time.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_time.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_time.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Kernel - Time Management
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                       DEPENDENCIES & AVAIL CHECK(S)
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <rtos_description.h>
     25          
     26          #if (defined(RTOS_MODULE_KERNEL_AVAIL))
     27          
     28          /********************************************************************************************************
     29           ********************************************************************************************************
     30           *                                               INCLUDE FILES
     31           ********************************************************************************************************
     32           *******************************************************************************************************/
     33          
     34          #define  MICRIUM_SOURCE
     35          #include "../include/os.h"
     36          #include "os_priv.h"
     37          
     38          #include  <em_core.h>
     39          
     40          #if (OS_CFG_TICK_EN == DEF_ENABLED)
     41          
     42          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     43          const CPU_CHAR *os_time__c = "$Id: $";
     44          #endif
     45          
     46          /********************************************************************************************************
     47           ********************************************************************************************************
     48           *                                           GLOBAL FUNCTIONS
     49           ********************************************************************************************************
     50           *******************************************************************************************************/
     51          
     52          /*****************************************************************************************************//**
     53           *                                         OSTimeTickRateHzGet()
     54           *
     55           * @brief    Gets kernel tick rate, in hertz.
     56           *
     57           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
     58           *                   from this function:
     59           *                       - RTOS_ERR_NONE
     60           *
     61           * @return   Kernel tick rate, in hertz.
     62           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     63          OS_RATE_HZ OSTimeTickRateHzGet(RTOS_ERR *p_err)
     64          {
   \                     OSTimeTickRateHzGet: (+1)
   \        0x0   0x0001             MOVS     R1,R0
     65            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x7008             STRB     R0,[R1, #+0]
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable4
   \        0xA   0x6048             STR      R0,[R1, #+4]
   \        0xC   0x2041             MOVS     R0,#+65
   \        0xE   0x6088             STR      R0,[R1, #+8]
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \       0x14   0x60C8             STR      R0,[R1, #+12]
     66          
     67            return (OSCfg_TickRate_Hz);
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x4770             BX       LR
     68          }
     69          
     70          /*****************************************************************************************************//**
     71           *                                               OSTimeDly()
     72           *
     73           * @brief    Delays the execution of the currently running task until the specified number of system
     74           *           ticks expires. This directly equates to delaying the current task for some time to
     75           *           expire. No delay will result if the specified delay is 0. If the specified delay is
     76           *           greater than 0, this results in a context switch.
     77           *
     78           * @param    dly     Value in 'clock ticks' that the task for which will delay. A value of 0 means that
     79           *                   the CPU is yield to another ready task that runs at the same priority (if any).
     80           *                   Depending on the option argument, the task will wake up in:
     81           *                       - OS_OPT_TIME_DLY         dly
     82           *                       - OS_OPT_TIME_TIMEOUT     dly
     83           *                       - OS_OPT_TIME_PERIODIC    OSTCBCurPtr.TickCtrPrev + dly
     84           *
     85           * @param    opt     Specifies whether 'dly' represents absolute or relative time; default option
     86           *                   is OS_OPT_TIME_DLY:
     87           *                       - OS_OPT_TIME_DLY         Specifies delay relative to current time.
     88           *                       - OS_OPT_TIME_TIMEOUT     Same as OS_OPT_TIME_DLY.
     89           *                       - OS_OPT_TIME_PERIODIC    Indicates that 'dly' specifies the periodic value
     90           *                                                 that current time must be a multiple of before the task
     91           *                                                 will be resumed.
     92           *
     93           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
     94           *                   from this function:
     95           *                       - RTOS_ERR_NONE
     96           *                       - RTOS_ERR_INVALID_ARG
     97           *                       - RTOS_ERR_OS_SCHED_LOCKED
     98           *                       - RTOS_ERR_NOT_READY
     99           *                       - RTOS_ERR_INVALID_STATE
    100           *                       - RTOS_ERR_NOT_INIT
    101           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    102          void OSTimeDly(OS_TICK  dly,
    103                         OS_OPT   opt,
    104                         RTOS_ERR *p_err)
    105          {
   \                     OSTimeDly: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0014             MOVS     R4,R2
    106            sl_status_t status;
    107            CPU_INT32U delay_ticks;
    108            CORE_DECLARE_IRQ_STATE;
    109          
    110            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??OSTimeDly_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    111          
    112            //                                                               Not allowed to call from an ISR
    113            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSTimeDly_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_InIrqContext
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??OSTimeDly_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??OSTimeDly_2
   \                     ??OSTimeDly_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDly_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10A             BNE.N    ??OSTimeDly_3
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x7020             STRB     R0,[R4, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x2E   0x6060             STR      R0,[R4, #+4]
   \       0x30   0x2071             MOVS     R0,#+113
   \       0x32   0x60A0             STR      R0,[R4, #+8]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \       0x38   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDly_4: (+1)
   \       0x3A   0xE7FE             B.N      ??OSTimeDly_4
    114          
    115            //                                                               Not allowed in atomic/critical sections
    116            OS_ASSERT_DBG_ERR_SET((!CORE_IrqIsDisabled()), *p_err, RTOS_ERR_INVALID_STATE,; );
   \                     ??OSTimeDly_3: (+1)
   \       0x3C   0x.... 0x....      BL       CORE_IrqIsDisabled
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD101             BNE.N    ??OSTimeDly_5
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE000             B.N      ??OSTimeDly_6
   \                     ??OSTimeDly_5: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDly_6: (+1)
   \       0x4A   0xB2C0             UXTB     R0,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD10A             BNE.N    ??OSTimeDly_7
   \       0x50   0x201F             MOVS     R0,#+31
   \       0x52   0x7020             STRB     R0,[R4, #+0]
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x58   0x6060             STR      R0,[R4, #+4]
   \       0x5A   0x2074             MOVS     R0,#+116
   \       0x5C   0x60A0             STR      R0,[R4, #+8]
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \       0x62   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDly_8: (+1)
   \       0x64   0xE7FE             B.N      ??OSTimeDly_8
    117          
    118            //                                                               Make sure kernel is running.
    119            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSTimeDly_7: (+1)
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \       0x6A   0x7800             LDRB     R0,[R0, #+0]
   \       0x6C   0x2801             CMP      R0,#+1
   \       0x6E   0xD00A             BEQ.N    ??OSTimeDly_9
    120              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x70   0x2002             MOVS     R0,#+2
   \       0x72   0x7020             STRB     R0,[R4, #+0]
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x78   0x6060             STR      R0,[R4, #+4]
   \       0x7A   0x2078             MOVS     R0,#+120
   \       0x7C   0x60A0             STR      R0,[R4, #+8]
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \       0x82   0x60E0             STR      R0,[R4, #+12]
    121              return;
   \       0x84   0xE118             B.N      ??OSTimeDly_10
    122            }
    123          
    124            if (OSSchedLockNestingCtr > 0u) {                             // Can't delay when the scheduler is locked
   \                     ??OSTimeDly_9: (+1)
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \       0x8A   0x7800             LDRB     R0,[R0, #+0]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD00A             BEQ.N    ??OSTimeDly_11
    125              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
   \       0x90   0x202D             MOVS     R0,#+45
   \       0x92   0x7020             STRB     R0,[R4, #+0]
   \       0x94   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x98   0x6060             STR      R0,[R4, #+4]
   \       0x9A   0x207D             MOVS     R0,#+125
   \       0x9C   0x60A0             STR      R0,[R4, #+8]
   \       0x9E   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \       0xA2   0x60E0             STR      R0,[R4, #+12]
    126              return;
   \       0xA4   0xE108             B.N      ??OSTimeDly_10
    127            }
    128          
    129            if (OS_SleeptimerFrequency_Hz == 0u) {
   \                     ??OSTimeDly_11: (+1)
   \       0xA6   0x.... 0x....      LDR.W    R6,??DataTable4_6
   \       0xAA   0x6830             LDR      R0,[R6, #+0]
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD10A             BNE.N    ??OSTimeDly_12
    130              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_INIT);
   \       0xB0   0x2013             MOVS     R0,#+19
   \       0xB2   0x7020             STRB     R0,[R4, #+0]
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0xB8   0x6060             STR      R0,[R4, #+4]
   \       0xBA   0x2082             MOVS     R0,#+130
   \       0xBC   0x60A0             STR      R0,[R4, #+8]
   \       0xBE   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \       0xC2   0x60E0             STR      R0,[R4, #+12]
    131              return;
   \       0xC4   0xE0F8             B.N      ??OSTimeDly_10
    132            }
    133          
    134            //                                                               Validate 'opt'
    135            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_TIME_DLY)
    136                                   || (opt == OS_OPT_TIME_TIMEOUT)
    137                                   || (opt == OS_OPT_TIME_PERIODIC)), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTimeDly_12: (+1)
   \       0xC6   0x0038             MOVS     R0,R7
   \       0xC8   0xB280             UXTH     R0,R0
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD007             BEQ.N    ??OSTimeDly_13
   \       0xCE   0x0038             MOVS     R0,R7
   \       0xD0   0xB280             UXTH     R0,R0
   \       0xD2   0x2802             CMP      R0,#+2
   \       0xD4   0xD003             BEQ.N    ??OSTimeDly_13
   \       0xD6   0x0038             MOVS     R0,R7
   \       0xD8   0xB280             UXTH     R0,R0
   \       0xDA   0x2808             CMP      R0,#+8
   \       0xDC   0xD101             BNE.N    ??OSTimeDly_14
   \                     ??OSTimeDly_13: (+1)
   \       0xDE   0x2001             MOVS     R0,#+1
   \       0xE0   0xE000             B.N      ??OSTimeDly_15
   \                     ??OSTimeDly_14: (+1)
   \       0xE2   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDly_15: (+1)
   \       0xE4   0xB2C0             UXTB     R0,R0
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD10A             BNE.N    ??OSTimeDly_16
   \       0xEA   0x2008             MOVS     R0,#+8
   \       0xEC   0x7020             STRB     R0,[R4, #+0]
   \       0xEE   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0xF2   0x6060             STR      R0,[R4, #+4]
   \       0xF4   0x2089             MOVS     R0,#+137
   \       0xF6   0x60A0             STR      R0,[R4, #+8]
   \       0xF8   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \       0xFC   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDly_17: (+1)
   \       0xFE   0xE7FE             B.N      ??OSTimeDly_17
    138          
    139            //                                                               Make sure we didn't specify a 0 delay
    140            OS_ASSERT_DBG_ERR_SET((dly != 0u) || (opt != OS_OPT_TIME_PERIODIC), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTimeDly_16: (+1)
   \      0x100   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x104   0xD103             BNE.N    ??OSTimeDly_18
   \      0x106   0x0038             MOVS     R0,R7
   \      0x108   0xB280             UXTH     R0,R0
   \      0x10A   0x2808             CMP      R0,#+8
   \      0x10C   0xD001             BEQ.N    ??OSTimeDly_19
   \                     ??OSTimeDly_18: (+1)
   \      0x10E   0x2001             MOVS     R0,#+1
   \      0x110   0xE000             B.N      ??OSTimeDly_20
   \                     ??OSTimeDly_19: (+1)
   \      0x112   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDly_20: (+1)
   \      0x114   0xB2C0             UXTB     R0,R0
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD10A             BNE.N    ??OSTimeDly_21
   \      0x11A   0x2008             MOVS     R0,#+8
   \      0x11C   0x7020             STRB     R0,[R4, #+0]
   \      0x11E   0x.... 0x....      LDR.W    R0,??DataTable4
   \      0x122   0x6060             STR      R0,[R4, #+4]
   \      0x124   0x208C             MOVS     R0,#+140
   \      0x126   0x60A0             STR      R0,[R4, #+8]
   \      0x128   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \      0x12C   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDly_22: (+1)
   \      0x12E   0xE7FE             B.N      ??OSTimeDly_22
    141          
    142            if ((opt == OS_OPT_TIME_DLY)
    143                || (opt == OS_OPT_TIME_TIMEOUT)) {
   \                     ??OSTimeDly_21: (+1)
   \      0x130   0x0038             MOVS     R0,R7
   \      0x132   0xB280             UXTH     R0,R0
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD003             BEQ.N    ??OSTimeDly_23
   \      0x138   0x0038             MOVS     R0,R7
   \      0x13A   0xB280             UXTH     R0,R0
   \      0x13C   0x2802             CMP      R0,#+2
   \      0x13E   0xD101             BNE.N    ??OSTimeDly_24
    144              delay_ticks = dly;
   \                     ??OSTimeDly_23: (+1)
   \      0x140   0x4645             MOV      R5,R8
   \      0x142   0xE03D             B.N      ??OSTimeDly_25
    145            } else {
    146              OS_TICK tick_ctr;
    147              OS_TICK tick_os_temp;
    148          
    149              tick_ctr = sl_sleeptimer_get_tick_count();
   \                     ??OSTimeDly_24: (+1)
   \      0x144   0x.... 0x....      BL       sl_sleeptimer_get_tick_count
   \      0x148   0x4681             MOV      R9,R0
    150              tick_os_temp = (uint64_t)((uint64_t)tick_ctr * (uint64_t)OSCfg_TickRate_Hz) / OS_SleeptimerFrequency_Hz;
   \      0x14A   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \      0x14E   0x6800             LDR      R0,[R0, #+0]
   \      0x150   0xFBA0 0x0109      UMULL    R0,R1,R0,R9
   \      0x154   0x6832             LDR      R2,[R6, #+0]
   \      0x156   0x2300             MOVS     R3,#+0
   \      0x158   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x15C   0x0002             MOVS     R2,R0
    151          
    152              if (OSTCBCurPtr->IsTickCtrPrevValid) {
   \      0x15E   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \      0x162   0x6808             LDR      R0,[R1, #+0]
   \      0x164   0xF890 0x003C      LDRB     R0,[R0, #+60]
   \      0x168   0x2800             CMP      R0,#+0
   \      0x16A   0xD00C             BEQ.N    ??OSTimeDly_26
    153                CPU_INT32S diff;
    154          
    155                OSTCBCurPtr->TickCtrPrev += dly;
   \      0x16C   0x6808             LDR      R0,[R1, #+0]
   \      0x16E   0x6C00             LDR      R0,[R0, #+64]
   \      0x170   0xEB18 0x0000      ADDS     R0,R8,R0
   \      0x174   0x680B             LDR      R3,[R1, #+0]
   \      0x176   0x6418             STR      R0,[R3, #+64]
    156          
    157                diff        = OSTCBCurPtr->TickCtrPrev - tick_os_temp;
   \      0x178   0x6808             LDR      R0,[R1, #+0]
   \      0x17A   0x6C05             LDR      R5,[R0, #+64]
   \      0x17C   0x1AAD             SUBS     R5,R5,R2
    158                delay_ticks = (diff > 0) ? (CPU_INT32U)diff : 0u;
   \      0x17E   0x2D01             CMP      R5,#+1
   \      0x180   0xDA0A             BGE.N    ??OSTimeDly_27
   \                     ??OSTimeDly_28: (+1)
   \      0x182   0x2500             MOVS     R5,#+0
   \      0x184   0xE008             B.N      ??OSTimeDly_27
    159              } else {
    160                delay_ticks                     = dly;
   \                     ??OSTimeDly_26: (+1)
   \      0x186   0x4645             MOV      R5,R8
    161                OSTCBCurPtr->TickCtrPrev        = tick_os_temp + dly;     // ... first time we load .TickCtrPrev
   \      0x188   0xEB18 0x0002      ADDS     R0,R8,R2
   \      0x18C   0x680B             LDR      R3,[R1, #+0]
   \      0x18E   0x6418             STR      R0,[R3, #+64]
    162                OSTCBCurPtr->IsTickCtrPrevValid = DEF_YES;
   \      0x190   0x2001             MOVS     R0,#+1
   \      0x192   0x680B             LDR      R3,[R1, #+0]
   \      0x194   0xF883 0x003C      STRB     R0,[R3, #+60]
    163              }
    164          
    165              if (OSDelayMaxTick != 0 && OSTCBCurPtr->TickCtrPrev >= OSDelayMaxTick) {
   \                     ??OSTimeDly_27: (+1)
   \      0x198   0x.... 0x....      LDR.W    R3,??DataTable4_8
   \      0x19C   0x6818             LDR      R0,[R3, #+0]
   \      0x19E   0x2800             CMP      R0,#+0
   \      0x1A0   0xD00E             BEQ.N    ??OSTimeDly_25
   \      0x1A2   0x6808             LDR      R0,[R1, #+0]
   \      0x1A4   0x6C00             LDR      R0,[R0, #+64]
   \      0x1A6   0xF8D3 0xC000      LDR      R12,[R3, #+0]
   \      0x1AA   0x4560             CMP      R0,R12
   \      0x1AC   0xD308             BCC.N    ??OSTimeDly_25
    166                OSTCBCurPtr->TickCtrPrev -= OSDelayMaxTick;               // Adjust in case of sleep timer overflow
   \      0x1AE   0x6808             LDR      R0,[R1, #+0]
   \      0x1B0   0xF8D0 0xC040      LDR      R12,[R0, #+64]
   \      0x1B4   0x6818             LDR      R0,[R3, #+0]
   \      0x1B6   0xEBBC 0x0C00      SUBS     R12,R12,R0
   \      0x1BA   0x6808             LDR      R0,[R1, #+0]
   \      0x1BC   0xF8C0 0xC040      STR      R12,[R0, #+64]
    167              }
    168            }
    169          
    170            if (delay_ticks > 0u) {
   \                     ??OSTimeDly_25: (+1)
   \      0x1C0   0x2D00             CMP      R5,#+0
   \      0x1C2   0xD04D             BEQ.N    ??OSTimeDly_29
    171              uint32_t delay;
    172          
    173              // Check for potential overflow
    174              if (OSDelayMaxTick != 0 && delay_ticks >= OSDelayMaxTick) {
   \      0x1C4   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \      0x1C8   0x6808             LDR      R0,[R1, #+0]
   \      0x1CA   0x2800             CMP      R0,#+0
   \      0x1CC   0xD00D             BEQ.N    ??OSTimeDly_30
   \      0x1CE   0x6808             LDR      R0,[R1, #+0]
   \      0x1D0   0x4285             CMP      R5,R0
   \      0x1D2   0xD30A             BCC.N    ??OSTimeDly_30
    175                RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   \      0x1D4   0x201E             MOVS     R0,#+30
   \      0x1D6   0x7020             STRB     R0,[R4, #+0]
   \      0x1D8   0x.... 0x....      LDR.W    R0,??DataTable4
   \      0x1DC   0x6060             STR      R0,[R4, #+4]
   \      0x1DE   0x20AF             MOVS     R0,#+175
   \      0x1E0   0x60A0             STR      R0,[R4, #+8]
   \      0x1E2   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \      0x1E6   0x60E0             STR      R0,[R4, #+12]
    176                return;
   \      0x1E8   0xE066             B.N      ??OSTimeDly_10
    177              }
    178          
    179              delay = (uint64_t)(((uint64_t)delay_ticks * (uint64_t)OS_SleeptimerFrequency_Hz) + (OSCfg_TickRate_Hz - 1u)) / OSCfg_TickRate_Hz;
   \                     ??OSTimeDly_30: (+1)
   \      0x1EA   0x.... 0x....      LDR.W    R2,??DataTable4_2
   \      0x1EE   0x6833             LDR      R3,[R6, #+0]
   \      0x1F0   0x6810             LDR      R0,[R2, #+0]
   \      0x1F2   0x1E40             SUBS     R0,R0,#+1
   \      0x1F4   0x2100             MOVS     R1,#+0
   \      0x1F6   0xFBE3 0x0105      UMLAL    R0,R1,R3,R5
   \      0x1FA   0x6812             LDR      R2,[R2, #+0]
   \      0x1FC   0x2300             MOVS     R3,#+0
   \      0x1FE   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x202   0x4683             MOV      R11,R0
    180          
    181              CORE_ENTER_ATOMIC();
   \      0x204   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x208   0x4681             MOV      R9,R0
    182          
    183              status = sl_sleeptimer_start_timer(&OSTCBCurPtr->TimerHandle,
    184                                                 delay,
    185                                                 OS_TimerCallback,
    186                                                 (void *)OSTCBCurPtr,
    187                                                 0u,
    188                                                 0u);
   \      0x20A   0x.... 0x....      LDR.W    R6,??DataTable4_7
   \      0x20E   0x2000             MOVS     R0,#+0
   \      0x210   0x9001             STR      R0,[SP, #+4]
   \      0x212   0x2000             MOVS     R0,#+0
   \      0x214   0x9000             STR      R0,[SP, #+0]
   \      0x216   0x6833             LDR      R3,[R6, #+0]
   \      0x218   0x.... 0x....      LDR.W    R2,??DataTable4_9
   \      0x21C   0x4659             MOV      R1,R11
   \      0x21E   0x6830             LDR      R0,[R6, #+0]
   \      0x220   0x3044             ADDS     R0,R0,#+68
   \      0x222   0x.... 0x....      BL       sl_sleeptimer_start_timer
   \      0x226   0x4682             MOV      R10,R0
    189              if (status != SL_STATUS_OK) {
   \      0x228   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x22C   0xD00D             BEQ.N    ??OSTimeDly_31
    190                CORE_EXIT_ATOMIC();
   \      0x22E   0x4648             MOV      R0,R9
   \      0x230   0x.... 0x....      BL       CORE_ExitAtomic
    191                RTOS_ERR_SET(*p_err, RTOS_ERR_FAIL);
   \      0x234   0x2001             MOVS     R0,#+1
   \      0x236   0x7020             STRB     R0,[R4, #+0]
   \      0x238   0x.... 0x....      LDR.W    R0,??DataTable4
   \      0x23C   0x6060             STR      R0,[R4, #+4]
   \      0x23E   0x20BF             MOVS     R0,#+191
   \      0x240   0x60A0             STR      R0,[R4, #+8]
   \      0x242   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \      0x246   0x60E0             STR      R0,[R4, #+12]
    192                return;
   \      0x248   0xE036             B.N      ??OSTimeDly_10
    193              }
    194          
    195              OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
   \                     ??OSTimeDly_31: (+1)
   \      0x24A   0x2101             MOVS     R1,#+1
   \      0x24C   0x6830             LDR      R0,[R6, #+0]
   \      0x24E   0xF880 0x1026      STRB     R1,[R0, #+38]
    196              OS_TRACE_TASK_DLY(dly);
    197              OS_RdyListRemove(OSTCBCurPtr);                              // Remove current task from ready list
   \      0x252   0x6830             LDR      R0,[R6, #+0]
   \      0x254   0x.... 0x....      BL       OS_RdyListRemove
    198              CORE_EXIT_ATOMIC();
   \      0x258   0x4648             MOV      R0,R9
   \      0x25A   0x.... 0x....      BL       CORE_ExitAtomic
   \      0x25E   0xE021             B.N      ??OSTimeDly_32
    199            } else {
    200              OS_RDY_LIST *p_rdy_list;
    201          
    202              CORE_ENTER_ATOMIC();
   \                     ??OSTimeDly_29: (+1)
   \      0x260   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x264   0x4681             MOV      R9,R0
    203              p_rdy_list = &OSRdyList[OSPrioCur];                         // Can't yield if it's the only task at that priority
   \      0x266   0x.... 0x....      LDR.W    R0,??DataTable4_10
   \      0x26A   0x.... 0x....      LDR.W    R1,??DataTable4_11
   \      0x26E   0x7809             LDRB     R1,[R1, #+0]
   \      0x270   0xEB00 0x06C1      ADD      R6,R0,R1, LSL #+3
    204              if (p_rdy_list->HeadPtr == p_rdy_list->TailPtr) {
   \      0x274   0x6831             LDR      R1,[R6, #+0]
   \      0x276   0x6870             LDR      R0,[R6, #+4]
   \      0x278   0x4281             CMP      R1,R0
   \      0x27A   0xD10D             BNE.N    ??OSTimeDly_33
    205                CORE_EXIT_ATOMIC();
   \      0x27C   0x4648             MOV      R0,R9
   \      0x27E   0x.... 0x....      BL       CORE_ExitAtomic
    206                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x282   0x2000             MOVS     R0,#+0
   \      0x284   0x7020             STRB     R0,[R4, #+0]
   \      0x286   0x.... 0x....      LDR.W    R0,??DataTable4
   \      0x28A   0x6060             STR      R0,[R4, #+4]
   \      0x28C   0x20CE             MOVS     R0,#+206
   \      0x28E   0x60A0             STR      R0,[R4, #+8]
   \      0x290   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \      0x294   0x60E0             STR      R0,[R4, #+12]
    207                return;
   \      0x296   0xE00F             B.N      ??OSTimeDly_10
    208              }
    209          
    210              OS_RdyListMoveHeadToTail(p_rdy_list);
   \                     ??OSTimeDly_33: (+1)
   \      0x298   0x0030             MOVS     R0,R6
   \      0x29A   0x.... 0x....      BL       OS_RdyListMoveHeadToTail
    211              CORE_EXIT_ATOMIC();
   \      0x29E   0x4648             MOV      R0,R9
   \      0x2A0   0x.... 0x....      BL       CORE_ExitAtomic
    212            }
    213          
    214            OSSched();                                                    // Find next task to run!
   \                     ??OSTimeDly_32: (+1)
   \      0x2A4   0x.... 0x....      BL       OSSched
    215          
    216            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x2A8   0x2000             MOVS     R0,#+0
   \      0x2AA   0x7020             STRB     R0,[R4, #+0]
   \      0x2AC   0x....             LDR.N    R0,??DataTable4
   \      0x2AE   0x6060             STR      R0,[R4, #+4]
   \      0x2B0   0x20D8             MOVS     R0,#+216
   \      0x2B2   0x60A0             STR      R0,[R4, #+8]
   \      0x2B4   0x....             LDR.N    R0,??DataTable4_3
   \      0x2B6   0x60E0             STR      R0,[R4, #+12]
    217          }
   \                     ??OSTimeDly_10: (+1)
   \      0x2B8   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    218          
    219          /****************************************************************************************************//**
    220           *                                               OSTimeDlyHMSM()
    221           *
    222           * @brief    Delay execution of the currently running task until some time expires. This call allows
    223           *           you to specify the delay time in HOURS, MINUTES, SECONDS, and MILLISECONDS instead of ticks.
    224           *
    225           * @param    hours       Specifies the number of hours that the task will be delayed (max. is 999 if the
    226           *                       tick rate is 1000 Hz or less otherwise, a higher value would overflow a 32-bit
    227           *                       unsigned counter). (max. 99 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    228           *
    229           * @param    minutes     Specifies the number of minutes. (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    230           *
    231           * @param    seconds     Specifies the number of seconds. (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    232           *
    233           * @param    milli       Specifies the number of milliseconds. (max. 999 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    234           *
    235           * @param    opt         Specifies time delay bit-field options logically OR'd; default options marked
    236           *                       with *** :
    237           *                           - OS_OPT_TIME_DLY         *** Specifies a relative time from the current
    238           *                                                   value of OSTickCtr.
    239           *                           - OS_OPT_TIME_TIMEOUT     Same as OS_OPT_TIME_DLY.
    240           *                           - OS_OPT_TIME_PERIODIC    Indicates that the delay specifies the
    241           *                                                     periodic value that OSTickCtr must reach
    242           *                                                     before the task will be resumed.
    243           *                           - OS_OPT_TIME_HMSM_STRICT    *** Strictly allows only hours        (0...99)
    244           *                                                                                 minutes      (0...59)
    245           *                                                                                 seconds      (0...59)
    246           *                                                                                 milliseconds (0...999)
    247           *                           - OS_OPT_TIME_HMSM_NON_STRICT    Allows any value of  hours        (0...999)
    248           *                                                                                 minutes      (0...9999)
    249           *                                                                                 seconds      (0...65535)
    250           *                                                                                 milliseconds (0...4294967295)
    251           *
    252           * @param    p_err       Pointer to the variable that will receive one of the following error code(s)
    253           *                       from this function:
    254           *                           - RTOS_ERR_NONE
    255           *                           - RTOS_ERR_INVALID_ARG
    256           *                           - RTOS_ERR_OS_SCHED_LOCKED
    257           *
    258           * @note     (1) The resolution of milliseconds depends on the tick rate. For example, you cannot
    259           *                   do a 10 mS delay if the ticker interrupts every 100 mS. In this case, the delay would
    260           *                   be set to 0. The actual delay is rounded to the nearest tick.
    261           *
    262           * @note     (2) Although this function allows you to delay a task for many hours, it is not recommended
    263           *                   to put a task to sleep for that long.
    264           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    265          void OSTimeDlyHMSM(CPU_INT16U hours,
    266                             CPU_INT16U minutes,
    267                             CPU_INT16U seconds,
    268                             CPU_INT32U milli,
    269                             OS_OPT     opt,
    270                             RTOS_ERR   *p_err)
    271          {
   \                     OSTimeDlyHMSM: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0x9D0C             LDR      R5,[SP, #+48]
   \        0xE   0x9C0D             LDR      R4,[SP, #+52]
    272            OS_OPT opt_time;
    273            OS_TICK ticks;
    274            OS_TICK hours_tick;
    275            OS_TICK minutes_tick;
    276            OS_TICK overflow_check;
    277          
    278            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD101             BNE.N    ??OSTimeDlyHMSM_0
   \       0x14   0x.... 0x....      BL       CPU_SW_Exception
    279          
    280            opt_time = opt & OS_OPT_TIME_MASK;                            // Retrieve time options only.
   \                     ??OSTimeDlyHMSM_0: (+1)
   \       0x18   0xF015 0x000A      ANDS     R0,R5,#0xA
   \       0x1C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    281          
    282            OS_ASSERT_DBG_ERR_SET((DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK) != DEF_YES), *p_err, RTOS_ERR_INVALID_ARG,; );
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0xF030 0x001A      BICS     R0,R0,#0x1A
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD009             BEQ.N    ??OSTimeDlyHMSM_1
   \       0x2C   0x2008             MOVS     R0,#+8
   \       0x2E   0x7020             STRB     R0,[R4, #+0]
   \       0x30   0x....             LDR.N    R0,??DataTable4
   \       0x32   0x6060             STR      R0,[R4, #+4]
   \       0x34   0xF44F 0x708D      MOV      R0,#+282
   \       0x38   0x60A0             STR      R0,[R4, #+8]
   \       0x3A   0x....             LDR.N    R0,??DataTable4_12
   \       0x3C   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDlyHMSM_2: (+1)
   \       0x3E   0xE7FE             B.N      ??OSTimeDlyHMSM_2
    283          
    284            if (DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT) != DEF_YES) {
   \                     ??OSTimeDlyHMSM_1: (+1)
   \       0x40   0x0028             MOVS     R0,R5
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0x0900             LSRS     R0,R0,#+4
   \       0x46   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD136             BNE.N    ??OSTimeDlyHMSM_3
    285              OS_ASSERT_DBG_ERR_SET((milli <= 999u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \       0x4E   0xF5B8 0x7F7A      CMP      R8,#+1000
   \       0x52   0xD309             BCC.N    ??OSTimeDlyHMSM_4
   \       0x54   0x2008             MOVS     R0,#+8
   \       0x56   0x7020             STRB     R0,[R4, #+0]
   \       0x58   0x....             LDR.N    R0,??DataTable4
   \       0x5A   0x6060             STR      R0,[R4, #+4]
   \       0x5C   0xF240 0x101D      MOVW     R0,#+285
   \       0x60   0x60A0             STR      R0,[R4, #+8]
   \       0x62   0x....             LDR.N    R0,??DataTable4_12
   \       0x64   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDlyHMSM_5: (+1)
   \       0x66   0xE7FE             B.N      ??OSTimeDlyHMSM_5
    286              OS_ASSERT_DBG_ERR_SET((seconds <= 59u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTimeDlyHMSM_4: (+1)
   \       0x68   0x0038             MOVS     R0,R7
   \       0x6A   0xB280             UXTH     R0,R0
   \       0x6C   0x283C             CMP      R0,#+60
   \       0x6E   0xD309             BCC.N    ??OSTimeDlyHMSM_6
   \       0x70   0x2008             MOVS     R0,#+8
   \       0x72   0x7020             STRB     R0,[R4, #+0]
   \       0x74   0x....             LDR.N    R0,??DataTable4
   \       0x76   0x6060             STR      R0,[R4, #+4]
   \       0x78   0xF44F 0x708F      MOV      R0,#+286
   \       0x7C   0x60A0             STR      R0,[R4, #+8]
   \       0x7E   0x....             LDR.N    R0,??DataTable4_12
   \       0x80   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDlyHMSM_7: (+1)
   \       0x82   0xE7FE             B.N      ??OSTimeDlyHMSM_7
    287              OS_ASSERT_DBG_ERR_SET((minutes <= 59u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTimeDlyHMSM_6: (+1)
   \       0x84   0x0030             MOVS     R0,R6
   \       0x86   0xB280             UXTH     R0,R0
   \       0x88   0x283C             CMP      R0,#+60
   \       0x8A   0xD309             BCC.N    ??OSTimeDlyHMSM_8
   \       0x8C   0x2008             MOVS     R0,#+8
   \       0x8E   0x7020             STRB     R0,[R4, #+0]
   \       0x90   0x....             LDR.N    R0,??DataTable4
   \       0x92   0x6060             STR      R0,[R4, #+4]
   \       0x94   0xF240 0x101F      MOVW     R0,#+287
   \       0x98   0x60A0             STR      R0,[R4, #+8]
   \       0x9A   0x....             LDR.N    R0,??DataTable4_12
   \       0x9C   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDlyHMSM_9: (+1)
   \       0x9E   0xE7FE             B.N      ??OSTimeDlyHMSM_9
    288              OS_ASSERT_DBG_ERR_SET((hours <= 99u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTimeDlyHMSM_8: (+1)
   \       0xA0   0x4648             MOV      R0,R9
   \       0xA2   0xB280             UXTH     R0,R0
   \       0xA4   0x2864             CMP      R0,#+100
   \       0xA6   0xD328             BCC.N    ??OSTimeDlyHMSM_10
   \       0xA8   0x2008             MOVS     R0,#+8
   \       0xAA   0x7020             STRB     R0,[R4, #+0]
   \       0xAC   0x....             LDR.N    R0,??DataTable4
   \       0xAE   0x6060             STR      R0,[R4, #+4]
   \       0xB0   0xF44F 0x7090      MOV      R0,#+288
   \       0xB4   0x60A0             STR      R0,[R4, #+8]
   \       0xB6   0x....             LDR.N    R0,??DataTable4_12
   \       0xB8   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDlyHMSM_11: (+1)
   \       0xBA   0xE7FE             B.N      ??OSTimeDlyHMSM_11
    289            } else {
    290              OS_ASSERT_DBG_ERR_SET((minutes <= 9999u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTimeDlyHMSM_3: (+1)
   \       0xBC   0x0030             MOVS     R0,R6
   \       0xBE   0xB280             UXTH     R0,R0
   \       0xC0   0xF242 0x7110      MOVW     R1,#+10000
   \       0xC4   0x4288             CMP      R0,R1
   \       0xC6   0xD309             BCC.N    ??OSTimeDlyHMSM_12
   \       0xC8   0x2008             MOVS     R0,#+8
   \       0xCA   0x7020             STRB     R0,[R4, #+0]
   \       0xCC   0x....             LDR.N    R0,??DataTable4
   \       0xCE   0x6060             STR      R0,[R4, #+4]
   \       0xD0   0xF44F 0x7091      MOV      R0,#+290
   \       0xD4   0x60A0             STR      R0,[R4, #+8]
   \       0xD6   0x....             LDR.N    R0,??DataTable4_12
   \       0xD8   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDlyHMSM_13: (+1)
   \       0xDA   0xE7FE             B.N      ??OSTimeDlyHMSM_13
    291              OS_ASSERT_DBG_ERR_SET((hours <= 999u), *p_err, RTOS_ERR_INVALID_ARG,; );
   \                     ??OSTimeDlyHMSM_12: (+1)
   \       0xDC   0x4648             MOV      R0,R9
   \       0xDE   0xB280             UXTH     R0,R0
   \       0xE0   0xF5B0 0x7F7A      CMP      R0,#+1000
   \       0xE4   0xD309             BCC.N    ??OSTimeDlyHMSM_10
   \       0xE6   0x2008             MOVS     R0,#+8
   \       0xE8   0x7020             STRB     R0,[R4, #+0]
   \       0xEA   0x....             LDR.N    R0,??DataTable4
   \       0xEC   0x6060             STR      R0,[R4, #+4]
   \       0xEE   0xF240 0x1023      MOVW     R0,#+291
   \       0xF2   0x60A0             STR      R0,[R4, #+8]
   \       0xF4   0x....             LDR.N    R0,??DataTable4_12
   \       0xF6   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSTimeDlyHMSM_14: (+1)
   \       0xF8   0xE7FE             B.N      ??OSTimeDlyHMSM_14
    292            }
    293          
    294            hours_tick = (OS_TICK)hours * (OS_TICK)3600u;
   \                     ??OSTimeDlyHMSM_10: (+1)
   \       0xFA   0x4649             MOV      R1,R9
   \       0xFC   0xB289             UXTH     R1,R1
   \       0xFE   0xF44F 0x6061      MOV      R0,#+3600
   \      0x102   0x4341             MULS     R1,R0,R1
   \      0x104   0x9102             STR      R1,[SP, #+8]
    295            minutes_tick = (OS_TICK)minutes * (OS_TICK)60u;
   \      0x106   0x0031             MOVS     R1,R6
   \      0x108   0xB289             UXTH     R1,R1
   \      0x10A   0x203C             MOVS     R0,#+60
   \      0x10C   0x4341             MULS     R1,R0,R1
   \      0x10E   0x9101             STR      R1,[SP, #+4]
    296          
    297            //                                                               Convert everything to milliseconds
    298            overflow_check = ((hours_tick + minutes_tick + (OS_TICK)seconds) * (OS_TICK)1000u) + milli;
   \      0x110   0x9902             LDR      R1,[SP, #+8]
   \      0x112   0x9801             LDR      R0,[SP, #+4]
   \      0x114   0x1841             ADDS     R1,R0,R1
   \      0x116   0xFA11 0xF087      UXTAH    R0,R1,R7
   \      0x11A   0xF44F 0x7A7A      MOV      R10,#+1000
   \      0x11E   0xFB0A 0x8A00      MLA      R10,R10,R0,R8
    299          
    300            //                                                               Check for potential overflow
    301            if (OSDelayMaxMilli != 0 && overflow_check >= OSDelayMaxMilli) {
   \      0x122   0x....             LDR.N    R1,??DataTable4_13
   \      0x124   0x6808             LDR      R0,[R1, #+0]
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD00C             BEQ.N    ??OSTimeDlyHMSM_15
   \      0x12A   0x6808             LDR      R0,[R1, #+0]
   \      0x12C   0x4582             CMP      R10,R0
   \      0x12E   0xD309             BCC.N    ??OSTimeDlyHMSM_15
    302              RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   \      0x130   0x201E             MOVS     R0,#+30
   \      0x132   0x7020             STRB     R0,[R4, #+0]
   \      0x134   0x....             LDR.N    R0,??DataTable4
   \      0x136   0x6060             STR      R0,[R4, #+4]
   \      0x138   0xF44F 0x7097      MOV      R0,#+302
   \      0x13C   0x60A0             STR      R0,[R4, #+8]
   \      0x13E   0x....             LDR.N    R0,??DataTable4_12
   \      0x140   0x60E0             STR      R0,[R4, #+12]
    303              return;
   \      0x142   0xE01C             B.N      ??OSTimeDlyHMSM_16
    304            }
    305          
    306            //                                                               Compute the total number of clock ticks required..   */
    307            //                                                               .. (rounded to the nearest tick)                     */
    308          
    309            ticks = (hours_tick + minutes_tick + (OS_TICK)seconds) * OSCfg_TickRate_Hz
    310                    + (OSCfg_TickRate_Hz * ((OS_TICK)milli + (OS_TICK)500u / OSCfg_TickRate_Hz)) / (OS_TICK)1000u;
   \                     ??OSTimeDlyHMSM_15: (+1)
   \      0x144   0x....             LDR.N    R1,??DataTable4_2
   \      0x146   0x9A02             LDR      R2,[SP, #+8]
   \      0x148   0x9801             LDR      R0,[SP, #+4]
   \      0x14A   0x1882             ADDS     R2,R0,R2
   \      0x14C   0xFA12 0xF087      UXTAH    R0,R2,R7
   \      0x150   0x680A             LDR      R2,[R1, #+0]
   \      0x152   0x680B             LDR      R3,[R1, #+0]
   \      0x154   0xF44F 0x7CFA      MOV      R12,#+500
   \      0x158   0x6809             LDR      R1,[R1, #+0]
   \      0x15A   0xFBBC 0xF1F1      UDIV     R1,R12,R1
   \      0x15E   0xEB11 0x0108      ADDS     R1,R1,R8
   \      0x162   0x434B             MULS     R3,R1,R3
   \      0x164   0xF44F 0x717A      MOV      R1,#+1000
   \      0x168   0xFBB3 0xF1F1      UDIV     R1,R3,R1
   \      0x16C   0x4683             MOV      R11,R0
   \      0x16E   0xFB02 0x1B0B      MLA      R11,R2,R11,R1
    311          
    312            OSTimeDly(ticks, opt_time, p_err);
   \      0x172   0x0022             MOVS     R2,R4
   \      0x174   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \      0x178   0x4658             MOV      R0,R11
   \      0x17A   0x.... 0x....      BL       OSTimeDly
    313          }
   \                     ??OSTimeDlyHMSM_16: (+1)
   \      0x17E   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    314          
    315          /****************************************************************************************************//**
    316           *                                               OSTimeDlyResume()
    317           *
    318           * @brief    Resumes a task that has been delayed through a call to either OSTimeDly() or
    319           *           OSTimeDlyHMSM(). Note that you cannot call this function to resume a task that is waiting
    320           *           for an event with timeout.
    321           *
    322           * @param    p_tcb   Pointer to the TCB of the task to resume.
    323           *
    324           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    325           *                   from this function:
    326           *                       - RTOS_ERR_NONE
    327           *                       - RTOS_ERR_OS_TASK_SUSPENDED
    328           *                       - RTOS_ERR_INVALID_STATE
    329           *                       - RTOS_ERR_NOT_READY
    330           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    331          void OSTimeDlyResume(OS_TCB   *p_tcb,
    332                               RTOS_ERR *p_err)
    333          {
   \                     OSTimeDlyResume: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
    334            sl_status_t status;
    335            CORE_DECLARE_IRQ_STATE;
    336          
    337            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x6   0x2E00             CMP      R6,#+0
   \        0x8   0xD101             BNE.N    ??OSTimeDlyResume_0
   \        0xA   0x.... 0x....      BL       CPU_SW_Exception
    338          
    339            //                                                               Not allowed to call from an ISR
    340            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSTimeDlyResume_0: (+1)
   \        0xE   0x.... 0x....      BL       CORE_InIrqContext
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??OSTimeDlyResume_1
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xE000             B.N      ??OSTimeDlyResume_2
   \                     ??OSTimeDlyResume_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDlyResume_2: (+1)
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD109             BNE.N    ??OSTimeDlyResume_3
   \       0x22   0x2020             MOVS     R0,#+32
   \       0x24   0x7030             STRB     R0,[R6, #+0]
   \       0x26   0x....             LDR.N    R0,??DataTable4
   \       0x28   0x6070             STR      R0,[R6, #+4]
   \       0x2A   0xF44F 0x70AA      MOV      R0,#+340
   \       0x2E   0x60B0             STR      R0,[R6, #+8]
   \       0x30   0x....             LDR.N    R0,??DataTable4_14
   \       0x32   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSTimeDlyResume_4: (+1)
   \       0x34   0xE7FE             B.N      ??OSTimeDlyResume_4
    341          
    342            //                                                               User must supply a valid OS_TCB
    343            OS_ASSERT_DBG_ERR_SET((p_tcb != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSTimeDlyResume_3: (+1)
   \       0x36   0x2D00             CMP      R5,#+0
   \       0x38   0xD109             BNE.N    ??OSTimeDlyResume_5
   \       0x3A   0x200A             MOVS     R0,#+10
   \       0x3C   0x7030             STRB     R0,[R6, #+0]
   \       0x3E   0x....             LDR.N    R0,??DataTable4
   \       0x40   0x6070             STR      R0,[R6, #+4]
   \       0x42   0xF240 0x1057      MOVW     R0,#+343
   \       0x46   0x60B0             STR      R0,[R6, #+8]
   \       0x48   0x....             LDR.N    R0,??DataTable4_14
   \       0x4A   0x60F0             STR      R0,[R6, #+12]
   \                     ??OSTimeDlyResume_6: (+1)
   \       0x4C   0xE7FE             B.N      ??OSTimeDlyResume_6
    344          
    345            //                                                               Make sure kernel is running.
    346            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSTimeDlyResume_5: (+1)
   \       0x4E   0x....             LDR.N    R0,??DataTable4_4
   \       0x50   0x7800             LDRB     R0,[R0, #+0]
   \       0x52   0x2801             CMP      R0,#+1
   \       0x54   0xD009             BEQ.N    ??OSTimeDlyResume_7
    347              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x56   0x2002             MOVS     R0,#+2
   \       0x58   0x7030             STRB     R0,[R6, #+0]
   \       0x5A   0x....             LDR.N    R0,??DataTable4
   \       0x5C   0x6070             STR      R0,[R6, #+4]
   \       0x5E   0xF240 0x105B      MOVW     R0,#+347
   \       0x62   0x60B0             STR      R0,[R6, #+8]
   \       0x64   0x....             LDR.N    R0,??DataTable4_14
   \       0x66   0x60F0             STR      R0,[R6, #+12]
    348              return;
   \       0x68   0xE057             B.N      ??OSTimeDlyResume_8
    349            }
    350          
    351            CORE_ENTER_ATOMIC();
   \                     ??OSTimeDlyResume_7: (+1)
   \       0x6A   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x6E   0x0007             MOVS     R7,R0
    352            switch (p_tcb->TaskState) {
   \       0x70   0xF895 0x1026      LDRB     R1,[R5, #+38]
   \       0x74   0x2900             CMP      R1,#+0
   \       0x76   0xD00C             BEQ.N    ??OSTimeDlyResume_9
   \       0x78   0x1E49             SUBS     R1,R1,#+1
   \       0x7A   0xD017             BEQ.N    ??OSTimeDlyResume_10
   \       0x7C   0x1E49             SUBS     R1,R1,#+1
   \       0x7E   0x2902             CMP      R1,#+2
   \       0x80   0xD907             BLS.N    ??OSTimeDlyResume_9
   \       0x82   0x1EC9             SUBS     R1,R1,#+3
   \       0x84   0xD025             BEQ.N    ??OSTimeDlyResume_11
   \       0x86   0x1E49             SUBS     R1,R1,#+1
   \       0x88   0x2901             CMP      R1,#+1
   \       0x8A   0xD902             BLS.N    ??OSTimeDlyResume_9
   \       0x8C   0x39F9             SUBS     R1,R1,#+249
   \       0x8E   0xD030             BEQ.N    ??OSTimeDlyResume_12
   \       0x90   0xE03C             B.N      ??OSTimeDlyResume_13
    353              case OS_TASK_STATE_RDY:                                     // Cannot Abort delay if task is ready
    354              case OS_TASK_STATE_PEND:
    355              case OS_TASK_STATE_PEND_TIMEOUT:
    356              case OS_TASK_STATE_SUSPENDED:
    357              case OS_TASK_STATE_PEND_SUSPENDED:
    358              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    359                CORE_EXIT_ATOMIC();
   \                     ??OSTimeDlyResume_9: (+1)
   \       0x92   0x0038             MOVS     R0,R7
   \       0x94   0x.... 0x....      BL       CORE_ExitAtomic
    360                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
   \       0x98   0x201F             MOVS     R0,#+31
   \       0x9A   0x7030             STRB     R0,[R6, #+0]
   \       0x9C   0x....             LDR.N    R0,??DataTable4
   \       0x9E   0x6070             STR      R0,[R6, #+4]
   \       0xA0   0xF44F 0x70B4      MOV      R0,#+360
   \       0xA4   0x60B0             STR      R0,[R6, #+8]
   \       0xA6   0x....             LDR.N    R0,??DataTable4_14
   \       0xA8   0x60F0             STR      R0,[R6, #+12]
    361                break;
   \       0xAA   0xE034             B.N      ??OSTimeDlyResume_14
    362          
    363              case OS_TASK_STATE_DLY:
    364          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    365                p_tcb->TaskState = OS_TASK_STATE_RDY;
   \                     ??OSTimeDlyResume_10: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xF885 0x0026      STRB     R0,[R5, #+38]
    366                OS_RdyListInsert(p_tcb);                                  // Add to ready list                                    */
   \       0xB2   0x0028             MOVS     R0,R5
   \       0xB4   0x.... 0x....      BL       OS_RdyListInsert
    367                status = sl_sleeptimer_stop_timer(&p_tcb->TimerHandle);
   \       0xB8   0xF115 0x0044      ADDS     R0,R5,#+68
   \       0xBC   0x.... 0x....      BL       sl_sleeptimer_stop_timer
   \       0xC0   0x0004             MOVS     R4,R0
    368                RTOS_ASSERT_CRITICAL((status == SL_STATUS_OK), RTOS_ERR_FAIL,; );
   \       0xC2   0x2C00             CMP      R4,#+0
   \       0xC4   0xD001             BEQ.N    ??OSTimeDlyResume_15
   \       0xC6   0x.... 0x....      BL       CPU_SW_Exception
    369          #endif
    370                CORE_EXIT_ATOMIC();
   \                     ??OSTimeDlyResume_15: (+1)
   \       0xCA   0x0038             MOVS     R0,R7
   \       0xCC   0x.... 0x....      BL       CORE_ExitAtomic
    371                break;
   \       0xD0   0xE021             B.N      ??OSTimeDlyResume_14
    372          
    373              case OS_TASK_STATE_DLY_SUSPENDED:
    374          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    375                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OSTimeDlyResume_11: (+1)
   \       0xD2   0x2004             MOVS     R0,#+4
   \       0xD4   0xF885 0x0026      STRB     R0,[R5, #+38]
    376                status = sl_sleeptimer_stop_timer(&p_tcb->TimerHandle);
   \       0xD8   0xF115 0x0044      ADDS     R0,R5,#+68
   \       0xDC   0x.... 0x....      BL       sl_sleeptimer_stop_timer
   \       0xE0   0x0004             MOVS     R4,R0
    377                RTOS_ASSERT_CRITICAL((status == SL_STATUS_OK), RTOS_ERR_FAIL,; );
   \       0xE2   0x2C00             CMP      R4,#+0
   \       0xE4   0xD001             BEQ.N    ??OSTimeDlyResume_16
   \       0xE6   0x.... 0x....      BL       CPU_SW_Exception
    378          #endif
    379                CORE_EXIT_ATOMIC();
   \                     ??OSTimeDlyResume_16: (+1)
   \       0xEA   0x0038             MOVS     R0,R7
   \       0xEC   0x.... 0x....      BL       CORE_ExitAtomic
    380                break;
   \       0xF0   0xE011             B.N      ??OSTimeDlyResume_14
    381          
    382              case OS_TASK_STATE_DEL:
    383          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
    384                CORE_EXIT_ATOMIC();
   \                     ??OSTimeDlyResume_12: (+1)
   \       0xF2   0x0038             MOVS     R0,R7
   \       0xF4   0x.... 0x....      BL       CORE_ExitAtomic
    385                RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
   \       0xF8   0x201F             MOVS     R0,#+31
   \       0xFA   0x7030             STRB     R0,[R6, #+0]
   \       0xFC   0x....             LDR.N    R0,??DataTable4
   \       0xFE   0x6070             STR      R0,[R6, #+4]
   \      0x100   0xF240 0x1081      MOVW     R0,#+385
   \      0x104   0x60B0             STR      R0,[R6, #+8]
   \      0x106   0x....             LDR.N    R0,??DataTable4_14
   \      0x108   0x60F0             STR      R0,[R6, #+12]
    386                break;
   \      0x10A   0xE004             B.N      ??OSTimeDlyResume_14
    387          #endif
    388          
    389              default:
    390                CORE_EXIT_ATOMIC();
   \                     ??OSTimeDlyResume_13: (+1)
   \      0x10C   0x0038             MOVS     R0,R7
   \      0x10E   0x.... 0x....      BL       CORE_ExitAtomic
    391                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \      0x112   0x.... 0x....      BL       CPU_SW_Exception
    392            }
    393          
    394            OSSched();
   \                     ??OSTimeDlyResume_14: (+1)
   \      0x116   0x.... 0x....      BL       OSSched
    395          }
   \                     ??OSTimeDlyResume_8: (+1)
   \      0x11A   0xBDF1             POP      {R0,R4-R7,PC}
    396          
    397          /****************************************************************************************************//**
    398           *                                               OSTimeGet()
    399           *
    400           * @brief    Used by your application to obtain the current value of the counter to keep track of
    401           *           the number of clock ticks.
    402           *
    403           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    404           *                   from this function:
    405           *                       - RTOS_ERR_NONE
    406           *                       - RTOS_ERR_NOT_INIT
    407           *
    408           * @return   The current tick count.
    409           *
    410           * @note     (1) The conversion is based on a 64 bits large hardware tick counter. The overflow of the
    411           *               64 bits counter during the calculation is not handle in this function.
    412           *               It is assumed that with a 64 bits counter running on a LF clock the calculation would
    413           *               overflow in millions of years making it acceptable.
    414           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    415          OS_TICK OSTimeGet(RTOS_ERR *p_err)
    416          {
   \                     OSTimeGet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    417            CPU_INT64U timer_ticks;
    418            OS_TICK ticks;
    419          
    420            if (OS_SleeptimerFrequency_Hz == 0u) {
   \        0x4   0x....             LDR.N    R5,??DataTable4_6
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD10A             BNE.N    ??OSTimeGet_0
    421              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_INIT);
   \        0xC   0x2013             MOVS     R0,#+19
   \        0xE   0x7020             STRB     R0,[R4, #+0]
   \       0x10   0x....             LDR.N    R0,??DataTable4
   \       0x12   0x6060             STR      R0,[R4, #+4]
   \       0x14   0xF240 0x10A5      MOVW     R0,#+421
   \       0x18   0x60A0             STR      R0,[R4, #+8]
   \       0x1A   0x....             LDR.N    R0,??DataTable4_15
   \       0x1C   0x60E0             STR      R0,[R4, #+12]
    422              return (0u);
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xE019             B.N      ??OSTimeGet_1
    423            }
    424          
    425            timer_ticks = sl_sleeptimer_get_tick_count64();
   \                     ??OSTimeGet_0: (+1)
   \       0x22   0x.... 0x....      BL       sl_sleeptimer_get_tick_count64
   \       0x26   0x0006             MOVS     R6,R0
   \       0x28   0x000F             MOVS     R7,R1
    426            ticks = (CPU_INT64U)(timer_ticks * (CPU_INT64U)OSCfg_TickRate_Hz) / OS_SleeptimerFrequency_Hz;
   \       0x2A   0x....             LDR.N    R0,??DataTable4_2
   \       0x2C   0x6802             LDR      R2,[R0, #+0]
   \       0x2E   0x2300             MOVS     R3,#+0
   \       0x30   0xFBA2 0x0106      UMULL    R0,R1,R2,R6
   \       0x34   0xFB02 0x1107      MLA      R1,R2,R7,R1
   \       0x38   0xFB03 0x1106      MLA      R1,R3,R6,R1
   \       0x3C   0x682A             LDR      R2,[R5, #+0]
   \       0x3E   0x2300             MOVS     R3,#+0
   \       0x40   0x.... 0x....      BL       __aeabi_uldivmod
    427          
    428            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x7021             STRB     R1,[R4, #+0]
   \       0x48   0x....             LDR.N    R1,??DataTable4
   \       0x4A   0x6061             STR      R1,[R4, #+4]
   \       0x4C   0xF44F 0x71D6      MOV      R1,#+428
   \       0x50   0x60A1             STR      R1,[R4, #+8]
   \       0x52   0x....             LDR.N    R1,??DataTable4_15
   \       0x54   0x60E1             STR      R1,[R4, #+12]
    429          
    430            return (ticks);
   \                     ??OSTimeGet_1: (+1)
   \       0x56   0xBDF2             POP      {R1,R4-R7,PC}
    431          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     `OSTimeTickRateHzGet::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     `OSTimeDly::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x....'....        DC32     OS_SleeptimerFrequency_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x....'....        DC32     OSDelayMaxTick

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x....'....        DC32     OS_TimerCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \        0x0   0x....'....        DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \        0x0   0x....'....        DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \        0x0   0x....'....        DC32     `OSTimeDlyHMSM::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \        0x0   0x....'....        DC32     OSDelayMaxMilli

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \        0x0   0x....'....        DC32     `OSTimeDlyResume::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \        0x0   0x....'....        DC32     `OSTimeGet::__func__`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x6B, 0x65, 0x72, 0x6E, 0x65
   \              0x5C 0x6B    
   \              0x65 0x72    
   \              0x6E 0x65
   \       0x58   0x6C 0x5C          DC8 0x6C, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65
   \       0x60   0x5C 0x6F          DC8 0x5C, 0x6F, 0x73, 0x5F, 0x74, 0x69, 0x6D, 0x65
   \              0x73 0x5F    
   \              0x74 0x69    
   \              0x6D 0x65
   \       0x68   0x2E 0x63          DC8 0x2E, 0x63, 0
   \              0x00
   \       0x6B                      DS8 1
    432          
    433          /********************************************************************************************************
    434           ********************************************************************************************************
    435           *                                   DEPENDENCIES & AVAIL CHECK(S) END
    436           ********************************************************************************************************
    437           *******************************************************************************************************/
    438          
    439          #endif // (OS_CFG_TICK_EN == DEF_ENABLED)
    440          #endif // (defined(RTOS_MODULE_KERNEL_AVAIL))

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   OSTimeDly
        48   -> CORE_EnterAtomic
        48   -> CORE_ExitAtomic
        48   -> CORE_InIrqContext
        48   -> CORE_IrqIsDisabled
        48   -> CPU_SW_Exception
        48   -> OSSched
        48   -> OS_RdyListMoveHeadToTail
        48   -> OS_RdyListRemove
        48   -> sl_sleeptimer_get_tick_count
        48   -> sl_sleeptimer_start_timer
        48 __aeabi_uldivmod
      48   OSTimeDlyHMSM
        48   -> CPU_SW_Exception
        48   -> OSTimeDly
      24   OSTimeDlyResume
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CORE_InIrqContext
        24   -> CPU_SW_Exception
        24   -> OSSched
        24   -> OS_RdyListInsert
        24   -> sl_sleeptimer_stop_timer
      24   OSTimeGet
        24   -> sl_sleeptimer_get_tick_count64
        24 __aeabi_uldivmod
       0   OSTimeTickRateHzGet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
     108  ?_0
     700  OSTimeDly
     386  OSTimeDlyHMSM
     284  OSTimeDlyResume
      88  OSTimeGet
      30  OSTimeTickRateHzGet
      76  -- Other

 
   184 bytes in section .rodata
 1'552 bytes in section .text
 
 1'552 bytes of CODE  memory
   184 bytes of CONST memory

Errors: none
Warnings: none
