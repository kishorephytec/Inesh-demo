###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:00
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_flag.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_flag.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_flag.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_flag.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir\os_flag.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_flag.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_flag.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Kernel - Event Flag Management
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                       DEPENDENCIES & AVAIL CHECK(S)
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <rtos_description.h>
     25          
     26          #if (defined(RTOS_MODULE_KERNEL_AVAIL))
     27          
     28          /********************************************************************************************************
     29           ********************************************************************************************************
     30           *                                               INCLUDE FILES
     31           ********************************************************************************************************
     32           *******************************************************************************************************/
     33          
     34          #define  MICRIUM_SOURCE
     35          #include "../include/os.h"
     36          #include "os_priv.h"
     37          
     38          #include  <em_core.h>
     39          
     40          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     41          const CPU_CHAR *os_flag__c = "$Id: $";
     42          #endif
     43          
     44          /********************************************************************************************************
     45           ********************************************************************************************************
     46           *                                           GLOBAL FUNCTIONS
     47           ********************************************************************************************************
     48           *******************************************************************************************************/
     49          
     50          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
     51          /****************************************************************************************************//**
     52           *                                               OSFlagCreate()
     53           *
     54           * @brief    This function is called to create an event flag group.
     55           *
     56           * @param    p_grp   Pointer to the event flag group to create. Your application is responsible
     57           *                   for allocating storage for the flag group.
     58           *
     59           * @param    p_name  The name of the event flag group.
     60           *
     61           * @param    flags   Contains the initial value to store in the event flag group (typically 0).
     62           *
     63           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
     64           *                   from this function:
     65           *                       - RTOS_ERR_NONE
     66           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
     67           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     68          void OSFlagCreate(OS_FLAG_GRP *p_grp,
     69                            CPU_CHAR    *p_name,
     70                            OS_FLAGS    flags,
     71                            RTOS_ERR    *p_err)
     72          {
   \                     OSFlagCreate: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0016             MOVS     R6,R2
   \        0x6   0x001D             MOVS     R5,R3
     73            CORE_DECLARE_IRQ_STATE;
     74          
     75            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD101             BNE.N    ??OSFlagCreate_0
   \        0xC   0x.... 0x....      BL       CPU_SW_Exception
     76          
     77          #ifdef OS_SAFETY_CRITICAL_IEC61508
     78            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     79              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
     80              return;
     81            }
     82          #endif
     83          
     84            //                                                               Not allowed to call from an ISR
     85            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSFlagCreate_0: (+1)
   \       0x10   0x.... 0x....      BL       CORE_InIrqContext
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??OSFlagCreate_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??OSFlagCreate_2
   \                     ??OSFlagCreate_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??OSFlagCreate_2: (+1)
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD10A             BNE.N    ??OSFlagCreate_3
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0x7028             STRB     R0,[R5, #+0]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x2C   0x6068             STR      R0,[R5, #+4]
   \       0x2E   0x2055             MOVS     R0,#+85
   \       0x30   0x60A8             STR      R0,[R5, #+8]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \       0x36   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagCreate_4: (+1)
   \       0x38   0xE7FE             B.N      ??OSFlagCreate_4
     86          
     87            //                                                               Validate 'p_grp'
     88            OS_ASSERT_DBG_ERR_SET((p_grp != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR,; );
   \                     ??OSFlagCreate_3: (+1)
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD10A             BNE.N    ??OSFlagCreate_5
   \       0x3E   0x200A             MOVS     R0,#+10
   \       0x40   0x7028             STRB     R0,[R5, #+0]
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x46   0x6068             STR      R0,[R5, #+4]
   \       0x48   0x2058             MOVS     R0,#+88
   \       0x4A   0x60A8             STR      R0,[R5, #+8]
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \       0x50   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagCreate_6: (+1)
   \       0x52   0xE7FE             B.N      ??OSFlagCreate_6
     89          
     90            CORE_ENTER_ATOMIC();
   \                     ??OSFlagCreate_5: (+1)
   \       0x54   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x58   0x0007             MOVS     R7,R0
     91          
     92            *p_grp = (OS_FLAG_GRP){ 0 };
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x2110             MOVS     R1,#+16
   \       0x5E   0x.... 0x....      BL       __aeabi_memclr4
     93          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
     94            p_grp->Type = OS_OBJ_TYPE_FLAG;                               // Set to event flag group type
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \       0x66   0x6020             STR      R0,[R4, #+0]
     95          #endif
     96          #if (OS_CFG_DBG_EN == DEF_ENABLED)
     97            p_grp->NamePtr = p_name;
     98          #else
     99            (void)&p_name;
   \       0x68   0x4668             MOV      R0,SP
    100          #endif
    101            p_grp->Flags = flags;                                         // Set to desired initial value
   \       0x6A   0x60E6             STR      R6,[R4, #+12]
    102            OS_PendListInit(&p_grp->PendList);
   \       0x6C   0x1D20             ADDS     R0,R4,#+4
   \       0x6E   0x.... 0x....      BL       OS_PendListInit
    103          
    104          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    105            OS_FlagDbgListAdd(p_grp);
    106            OSFlagQty++;
    107          #endif
    108          
    109            OS_TRACE_FLAG_CREATE(p_grp, p_name);
    110          
    111            CORE_EXIT_ATOMIC();
   \       0x72   0x0038             MOVS     R0,R7
   \       0x74   0x.... 0x....      BL       CORE_ExitAtomic
    112            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x7028             STRB     R0,[R5, #+0]
   \       0x7C   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x80   0x6068             STR      R0,[R5, #+4]
   \       0x82   0x2070             MOVS     R0,#+112
   \       0x84   0x60A8             STR      R0,[R5, #+8]
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \       0x8A   0x60E8             STR      R0,[R5, #+12]
    113          }
   \       0x8C   0xBDF1             POP      {R0,R4-R7,PC}
    114          
    115          /****************************************************************************************************//**
    116           *                                               OSFlagDel()
    117           *
    118           * @brief    This function deletes an event flag group and readies all tasks pending on the event flag
    119           *           group.
    120           *
    121           * @param    p_grp   Pointer to the event flag group.
    122           *
    123           * @param    opt     Determines delete options as follows:
    124           *                       - OS_OPT_DEL_NO_PEND  Deletes the event flag group ONLY if no task is
    125           *                                             pending.
    126           *                       - OS_OPT_DEL_ALWAYS   Deletes the event flag group even if tasks are
    127           *                                             waiting. In this case, all the pending tasks
    128           *                                             will be made ready.
    129           *
    130           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    131           *                   from this function:
    132           *                       - RTOS_ERR_NONE
    133           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    134           *                       - RTOS_ERR_OS_TASK_WAITING
    135           *                       - RTOS_ERR_NOT_READY
    136           *
    137           * @return   == 0    If no tasks were waiting on the event flag group, or upon error.
    138           *           >  0    If one or more tasks waiting on the event flag group are now ready and
    139           *                   informed.
    140           *
    141           * @note     (1) Use this function with care. Tasks that would normally expect the presence of
    142           *               the event flag group MUST check the return code of OSFlagPost() and OSFlagPend().
    143           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    144          OS_OBJ_QTY OSFlagDel(OS_FLAG_GRP *p_grp,
    145                               OS_OPT      opt,
    146                               RTOS_ERR    *p_err)
    147          {
   \                     OSFlagDel: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x0015             MOVS     R5,R2
    148            OS_OBJ_QTY   nbr_tasks;
    149            OS_PEND_LIST *p_pend_list;
    150            OS_TCB       *p_tcb;
    151            CPU_TS       ts;
    152            CORE_DECLARE_IRQ_STATE;
    153          
    154            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSFlagDel_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    155          
    156            OS_TRACE_FLAG_DEL_ENTER(p_grp, opt);
    157          
    158          #ifdef OS_SAFETY_CRITICAL_IEC61508
    159            if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    160              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_ILLEGAL_RUN_TIME);
    161              return (0u);
    162            }
    163          #endif
    164          
    165            //                                                               Not allowed to call from an ISR
    166            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSFlagDel_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_InIrqContext
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??OSFlagDel_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??OSFlagDel_2
   \                     ??OSFlagDel_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??OSFlagDel_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10A             BNE.N    ??OSFlagDel_3
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x2E   0x6068             STR      R0,[R5, #+4]
   \       0x30   0x20A6             MOVS     R0,#+166
   \       0x32   0x60A8             STR      R0,[R5, #+8]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0x38   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagDel_4: (+1)
   \       0x3A   0xE7FE             B.N      ??OSFlagDel_4
    167          
    168            //                                                               Make sure kernel is running.
    169            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSFlagDel_3: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \       0x40   0x7800             LDRB     R0,[R0, #+0]
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD00B             BEQ.N    ??OSFlagDel_5
    170              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0x7028             STRB     R0,[R5, #+0]
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x4E   0x6068             STR      R0,[R5, #+4]
   \       0x50   0x20AA             MOVS     R0,#+170
   \       0x52   0x60A8             STR      R0,[R5, #+8]
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0x58   0x60E8             STR      R0,[R5, #+12]
    171              return (0u);
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE081             B.N      ??OSFlagDel_6
    172            }
    173          
    174            //                                                               Validate 'p_grp'
    175            OS_ASSERT_DBG_ERR_SET((p_grp != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??OSFlagDel_5: (+1)
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xD10A             BNE.N    ??OSFlagDel_7
   \       0x62   0x200A             MOVS     R0,#+10
   \       0x64   0x7028             STRB     R0,[R5, #+0]
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x6A   0x6068             STR      R0,[R5, #+4]
   \       0x6C   0x20AF             MOVS     R0,#+175
   \       0x6E   0x60A8             STR      R0,[R5, #+8]
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0x74   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagDel_8: (+1)
   \       0x76   0xE7FE             B.N      ??OSFlagDel_8
    176          
    177            //                                                               Validate event group object
    178            OS_ASSERT_DBG_ERR_SET((p_grp->Type == OS_OBJ_TYPE_FLAG), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
   \                     ??OSFlagDel_7: (+1)
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \       0x7E   0x4281             CMP      R1,R0
   \       0x80   0xD00A             BEQ.N    ??OSFlagDel_9
   \       0x82   0x200C             MOVS     R0,#+12
   \       0x84   0x7028             STRB     R0,[R5, #+0]
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x8A   0x6068             STR      R0,[R5, #+4]
   \       0x8C   0x20B2             MOVS     R0,#+178
   \       0x8E   0x60A8             STR      R0,[R5, #+8]
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0x94   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagDel_10: (+1)
   \       0x96   0xE7FE             B.N      ??OSFlagDel_10
    179          
    180            CORE_ENTER_ATOMIC();
   \                     ??OSFlagDel_9: (+1)
   \       0x98   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x9C   0x4680             MOV      R8,R0
    181            p_pend_list = &p_grp->PendList;
   \       0x9E   0xF114 0x0904      ADDS     R9,R4,#+4
    182            nbr_tasks = 0u;
   \       0xA2   0xF05F 0x0A00      MOVS     R10,#+0
    183            switch (opt) {
   \       0xA6   0x4658             MOV      R0,R11
   \       0xA8   0xB280             UXTH     R0,R0
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD002             BEQ.N    ??OSFlagDel_11
   \       0xAE   0x2801             CMP      R0,#+1
   \       0xB0   0xD023             BEQ.N    ??OSFlagDel_12
   \       0xB2   0xE046             B.N      ??OSFlagDel_13
    184              case OS_OPT_DEL_NO_PEND:                                    // Delete group if no task waiting
    185                if (p_pend_list->HeadPtr == DEF_NULL) {
   \                     ??OSFlagDel_11: (+1)
   \       0xB4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD110             BNE.N    ??OSFlagDel_14
    186          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    187                  OS_FlagDbgListRemove(p_grp);
    188                  OSFlagQty--;
    189          #endif
    190                  OS_TRACE_FLAG_DEL(p_grp);
    191          
    192                  OS_FlagClr(p_grp);
   \       0xBC   0x0020             MOVS     R0,R4
   \       0xBE   0x.... 0x....      BL       OS_FlagClr
    193          
    194                  CORE_EXIT_ATOMIC();
   \       0xC2   0x4640             MOV      R0,R8
   \       0xC4   0x.... 0x....      BL       CORE_ExitAtomic
    195          
    196                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0x7028             STRB     R0,[R5, #+0]
   \       0xCC   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0xD0   0x6068             STR      R0,[R5, #+4]
   \       0xD2   0x20C4             MOVS     R0,#+196
   \       0xD4   0x60A8             STR      R0,[R5, #+8]
   \       0xD6   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0xDA   0x60E8             STR      R0,[R5, #+12]
   \       0xDC   0xE00C             B.N      ??OSFlagDel_15
    197                } else {
    198                  CORE_EXIT_ATOMIC();
   \                     ??OSFlagDel_14: (+1)
   \       0xDE   0x4640             MOV      R0,R8
   \       0xE0   0x.... 0x....      BL       CORE_ExitAtomic
    199                  RTOS_ERR_SET(*p_err, RTOS_ERR_OS_TASK_WAITING);
   \       0xE4   0x202E             MOVS     R0,#+46
   \       0xE6   0x7028             STRB     R0,[R5, #+0]
   \       0xE8   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0xEC   0x6068             STR      R0,[R5, #+4]
   \       0xEE   0x20C7             MOVS     R0,#+199
   \       0xF0   0x60A8             STR      R0,[R5, #+8]
   \       0xF2   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0xF6   0x60E8             STR      R0,[R5, #+12]
    200                }
    201                break;
   \                     ??OSFlagDel_15: (+1)
   \       0xF8   0xE031             B.N      ??OSFlagDel_16
    202          
    203              case OS_OPT_DEL_ALWAYS:                                     // Always delete the event flag group
    204          #if (OS_CFG_TS_EN == DEF_ENABLED)
    205                ts = OS_TS_GET();                                         // Get local time stamp so all tasks get the same time
    206          #else
    207                ts = 0u;
   \                     ??OSFlagDel_12: (+1)
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0x0007             MOVS     R7,R0
    208          #endif
    209                while (p_pend_list->HeadPtr != DEF_NULL) {                // Remove all tasks from the pend list
   \                     ??OSFlagDel_17: (+1)
   \       0xFE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD00A             BEQ.N    ??OSFlagDel_18
    210                  p_tcb = p_pend_list->HeadPtr;
   \      0x106   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x10A   0x0006             MOVS     R6,R0
    211                  OS_PendAbort(p_tcb,
    212                               ts,
    213                               OS_STATUS_PEND_DEL);
   \      0x10C   0x2202             MOVS     R2,#+2
   \      0x10E   0x0039             MOVS     R1,R7
   \      0x110   0x0030             MOVS     R0,R6
   \      0x112   0x.... 0x....      BL       OS_PendAbort
    214                  nbr_tasks++;
   \      0x116   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x11A   0xE7F0             B.N      ??OSFlagDel_17
    215                }
    216          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    217                OS_FlagDbgListRemove(p_grp);
    218                OSFlagQty--;
    219          #endif
    220                OS_TRACE_FLAG_DEL(p_grp);
    221          
    222                OS_FlagClr(p_grp);
   \                     ??OSFlagDel_18: (+1)
   \      0x11C   0x0020             MOVS     R0,R4
   \      0x11E   0x.... 0x....      BL       OS_FlagClr
    223                CORE_EXIT_ATOMIC();
   \      0x122   0x4640             MOV      R0,R8
   \      0x124   0x.... 0x....      BL       CORE_ExitAtomic
    224          
    225                OSSched();                                                // Find highest priority task ready to run
   \      0x128   0x.... 0x....      BL       OSSched
    226                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0x7028             STRB     R0,[R5, #+0]
   \      0x130   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x134   0x6068             STR      R0,[R5, #+4]
   \      0x136   0x20E2             MOVS     R0,#+226
   \      0x138   0x60A8             STR      R0,[R5, #+8]
   \      0x13A   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \      0x13E   0x60E8             STR      R0,[R5, #+12]
    227                break;
   \      0x140   0xE00D             B.N      ??OSFlagDel_16
    228          
    229              default:
    230                CORE_EXIT_ATOMIC();
   \                     ??OSFlagDel_13: (+1)
   \      0x142   0x4640             MOV      R0,R8
   \      0x144   0x.... 0x....      BL       CORE_ExitAtomic
    231                OS_ASSERT_DBG_FAIL_EXEC(*p_err, RTOS_ERR_INVALID_ARG, 0u);
   \      0x148   0x2008             MOVS     R0,#+8
   \      0x14A   0x7028             STRB     R0,[R5, #+0]
   \      0x14C   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x150   0x6068             STR      R0,[R5, #+4]
   \      0x152   0x20E7             MOVS     R0,#+231
   \      0x154   0x60A8             STR      R0,[R5, #+8]
   \      0x156   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \      0x15A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagDel_19: (+1)
   \      0x15C   0xE7FE             B.N      ??OSFlagDel_19
    232            }
    233          
    234            OS_TRACE_FLAG_DEL_EXIT(RTOS_ERR_CODE_GET(*p_err));
    235          
    236            return (nbr_tasks);
   \                     ??OSFlagDel_16: (+1)
   \      0x15E   0x4650             MOV      R0,R10
   \      0x160   0xB280             UXTH     R0,R0
   \                     ??OSFlagDel_6: (+1)
   \      0x162   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    237          }
    238          
    239          /****************************************************************************************************//**
    240           *                                               OSFlagPend()
    241           *
    242           * @brief          This function is called to wait for a combination of bits to be set in an event flag group.
    243           *               Your application can wait for either ANY bit to be set or ALL bits to be set.
    244           *
    245           * @param          p_grp       Pointer to the event flag group.
    246           *
    247           * @param          flags       Bit pattern that indicates which bit(s) (i.e. flags) to wait for.
    248           *                             The bits you want are specified by setting the corresponding bits in 'flags'
    249           *                             (e.g. if your application waits for bits 0 and 1, then the 'flags' would
    250           *                             contain 0x03).
    251           *
    252           * @param          timeout     Optional timeout (in clock ticks                            ) that your task will wait for the
    253           *                             desired bit combination. If you specify 0, the task will wait forever at the
    254           *                             specified event flag group, or until a message arrives.
    255           *
    256           * @param          opt         Specifies whether you want ALL bits to be set or ANY of the bits to be set.
    257           *                             You can specify the 'ONE' of the following arguments:
    258           *                                 - OS_OPT_PEND_FLAG_CLR_ALL    Wait for ALL bits in 'flags' to be clear. (0)
    259           *                                 - OS_OPT_PEND_FLAG_CLR_ANY    Wait for ANY bit  in 'flags' to be clear. (0)
    260           *                                 - OS_OPT_PEND_FLAG_SET_ALL    Wait for ALL bits in 'flags' to be set.   (1)
    261           *                                 - OS_OPT_PEND_FLAG_SET_ANY    Wait for ANY bit  in 'flags' to be set.   (1)
    262           *                             @n
    263           *                             You can 'ADD' OS_OPT_PEND_FLAG_CONSUME if you want the event flag to be
    264           *                             'consumed' by the call. For example, to wait for any flag in a group AND
    265           *                             clear the flags that are present, set 'wait_opt' to:
    266           *                             @n
    267           *                             OS_OPT_PEND_FLAG_SET_ANY + OS_OPT_PEND_FLAG_CONSUME
    268           *                             @n
    269           *                             You can also 'ADD' the type of pend with 'ONE' of the two options:
    270           *                                 - OS_OPT_PEND_BLOCKING        Task will     block if flags are not available.
    271           *                                 - OS_OPT_PEND_NON_BLOCKING    Task will NOT block if flags are not available.
    272           *
    273           * @param          p_ts        Pointer to a variable that receives the timestamp of when the event flag
    274           *                             group was posted, aborted, or deleted. If you pass a NULL pointer
    275           *                             (i.e. (CPU_TS *)0) then you will not get the timestamp. In other words,
    276           *                             passing a NULL pointer is valid and indicates that you don't need the timestamp.
    277           *
    278           * @param          p_err       Pointer to the variable that will receive one of the following error code(s)
    279           *                             from this function:
    280           *                                 - RTOS_ERR_NONE
    281           *                                 - RTOS_ERR_OS_OBJ_DEL
    282           *                                 - RTOS_ERR_WOULD_BLOCK
    283           *                                 - RTOS_ERR_OS_SCHED_LOCKED
    284           *                                 - RTOS_ERR_ABORT
    285           *                                 - RTOS_ERR_TIMEOUT
    286           *                                 - RTOS_ERR_NOT_READY
    287           *                                 - RTOS_ERR_INVALID_STATE
    288           *
    289           * @return        The flags in the event flag group that made the task ready or, 0 if a timeout or an error
    290           *               occurred.
    291           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    292          OS_FLAGS OSFlagPend(OS_FLAG_GRP *p_grp,
    293                              OS_FLAGS    flags,
    294                              OS_TICK     timeout,
    295                              OS_OPT      opt,
    296                              CPU_TS      *p_ts,
    297                              RTOS_ERR    *p_err)
    298          {
   \                     OSFlagPend: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x001F             MOVS     R7,R3
   \        0xA   0x9D0D             LDR      R5,[SP, #+52]
    299            CPU_BOOLEAN consume;
    300            OS_FLAGS    flags_rdy;
    301            OS_OPT      mode;
    302            CORE_DECLARE_IRQ_STATE;
    303          
    304            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??OSFlagPend_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
    305          
    306            OS_TRACE_FLAG_PEND_ENTER(p_grp, flags, timeout, opt, p_ts);
    307          
    308            //                                                               Not allowed to call from an ISR
    309            OS_ASSERT_DBG_ERR_SET(( (opt & OS_OPT_PEND_NON_BLOCKING)
    310                                    || !(CORE_InIrqContext())), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSFlagPend_0: (+1)
   \       0x14   0x0438             LSLS     R0,R7,#+16
   \       0x16   0xD403             BMI.N    ??OSFlagPend_1
   \       0x18   0x.... 0x....      BL       CORE_InIrqContext
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD101             BNE.N    ??OSFlagPend_2
   \                     ??OSFlagPend_1: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE000             B.N      ??OSFlagPend_3
   \                     ??OSFlagPend_2: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \                     ??OSFlagPend_3: (+1)
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD10B             BNE.N    ??OSFlagPend_4
   \       0x2C   0x2020             MOVS     R0,#+32
   \       0x2E   0x7028             STRB     R0,[R5, #+0]
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x34   0x6068             STR      R0,[R5, #+4]
   \       0x36   0xF44F 0x709B      MOV      R0,#+310
   \       0x3A   0x60A8             STR      R0,[R5, #+8]
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \       0x40   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagPend_5: (+1)
   \       0x42   0xE7FE             B.N      ??OSFlagPend_5
    311          
    312            //                                                               Not allowed to pend in atomic/critical sections
    313            OS_ASSERT_DBG_ERR_SET(( (opt & OS_OPT_PEND_NON_BLOCKING)
    314                                    || !CORE_IrqIsDisabled()), *p_err, RTOS_ERR_INVALID_STATE, 0u);
   \                     ??OSFlagPend_4: (+1)
   \       0x44   0x0438             LSLS     R0,R7,#+16
   \       0x46   0xD403             BMI.N    ??OSFlagPend_6
   \       0x48   0x.... 0x....      BL       CORE_IrqIsDisabled
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD101             BNE.N    ??OSFlagPend_7
   \                     ??OSFlagPend_6: (+1)
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xE000             B.N      ??OSFlagPend_8
   \                     ??OSFlagPend_7: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??OSFlagPend_8: (+1)
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD10B             BNE.N    ??OSFlagPend_9
   \       0x5C   0x201F             MOVS     R0,#+31
   \       0x5E   0x7028             STRB     R0,[R5, #+0]
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x64   0x6068             STR      R0,[R5, #+4]
   \       0x66   0xF44F 0x709D      MOV      R0,#+314
   \       0x6A   0x60A8             STR      R0,[R5, #+8]
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \       0x70   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagPend_10: (+1)
   \       0x72   0xE7FE             B.N      ??OSFlagPend_10
    315          
    316            //                                                               Make sure kernel is running.
    317            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSFlagPend_9: (+1)
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \       0x78   0x7800             LDRB     R0,[R0, #+0]
   \       0x7A   0x2801             CMP      R0,#+1
   \       0x7C   0xD00C             BEQ.N    ??OSFlagPend_11
    318              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x7E   0x2002             MOVS     R0,#+2
   \       0x80   0x7028             STRB     R0,[R5, #+0]
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x86   0x6068             STR      R0,[R5, #+4]
   \       0x88   0xF44F 0x709F      MOV      R0,#+318
   \       0x8C   0x60A8             STR      R0,[R5, #+8]
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \       0x92   0x60E8             STR      R0,[R5, #+12]
    319              return (0u);
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0xE1DA             B.N      ??OSFlagPend_12
    320            }
    321          
    322            //                                                               Validate 'p_grp'
    323            OS_ASSERT_DBG_ERR_SET((p_grp != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??OSFlagPend_11: (+1)
   \       0x98   0x2C00             CMP      R4,#+0
   \       0x9A   0xD10B             BNE.N    ??OSFlagPend_13
   \       0x9C   0x200A             MOVS     R0,#+10
   \       0x9E   0x7028             STRB     R0,[R5, #+0]
   \       0xA0   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0xA4   0x6068             STR      R0,[R5, #+4]
   \       0xA6   0xF240 0x1043      MOVW     R0,#+323
   \       0xAA   0x60A8             STR      R0,[R5, #+8]
   \       0xAC   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \       0xB0   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagPend_14: (+1)
   \       0xB2   0xE7FE             B.N      ??OSFlagPend_14
    324          
    325            //                                                               Validate 'opt'
    326            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_PEND_FLAG_CLR_ALL)
    327                                   || (opt == OS_OPT_PEND_FLAG_CLR_ANY)
    328                                   || (opt == OS_OPT_PEND_FLAG_SET_ALL)
    329                                   || (opt == OS_OPT_PEND_FLAG_SET_ANY)
    330                                   || (opt == (OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME))
    331                                   || (opt == (OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME))
    332                                   || (opt == (OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME))
    333                                   || (opt == (OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME))
    334                                   || (opt == (OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_NON_BLOCKING))
    335                                   || (opt == (OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_NON_BLOCKING))
    336                                   || (opt == (OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_NON_BLOCKING))
    337                                   || (opt == (OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_NON_BLOCKING))
    338                                   || (opt == (OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING))
    339                                   || (opt == (OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING))
    340                                   || (opt == (OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING))
    341                                   || (opt == (OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING))), *p_err, RTOS_ERR_INVALID_ARG, 0u);
   \                     ??OSFlagPend_13: (+1)
   \       0xB4   0x0038             MOVS     R0,R7
   \       0xB6   0xB280             UXTH     R0,R0
   \       0xB8   0x2801             CMP      R0,#+1
   \       0xBA   0xD050             BEQ.N    ??OSFlagPend_15
   \       0xBC   0x0038             MOVS     R0,R7
   \       0xBE   0xB280             UXTH     R0,R0
   \       0xC0   0x2802             CMP      R0,#+2
   \       0xC2   0xD04C             BEQ.N    ??OSFlagPend_15
   \       0xC4   0x0038             MOVS     R0,R7
   \       0xC6   0xB280             UXTH     R0,R0
   \       0xC8   0x2804             CMP      R0,#+4
   \       0xCA   0xD048             BEQ.N    ??OSFlagPend_15
   \       0xCC   0x0038             MOVS     R0,R7
   \       0xCE   0xB280             UXTH     R0,R0
   \       0xD0   0x2808             CMP      R0,#+8
   \       0xD2   0xD044             BEQ.N    ??OSFlagPend_15
   \       0xD4   0x0038             MOVS     R0,R7
   \       0xD6   0xF240 0x1101      MOVW     R1,#+257
   \       0xDA   0xB280             UXTH     R0,R0
   \       0xDC   0x4288             CMP      R0,R1
   \       0xDE   0xD03E             BEQ.N    ??OSFlagPend_15
   \       0xE0   0x0038             MOVS     R0,R7
   \       0xE2   0xB280             UXTH     R0,R0
   \       0xE4   0xF5B0 0x7F81      CMP      R0,#+258
   \       0xE8   0xD039             BEQ.N    ??OSFlagPend_15
   \       0xEA   0x0038             MOVS     R0,R7
   \       0xEC   0xB280             UXTH     R0,R0
   \       0xEE   0xF5B0 0x7F82      CMP      R0,#+260
   \       0xF2   0xD034             BEQ.N    ??OSFlagPend_15
   \       0xF4   0x0038             MOVS     R0,R7
   \       0xF6   0xB280             UXTH     R0,R0
   \       0xF8   0xF5B0 0x7F84      CMP      R0,#+264
   \       0xFC   0xD02F             BEQ.N    ??OSFlagPend_15
   \       0xFE   0x0039             MOVS     R1,R7
   \      0x100   0xF248 0x0001      MOVW     R0,#+32769
   \      0x104   0xB289             UXTH     R1,R1
   \      0x106   0x4281             CMP      R1,R0
   \      0x108   0xD029             BEQ.N    ??OSFlagPend_15
   \      0x10A   0x0039             MOVS     R1,R7
   \      0x10C   0xF248 0x0002      MOVW     R0,#+32770
   \      0x110   0xB289             UXTH     R1,R1
   \      0x112   0x4281             CMP      R1,R0
   \      0x114   0xD023             BEQ.N    ??OSFlagPend_15
   \      0x116   0x0039             MOVS     R1,R7
   \      0x118   0xF248 0x0004      MOVW     R0,#+32772
   \      0x11C   0xB289             UXTH     R1,R1
   \      0x11E   0x4281             CMP      R1,R0
   \      0x120   0xD01D             BEQ.N    ??OSFlagPend_15
   \      0x122   0x0039             MOVS     R1,R7
   \      0x124   0xF248 0x0008      MOVW     R0,#+32776
   \      0x128   0xB289             UXTH     R1,R1
   \      0x12A   0x4281             CMP      R1,R0
   \      0x12C   0xD017             BEQ.N    ??OSFlagPend_15
   \      0x12E   0x0039             MOVS     R1,R7
   \      0x130   0xF248 0x1001      MOVW     R0,#+33025
   \      0x134   0xB289             UXTH     R1,R1
   \      0x136   0x4281             CMP      R1,R0
   \      0x138   0xD011             BEQ.N    ??OSFlagPend_15
   \      0x13A   0x0039             MOVS     R1,R7
   \      0x13C   0xF248 0x1002      MOVW     R0,#+33026
   \      0x140   0xB289             UXTH     R1,R1
   \      0x142   0x4281             CMP      R1,R0
   \      0x144   0xD00B             BEQ.N    ??OSFlagPend_15
   \      0x146   0x0039             MOVS     R1,R7
   \      0x148   0xF248 0x1004      MOVW     R0,#+33028
   \      0x14C   0xB289             UXTH     R1,R1
   \      0x14E   0x4281             CMP      R1,R0
   \      0x150   0xD005             BEQ.N    ??OSFlagPend_15
   \      0x152   0x0039             MOVS     R1,R7
   \      0x154   0xF248 0x1008      MOVW     R0,#+33032
   \      0x158   0xB289             UXTH     R1,R1
   \      0x15A   0x4281             CMP      R1,R0
   \      0x15C   0xD101             BNE.N    ??OSFlagPend_16
   \                     ??OSFlagPend_15: (+1)
   \      0x15E   0x2001             MOVS     R0,#+1
   \      0x160   0xE000             B.N      ??OSFlagPend_17
   \                     ??OSFlagPend_16: (+1)
   \      0x162   0x2000             MOVS     R0,#+0
   \                     ??OSFlagPend_17: (+1)
   \      0x164   0xB2C0             UXTB     R0,R0
   \      0x166   0x2800             CMP      R0,#+0
   \      0x168   0xD10B             BNE.N    ??OSFlagPend_18
   \      0x16A   0x2008             MOVS     R0,#+8
   \      0x16C   0x7028             STRB     R0,[R5, #+0]
   \      0x16E   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x172   0x6068             STR      R0,[R5, #+4]
   \      0x174   0xF240 0x1055      MOVW     R0,#+341
   \      0x178   0x60A8             STR      R0,[R5, #+8]
   \      0x17A   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x17E   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagPend_19: (+1)
   \      0x180   0xE7FE             B.N      ??OSFlagPend_19
    342          
    343            //                                                               Validate event group object
    344            OS_ASSERT_DBG_ERR_SET((p_grp->Type == OS_OBJ_TYPE_FLAG), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
   \                     ??OSFlagPend_18: (+1)
   \      0x182   0x6820             LDR      R0,[R4, #+0]
   \      0x184   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \      0x188   0x4288             CMP      R0,R1
   \      0x18A   0xD00B             BEQ.N    ??OSFlagPend_20
   \      0x18C   0x200C             MOVS     R0,#+12
   \      0x18E   0x7028             STRB     R0,[R5, #+0]
   \      0x190   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x194   0x6068             STR      R0,[R5, #+4]
   \      0x196   0xF44F 0x70AC      MOV      R0,#+344
   \      0x19A   0x60A8             STR      R0,[R5, #+8]
   \      0x19C   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x1A0   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagPend_21: (+1)
   \      0x1A2   0xE7FE             B.N      ??OSFlagPend_21
    345          
    346            if ((opt & OS_OPT_PEND_FLAG_CONSUME) != 0u) {                 // See if we need to consume the flags
   \                     ??OSFlagPend_20: (+1)
   \      0x1A4   0x0038             MOVS     R0,R7
   \      0x1A6   0xB280             UXTH     R0,R0
   \      0x1A8   0x05C0             LSLS     R0,R0,#+23
   \      0x1AA   0xD502             BPL.N    ??OSFlagPend_22
    347              consume = DEF_TRUE;
   \      0x1AC   0xF05F 0x0801      MOVS     R8,#+1
   \      0x1B0   0xE001             B.N      ??OSFlagPend_23
    348            } else {
    349              consume = DEF_FALSE;
   \                     ??OSFlagPend_22: (+1)
   \      0x1B2   0xF05F 0x0800      MOVS     R8,#+0
    350            }
    351          
    352            if (p_ts != DEF_NULL) {
   \                     ??OSFlagPend_23: (+1)
   \      0x1B6   0x980C             LDR      R0,[SP, #+48]
   \      0x1B8   0x2800             CMP      R0,#+0
   \      0x1BA   0xD002             BEQ.N    ??OSFlagPend_24
    353              *p_ts = 0u;                                                 // Initialize the returned timestamp
   \      0x1BC   0x2100             MOVS     R1,#+0
   \      0x1BE   0x980C             LDR      R0,[SP, #+48]
   \      0x1C0   0x6001             STR      R1,[R0, #+0]
    354            }
    355          
    356            mode = opt & OS_OPT_PEND_FLAG_MASK;
   \                     ??OSFlagPend_24: (+1)
   \      0x1C2   0xF017 0x000F      ANDS     R0,R7,#0xF
   \      0x1C6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    357            CORE_ENTER_ATOMIC();
   \      0x1CA   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x1CE   0x4681             MOV      R9,R0
    358            switch (mode) {
   \      0x1D0   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1D4   0x2804             CMP      R0,#+4
   \      0x1D6   0xD002             BEQ.N    ??OSFlagPend_25
   \      0x1D8   0x2808             CMP      R0,#+8
   \      0x1DA   0xD058             BEQ.N    ??OSFlagPend_26
   \      0x1DC   0xE0AF             B.N      ??OSFlagPend_27
    359              case OS_OPT_PEND_FLAG_SET_ALL:                              // See if all required flags are set
    360                flags_rdy = (p_grp->Flags & flags);                       // Extract only the bits we want
   \                     ??OSFlagPend_25: (+1)
   \      0x1DE   0x68E0             LDR      R0,[R4, #+12]
   \      0x1E0   0xEA1A 0x0000      ANDS     R0,R10,R0
   \      0x1E4   0x0006             MOVS     R6,R0
    361                if (flags_rdy == flags) {                                 // Must match ALL the bits that we want
   \      0x1E6   0x4556             CMP      R6,R10
   \      0x1E8   0xD11D             BNE.N    ??OSFlagPend_28
    362                  if (consume == DEF_TRUE) {                              // See if we need to consume the flags
   \      0x1EA   0x4640             MOV      R0,R8
   \      0x1EC   0xB2C0             UXTB     R0,R0
   \      0x1EE   0x2801             CMP      R0,#+1
   \      0x1F0   0xD102             BNE.N    ??OSFlagPend_29
    363                    p_grp->Flags &= ~flags_rdy;                           // Clear ONLY the flags that we wanted
   \      0x1F2   0x68E0             LDR      R0,[R4, #+12]
   \      0x1F4   0x43B0             BICS     R0,R0,R6
   \      0x1F6   0x60E0             STR      R0,[R4, #+12]
    364                  }
    365                  if (OSTCBCurPtr != DEF_NULL) {
   \                     ??OSFlagPend_29: (+1)
   \      0x1F8   0x.... 0x....      LDR.W    R1,??DataTable7_6
   \      0x1FC   0x6808             LDR      R0,[R1, #+0]
   \      0x1FE   0x2800             CMP      R0,#+0
   \      0x200   0xD001             BEQ.N    ??OSFlagPend_30
    366                    OSTCBCurPtr->FlagsRdy = flags_rdy;                    // Save flags that were ready
   \      0x202   0x6808             LDR      R0,[R1, #+0]
   \      0x204   0x67C6             STR      R6,[R0, #+124]
    367                  }
    368          #if (OS_CFG_TS_EN == DEF_ENABLED)
    369                  if (p_ts != DEF_NULL) {
    370                    *p_ts = p_grp->TS;
    371                  }
    372          #endif
    373                  CORE_EXIT_ATOMIC();                                     // Yes, condition met, return to caller
   \                     ??OSFlagPend_30: (+1)
   \      0x206   0x4648             MOV      R0,R9
   \      0x208   0x.... 0x....      BL       CORE_ExitAtomic
    374                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x20C   0x2000             MOVS     R0,#+0
   \      0x20E   0x7028             STRB     R0,[R5, #+0]
   \      0x210   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x214   0x6068             STR      R0,[R5, #+4]
   \      0x216   0xF44F 0x70BB      MOV      R0,#+374
   \      0x21A   0x60A8             STR      R0,[R5, #+8]
   \      0x21C   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x220   0x60E8             STR      R0,[R5, #+12]
    375                  OS_TRACE_FLAG_PEND(p_grp);
    376                  OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    377                  return (flags_rdy);
   \      0x222   0x0030             MOVS     R0,R6
   \      0x224   0xE113             B.N      ??OSFlagPend_12
    378                } else {                                                  // Block task until events occur or timeout
    379                  if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
   \                     ??OSFlagPend_28: (+1)
   \      0x226   0x0038             MOVS     R0,R7
   \      0x228   0xB280             UXTH     R0,R0
   \      0x22A   0x0400             LSLS     R0,R0,#+16
   \      0x22C   0xD50F             BPL.N    ??OSFlagPend_31
    380                    CORE_EXIT_ATOMIC();
   \      0x22E   0x4648             MOV      R0,R9
   \      0x230   0x.... 0x....      BL       CORE_ExitAtomic
    381                    RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);           // Specified non-blocking so task would block
   \      0x234   0x201D             MOVS     R0,#+29
   \      0x236   0x7028             STRB     R0,[R5, #+0]
   \      0x238   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x23C   0x6068             STR      R0,[R5, #+4]
   \      0x23E   0xF240 0x107D      MOVW     R0,#+381
   \      0x242   0x60A8             STR      R0,[R5, #+8]
   \      0x244   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x248   0x60E8             STR      R0,[R5, #+12]
    382                    OS_TRACE_FLAG_PEND_FAILED(p_grp);
    383                    OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    384                    return ((OS_FLAGS)0);
   \      0x24A   0x2000             MOVS     R0,#+0
   \      0x24C   0xE0FF             B.N      ??OSFlagPend_12
    385                  } else {                                                // Specified blocking so check is scheduler is locked
    386                    if (OSSchedLockNestingCtr > 0u) {                     // See if called with scheduler locked ...
   \                     ??OSFlagPend_31: (+1)
   \      0x24E   0x.... 0x....      LDR.W    R0,??DataTable7_7
   \      0x252   0x7800             LDRB     R0,[R0, #+0]
   \      0x254   0x2800             CMP      R0,#+0
   \      0x256   0xD00F             BEQ.N    ??OSFlagPend_32
    387                      CORE_EXIT_ATOMIC();                                 // ... can't PEND when locked
   \      0x258   0x4648             MOV      R0,R9
   \      0x25A   0x.... 0x....      BL       CORE_ExitAtomic
    388                      RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
   \      0x25E   0x202D             MOVS     R0,#+45
   \      0x260   0x7028             STRB     R0,[R5, #+0]
   \      0x262   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x266   0x6068             STR      R0,[R5, #+4]
   \      0x268   0xF44F 0x70C2      MOV      R0,#+388
   \      0x26C   0x60A8             STR      R0,[R5, #+8]
   \      0x26E   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x272   0x60E8             STR      R0,[R5, #+12]
    389                      OS_TRACE_FLAG_PEND_FAILED(p_grp);
    390                      OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    391                      return (0u);
   \      0x274   0x2000             MOVS     R0,#+0
   \      0x276   0xE0EA             B.N      ??OSFlagPend_12
    392                    }
    393                  }
    394                  //                                                         Lock the scheduler/re-enable interrupts
    395                  OS_FlagBlock(p_grp,
    396                               flags,
    397                               opt,
    398                               timeout);
   \                     ??OSFlagPend_32: (+1)
   \      0x278   0x9B02             LDR      R3,[SP, #+8]
   \      0x27A   0x003A             MOVS     R2,R7
   \      0x27C   0xB292             UXTH     R2,R2
   \      0x27E   0x4651             MOV      R1,R10
   \      0x280   0x0020             MOVS     R0,R4
   \      0x282   0x.... 0x....      BL       OS_FlagBlock
    399                  CORE_EXIT_ATOMIC();
   \      0x286   0x4648             MOV      R0,R9
   \      0x288   0x.... 0x....      BL       CORE_ExitAtomic
    400                }
    401                break;
   \      0x28C   0xE05C             B.N      ??OSFlagPend_33
    402          
    403              case OS_OPT_PEND_FLAG_SET_ANY:
    404                flags_rdy = (p_grp->Flags & flags);                       // Extract only the bits we want
   \                     ??OSFlagPend_26: (+1)
   \      0x28E   0x68E0             LDR      R0,[R4, #+12]
   \      0x290   0xEA1A 0x0000      ANDS     R0,R10,R0
   \      0x294   0x0006             MOVS     R6,R0
    405                if (flags_rdy != 0u) {                                    // See if any flag set
   \      0x296   0x2E00             CMP      R6,#+0
   \      0x298   0xD01D             BEQ.N    ??OSFlagPend_34
    406                  if (consume == DEF_TRUE) {                              // See if we need to consume the flags
   \      0x29A   0x4640             MOV      R0,R8
   \      0x29C   0xB2C0             UXTB     R0,R0
   \      0x29E   0x2801             CMP      R0,#+1
   \      0x2A0   0xD102             BNE.N    ??OSFlagPend_35
    407                    p_grp->Flags &= ~flags_rdy;                           // Clear ONLY the flags that we got
   \      0x2A2   0x68E0             LDR      R0,[R4, #+12]
   \      0x2A4   0x43B0             BICS     R0,R0,R6
   \      0x2A6   0x60E0             STR      R0,[R4, #+12]
    408                  }
    409                  if (OSTCBCurPtr != DEF_NULL) {
   \                     ??OSFlagPend_35: (+1)
   \      0x2A8   0x.... 0x....      LDR.W    R1,??DataTable7_6
   \      0x2AC   0x6808             LDR      R0,[R1, #+0]
   \      0x2AE   0x2800             CMP      R0,#+0
   \      0x2B0   0xD001             BEQ.N    ??OSFlagPend_36
    410                    OSTCBCurPtr->FlagsRdy = flags_rdy;                    // Save flags that were ready
   \      0x2B2   0x6808             LDR      R0,[R1, #+0]
   \      0x2B4   0x67C6             STR      R6,[R0, #+124]
    411                  }
    412          #if (OS_CFG_TS_EN == DEF_ENABLED)
    413                  if (p_ts != DEF_NULL) {
    414                    *p_ts = p_grp->TS;
    415                  }
    416          #endif
    417                  CORE_EXIT_ATOMIC();                                     // Yes, condition met, return to caller
   \                     ??OSFlagPend_36: (+1)
   \      0x2B6   0x4648             MOV      R0,R9
   \      0x2B8   0x.... 0x....      BL       CORE_ExitAtomic
    418                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x2BC   0x2000             MOVS     R0,#+0
   \      0x2BE   0x7028             STRB     R0,[R5, #+0]
   \      0x2C0   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x2C4   0x6068             STR      R0,[R5, #+4]
   \      0x2C6   0xF44F 0x70D1      MOV      R0,#+418
   \      0x2CA   0x60A8             STR      R0,[R5, #+8]
   \      0x2CC   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x2D0   0x60E8             STR      R0,[R5, #+12]
    419                  OS_TRACE_FLAG_PEND(p_grp);
    420                  OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    421                  return (flags_rdy);
   \      0x2D2   0x0030             MOVS     R0,R6
   \      0x2D4   0xE0BB             B.N      ??OSFlagPend_12
    422                } else {                                                  // Block task until events occur or timeout
    423                  if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
   \                     ??OSFlagPend_34: (+1)
   \      0x2D6   0x0038             MOVS     R0,R7
   \      0x2D8   0xB280             UXTH     R0,R0
   \      0x2DA   0x0400             LSLS     R0,R0,#+16
   \      0x2DC   0xD50F             BPL.N    ??OSFlagPend_37
    424                    CORE_EXIT_ATOMIC();
   \      0x2DE   0x4648             MOV      R0,R9
   \      0x2E0   0x.... 0x....      BL       CORE_ExitAtomic
    425                    RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);           // Specified non-blocking so task would block
   \      0x2E4   0x201D             MOVS     R0,#+29
   \      0x2E6   0x7028             STRB     R0,[R5, #+0]
   \      0x2E8   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x2EC   0x6068             STR      R0,[R5, #+4]
   \      0x2EE   0xF240 0x10A9      MOVW     R0,#+425
   \      0x2F2   0x60A8             STR      R0,[R5, #+8]
   \      0x2F4   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x2F8   0x60E8             STR      R0,[R5, #+12]
    426                    OS_TRACE_FLAG_PEND_FAILED(p_grp);
    427                    OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    428                    return ((OS_FLAGS)0);
   \      0x2FA   0x2000             MOVS     R0,#+0
   \      0x2FC   0xE0A7             B.N      ??OSFlagPend_12
    429                  } else {                                                // Specified blocking so check is scheduler is locked
    430                    if (OSSchedLockNestingCtr > 0u) {                     // See if called with scheduler locked ...
   \                     ??OSFlagPend_37: (+1)
   \      0x2FE   0x.... 0x....      LDR.W    R0,??DataTable7_7
   \      0x302   0x7800             LDRB     R0,[R0, #+0]
   \      0x304   0x2800             CMP      R0,#+0
   \      0x306   0xD00F             BEQ.N    ??OSFlagPend_38
    431                      CORE_EXIT_ATOMIC();                                 // ... can't PEND when locked
   \      0x308   0x4648             MOV      R0,R9
   \      0x30A   0x.... 0x....      BL       CORE_ExitAtomic
    432                      RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
   \      0x30E   0x202D             MOVS     R0,#+45
   \      0x310   0x7028             STRB     R0,[R5, #+0]
   \      0x312   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x316   0x6068             STR      R0,[R5, #+4]
   \      0x318   0xF44F 0x70D8      MOV      R0,#+432
   \      0x31C   0x60A8             STR      R0,[R5, #+8]
   \      0x31E   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x322   0x60E8             STR      R0,[R5, #+12]
    433                      OS_TRACE_FLAG_PEND_FAILED(p_grp);
    434                      OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    435                      return ((OS_FLAGS)0);
   \      0x324   0x2000             MOVS     R0,#+0
   \      0x326   0xE092             B.N      ??OSFlagPend_12
    436                    }
    437                  }
    438          
    439                  OS_FlagBlock(p_grp,
    440                               flags,
    441                               opt,
    442                               timeout);
   \                     ??OSFlagPend_38: (+1)
   \      0x328   0x9B02             LDR      R3,[SP, #+8]
   \      0x32A   0x003A             MOVS     R2,R7
   \      0x32C   0xB292             UXTH     R2,R2
   \      0x32E   0x4651             MOV      R1,R10
   \      0x330   0x0020             MOVS     R0,R4
   \      0x332   0x.... 0x....      BL       OS_FlagBlock
    443                  CORE_EXIT_ATOMIC();
   \      0x336   0x4648             MOV      R0,R9
   \      0x338   0x.... 0x....      BL       CORE_ExitAtomic
    444                }
    445                break;
   \      0x33C   0xE004             B.N      ??OSFlagPend_33
    446          
    447          #if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
    448              case OS_OPT_PEND_FLAG_CLR_ALL:                              // See if all required flags are cleared
    449                flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags);            // Extract only the bits we want
    450                if (flags_rdy == flags) {                                 // Must match ALL the bits that we want
    451                  if (consume == DEF_TRUE) {                              // See if we need to consume the flags
    452                    p_grp->Flags |= flags_rdy;                            // Set ONLY the flags that we wanted
    453                  }
    454                  if (OSTCBCurPtr != DEF_NULL) {
    455                    OSTCBCurPtr->FlagsRdy = flags_rdy;                    // Save flags that were ready
    456                  }
    457          #if (OS_CFG_TS_EN == DEF_ENABLED)
    458                  if (p_ts != DEF_NULL) {
    459                    *p_ts = p_grp->TS;
    460                  }
    461          #endif
    462                  CORE_EXIT_ATOMIC();                                     // Yes, condition met, return to caller
    463                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    464                  OS_TRACE_FLAG_PEND(p_grp);
    465                  OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    466                  return (flags_rdy);
    467                } else {                                                  // Block task until events occur or timeout
    468                  if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
    469                    CORE_EXIT_ATOMIC();
    470                    RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);           // Specified non-blocking so task would block
    471                    OS_TRACE_FLAG_PEND_FAILED(p_grp);
    472                    OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    473                    return ((OS_FLAGS)0);
    474                  } else {                                                // Specified blocking so check is scheduler is locked
    475                    if (OSSchedLockNestingCtr > 0u) {                     // See if called with scheduler locked ...
    476                      CORE_EXIT_ATOMIC();                                 // ... can't PEND when locked
    477                      RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
    478                      OS_TRACE_FLAG_PEND_FAILED(p_grp);
    479                      OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    480                      return (0);
    481                    }
    482                  }
    483          
    484                  OS_FlagBlock(p_grp,
    485                               flags,
    486                               opt,
    487                               timeout);
    488                  CORE_EXIT_ATOMIC();
    489                }
    490                break;
    491          
    492              case OS_OPT_PEND_FLAG_CLR_ANY:
    493                flags_rdy = (~p_grp->Flags & flags);                      // Extract only the bits we want
    494                if (flags_rdy != 0u) {                                    // See if any flag cleared
    495                  if (consume == DEF_TRUE) {                              // See if we need to consume the flags
    496                    p_grp->Flags |= flags_rdy;                            // Set ONLY the flags that we got
    497                  }
    498                  if (OSTCBCurPtr != DEF_NULL) {
    499                    OSTCBCurPtr->FlagsRdy = flags_rdy;                    // Save flags that were ready
    500                  }
    501          #if (OS_CFG_TS_EN == DEF_ENABLED)
    502                  if (p_ts != DEF_NULL) {
    503                    *p_ts = p_grp->TS;
    504                  }
    505          #endif
    506                  CORE_EXIT_ATOMIC();                                     // Yes, condition met, return to caller
    507                  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    508                  OS_TRACE_FLAG_PEND(p_grp);
    509                  OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    510                  return (flags_rdy);
    511                } else {                                                  // Block task until events occur or timeout
    512                  if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
    513                    CORE_EXIT_ATOMIC();
    514                    RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);           // Specified non-blocking so task would block
    515                    OS_TRACE_FLAG_PEND_FAILED(p_grp);
    516                    OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    517                    return ((OS_FLAGS)0);
    518                  } else {                                                // Specified blocking so check is scheduler is locked
    519                    if (OSSchedLockNestingCtr > 0u) {                     // See if called with scheduler locked ...
    520                      CORE_EXIT_ATOMIC();                                 // ... can't PEND when locked
    521                      RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
    522                      OS_TRACE_FLAG_PEND_FAILED(p_grp);
    523                      OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    524                      return (0u);
    525                    }
    526                  }
    527          
    528                  OS_FlagBlock(p_grp,
    529                               flags,
    530                               opt,
    531                               timeout);
    532                  CORE_EXIT_ATOMIC();
    533                }
    534                break;
    535          #endif
    536          
    537              default:
    538                CORE_EXIT_ATOMIC();
   \                     ??OSFlagPend_27: (+1)
   \      0x33E   0x4648             MOV      R0,R9
   \      0x340   0x.... 0x....      BL       CORE_ExitAtomic
    539                OS_TRACE_FLAG_PEND_FAILED(p_grp);
    540                OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_INVALID_ARG);
    541                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_ARG, 0u);
   \      0x344   0x.... 0x....      BL       CPU_SW_Exception
    542            }
    543          
    544            OS_TRACE_FLAG_PEND_BLOCK(p_grp);
    545          
    546            OSSched();                                                    // Find next HPT ready to run
   \                     ??OSFlagPend_33: (+1)
   \      0x348   0x.... 0x....      BL       OSSched
    547          
    548            CORE_ENTER_ATOMIC();
   \      0x34C   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x350   0x4683             MOV      R11,R0
    549            switch (OSTCBCurPtr->PendStatus) {
   \      0x352   0x.... 0x....      LDR.W    R0,??DataTable7_6
   \      0x356   0x6800             LDR      R0,[R0, #+0]
   \      0x358   0xF890 0x0025      LDRB     R0,[R0, #+37]
   \      0x35C   0x2800             CMP      R0,#+0
   \      0x35E   0xD005             BEQ.N    ??OSFlagPend_39
   \      0x360   0x2802             CMP      R0,#+2
   \      0x362   0xD033             BEQ.N    ??OSFlagPend_40
   \      0x364   0xD30E             BCC.N    ??OSFlagPend_41
   \      0x366   0x2803             CMP      R0,#+3
   \      0x368   0xD01B             BEQ.N    ??OSFlagPend_42
   \      0x36A   0xE03E             B.N      ??OSFlagPend_43
    550              case OS_STATUS_PEND_OK:                                     // We got the event flags
    551          #if (OS_CFG_TS_EN == DEF_ENABLED)
    552                if (p_ts != DEF_NULL) {
    553                  *p_ts = OSTCBCurPtr->TS;
    554                }
    555          #endif
    556                OS_TRACE_FLAG_PEND(p_grp);
    557                RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSFlagPend_39: (+1)
   \      0x36C   0x2000             MOVS     R0,#+0
   \      0x36E   0x7028             STRB     R0,[R5, #+0]
   \      0x370   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x374   0x6068             STR      R0,[R5, #+4]
   \      0x376   0xF240 0x202D      MOVW     R0,#+557
   \      0x37A   0x60A8             STR      R0,[R5, #+8]
   \      0x37C   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x380   0x60E8             STR      R0,[R5, #+12]
    558                break;
   \      0x382   0xE037             B.N      ??OSFlagPend_44
    559          
    560              case OS_STATUS_PEND_ABORT:                                  // Indicate that we aborted
    561          #if (OS_CFG_TS_EN == DEF_ENABLED)
    562                if (p_ts != DEF_NULL) {
    563                  *p_ts = OSTCBCurPtr->TS;
    564                }
    565          #endif
    566                CORE_EXIT_ATOMIC();
   \                     ??OSFlagPend_41: (+1)
   \      0x384   0x4658             MOV      R0,R11
   \      0x386   0x.... 0x....      BL       CORE_ExitAtomic
    567                OS_TRACE_FLAG_PEND_FAILED(p_grp);
    568                RTOS_ERR_SET(*p_err, RTOS_ERR_ABORT);
   \      0x38A   0x2021             MOVS     R0,#+33
   \      0x38C   0x7028             STRB     R0,[R5, #+0]
   \      0x38E   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x392   0x6068             STR      R0,[R5, #+4]
   \      0x394   0xF44F 0x700E      MOV      R0,#+568
   \      0x398   0x60A8             STR      R0,[R5, #+8]
   \      0x39A   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x39E   0x60E8             STR      R0,[R5, #+12]
    569                break;
   \      0x3A0   0xE028             B.N      ??OSFlagPend_44
    570          
    571              case OS_STATUS_PEND_TIMEOUT:                                // Indicate that we didn't get semaphore within timeout
    572                if (p_ts != DEF_NULL) {
   \                     ??OSFlagPend_42: (+1)
   \      0x3A2   0x980C             LDR      R0,[SP, #+48]
   \      0x3A4   0x2800             CMP      R0,#+0
   \      0x3A6   0xD002             BEQ.N    ??OSFlagPend_45
    573                  *p_ts = 0u;
   \      0x3A8   0x2100             MOVS     R1,#+0
   \      0x3AA   0x980C             LDR      R0,[SP, #+48]
   \      0x3AC   0x6001             STR      R1,[R0, #+0]
    574                }
    575                CORE_EXIT_ATOMIC();
   \                     ??OSFlagPend_45: (+1)
   \      0x3AE   0x4658             MOV      R0,R11
   \      0x3B0   0x.... 0x....      BL       CORE_ExitAtomic
    576                OS_TRACE_FLAG_PEND_FAILED(p_grp);
    577                RTOS_ERR_SET(*p_err, RTOS_ERR_TIMEOUT);
   \      0x3B4   0x2022             MOVS     R0,#+34
   \      0x3B6   0x7028             STRB     R0,[R5, #+0]
   \      0x3B8   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x3BC   0x6068             STR      R0,[R5, #+4]
   \      0x3BE   0xF240 0x2041      MOVW     R0,#+577
   \      0x3C2   0x60A8             STR      R0,[R5, #+8]
   \      0x3C4   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x3C8   0x60E8             STR      R0,[R5, #+12]
    578                break;
   \      0x3CA   0xE013             B.N      ??OSFlagPend_44
    579          
    580              case OS_STATUS_PEND_DEL:                                    // Indicate that object pended on has been deleted
    581          #if (OS_CFG_TS_EN == DEF_ENABLED)
    582                if (p_ts != DEF_NULL) {
    583                  *p_ts = OSTCBCurPtr->TS;
    584                }
    585          #endif
    586                CORE_EXIT_ATOMIC();
   \                     ??OSFlagPend_40: (+1)
   \      0x3CC   0x4658             MOV      R0,R11
   \      0x3CE   0x.... 0x....      BL       CORE_ExitAtomic
    587                OS_TRACE_FLAG_PEND_FAILED(p_grp);
    588                RTOS_ERR_SET(*p_err, RTOS_ERR_OS_OBJ_DEL);
   \      0x3D2   0x2031             MOVS     R0,#+49
   \      0x3D4   0x7028             STRB     R0,[R5, #+0]
   \      0x3D6   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x3DA   0x6068             STR      R0,[R5, #+4]
   \      0x3DC   0xF44F 0x7013      MOV      R0,#+588
   \      0x3E0   0x60A8             STR      R0,[R5, #+8]
   \      0x3E2   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x3E6   0x60E8             STR      R0,[R5, #+12]
    589                break;
   \      0x3E8   0xE004             B.N      ??OSFlagPend_44
    590          
    591              default:
    592                CORE_EXIT_ATOMIC();
   \                     ??OSFlagPend_43: (+1)
   \      0x3EA   0x4658             MOV      R0,R11
   \      0x3EC   0x.... 0x....      BL       CORE_ExitAtomic
    593                OS_TRACE_FLAG_PEND_FAILED(p_grp);
    594                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS, 0u);
   \      0x3F0   0x.... 0x....      BL       CPU_SW_Exception
    595            }
    596            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \                     ??OSFlagPend_44: (+1)
   \      0x3F4   0x7828             LDRB     R0,[R5, #+0]
   \      0x3F6   0x2800             CMP      R0,#+0
   \      0x3F8   0xD001             BEQ.N    ??OSFlagPend_46
    597              OS_TRACE_FLAG_PEND_FAILED(p_grp);
    598              OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    599              return (0u);
   \      0x3FA   0x2000             MOVS     R0,#+0
   \      0x3FC   0xE027             B.N      ??OSFlagPend_12
    600            }
    601          
    602            flags_rdy = OSTCBCurPtr->FlagsRdy;
   \                     ??OSFlagPend_46: (+1)
   \      0x3FE   0x.... 0x....      LDR.W    R0,??DataTable7_6
   \      0x402   0x6800             LDR      R0,[R0, #+0]
   \      0x404   0xF8D0 0x907C      LDR      R9,[R0, #+124]
    603            if (consume == DEF_TRUE) {                                    // See if we need to consume the flags
   \      0x408   0x4640             MOV      R0,R8
   \      0x40A   0xB2C0             UXTB     R0,R0
   \      0x40C   0x2801             CMP      R0,#+1
   \      0x40E   0xD10F             BNE.N    ??OSFlagPend_47
    604              switch (mode) {
   \      0x410   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x414   0x2804             CMP      R0,#+4
   \      0x416   0xD001             BEQ.N    ??OSFlagPend_48
   \      0x418   0x2808             CMP      R0,#+8
   \      0x41A   0xD104             BNE.N    ??OSFlagPend_49
    605                case OS_OPT_PEND_FLAG_SET_ALL:
    606                case OS_OPT_PEND_FLAG_SET_ANY:                            // Clear ONLY the flags we got
    607                  p_grp->Flags &= ~flags_rdy;
   \                     ??OSFlagPend_48: (+1)
   \      0x41C   0x68E0             LDR      R0,[R4, #+12]
   \      0x41E   0xEA30 0x0009      BICS     R0,R0,R9
   \      0x422   0x60E0             STR      R0,[R4, #+12]
    608                  break;
   \      0x424   0xE004             B.N      ??OSFlagPend_47
    609          
    610          #if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
    611                case OS_OPT_PEND_FLAG_CLR_ALL:
    612                case OS_OPT_PEND_FLAG_CLR_ANY:                            // Set   ONLY the flags we got
    613                  p_grp->Flags |= flags_rdy;
    614                  break;
    615          #endif
    616                default:
    617                  CORE_EXIT_ATOMIC();
   \                     ??OSFlagPend_49: (+1)
   \      0x426   0x4658             MOV      R0,R11
   \      0x428   0x.... 0x....      BL       CORE_ExitAtomic
    618                  OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_INVALID_ARG);
    619                  RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_ARG, 0u);
   \      0x42C   0x.... 0x....      BL       CPU_SW_Exception
    620              }
    621            }
    622            CORE_EXIT_ATOMIC();
   \                     ??OSFlagPend_47: (+1)
   \      0x430   0x4658             MOV      R0,R11
   \      0x432   0x.... 0x....      BL       CORE_ExitAtomic
    623            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);                          // Event(s) must have occurred
   \      0x436   0x2000             MOVS     R0,#+0
   \      0x438   0x7028             STRB     R0,[R5, #+0]
   \      0x43A   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x43E   0x6068             STR      R0,[R5, #+4]
   \      0x440   0xF240 0x206F      MOVW     R0,#+623
   \      0x444   0x60A8             STR      R0,[R5, #+8]
   \      0x446   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \      0x44A   0x60E8             STR      R0,[R5, #+12]
    624            OS_TRACE_FLAG_PEND_EXIT(RTOS_ERR_CODE_GET(*p_err));
    625            return (flags_rdy);
   \      0x44C   0x4648             MOV      R0,R9
   \                     ??OSFlagPend_12: (+1)
   \      0x44E   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    626          }
    627          
    628          /****************************************************************************************************//**
    629           *                                               OSFlagPendAbort()
    630           *
    631           * @brief    This function aborts & prepares any tasks currently waiting on an event flag group.
    632           *           Rather than posting to the event flag group with OSFlagPost(), you should use this
    633           *           function to fault-abort the wait on the event flag group.
    634           *
    635           * @param    p_grp   Pointer to the event flag group.
    636           *
    637           * @param    opt     Determines the type of ABORT performed:
    638           *                       - OS_OPT_PEND_ABORT_1     ABORT wait for a single task (HPT) waiting on
    639           *                                                 the event flag.
    640           *                       - OS_OPT_PEND_ABORT_ALL   ABORT wait for ALL tasks that are  waiting on
    641           *                                                 the event flag.
    642           *                       - OS_OPT_POST_NO_SCHED    Do not call the scheduler.
    643           *
    644           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    645           *                   from this function:
    646           *                       - RTOS_ERR_NONE
    647           *                       - RTOS_ERR_NONE_WAITING
    648           *                       - RTOS_ERR_NOT_READY
    649           *
    650           * @return   == 0    If no tasks were waiting on the event flag group, or upon error.
    651           *           >  0    If one or more tasks waiting on the event flag group are now ready and
    652           *                   informed.
    653           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    654          OS_OBJ_QTY OSFlagPendAbort(OS_FLAG_GRP *p_grp,
    655                                     OS_OPT      opt,
    656                                     RTOS_ERR    *p_err)
    657          {
   \                     OSFlagPendAbort: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x0015             MOVS     R5,R2
    658            OS_PEND_LIST *p_pend_list;
    659            OS_TCB       *p_tcb;
    660            CPU_TS       ts;
    661            OS_OBJ_QTY   nbr_tasks;
    662            CORE_DECLARE_IRQ_STATE;
    663          
    664            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??OSFlagPendAbort_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    665          
    666            //                                                               Not allowed to call from an ISR
    667            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSFlagPendAbort_0: (+1)
   \       0x12   0x.... 0x....      BL       CORE_InIrqContext
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??OSFlagPendAbort_1
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??OSFlagPendAbort_2
   \                     ??OSFlagPendAbort_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??OSFlagPendAbort_2: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10B             BNE.N    ??OSFlagPendAbort_3
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x2E   0x6068             STR      R0,[R5, #+4]
   \       0x30   0xF240 0x209B      MOVW     R0,#+667
   \       0x34   0x60A8             STR      R0,[R5, #+8]
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable7_8
   \       0x3A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagPendAbort_4: (+1)
   \       0x3C   0xE7FE             B.N      ??OSFlagPendAbort_4
    668          
    669            //                                                               Make sure kernel is running.
    670            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSFlagPendAbort_3: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \       0x42   0x7800             LDRB     R0,[R0, #+0]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD00C             BEQ.N    ??OSFlagPendAbort_5
    671              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0x7028             STRB     R0,[R5, #+0]
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x50   0x6068             STR      R0,[R5, #+4]
   \       0x52   0xF240 0x209F      MOVW     R0,#+671
   \       0x56   0x60A8             STR      R0,[R5, #+8]
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable7_8
   \       0x5C   0x60E8             STR      R0,[R5, #+12]
    672              return (0u);
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xE084             B.N      ??OSFlagPendAbort_6
    673            }
    674          
    675            //                                                               Validate 'p_grp'
    676            OS_ASSERT_DBG_ERR_SET((p_grp != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??OSFlagPendAbort_5: (+1)
   \       0x62   0x2C00             CMP      R4,#+0
   \       0x64   0xD10B             BNE.N    ??OSFlagPendAbort_7
   \       0x66   0x200A             MOVS     R0,#+10
   \       0x68   0x7028             STRB     R0,[R5, #+0]
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x6E   0x6068             STR      R0,[R5, #+4]
   \       0x70   0xF44F 0x7029      MOV      R0,#+676
   \       0x74   0x60A8             STR      R0,[R5, #+8]
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable7_8
   \       0x7A   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagPendAbort_8: (+1)
   \       0x7C   0xE7FE             B.N      ??OSFlagPendAbort_8
    677          
    678            //                                                               Validate 'opt'
    679            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_PEND_ABORT_1)
    680                                   || (opt == OS_OPT_PEND_ABORT_ALL)
    681                                   || (opt == (OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED))
    682                                   || (opt == (OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED))), *p_err, RTOS_ERR_INVALID_ARG, 0u);
   \                     ??OSFlagPendAbort_7: (+1)
   \       0x7E   0x4658             MOV      R0,R11
   \       0x80   0xB280             UXTH     R0,R0
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD00E             BEQ.N    ??OSFlagPendAbort_9
   \       0x86   0x4658             MOV      R0,R11
   \       0x88   0xB280             UXTH     R0,R0
   \       0x8A   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x8E   0xD009             BEQ.N    ??OSFlagPendAbort_9
   \       0x90   0x4658             MOV      R0,R11
   \       0x92   0xB280             UXTH     R0,R0
   \       0x94   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x98   0xD004             BEQ.N    ??OSFlagPendAbort_9
   \       0x9A   0x4658             MOV      R0,R11
   \       0x9C   0xB280             UXTH     R0,R0
   \       0x9E   0xF5B0 0x4F01      CMP      R0,#+33024
   \       0xA2   0xD101             BNE.N    ??OSFlagPendAbort_10
   \                     ??OSFlagPendAbort_9: (+1)
   \       0xA4   0x2001             MOVS     R0,#+1
   \       0xA6   0xE000             B.N      ??OSFlagPendAbort_11
   \                     ??OSFlagPendAbort_10: (+1)
   \       0xA8   0x2000             MOVS     R0,#+0
   \                     ??OSFlagPendAbort_11: (+1)
   \       0xAA   0xB2C0             UXTB     R0,R0
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD10B             BNE.N    ??OSFlagPendAbort_12
   \       0xB0   0x2008             MOVS     R0,#+8
   \       0xB2   0x7028             STRB     R0,[R5, #+0]
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0xB8   0x6068             STR      R0,[R5, #+4]
   \       0xBA   0xF240 0x20AA      MOVW     R0,#+682
   \       0xBE   0x60A8             STR      R0,[R5, #+8]
   \       0xC0   0x.... 0x....      LDR.W    R0,??DataTable7_8
   \       0xC4   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagPendAbort_13: (+1)
   \       0xC6   0xE7FE             B.N      ??OSFlagPendAbort_13
    683          
    684            //                                                               Validate event group object
    685            OS_ASSERT_DBG_ERR_SET((p_grp->Type == OS_OBJ_TYPE_FLAG), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
   \                     ??OSFlagPendAbort_12: (+1)
   \       0xC8   0x6821             LDR      R1,[R4, #+0]
   \       0xCA   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \       0xCE   0x4281             CMP      R1,R0
   \       0xD0   0xD00A             BEQ.N    ??OSFlagPendAbort_14
   \       0xD2   0x200C             MOVS     R0,#+12
   \       0xD4   0x7028             STRB     R0,[R5, #+0]
   \       0xD6   0x....             LDR.N    R0,??DataTable7
   \       0xD8   0x6068             STR      R0,[R5, #+4]
   \       0xDA   0xF240 0x20AD      MOVW     R0,#+685
   \       0xDE   0x60A8             STR      R0,[R5, #+8]
   \       0xE0   0x.... 0x....      LDR.W    R0,??DataTable7_8
   \       0xE4   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSFlagPendAbort_15: (+1)
   \       0xE6   0xE7FE             B.N      ??OSFlagPendAbort_15
    686          
    687            CORE_ENTER_ATOMIC();
   \                     ??OSFlagPendAbort_14: (+1)
   \       0xE8   0x.... 0x....      BL       CORE_EnterAtomic
   \       0xEC   0x0007             MOVS     R7,R0
    688            p_pend_list = &p_grp->PendList;
   \       0xEE   0xF114 0x0804      ADDS     R8,R4,#+4
    689            if (p_pend_list->HeadPtr == DEF_NULL) {                       // Any task waiting on flag group?
   \       0xF2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xF6   0x2800             CMP      R0,#+0
   \       0xF8   0xD10D             BNE.N    ??OSFlagPendAbort_16
    690              CORE_EXIT_ATOMIC();                                         // No
   \       0xFA   0x0038             MOVS     R0,R7
   \       0xFC   0x.... 0x....      BL       CORE_ExitAtomic
    691              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE_WAITING);
   \      0x100   0x2024             MOVS     R0,#+36
   \      0x102   0x7028             STRB     R0,[R5, #+0]
   \      0x104   0x....             LDR.N    R0,??DataTable7
   \      0x106   0x6068             STR      R0,[R5, #+4]
   \      0x108   0xF240 0x20B3      MOVW     R0,#+691
   \      0x10C   0x60A8             STR      R0,[R5, #+8]
   \      0x10E   0x....             LDR.N    R0,??DataTable7_8
   \      0x110   0x60E8             STR      R0,[R5, #+12]
    692              return (0u);
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0xE02A             B.N      ??OSFlagPendAbort_6
    693            }
    694          
    695            nbr_tasks = 0u;
   \                     ??OSFlagPendAbort_16: (+1)
   \      0x116   0xF05F 0x0900      MOVS     R9,#+0
    696          #if (OS_CFG_TS_EN == DEF_ENABLED)
    697            ts = OS_TS_GET();                                             // Get local time stamp so all tasks get the same time
    698          #else
    699            ts = 0u;
   \      0x11A   0xF05F 0x0A00      MOVS     R10,#+0
    700          #endif
    701          
    702            while (p_pend_list->HeadPtr != DEF_NULL) {
   \                     ??OSFlagPendAbort_17: (+1)
   \      0x11E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xD00E             BEQ.N    ??OSFlagPendAbort_18
    703              p_tcb = p_pend_list->HeadPtr;
   \      0x126   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x12A   0x0006             MOVS     R6,R0
    704              OS_PendAbort(p_tcb,
    705                           ts,
    706                           OS_STATUS_PEND_ABORT);
   \      0x12C   0x2201             MOVS     R2,#+1
   \      0x12E   0x4651             MOV      R1,R10
   \      0x130   0x0030             MOVS     R0,R6
   \      0x132   0x.... 0x....      BL       OS_PendAbort
    707              nbr_tasks++;
   \      0x136   0xF119 0x0901      ADDS     R9,R9,#+1
    708              if (opt != OS_OPT_PEND_ABORT_ALL) {                         // Pend abort all tasks waiting?
   \      0x13A   0x4658             MOV      R0,R11
   \      0x13C   0xB280             UXTH     R0,R0
   \      0x13E   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x142   0xD0EC             BEQ.N    ??OSFlagPendAbort_17
    709                break;                                                    // No
    710              }
    711            }
    712            CORE_EXIT_ATOMIC();
   \                     ??OSFlagPendAbort_18: (+1)
   \      0x144   0x0038             MOVS     R0,R7
   \      0x146   0x.... 0x....      BL       CORE_ExitAtomic
    713          
    714            if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \      0x14A   0x4658             MOV      R0,R11
   \      0x14C   0xB280             UXTH     R0,R0
   \      0x14E   0x0400             LSLS     R0,R0,#+16
   \      0x150   0xD401             BMI.N    ??OSFlagPendAbort_19
    715              OSSched();                                                  // Run the scheduler
   \      0x152   0x.... 0x....      BL       OSSched
    716            }
    717          
    718            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSFlagPendAbort_19: (+1)
   \      0x156   0x2000             MOVS     R0,#+0
   \      0x158   0x7028             STRB     R0,[R5, #+0]
   \      0x15A   0x....             LDR.N    R0,??DataTable7
   \      0x15C   0x6068             STR      R0,[R5, #+4]
   \      0x15E   0xF240 0x20CE      MOVW     R0,#+718
   \      0x162   0x60A8             STR      R0,[R5, #+8]
   \      0x164   0x....             LDR.N    R0,??DataTable7_8
   \      0x166   0x60E8             STR      R0,[R5, #+12]
    719            return (nbr_tasks);
   \      0x168   0x4648             MOV      R0,R9
   \      0x16A   0xB280             UXTH     R0,R0
   \                     ??OSFlagPendAbort_6: (+1)
   \      0x16C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    720          }
    721          
    722          /****************************************************************************************************//**
    723           *                                           OSFlagPendGetFlagsRdy()
    724           *
    725           * @brief    This function is called to obtain the flags that caused the task to be ready.
    726           *           In other words, this function allows you to reveal "Who done it!"
    727           *
    728           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    729           *                   from this function:
    730           *                       - RTOS_ERR_NONE
    731           *                       - RTOS_ERR_NOT_READY
    732           *
    733           * @return   The flags that caused the task to be ready.
    734           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    735          OS_FLAGS OSFlagPendGetFlagsRdy(RTOS_ERR *p_err)
    736          {
   \                     OSFlagPendGetFlagsRdy: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    737            OS_FLAGS flags;
    738            CORE_DECLARE_IRQ_STATE;
    739          
    740            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??OSFlagPendGetFlagsRdy_0
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
    741          
    742            //                                                               Make sure kernel is running.
    743            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSFlagPendGetFlagsRdy_0: (+1)
   \        0xC   0x....             LDR.N    R0,??DataTable7_4
   \        0xE   0x7800             LDRB     R0,[R0, #+0]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD00A             BEQ.N    ??OSFlagPendGetFlagsRdy_1
    744              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0x7020             STRB     R0,[R4, #+0]
   \       0x18   0x....             LDR.N    R0,??DataTable7
   \       0x1A   0x6060             STR      R0,[R4, #+4]
   \       0x1C   0xF44F 0x703A      MOV      R0,#+744
   \       0x20   0x60A0             STR      R0,[R4, #+8]
   \       0x22   0x....             LDR.N    R0,??DataTable7_9
   \       0x24   0x60E0             STR      R0,[R4, #+12]
    745              return (0u);
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE026             B.N      ??OSFlagPendGetFlagsRdy_2
    746            }
    747          
    748            //                                                               Not allowed to call from an ISR
    749            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR, 0u);
   \                     ??OSFlagPendGetFlagsRdy_1: (+1)
   \       0x2A   0x.... 0x....      BL       CORE_InIrqContext
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD101             BNE.N    ??OSFlagPendGetFlagsRdy_3
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xE000             B.N      ??OSFlagPendGetFlagsRdy_4
   \                     ??OSFlagPendGetFlagsRdy_3: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??OSFlagPendGetFlagsRdy_4: (+1)
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD109             BNE.N    ??OSFlagPendGetFlagsRdy_5
   \       0x3E   0x2020             MOVS     R0,#+32
   \       0x40   0x7020             STRB     R0,[R4, #+0]
   \       0x42   0x....             LDR.N    R0,??DataTable7
   \       0x44   0x6060             STR      R0,[R4, #+4]
   \       0x46   0xF240 0x20ED      MOVW     R0,#+749
   \       0x4A   0x60A0             STR      R0,[R4, #+8]
   \       0x4C   0x....             LDR.N    R0,??DataTable7_9
   \       0x4E   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSFlagPendGetFlagsRdy_6: (+1)
   \       0x50   0xE7FE             B.N      ??OSFlagPendGetFlagsRdy_6
    750          
    751            CORE_ENTER_ATOMIC();
   \                     ??OSFlagPendGetFlagsRdy_5: (+1)
   \       0x52   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x56   0x0005             MOVS     R5,R0
    752            flags = OSTCBCurPtr->FlagsRdy;
   \       0x58   0x....             LDR.N    R0,??DataTable7_6
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x6FC6             LDR      R6,[R0, #+124]
    753            CORE_EXIT_ATOMIC();
   \       0x5E   0x0028             MOVS     R0,R5
   \       0x60   0x.... 0x....      BL       CORE_ExitAtomic
    754            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x7020             STRB     R0,[R4, #+0]
   \       0x68   0x....             LDR.N    R0,??DataTable7
   \       0x6A   0x6060             STR      R0,[R4, #+4]
   \       0x6C   0xF240 0x20F2      MOVW     R0,#+754
   \       0x70   0x60A0             STR      R0,[R4, #+8]
   \       0x72   0x....             LDR.N    R0,??DataTable7_9
   \       0x74   0x60E0             STR      R0,[R4, #+12]
    755            return (flags);
   \       0x76   0x0030             MOVS     R0,R6
   \                     ??OSFlagPendGetFlagsRdy_2: (+1)
   \       0x78   0xBD70             POP      {R4-R6,PC}
    756          }
    757          
    758          /****************************************************************************************************//**
    759           *                                               OSFlagPost()
    760           *
    761           * @brief    This function is called to set or clear some bits in an event flag group. The bits to set
    762           *           or clear are specified by a 'bit mask'.
    763           *
    764           * @param    p_grp   Pointer to the event flag group.
    765           *
    766           * @param    flags   If 'opt' (see below) is OS_OPT_POST_FLAG_SET, each bit set in 'flags' will be
    767           *                   SET to the corresponding bit in the event flag group. For example, to set bits
    768           *                   0, 4, and 5, you would set 'flags' to:
    769           *
    770           *                       - 0x31    (note, bit 0 is least significant bit)
    771           *
    772           *                   If 'opt' (see below) is OS_OPT_POST_FLAG_CLR, each bit set in 'flags'
    773           *                   will CLEAR the corresponding bit in the event flag group. For example, to clear
    774           *                   bits 0, 4, and 5, you would specify 'flags' as:
    775           *
    776           *                       - 0x31    (note, bit 0 is least significant bit)
    777           *
    778           *
    779           * @param    opt     Indicates whether the flags will be Set or Cleared:
    780           *                       - OS_OPT_POST_FLAG_SET    Set.
    781           *                       - OS_OPT_POST_FLAG_CLR    Cleared.
    782           *
    783           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    784           *                   from this function:
    785           *                       - RTOS_ERR_NONE
    786           *                       - RTOS_ERR_NOT_READY
    787           *
    788           * @return   The new value of the event flags bits that are still set.
    789           *
    790           * @note     (1) The execution time of this function depends on the number of tasks waiting on the
    791           *               event flag group.
    792           *
    793           * @note     (2) This function may be called from an ISR.
    794           *
    795           * @note     (3) OS_OPT_POST_NO_SCHED can be OR'ed with one of the other two options to prevent the
    796           *               scheduler from being called.
    797           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    798          OS_FLAGS OSFlagPost(OS_FLAG_GRP *p_grp,
    799                              OS_FLAGS    flags,
    800                              OS_OPT      opt,
    801                              RTOS_ERR    *p_err)
    802          {
   \                     OSFlagPost: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x0006             MOVS     R6,R0
   \        0x8   0x468B             MOV      R11,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x001F             MOVS     R7,R3
    803            OS_FLAGS     flags_cur;
    804            OS_FLAGS     flags_rdy;
    805            OS_OPT       mode;
    806            OS_PEND_LIST *p_pend_list;
    807            OS_TCB       *p_tcb;
    808            OS_TCB       *p_tcb_next;
    809            CPU_TS       ts;
    810            CORE_DECLARE_IRQ_STATE;
    811          
    812            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0xE   0x2F00             CMP      R7,#+0
   \       0x10   0xD101             BNE.N    ??OSFlagPost_0
   \       0x12   0x.... 0x....      BL       CPU_SW_Exception
    813          
    814            OS_TRACE_FLAG_POST_ENTER(p_grp, flags, opt);
    815          
    816            //                                                               Make sure kernel is running.
    817            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSFlagPost_0: (+1)
   \       0x16   0x....             LDR.N    R0,??DataTable7_4
   \       0x18   0x7800             LDRB     R0,[R0, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD00A             BEQ.N    ??OSFlagPost_1
    818              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x7038             STRB     R0,[R7, #+0]
   \       0x22   0x....             LDR.N    R0,??DataTable7
   \       0x24   0x6078             STR      R0,[R7, #+4]
   \       0x26   0xF240 0x3032      MOVW     R0,#+818
   \       0x2A   0x60B8             STR      R0,[R7, #+8]
   \       0x2C   0x....             LDR.N    R0,??DataTable7_10
   \       0x2E   0x60F8             STR      R0,[R7, #+12]
    819              return (0u);
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xE0C1             B.N      ??OSFlagPost_2
    820            }
    821          
    822            //                                                               Validate 'p_grp'
    823            OS_ASSERT_DBG_ERR_SET((p_grp != DEF_NULL), *p_err, RTOS_ERR_NULL_PTR, 0u);
   \                     ??OSFlagPost_1: (+1)
   \       0x34   0x2E00             CMP      R6,#+0
   \       0x36   0xD109             BNE.N    ??OSFlagPost_3
   \       0x38   0x200A             MOVS     R0,#+10
   \       0x3A   0x7038             STRB     R0,[R7, #+0]
   \       0x3C   0x....             LDR.N    R0,??DataTable7
   \       0x3E   0x6078             STR      R0,[R7, #+4]
   \       0x40   0xF240 0x3037      MOVW     R0,#+823
   \       0x44   0x60B8             STR      R0,[R7, #+8]
   \       0x46   0x....             LDR.N    R0,??DataTable7_10
   \       0x48   0x60F8             STR      R0,[R7, #+12]
   \                     ??OSFlagPost_4: (+1)
   \       0x4A   0xE7FE             B.N      ??OSFlagPost_4
    824          
    825            //                                                               Validate 'opt'
    826            OS_ASSERT_DBG_ERR_SET(((opt == OS_OPT_POST_FLAG_SET)
    827                                   || (opt == OS_OPT_POST_FLAG_CLR)
    828                                   || (opt == (OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED))
    829                                   || (opt == (OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED))), *p_err, RTOS_ERR_INVALID_ARG, 0u);
   \                     ??OSFlagPost_3: (+1)
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0xB280             UXTH     R0,R0
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD00E             BEQ.N    ??OSFlagPost_5
   \       0x54   0x4640             MOV      R0,R8
   \       0x56   0xB280             UXTH     R0,R0
   \       0x58   0x2801             CMP      R0,#+1
   \       0x5A   0xD00A             BEQ.N    ??OSFlagPost_5
   \       0x5C   0x4640             MOV      R0,R8
   \       0x5E   0xB280             UXTH     R0,R0
   \       0x60   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x64   0xD005             BEQ.N    ??OSFlagPost_5
   \       0x66   0x4641             MOV      R1,R8
   \       0x68   0xF248 0x0001      MOVW     R0,#+32769
   \       0x6C   0xB289             UXTH     R1,R1
   \       0x6E   0x4281             CMP      R1,R0
   \       0x70   0xD101             BNE.N    ??OSFlagPost_6
   \                     ??OSFlagPost_5: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0xE000             B.N      ??OSFlagPost_7
   \                     ??OSFlagPost_6: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \                     ??OSFlagPost_7: (+1)
   \       0x78   0xB2C0             UXTB     R0,R0
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD109             BNE.N    ??OSFlagPost_8
   \       0x7E   0x2008             MOVS     R0,#+8
   \       0x80   0x7038             STRB     R0,[R7, #+0]
   \       0x82   0x....             LDR.N    R0,??DataTable7
   \       0x84   0x6078             STR      R0,[R7, #+4]
   \       0x86   0xF240 0x303D      MOVW     R0,#+829
   \       0x8A   0x60B8             STR      R0,[R7, #+8]
   \       0x8C   0x....             LDR.N    R0,??DataTable7_10
   \       0x8E   0x60F8             STR      R0,[R7, #+12]
   \                     ??OSFlagPost_9: (+1)
   \       0x90   0xE7FE             B.N      ??OSFlagPost_9
    830          
    831            //                                                               Validate event group object
    832            OS_ASSERT_DBG_ERR_SET((p_grp->Type == OS_OBJ_TYPE_FLAG), *p_err, RTOS_ERR_INVALID_TYPE, 0u);
   \                     ??OSFlagPost_8: (+1)
   \       0x92   0x6830             LDR      R0,[R6, #+0]
   \       0x94   0x....             LDR.N    R1,??DataTable7_2
   \       0x96   0x4288             CMP      R0,R1
   \       0x98   0xD009             BEQ.N    ??OSFlagPost_10
   \       0x9A   0x200C             MOVS     R0,#+12
   \       0x9C   0x7038             STRB     R0,[R7, #+0]
   \       0x9E   0x....             LDR.N    R0,??DataTable7
   \       0xA0   0x6078             STR      R0,[R7, #+4]
   \       0xA2   0xF44F 0x7050      MOV      R0,#+832
   \       0xA6   0x60B8             STR      R0,[R7, #+8]
   \       0xA8   0x....             LDR.N    R0,??DataTable7_10
   \       0xAA   0x60F8             STR      R0,[R7, #+12]
   \                     ??OSFlagPost_11: (+1)
   \       0xAC   0xE7FE             B.N      ??OSFlagPost_11
    833          
    834          #if (OS_CFG_TS_EN == DEF_ENABLED)
    835            ts = OS_TS_GET();                                             // Get timestamp
    836          #else
    837            ts = 0u;
   \                     ??OSFlagPost_10: (+1)
   \       0xAE   0xF05F 0x0900      MOVS     R9,#+0
    838          #endif
    839          
    840            OS_TRACE_FLAG_POST(p_grp);
    841          
    842            CORE_ENTER_ATOMIC();
   \       0xB2   0x.... 0x....      BL       CORE_EnterAtomic
   \       0xB6   0x4682             MOV      R10,R0
    843            switch (opt) {
   \       0xB8   0x4641             MOV      R1,R8
   \       0xBA   0xB289             UXTH     R1,R1
   \       0xBC   0x2900             CMP      R1,#+0
   \       0xBE   0xD009             BEQ.N    ??OSFlagPost_12
   \       0xC0   0x2901             CMP      R1,#+1
   \       0xC2   0xD00C             BEQ.N    ??OSFlagPost_13
   \       0xC4   0xF5B1 0x4F00      CMP      R1,#+32768
   \       0xC8   0xD004             BEQ.N    ??OSFlagPost_12
   \       0xCA   0xF248 0x0001      MOVW     R0,#+32769
   \       0xCE   0x4281             CMP      R1,R0
   \       0xD0   0xD005             BEQ.N    ??OSFlagPost_13
   \       0xD2   0xE009             B.N      ??OSFlagPost_14
    844              case OS_OPT_POST_FLAG_SET:
    845              case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
    846                p_grp->Flags |= flags;                                    // Set   the flags specified in the group
   \                     ??OSFlagPost_12: (+1)
   \       0xD4   0x68F0             LDR      R0,[R6, #+12]
   \       0xD6   0xEA5B 0x0000      ORRS     R0,R11,R0
   \       0xDA   0x60F0             STR      R0,[R6, #+12]
    847                break;
   \       0xDC   0xE009             B.N      ??OSFlagPost_15
    848          
    849              case OS_OPT_POST_FLAG_CLR:
    850              case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
    851                p_grp->Flags &= ~flags;                                   // Clear the flags specified in the group
   \                     ??OSFlagPost_13: (+1)
   \       0xDE   0x68F0             LDR      R0,[R6, #+12]
   \       0xE0   0xEA30 0x000B      BICS     R0,R0,R11
   \       0xE4   0x60F0             STR      R0,[R6, #+12]
    852                break;
   \       0xE6   0xE004             B.N      ??OSFlagPost_15
    853          
    854              default:
    855                CORE_EXIT_ATOMIC();                                       // INVALID option, checked before, should never happen
   \                     ??OSFlagPost_14: (+1)
   \       0xE8   0x4650             MOV      R0,R10
   \       0xEA   0x.... 0x....      BL       CORE_ExitAtomic
    856                OS_TRACE_FLAG_POST_EXIT(RTOS_ERR_INVALID_ARG);
    857                OS_TRACE_FLAG_POST_FAILED(p_grp);
    858                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_ARG, 0u);
   \       0xEE   0x.... 0x....      BL       CPU_SW_Exception
    859            }
    860          #if (OS_CFG_TS_EN == DEF_ENABLED)
    861            p_grp->TS = ts;
    862          #endif
    863            p_pend_list = &p_grp->PendList;
   \                     ??OSFlagPost_15: (+1)
   \       0xF2   0x1D30             ADDS     R0,R6,#+4
   \       0xF4   0x9002             STR      R0,[SP, #+8]
    864            if (p_pend_list->HeadPtr == DEF_NULL) {                       // Any task waiting on event flag group?
   \       0xF6   0x9802             LDR      R0,[SP, #+8]
   \       0xF8   0x6800             LDR      R0,[R0, #+0]
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xD10D             BNE.N    ??OSFlagPost_16
    865              CORE_EXIT_ATOMIC();                                         // No
   \       0xFE   0x4650             MOV      R0,R10
   \      0x100   0x.... 0x....      BL       CORE_ExitAtomic
    866              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0x7038             STRB     R0,[R7, #+0]
   \      0x108   0x....             LDR.N    R0,??DataTable7
   \      0x10A   0x6078             STR      R0,[R7, #+4]
   \      0x10C   0xF240 0x3062      MOVW     R0,#+866
   \      0x110   0x60B8             STR      R0,[R7, #+8]
   \      0x112   0x....             LDR.N    R0,??DataTable7_10
   \      0x114   0x60F8             STR      R0,[R7, #+12]
    867              OS_TRACE_FLAG_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
    868              return (p_grp->Flags);
   \      0x116   0x68F0             LDR      R0,[R6, #+12]
   \      0x118   0xE04E             B.N      ??OSFlagPost_2
    869            }
    870          
    871            p_tcb = p_pend_list->HeadPtr;
   \                     ??OSFlagPost_16: (+1)
   \      0x11A   0x9802             LDR      R0,[SP, #+8]
   \      0x11C   0x6805             LDR      R5,[R0, #+0]
    872            while (p_tcb != DEF_NULL) {                                   // Go through all tasks waiting on event flag(s)
   \                     ??OSFlagPost_17: (+1)
   \      0x11E   0x2D00             CMP      R5,#+0
   \      0x120   0xD02F             BEQ.N    ??OSFlagPost_18
    873              p_tcb_next = p_tcb->PendNextPtr;
   \      0x122   0x69A8             LDR      R0,[R5, #+24]
   \      0x124   0x9001             STR      R0,[SP, #+4]
    874              mode = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
   \      0x126   0xF895 0x0080      LDRB     R0,[R5, #+128]
   \      0x12A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x12E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    875              switch (mode) {
   \      0x132   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x136   0x2804             CMP      R0,#+4
   \      0x138   0xD002             BEQ.N    ??OSFlagPost_19
   \      0x13A   0x2808             CMP      R0,#+8
   \      0x13C   0xD00D             BEQ.N    ??OSFlagPost_20
   \      0x13E   0xE018             B.N      ??OSFlagPost_21
    876                case OS_OPT_PEND_FLAG_SET_ALL:                            // See if all req. flags are set for current node
    877                  flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
   \                     ??OSFlagPost_19: (+1)
   \      0x140   0x68F1             LDR      R1,[R6, #+12]
   \      0x142   0x6FA8             LDR      R0,[R5, #+120]
   \      0x144   0x4001             ANDS     R1,R0,R1
   \      0x146   0x000C             MOVS     R4,R1
    878                  if (flags_rdy == p_tcb->FlagsPend) {
   \      0x148   0x6FA8             LDR      R0,[R5, #+120]
   \      0x14A   0x4284             CMP      R4,R0
   \      0x14C   0xD104             BNE.N    ??OSFlagPost_22
    879                    OS_FlagTaskRdy(p_tcb,                                 // Make task RTR, event(s) Rx'd
    880                                   flags_rdy,
    881                                   ts);
   \      0x14E   0x464A             MOV      R2,R9
   \      0x150   0x0021             MOVS     R1,R4
   \      0x152   0x0028             MOVS     R0,R5
   \      0x154   0x.... 0x....      BL       OS_FlagTaskRdy
    882                  }
    883                  break;
   \                     ??OSFlagPost_22: (+1)
   \      0x158   0xE010             B.N      ??OSFlagPost_23
    884          
    885                case OS_OPT_PEND_FLAG_SET_ANY:                            // See if any flag set
    886                  flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
   \                     ??OSFlagPost_20: (+1)
   \      0x15A   0x68F1             LDR      R1,[R6, #+12]
   \      0x15C   0x6FA8             LDR      R0,[R5, #+120]
   \      0x15E   0x4001             ANDS     R1,R0,R1
   \      0x160   0x000C             MOVS     R4,R1
    887                  if (flags_rdy != 0u) {
   \      0x162   0x2C00             CMP      R4,#+0
   \      0x164   0xD004             BEQ.N    ??OSFlagPost_24
    888                    OS_FlagTaskRdy(p_tcb,                                 // Make task RTR, event(s) Rx'd
    889                                   flags_rdy,
    890                                   ts);
   \      0x166   0x464A             MOV      R2,R9
   \      0x168   0x0021             MOVS     R1,R4
   \      0x16A   0x0028             MOVS     R0,R5
   \      0x16C   0x.... 0x....      BL       OS_FlagTaskRdy
    891                  }
    892                  break;
   \                     ??OSFlagPost_24: (+1)
   \      0x170   0xE004             B.N      ??OSFlagPost_23
    893          
    894          #if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
    895                case OS_OPT_PEND_FLAG_CLR_ALL:                            // See if all req. flags are set for current node
    896                  flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
    897                  if (flags_rdy == p_tcb->FlagsPend) {
    898                    OS_FlagTaskRdy(p_tcb,                                 // Make task RTR, event(s) Rx'd
    899                                   flags_rdy,
    900                                   ts);
    901                  }
    902                  break;
    903          
    904                case OS_OPT_PEND_FLAG_CLR_ANY:                            // See if any flag set
    905                  flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
    906                  if (flags_rdy != 0u) {
    907                    OS_FlagTaskRdy(p_tcb,                                 // Make task RTR, event(s) Rx'd
    908                                   flags_rdy,
    909                                   ts);
    910                  }
    911                  break;
    912          #endif
    913                default:
    914                  CORE_EXIT_ATOMIC();                                     // Checked before, should never happen
   \                     ??OSFlagPost_21: (+1)
   \      0x172   0x4650             MOV      R0,R10
   \      0x174   0x.... 0x....      BL       CORE_ExitAtomic
    915                  OS_TRACE_FLAG_POST_EXIT(RTOS_ERR_INVALID_ARG);
    916                  OS_TRACE_FLAG_POST_FAILED(p_grp);
    917                  RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_ARG, 0u);
   \      0x178   0x.... 0x....      BL       CPU_SW_Exception
    918              }
    919              //                                                             Point to next task waiting for event flag(s)
    920              p_tcb = p_tcb_next;
   \                     ??OSFlagPost_23: (+1)
   \      0x17C   0x9801             LDR      R0,[SP, #+4]
   \      0x17E   0x0005             MOVS     R5,R0
   \      0x180   0xE7CD             B.N      ??OSFlagPost_17
    921            }
    922            CORE_EXIT_ATOMIC();
   \                     ??OSFlagPost_18: (+1)
   \      0x182   0x4650             MOV      R0,R10
   \      0x184   0x.... 0x....      BL       CORE_ExitAtomic
    923          
    924            if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \      0x188   0x4640             MOV      R0,R8
   \      0x18A   0xB280             UXTH     R0,R0
   \      0x18C   0x0400             LSLS     R0,R0,#+16
   \      0x18E   0xD401             BMI.N    ??OSFlagPost_25
    925              OSSched();
   \      0x190   0x.... 0x....      BL       OSSched
    926            }
    927          
    928            CORE_ENTER_ATOMIC();
   \                     ??OSFlagPost_25: (+1)
   \      0x194   0x.... 0x....      BL       CORE_EnterAtomic
   \      0x198   0x9003             STR      R0,[SP, #+12]
    929            flags_cur = p_grp->Flags;
   \      0x19A   0x68F0             LDR      R0,[R6, #+12]
   \      0x19C   0x9004             STR      R0,[SP, #+16]
    930            CORE_EXIT_ATOMIC();
   \      0x19E   0x9803             LDR      R0,[SP, #+12]
   \      0x1A0   0x.... 0x....      BL       CORE_ExitAtomic
    931            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \      0x1A4   0x2000             MOVS     R0,#+0
   \      0x1A6   0x7038             STRB     R0,[R7, #+0]
   \      0x1A8   0x....             LDR.N    R0,??DataTable7
   \      0x1AA   0x6078             STR      R0,[R7, #+4]
   \      0x1AC   0xF240 0x30A3      MOVW     R0,#+931
   \      0x1B0   0x60B8             STR      R0,[R7, #+8]
   \      0x1B2   0x....             LDR.N    R0,??DataTable7_10
   \      0x1B4   0x60F8             STR      R0,[R7, #+12]
    932          
    933            OS_TRACE_FLAG_POST_EXIT(RTOS_ERR_CODE_GET(*p_err));
    934          
    935            return (flags_cur);
   \      0x1B6   0x9804             LDR      R0,[SP, #+16]
   \                     ??OSFlagPost_2: (+1)
   \      0x1B8   0xB005             ADD      SP,SP,#+20
   \      0x1BA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    936          }
    937          
    938          /********************************************************************************************************
    939           ********************************************************************************************************
    940           *                                           INTERNAL FUNCTIONS
    941           ********************************************************************************************************
    942           *******************************************************************************************************/
    943          
    944          /****************************************************************************************************//**
    945           *                                               OS_FlagBlock()
    946           *
    947           * @brief    This function is internal to the Kernel and is used to put a task to sleep until the
    948           *           desired event flag bit(s) are set.
    949           *
    950           * @param    p_grp       Pointer to the event flag group.
    951           *
    952           * @param    flags       Bit pattern indicating which bit(s) (i.e. flags) you wish to check.
    953           *                       The bits you want are specified by setting the corresponding bits in
    954           *                       'flags'. e.g. if your application wants to wait for bits 0 and 1 then
    955           *                       'flags' would contain 0x03.
    956           *
    957           * @param    opt         Specifies whether you want ALL bits to be set/cleared or ANY of the bits
    958           *                       to be set/cleared.
    959           *                       You can specify the following argument:
    960           *                           - OS_OPT_PEND_FLAG_CLR_ALL    Check ALL bits in 'mask' to be clear. (0)
    961           *                           - OS_OPT_PEND_FLAG_CLR_ANY    Check ANY bit  in 'mask' to be clear. (0)
    962           *                           - OS_OPT_PEND_FLAG_SET_ALL    Check ALL bits in 'mask' to be set.   (1)
    963           *                           - OS_OPT_PEND_FLAG_SET_ANY    Check ANY bit  in 'mask' to be set.   (1)
    964           *
    965           * @param    timeout     The desired amount of time that the task will wait for the event flag
    966           *                       bit(s) to be set.
    967           *
    968           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    969           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    970          void OS_FlagBlock(OS_FLAG_GRP *p_grp,
    971                            OS_FLAGS    flags,
    972                            OS_OPT      opt,
    973                            OS_TICK     timeout)
    974          {
   \                     OS_FlagBlock: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
    975            OSTCBCurPtr->FlagsPend = flags;                               // Save the flags that we need to wait for
   \        0xA   0x....             LDR.N    R1,??DataTable7_6
   \        0xC   0x6808             LDR      R0,[R1, #+0]
   \        0xE   0x6785             STR      R5,[R0, #+120]
    976            OSTCBCurPtr->FlagsOpt = opt;                                  // Save the type of wait we are doing
   \       0x10   0x6808             LDR      R0,[R1, #+0]
   \       0x12   0xF8A0 0x6080      STRH     R6,[R0, #+128]
    977            OSTCBCurPtr->FlagsRdy = 0u;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x6809             LDR      R1,[R1, #+0]
   \       0x1A   0x67C8             STR      R0,[R1, #+124]
    978          
    979            OS_Pend((OS_PEND_OBJ *)((void *)p_grp),
    980                    OS_TASK_PEND_ON_FLAG,
    981                    timeout);
   \       0x1C   0x003A             MOVS     R2,R7
   \       0x1E   0x2101             MOVS     R1,#+1
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       OS_Pend
    982          }
   \       0x26   0xBDF1             POP      {R0,R4-R7,PC}
    983          
    984          /****************************************************************************************************//**
    985           *                                               OS_FlagClr()
    986           *
    987           * @brief    This function is called by OSFlagDel() to clear the contents of an event flag group.
    988           *
    989           * @param    p_grp   Pointer to the event flag group to clear.
    990           *
    991           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
    992           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    993          void OS_FlagClr(OS_FLAG_GRP *p_grp)
    994          {
   \                     OS_FlagClr: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    995            OS_PEND_LIST *p_pend_list;
    996          
    997          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    998            p_grp->Type = OS_OBJ_TYPE_NONE;
   \        0x4   0x....             LDR.N    R0,??DataTable7_11
   \        0x6   0x6020             STR      R0,[R4, #+0]
    999          #endif
   1000          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1001            p_grp->NamePtr = (CPU_CHAR *)((void *)"?FLAG");               // Unknown name
   1002          #endif
   1003            p_grp->Flags = 0u;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x60E0             STR      R0,[R4, #+12]
   1004            p_pend_list = &p_grp->PendList;
   \        0xC   0x1D25             ADDS     R5,R4,#+4
   1005            OS_PendListInit(p_pend_list);
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       OS_PendListInit
   1006          }
   \       0x14   0xBD31             POP      {R0,R4,R5,PC}
   1007          
   1008          /****************************************************************************************************//**
   1009           *                                           OS_FlagDbgListAdd()
   1010           *
   1011           * @brief    Add an event flag group from the event flag debug list.
   1012           *
   1013           * @param    p_grp   Pointer to the event flag group to add.
   1014           *
   1015           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1016           *******************************************************************************************************/
   1017          
   1018          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1019          void OS_FlagDbgListAdd(OS_FLAG_GRP *p_grp)
   1020          {
   1021            p_grp->DbgNamePtr = (CPU_CHAR *)((void *)" ");
   1022            p_grp->DbgPrevPtr = DEF_NULL;
   1023            if (OSFlagDbgListPtr == DEF_NULL) {
   1024              p_grp->DbgNextPtr = DEF_NULL;
   1025            } else {
   1026              p_grp->DbgNextPtr = OSFlagDbgListPtr;
   1027              OSFlagDbgListPtr->DbgPrevPtr = p_grp;
   1028            }
   1029            OSFlagDbgListPtr = p_grp;
   1030          }
   1031          
   1032          /****************************************************************************************************//**
   1033           *                                           OS_FlagDbgListRemove()
   1034           *
   1035           * @brief    Remove an event flag group from the event flag debug list.
   1036           *
   1037           * @param    p_grp   Pointer to the event flag group to remove.
   1038           *
   1039           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1040           *******************************************************************************************************/
   1041          void OS_FlagDbgListRemove(OS_FLAG_GRP *p_grp)
   1042          {
   1043            OS_FLAG_GRP *p_grp_next;
   1044            OS_FLAG_GRP *p_grp_prev;
   1045          
   1046            p_grp_prev = p_grp->DbgPrevPtr;
   1047            p_grp_next = p_grp->DbgNextPtr;
   1048          
   1049            if (p_grp_prev == DEF_NULL) {
   1050              OSFlagDbgListPtr = p_grp_next;
   1051              if (p_grp_next != DEF_NULL) {
   1052                p_grp_next->DbgPrevPtr = DEF_NULL;
   1053              }
   1054              p_grp->DbgNextPtr = DEF_NULL;
   1055            } else if (p_grp_next == DEF_NULL) {
   1056              p_grp_prev->DbgNextPtr = DEF_NULL;
   1057              p_grp->DbgPrevPtr = DEF_NULL;
   1058            } else {
   1059              p_grp_prev->DbgNextPtr = p_grp_next;
   1060              p_grp_next->DbgPrevPtr = p_grp_prev;
   1061              p_grp->DbgNextPtr = DEF_NULL;
   1062              p_grp->DbgPrevPtr = DEF_NULL;
   1063            }
   1064          }
   1065          #endif
   1066          
   1067          /****************************************************************************************************//**
   1068           *                                               OS_FlagTaskRdy()
   1069           *
   1070           * @brief    This function is internal to the Kernel and is used to make a task ready-to-run because
   1071           *           the desired event flag bits have been set.
   1072           *
   1073           * @param    p_tcb       Pointer to the OS_TCB of the task to remove.
   1074           *
   1075           * @param    flags_rdy   Contains the bit pattern of the event flags that cause the task to become
   1076           *                       ready-to-run.
   1077           *
   1078           * @param    ts          Timestamp associated with the post.
   1079           *
   1080           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1081           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1082          void OS_FlagTaskRdy(OS_TCB   *p_tcb,
   1083                              OS_FLAGS flags_rdy,
   1084                              CPU_TS   ts)
   1085          {
   \                     OS_FlagTaskRdy: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
   1086          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1087            sl_status_t status;
   1088          #endif
   1089          
   1090          #if (OS_CFG_TS_EN == DEF_DISABLED)
   1091            (void)ts;                                                     // Prevent compiler warning for not using 'ts'
   1092          #endif
   1093          
   1094            p_tcb->FlagsRdy = flags_rdy;
   \        0x8   0x67EE             STR      R6,[R5, #+124]
   1095            p_tcb->PendStatus = OS_STATUS_PEND_OK;                        // Clear pend status
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xF885 0x0025      STRB     R0,[R5, #+37]
   1096            p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;                      // Indicate no longer pending
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xF885 0x0024      STRB     R0,[R5, #+36]
   1097          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1098            p_tcb->TS = ts;
   1099          #endif
   1100            switch (p_tcb->TaskState) {
   \       0x16   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD023             BEQ.N    ??OS_FlagTaskRdy_0
   \       0x1E   0x2802             CMP      R0,#+2
   \       0x20   0xD009             BEQ.N    ??OS_FlagTaskRdy_1
   \       0x22   0xD320             BCC.N    ??OS_FlagTaskRdy_0
   \       0x24   0x2804             CMP      R0,#+4
   \       0x26   0xD01E             BEQ.N    ??OS_FlagTaskRdy_0
   \       0x28   0xD305             BCC.N    ??OS_FlagTaskRdy_1
   \       0x2A   0x2806             CMP      R0,#+6
   \       0x2C   0xD017             BEQ.N    ??OS_FlagTaskRdy_2
   \       0x2E   0xD31A             BCC.N    ??OS_FlagTaskRdy_0
   \       0x30   0x2807             CMP      R0,#+7
   \       0x32   0xD014             BEQ.N    ??OS_FlagTaskRdy_2
   \       0x34   0xE018             B.N      ??OS_FlagTaskRdy_3
   1101              case OS_TASK_STATE_PEND:
   1102              case OS_TASK_STATE_PEND_TIMEOUT:
   1103          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1104                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \                     ??OS_FlagTaskRdy_1: (+1)
   \       0x36   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \       0x3A   0x2803             CMP      R0,#+3
   \       0x3C   0xD108             BNE.N    ??OS_FlagTaskRdy_4
   1105                  status = sl_sleeptimer_stop_timer(&p_tcb->TimerHandle);
   \       0x3E   0xF115 0x0044      ADDS     R0,R5,#+68
   \       0x42   0x.... 0x....      BL       sl_sleeptimer_stop_timer
   \       0x46   0x0004             MOVS     R4,R0
   1106                  RTOS_ASSERT_CRITICAL((status == SL_STATUS_OK), RTOS_ERR_FAIL,; );
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD001             BEQ.N    ??OS_FlagTaskRdy_4
   \       0x4C   0x.... 0x....      BL       CPU_SW_Exception
   1107                }
   1108          #endif
   1109                OS_RdyListInsert(p_tcb);                                  // Insert the task in the ready list
   \                     ??OS_FlagTaskRdy_4: (+1)
   \       0x50   0x0028             MOVS     R0,R5
   \       0x52   0x.... 0x....      BL       OS_RdyListInsert
   1110                p_tcb->TaskState = OS_TASK_STATE_RDY;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF885 0x0026      STRB     R0,[R5, #+38]
   1111                break;
   \       0x5C   0xE006             B.N      ??OS_FlagTaskRdy_5
   1112          
   1113              case OS_TASK_STATE_PEND_SUSPENDED:
   1114              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1115                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_FlagTaskRdy_2: (+1)
   \       0x5E   0x2004             MOVS     R0,#+4
   \       0x60   0xF885 0x0026      STRB     R0,[R5, #+38]
   1116                break;
   \       0x64   0xE002             B.N      ??OS_FlagTaskRdy_5
   1117          
   1118              case OS_TASK_STATE_RDY:
   1119              case OS_TASK_STATE_DLY:
   1120              case OS_TASK_STATE_DLY_SUSPENDED:
   1121              case OS_TASK_STATE_SUSPENDED:
   1122                break;
   \                     ??OS_FlagTaskRdy_0: (+1)
   \       0x66   0xE001             B.N      ??OS_FlagTaskRdy_5
   1123          
   1124              case OS_TASK_STATE_DEL:
   1125              default:
   1126                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \                     ??OS_FlagTaskRdy_3: (+1)
   \       0x68   0x.... 0x....      BL       CPU_SW_Exception
   1127            }
   1128            OS_PendListRemove(p_tcb);
   \                     ??OS_FlagTaskRdy_5: (+1)
   \       0x6C   0x0028             MOVS     R0,R5
   \       0x6E   0x.... 0x....      BL       OS_PendListRemove
   1129          }
   \       0x72   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     `OSFlagCreate::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x4741'4C46        DC32     0x47414c46

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x....'....        DC32     `OSFlagDel::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x....'....        DC32     `OSFlagPend::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \        0x0   0x....'....        DC32     `OSFlagPendAbort::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \        0x0   0x....'....        DC32     `OSFlagPendGetFlagsRdy::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \        0x0   0x....'....        DC32     `OSFlagPost::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \        0x0   0x454E'4F4E        DC32     0x454e4f4e

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x6B, 0x65, 0x72, 0x6E, 0x65
   \              0x5C 0x6B    
   \              0x65 0x72    
   \              0x6E 0x65
   \       0x58   0x6C 0x5C          DC8 0x6C, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65
   \       0x60   0x5C 0x6F          DC8 0x5C, 0x6F, 0x73, 0x5F, 0x66, 0x6C, 0x61, 0x67
   \              0x73 0x5F    
   \              0x66 0x6C    
   \              0x61 0x67
   \       0x68   0x2E 0x63          DC8 0x2E, 0x63, 0
   \              0x00
   \       0x6B                      DS8 1
   1130          #endif
   1131          
   1132          /********************************************************************************************************
   1133           ********************************************************************************************************
   1134           *                                   DEPENDENCIES & AVAIL CHECK(S) END
   1135           ********************************************************************************************************
   1136           *******************************************************************************************************/
   1137          
   1138          #endif // (defined(RTOS_MODULE_KERNEL_AVAIL))

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSFlagCreate
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> CORE_InIrqContext
        24   -> CPU_SW_Exception
        24   -> OS_PendListInit
        24   -> __aeabi_memclr4
      40   OSFlagDel
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> CORE_InIrqContext
        40   -> CPU_SW_Exception
        40   -> OSSched
        40   -> OS_FlagClr
        40   -> OS_PendAbort
      48   OSFlagPend
        48   -> CORE_EnterAtomic
        48   -> CORE_ExitAtomic
        48   -> CORE_InIrqContext
        48   -> CORE_IrqIsDisabled
        48   -> CPU_SW_Exception
        48   -> OSSched
        48   -> OS_FlagBlock
      40   OSFlagPendAbort
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> CORE_InIrqContext
        40   -> CPU_SW_Exception
        40   -> OSSched
        40   -> OS_PendAbort
      16   OSFlagPendGetFlagsRdy
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> CORE_InIrqContext
        16   -> CPU_SW_Exception
      56   OSFlagPost
        56   -> CORE_EnterAtomic
        56   -> CORE_ExitAtomic
        56   -> CPU_SW_Exception
        56   -> OSSched
        56   -> OS_FlagTaskRdy
      24   OS_FlagBlock
        24   -> OS_Pend
      16   OS_FlagClr
        16   -> OS_PendListInit
      24   OS_FlagTaskRdy
        24   -> CPU_SW_Exception
        24   -> OS_PendListRemove
        24   -> OS_RdyListInsert
        24   -> sl_sleeptimer_stop_timer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
     108  ?_0
     142  OSFlagCreate
     358  OSFlagDel
   1'106  OSFlagPend
     368  OSFlagPendAbort
     122  OSFlagPendGetFlagsRdy
     446  OSFlagPost
      40  OS_FlagBlock
      22  OS_FlagClr
     116  OS_FlagTaskRdy
     108  -- Other

 
   216 bytes in section .rodata
 2'768 bytes in section .text
 
 2'768 bytes of CODE  memory
   216 bytes of CONST memory

Errors: none
Warnings: none
