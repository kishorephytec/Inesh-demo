###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:00
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_core.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_core.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_core.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_core.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\source_1437350445724322328.dir\os_core.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\source_1437350445724322328.dir\os_core.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\os_core.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Kernel - Core Functions
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          /********************************************************************************************************
     19           ********************************************************************************************************
     20           *                                       DEPENDENCIES & AVAIL CHECK(S)
     21           ********************************************************************************************************
     22           *******************************************************************************************************/
     23          
     24          #include  <rtos_description.h>
     25          
     26          #if (defined(RTOS_MODULE_KERNEL_AVAIL))
     27          
     28          /********************************************************************************************************
     29           ********************************************************************************************************
     30           *                                               INCLUDE FILES
     31           ********************************************************************************************************
     32           *******************************************************************************************************/
     33          
     34          #define  MICRIUM_SOURCE
     35          #include  "../include/os.h"
     36          #include  "os_priv.h"
     37          
     38          #include  <em_core.h>
     39          
     40          #if ((OS_CFG_TICK_EN == DEF_ENABLED) || (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED))
     41          #include  <sl_sleeptimer.h>
     42          #endif
     43          
     44          #include  <common/include/rtos_prio.h>
     45          #include  <common/include/toolchains.h>
     46          
     47          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     48          const CPU_CHAR *os_core__c = "$Id: $";
     49          #endif
     50          
     51          /********************************************************************************************************
     52           ********************************************************************************************************
     53           *                                               LOCAL DEFINES
     54           ********************************************************************************************************
     55           *******************************************************************************************************/
     56          
     57          #define  DEF_INT_OS_TICK_MAX_VAL                (UINT64_C(0x100000000))
     58          
     59          /********************************************************************************************************
     60           *                                       DEFAULT RUNTIME CONFIGURATION
     61           *******************************************************************************************************/
     62          
     63          // Default Stacks, Pool Size, Stack Limit and Tasks.
     64          #define  OS_INIT_CFG_DFLT                   { \
     65              .ISR =                                    \
     66              {                                         \
     67                .StkBasePtr = DEF_NULL,                 \
     68                .StkSize = 256u                         \
     69              },                                        \
     70              .MsgPoolSize = 100u,                      \
     71              .TaskStkLimit = 10u,                      \
     72              .StatTaskCfg =                            \
     73              {                                         \
     74                .StkBasePtr = DEF_NULL,                 \
     75                .StkSize = 256u,                        \
     76                .Prio = KERNEL_STAT_TASK_PRIO_DFLT,     \
     77                .RateHz = 10u                           \
     78              },                                        \
     79              .TmrTaskCfg =                             \
     80              {                                         \
     81                .StkBasePtr = DEF_NULL,                 \
     82                .StkSize = 256u,                        \
     83                .Prio = KERNEL_TMR_TASK_PRIO_DFLT,      \
     84                .RateHz = 10u                           \
     85              },                                        \
     86              .MemSeg = DEF_NULL,                       \
     87              .TickRate = 1000u                         \
     88          }
     89          
     90          /********************************************************************************************************
     91           ********************************************************************************************************
     92           *                                       LOCAL GLOBAL VARIABLES
     93           ********************************************************************************************************
     94           *******************************************************************************************************/
     95          
     96          #ifndef  OS_CFG_COMPAT_INIT
     97          #if (RTOS_CFG_EXTERNALIZE_OPTIONAL_CFG_EN == DEF_DISABLED)
     98          // Kernel configuration.

   \                                 In section .rodata, align 4
     99          const OS_INIT_CFG  OS_InitCfgDflt = OS_INIT_CFG_DFLT;
   \                     OS_InitCfgDflt:
   \        0x0   0x0000'0000        DC32 0x0, 256
   \              0x0000'0100
   \        0x8   0x0064             DC16 100
   \        0xA                      DS8 2
   \        0xC   0x0000'000A        DC32 10, 0x0, 256
   \              0x0000'0000  
   \              0x0000'0100
   \       0x18   0x06               DC8 6
   \       0x19                      DS8 3
   \       0x1C   0x0000'000A        DC32 10, 0x0, 256
   \              0x0000'0000  
   \              0x0000'0100
   \       0x28   0x05               DC8 5
   \       0x29                      DS8 3
   \       0x2C   0x0000'000A        DC32 10, 0x0, 1'000
   \              0x0000'0000  
   \              0x0000'03E8

   \                                 In section .data, align 4
    100          static OS_INIT_CFG OS_InitCfg = OS_INIT_CFG_DFLT;
   \                     OS_InitCfg:
   \        0x0   0x0000'0000        DC32 0x0, 256
   \              0x0000'0100
   \        0x8   0x0064             DC16 100
   \        0xA                      DS8 2
   \        0xC   0x0000'000A        DC32 10, 0x0, 256
   \              0x0000'0000  
   \              0x0000'0100
   \       0x18   0x06               DC8 6
   \       0x19                      DS8 3
   \       0x1C   0x0000'000A        DC32 10, 0x0, 256
   \              0x0000'0000  
   \              0x0000'0100
   \       0x28   0x05               DC8 5
   \       0x29                      DS8 3
   \       0x2C   0x0000'000A        DC32 10, 0x0, 1'000
   \              0x0000'0000  
   \              0x0000'03E8
    101          #else
    102          // Kernel configuration.
    103          extern const OS_INIT_CFG OS_InitCfg;
    104          #endif
    105          #endif
    106          
    107          #if  (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    108          sl_sleeptimer_timer_handle_t OSRoundRobinTimer;
    109          OS_TCB                       *OSRoundRobinCurTCB;
    110          #endif
    111          
    112          #if (OS_CFG_TICK_EN == DEF_ENABLED)

   \                                 In section .bss, align 4
    113          CPU_INT32U OSDelayMaxMilli = 0u;
   \                     OSDelayMaxMilli:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    114          OS_TICK OSDelayMaxTick = 0u;
   \                     OSDelayMaxTick:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    115          CPU_INT32U OS_SleeptimerFrequency_Hz = 0u;
   \                     OS_SleeptimerFrequency_Hz:
   \        0x0                      DS8 4
    116          #endif
    117          
    118          #if (OS_CFG_ERRNO_EN == 1)
    119          // Errno Variable

   \                                 In section .bss, align 4
    120          int micriumos_errno;
   \                     micriumos_errno:
   \        0x0                      DS8 4
    121          #endif
    122          
    123          /*
    124           *********************************************************************************************************
    125           *                                        HOOK WEAK REFERENCES
    126           *********************************************************************************************************
    127           */
    128          
    129          /*****************************************************************************************************//**
    130           *                                               OSIdleEnterHook()
    131           *
    132           * @brief    Allows performing other operations during an Idle enter.
    133           *
    134           * @note     (1) Allow the MCU to be put in sleep mode.
    135           *******************************************************************************************************/
    136          __WEAK void OSIdleEnterHook(void);
    137          
    138          /*****************************************************************************************************//**
    139           *                                               OSIdleExitHook()
    140           *
    141           * @brief    Allows performing other operations during an Idle exit.
    142           *******************************************************************************************************/
    143          __WEAK void OSIdleExitHook(void);
    144          
    145          /********************************************************************************************************
    146           ********************************************************************************************************
    147           *                                           GLOBAL FUNCTIONS
    148           ********************************************************************************************************
    149           *******************************************************************************************************/
    150          
    151          /****************************************************************************************************//**
    152           *                                           OS_ConfigureISRStk()
    153           *
    154           * @brief    Configure the stack used for ISRs, if available.
    155           *
    156           * @param    p_stk_base_ptr  Pointer to the base of the buffer used as the stack.
    157           *
    158           * @param    stk_size        Size of the stack, in CPU_STK elements.
    159           *
    160           * @note     (1) This function is optional. If it is called, it must be called before OSInit().
    161           *               If it is not called, default values will be used.
    162           *******************************************************************************************************/
    163          #if (!defined(OS_CFG_COMPAT_INIT) \
    164            && (RTOS_CFG_EXTERNALIZE_OPTIONAL_CFG_EN == DEF_DISABLED))

   \                                 In section .text, align 2, keep-with-next
    165          void OS_ConfigureISRStk(CPU_STK      *p_stk_base_ptr,
    166                                  CPU_STK_SIZE stk_size)
    167          {
   \                     OS_ConfigureISRStk: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    168            RTOS_ASSERT_CRITICAL((OSInitialized == DEF_FALSE), RTOS_ERR_ALREADY_INIT,; );
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable17
   \        0xA   0x7800             LDRB     R0,[R0, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD001             BEQ.N    ??OS_ConfigureISRStk_0
   \       0x10   0x.... 0x....      BL       CPU_SW_Exception
    169          
    170            OS_InitCfg.ISR.StkBasePtr = p_stk_base_ptr;
   \                     ??OS_ConfigureISRStk_0: (+1)
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x18   0x6004             STR      R4,[R0, #+0]
    171            OS_InitCfg.ISR.StkSize = stk_size;
   \       0x1A   0x6045             STR      R5,[R0, #+4]
    172          }
   \       0x1C   0xBD31             POP      {R0,R4,R5,PC}
    173          #endif
    174          
    175          /****************************************************************************************************//**
    176           *                                           OS_ConfigureMemSeg()
    177           *
    178           * @brief    Configure the memory segment used by the Kernel.
    179           *
    180           * @param    p_mem_seg   Pointer to the memory segment in which the kernel data will be allocated.
    181           *
    182           * @note     (1) This function is optional. If it is called, it must be called before OSInit().
    183           *               If it is not called, default values will be used.
    184           *******************************************************************************************************/
    185          #if (!defined(OS_CFG_COMPAT_INIT) \
    186            && (RTOS_CFG_EXTERNALIZE_OPTIONAL_CFG_EN == DEF_DISABLED))

   \                                 In section .text, align 2, keep-with-next
    187          void OS_ConfigureMemSeg(MEM_SEG *p_mem_seg)
    188          {
   \                     OS_ConfigureMemSeg: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    189            RTOS_ASSERT_CRITICAL((OSInitialized == DEF_FALSE), RTOS_ERR_ALREADY_INIT,; );
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable17
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??OS_ConfigureMemSeg_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    190          
    191            OS_InitCfg.MemSeg = p_mem_seg;
   \                     ??OS_ConfigureMemSeg_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x16   0x6304             STR      R4,[R0, #+48]
    192          }
   \       0x18   0xBD10             POP      {R4,PC}
    193          #endif
    194          
    195          /****************************************************************************************************//**
    196           *                                           OS_ConfigureMsgPoolSize()
    197           *
    198           * @brief    Configure the Kernel message pool size.
    199           *
    200           * @param    msg_pool_size   Number of messages the kernel will manage. Shared between task message
    201           *                           queues and regular message queues.
    202           *
    203           * @note     (1) This function is optional. If it is called, it must be called before OSInit().
    204           *               If it is not called, default values will be used.
    205           *******************************************************************************************************/
    206          #if (!defined(OS_CFG_COMPAT_INIT) \
    207            && (RTOS_CFG_EXTERNALIZE_OPTIONAL_CFG_EN == DEF_DISABLED))

   \                                 In section .text, align 2, keep-with-next
    208          void OS_ConfigureMsgPoolSize(OS_MSG_SIZE msg_pool_size)
    209          {
   \                     OS_ConfigureMsgPoolSize: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    210            RTOS_ASSERT_CRITICAL((OSInitialized == DEF_FALSE), RTOS_ERR_ALREADY_INIT,; );
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable17
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??OS_ConfigureMsgPoolSize_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    211          
    212            OS_InitCfg.MsgPoolSize = msg_pool_size;
   \                     ??OS_ConfigureMsgPoolSize_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x16   0x8104             STRH     R4,[R0, #+8]
    213          }
   \       0x18   0xBD10             POP      {R4,PC}
    214          #endif
    215          
    216          /****************************************************************************************************//**
    217           *                                           OS_ConfigureStkLimit()
    218           *
    219           * @brief    Configure the application stack limit.
    220           *
    221           * @param    task_stk_limit  Stack limit in percentage to empty.
    222           *
    223           * @note     (1) This function is optional. If it is called, it must be called before OSInit().
    224           *               If it is not called, default values will be used.
    225           *******************************************************************************************************/
    226          #if (!defined(OS_CFG_COMPAT_INIT) \
    227            && (RTOS_CFG_EXTERNALIZE_OPTIONAL_CFG_EN == DEF_DISABLED))

   \                                 In section .text, align 2, keep-with-next
    228          void OS_ConfigureStkLimit(CPU_STK_SIZE task_stk_limit)
    229          {
   \                     OS_ConfigureStkLimit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    230            RTOS_ASSERT_CRITICAL((OSInitialized == DEF_FALSE), RTOS_ERR_ALREADY_INIT,; );
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable17
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??OS_ConfigureStkLimit_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    231          
    232            OS_InitCfg.TaskStkLimit = task_stk_limit;
   \                     ??OS_ConfigureStkLimit_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x16   0x60C4             STR      R4,[R0, #+12]
    233          }
   \       0x18   0xBD10             POP      {R4,PC}
    234          #endif
    235          
    236          /*****************************************************************************************************//**
    237           *                                           OS_ConfigureStatTask()
    238           *
    239           * @brief    If enabled, configure the Statistics Task.
    240           *
    241           * @param    p_stat_task_cfg     Pointer to the Statistics Task configuration.
    242           *
    243           * @note     (1) This function is optional. If it is called, it must be called before OSInit().
    244           *               If it is not called, default values will be used.
    245           *******************************************************************************************************/
    246          #if (!defined(OS_CFG_COMPAT_INIT)                           \
    247            && (RTOS_CFG_EXTERNALIZE_OPTIONAL_CFG_EN == DEF_DISABLED) \
    248            && (OS_CFG_STAT_TASK_EN == DEF_ENABLED))
    249          void OS_ConfigureStatTask(OS_TASK_CFG *p_stat_task_cfg)
    250          {
    251            RTOS_ASSERT_CRITICAL((OSInitialized == DEF_FALSE), RTOS_ERR_ALREADY_INIT,; );
    252          
    253            OS_ASSERT_DBG_NO_ERR((p_stat_task_cfg != DEF_NULL), RTOS_ERR_NULL_PTR,; );
    254          
    255            OS_InitCfg.StatTaskCfg = *p_stat_task_cfg;
    256          }
    257          #endif
    258          
    259          /*****************************************************************************************************//**
    260           *                                           OS_ConfigureTmrTask()
    261           *
    262           * @brief    If enabled, configure the Timer Management Task.
    263           *
    264           * @param    p_tmr_task_cfg  Pointer to the Timer Management Task configuration.
    265           *
    266           * @note     (1) This function is optional. If it is called, it must be called before OSInit().
    267           *               If it is not called, default values will be used.
    268           *******************************************************************************************************/
    269          #if (!defined(OS_CFG_COMPAT_INIT)                           \
    270            && (RTOS_CFG_EXTERNALIZE_OPTIONAL_CFG_EN == DEF_DISABLED) \
    271            && (OS_CFG_TMR_EN == DEF_ENABLED))
    272          void OS_ConfigureTmrTask(OS_TASK_CFG *p_tmr_task_cfg)
    273          {
    274            RTOS_ASSERT_CRITICAL((OSInitialized == DEF_FALSE), RTOS_ERR_ALREADY_INIT,; );
    275          
    276            OS_ASSERT_DBG_NO_ERR((p_tmr_task_cfg != DEF_NULL), RTOS_ERR_NULL_PTR,; );
    277          
    278            OS_InitCfg.TmrTaskCfg = *p_tmr_task_cfg;
    279          }
    280          #endif
    281          
    282          /*****************************************************************************************************//**
    283           *                                          OS_ConfigureTickRate()
    284           *
    285           * @brief    If enabled, configure the OS tick rate.
    286           *
    287           * @param    tick_rate  Tick rate, in hertz.
    288           *
    289           * @note     (1) This function is optional. If it is called, it must be called before OSInit().
    290           *               If it is not called, default values will be used.
    291           *******************************************************************************************************/
    292          #if (!defined(OS_CFG_COMPAT_INIT)                           \
    293            && (RTOS_CFG_EXTERNALIZE_OPTIONAL_CFG_EN == DEF_DISABLED) \
    294            && (OS_CFG_TICK_EN == DEF_ENABLED)) // TODO re-add compat

   \                                 In section .text, align 2, keep-with-next
    295          void OS_ConfigureTickRate(OS_RATE_HZ tick_rate)
    296          {
   \                     OS_ConfigureTickRate: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    297            RTOS_ASSERT_CRITICAL((OSInitialized == DEF_FALSE), RTOS_ERR_ALREADY_INIT,; );
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable17
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??OS_ConfigureTickRate_0
   \        0xE   0x.... 0x....      BL       CPU_SW_Exception
    298          
    299            OS_ASSERT_DBG_NO_ERR((tick_rate != 0), RTOS_ERR_INVALID_ARG,; );
   \                     ??OS_ConfigureTickRate_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD100             BNE.N    ??OS_ConfigureTickRate_1
   \                     ??OS_ConfigureTickRate_2: (+1)
   \       0x16   0xE7FE             B.N      ??OS_ConfigureTickRate_2
    300          
    301            OS_InitCfg.TickRate = tick_rate;
   \                     ??OS_ConfigureTickRate_1: (+1)
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x1C   0x6344             STR      R4,[R0, #+52]
    302          }
   \       0x1E   0xBD10             POP      {R4,PC}
    303          #endif
    304          
    305          /****************************************************************************************************//**
    306           *                                                   OSInit()
    307           *
    308           * @brief    Initializes the internals of the Kernel and MUST be called before creating any Kernel
    309           *           object and before calling OSStart().
    310           *
    311           * @param    p_err   Pointer to the variable that will receive one of the following error
    312           *                   code(s) from this function:
    313           *                       - RTOS_ERR_NONE
    314           *                       - RTOS_ERR_OS_ILLEGAL_RUN_TIME
    315           *                       - RTOS_ERR_SEG_OVF
    316           *                       - RTOS_ERR_INVALID_CFG
    317           *
    318           * @note     (1) This function MUST be called AFTER Common's Mem_Init().
    319           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    320          void OSInit(RTOS_ERR *p_err)
    321          {
   \                     OSInit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
    322          #ifdef  OS_CFG_COMPAT_INIT
    323          #if (OS_CFG_ISR_STK_SIZE > 0u)
    324            CPU_STK      *p_stk;
    325            CPU_STK_SIZE size;
    326          #endif
    327          #else
    328            CPU_STK      *p_stk;
    329            CPU_STK_SIZE size;
    330          #endif
    331          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    332            sl_status_t status;
    333          #endif
    334          
    335            //                                                               Validate 'p_err'
    336            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD101             BNE.N    ??OSInit_0
   \        0xA   0x.... 0x....      BL       CPU_SW_Exception
    337          
    338            //                                                               Allocate Objects and Stacks.
    339          #ifndef OS_CFG_COMPAT_INIT
    340            //                                                               Allocate ISR Stack.
    341            if (OS_InitCfg.ISR.StkSize > 0u) {
   \                     ??OSInit_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R8,??DataTable17_1
   \       0x12   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD030             BEQ.N    ??OSInit_1
    342              if (OS_InitCfg.ISR.StkBasePtr == DEF_NULL) {
   \       0x1A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD110             BNE.N    ??OSInit_2
    343                OSCfg_ISRStk = (CPU_STK *)Mem_SegAlloc("Kernel's ISR Stack",
    344                                                       OS_InitCfg.MemSeg,
    345                                                       OS_InitCfg.ISR.StkSize * sizeof(CPU_STK),
    346                                                       p_err);
   \       0x22   0x002B             MOVS     R3,R5
   \       0x24   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x28   0x0082             LSLS     R2,R0,#+2
   \       0x2A   0xF8D8 0x1030      LDR      R1,[R8, #+48]
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \       0x32   0x.... 0x....      BL       Mem_SegAlloc
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \       0x3A   0x6008             STR      R0,[R1, #+0]
    347                if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0x3C   0x7828             LDRB     R0,[R5, #+0]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD005             BEQ.N    ??OSInit_3
    348                  return;
   \       0x42   0xE104             B.N      ??OSInit_4
    349                }
    350              } else {
    351                OSCfg_ISRStk = OS_InitCfg.ISR.StkBasePtr;
   \                     ??OSInit_2: (+1)
   \       0x44   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \       0x4C   0x6001             STR      R1,[R0, #+0]
    352              }
    353          
    354              OSCfg_ISRStkBasePtr = OSCfg_ISRStk;
   \                     ??OSInit_3: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \       0x52   0x6801             LDR      R1,[R0, #+0]
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \       0x58   0x6001             STR      R1,[R0, #+0]
    355              OSCfg_ISRStkSize = OS_InitCfg.ISR.StkSize;
   \       0x5A   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \       0x62   0x6001             STR      R1,[R0, #+0]
    356              OSCfg_ISRStkSizeRAM = OS_InitCfg.ISR.StkSize * sizeof(CPU_STK);
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \       0x68   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \       0x6C   0x0089             LSLS     R1,R1,#+2
   \       0x6E   0x6001             STR      R1,[R0, #+0]
    357              OSCfg_DataSizeRAM += OSCfg_ISRStkSizeRAM;
   \       0x70   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \       0x74   0x680A             LDR      R2,[R1, #+0]
   \       0x76   0x6800             LDR      R0,[R0, #+0]
   \       0x78   0x1882             ADDS     R2,R0,R2
   \       0x7A   0x600A             STR      R2,[R1, #+0]
    358            }
    359          
    360          #if (OS_MSG_EN == DEF_ENABLED)                                  // Message Queue.
    361          
    362            if (OS_InitCfg.MsgPoolSize > 0u) {
   \                     ??OSInit_1: (+1)
   \       0x7C   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD029             BEQ.N    ??OSInit_5
    363              OSCfg_MsgPool = (OS_MSG *)Mem_SegAlloc("Kernel's Msg Pool",
    364                                                     OS_InitCfg.MemSeg,
    365                                                     OS_InitCfg.MsgPoolSize * sizeof(OS_MSG),
    366                                                     p_err);
   \       0x84   0x270C             MOVS     R7,#+12
   \       0x86   0x.... 0x....      LDR.W    R9,??DataTable17_8
   \       0x8A   0x002B             MOVS     R3,R5
   \       0x8C   0xF8B8 0x2008      LDRH     R2,[R8, #+8]
   \       0x90   0x437A             MULS     R2,R7,R2
   \       0x92   0xF8D8 0x1030      LDR      R1,[R8, #+48]
   \       0x96   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \       0x9A   0x.... 0x....      BL       Mem_SegAlloc
   \       0x9E   0xF8C9 0x0000      STR      R0,[R9, #+0]
    367              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \       0xA2   0x7828             LDRB     R0,[R5, #+0]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xF040 0x80D2      BNE.W    ??OSInit_4
    368                return;
    369              }
    370          
    371              OSCfg_MsgPoolBasePtr = OSCfg_MsgPool;
   \                     ??OSInit_6: (+1)
   \       0xAA   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0xAE   0x.... 0x....      LDR.W    R0,??DataTable17_10
   \       0xB2   0x6001             STR      R1,[R0, #+0]
    372              OSCfg_MsgPoolSize = OS_InitCfg.MsgPoolSize;
   \       0xB4   0xF8B8 0x1008      LDRH     R1,[R8, #+8]
   \       0xB8   0x.... 0x....      LDR.W    R0,??DataTable17_11
   \       0xBC   0x8001             STRH     R1,[R0, #+0]
    373              OSCfg_MsgPoolSizeRAM = OS_InitCfg.MsgPoolSize * sizeof(OS_MSG);
   \       0xBE   0x.... 0x....      LDR.W    R0,??DataTable17_12
   \       0xC2   0xF8B8 0x1008      LDRH     R1,[R8, #+8]
   \       0xC6   0xFB07 0xF701      MUL      R7,R7,R1
   \       0xCA   0x6007             STR      R7,[R0, #+0]
    374              OSCfg_DataSizeRAM += OSCfg_MsgPoolSizeRAM;
   \       0xCC   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \       0xD0   0x680A             LDR      R2,[R1, #+0]
   \       0xD2   0x6800             LDR      R0,[R0, #+0]
   \       0xD4   0x1882             ADDS     R2,R0,R2
   \       0xD6   0x600A             STR      R2,[R1, #+0]
    375            }
    376          #endif
    377          
    378          #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)                        // Statistic Task's Stack.
    379            if (OS_InitCfg.StatTaskCfg.StkSize > 0u) {
    380              if (OS_InitCfg.StatTaskCfg.StkBasePtr == DEF_NULL) {
    381                OSCfg_StatTaskStk = (CPU_STK *)Mem_SegAlloc("Kernel's Stat Task Stack",
    382                                                            OS_InitCfg.MemSeg,
    383                                                            OS_InitCfg.StatTaskCfg.StkSize * sizeof(CPU_STK),
    384                                                            p_err);
    385                if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    386                  return;
    387                }
    388              } else {
    389                OSCfg_StatTaskStk = OS_InitCfg.StatTaskCfg.StkBasePtr;
    390              }
    391          
    392              OSCfg_StatTaskPrio = OS_InitCfg.StatTaskCfg.Prio;
    393              OSCfg_StatTaskRate_Hz = OS_InitCfg.StatTaskCfg.RateHz;
    394              OSCfg_StatTaskStkBasePtr = OSCfg_StatTaskStk;
    395              OSCfg_StatTaskStkLimit = ((OS_InitCfg.StatTaskCfg.StkSize * OS_InitCfg.TaskStkLimit) / 100u);
    396              OSCfg_StatTaskStkSize = OS_InitCfg.StatTaskCfg.StkSize;
    397              OSCfg_StatTaskStkSizeRAM = OS_InitCfg.StatTaskCfg.StkSize * sizeof(CPU_STK);
    398              OSCfg_DataSizeRAM += OSCfg_StatTaskStkSizeRAM;
    399            }
    400          #endif
    401          
    402          #if (OS_CFG_TMR_EN == DEF_ENABLED)                              // Timer Manager Task's Stack.
    403            if (OS_InitCfg.TmrTaskCfg.StkSize > 0u) {
    404              if (OS_InitCfg.TmrTaskCfg.StkBasePtr == DEF_NULL) {
    405                OSCfg_TmrTaskStk = (CPU_STK *)Mem_SegAlloc("Kernel's Timer Task Stack",
    406                                                           OS_InitCfg.MemSeg,
    407                                                           OS_InitCfg.TmrTaskCfg.StkSize * sizeof(CPU_STK),
    408                                                           p_err);
    409                if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    410                  return;
    411                }
    412              } else {
    413                OSCfg_TmrTaskStk = OS_InitCfg.TmrTaskCfg.StkBasePtr;
    414              }
    415          
    416              OSCfg_TmrTaskPrio = OS_InitCfg.TmrTaskCfg.Prio;
    417              OSCfg_TmrTaskStkBasePtr = OSCfg_TmrTaskStk;
    418              OSCfg_TmrTaskStkLimit = ((OS_InitCfg.TmrTaskCfg.StkSize * OS_InitCfg.TaskStkLimit) / 100u);
    419              OSCfg_TmrTaskStkSize = OS_InitCfg.TmrTaskCfg.StkSize;
    420              OSCfg_TmrTaskStkSizeRAM = OS_InitCfg.TmrTaskCfg.StkSize * sizeof(CPU_STK);
    421              OSCfg_TmrTaskRate_Hz = OS_InitCfg.TmrTaskCfg.RateHz;
    422              OSCfg_DataSizeRAM += OSCfg_TmrTaskStkSizeRAM;
    423            }
    424          #endif
    425          
    426          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    427            OSCfg_TickRate_Hz = OS_InitCfg.TickRate;
   \                     ??OSInit_5: (+1)
   \       0xD8   0x.... 0x....      LDR.W    R7,??DataTable17_13
   \       0xDC   0xF8D8 0x0034      LDR      R0,[R8, #+52]
   \       0xE0   0x6038             STR      R0,[R7, #+0]
    428          #endif
    429          #endif
    430          
    431            OSInitHook();                                                 // Call port specific initialization code
   \       0xE2   0x.... 0x....      BL       OSInitHook
    432          
    433          #if (OS_CFG_TICK_EN == DEF_ENABLED)
    434            status = sl_sleeptimer_init();
   \       0xE6   0x.... 0x....      BL       sl_sleeptimer_init
   \       0xEA   0x4680             MOV      R8,R0
    435            if (status != SL_STATUS_OK) {
   \       0xEC   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xF0   0xD00B             BEQ.N    ??OSInit_7
    436              RTOS_ERR_SET(*p_err, RTOS_ERR_FAIL);
   \       0xF2   0x2001             MOVS     R0,#+1
   \       0xF4   0x7028             STRB     R0,[R5, #+0]
   \       0xF6   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0xFA   0x6068             STR      R0,[R5, #+4]
   \       0xFC   0xF44F 0x70DA      MOV      R0,#+436
   \      0x100   0x60A8             STR      R0,[R5, #+8]
   \      0x102   0x.... 0x....      LDR.W    R0,??DataTable17_15
   \      0x106   0x60E8             STR      R0,[R5, #+12]
    437              return;
   \      0x108   0xE0A1             B.N      ??OSInit_4
    438            }
    439          
    440            OS_SleeptimerFrequency_Hz = (CPU_INT32U)sl_sleeptimer_get_timer_frequency();
   \                     ??OSInit_7: (+1)
   \      0x10A   0x.... 0x....      LDR.W    R9,??DataTable17_16
   \      0x10E   0x.... 0x....      BL       sl_sleeptimer_get_timer_frequency
   \      0x112   0xF8C9 0x0000      STR      R0,[R9, #+0]
    441          
    442            OS_ASSERT_DBG_ERR_SET((OSCfg_TickRate_Hz <= OS_SleeptimerFrequency_Hz), *p_err, RTOS_ERR_INVALID_CFG,; )
   \      0x116   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x11A   0x6839             LDR      R1,[R7, #+0]
   \      0x11C   0x4288             CMP      R0,R1
   \      0x11E   0xD20B             BCS.N    ??OSInit_8
   \      0x120   0x2009             MOVS     R0,#+9
   \      0x122   0x7028             STRB     R0,[R5, #+0]
   \      0x124   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \      0x128   0x6068             STR      R0,[R5, #+4]
   \      0x12A   0xF44F 0x70DD      MOV      R0,#+442
   \      0x12E   0x60A8             STR      R0,[R5, #+8]
   \      0x130   0x.... 0x....      LDR.W    R0,??DataTable17_15
   \      0x134   0x60E8             STR      R0,[R5, #+12]
   \                     ??OSInit_9: (+1)
   \      0x136   0xE7FE             B.N      ??OSInit_9
    443          
    444            if (OSCfg_TickRate_Hz == OS_SleeptimerFrequency_Hz) {
   \                     ??OSInit_8: (+1)
   \      0x138   0x6839             LDR      R1,[R7, #+0]
   \      0x13A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x13E   0x4281             CMP      R1,R0
   \      0x140   0xD104             BNE.N    ??OSInit_10
    445              OSDelayMaxTick =  0u;                                       // There is no limit for delay ticks
   \      0x142   0x2100             MOVS     R1,#+0
   \      0x144   0x.... 0x....      LDR.W    R0,??DataTable17_17
   \      0x148   0x6001             STR      R1,[R0, #+0]
   \      0x14A   0xE00B             B.N      ??OSInit_11
    446            } else {
    447              OSDelayMaxTick = (DEF_INT_OS_TICK_MAX_VAL / OS_SleeptimerFrequency_Hz) * OSCfg_TickRate_Hz;
   \                     ??OSInit_10: (+1)
   \      0x14C   0x2000             MOVS     R0,#+0
   \      0x14E   0x2101             MOVS     R1,#+1
   \      0x150   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \      0x154   0x2300             MOVS     R3,#+0
   \      0x156   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x15A   0x6839             LDR      R1,[R7, #+0]
   \      0x15C   0x4348             MULS     R0,R1,R0
   \      0x15E   0x.... 0x....      LDR.W    R1,??DataTable17_17
   \      0x162   0x6008             STR      R0,[R1, #+0]
    448            }
    449          
    450            if (OSCfg_TickRate_Hz <= 1000u) {
   \                     ??OSInit_11: (+1)
   \      0x164   0x6839             LDR      R1,[R7, #+0]
   \      0x166   0xF240 0x30E9      MOVW     R0,#+1001
   \      0x16A   0x4281             CMP      R1,R0
   \      0x16C   0xD204             BCS.N    ??OSInit_12
    451              OSDelayMaxMilli =  0u;                                      // There is no limit for delay milliseconds
   \      0x16E   0x2000             MOVS     R0,#+0
   \      0x170   0x.... 0x....      LDR.W    R1,??DataTable17_18
   \      0x174   0x6008             STR      R0,[R1, #+0]
   \      0x176   0xE00B             B.N      ??OSInit_13
    452            } else {
    453              OSDelayMaxMilli = (DEF_INT_OS_TICK_MAX_VAL / OSCfg_TickRate_Hz) * 1000u;
   \                     ??OSInit_12: (+1)
   \      0x178   0x2000             MOVS     R0,#+0
   \      0x17A   0x2101             MOVS     R1,#+1
   \      0x17C   0x683A             LDR      R2,[R7, #+0]
   \      0x17E   0x2300             MOVS     R3,#+0
   \      0x180   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x184   0xF44F 0x717A      MOV      R1,#+1000
   \      0x188   0x4348             MULS     R0,R1,R0
   \      0x18A   0x.... 0x....      LDR.W    R1,??DataTable17_18
   \      0x18E   0x6008             STR      R0,[R1, #+0]
    454            }
    455          #endif
    456          
    457            OSRunning = OS_STATE_OS_STOPPED;                              // Indicate that multitasking not started
   \                     ??OSInit_13: (+1)
   \      0x190   0x2000             MOVS     R0,#+0
   \      0x192   0x.... 0x....      LDR.W    R1,??DataTable17_19
   \      0x196   0x7008             STRB     R0,[R1, #+0]
    458          
    459            OSSchedLockNestingCtr = 0u;                                   // Clear the scheduling lock counter
   \      0x198   0x2000             MOVS     R0,#+0
   \      0x19A   0x.... 0x....      LDR.W    R1,??DataTable17_20
   \      0x19E   0x7008             STRB     R0,[R1, #+0]
    460          
    461            OSTCBCurPtr = DEF_NULL;                                       // Initialize OS_TCB pointers to a known state
   \      0x1A0   0x2000             MOVS     R0,#+0
   \      0x1A2   0x.... 0x....      LDR.W    R1,??DataTable17_21
   \      0x1A6   0x6008             STR      R0,[R1, #+0]
    462            OSTCBHighRdyPtr = DEF_NULL;
   \      0x1A8   0x2000             MOVS     R0,#+0
   \      0x1AA   0x.... 0x....      LDR.W    R1,??DataTable17_22
   \      0x1AE   0x6008             STR      R0,[R1, #+0]
    463          
    464            OSPrioCur = 0u;                                               // Initialize priority variables to a known state
   \      0x1B0   0x2100             MOVS     R1,#+0
   \      0x1B2   0x.... 0x....      LDR.W    R0,??DataTable17_23
   \      0x1B6   0x7001             STRB     R1,[R0, #+0]
    465            OSPrioHighRdy = 0u;
   \      0x1B8   0x2000             MOVS     R0,#+0
   \      0x1BA   0x.... 0x....      LDR.W    R1,??DataTable17_24
   \      0x1BE   0x7008             STRB     R0,[R1, #+0]
    466          
    467          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
    468            OSSchedLockTimeBegin = 0u;
    469            OSSchedLockTimeMax = 0u;
    470            OSSchedLockTimeMaxCur = 0u;
    471          #endif
    472          
    473          #ifdef OS_SAFETY_CRITICAL_IEC61508
    474            OSSafetyCriticalStartFlag = DEF_FALSE;
    475          #endif
    476          
    477          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    478            OSSchedRoundRobinEn = DEF_FALSE;
    479            OSSchedRoundRobinDfltTimeQuanta = OSTimeTickRateHzGet(p_err) / 10u;
    480            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    481              return;
    482            }
    483          #endif
    484          
    485            //                                                               Clear exception stack for stack checking.
    486          #ifdef  OS_CFG_COMPAT_INIT
    487          #if (OS_CFG_ISR_STK_SIZE > 0u)
    488            p_stk = OSCfg_ISRStkBasePtr;
    489            if (p_stk != DEF_NULL) {
    490              size = OSCfg_ISRStkSize;
    491              while (size > 0u) {
    492                size--;
    493                *p_stk = 0u;
    494                p_stk++;
    495              }
    496          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)                 // Initialize Redzoned ISR stack
    497              OS_TaskStkRedzoneInit(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
    498          #endif
    499            }
    500          #endif
    501          #else
    502            if (OSCfg_ISRStkSize > 0u) {
   \      0x1C0   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \      0x1C4   0x6808             LDR      R0,[R1, #+0]
   \      0x1C6   0x2800             CMP      R0,#+0
   \      0x1C8   0xD00E             BEQ.N    ??OSInit_14
    503              p_stk = OSCfg_ISRStkBasePtr;
   \      0x1CA   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \      0x1CE   0x6800             LDR      R0,[R0, #+0]
   \      0x1D0   0x0006             MOVS     R6,R0
    504              if (p_stk != DEF_NULL) {
   \      0x1D2   0x2E00             CMP      R6,#+0
   \      0x1D4   0xD008             BEQ.N    ??OSInit_14
    505                size = OSCfg_ISRStkSize;
   \      0x1D6   0x6808             LDR      R0,[R1, #+0]
   \      0x1D8   0x0004             MOVS     R4,R0
    506                while (size > 0u) {
   \                     ??OSInit_15: (+1)
   \      0x1DA   0x2C00             CMP      R4,#+0
   \      0x1DC   0xD004             BEQ.N    ??OSInit_14
    507                  size--;
   \      0x1DE   0x1E64             SUBS     R4,R4,#+1
    508                  *p_stk = 0u;
   \      0x1E0   0x2000             MOVS     R0,#+0
   \      0x1E2   0x6030             STR      R0,[R6, #+0]
    509                  p_stk++;
   \      0x1E4   0x1D36             ADDS     R6,R6,#+4
   \      0x1E6   0xE7F8             B.N      ??OSInit_15
    510                }
    511          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)                 // Initialize Redzoned ISR stack
    512                OS_TaskStkRedzoneInit(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
    513          #endif
    514              }
    515            }
    516          #endif
    517          
    518          #if (OS_CFG_APP_HOOKS_EN == DEF_ENABLED)                        // Clear application hook pointers
    519          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    520            OS_AppRedzoneHitHookPtr = DEF_NULL;
    521          #endif
    522            OS_AppTaskCreateHookPtr = DEF_NULL;
   \                     ??OSInit_14: (+1)
   \      0x1E8   0x2000             MOVS     R0,#+0
   \      0x1EA   0x.... 0x....      LDR.W    R1,??DataTable17_25
   \      0x1EE   0x6008             STR      R0,[R1, #+0]
    523            OS_AppTaskDelHookPtr = DEF_NULL;
   \      0x1F0   0x2000             MOVS     R0,#+0
   \      0x1F2   0x.... 0x....      LDR.W    R1,??DataTable17_26
   \      0x1F6   0x6008             STR      R0,[R1, #+0]
    524            OS_AppTaskReturnHookPtr = DEF_NULL;
   \      0x1F8   0x2000             MOVS     R0,#+0
   \      0x1FA   0x.... 0x....      LDR.W    R1,??DataTable17_27
   \      0x1FE   0x6008             STR      R0,[R1, #+0]
    525          
    526            OS_AppStatTaskHookPtr = DEF_NULL;
   \      0x200   0x2100             MOVS     R1,#+0
   \      0x202   0x.... 0x....      LDR.W    R0,??DataTable17_28
   \      0x206   0x6001             STR      R1,[R0, #+0]
    527            OS_AppTaskSwHookPtr = DEF_NULL;
   \      0x208   0x2100             MOVS     R1,#+0
   \      0x20A   0x.... 0x....      LDR.W    R0,??DataTable17_29
   \      0x20E   0x6001             STR      R1,[R0, #+0]
    528          #endif
    529          
    530          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    531            OSTaskRegNextAvailID = 0u;
   \      0x210   0x2100             MOVS     R1,#+0
   \      0x212   0x.... 0x....      LDR.W    R0,??DataTable17_30
   \      0x216   0x7001             STRB     R1,[R0, #+0]
    532          #endif
    533          
    534            OS_PrioInit();                                                // Initialize the priority bitmap table
   \      0x218   0x.... 0x....      BL       OS_PrioInit
    535          
    536            OS_RdyListInit();                                             // Initialize the Ready List
   \      0x21C   0x.... 0x....      BL       OS_RdyListInit
    537          
    538          #if (OS_CFG_FLAG_EN == DEF_ENABLED)                             // Initialize the Event Flag module
    539          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    540            OSFlagDbgListPtr = DEF_NULL;
    541            OSFlagQty = 0u;
    542          #endif
    543          #endif
    544          
    545          #if (OS_MSG_EN == DEF_ENABLED)                                  // Initialize the free list of OS_MSGs
    546            if (OSCfg_MsgPoolSize > 0u) {
   \      0x220   0x.... 0x....      LDR.W    R0,??DataTable17_11
   \      0x224   0x8800             LDRH     R0,[R0, #+0]
   \      0x226   0x2800             CMP      R0,#+0
   \      0x228   0xD005             BEQ.N    ??OSInit_16
    547              OS_MsgPoolInit(p_err);
   \      0x22A   0x0028             MOVS     R0,R5
   \      0x22C   0x.... 0x....      BL       OS_MsgPoolInit
    548              if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \      0x230   0x7828             LDRB     R0,[R5, #+0]
   \      0x232   0x2800             CMP      R0,#+0
   \      0x234   0xD10B             BNE.N    ??OSInit_4
    549                return;
    550              }
    551            }
    552          #endif
    553          
    554          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)                            // Initialize the Mutex Manager module
    555          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    556            OSMutexDbgListPtr = DEF_NULL;
    557            OSMutexQty = 0u;
    558          #endif
    559          #endif
    560          
    561          #if (OS_CFG_Q_EN == DEF_ENABLED)                                // Initialize the Message Queue Manager module
    562          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    563            OSQDbgListPtr = DEF_NULL;
    564            OSQQty = 0u;
    565          #endif
    566          #endif
    567          
    568          #if (OS_CFG_SEM_EN == DEF_ENABLED)                              // Initialize the Semaphore Manager module
    569          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    570            OSSemDbgListPtr = DEF_NULL;
    571            OSSemQty = 0u;
    572          #endif
    573          #endif
    574          
    575          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    576            OS_TLS_Init(p_err);                                           // Initialize Task Local Storage, before creating tasks
    577            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    578              return;
    579            }
    580          #endif
    581          
    582            OS_TaskInit(p_err);                                           // Initialize the task manager
   \                     ??OSInit_16: (+1)
   \      0x236   0x0028             MOVS     R0,R5
   \      0x238   0x.... 0x....      BL       OS_TaskInit
    583            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
   \      0x23C   0x7828             LDRB     R0,[R5, #+0]
   \      0x23E   0x2800             CMP      R0,#+0
   \      0x240   0xD105             BNE.N    ??OSInit_4
    584              return;
    585            }
    586          
    587          #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)                        // Initialize the Statistic Task
    588            OS_StatTaskInit(p_err);
    589            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    590              return;
    591            }
    592          #endif
    593          
    594          #if (OS_CFG_TMR_EN == DEF_ENABLED)                              // Initialize the Timer Manager module
    595            OS_TmrInit(p_err);
    596            if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    597              return;
    598            }
    599          #endif
    600          
    601          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    602            OS_Dbg_Init();
    603          #endif
    604          
    605            OSCfg_Init();
   \                     ??OSInit_17: (+1)
   \      0x242   0x.... 0x....      BL       OSCfg_Init
    606          
    607            OSInitialized = DEF_TRUE;                                     // Kernel is initialized
   \      0x246   0x2101             MOVS     R1,#+1
   \      0x248   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x24C   0x7001             STRB     R1,[R0, #+0]
    608          }
   \                     ??OSInit_4: (+1)
   \      0x24E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
    609          
    610          /*****************************************************************************************************//**
    611           *                                               OSIntEnter()
    612           *
    613           * @brief    Used in an interrupt service routine (ISR) to trace that you are about to
    614           *           service an interrupt.
    615           *
    616           * @note     (1) You MUST invoke OSIntEnter() and OSIntExit() in pairs. In other words, for every call
    617           *               to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at
    618           *               the end of the ISR.
    619           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    620          void OSIntEnter(void)
    621          {
    622            OS_TRACE_ISR_ENTER();
    623          }
   \                     OSIntEnter: (+1)
   \        0x0   0x4770             BX       LR
    624          
    625          /****************************************************************************************************//**
    626           *                                               OSIntExit()
    627           *
    628           * @brief    Traces that you have completed servicing an ISR.
    629           *
    630           * @note     (1) You MUST invoke OSIntEnter() and OSIntExit() in pairs. In other words, for every call
    631           *               to OSIntEnter() at the beginning of the ISR, you MUST have a call to OSIntExit() at the
    632           *               end of the ISR.
    633           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    634          void OSIntExit(void)
    635          {
    636          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    637            CPU_BOOLEAN stk_status;
    638          
    639            //                                                               Verify ISR Stack
    640          #ifdef  OS_CFG_COMPAT_INIT
    641          #if (OS_CFG_ISR_STK_SIZE > 0u)
    642            stk_status = OS_TaskStkRedzoneChk(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
    643            if (stk_status != DEF_OK) {
    644              OSRedzoneHitHook(DEF_NULL);
    645            }
    646          #endif
    647          #else
    648            if (OSCfg_ISRStkSize > 0u) {
    649              stk_status = OS_TaskStkRedzoneChk(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
    650              if (stk_status != DEF_OK) {
    651                OSRedzoneHitHook(DEF_NULL);
    652              }
    653            }
    654          #endif
    655          #endif
    656          
    657            OS_TRACE_ISR_EXIT();
    658          }
   \                     OSIntExit: (+1)
   \        0x0   0x4770             BX       LR
    659          
    660          /****************************************************************************************************//**
    661           *                                                   OSSched()
    662           *
    663           * @brief    This function is called by other Kernel services to determine whether a new, high
    664           *           priority task has been made ready to run. This function is invoked by TASK level code and
    665           *           is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
    666           *
    667           * @note     (1) Rescheduling is prevented when the scheduler is locked (see OSSchedLock()).
    668           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    669          void OSSched(void)
    670          {
   \                     OSSched: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    671            OS_PRIO prio_prev;
    672          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    673            CPU_BOOLEAN stk_status;
    674          #endif
    675            CORE_DECLARE_IRQ_STATE;
    676            //                                                               Can't schedule when the kernel is stopped.
    677            OS_ASSERT_DBG_NO_ERR((OSRunning == OS_STATE_OS_RUNNING), RTOS_ERR_NOT_READY,; );
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable17_19
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD000             BEQ.N    ??OSSched_0
   \                     ??OSSched_1: (+1)
   \        0xC   0xE7FE             B.N      ??OSSched_1
    678          
    679            if (OSSchedLockNestingCtr > 0u) {                             // Scheduler locked?
   \                     ??OSSched_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable17_20
   \       0x12   0x7800             LDRB     R0,[R0, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD133             BNE.N    ??OSSched_2
    680              return;                                                     // Yes
    681            }
    682          
    683            CORE_ENTER_ATOMIC();
   \                     ??OSSched_3: (+1)
   \       0x18   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x1C   0x0004             MOVS     R4,R0
    684            prio_prev     = OSPrioHighRdy;
   \       0x1E   0x.... 0x....      LDR.W    R5,??DataTable17_24
   \       0x22   0x782E             LDRB     R6,[R5, #+0]
    685            OSPrioHighRdy = OS_PrioGetHighest();                          // Find the highest priority ready
   \       0x24   0x.... 0x....      BL       OS_PrioGetHighest
   \       0x28   0x7028             STRB     R0,[R5, #+0]
    686            if (OSPrioHighRdy != (OS_CFG_PRIO_MAX)) {                     // Are we going to idle?
   \       0x2A   0x7828             LDRB     R0,[R5, #+0]
   \       0x2C   0x2840             CMP      R0,#+64
   \       0x2E   0xD017             BEQ.N    ??OSSched_4
    687              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;         // No ... get highest priority task ready-to-run
   \       0x30   0x.... 0x....      LDR.W    R7,??DataTable17_22
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable17_31
   \       0x38   0x7828             LDRB     R0,[R5, #+0]
   \       0x3A   0xF851 0x0030      LDR      R0,[R1, R0, LSL #+3]
   \       0x3E   0x6038             STR      R0,[R7, #+0]
    688              if (prio_prev == (OS_CFG_PRIO_MAX)) {                       // Were we previously in idle ?
   \       0x40   0x0030             MOVS     R0,R6
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0x2840             CMP      R0,#+64
   \       0x46   0xD101             BNE.N    ??OSSched_5
    689          #if OS_CFG_STAT_TASK_EN > 0u
    690                OS_StatIdleExitNotify();                                  // Yes
    691          #endif
    692                OSIdleExitHook();
   \       0x48   0x.... 0x....      BL       OSIdleExitHook
    693              }
    694          
    695              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                       // Current task still the highest priority?
   \                     ??OSSched_5: (+1)
   \       0x4C   0x6838             LDR      R0,[R7, #+0]
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable17_21
   \       0x52   0x6809             LDR      R1,[R1, #+0]
   \       0x54   0x4288             CMP      R0,R1
   \       0x56   0xD107             BNE.N    ??OSSched_6
    696          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    697                stk_status = OSTaskStkRedzoneChk(DEF_NULL);
    698                if (stk_status != DEF_OK) {
    699                  OSRedzoneHitHook(OSTCBCurPtr);
    700                }
    701          #endif
    702          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    703                if (OSSchedRoundRobinEn) {
    704                  if (OSTCBHighRdyPtr->TimeQuantaCtr == 0u) {
    705                    OS_SchedRoundRobinResetQuanta(OSTCBHighRdyPtr);
    706                  }
    707                  OS_SchedRoundRobinRestartTimer(OSTCBHighRdyPtr);
    708                }
    709          #endif
    710                CORE_EXIT_ATOMIC();
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x.... 0x....      BL       CORE_ExitAtomic
    711                return;
   \       0x5E   0xE00F             B.N      ??OSSched_2
    712              }
    713          
    714          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    715              if ((OSSchedRoundRobinEn)
    716                  && ((OSRoundRobinCurTCB->TimeQuantaCtr != 0u))) {
    717                sl_status_t status;
    718                uint32_t time_remain;
    719                // Check if round robin timer is currently running, if yes store remaining time
    720                status = sl_sleeptimer_get_timer_time_remaining(&OSRoundRobinTimer, &time_remain);
    721                if (status == SL_STATUS_OK) {
    722                  OSRoundRobinCurTCB->TimeQuantaCtr = time_remain;
    723                  sl_sleeptimer_stop_timer(&OSRoundRobinTimer);
    724                }
    725                // Check if round robin timer expire while in scheduler
    726                if (OSRoundRobinCurTCB->TimeQuantaCtr == 0u) {
    727                  // Move current task to tail
    728                  OS_RdyListMoveHeadToTail(&OSRdyList[OSRoundRobinCurTCB->Prio]);
    729                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
    730                }
    731              }
    732          #endif
    733          
    734          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
    735              OSTCBHighRdyPtr->CtxSwCtr++;                                // Inc. # of context switches to this task
    736          #endif
    737            } else {
    738              OSTCBHighRdyPtr = DEF_NULL;
   \                     ??OSSched_4: (+1)
   \       0x60   0x2100             MOVS     R1,#+0
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable17_22
   \       0x66   0x6001             STR      R1,[R0, #+0]
    739          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    740              if (OSSchedRoundRobinEn) {
    741                sl_sleeptimer_stop_timer(&OSRoundRobinTimer);
    742              }
    743          #endif
    744            }
    745          
    746          #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) || (OS_CFG_DBG_EN == DEF_ENABLED))
    747            OSTaskCtxSwCtr++;                                             // Increment context switch counter
    748          #endif
    749          
    750          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    751            OS_TLS_TaskSw();
    752          #endif
    753          
    754            if (OSPrioHighRdy != (OS_CFG_PRIO_MAX)) {
   \                     ??OSSched_6: (+1)
   \       0x68   0x7828             LDRB     R0,[R5, #+0]
   \       0x6A   0x2840             CMP      R0,#+64
   \       0x6C   0xD101             BNE.N    ??OSSched_7
    755          #if OS_CFG_TASK_PROFILE_EN > 0u
    756              if ((OSTCBCurPtr != OSTCBHighRdyPtr)
    757                  && (OSTCBCurPtr != DEF_NULL)) {
    758                OSTCBCurPtr->CyclesDelta = OS_TMR_GET_DIFF(OS_TS_GET(), OSTCBCurPtr->CyclesStart);
    759                OSTCBCurPtr->CyclesTotal += (OS_CYCLES)OSTCBCurPtr->CyclesDelta;
    760              }
    761              OSTCBHighRdyPtr->CyclesStart = OS_TS_GET();
    762          #endif
    763            } else {
    764          #if OS_CFG_STAT_TASK_EN > 0u
    765              OS_StatIdleEnterNotify();
    766          #endif
    767          #if OS_CFG_TASK_PROFILE_EN > 0u
    768              if (OSTCBCurPtr != DEF_NULL) {
    769                OSTCBCurPtr->CyclesStart = OS_TS_GET();
    770              }
    771          #endif
    772              OS_TRACE_ON_IDLE_ENTER();
    773              OSIdleEnterHook();
   \       0x6E   0x.... 0x....      BL       OSIdleEnterHook
    774            }
    775          
    776            OS_TASK_SW();                                                 // Perform a task level context switch
   \                     ??OSSched_7: (+1)
   \       0x72   0x.... 0x....      BL       OSCtxSw
    777            CORE_EXIT_ATOMIC();
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0x.... 0x....      BL       CORE_ExitAtomic
    778          
    779          #ifdef OS_TASK_SW_SYNC
    780            OS_TASK_SW_SYNC();
   \       0x7C   0xF3BF 0x8F6F      ISB      SY
    781          #endif
    782          }
   \                     ??OSSched_2: (+1)
   \       0x80   0xBDF1             POP      {R0,R4-R7,PC}
    783          
    784          /****************************************************************************************************//**
    785           *                                               OSSchedLock()
    786           *
    787           * @brief    Prevents rescheduling from taking place, allowing your application to prevent context
    788           *           switches until you are ready to permit context switching.
    789           *
    790           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    791           *                   from this function:
    792           *                       - RTOS_ERR_NONE
    793           *                       - RTOS_ERR_WOULD_OVF
    794           *                       - RTOS_ERR_NOT_READY
    795           *
    796           * @note     (1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pairs. In other words, for every
    797           *               call to OSSchedLock(), you MUST have a call to OSSchedUnlock().
    798           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    799          void OSSchedLock(RTOS_ERR *p_err)
    800          {
   \                     OSSchedLock: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    801            CORE_DECLARE_IRQ_STATE;
    802          
    803            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??OSSchedLock_0
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
    804          
    805            //                                                               Not allowed to call from an ISR
    806            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSSchedLock_0: (+1)
   \        0xC   0x.... 0x....      BL       CORE_InIrqContext
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD101             BNE.N    ??OSSchedLock_1
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xE000             B.N      ??OSSchedLock_2
   \                     ??OSSchedLock_1: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \                     ??OSSchedLock_2: (+1)
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD10B             BNE.N    ??OSSchedLock_3
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0x7020             STRB     R0,[R4, #+0]
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x28   0x6060             STR      R0,[R4, #+4]
   \       0x2A   0xF240 0x3026      MOVW     R0,#+806
   \       0x2E   0x60A0             STR      R0,[R4, #+8]
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable17_32
   \       0x34   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSSchedLock_4: (+1)
   \       0x36   0xE7FE             B.N      ??OSSchedLock_4
    807          
    808            //                                                               Make sure kernel is running.
    809            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSSchedLock_3: (+1)
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable17_19
   \       0x3C   0x7800             LDRB     R0,[R0, #+0]
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD00B             BEQ.N    ??OSSchedLock_5
    810              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0x7020             STRB     R0,[R4, #+0]
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x4A   0x6060             STR      R0,[R4, #+4]
   \       0x4C   0xF240 0x302A      MOVW     R0,#+810
   \       0x50   0x60A0             STR      R0,[R4, #+8]
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable17_32
   \       0x56   0x60E0             STR      R0,[R4, #+12]
    811              return;
   \       0x58   0xE024             B.N      ??OSSchedLock_6
    812            }
    813          
    814            if (OSSchedLockNestingCtr >= 250u) {                          // Prevent OSSchedLockNestingCtr overflowing
   \                     ??OSSchedLock_5: (+1)
   \       0x5A   0x.... 0x....      LDR.W    R5,??DataTable17_20
   \       0x5E   0x7828             LDRB     R0,[R5, #+0]
   \       0x60   0x28FA             CMP      R0,#+250
   \       0x62   0xD30B             BCC.N    ??OSSchedLock_7
    815              RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_OVF);
   \       0x64   0x201E             MOVS     R0,#+30
   \       0x66   0x7020             STRB     R0,[R4, #+0]
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x6C   0x6060             STR      R0,[R4, #+4]
   \       0x6E   0xF240 0x302F      MOVW     R0,#+815
   \       0x72   0x60A0             STR      R0,[R4, #+8]
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable17_32
   \       0x78   0x60E0             STR      R0,[R4, #+12]
    816              return;
   \       0x7A   0xE013             B.N      ??OSSchedLock_6
    817            }
    818          
    819            CORE_ENTER_ATOMIC();
   \                     ??OSSchedLock_7: (+1)
   \       0x7C   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x80   0x0006             MOVS     R6,R0
    820            OSSchedLockNestingCtr++;                                      // Increment lock nesting level
   \       0x82   0x7828             LDRB     R0,[R5, #+0]
   \       0x84   0x1C40             ADDS     R0,R0,#+1
   \       0x86   0x7028             STRB     R0,[R5, #+0]
    821          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
    822            OS_SchedLockTimeMeasStart();
    823          #endif
    824            CORE_EXIT_ATOMIC();
   \       0x88   0x0030             MOVS     R0,R6
   \       0x8A   0x.... 0x....      BL       CORE_ExitAtomic
    825          
    826            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0x7020             STRB     R0,[R4, #+0]
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x96   0x6060             STR      R0,[R4, #+4]
   \       0x98   0xF240 0x303A      MOVW     R0,#+826
   \       0x9C   0x60A0             STR      R0,[R4, #+8]
   \       0x9E   0x.... 0x....      LDR.W    R0,??DataTable17_32
   \       0xA2   0x60E0             STR      R0,[R4, #+12]
    827          }
   \                     ??OSSchedLock_6: (+1)
   \       0xA4   0xBD70             POP      {R4-R6,PC}
    828          
    829          /****************************************************************************************************//**
    830           *                                               OSSchedUnlock()
    831           *
    832           * @brief    Re-allows rescheduling.
    833           *
    834           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    835           *                   from this function:
    836           *                       - RTOS_ERR_NONE
    837           *                       - RTOS_ERR_INVALID_STATE
    838           *                       - RTOS_ERR_OS_SCHED_LOCKED
    839           *
    840           * @note     (1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pairs. In other words, for every
    841           *               call to OSSchedLock(), you MUST have a call to OSSchedUnlock().
    842           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    843          void OSSchedUnlock(RTOS_ERR *p_err)
    844          {
   \                     OSSchedUnlock: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    845            CORE_DECLARE_IRQ_STATE;
    846          
    847            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??OSSchedUnlock_0
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
    848          
    849            //                                                               Not allowed to call from an ISR
    850            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
   \                     ??OSSchedUnlock_0: (+1)
   \        0xC   0x.... 0x....      BL       CORE_InIrqContext
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD101             BNE.N    ??OSSchedUnlock_1
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xE000             B.N      ??OSSchedUnlock_2
   \                     ??OSSchedUnlock_1: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \                     ??OSSchedUnlock_2: (+1)
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD10B             BNE.N    ??OSSchedUnlock_3
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0x7020             STRB     R0,[R4, #+0]
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x28   0x6060             STR      R0,[R4, #+4]
   \       0x2A   0xF240 0x3052      MOVW     R0,#+850
   \       0x2E   0x60A0             STR      R0,[R4, #+8]
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable17_33
   \       0x34   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSSchedUnlock_4: (+1)
   \       0x36   0xE7FE             B.N      ??OSSchedUnlock_4
    851          
    852            //                                                               Make sure kernel is running.
    853            if (OSRunning != OS_STATE_OS_RUNNING) {
   \                     ??OSSchedUnlock_3: (+1)
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable17_19
   \       0x3C   0x7800             LDRB     R0,[R0, #+0]
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD00B             BEQ.N    ??OSSchedUnlock_5
    854              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_READY);
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0x7020             STRB     R0,[R4, #+0]
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x4A   0x6060             STR      R0,[R4, #+4]
   \       0x4C   0xF240 0x3056      MOVW     R0,#+854
   \       0x50   0x60A0             STR      R0,[R4, #+8]
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable17_33
   \       0x56   0x60E0             STR      R0,[R4, #+12]
    855              return;
   \       0x58   0xE038             B.N      ??OSSchedUnlock_6
    856            }
    857          
    858            if (OSSchedLockNestingCtr == 0u) {                            // See if the scheduler is locked
   \                     ??OSSchedUnlock_5: (+1)
   \       0x5A   0x.... 0x....      LDR.W    R5,??DataTable17_20
   \       0x5E   0x7828             LDRB     R0,[R5, #+0]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD10B             BNE.N    ??OSSchedUnlock_7
    859              RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
   \       0x64   0x201F             MOVS     R0,#+31
   \       0x66   0x7020             STRB     R0,[R4, #+0]
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x6C   0x6060             STR      R0,[R4, #+4]
   \       0x6E   0xF240 0x305B      MOVW     R0,#+859
   \       0x72   0x60A0             STR      R0,[R4, #+8]
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable17_33
   \       0x78   0x60E0             STR      R0,[R4, #+12]
    860              return;
   \       0x7A   0xE027             B.N      ??OSSchedUnlock_6
    861            }
    862          
    863            CORE_ENTER_ATOMIC();
   \                     ??OSSchedUnlock_7: (+1)
   \       0x7C   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x80   0x0006             MOVS     R6,R0
    864            OSSchedLockNestingCtr--;                                      // Decrement lock nesting level
   \       0x82   0x7828             LDRB     R0,[R5, #+0]
   \       0x84   0x1E40             SUBS     R0,R0,#+1
   \       0x86   0x7028             STRB     R0,[R5, #+0]
    865            if (OSSchedLockNestingCtr > 0u) {
   \       0x88   0x7828             LDRB     R0,[R5, #+0]
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD00E             BEQ.N    ??OSSchedUnlock_8
    866              CORE_EXIT_ATOMIC();                                         // Scheduler is still locked
   \       0x8E   0x0030             MOVS     R0,R6
   \       0x90   0x.... 0x....      BL       CORE_ExitAtomic
    867              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
   \       0x94   0x202D             MOVS     R0,#+45
   \       0x96   0x7020             STRB     R0,[R4, #+0]
   \       0x98   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x9C   0x6060             STR      R0,[R4, #+4]
   \       0x9E   0xF240 0x3063      MOVW     R0,#+867
   \       0xA2   0x60A0             STR      R0,[R4, #+8]
   \       0xA4   0x.... 0x....      LDR.W    R0,??DataTable17_33
   \       0xA8   0x60E0             STR      R0,[R4, #+12]
    868              return;
   \       0xAA   0xE00F             B.N      ??OSSchedUnlock_6
    869            }
    870          
    871          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
    872            OS_SchedLockTimeMeasStop();
    873          #endif
    874          
    875            CORE_EXIT_ATOMIC();                                           // Scheduler should be re-enabled
   \                     ??OSSchedUnlock_8: (+1)
   \       0xAC   0x0030             MOVS     R0,R6
   \       0xAE   0x.... 0x....      BL       CORE_ExitAtomic
    876            OSSched();                                                    // Run the scheduler
   \       0xB2   0x.... 0x....      BL       OSSched
    877            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0x7020             STRB     R0,[R4, #+0]
   \       0xBA   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0xBE   0x6060             STR      R0,[R4, #+4]
   \       0xC0   0xF240 0x306D      MOVW     R0,#+877
   \       0xC4   0x60A0             STR      R0,[R4, #+8]
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable17_33
   \       0xCA   0x60E0             STR      R0,[R4, #+12]
    878          }
   \                     ??OSSchedUnlock_6: (+1)
   \       0xCC   0xBD70             POP      {R4-R6,PC}
    879          
    880          /****************************************************************************************************//**
    881           *                                           OSSchedRoundRobinCfg()
    882           *
    883           * @brief    Changes the round-robin scheduling parameters.
    884           *
    885           * @param    en                  Determines if the round-robin will be used:
    886           *                                   - DEF_ENABLED     Round-robin scheduling is enabled.
    887           *                                   - DEF_DISABLED    Round-robin scheduling is disabled.
    888           *
    889           * @param    dflt_time_quanta    Default number of ticks between time slices.
    890           *                               A value of 0 assumes OSCfg_TickRate_Hz / 10.
    891           *
    892           * @param    p_err               Pointer to the variable that will receive one of the following
    893           *                               error code(s) from this function:
    894           *                                   - RTOS_ERR_NONE
    895           *******************************************************************************************************/
    896          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    897          void OSSchedRoundRobinCfg(CPU_BOOLEAN en,
    898                                    OS_TICK     dflt_time_quanta,
    899                                    RTOS_ERR    *p_err)
    900          {
    901            sl_status_t status;
    902            CORE_DECLARE_IRQ_STATE;
    903          
    904            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
    905          
    906            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
    907          
    908            CORE_ENTER_ATOMIC();
    909          
    910            if (dflt_time_quanta > 0u) {
    911              OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
    912            } else {
    913              OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSTimeTickRateHzGet(p_err) / 10u);
    914            }
    915          
    916            if ((en != DEF_ENABLED)
    917                && (OSSchedRoundRobinEn == DEF_TRUE)) {
    918              OSSchedRoundRobinEn = DEF_FALSE;
    919              status = sl_sleeptimer_get_timer_time_remaining(&OSRoundRobinTimer,
    920                                                              &OSRoundRobinCurTCB->TimeQuantaCtr);
    921              if (status != SL_STATUS_OK) {
    922                OSRoundRobinCurTCB->TimeQuantaCtr = 0u;
    923              }
    924          
    925              sl_sleeptimer_stop_timer(&OSRoundRobinTimer);
    926          
    927              OSRoundRobinCurTCB = DEF_NULL;
    928            } else if ((en == DEF_ENABLED)
    929                       && (OSSchedRoundRobinEn == DEF_FALSE)) {
    930              OSSchedRoundRobinEn = DEF_TRUE;
    931              OS_SchedRoundRobinResetQuanta(OSTCBCurPtr);
    932              OS_SchedRoundRobinRestartTimer(OSTCBCurPtr);
    933            }
    934            CORE_EXIT_ATOMIC();
    935          }
    936          #endif
    937          
    938          /****************************************************************************************************//**
    939           *                                           OSSchedRoundRobinYield()
    940           *
    941           * @brief    Gives up the CPU when a task is finished its execution before its time slice expires.
    942           *
    943           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
    944           *                   from this function:
    945           *                       - RTOS_ERR_NONE
    946           *                       - RTOS_ERR_NOT_AVAIL
    947           *                       - RTOS_ERR_NONE_WAITING
    948           *                       - RTOS_ERR_OS_SCHED_LOCKED
    949           *                       - RTOS_ERR_INVALID_STATE
    950           *
    951           * @note     (1) This function MUST be called from a task.
    952           *******************************************************************************************************/
    953          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    954          void OSSchedRoundRobinYield(RTOS_ERR *p_err)
    955          {
    956            OS_RDY_LIST *p_rdy_list;
    957            sl_status_t status;
    958            CORE_DECLARE_IRQ_STATE;
    959          
    960            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
    961          
    962            //                                                               Not allowed to call from an ISR
    963            OS_ASSERT_DBG_ERR_SET((!CORE_InIrqContext()), *p_err, RTOS_ERR_ISR,; );
    964          
    965            //                                                               Not allowed in atomic/critical sections
    966            OS_ASSERT_DBG_ERR_SET((!CORE_IrqIsDisabled()), *p_err, RTOS_ERR_INVALID_STATE,; );
    967          
    968            if (OSSchedLockNestingCtr > 0u) {                             // Can't yield if the scheduler is locked
    969              RTOS_ERR_SET(*p_err, RTOS_ERR_OS_SCHED_LOCKED);
    970              return;
    971            }
    972          
    973            if (OSSchedRoundRobinEn != DEF_TRUE) {                        // Make sure round-robin has been enabled
    974              RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_AVAIL);
    975              return;
    976            }
    977          
    978            CORE_ENTER_ATOMIC();
    979            p_rdy_list = &OSRdyList[OSPrioCur];                           // Can't yield if it's the only task at that priority
    980            if (p_rdy_list->HeadPtr == p_rdy_list->TailPtr) {
    981              CORE_EXIT_ATOMIC();
    982              RTOS_ERR_SET(*p_err, RTOS_ERR_NONE_WAITING);
    983              return;
    984            }
    985          
    986            status = sl_sleeptimer_stop_timer(&OSRoundRobinTimer);
    987            if (status != SL_STATUS_OK) {
    988              CORE_EXIT_ATOMIC();
    989              RTOS_ERR_SET(*p_err, RTOS_ERR_FAIL);
    990              return;
    991            }
    992          
    993            p_rdy_list->HeadPtr->TimeQuantaCtr = 0u;                      // TimeQuantaCtr will be reset next time this task is scheduled
    994            OS_RdyListMoveHeadToTail(p_rdy_list);                         // Move current OS_TCB to the end of the list
    995          
    996            CORE_EXIT_ATOMIC();
    997          
    998            OSSched();                                                    // Run new task
    999            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   1000          }
   1001          #endif
   1002          
   1003          /****************************************************************************************************//**
   1004           *                                                   OSStart()
   1005           *
   1006           * @brief    Starts the multitasking process which lets the Kernel manage the tasks that you created.
   1007           *           Before you can call OSStart(), you MUST have called OSInit() and you MUST have created
   1008           *           at least one application task.
   1009           *
   1010           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1011           *                   from this function:
   1012           *                       - RTOS_ERR_NONE
   1013           *
   1014           * @note     (1) OSStartHighRdy() MUST:
   1015           *               - (a) Call OSTaskSwHook().
   1016           *               - (b) Load the context of the task pointed to by OSTCBHighRdyPtr.
   1017           *               - (c) Execute the task.
   1018           *
   1019           * @note     (2) OSStart() is not supposed to return. If it does, that would be considered a fatal error.
   1020           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1021          void OSStart(RTOS_ERR *p_err)
   1022          {
   \                     OSStart: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1023            OS_OBJ_QTY kernel_task_cnt;
   1024          
   1025            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err,; );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??OSStart_0
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
   1026          
   1027            OS_ASSERT_DBG_ERR_SET((OSInitialized == DEF_TRUE), *p_err, RTOS_ERR_NOT_INIT,; );
   \                     ??OSStart_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD00B             BEQ.N    ??OSStart_1
   \       0x16   0x2013             MOVS     R0,#+19
   \       0x18   0x7020             STRB     R0,[R4, #+0]
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x1E   0x6060             STR      R0,[R4, #+4]
   \       0x20   0xF240 0x4003      MOVW     R0,#+1027
   \       0x24   0x60A0             STR      R0,[R4, #+8]
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable17_34
   \       0x2A   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSStart_2: (+1)
   \       0x2C   0xE7FE             B.N      ??OSStart_2
   1028          
   1029            kernel_task_cnt = 0u;                                         // Calculate the number of kernel tasks
   \                     ??OSStart_1: (+1)
   \       0x2E   0x2500             MOVS     R5,#+0
   1030          #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
   1031            kernel_task_cnt++;
   1032          #endif
   1033          #if (OS_CFG_TMR_EN == DEF_ENABLED)
   1034            kernel_task_cnt++;
   1035          #endif
   1036          
   1037            //                                                               Make sure at least one application task is created
   1038            OS_ASSERT_DBG_ERR_SET((OSTaskQty > kernel_task_cnt), *p_err, RTOS_ERR_INVALID_CFG,; );
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable17_35
   \       0x36   0x8809             LDRH     R1,[R1, #+0]
   \       0x38   0xB280             UXTH     R0,R0
   \       0x3A   0x4288             CMP      R0,R1
   \       0x3C   0xD30B             BCC.N    ??OSStart_3
   \       0x3E   0x2009             MOVS     R0,#+9
   \       0x40   0x7020             STRB     R0,[R4, #+0]
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x46   0x6060             STR      R0,[R4, #+4]
   \       0x48   0xF240 0x400E      MOVW     R0,#+1038
   \       0x4C   0x60A0             STR      R0,[R4, #+8]
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable17_34
   \       0x52   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSStart_4: (+1)
   \       0x54   0xE7FE             B.N      ??OSStart_4
   1039          
   1040            //                                                               Make sure kernel is not already running
   1041            OS_ASSERT_DBG_ERR_SET((OSRunning == OS_STATE_OS_STOPPED), *p_err, RTOS_ERR_INVALID_STATE,; );
   \                     ??OSStart_3: (+1)
   \       0x56   0x.... 0x....      LDR.W    R6,??DataTable17_19
   \       0x5A   0x7830             LDRB     R0,[R6, #+0]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD00B             BEQ.N    ??OSStart_5
   \       0x60   0x201F             MOVS     R0,#+31
   \       0x62   0x7020             STRB     R0,[R4, #+0]
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x68   0x6060             STR      R0,[R4, #+4]
   \       0x6A   0xF240 0x4011      MOVW     R0,#+1041
   \       0x6E   0x60A0             STR      R0,[R4, #+8]
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable17_34
   \       0x74   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSStart_6: (+1)
   \       0x76   0xE7FE             B.N      ??OSStart_6
   1042          
   1043            //                                                               Not allowed in atomic/critical sections
   1044            OS_ASSERT_DBG_ERR_SET((!CORE_IrqIsDisabled()), *p_err, RTOS_ERR_INVALID_STATE,; );
   \                     ??OSStart_5: (+1)
   \       0x78   0x.... 0x....      BL       CORE_IrqIsDisabled
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD101             BNE.N    ??OSStart_7
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0xE000             B.N      ??OSStart_8
   \                     ??OSStart_7: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \                     ??OSStart_8: (+1)
   \       0x86   0xB2C0             UXTB     R0,R0
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD10B             BNE.N    ??OSStart_9
   \       0x8C   0x201F             MOVS     R0,#+31
   \       0x8E   0x7020             STRB     R0,[R4, #+0]
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x94   0x6060             STR      R0,[R4, #+4]
   \       0x96   0xF240 0x4014      MOVW     R0,#+1044
   \       0x9A   0x60A0             STR      R0,[R4, #+8]
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable17_34
   \       0xA0   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSStart_10: (+1)
   \       0xA2   0xE7FE             B.N      ??OSStart_10
   1045          
   1046            OSPrioHighRdy = OS_PrioGetHighest();                          // Find the highest priority
   \                     ??OSStart_9: (+1)
   \       0xA4   0x.... 0x....      LDR.W    R7,??DataTable17_24
   \       0xA8   0x.... 0x....      BL       OS_PrioGetHighest
   \       0xAC   0x7038             STRB     R0,[R7, #+0]
   1047            OSPrioCur = OSPrioHighRdy;
   \       0xAE   0x7839             LDRB     R1,[R7, #+0]
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable17_23
   \       0xB4   0x7001             STRB     R1,[R0, #+0]
   1048            OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
   \       0xB6   0x.... 0x....      LDR.W    R0,??DataTable17_22
   \       0xBA   0x.... 0x....      LDR.W    R1,??DataTable17_31
   \       0xBE   0x783A             LDRB     R2,[R7, #+0]
   \       0xC0   0xF851 0x1032      LDR      R1,[R1, R2, LSL #+3]
   \       0xC4   0x6001             STR      R1,[R0, #+0]
   1049            OSTCBCurPtr = OSTCBHighRdyPtr;
   \       0xC6   0x6801             LDR      R1,[R0, #+0]
   \       0xC8   0x.... 0x....      LDR.W    R0,??DataTable17_21
   \       0xCC   0x6001             STR      R1,[R0, #+0]
   1050          #ifdef OS_SAFETY_CRITICAL_IEC61508
   1051            OSSafetyCriticalStartFlag = DEF_TRUE;                         // Prevent creation of additional kernel objects
   1052          #endif
   1053            OSRunning = OS_STATE_OS_RUNNING;
   \       0xCE   0x2001             MOVS     R0,#+1
   \       0xD0   0x7030             STRB     R0,[R6, #+0]
   1054          #if OS_CFG_STAT_TASK_EN > 0u
   1055            OS_StatTickInit();
   1056          #endif
   1057            OSStartHighRdy();                                             // Execute target specific code to start task
   \       0xD2   0x.... 0x....      BL       OSStartHighRdy
   1058            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );                      // OSStart() is not supposed to return
   \       0xD6   0x.... 0x....      BL       CPU_SW_Exception
   1059          }
   \       0xDA   0xBDF1             POP      {R0,R4-R7,PC}
   1060          
   1061          /********************************************************************************************************
   1062           ********************************************************************************************************
   1063           *                                       DEPRECATED GLOBAL FUNCTIONS
   1064           ********************************************************************************************************
   1065           *******************************************************************************************************/
   1066          
   1067          /****************************************************************************************************//**
   1068           *                                               OSVersion()
   1069           *
   1070           * @brief    Returns the version number of the Kernel. The returned value is the Kernel's version
   1071           *           number multiplied by 10000. In other words, version 3.01.02 would be returned as 30102.
   1072           *
   1073           * @param    p_err   Pointer to the variable that will receive one of the following error code(s)
   1074           *                   from this function:
   1075           *                       - RTOS_ERR_NONE
   1076           *
   1077           * @return   The version number of the Kernel multiplied by 10000.
   1078           *
   1079           * @note     (1) This function is DEPRECATED and will be removed in a future version of this product.
   1080           *               Instead, use RTOS_Version() or RTOS_VERSION.
   1081           * @deprecated
   1082           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1083          CPU_INT16U OSVersion(RTOS_ERR *p_err)
   1084          {
   \                     OSVersion: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1085            OS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, 0u);
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??OSVersion_0
   \        0x8   0x.... 0x....      BL       CPU_SW_Exception
   1086          
   1087            RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);
   \                     ??OSVersion_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x7020             STRB     R0,[R4, #+0]
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \       0x14   0x6060             STR      R0,[R4, #+4]
   \       0x16   0xF240 0x403F      MOVW     R0,#+1087
   \       0x1A   0x60A0             STR      R0,[R4, #+8]
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable17_36
   \       0x20   0x60E0             STR      R0,[R4, #+12]
   1088            return (OS_VERSION);
   \       0x22   0xF64C 0x102D      MOVW     R0,#+51501
   \       0x26   0xBD10             POP      {R4,PC}
   1089          }
   1090          
   1091          /***************************************************************************//**
   1092           * This function return the state of the kernel.
   1093           *
   1094           * @return   True, if the kernel is idle,
   1095           *           False, otherwise.
   1096           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1097          CPU_BOOLEAN OSIsIdle(void)
   1098          {
   \                     OSIsIdle: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1099            if (OS_PrioGetHighest() != OS_CFG_PRIO_MAX ) {
   \        0x2   0x.... 0x....      BL       OS_PrioGetHighest
   \        0x6   0x2840             CMP      R0,#+64
   \        0x8   0xD001             BEQ.N    ??OSIsIdle_0
   1100              return DEF_NO;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE000             B.N      ??OSIsIdle_1
   1101            } else {
   1102              return DEF_YES;
   \                     ??OSIsIdle_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \                     ??OSIsIdle_1: (+1)
   \       0x10   0xBD02             POP      {R1,PC}
   1103            }
   1104          }
   1105          
   1106          /********************************************************************************************************
   1107           ********************************************************************************************************
   1108           *                                           INTERNAL FUNCTIONS
   1109           ********************************************************************************************************
   1110           *******************************************************************************************************/
   1111          
   1112          /*****************************************************************************************************//**
   1113           *                                               OS_Pend()
   1114           *
   1115           * @brief    This function is called to place a task in the blocked state waiting for an event to occur.
   1116           *           This function exists because it is common to a number of OSxxxPend() services.
   1117           *
   1118           * @param    p_obj       Pointer to the object to pend on. If there are no object used to pend
   1119           *                       on then the caller must pass a NULL pointer.
   1120           *
   1121           * @param    pending_on  Specifies what the task will be pending on:
   1122           *                           - OS_TASK_PEND_ON_FLAG
   1123           *                           - OS_TASK_PEND_ON_TASK_Q      <- No object (pending for a message sent to
   1124           *                                                            the task)
   1125           *                           - OS_TASK_PEND_ON_MUTEX
   1126           *                           - OS_TASK_PEND_ON_Q
   1127           *                           - OS_TASK_PEND_ON_SEM
   1128           *                           - OS_TASK_PEND_ON_TASK_SEM    <- No object (pending on a signal   sent to
   1129           *                                                            the task)
   1130           *
   1131           * @param    timeout     Amount of time the task will wait for the event to occur.
   1132           *
   1133           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1134           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1135          void OS_Pend(OS_PEND_OBJ *p_obj,
   1136                       OS_STATE    pending_on,
   1137                       OS_TICK     timeout)
   1138          {
   \                     OS_Pend: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1139            OS_PEND_LIST *p_pend_list;
   1140          
   1141            OSTCBCurPtr->PendOn = pending_on;                             // Resource not available, wait until it is
   \        0xA   0x.... 0x....      LDR.W    R8,??DataTable17_21
   \        0xE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x12   0xF880 0x5024      STRB     R5,[R0, #+36]
   1142            OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x1C   0xF880 0x1025      STRB     R1,[R0, #+37]
   1143          
   1144          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
   1145            if (OSSchedRoundRobinEn) {
   1146              OSRoundRobinCurTCB->TimeQuantaCtr = 0u;                     // Time quanta counter will be reset later.
   1147              (void)sl_sleeptimer_stop_timer(&OSRoundRobinTimer);
   1148            }
   1149          #endif
   1150          
   1151            OS_TaskBlock(OSTCBCurPtr,                                     // Block the task and add it to the tick list if needed
   1152                         timeout);
   \       0x20   0x0031             MOVS     R1,R6
   \       0x22   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x26   0x.... 0x....      BL       OS_TaskBlock
   1153          
   1154            if (p_obj != DEF_NULL) {                                      // Add the current task to the pend list ...
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD00A             BEQ.N    ??OS_Pend_0
   1155              p_pend_list = &p_obj->PendList;                             // ... if there is an object to pend on
   \       0x2E   0x1D20             ADDS     R0,R4,#+4
   \       0x30   0x0007             MOVS     R7,R0
   1156              OSTCBCurPtr->PendObjPtr = p_obj;                            // Save the pointer to the object pending on
   \       0x32   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x36   0x6204             STR      R4,[R0, #+32]
   1157              OS_PendListInsertPrio(p_pend_list,                          // Insert in the pend list in priority order
   1158                                    OSTCBCurPtr);
   \       0x38   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x3C   0x0038             MOVS     R0,R7
   \       0x3E   0x.... 0x....      BL       OS_PendListInsertPrio
   \       0x42   0xE003             B.N      ??OS_Pend_1
   1159            } else {
   1160              OSTCBCurPtr->PendObjPtr = DEF_NULL;                         // If no object being pended on, clear the pend object
   \                     ??OS_Pend_0: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x4A   0x6208             STR      R0,[R1, #+32]
   1161            }
   1162          
   1163          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1164            OS_PendDbgNameAdd(p_obj,
   1165                              OSTCBCurPtr);
   1166          #endif
   1167          }
   \                     ??OS_Pend_1: (+1)
   \       0x4C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1168          
   1169          /****************************************************************************************************//**
   1170           *                                               OS_PendAbort()
   1171           *
   1172           * @brief    This function is called by the OSxxxPendAbort() and OSxxxDel() functions to cancel pending
   1173           *           on an event.
   1174           *
   1175           * @param    p_tcb   Pointer to the OS_TCB of the task that we'll abort the pend for.
   1176           *
   1177           * @param    ts      Timestamp as to when the pend was cancelled.
   1178           *
   1179           * @param    reason  Indicates how the task was readied:
   1180           *                       - OS_STATUS_PEND_DEL      Object pended on was deleted.
   1181           *                       - OS_STATUS_PEND_ABORT    Pend was aborted.
   1182           *
   1183           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1184           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1185          void OS_PendAbort(OS_TCB    *p_tcb,
   1186                            CPU_TS    ts,
   1187                            OS_STATUS reason)
   1188          {
   \                     OS_PendAbort: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
   1189          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1190            sl_status_t status;
   1191          #endif
   1192          #if (OS_CFG_TS_EN == DEF_DISABLED)
   1193            (void)ts;                                                     // Prevent compiler warning for not using 'ts'
   1194          #endif
   1195          
   1196            switch (p_tcb->TaskState) {
   \        0x8   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD04A             BEQ.N    ??OS_PendAbort_0
   \       0x10   0x2802             CMP      R0,#+2
   \       0x12   0xD009             BEQ.N    ??OS_PendAbort_1
   \       0x14   0xD347             BCC.N    ??OS_PendAbort_0
   \       0x16   0x2804             CMP      R0,#+4
   \       0x18   0xD045             BEQ.N    ??OS_PendAbort_0
   \       0x1A   0xD305             BCC.N    ??OS_PendAbort_1
   \       0x1C   0x2806             CMP      R0,#+6
   \       0x1E   0xD024             BEQ.N    ??OS_PendAbort_2
   \       0x20   0xD341             BCC.N    ??OS_PendAbort_0
   \       0x22   0x2807             CMP      R0,#+7
   \       0x24   0xD021             BEQ.N    ??OS_PendAbort_2
   \       0x26   0xE03F             B.N      ??OS_PendAbort_3
   1197              case OS_TASK_STATE_PEND:
   1198              case OS_TASK_STATE_PEND_TIMEOUT:
   1199          #if (OS_MSG_EN == DEF_ENABLED)
   1200                p_tcb->MsgPtr = DEF_NULL;
   \                     ??OS_PendAbort_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6668             STR      R0,[R5, #+100]
   1201                p_tcb->MsgSize = 0u;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xF8A5 0x0068      STRH     R0,[R5, #+104]
   1202          #endif
   1203          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1204                p_tcb->TS = ts;
   1205          #endif
   1206                OS_PendListRemove(p_tcb);                                 // Remove task from the pend list
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0x.... 0x....      BL       OS_PendListRemove
   1207          
   1208          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1209                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \       0x38   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \       0x3C   0x2803             CMP      R0,#+3
   \       0x3E   0xD108             BNE.N    ??OS_PendAbort_4
   1210                  status = sl_sleeptimer_stop_timer(&p_tcb->TimerHandle);
   \       0x40   0xF115 0x0044      ADDS     R0,R5,#+68
   \       0x44   0x.... 0x....      BL       sl_sleeptimer_stop_timer
   \       0x48   0x0004             MOVS     R4,R0
   1211                  RTOS_ASSERT_CRITICAL((status == SL_STATUS_OK), RTOS_ERR_FAIL,; );
   \       0x4A   0x2C00             CMP      R4,#+0
   \       0x4C   0xD001             BEQ.N    ??OS_PendAbort_4
   \       0x4E   0x.... 0x....      BL       CPU_SW_Exception
   1212                }
   1213          #endif
   1214                OS_RdyListInsert(p_tcb);                                  // Insert the task in the ready list
   \                     ??OS_PendAbort_4: (+1)
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0x.... 0x....      BL       OS_RdyListInsert
   1215                p_tcb->TaskState = OS_TASK_STATE_RDY;                     // Task will be ready
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF885 0x0026      STRB     R0,[R5, #+38]
   1216                p_tcb->PendStatus = reason;                               // Indicate how the task became ready
   \       0x5E   0xF885 0x7025      STRB     R7,[R5, #+37]
   1217                p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;                  // Indicate no longer pending
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xF885 0x0024      STRB     R0,[R5, #+36]
   1218                break;
   \       0x68   0xE020             B.N      ??OS_PendAbort_5
   1219          
   1220              case OS_TASK_STATE_PEND_SUSPENDED:
   1221              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1222          #if (OS_MSG_EN == DEF_ENABLED)
   1223                p_tcb->MsgPtr = DEF_NULL;
   \                     ??OS_PendAbort_2: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x6668             STR      R0,[R5, #+100]
   1224                p_tcb->MsgSize = 0u;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xF8A5 0x0068      STRH     R0,[R5, #+104]
   1225          #endif
   1226          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1227                p_tcb->TS = ts;
   1228          #endif
   1229                OS_PendListRemove(p_tcb);                                 // Remove task from the pend list
   \       0x74   0x0028             MOVS     R0,R5
   \       0x76   0x.... 0x....      BL       OS_PendListRemove
   1230          
   1231          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1232                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
   \       0x7A   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \       0x7E   0x2807             CMP      R0,#+7
   \       0x80   0xD108             BNE.N    ??OS_PendAbort_6
   1233                  status = sl_sleeptimer_stop_timer(&p_tcb->TimerHandle);
   \       0x82   0xF115 0x0044      ADDS     R0,R5,#+68
   \       0x86   0x.... 0x....      BL       sl_sleeptimer_stop_timer
   \       0x8A   0x0004             MOVS     R4,R0
   1234                  RTOS_ASSERT_CRITICAL((status == SL_STATUS_OK), RTOS_ERR_FAIL,; );
   \       0x8C   0x2C00             CMP      R4,#+0
   \       0x8E   0xD001             BEQ.N    ??OS_PendAbort_6
   \       0x90   0x.... 0x....      BL       CPU_SW_Exception
   1235                }
   1236          #endif
   1237                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;               // Task needs to remain suspended
   \                     ??OS_PendAbort_6: (+1)
   \       0x94   0x2004             MOVS     R0,#+4
   \       0x96   0xF885 0x0026      STRB     R0,[R5, #+38]
   1238                p_tcb->PendStatus = reason;                               // Indicate how the task became ready
   \       0x9A   0xF885 0x7025      STRB     R7,[R5, #+37]
   1239                p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;                  // Indicate no longer pending
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xF885 0x0024      STRB     R0,[R5, #+36]
   1240                break;
   \       0xA4   0xE002             B.N      ??OS_PendAbort_5
   1241          
   1242              case OS_TASK_STATE_RDY:                                     // Cannot cancel a pend when a task is in these states.
   1243              case OS_TASK_STATE_DLY:
   1244              case OS_TASK_STATE_SUSPENDED:
   1245              case OS_TASK_STATE_DLY_SUSPENDED:
   1246                break;
   \                     ??OS_PendAbort_0: (+1)
   \       0xA6   0xE001             B.N      ??OS_PendAbort_5
   1247          
   1248              case OS_TASK_STATE_DEL:
   1249              default:
   1250                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \                     ??OS_PendAbort_3: (+1)
   \       0xA8   0x.... 0x....      BL       CPU_SW_Exception
   1251            }
   1252          }
   \                     ??OS_PendAbort_5: (+1)
   \       0xAC   0xBDF1             POP      {R0,R4-R7,PC}
   1253          
   1254          /****************************************************************************************************//**
   1255           *                                           OS_PendDbgNameAdd()
   1256           *
   1257           * @brief    Add pointers to ASCII 'names' of objects so they can easily be displayed using a Kernel
   1258           *           aware tool.
   1259           *
   1260           * @param    p_obj   Pointer to the object being pended on.
   1261           *
   1262           * @param    p_tcb   Pointer to the OS_TCB of the task pending on the object.
   1263           *
   1264           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1265           *******************************************************************************************************/
   1266          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1267          void OS_PendDbgNameAdd(OS_PEND_OBJ *p_obj,
   1268                                 OS_TCB      *p_tcb)
   1269          {
   1270            OS_PEND_LIST *p_pend_list;
   1271            OS_TCB       *p_tcb1;
   1272          
   1273            if (p_obj != DEF_NULL) {
   1274              p_tcb->DbgNamePtr = p_obj->NamePtr;                         // Task pending on this object ... save name in TCB
   1275              p_pend_list = &p_obj->PendList;                             // Find name of HP task pending on this object ...
   1276              p_tcb1 = p_pend_list->HeadPtr;
   1277              p_obj->DbgNamePtr = p_tcb1->NamePtr;                        // ... Save in object
   1278            } else {
   1279              switch (p_tcb->PendOn) {
   1280                case OS_TASK_PEND_ON_TASK_Q:
   1281                  p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
   1282                  break;
   1283          
   1284                case OS_TASK_PEND_ON_TASK_SEM:
   1285                  p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
   1286                  break;
   1287          
   1288                default:
   1289                  p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
   1290                  break;
   1291              }
   1292            }
   1293          }
   1294          
   1295          /****************************************************************************************************//**
   1296           *                                           OS_PendDbgNameRemove()
   1297           *
   1298           * @brief    Remove pointers to ASCII 'names' of objects so they can easily be displayed using a Kernel
   1299           *           aware tool.
   1300           *
   1301           * @param    p_obj   Pointer to the object being pended on.
   1302           *
   1303           * @param    p_tcb   Pointer to the OS_TCB of the task pending on the object.
   1304           *
   1305           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1306           *******************************************************************************************************/
   1307          void OS_PendDbgNameRemove(OS_PEND_OBJ *p_obj,
   1308                                    OS_TCB      *p_tcb)
   1309          {
   1310            OS_PEND_LIST *p_pend_list;
   1311            OS_TCB       *p_tcb1;
   1312          
   1313            p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");                // Remove name of object pended on for readied task
   1314          
   1315            if (p_obj != DEF_NULL) {
   1316              p_pend_list = &p_obj->PendList;
   1317              p_tcb1 = p_pend_list->HeadPtr;
   1318              if (p_tcb1 != DEF_NULL) {                                   // Find name of HP task pending on this object ...
   1319                p_obj->DbgNamePtr = p_tcb1->NamePtr;                      // ... Save in object
   1320              } else {
   1321                p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");            // Or no other task is pending on object
   1322              }
   1323            }
   1324          }
   1325          #endif
   1326          
   1327          /****************************************************************************************************//**
   1328           *                                           OS_PendListChangePrio()
   1329           *
   1330           * @brief    This function is called to change the position of a task waiting in a pend list. The
   1331           *           strategy used is to remove the task from the pend list and add it again using its changed
   1332           *           priority.
   1333           *
   1334           * @param    p_tcb   Pointer to the TCB of the task to move.
   1335           *
   1336           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1337           *
   1338           * @note     (2) It's assumed that the TCB contains the NEW priority in its .Prio field.
   1339           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1340          void OS_PendListChangePrio(OS_TCB *p_tcb)
   1341          {
   \                     OS_PendListChangePrio: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1342            OS_PEND_LIST *p_pend_list;
   1343            OS_PEND_OBJ  *p_obj;
   1344          
   1345            p_obj = p_tcb->PendObjPtr;                                    // Get pointer to pend list
   \        0x4   0x6A25             LDR      R5,[R4, #+32]
   1346            p_pend_list = &p_obj->PendList;
   \        0x6   0x1D2E             ADDS     R6,R5,#+4
   1347          
   1348            if (p_pend_list->HeadPtr->PendNextPtr != DEF_NULL) {          // Only move if multiple entries in the list
   \        0x8   0x6830             LDR      R0,[R6, #+0]
   \        0xA   0x6980             LDR      R0,[R0, #+24]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD007             BEQ.N    ??OS_PendListChangePrio_0
   1349              OS_PendListRemove(p_tcb);                                   // Remove entry from current position
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       OS_PendListRemove
   1350              p_tcb->PendObjPtr = p_obj;
   \       0x16   0x6225             STR      R5,[R4, #+32]
   1351              OS_PendListInsertPrio(p_pend_list,                          // INSERT it back in the list
   1352                                    p_tcb);
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x.... 0x....      BL       OS_PendListInsertPrio
   1353            }
   1354          }
   \                     ??OS_PendListChangePrio_0: (+1)
   \       0x20   0xBD70             POP      {R4-R6,PC}
   1355          
   1356          /****************************************************************************************************//**
   1357           *                                               OS_PendListInit()
   1358           *
   1359           * @brief    This function is called to initialize the fields of an OS_PEND_LIST.
   1360           *
   1361           * @param    p_pend_list     Pointer to an OS_PEND_LIST.
   1362           *
   1363           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1364           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1365          void OS_PendListInit(OS_PEND_LIST *p_pend_list)
   1366          {
   1367            p_pend_list->HeadPtr = DEF_NULL;
   \                     OS_PendListInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
   1368            p_pend_list->TailPtr = DEF_NULL;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
   1369          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1370            p_pend_list->NbrEntries = 0u;
   1371          #endif
   1372          }
   \        0x8   0x4770             BX       LR
   1373          
   1374          /****************************************************************************************************//**
   1375           *                                           OS_PendListInsertPrio()
   1376           *
   1377           * @brief    This function is called to place an OS_TCB entry in a linked list based on its priority.
   1378           *           The highest priority being placed at the head of the list. The TCB is assumed to contain
   1379           *           the priority of the task in its .Prio field.
   1380           *           @verbatim
   1381           *           CASE 0: Insert in an empty list.
   1382           *
   1383           *               OS_PEND_LIST
   1384           *               +---------------+
   1385           *               | TailPtr       |-> 0
   1386           *               +---------------+
   1387           *               | HeadPtr       |-> 0
   1388           *               +---------------+
   1389           *               | NbrEntries=0  |
   1390           *               +---------------+
   1391           *
   1392           *           CASE 1: Insert BEFORE or AFTER an OS_TCB
   1393           *
   1394           *               OS_PEND_LIST
   1395           *               +--------------+      OS_TCB
   1396           *               | TailPtr      |-+--> +--------------+
   1397           *               +--------------+ |    | PendNextPtr  |->0
   1398           *               | HeadPtr      |-/    +--------------+
   1399           *               +--------------+   0<-| PendPrevPtr  |
   1400           *               | NbrEntries=1 |      +--------------+
   1401           *               +--------------+      |              |
   1402           *                                     +--------------+
   1403           *                                     |              |
   1404           *                                     +--------------+
   1405           *
   1406           *               OS_PEND_LIST
   1407           *               +--------------+
   1408           *               | TailPtr      |---------------------------------------------+
   1409           *               +--------------+      OS_TCB               OS_TCB            |    OS_TCB
   1410           *               | HeadPtr      |----> +--------------+     +--------------+  +-> +--------------+
   1411           *               +--------------+      | PendNextPtr  |<----| PendNextPtr  | .... | PendNextPtr  |->0
   1412           *               | NbrEntries=N |      +--------------+     +--------------+      +--------------+
   1413           *               +--------------+   0<-| PendPrevPtr  |<----| PendPrevPtr  | .... | PendPrevPtr  |
   1414           *                                     +--------------+     +--------------+      +--------------+
   1415           *                                     |              |     |              |      |              |
   1416           *                                     +--------------+     +--------------+      +--------------+
   1417           *                                     |              |     |              |      |              |
   1418           *                                     +--------------+     +--------------+      +--------------+
   1419           *           @endverbatim
   1420           *
   1421           * @param    p_pend_list     Pointer to the OS_PEND_LIST where the OS_TCB entry will be inserted.
   1422           *
   1423           * @param    p_tcb           The OS_TCB to insert in the list.
   1424           *
   1425           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1426           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1427          void OS_PendListInsertPrio(OS_PEND_LIST *p_pend_list,
   1428                                     OS_TCB       *p_tcb)
   1429          {
   \                     OS_PendListInsertPrio: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0002             MOVS     R2,R0
   1430            OS_PRIO prio;
   1431            OS_TCB  *p_tcb_next;
   1432          
   1433            prio = p_tcb->Prio;                                           // Obtain the priority of the task to insert
   \        0x4   0xF891 0x4027      LDRB     R4,[R1, #+39]
   1434          
   1435            if (p_pend_list->HeadPtr == DEF_NULL) {                       // CASE 0: Insert when there are no entries
   \        0x8   0x6813             LDR      R3,[R2, #+0]
   \        0xA   0x2B00             CMP      R3,#+0
   \        0xC   0xD106             BNE.N    ??OS_PendListInsertPrio_0
   1436          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1437              p_pend_list->NbrEntries = 1u;                               // This is the first entry
   1438          #endif
   1439              p_tcb->PendNextPtr = DEF_NULL;                              // No other OS_TCBs in the list
   \        0xE   0x2300             MOVS     R3,#+0
   \       0x10   0x618B             STR      R3,[R1, #+24]
   1440              p_tcb->PendPrevPtr = DEF_NULL;
   \       0x12   0x2300             MOVS     R3,#+0
   \       0x14   0x61CB             STR      R3,[R1, #+28]
   1441              p_pend_list->HeadPtr = p_tcb;
   \       0x16   0x6011             STR      R1,[R2, #+0]
   1442              p_pend_list->TailPtr = p_tcb;
   \       0x18   0x6051             STR      R1,[R2, #+4]
   \       0x1A   0xE024             B.N      ??OS_PendListInsertPrio_1
   1443            } else {
   1444          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1445              p_pend_list->NbrEntries++;                                  // CASE 1: One more OS_TCBs in the list
   1446          #endif
   1447              p_tcb_next = p_pend_list->HeadPtr;
   \                     ??OS_PendListInsertPrio_0: (+1)
   \       0x1C   0x6813             LDR      R3,[R2, #+0]
   \       0x1E   0x0018             MOVS     R0,R3
   1448              while (p_tcb_next != DEF_NULL) {                            // Find the position where to insert
   \                     ??OS_PendListInsertPrio_2: (+1)
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD007             BEQ.N    ??OS_PendListInsertPrio_3
   1449                if (prio < p_tcb_next->Prio) {
   \       0x24   0x0025             MOVS     R5,R4
   \       0x26   0xF890 0x3027      LDRB     R3,[R0, #+39]
   \       0x2A   0xB2ED             UXTB     R5,R5
   \       0x2C   0x429D             CMP      R5,R3
   \       0x2E   0xD301             BCC.N    ??OS_PendListInsertPrio_3
   1450                  break;                                                  // Found! ... insert BEFORE current
   1451                } else {
   1452                  p_tcb_next = p_tcb_next->PendNextPtr;                   // Not Found, follow the list
   \                     ??OS_PendListInsertPrio_4: (+1)
   \       0x30   0x6980             LDR      R0,[R0, #+24]
   \       0x32   0xE7F5             B.N      ??OS_PendListInsertPrio_2
   1453                }
   1454              }
   1455              if (p_tcb_next == DEF_NULL) {                               // TCB to insert is lowest in priority
   \                     ??OS_PendListInsertPrio_3: (+1)
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD107             BNE.N    ??OS_PendListInsertPrio_5
   1456                p_tcb->PendNextPtr = DEF_NULL;                            // ... insert at the tail.
   \       0x38   0x2300             MOVS     R3,#+0
   \       0x3A   0x618B             STR      R3,[R1, #+24]
   1457                p_tcb->PendPrevPtr = p_pend_list->TailPtr;
   \       0x3C   0x6853             LDR      R3,[R2, #+4]
   \       0x3E   0x61CB             STR      R3,[R1, #+28]
   1458                p_tcb->PendPrevPtr->PendNextPtr = p_tcb;
   \       0x40   0x69CB             LDR      R3,[R1, #+28]
   \       0x42   0x6199             STR      R1,[R3, #+24]
   1459                p_pend_list->TailPtr = p_tcb;
   \       0x44   0x6051             STR      R1,[R2, #+4]
   \       0x46   0xE00E             B.N      ??OS_PendListInsertPrio_1
   1460              } else {
   1461                if (p_tcb_next->PendPrevPtr == DEF_NULL) {                // Is new TCB highest priority?
   \                     ??OS_PendListInsertPrio_5: (+1)
   \       0x48   0x69C3             LDR      R3,[R0, #+28]
   \       0x4A   0x2B00             CMP      R3,#+0
   \       0x4C   0xD105             BNE.N    ??OS_PendListInsertPrio_6
   1462                  p_tcb->PendNextPtr = p_tcb_next;                        // Yes, insert as new Head of list
   \       0x4E   0x6188             STR      R0,[R1, #+24]
   1463                  p_tcb->PendPrevPtr = DEF_NULL;
   \       0x50   0x2300             MOVS     R3,#+0
   \       0x52   0x61CB             STR      R3,[R1, #+28]
   1464                  p_tcb_next->PendPrevPtr = p_tcb;
   \       0x54   0x61C1             STR      R1,[R0, #+28]
   1465                  p_pend_list->HeadPtr = p_tcb;
   \       0x56   0x6011             STR      R1,[R2, #+0]
   \       0x58   0xE005             B.N      ??OS_PendListInsertPrio_1
   1466                } else {                                                  // No, insert in between two entries
   1467                  p_tcb->PendNextPtr = p_tcb_next;
   \                     ??OS_PendListInsertPrio_6: (+1)
   \       0x5A   0x6188             STR      R0,[R1, #+24]
   1468                  p_tcb->PendPrevPtr = p_tcb_next->PendPrevPtr;
   \       0x5C   0x69C3             LDR      R3,[R0, #+28]
   \       0x5E   0x61CB             STR      R3,[R1, #+28]
   1469                  p_tcb->PendPrevPtr->PendNextPtr = p_tcb;
   \       0x60   0x69CB             LDR      R3,[R1, #+28]
   \       0x62   0x6199             STR      R1,[R3, #+24]
   1470                  p_tcb_next->PendPrevPtr = p_tcb;
   \       0x64   0x61C1             STR      R1,[R0, #+28]
   1471                }
   1472              }
   1473            }
   1474          }
   \                     ??OS_PendListInsertPrio_1: (+1)
   \       0x66   0xBC30             POP      {R4,R5}
   \       0x68   0x4770             BX       LR
   1475          
   1476          /****************************************************************************************************//**
   1477           *                                           OS_PendListRemove()
   1478           *
   1479           * @brief    This function is called to remove a task from a pend list knowing its TCB.
   1480           *           @verbatim
   1481           *           CASE 0: OS_PEND_LIST list is empty, nothing to do.
   1482           *
   1483           *           CASE 1: Only 1 OS_TCB in the list.
   1484           *
   1485           *               OS_PEND_LIST
   1486           *               +--------------+      OS_TCB
   1487           *               | TailPtr      |-+--> +--------------+
   1488           *               +--------------+ |    | PendNextPtr  |->0
   1489           *               | HeadPtr      |-/    +--------------+
   1490           *               +--------------+   0<-| PendPrevPtr  |
   1491           *               | NbrEntries=1 |      +--------------+
   1492           *               +--------------+      |              |
   1493           *                                     +--------------+
   1494           *                                     |              |
   1495           *                                     +--------------+
   1496           *
   1497           *           CASE N: Two or more OS_TCBs in the list.
   1498           *
   1499           *               OS_PEND_LIST
   1500           *               +--------------+
   1501           *               | TailPtr      |---------------------------------------------+
   1502           *               +--------------+      OS_TCB               OS_TCB            |   OS_TCB
   1503           *               | HeadPtr      |----> +--------------+     +--------------+  +-> +--------------+
   1504           *               +--------------+      | PendNextPtr  |<----| PendNextPtr  | .... | PendNextPtr  |->0
   1505           *               | NbrEntries=N |      +--------------+     +--------------+      +--------------+
   1506           *               +--------------+   0<-| PendPrevPtr  |<----| PendPrevPtr  | .... | PendPrevPtr  |
   1507           *                                     +--------------+     +--------------+      +--------------+
   1508           *                                     |              |     |              |      |              |
   1509           *                                     +--------------+     +--------------+      +--------------+
   1510           *                                     |              |     |              |      |              |
   1511           *                                     +--------------+     +--------------+      +--------------+
   1512           *           @endverbatim
   1513           * @param    p_tcb   Pointer to the TCB of the task to remove from the pend list.
   1514           *
   1515           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1516           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1517          void OS_PendListRemove(OS_TCB *p_tcb)
   1518          {
   \                     OS_PendListRemove: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1519            OS_PEND_LIST *p_pend_list;
   1520            OS_TCB       *p_next;
   1521            OS_TCB       *p_prev;
   1522          
   1523            if (p_tcb->PendObjPtr != DEF_NULL) {                          // Only remove if object has a pend list.
   \        0x2   0x6A01             LDR      R1,[R0, #+32]
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD029             BEQ.N    ??OS_PendListRemove_0
   1524              p_pend_list = &p_tcb->PendObjPtr->PendList;                 // Get pointer to pend list
   \        0x8   0x6A01             LDR      R1,[R0, #+32]
   \        0xA   0x1D09             ADDS     R1,R1,#+4
   \        0xC   0x000A             MOVS     R2,R1
   1525          
   1526              // Remove TCB from the pend list.
   1527              if (p_pend_list->HeadPtr->PendNextPtr == DEF_NULL) {
   \        0xE   0x6811             LDR      R1,[R2, #+0]
   \       0x10   0x6989             LDR      R1,[R1, #+24]
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD104             BNE.N    ??OS_PendListRemove_1
   1528                p_pend_list->HeadPtr = DEF_NULL;                          // Only one entry in the pend list
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x6011             STR      R1,[R2, #+0]
   1529                p_pend_list->TailPtr = DEF_NULL;
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x6051             STR      R1,[R2, #+4]
   \       0x1E   0xE017             B.N      ??OS_PendListRemove_2
   1530              } else if (p_tcb->PendPrevPtr == DEF_NULL) {                // See if entry is at the head of the list
   \                     ??OS_PendListRemove_1: (+1)
   \       0x20   0x69C1             LDR      R1,[R0, #+28]
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD105             BNE.N    ??OS_PendListRemove_3
   1531                p_next = p_tcb->PendNextPtr;                              // Yes
   \       0x26   0x6981             LDR      R1,[R0, #+24]
   \       0x28   0x000B             MOVS     R3,R1
   1532                p_next->PendPrevPtr = DEF_NULL;
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x61D9             STR      R1,[R3, #+28]
   1533                p_pend_list->HeadPtr = p_next;
   \       0x2E   0x6013             STR      R3,[R2, #+0]
   \       0x30   0xE00E             B.N      ??OS_PendListRemove_2
   1534              } else if (p_tcb->PendNextPtr == DEF_NULL) {                // See if entry is at the tail of the list
   \                     ??OS_PendListRemove_3: (+1)
   \       0x32   0x6981             LDR      R1,[R0, #+24]
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xD105             BNE.N    ??OS_PendListRemove_4
   1535                p_prev = p_tcb->PendPrevPtr;                              // Yes
   \       0x38   0x69C1             LDR      R1,[R0, #+28]
   \       0x3A   0x000C             MOVS     R4,R1
   1536                p_prev->PendNextPtr = DEF_NULL;
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x61A1             STR      R1,[R4, #+24]
   1537                p_pend_list->TailPtr = p_prev;
   \       0x40   0x6054             STR      R4,[R2, #+4]
   \       0x42   0xE005             B.N      ??OS_PendListRemove_2
   1538              } else {
   1539                p_prev = p_tcb->PendPrevPtr;                              // Remove from inside the list
   \                     ??OS_PendListRemove_4: (+1)
   \       0x44   0x69C1             LDR      R1,[R0, #+28]
   \       0x46   0x000C             MOVS     R4,R1
   1540                p_next = p_tcb->PendNextPtr;
   \       0x48   0x6981             LDR      R1,[R0, #+24]
   \       0x4A   0x000B             MOVS     R3,R1
   1541                p_prev->PendNextPtr = p_next;
   \       0x4C   0x61A3             STR      R3,[R4, #+24]
   1542                p_next->PendPrevPtr = p_prev;
   \       0x4E   0x61DC             STR      R4,[R3, #+28]
   1543              }
   1544          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1545              p_pend_list->NbrEntries--;                                  // One less entry in the list
   1546          #endif
   1547              p_tcb->PendNextPtr = DEF_NULL;
   \                     ??OS_PendListRemove_2: (+1)
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x6181             STR      R1,[R0, #+24]
   1548              p_tcb->PendPrevPtr = DEF_NULL;
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x61C1             STR      R1,[R0, #+28]
   1549              p_tcb->PendObjPtr = DEF_NULL;
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0x6201             STR      R1,[R0, #+32]
   1550            }
   1551          }
   \                     ??OS_PendListRemove_0: (+1)
   \       0x5C   0xBC10             POP      {R4}
   \       0x5E   0x4770             BX       LR
   1552          
   1553          /****************************************************************************************************//**
   1554           *                                                   OS_Post()
   1555           *
   1556           * @brief    This function is called to post to a task. This function exist because it is common to a
   1557           *           number of OSxxxPost() services.
   1558           *
   1559           * @param    p_obj       Pointer to the object being posted to. If there are no object posted to
   1560           *                       then the caller must pass a NULL pointer.
   1561           *
   1562           * @param    p_tcb       Pointer to the OS_TCB that will receive the 'post'.
   1563           *
   1564           * @param    p_void      If we are posting a message to a task, this is the message that the task
   1565           *                       will receive.
   1566           *
   1567           * @param    msg_size    If we are posting a message to a task, this is the size of the message.
   1568           *
   1569           * @param    ts          The timestamp as to when the post occurred.
   1570           *
   1571           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1572           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1573          void OS_Post(OS_PEND_OBJ *p_obj,
   1574                       OS_TCB      *p_tcb,
   1575                       void        *p_void,
   1576                       OS_MSG_SIZE msg_size,
   1577                       CPU_TS      ts)
   1578          {
   \                     OS_Post: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   1579          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1580            sl_status_t status;
   1581          #endif
   1582          
   1583          #if (OS_CFG_TS_EN == DEF_DISABLED)
   1584            (void)ts;                                                     // Prevent compiler warning for not using 'ts'
   1585          #endif
   1586          #if (OS_MSG_EN == DEF_DISABLED)
   1587            (void)msg_size;                                               // Prevent compiler warning for not using 'msg_size'
   1588          #endif
   1589          #if (OS_MSG_EN == DEF_DISABLED)
   1590            (void)p_void;                                                 // Prevent compiler warning for not using 'p_void'
   1591          #endif
   1592          
   1593            switch (p_tcb->TaskState) {
   \        0xC   0xF896 0x1026      LDRB     R1,[R6, #+38]
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0x2901             CMP      R1,#+1
   \       0x14   0xD90B             BLS.N    ??OS_Post_0
   \       0x16   0x1E89             SUBS     R1,R1,#+2
   \       0x18   0x2901             CMP      R1,#+1
   \       0x1A   0xD909             BLS.N    ??OS_Post_1
   \       0x1C   0x1E89             SUBS     R1,R1,#+2
   \       0x1E   0x2901             CMP      R1,#+1
   \       0x20   0xD905             BLS.N    ??OS_Post_0
   \       0x22   0x1E89             SUBS     R1,R1,#+2
   \       0x24   0x2901             CMP      R1,#+1
   \       0x26   0xD925             BLS.N    ??OS_Post_2
   \       0x28   0x39F9             SUBS     R1,R1,#+249
   \       0x2A   0xD042             BEQ.N    ??OS_Post_3
   \       0x2C   0xE042             B.N      ??OS_Post_4
   1594              case OS_TASK_STATE_RDY:                                     // Cannot Post a task that is ready
   1595              case OS_TASK_STATE_DLY:                                     // Cannot Post a task that is delayed
   1596              case OS_TASK_STATE_SUSPENDED:                               // Cannot Post a suspended task
   1597              case OS_TASK_STATE_DLY_SUSPENDED:                           // Cannot Post a suspended task that was also dly'd
   1598                break;
   \                     ??OS_Post_0: (+1)
   \       0x2E   0xE043             B.N      ??OS_Post_5
   1599          
   1600              case OS_TASK_STATE_PEND:
   1601              case OS_TASK_STATE_PEND_TIMEOUT:
   1602          #if (OS_MSG_EN == DEF_ENABLED)
   1603                p_tcb->MsgPtr = p_void;                                   // Deposit message in OS_TCB of task waiting
   \                     ??OS_Post_1: (+1)
   \       0x30   0x6677             STR      R7,[R6, #+100]
   1604                p_tcb->MsgSize = msg_size;                                // ... assuming posting a message
   \       0x32   0xF8A6 0x8068      STRH     R8,[R6, #+104]
   1605          #endif
   1606          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1607                p_tcb->TS = ts;
   1608          #endif
   1609                if (p_obj != DEF_NULL) {
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD002             BEQ.N    ??OS_Post_6
   1610                  OS_PendListRemove(p_tcb);                               // Remove task from pend list
   \       0x3A   0x0030             MOVS     R0,R6
   \       0x3C   0x.... 0x....      BL       OS_PendListRemove
   1611                }
   1612          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1613                OS_PendDbgNameRemove(p_obj,
   1614                                     p_tcb);
   1615          #endif
   1616          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1617                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \                     ??OS_Post_6: (+1)
   \       0x40   0xF896 0x0026      LDRB     R0,[R6, #+38]
   \       0x44   0x2803             CMP      R0,#+3
   \       0x46   0xD108             BNE.N    ??OS_Post_7
   1618                  status = sl_sleeptimer_stop_timer(&p_tcb->TimerHandle);
   \       0x48   0xF116 0x0044      ADDS     R0,R6,#+68
   \       0x4C   0x.... 0x....      BL       sl_sleeptimer_stop_timer
   \       0x50   0x0005             MOVS     R5,R0
   1619                  RTOS_ASSERT_CRITICAL((status == SL_STATUS_OK), RTOS_ERR_FAIL,; );
   \       0x52   0x2D00             CMP      R5,#+0
   \       0x54   0xD001             BEQ.N    ??OS_Post_7
   \       0x56   0x.... 0x....      BL       CPU_SW_Exception
   1620                }
   1621          #endif
   1622                OS_RdyListInsert(p_tcb);                                  // Insert the task in the ready list
   \                     ??OS_Post_7: (+1)
   \       0x5A   0x0030             MOVS     R0,R6
   \       0x5C   0x.... 0x....      BL       OS_RdyListInsert
   1623                p_tcb->TaskState = OS_TASK_STATE_RDY;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xF886 0x0026      STRB     R0,[R6, #+38]
   1624                p_tcb->PendStatus = OS_STATUS_PEND_OK;                    // Clear pend status
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xF886 0x0025      STRB     R0,[R6, #+37]
   1625                p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;                  // Indicate no longer pending
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xF886 0x0024      STRB     R0,[R6, #+36]
   1626                break;
   \       0x72   0xE021             B.N      ??OS_Post_5
   1627          
   1628              case OS_TASK_STATE_PEND_SUSPENDED:
   1629              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1630          #if (OS_MSG_EN == DEF_ENABLED)
   1631                p_tcb->MsgPtr = p_void;                                   // Deposit message in OS_TCB of task waiting
   \                     ??OS_Post_2: (+1)
   \       0x74   0x6677             STR      R7,[R6, #+100]
   1632                p_tcb->MsgSize = msg_size;                                // ... assuming posting a message
   \       0x76   0xF8A6 0x8068      STRH     R8,[R6, #+104]
   1633          #endif
   1634          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1635                p_tcb->TS = ts;
   1636          #endif
   1637                if (p_obj != DEF_NULL) {
   \       0x7A   0x2C00             CMP      R4,#+0
   \       0x7C   0xD002             BEQ.N    ??OS_Post_8
   1638                  OS_PendListRemove(p_tcb);                               // Remove from pend list
   \       0x7E   0x0030             MOVS     R0,R6
   \       0x80   0x.... 0x....      BL       OS_PendListRemove
   1639                }
   1640          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1641                OS_PendDbgNameRemove(p_obj,
   1642                                     p_tcb);
   1643          #endif
   1644          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   1645                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
   \                     ??OS_Post_8: (+1)
   \       0x84   0xF896 0x0026      LDRB     R0,[R6, #+38]
   \       0x88   0x2807             CMP      R0,#+7
   \       0x8A   0xD108             BNE.N    ??OS_Post_9
   1646                  status = sl_sleeptimer_stop_timer(&p_tcb->TimerHandle);
   \       0x8C   0xF116 0x0044      ADDS     R0,R6,#+68
   \       0x90   0x.... 0x....      BL       sl_sleeptimer_stop_timer
   \       0x94   0x0005             MOVS     R5,R0
   1647                  RTOS_ASSERT_CRITICAL((status == SL_STATUS_OK), RTOS_ERR_FAIL,; );
   \       0x96   0x2D00             CMP      R5,#+0
   \       0x98   0xD001             BEQ.N    ??OS_Post_9
   \       0x9A   0x.... 0x....      BL       CPU_SW_Exception
   1648                }
   1649          #endif
   1650                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_Post_9: (+1)
   \       0x9E   0x2004             MOVS     R0,#+4
   \       0xA0   0xF886 0x0026      STRB     R0,[R6, #+38]
   1651                p_tcb->PendStatus = OS_STATUS_PEND_OK;                    // Clear pend status
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0xF886 0x0025      STRB     R0,[R6, #+37]
   1652                p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;                  // Indicate no longer pending
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xF886 0x0024      STRB     R0,[R6, #+36]
   1653                break;
   \       0xB0   0xE002             B.N      ??OS_Post_5
   1654          
   1655              case OS_TASK_STATE_DEL:
   1656          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
   1657                break;
   \                     ??OS_Post_3: (+1)
   \       0xB2   0xE001             B.N      ??OS_Post_5
   1658          #endif
   1659          
   1660              default:
   1661                RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_OS,; );
   \                     ??OS_Post_4: (+1)
   \       0xB4   0x.... 0x....      BL       CPU_SW_Exception
   1662            }
   1663          }
   \                     ??OS_Post_5: (+1)
   \       0xB8   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1664          
   1665          /****************************************************************************************************//**
   1666           *                                               OS_RdyListInit()
   1667           *
   1668           * @brief    This function is called by OSInit() to initialize the ready list. The ready list contains
   1669           *           a list of all the tasks that are ready to run. The list is actually an array of OS_RDY_LIST.
   1670           *           An OS_RDY_LIST contains three fields. The number of OS_TCBs in the list (i.e. .NbrEntries),
   1671           *           a pointer to the first OS_TCB in the OS_RDY_LIST (i.e. .HeadPtr) and a pointer to the last
   1672           *           OS_TCB in the OS_RDY_LIST (i.e. .TailPtr).
   1673           *           @n
   1674           *           OS_TCBs are doubly linked in the OS_RDY_LIST and each OS_TCB points back to the OS_RDY_LIST
   1675           *           it belongs to.
   1676           *           @n
   1677           *           'OS_RDY_LIST  OSRdyTbl[OS_CFG_PRIO_MAX]'  looks like this once initialized:
   1678           *           @verbatim
   1679           *                                   +---------------+--------------+
   1680           *                                   |               | TailPtr      |-----> 0
   1681           *                              [0]  | NbrEntries=0  +--------------+
   1682           *                                   |               | HeadPtr      |-----> 0
   1683           *                                   +---------------+--------------+
   1684           *                                   |               | TailPtr      |-----> 0
   1685           *                              [1]  | NbrEntries=0  +--------------+
   1686           *                                   |               | HeadPtr      |-----> 0
   1687           *                                   +---------------+--------------+
   1688           *                                           :              :
   1689           *                                           :              :
   1690           *                                           :              :
   1691           *                                   +---------------+--------------+
   1692           *                                   |               | TailPtr      |-----> 0
   1693           *               [OS_CFG_PRIO_MAX-1]  | NbrEntries=0  +--------------+
   1694           *                                   |               | HeadPtr      |-----> 0
   1695           *                                   +---------------+--------------+
   1696           *           @endverbatim
   1697           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1698           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1699          void OS_RdyListInit(void)
   1700          {
   1701            CPU_INT32U  i;
   1702            OS_RDY_LIST *p_rdy_list;
   1703          
   1704            for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                      // Initialize the array of OS_RDY_LIST at each priority
   \                     OS_RdyListInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \                     ??OS_RdyListInit_0: (+1)
   \        0x2   0x2940             CMP      R1,#+64
   \        0x4   0xD209             BCS.N    ??OS_RdyListInit_1
   1705              p_rdy_list = &OSRdyList[i];
   \        0x6   0x....             LDR.N    R2,??DataTable17_31
   \        0x8   0xEB02 0x02C1      ADD      R2,R2,R1, LSL #+3
   \        0xC   0x0010             MOVS     R0,R2
   1706          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1707              p_rdy_list->NbrEntries = 0u;
   1708          #endif
   1709              p_rdy_list->HeadPtr = DEF_NULL;
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x6002             STR      R2,[R0, #+0]
   1710              p_rdy_list->TailPtr = DEF_NULL;
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x6042             STR      R2,[R0, #+4]
   1711            }
   \       0x16   0x1C49             ADDS     R1,R1,#+1
   \       0x18   0xE7F3             B.N      ??OS_RdyListInit_0
   1712          }
   \                     ??OS_RdyListInit_1: (+1)
   \       0x1A   0x4770             BX       LR
   1713          
   1714          /****************************************************************************************************//**
   1715           *                                           OS_RdyListInsert()
   1716           *
   1717           * @brief    This function is called to insert a TCB in the ready list.
   1718           *
   1719           *           The TCB is inserted at the tail of the list if the priority of the TCB is the same as the
   1720           *           priority of the current task. The TCB is inserted at the head of the list if not.
   1721           *
   1722           * @param    p_tcb   Pointer to the TCB to insert into the ready list.
   1723           *
   1724           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1725           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1726          void OS_RdyListInsert(OS_TCB *p_tcb)
   1727          {
   \                     OS_RdyListInsert: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1728            OS_PrioInsert(p_tcb->Prio);
   \        0x4   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \        0x8   0x.... 0x....      BL       OS_PrioInsert
   1729            if (p_tcb->Prio == OSPrioCur) {                               // Are we readying a task at the same prio?
   \        0xC   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \       0x10   0x....             LDR.N    R1,??DataTable17_23
   \       0x12   0x7809             LDRB     R1,[R1, #+0]
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD103             BNE.N    ??OS_RdyListInsert_0
   1730              OS_RdyListInsertTail(p_tcb);                                // Yes, insert readied task at the end of the list
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       OS_RdyListInsertTail
   \       0x1E   0xE002             B.N      ??OS_RdyListInsert_1
   1731            } else {
   1732              OS_RdyListInsertHead(p_tcb);                                // No, insert readied task at the beginning of the list
   \                     ??OS_RdyListInsert_0: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       OS_RdyListInsertHead
   1733            }
   1734          
   1735            OS_TRACE_TASK_READY(p_tcb);
   1736          }
   \                     ??OS_RdyListInsert_1: (+1)
   \       0x26   0xBD10             POP      {R4,PC}
   1737          
   1738          /****************************************************************************************************//**
   1739           *                                           OS_RdyListInsertHead()
   1740           *
   1741           * @brief    This function is called to place an OS_TCB at the beginning of a linked list as follows:
   1742           *
   1743           *           CASE 0: Insert in an empty list.
   1744           *
   1745           *               OS_RDY_LIST
   1746           *               +--------------+
   1747           *               | TailPtr      |-> 0
   1748           *               +--------------+
   1749           *               | HeadPtr      |-> 0
   1750           *               +--------------+
   1751           *               | NbrEntries=0 |
   1752           *               +--------------+
   1753           *
   1754           *           CASE 1: Insert BEFORE the current head of list
   1755           *
   1756           *               OS_RDY_LIST
   1757           *               +--------------+      OS_TCB
   1758           *               | TailPtr      |-+--> +------------+
   1759           *               +--------------+ |    | NextPtr    |->0
   1760           *               | HeadPtr      |-/    +------------+
   1761           *               +--------------+   0<-| PrevPtr    |
   1762           *               | NbrEntries=1 |      +------------+
   1763           *               +--------------+      :            :
   1764           *                                     :            :
   1765           *                                     +------------+
   1766           *
   1767           *               OS_RDY_LIST
   1768           *               +--------------+
   1769           *               | TailPtr      |-----------------------------------------+
   1770           *               +--------------+      OS_TCB             OS_TCB          |   OS_TCB
   1771           *               | HeadPtr      |----> +------------+     +------------+  +-> +------------+
   1772           *               +--------------+      | NextPtr    |---->| NextPtr    | .... | NextPtr    |->0
   1773           *               | NbrEntries=N |      +------------+     +------------+      +------------+
   1774           *               +--------------+   0<-| PrevPtr    |<----| PrevPtr    | .... | PrevPtr    |
   1775           *                                     +------------+     +------------+      +------------+
   1776           *                                     :            :     :            :      :            :
   1777           *                                     :            :     :            :      :            :
   1778           *                                     +------------+     +------------+      +------------+
   1779           *
   1780           * @param    p_tcb   Pointer to the TCB to insert into the ready list.
   1781           *
   1782           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1783           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1784          void OS_RdyListInsertHead(OS_TCB *p_tcb)
   1785          {
   1786            OS_RDY_LIST *p_rdy_list;
   1787            OS_TCB      *p_tcb2;
   1788          
   1789            p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     OS_RdyListInsertHead: (+1)
   \        0x0   0x....             LDR.N    R3,??DataTable17_31
   \        0x2   0xF890 0x1027      LDRB     R1,[R0, #+39]
   \        0x6   0xEB03 0x03C1      ADD      R3,R3,R1, LSL #+3
   1790            if (p_rdy_list->HeadPtr == DEF_NULL) {                        // CASE 0: Insert when there are no entries
   \        0xA   0x6819             LDR      R1,[R3, #+0]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD106             BNE.N    ??OS_RdyListInsertHead_0
   1791          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1792              p_rdy_list->NbrEntries = 1u;                                // This is the first entry
   1793          #endif
   1794              p_tcb->NextPtr = DEF_NULL;                                  // No other OS_TCBs in the list
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x60C1             STR      R1,[R0, #+12]
   1795              p_tcb->PrevPtr = DEF_NULL;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6101             STR      R1,[R0, #+16]
   1796              p_rdy_list->HeadPtr = p_tcb;                                // Both list pointers point to this OS_TCB
   \       0x18   0x6018             STR      R0,[R3, #+0]
   1797              p_rdy_list->TailPtr = p_tcb;
   \       0x1A   0x6058             STR      R0,[R3, #+4]
   \       0x1C   0xE007             B.N      ??OS_RdyListInsertHead_1
   1798            } else {                                                      // CASE 1: Insert BEFORE the current head of list
   1799          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1800              p_rdy_list->NbrEntries++;                                   // One more OS_TCB in the list
   1801          #endif
   1802              p_tcb->NextPtr = p_rdy_list->HeadPtr;                       // Adjust new OS_TCBs links
   \                     ??OS_RdyListInsertHead_0: (+1)
   \       0x1E   0x6819             LDR      R1,[R3, #+0]
   \       0x20   0x60C1             STR      R1,[R0, #+12]
   1803              p_tcb->PrevPtr = DEF_NULL;
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x6101             STR      R1,[R0, #+16]
   1804              p_tcb2 = p_rdy_list->HeadPtr;                               // Adjust old head of list's links
   \       0x26   0x6819             LDR      R1,[R3, #+0]
   \       0x28   0x000A             MOVS     R2,R1
   1805              p_tcb2->PrevPtr = p_tcb;
   \       0x2A   0x6110             STR      R0,[R2, #+16]
   1806              p_rdy_list->HeadPtr = p_tcb;
   \       0x2C   0x6018             STR      R0,[R3, #+0]
   1807            }
   1808          }
   \                     ??OS_RdyListInsertHead_1: (+1)
   \       0x2E   0x4770             BX       LR
   1809          
   1810          /****************************************************************************************************//**
   1811           *                                           OS_RdyListInsertTail()
   1812           *
   1813           * @brief    This function is called to place an OS_TCB at the end of a linked list as follows:
   1814           *
   1815           *           CASE 0: Insert in an empty list.
   1816           *
   1817           *               OS_RDY_LIST
   1818           *               +--------------+
   1819           *               | TailPtr      |-> 0
   1820           *               +--------------+
   1821           *               | HeadPtr      |-> 0
   1822           *               +--------------+
   1823           *               | NbrEntries=0 |
   1824           *               +--------------+
   1825           *
   1826           *           CASE 1: Insert AFTER the current tail of list
   1827           *
   1828           *               OS_RDY_LIST
   1829           *               +--------------+      OS_TCB
   1830           *               | TailPtr      |-+--> +------------+
   1831           *               +--------------+ |    | NextPtr    |->0
   1832           *               | HeadPtr      |-/    +------------+
   1833           *               +--------------+   0<-| PrevPtr    |
   1834           *               | NbrEntries=1 |      +------------+
   1835           *               +--------------+      :            :
   1836           *                                     :            :
   1837           *                                     +------------+
   1838           *
   1839           *               OS_RDY_LIST
   1840           *               +--------------+
   1841           *               | TailPtr      |-----------------------------------------+
   1842           *               +--------------+      OS_TCB             OS_TCB          |   OS_TCB
   1843           *               | HeadPtr      |----> +------------+     +------------+  +-> +------------+
   1844           *               +--------------+      | NextPtr    |---->| NextPtr    | .... | NextPtr    |->0
   1845           *               | NbrEntries=N |      +------------+     +------------+      +------------+
   1846           *               +--------------+   0<-| PrevPtr    |<----| PrevPtr    | .... | PrevPtr    |
   1847           *                                     +------------+     +------------+      +------------+
   1848           *                                     :            :     :            :      :            :
   1849           *                                     :            :     :            :      :            :
   1850           *                                     +------------+     +------------+      +------------+
   1851           *
   1852           * @param    p_tcb   Pointer to the TCB to insert into the ready list.
   1853           *
   1854           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1855           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1856          void OS_RdyListInsertTail(OS_TCB *p_tcb)
   1857          {
   1858            OS_RDY_LIST *p_rdy_list;
   1859            OS_TCB      *p_tcb2;
   1860          
   1861            p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     OS_RdyListInsertTail: (+1)
   \        0x0   0x....             LDR.N    R3,??DataTable17_31
   \        0x2   0xF890 0x1027      LDRB     R1,[R0, #+39]
   \        0x6   0xEB03 0x03C1      ADD      R3,R3,R1, LSL #+3
   1862            if (p_rdy_list->HeadPtr == DEF_NULL) {                        // CASE 0: Insert when there are no entries
   \        0xA   0x6819             LDR      R1,[R3, #+0]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD106             BNE.N    ??OS_RdyListInsertTail_0
   1863          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1864              p_rdy_list->NbrEntries = 1u;                                // This is the first entry
   1865          #endif
   1866              p_tcb->NextPtr = DEF_NULL;                                  // No other OS_TCBs in the list
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x60C1             STR      R1,[R0, #+12]
   1867              p_tcb->PrevPtr = DEF_NULL;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6101             STR      R1,[R0, #+16]
   1868              p_rdy_list->HeadPtr = p_tcb;                                // Both list pointers point to this OS_TCB
   \       0x18   0x6018             STR      R0,[R3, #+0]
   1869              p_rdy_list->TailPtr = p_tcb;
   \       0x1A   0x6058             STR      R0,[R3, #+4]
   \       0x1C   0xE006             B.N      ??OS_RdyListInsertTail_1
   1870            } else {                                                      // CASE 1: Insert AFTER the current tail of list
   1871          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1872              p_rdy_list->NbrEntries++;                                   // One more OS_TCB in the list
   1873          #endif
   1874              p_tcb->NextPtr = DEF_NULL;                                  // Adjust new OS_TCBs links
   \                     ??OS_RdyListInsertTail_0: (+1)
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x60C1             STR      R1,[R0, #+12]
   1875              p_tcb2 = p_rdy_list->TailPtr;
   \       0x22   0x6859             LDR      R1,[R3, #+4]
   \       0x24   0x000A             MOVS     R2,R1
   1876              p_tcb->PrevPtr = p_tcb2;
   \       0x26   0x6102             STR      R2,[R0, #+16]
   1877              p_tcb2->NextPtr = p_tcb;                                    // Adjust old tail of list's links
   \       0x28   0x60D0             STR      R0,[R2, #+12]
   1878              p_rdy_list->TailPtr = p_tcb;
   \       0x2A   0x6058             STR      R0,[R3, #+4]
   1879            }
   1880          }
   \                     ??OS_RdyListInsertTail_1: (+1)
   \       0x2C   0x4770             BX       LR
   1881          
   1882          /****************************************************************************************************//**
   1883           *                                       OS_RdyListMoveHeadToTail()
   1884           *
   1885           * @brief    This function is called to move the current head of a list to the tail of the list.
   1886           *
   1887           *           CASE 0: TCB list is empty, nothing to do.
   1888           *
   1889           *           CASE 1: Only 1 OS_TCB  in the list, nothing to do.
   1890           *
   1891           *           CASE 2: Only 2 OS_TCBs in the list.
   1892           *
   1893           *               OS_RDY_LIST
   1894           *               +--------------+
   1895           *               | TailPtr      |----------------------+
   1896           *               +--------------+      OS_TCB          |   OS_TCB
   1897           *               | HeadPtr      |----> +------------+  +-> +------------+
   1898           *               +--------------+      | NextPtr    |----> | NextPtr    |->0
   1899           *               | NbrEntries=2 |      +------------+      +------------+
   1900           *               +--------------+   0<-| PrevPtr    | <----| PrevPtr    |
   1901           *                                     +------------+      +------------+
   1902           *                                     :            :      :            :
   1903           *                                     :            :      :            :
   1904           *                                     +------------+      +------------+
   1905           *
   1906           *           CASE N: More than 2 OS_TCBs in the list.
   1907           *
   1908           *               OS_RDY_LIST
   1909           *               +--------------+
   1910           *               | TailPtr      |-----------------------------------------+
   1911           *               +--------------+      OS_TCB             OS_TCB          |   OS_TCB
   1912           *               | HeadPtr      |----> +------------+     +------------+  +-> +------------+
   1913           *               +--------------+      | NextPtr    |---->| NextPtr    | .... | NextPtr    |->0
   1914           *               | NbrEntries=N |      +------------+     +------------+      +------------+
   1915           *               +--------------+   0<-| PrevPtr    |<----| PrevPtr    | .... | PrevPtr    |
   1916           *                                     +------------+     +------------+      +------------+
   1917           *                                     :            :     :            :      :            :
   1918           *                                     :            :     :            :      :            :
   1919           *                                     +------------+     +------------+      +------------+
   1920           *
   1921           * @param    p_list  Pointer to the OS_RDY_LIST where the OS_TCB will be moved.
   1922           *
   1923           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1924           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1925          void OS_RdyListMoveHeadToTail(OS_RDY_LIST *p_rdy_list)
   1926          {
   \                     OS_RdyListMoveHeadToTail: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   1927            OS_TCB *p_tcb1;
   1928            OS_TCB *p_tcb2;
   1929            OS_TCB *p_tcb3;
   1930          
   1931            if (p_rdy_list->HeadPtr != p_rdy_list->TailPtr) {
   \        0x2   0x6805             LDR      R5,[R0, #+0]
   \        0x4   0x6844             LDR      R4,[R0, #+4]
   \        0x6   0x42A5             CMP      R5,R4
   \        0x8   0xD01F             BEQ.N    ??OS_RdyListMoveHeadToTail_0
   1932              if (p_rdy_list->HeadPtr->NextPtr == p_rdy_list->TailPtr) {  // SWAP the TCBs
   \        0xA   0x6804             LDR      R4,[R0, #+0]
   \        0xC   0x68E5             LDR      R5,[R4, #+12]
   \        0xE   0x6844             LDR      R4,[R0, #+4]
   \       0x10   0x42A5             CMP      R5,R4
   \       0x12   0xD10C             BNE.N    ??OS_RdyListMoveHeadToTail_1
   1933                p_tcb1 = p_rdy_list->HeadPtr;                             // Point to current head
   \       0x14   0x6804             LDR      R4,[R0, #+0]
   \       0x16   0x0021             MOVS     R1,R4
   1934                p_tcb2 = p_rdy_list->TailPtr;                             // Point to current tail
   \       0x18   0x6844             LDR      R4,[R0, #+4]
   \       0x1A   0x0022             MOVS     R2,R4
   1935                p_tcb1->PrevPtr = p_tcb2;
   \       0x1C   0x610A             STR      R2,[R1, #+16]
   1936                p_tcb1->NextPtr = DEF_NULL;
   \       0x1E   0x2400             MOVS     R4,#+0
   \       0x20   0x60CC             STR      R4,[R1, #+12]
   1937                p_tcb2->PrevPtr = DEF_NULL;
   \       0x22   0x2400             MOVS     R4,#+0
   \       0x24   0x6114             STR      R4,[R2, #+16]
   1938                p_tcb2->NextPtr = p_tcb1;
   \       0x26   0x60D1             STR      R1,[R2, #+12]
   1939                p_rdy_list->HeadPtr = p_tcb2;
   \       0x28   0x6002             STR      R2,[R0, #+0]
   1940                p_rdy_list->TailPtr = p_tcb1;
   \       0x2A   0x6041             STR      R1,[R0, #+4]
   \       0x2C   0xE00D             B.N      ??OS_RdyListMoveHeadToTail_0
   1941              } else {
   1942                p_tcb1 = p_rdy_list->HeadPtr;                             // Point to current head
   \                     ??OS_RdyListMoveHeadToTail_1: (+1)
   \       0x2E   0x6804             LDR      R4,[R0, #+0]
   \       0x30   0x0021             MOVS     R1,R4
   1943                p_tcb2 = p_rdy_list->TailPtr;                             // Point to current tail
   \       0x32   0x6844             LDR      R4,[R0, #+4]
   \       0x34   0x0022             MOVS     R2,R4
   1944                p_tcb3 = p_tcb1->NextPtr;                                 // Point to new list head
   \       0x36   0x68CC             LDR      R4,[R1, #+12]
   \       0x38   0x0023             MOVS     R3,R4
   1945                p_tcb3->PrevPtr = DEF_NULL;                               // Adjust back    link of new list head
   \       0x3A   0x2400             MOVS     R4,#+0
   \       0x3C   0x611C             STR      R4,[R3, #+16]
   1946                p_tcb1->NextPtr = DEF_NULL;                               // Adjust forward link of new list tail
   \       0x3E   0x2400             MOVS     R4,#+0
   \       0x40   0x60CC             STR      R4,[R1, #+12]
   1947                p_tcb1->PrevPtr = p_tcb2;                                 // Adjust back    link of new list tail
   \       0x42   0x610A             STR      R2,[R1, #+16]
   1948                p_tcb2->NextPtr = p_tcb1;                                 // Adjust forward link of old list tail
   \       0x44   0x60D1             STR      R1,[R2, #+12]
   1949                p_rdy_list->HeadPtr = p_tcb3;                             // Adjust new list head and tail pointers
   \       0x46   0x6003             STR      R3,[R0, #+0]
   1950                p_rdy_list->TailPtr = p_tcb1;
   \       0x48   0x6041             STR      R1,[R0, #+4]
   1951              }
   1952            }
   1953          }
   \                     ??OS_RdyListMoveHeadToTail_0: (+1)
   \       0x4A   0xBC30             POP      {R4,R5}
   \       0x4C   0x4770             BX       LR
   1954          
   1955          /****************************************************************************************************//**
   1956           *                                           OS_RdyListRemove()
   1957           *
   1958           * @brief    This function is called to remove an OS_TCB from an OS_RDY_LIST knowing the address of the
   1959           *           OS_TCB to remove.
   1960           *
   1961           *           CASE 0: TCB list is empty, nothing to do.
   1962           *
   1963           *           CASE 1: Only 1 OS_TCBs in the list.
   1964           *
   1965           *               OS_RDY_LIST
   1966           *               +--------------+      OS_TCB
   1967           *               | TailPtr      |-+--> +------------+
   1968           *               +--------------+ |    | NextPtr    |->0
   1969           *               | HeadPtr      |-/    +------------+
   1970           *               +--------------+   0<-| PrevPtr    |
   1971           *               | NbrEntries=1 |      +------------+
   1972           *               +--------------+      :            :
   1973           *                                     :            :
   1974           *                                     +------------+
   1975           *
   1976           *           CASE N: Two or more OS_TCBs in the list.
   1977           *
   1978           *               OS_RDY_LIST
   1979           *               +--------------+
   1980           *               | TailPtr      |-----------------------------------------+
   1981           *               +--------------+    OS_TCB               OS_TCB          |   OS_TCB
   1982           *               | HeadPtr      |----> +------------+     +------------+  +-> +------------+
   1983           *               +--------------+      | NextPtr    |---->| NextPtr    | .... | NextPtr    |->0
   1984           *               | NbrEntries=N |      +------------+     +------------+      +------------+
   1985           *               +--------------+   0<-| PrevPtr    |<----| PrevPtr    | .... | PrevPtr    |
   1986           *                                     +------------+     +------------+      +------------+
   1987           *                                     :            :     :            :      :            :
   1988           *                                     :            :     :            :      :            :
   1989           *                                     +------------+     +------------+      +------------+
   1990           *
   1991           * @param    p_tcb   Pointer to the OS_TCB to remove.
   1992           *
   1993           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   1994           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1995          void OS_RdyListRemove(OS_TCB *p_tcb)
   1996          {
   \                     OS_RdyListRemove: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   1997            OS_RDY_LIST *p_rdy_list;
   1998            OS_TCB      *p_tcb1;
   1999            OS_TCB      *p_tcb2;
   2000          
   2001            p_rdy_list = &OSRdyList[p_tcb->Prio];
   \        0x4   0x....             LDR.N    R1,??DataTable17_31
   \        0x6   0xF896 0x0027      LDRB     R0,[R6, #+39]
   \        0xA   0xEB01 0x07C0      ADD      R7,R1,R0, LSL #+3
   2002            p_tcb1 = p_tcb->PrevPtr;                                      // Point to next and previous OS_TCB in the list
   \        0xE   0x6935             LDR      R5,[R6, #+16]
   2003            p_tcb2 = p_tcb->NextPtr;
   \       0x10   0x68F4             LDR      R4,[R6, #+12]
   2004            if (p_tcb1 == DEF_NULL) {                                     // Was the OS_TCB to remove at the head?
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD10E             BNE.N    ??OS_RdyListRemove_0
   2005              if (p_tcb2 == DEF_NULL) {                                   // Yes, was it the only OS_TCB?
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD108             BNE.N    ??OS_RdyListRemove_1
   2006          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2007                p_rdy_list->NbrEntries = 0u;                              // Yes, no more entries
   2008          #endif
   2009                p_rdy_list->HeadPtr = DEF_NULL;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6038             STR      R0,[R7, #+0]
   2010                p_rdy_list->TailPtr = DEF_NULL;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6078             STR      R0,[R7, #+4]
   2011                OS_PrioRemove(p_tcb->Prio);
   \       0x22   0xF896 0x0027      LDRB     R0,[R6, #+39]
   \       0x26   0x.... 0x....      BL       OS_PrioRemove
   \       0x2A   0xE009             B.N      ??OS_RdyListRemove_2
   2012              } else {
   2013          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2014                p_rdy_list->NbrEntries--;                                 // No, one less entry
   2015          #endif
   2016                p_tcb2->PrevPtr = DEF_NULL;                               // adjust back link of new list head
   \                     ??OS_RdyListRemove_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x6120             STR      R0,[R4, #+16]
   2017                p_rdy_list->HeadPtr = p_tcb2;                             // adjust OS_RDY_LIST's new head
   \       0x30   0x603C             STR      R4,[R7, #+0]
   \       0x32   0xE005             B.N      ??OS_RdyListRemove_2
   2018              }
   2019            } else {
   2020          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2021              p_rdy_list->NbrEntries--;                                   // No, one less entry
   2022          #endif
   2023              p_tcb1->NextPtr = p_tcb2;
   \                     ??OS_RdyListRemove_0: (+1)
   \       0x34   0x60EC             STR      R4,[R5, #+12]
   2024              if (p_tcb2 == DEF_NULL) {
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD101             BNE.N    ??OS_RdyListRemove_3
   2025                p_rdy_list->TailPtr = p_tcb1;                             // Removing the TCB at the tail, adj the tail ptr
   \       0x3A   0x607D             STR      R5,[R7, #+4]
   \       0x3C   0xE000             B.N      ??OS_RdyListRemove_2
   2026              } else {
   2027                p_tcb2->PrevPtr = p_tcb1;
   \                     ??OS_RdyListRemove_3: (+1)
   \       0x3E   0x6125             STR      R5,[R4, #+16]
   2028              }
   2029            }
   2030            p_tcb->PrevPtr = DEF_NULL;
   \                     ??OS_RdyListRemove_2: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x6130             STR      R0,[R6, #+16]
   2031            p_tcb->NextPtr = DEF_NULL;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x60F0             STR      R0,[R6, #+12]
   2032          
   2033            OS_TRACE_TASK_SUSPENDED(p_tcb);
   2034          }
   \       0x48   0xBDF1             POP      {R0,R4-R7,PC}
   2035          
   2036          /****************************************************************************************************//**
   2037           *                                       OS_SchedLockTimeMeasStart()
   2038           *
   2039           * @brief    Start measuring the time the scheduler is locked.
   2040           *
   2041           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2042           *
   2043           * @note     (2) It's assumed that this function is called when interrupts are disabled.
   2044           *
   2045           * @note     (3) We are reading the CPU_TS_TmrRd() directly even if this is a 16-bit timer. The reason
   2046           *               is that we don't expect to have the scheduler locked for 65536 counts even at the rate
   2047           *               the TS timer is updated. In other words, locking the scheduler for longer than 65536
   2048           *               counts would not be a good thing for a real-time system.
   2049           *******************************************************************************************************/
   2050          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
   2051          void OS_SchedLockTimeMeasStart(void)
   2052          {
   2053            if (OSSchedLockNestingCtr == 1u) {
   2054              OSSchedLockTimeBegin = CPU_TS_TmrRd();
   2055            }
   2056          }
   2057          
   2058          /****************************************************************************************************//**
   2059           *                                       OS_SchedLockTimeMeasStop()
   2060           *
   2061           * @brief    Stop measuring the time the scheduler is locked and update the current and max locked
   2062           *           times.
   2063           *
   2064           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2065           *
   2066           * @note     (2) It's assumed that this function is called when interrupts are disabled.
   2067           *
   2068           * @note     (3) We are reading the CPU_TS_TmrRd() directly even if this is a 16-bit timer. The reason
   2069           *               is that we don't expect to have the scheduler locked for 65536 counts even at the rate
   2070           *               the TS timer is updated. In other words, locking the scheduler for longer than 65536
   2071           *               counts would not be a good thing for a real-time system.
   2072           *******************************************************************************************************/
   2073          void OS_SchedLockTimeMeasStop(void)
   2074          {
   2075            CPU_TS_TMR delta;
   2076          
   2077            if (OSSchedLockNestingCtr == 0u) {                            // Make sure we fully un-nested scheduler lock
   2078              delta = CPU_TS_TmrRd()                                      // Compute the delta time between begin and end
   2079                      - OSSchedLockTimeBegin;
   2080              if (OSSchedLockTimeMax < delta) {                           // Detect peak value
   2081                OSSchedLockTimeMax = delta;
   2082              }
   2083              if (OSSchedLockTimeMaxCur < delta) {                        // Detect peak value (for resettable value)
   2084                OSSchedLockTimeMaxCur = delta;
   2085              }
   2086            }
   2087          }
   2088          #endif
   2089          
   2090          /****************************************************************************************************//**
   2091           *                                           OS_SchedRoundRobin()
   2092           *
   2093           * @brief    This function is a callback for the task timer when operating in Round-Robin mode. It updates
   2094           *           the RdyList and reschedules the task.
   2095           *
   2096           * @param    handle   Handle to timer that expired.
   2097           *
   2098           * @param    data     TCB of the task that owns this timer
   2099           *
   2100           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2101           *******************************************************************************************************/
   2102          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
   2103          void OS_SchedRoundRobin(sl_sleeptimer_timer_handle_t *handle,
   2104                                  void                         *data)
   2105          {
   2106            OS_TCB *p_tcb = (OS_TCB *)data;
   2107            CORE_DECLARE_IRQ_STATE;
   2108          
   2109            PP_UNUSED_PARAM(handle);
   2110          
   2111            if (OSSchedRoundRobinEn != DEF_TRUE) {                        // Make sure round-robin has been enabled
   2112              return;
   2113            }
   2114          
   2115            CORE_ENTER_ATOMIC();
   2116            p_tcb->TimeQuantaCtr = 0u;
   2117            OS_RdyListMoveHeadToTail(&OSRdyList[OSRoundRobinCurTCB->Prio]);
   2118            CORE_EXIT_ATOMIC();
   2119          
   2120            OSSched();
   2121          }
   2122          
   2123          /*****************************************************************************************************//**
   2124           *                                          OS_SchedRoundRobinRestartTimer()
   2125           *
   2126           * @brief    Restart the Round-Robin timer, saving the TimeQuanta remaining if needed.
   2127           *
   2128           * @param    p_tcb     pointer to the TCB of the new task to round-robin
   2129           *
   2130           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2131           *
   2132           * @note     (2) Due to the sleeptimer's behavior and it blocking interrupts, we cannot rely on the
   2133           *               OSTCBCurPtr as being 100% accurate. OSRoundRobinCurTCB is used instead as the current
   2134           *               Task for the RoundRobin timer.
   2135           *******************************************************************************************************/
   2136          void OS_SchedRoundRobinRestartTimer(OS_TCB* p_tcb)
   2137          {
   2138            if (p_tcb == DEF_NULL) {
   2139              return;
   2140            }
   2141          
   2142            if (OSSchedRoundRobinEn != DEF_TRUE) {                        // Make sure round-robin has been enabled
   2143              return;
   2144            }
   2145          
   2146            sl_sleeptimer_start_timer(&OSRoundRobinTimer,
   2147                                      p_tcb->TimeQuantaCtr,
   2148                                      OS_SchedRoundRobin,
   2149                                      (void *)p_tcb,
   2150                                      0u,
   2151                                      0u);
   2152          
   2153            OSRoundRobinCurTCB = p_tcb;
   2154          }
   2155          
   2156          /*****************************************************************************************************//**
   2157           *                                          OS_SchedRoundRobinResetQuanta()
   2158           *
   2159           * @brief    Resets a task's TimeQuantaCtr
   2160           *
   2161           * @param    p_tcb     pointer to the TCB of the task
   2162           *
   2163           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2164           *******************************************************************************************************/
   2165          void OS_SchedRoundRobinResetQuanta(OS_TCB *p_tcb)
   2166          {
   2167            if (p_tcb == DEF_NULL) {
   2168              return;
   2169            }
   2170          
   2171            if (OSSchedRoundRobinEn != DEF_TRUE) {                        // Make sure round-robin has been enabled
   2172              return;
   2173            }
   2174          
   2175            if (p_tcb->TimeQuanta == 0u) {                                // See if we need to use the default time slice
   2176              p_tcb->TimeQuantaCtr = (uint64_t)(((uint64_t)OSSchedRoundRobinDfltTimeQuanta * (uint64_t)sl_sleeptimer_get_timer_frequency()) + (OSCfg_TickRate_Hz - 1u)) / OSCfg_TickRate_Hz;
   2177            } else {
   2178              p_tcb->TimeQuantaCtr = (uint64_t)(((uint64_t)p_tcb->TimeQuanta * (uint64_t)sl_sleeptimer_get_timer_frequency()) + (OSCfg_TickRate_Hz - 1u)) / OSCfg_TickRate_Hz;
   2179            }
   2180          }
   2181          
   2182          #endif
   2183          
   2184          /****************************************************************************************************//**
   2185           *                                               OS_TaskBlock()
   2186           *
   2187           * @brief    This function is called to remove a task from the ready list and also insert it in the
   2188           *           timer tick list if the specified timeout is non-zero.
   2189           *
   2190           * @param    p_tcb       Pointer to the OS_TCB of the task block.
   2191           *
   2192           * @param    timeout     The desired timeout.
   2193           *
   2194           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2195           *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2196          void OS_TaskBlock(OS_TCB  *p_tcb,
   2197                            OS_TICK timeout)
   2198          {
   \                     OS_TaskBlock: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   2199            if (timeout > 0u) {                                           // Add task to tick list if timeout non zero            */
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD024             BEQ.N    ??OS_TaskBlock_0
   2200          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   2201              sl_status_t status;
   2202          
   2203              uint32_t delay = (uint64_t)(((uint64_t)timeout * (uint64_t)sl_sleeptimer_get_timer_frequency()) + ((uint64_t)OSCfg_TickRate_Hz - 1u)) / OSCfg_TickRate_Hz;
   \        0xA   0x.... 0x....      BL       sl_sleeptimer_get_timer_frequency
   \        0xE   0x0002             MOVS     R2,R0
   \       0x10   0x....             LDR.N    R3,??DataTable17_13
   \       0x12   0x6818             LDR      R0,[R3, #+0]
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0xFBE2 0x0104      UMLAL    R0,R1,R2,R4
   \       0x1A   0x1E40             SUBS     R0,R0,#+1
   \       0x1C   0xF171 0x0100      SBCS     R1,R1,#+0
   \       0x20   0x681A             LDR      R2,[R3, #+0]
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x28   0x0007             MOVS     R7,R0
   2204              status = sl_sleeptimer_start_timer(&p_tcb->TimerHandle,
   2205                                                 delay,
   2206                                                 OS_TimerCallback,
   2207                                                 (void *)p_tcb,
   2208                                                 0u,
   2209                                                 0u);
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x9001             STR      R0,[SP, #+4]
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x9000             STR      R0,[SP, #+0]
   \       0x32   0x002B             MOVS     R3,R5
   \       0x34   0x.... 0x....      ADR.W    R2,OS_TimerCallback
   \       0x38   0x0039             MOVS     R1,R7
   \       0x3A   0xF115 0x0044      ADDS     R0,R5,#+68
   \       0x3E   0x.... 0x....      BL       sl_sleeptimer_start_timer
   \       0x42   0x0006             MOVS     R6,R0
   2210              RTOS_ASSERT_CRITICAL(status == SL_STATUS_OK, RTOS_ERR_FAIL,; );
   \       0x44   0x2E00             CMP      R6,#+0
   \       0x46   0xD001             BEQ.N    ??OS_TaskBlock_1
   \       0x48   0x.... 0x....      BL       CPU_SW_Exception
   2211          
   2212              p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   \                     ??OS_TaskBlock_1: (+1)
   \       0x4C   0x2003             MOVS     R0,#+3
   \       0x4E   0xF885 0x0026      STRB     R0,[R5, #+38]
   \       0x52   0xE002             B.N      ??OS_TaskBlock_2
   2213          #else
   2214              RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_FAIL,; );
   2215          #endif
   2216            } else {
   2217              p_tcb->TaskState = OS_TASK_STATE_PEND;
   \                     ??OS_TaskBlock_0: (+1)
   \       0x54   0x2002             MOVS     R0,#+2
   \       0x56   0xF885 0x0026      STRB     R0,[R5, #+38]
   2218            }
   2219          
   2220            OS_RdyListRemove(p_tcb);
   \                     ??OS_TaskBlock_2: (+1)
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0x.... 0x....      BL       OS_RdyListRemove
   2221          }
   \       0x60   0xBDF7             POP      {R0-R2,R4-R7,PC}
   2222          
   2223          #if (OS_CFG_TICK_EN == DEF_ENABLED)
   2224          /*****************************************************************************************************//**
   2225           *                                             OS_TimerCallback()
   2226           *
   2227           * @brief    Function called when a timer expires.
   2228           *
   2229           * @param    handle Handle to timer that expired.
   2230           *
   2231           * @param    data   Pointer caller specific data.
   2232           *
   2233           * @note     (1) This function is INTERNAL to the Kernel and your application MUST NOT call it.
   2234           *******************************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   2235          void OS_TimerCallback(sl_sleeptimer_timer_handle_t *handle,
   2236                                void                         *data)
   2237          {
   \                     OS_TimerCallback: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   2238            OS_TCB  *p_tcb = (OS_TCB *)data;
   \        0x8   0x46B8             MOV      R8,R7
   2239          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2240            OS_TCB  *p_tcb_owner;
   2241            OS_PRIO  prio_new;
   2242          #endif
   2243            PP_UNUSED_PARAM(handle);
   2244            CORE_DECLARE_IRQ_STATE;
   2245          
   2246            CORE_ENTER_ATOMIC();
   \        0xA   0x.... 0x....      BL       CORE_EnterAtomic
   \        0xE   0x4681             MOV      R9,R0
   2247            switch (p_tcb->TaskState) {
   \       0x10   0xF898 0x0026      LDRB     R0,[R8, #+38]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD057             BEQ.N    ??OS_TimerCallback_0
   \       0x18   0x2803             CMP      R0,#+3
   \       0x1A   0xD003             BEQ.N    ??OS_TimerCallback_1
   \       0x1C   0x2805             CMP      R0,#+5
   \       0x1E   0xD05A             BEQ.N    ??OS_TimerCallback_2
   \       0x20   0x2807             CMP      R0,#+7
   \       0x22   0xD15C             BNE.N    ??OS_TimerCallback_3
   2248              case OS_TASK_STATE_PEND_TIMEOUT:
   2249              case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2250          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2251                p_tcb_owner = DEF_NULL;
   \                     ??OS_TimerCallback_1: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0004             MOVS     R4,R0
   2252                if (p_tcb->PendOn == OS_TASK_PEND_ON_MUTEX) {
   \       0x28   0xF898 0x0024      LDRB     R0,[R8, #+36]
   \       0x2C   0x2804             CMP      R0,#+4
   \       0x2E   0xD103             BNE.N    ??OS_TimerCallback_4
   2253                  p_tcb_owner = ((OS_MUTEX *)p_tcb->PendObjPtr)->OwnerTCBPtr;
   \       0x30   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \       0x34   0x6900             LDR      R0,[R0, #+16]
   \       0x36   0x0004             MOVS     R4,R0
   2254                }
   2255          #endif
   2256          
   2257          #if (OS_MSG_EN == DEF_ENABLED)
   2258                p_tcb->MsgPtr = DEF_NULL;
   \                     ??OS_TimerCallback_4: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xF8C8 0x0064      STR      R0,[R8, #+100]
   2259                p_tcb->MsgSize = 0u;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xF8A8 0x0068      STRH     R0,[R8, #+104]
   2260          #endif
   2261          #if (OS_CFG_TS_EN == DEF_ENABLED)
   2262                p_tcb->TS = OS_TS_GET();
   2263          #endif
   2264                OS_PendListRemove(p_tcb);                                 /* Remove task from pend list                           */
   \       0x44   0x4640             MOV      R0,R8
   \       0x46   0x.... 0x....      BL       OS_PendListRemove
   2265                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \       0x4A   0xF898 0x0026      LDRB     R0,[R8, #+38]
   \       0x4E   0x2803             CMP      R0,#+3
   \       0x50   0xD106             BNE.N    ??OS_TimerCallback_5
   2266                  OS_RdyListInsert(p_tcb);                                /* Insert the task in the ready list                    */
   \       0x52   0x4640             MOV      R0,R8
   \       0x54   0x.... 0x....      BL       OS_RdyListInsert
   2267                  p_tcb->TaskState = OS_TASK_STATE_RDY;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF888 0x0026      STRB     R0,[R8, #+38]
   \       0x5E   0xE006             B.N      ??OS_TimerCallback_6
   2268                } else if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
   \                     ??OS_TimerCallback_5: (+1)
   \       0x60   0xF898 0x0026      LDRB     R0,[R8, #+38]
   \       0x64   0x2807             CMP      R0,#+7
   \       0x66   0xD102             BNE.N    ??OS_TimerCallback_6
   2269                  p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \       0x68   0x2004             MOVS     R0,#+4
   \       0x6A   0xF888 0x0026      STRB     R0,[R8, #+38]
   2270                }
   2271                p_tcb->PendStatus = OS_STATUS_PEND_TIMEOUT;               /* Indicate pend timed out                              */
   \                     ??OS_TimerCallback_6: (+1)
   \       0x6E   0x2003             MOVS     R0,#+3
   \       0x70   0xF888 0x0025      STRB     R0,[R8, #+37]
   2272                p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;                  /* Indicate no longer pending                           */
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF888 0x0024      STRB     R0,[R8, #+36]
   2273          
   2274          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2275                if (p_tcb_owner != DEF_NULL) {
   \       0x7A   0x2C00             CMP      R4,#+0
   \       0x7C   0xD023             BEQ.N    ??OS_TimerCallback_7
   2276                  if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio)
   2277                      && (p_tcb_owner->Prio == p_tcb->Prio)) {            /* Has the owner inherited a priority?                  */
   \       0x7E   0xF894 0x1027      LDRB     R1,[R4, #+39]
   \       0x82   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \       0x86   0x4281             CMP      R1,R0
   \       0x88   0xD01D             BEQ.N    ??OS_TimerCallback_7
   \       0x8A   0xF894 0x1027      LDRB     R1,[R4, #+39]
   \       0x8E   0xF898 0x0027      LDRB     R0,[R8, #+39]
   \       0x92   0x4281             CMP      R1,R0
   \       0x94   0xD117             BNE.N    ??OS_TimerCallback_7
   2278                    prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \       0x96   0x0020             MOVS     R0,R4
   \       0x98   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   2279                    prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
   \       0x9C   0xF894 0x2028      LDRB     R2,[R4, #+40]
   \       0xA0   0x0001             MOVS     R1,R0
   \       0xA2   0xB2C9             UXTB     R1,R1
   \       0xA4   0x428A             CMP      R2,R1
   \       0xA6   0xD202             BCS.N    ??OS_TimerCallback_8
   \       0xA8   0xF894 0x5028      LDRB     R5,[R4, #+40]
   \       0xAC   0xE000             B.N      ??OS_TimerCallback_9
   \                     ??OS_TimerCallback_8: (+1)
   \       0xAE   0x0005             MOVS     R5,R0
   2280                    if (prio_new != p_tcb_owner->Prio) {
   \                     ??OS_TimerCallback_9: (+1)
   \       0xB0   0x0029             MOVS     R1,R5
   \       0xB2   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \       0xB6   0xB2C9             UXTB     R1,R1
   \       0xB8   0x4281             CMP      R1,R0
   \       0xBA   0xD004             BEQ.N    ??OS_TimerCallback_7
   2281                      OS_TaskChangePrio(p_tcb_owner, prio_new);
   \       0xBC   0x0029             MOVS     R1,R5
   \       0xBE   0xB2C9             UXTB     R1,R1
   \       0xC0   0x0020             MOVS     R0,R4
   \       0xC2   0x.... 0x....      BL       OS_TaskChangePrio
   2282                      OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
   2283                    }
   2284                  }
   2285                }
   2286          #endif
   2287                break;
   \                     ??OS_TimerCallback_7: (+1)
   \       0xC6   0xE00A             B.N      ??OS_TimerCallback_10
   2288          
   2289              case OS_TASK_STATE_DLY:
   2290                p_tcb->TaskState = OS_TASK_STATE_RDY;
   \                     ??OS_TimerCallback_0: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0xF888 0x0026      STRB     R0,[R8, #+38]
   2291                OS_RdyListInsert(p_tcb);                                  /* Insert the task in the ready list                    */
   \       0xCE   0x4640             MOV      R0,R8
   \       0xD0   0x.... 0x....      BL       OS_RdyListInsert
   2292                break;
   \       0xD4   0xE003             B.N      ??OS_TimerCallback_10
   2293          
   2294              case OS_TASK_STATE_DLY_SUSPENDED:
   2295                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_TimerCallback_2: (+1)
   \       0xD6   0x2004             MOVS     R0,#+4
   \       0xD8   0xF888 0x0026      STRB     R0,[R8, #+38]
   2296                break;
   \       0xDC   0xE7FF             B.N      ??OS_TimerCallback_10
   2297          
   2298              default:
   2299                break;
   2300            }
   2301            CORE_EXIT_ATOMIC();
   \                     ??OS_TimerCallback_3: (+1)
   \                     ??OS_TimerCallback_10: (+1)
   \       0xDE   0x4648             MOV      R0,R9
   \       0xE0   0x.... 0x....      BL       CORE_ExitAtomic
   2302          
   2303            OSSched();
   \       0xE4   0x.... 0x....      BL       OSSched
   2304          }
   \       0xE8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     OSInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     OS_InitCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \        0x0   0x....'....        DC32     OSCfg_ISRStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \        0x0   0x....'....        DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \        0x0   0x....'....        DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \        0x0   0x....'....        DC32     OSCfg_ISRStkSizeRAM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \        0x0   0x....'....        DC32     OSCfg_DataSizeRAM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \        0x0   0x....'....        DC32     OSCfg_MsgPool

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \        0x0   0x....'....        DC32     OSCfg_MsgPoolBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \        0x0   0x....'....        DC32     OSCfg_MsgPoolSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \        0x0   0x....'....        DC32     OSCfg_MsgPoolSizeRAM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \        0x0   0x....'....        DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \        0x0   0x....'....        DC32     `OSInit::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \        0x0   0x....'....        DC32     OS_SleeptimerFrequency_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \        0x0   0x....'....        DC32     OSDelayMaxTick

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \        0x0   0x....'....        DC32     OSDelayMaxMilli

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_22:
   \        0x0   0x....'....        DC32     OSTCBHighRdyPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_23:
   \        0x0   0x....'....        DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_24:
   \        0x0   0x....'....        DC32     OSPrioHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_25:
   \        0x0   0x....'....        DC32     OS_AppTaskCreateHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_26:
   \        0x0   0x....'....        DC32     OS_AppTaskDelHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_27:
   \        0x0   0x....'....        DC32     OS_AppTaskReturnHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_28:
   \        0x0   0x....'....        DC32     OS_AppStatTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_29:
   \        0x0   0x....'....        DC32     OS_AppTaskSwHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_30:
   \        0x0   0x....'....        DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_31:
   \        0x0   0x....'....        DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_32:
   \        0x0   0x....'....        DC32     `OSSchedLock::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_33:
   \        0x0   0x....'....        DC32     `OSSchedUnlock::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_34:
   \        0x0   0x....'....        DC32     `OSStart::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_35:
   \        0x0   0x....'....        DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_36:
   \        0x0   0x....'....        DC32     `OSVersion::__func__`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x4B 0x65          DC8 "Kernel's ISR Stack"
   \              0x72 0x6E    
   \              0x65 0x6C    
   \              0x27 0x73    
   \              0x20 0x49    
   \              0x53 0x52    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x63 0x6B    
   \              0x00
   \       0x13                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x4B 0x65          DC8 "Kernel's Msg Pool"
   \              0x72 0x6E    
   \              0x65 0x6C    
   \              0x27 0x73    
   \              0x20 0x4D    
   \              0x73 0x67    
   \              0x20 0x50    
   \              0x6F 0x6F    
   \              0x6C 0x00
   \       0x12                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x6D 0x69          DC8 0x6D, 0x69, 0x63, 0x72, 0x69, 0x75, 0x6D, 0x5F
   \              0x63 0x72    
   \              0x69 0x75    
   \              0x6D 0x5F
   \       0x50   0x6F 0x73          DC8 0x6F, 0x73, 0x5C, 0x6B, 0x65, 0x72, 0x6E, 0x65
   \              0x5C 0x6B    
   \              0x65 0x72    
   \              0x6E 0x65
   \       0x58   0x6C 0x5C          DC8 0x6C, 0x5C, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65
   \       0x60   0x5C 0x6F          DC8 0x5C, 0x6F, 0x73, 0x5F, 0x63, 0x6F, 0x72, 0x65
   \              0x73 0x5F    
   \              0x63 0x6F    
   \              0x72 0x65
   \       0x68   0x2E 0x63          DC8 0x2E, 0x63, 0
   \              0x00
   \       0x6B                      DS8 1
   2305          #endif
   2306          
   2307          /********************************************************************************************************
   2308           ********************************************************************************************************
   2309           *                                   DEPENDENCIES & AVAIL CHECK(S) END
   2310           ********************************************************************************************************
   2311           *******************************************************************************************************/
   2312          
   2313          #endif // (defined(RTOS_MODULE_KERNEL_AVAIL))

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   OSInit
        32   -> CPU_SW_Exception
        32   -> Mem_SegAlloc
        32   -> OSCfg_Init
        32   -> OSInitHook
        32   -> OS_MsgPoolInit
        32   -> OS_PrioInit
        32   -> OS_RdyListInit
        32   -> OS_TaskInit
        32   -> sl_sleeptimer_get_timer_frequency
        32   -> sl_sleeptimer_init
        32 __aeabi_uldivmod
       0   OSIntEnter
       0   OSIntExit
       8   OSIsIdle
         8   -> OS_PrioGetHighest
      24   OSSched
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> OSCtxSw
        24   -> OSIdleEnterHook
        24   -> OSIdleExitHook
        24   -> OS_PrioGetHighest
      16   OSSchedLock
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> CORE_InIrqContext
        16   -> CPU_SW_Exception
      16   OSSchedUnlock
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> CORE_InIrqContext
        16   -> CPU_SW_Exception
        16   -> OSSched
      24   OSStart
        24   -> CORE_IrqIsDisabled
        24   -> CPU_SW_Exception
        24   -> OSStartHighRdy
        24   -> OS_PrioGetHighest
       8   OSVersion
         8   -> CPU_SW_Exception
      16   OS_ConfigureISRStk
        16   -> CPU_SW_Exception
       8   OS_ConfigureMemSeg
         8   -> CPU_SW_Exception
       8   OS_ConfigureMsgPoolSize
         8   -> CPU_SW_Exception
       8   OS_ConfigureStkLimit
         8   -> CPU_SW_Exception
       8   OS_ConfigureTickRate
         8   -> CPU_SW_Exception
      24   OS_Pend
        24   -> OS_PendListInsertPrio
        24   -> OS_TaskBlock
      24   OS_PendAbort
        24   -> CPU_SW_Exception
        24   -> OS_PendListRemove
        24   -> OS_RdyListInsert
        24   -> sl_sleeptimer_stop_timer
      16   OS_PendListChangePrio
        16   -> OS_PendListInsertPrio
        16   -> OS_PendListRemove
       0   OS_PendListInit
       8   OS_PendListInsertPrio
       4   OS_PendListRemove
      24   OS_Post
        24   -> CPU_SW_Exception
        24   -> OS_PendListRemove
        24   -> OS_RdyListInsert
        24   -> sl_sleeptimer_stop_timer
       0   OS_RdyListInit
       8   OS_RdyListInsert
         8   -> OS_PrioInsert
         8   -> OS_RdyListInsertHead
         8   -> OS_RdyListInsertTail
       0   OS_RdyListInsertHead
       0   OS_RdyListInsertTail
       8   OS_RdyListMoveHeadToTail
      24   OS_RdyListRemove
        24   -> OS_PrioRemove
      32   OS_TaskBlock
        32   -> CPU_SW_Exception
        32   -> OS_RdyListRemove
        32   -> sl_sleeptimer_get_timer_frequency
        32   -> sl_sleeptimer_start_timer
        32 __aeabi_uldivmod
      32   OS_TimerCallback
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> OSSched
        32   -> OS_MutexGrpPrioFindHighest
        32   -> OS_PendListRemove
        32   -> OS_RdyListInsert
        32   -> OS_TaskChangePrio


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_25
       4  ??DataTable17_26
       4  ??DataTable17_27
       4  ??DataTable17_28
       4  ??DataTable17_29
       4  ??DataTable17_3
       4  ??DataTable17_30
       4  ??DataTable17_31
       4  ??DataTable17_32
       4  ??DataTable17_33
       4  ??DataTable17_34
       4  ??DataTable17_35
       4  ??DataTable17_36
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      20  ?_0
      20  ?_1
     108  ?_2
       4  OSDelayMaxMilli
       4  OSDelayMaxTick
     594  OSInit
       2  OSIntEnter
       2  OSIntExit
      18  OSIsIdle
     130  OSSched
     166  OSSchedLock
     206  OSSchedUnlock
     220  OSStart
      40  OSVersion
      30  OS_ConfigureISRStk
      26  OS_ConfigureMemSeg
      26  OS_ConfigureMsgPoolSize
      26  OS_ConfigureStkLimit
      32  OS_ConfigureTickRate
      56  OS_InitCfg
      56  OS_InitCfgDflt
      80  OS_Pend
     174  OS_PendAbort
      34  OS_PendListChangePrio
      10  OS_PendListInit
     106  OS_PendListInsertPrio
      96  OS_PendListRemove
     188  OS_Post
      28  OS_RdyListInit
      40  OS_RdyListInsert
      48  OS_RdyListInsertHead
      46  OS_RdyListInsertTail
      78  OS_RdyListMoveHeadToTail
      74  OS_RdyListRemove
       4  OS_SleeptimerFrequency_Hz
      98  OS_TaskBlock
     236  OS_TimerCallback
       4  micriumos_errno
      56  -- Other

 
    16 bytes in section .bss
    56 bytes in section .data
   260 bytes in section .rodata
 3'002 bytes in section .text
 
 3'002 bytes of CODE  memory
   260 bytes of CONST memory
    72 bytes of DATA  memory

Errors: none
Warnings: none
