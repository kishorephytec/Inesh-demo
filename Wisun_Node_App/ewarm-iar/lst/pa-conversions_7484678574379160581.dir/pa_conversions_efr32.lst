###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:24
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\pa_conversions_efr32.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\pa-conversions_7484678574379160581.dir\pa_conversions_efr32.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\pa_conversions_efr32.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\pa-conversions_7484678574379160581.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\pa-conversions_7484678574379160581.dir"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\pa-conversions_7484678574379160581.dir\pa_conversions_efr32.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\pa-conversions_7484678574379160581.dir\pa_conversions_efr32.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\pa-conversions_7484678574379160581.dir\pa_conversions_efr32.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\pa_conversions_efr32.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief PA power conversion functions provided to the customer as source for
      4           *   highest level of customization.
      5           * @details This file contains the curves and logic that convert PA power
      6           *   levels to dBm powers.
      7           *******************************************************************************
      8           * # License
      9           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
     10           *******************************************************************************
     11           *
     12           * SPDX-License-Identifier: Zlib
     13           *
     14           * The licensor of this software is Silicon Laboratories Inc.
     15           *
     16           * This software is provided 'as-is', without any express or implied
     17           * warranty. In no event will the authors be held liable for any damages
     18           * arising from the use of this software.
     19           *
     20           * Permission is granted to anyone to use this software for any purpose,
     21           * including commercial applications, and to alter it and redistribute it
     22           * freely, subject to the following restrictions:
     23           *
     24           * 1. The origin of this software must not be misrepresented; you must not
     25           *    claim that you wrote the original software. If you use this software
     26           *    in a product, an acknowledgment in the product documentation would be
     27           *    appreciated but is not required.
     28           * 2. Altered source versions must be plainly marked as such, and must not be
     29           *    misrepresented as being the original software.
     30           * 3. This notice may not be removed or altered from any source distribution.
     31           *
     32           ******************************************************************************/
     33          // For details on how to use this plugin, see
     34          //   https://www.silabs.com/documents/public/application-notes/an1127-power-amplifier-power-conversion-functions.pdf
     35          
     36          #include "em_device.h"
     37          #include "em_cmu.h"
     38          #include "pa_conversions_efr32.h"
     39          #include "rail.h"
     40          
     41          #define MAX(a, b) ((a) > (b) ? (a) : (b))
     42          

   \                                 In section .bss, align 4
     43          static RAIL_TxPowerCurvesConfigAlt_t powerCurvesState;
   \                     powerCurvesState:
   \        0x0                      DS8 48
     44          
     45          // Make sure SUPPORTED_PA_INDICES match the per-platform PA curves
     46          // provided by RAIL_DECLARE_TX_POWER_CURVES_CONFIG_ALT and resulting
     47          // RAIL_TxPowerCurvesConfigAlt_t!
     48          #ifndef SUPPORTED_PA_INDICES
     49          #if defined(_SILICON_LABS_32B_SERIES_1)
     50          #define SUPPORTED_PA_INDICES {                   \
     51              0U,        /* 2P4GIG_HP  */                  \
     52              RAIL_NUM_PA, /* 2P4GIG_MP  */                \
     53              1U,        /* 2P4GIG_LP  */                  \
     54              RAIL_NUM_PA, /* 2P4GIG_LLP */                \
     55              RAIL_NUM_PA, /* 2P4GIG_HIGHEST */            \
     56              RAIL_NUM_PA, /* SUBGIG_POWERSETTING_TABLE */ \
     57              2U,        /* SUBGIG_HP */                   \
     58              /* The rest are unsupported */               \
     59          }
     60          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 1)
     61          #define SUPPORTED_PA_INDICES {     \
     62              0U,        /* 2P4GIG_HP  */    \
     63              1U,        /* 2P4GIG_MP  */    \
     64              2U,        /* 2P4GIG_LP  */    \
     65              /* The rest are unsupported */ \
     66          }
     67          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 2)
     68          #define SUPPORTED_PA_INDICES {     \
     69              0U,        /* 2P4GIG_HP  */    \
     70              RAIL_NUM_PA, /* 2P4GIG_MP  */  \
     71              1U,        /* 2P4GIG_LP  */    \
     72              /* The rest are unsupported */ \
     73          }
     74          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 3)
     75          #define SUPPORTED_PA_INDICES {                   \
     76              RAIL_NUM_PA, /* 2P4GIG_HP  */                \
     77              RAIL_NUM_PA, /* 2P4GIG_MP  */                \
     78              RAIL_NUM_PA, /* 2P4GIG_LP  */                \
     79              RAIL_NUM_PA, /* 2P4GIG_LLP */                \
     80              RAIL_NUM_PA, /* 2P4GIG_HIGHEST */            \
     81              RAIL_NUM_PA, /* SUBGIG_POWERSETTING_TABLE */ \
     82              0U,        /* SUBGIG_HP */                   \
     83              1U,        /* SUBGIG_MP */                   \
     84              2U,        /* SUBGIG_LP */                   \
     85              3U,        /* SUBGIG_LLP */                  \
     86              /* The rest are unsupported */               \
     87          }
     88          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 4)
     89          #define SUPPORTED_PA_INDICES {     \
     90              0U,        /* 2P4GIG_HP  */    \
     91              RAIL_NUM_PA, /* 2P4GIG_MP  */  \
     92              1U,        /* 2P4GIG_LP  */    \
     93              /* The rest are unsupported */ \
     94          }
     95          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 5)
     96          #define SUPPORTED_PA_INDICES {                      \
     97              RAIL_NUM_PA, /* 2P4GIG_HP  */                   \
     98              RAIL_NUM_PA, /* 2P4GIG_MP  */                   \
     99              RAIL_NUM_PA, /* 2P4GIG_LP  */                   \
    100              RAIL_NUM_PA, /* 2P4GIG_LLP */                   \
    101              RAIL_NUM_PA, /* 2P4GIG_HIGHEST */               \
    102              0U,        /* SUBGIG_POWERSETTING_TABLE */      \
    103              RAIL_NUM_PA, /* SUBGIG_HP */                    \
    104              RAIL_NUM_PA, /* SUBGIG_MP */                    \
    105              RAIL_NUM_PA, /* SUBGIG_LP */                    \
    106              RAIL_NUM_PA, /* SUBGIG_LLP */                   \
    107              RAIL_NUM_PA, /* SUBGIG_HIGHEST */               \
    108              1U,        /* OFDM_PA_POWERSETTING_TABLE */     \
    109              2U,        /* SUBGIG_EFF_POWERSETTING_TABLE */  \
    110              3U,        /* OFDM_PA_EFF_POWERSETTING_TABLE */ \
    111          }
    112          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 7)
    113          #define SUPPORTED_PA_INDICES {     \
    114              0U,        /* 2P4GIG_HP  */    \
    115              RAIL_NUM_PA, /* 2P4GIG_MP  */  \
    116              1U,        /* 2P4GIG_LP  */    \
    117              /* The rest are unsupported */ \
    118          }
    119          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 8)
    120          #define SUPPORTED_PA_INDICES {                   \
    121              0U,        /* 2P4GIG_HP  */                  \
    122              RAIL_NUM_PA, /* 2P4GIG_MP  */                \
    123              RAIL_NUM_PA, /* 2P4GIG_LP  */                \
    124              RAIL_NUM_PA, /* 2P4GIG_LLP */                \
    125              RAIL_NUM_PA, /* 2P4GIG_HIGHEST */            \
    126              RAIL_NUM_PA, /* SUBGIG_POWERSETTING_TABLE */ \
    127              1U,        /* SUBGIG_HP */                   \
    128              2U,        /* SUBGIG_MP */                   \
    129              3U,        /* SUBGIG_LP */                   \
    130              4U,        /* SUBGIG_LLP */                  \
    131              /* The rest are unsupported */               \
    132          }
    133          #else
    134          #error "unknown platform"
    135          #endif
    136          #endif
    137          

   \                                 In section .rodata, align 4
    138          static const uint8_t supportedPaIndices[] = SUPPORTED_PA_INDICES;
   \                     supportedPaIndices:
   \        0x0   0x00 0x05          DC8 0, 5, 5, 5, 5, 5, 1, 2, 3, 4
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x01 0x02    
   \              0x03 0x04
   \        0xA                      DS8 2
    139          
    140          #if defined(_SILICON_LABS_32B_SERIES_1) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    141            #define PA_CONVERSION_MINIMUM_PWRLVL 1U
    142          #else
    143            #define PA_CONVERSION_MINIMUM_PWRLVL 0U
    144          #endif
    145          
    146          //   This macro is defined when Silicon Labs builds this into the library as WEAK
    147          //   to ensure it can be overriden by customer versions of these functions. The macro
    148          //   should *not* be defined in a customer build.
    149          #ifdef RAIL_PA_CONVERSIONS_WEAK
    150          __WEAK
    151          #endif

   \                                 In section .text, align 2, keep-with-next
    152          const RAIL_TxPowerCurves_t *RAIL_GetTxPowerCurve(RAIL_TxPowerMode_t mode)
    153          {
   \                     RAIL_GetTxPowerCurve: (+1)
   \        0x0   0xB501             PUSH     {R0,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
    154            static RAIL_TxPowerCurves_t powerCurves;
    155            RAIL_TxPowerLevel_t maxPowerLevel, minPowerLevel;
    156            if (RAIL_SupportsTxPowerModeAlt(RAIL_EFR32_HANDLE,
    157                                            &mode,
    158                                            &maxPowerLevel,
    159                                            &minPowerLevel)
    160                && (mode < sizeof(supportedPaIndices))
    161                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
   \        0x4   0x466B             MOV      R3,SP
   \        0x6   0xF10D 0x0201      ADD      R2,SP,#+1
   \        0xA   0xA902             ADD      R1,SP,#+8
   \        0xC   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x10   0x.... 0x....      BL       RAIL_SupportsTxPowerModeAlt
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD01F             BEQ.N    ??RAIL_GetTxPowerCurve_0
   \       0x18   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x1C   0x280A             CMP      R0,#+10
   \       0x1E   0xD21B             BCS.N    ??RAIL_GetTxPowerCurve_0
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x24   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \       0x28   0x5C41             LDRB     R1,[R0, R1]
   \       0x2A   0x2905             CMP      R1,#+5
   \       0x2C   0xD214             BCS.N    ??RAIL_GetTxPowerCurve_0
    162              const RAIL_PaDescriptor_t *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \       0x32   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \       0x36   0x5C80             LDRB     R0,[R0, R2]
   \       0x38   0xEB01 0x02C0      ADD      R2,R1,R0, LSL #+3
    163              const RAIL_TxPowerCurveAlt_t *curve = modeInfo->conversion.powerCurve;
   \       0x3C   0x6851             LDR      R1,[R2, #+4]
    164              // Check for an invalid power curve
    165              if (curve == NULL) {
   \       0x3E   0x2900             CMP      R1,#+0
   \       0x40   0xD101             BNE.N    ??RAIL_GetTxPowerCurve_1
    166                return NULL;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xE009             B.N      ??RAIL_GetTxPowerCurve_2
    167              }
    168          
    169          #if RAIL_SUPPORTS_DBM_POWERSETTING_MAPPING_TABLE
    170              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_DBM_POWERSETTING_MAPPING_TABLE) {
    171                powerCurves.maxPower = modeInfo->maxPowerDbm;
    172                powerCurves.minPower = modeInfo->minPowerDbm;
    173                // Mapping table does not have RAIL_TxPowerCurveSegment_t segments
    174                powerCurves.powerParams = NULL;
    175              } else
    176          #endif
    177              {
    178                powerCurves.maxPower = curve->maxPower;
   \                     ??RAIL_GetTxPowerCurve_1: (+1)
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \       0x4A   0x880B             LDRH     R3,[R1, #+0]
   \       0x4C   0x8003             STRH     R3,[R0, #+0]
    179                powerCurves.minPower = curve->minPower;
   \       0x4E   0x884B             LDRH     R3,[R1, #+2]
   \       0x50   0x8043             STRH     R3,[R0, #+2]
    180                powerCurves.powerParams = &curve->powerParams[0];
   \       0x52   0x1D0B             ADDS     R3,R1,#+4
   \       0x54   0x6043             STR      R3,[R0, #+4]
    181              }
    182              return &powerCurves;
   \       0x56   0xE000             B.N      ??RAIL_GetTxPowerCurve_2
    183            }
    184            return NULL;
   \                     ??RAIL_GetTxPowerCurve_0: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \                     ??RAIL_GetTxPowerCurve_2: (+1)
   \       0x5A   0xBD0E             POP      {R1-R3,PC}
    185          }

   \                                 In section .bss, align 4
   \                     `RAIL_GetTxPowerCurve::powerCurves`:
   \        0x0                      DS8 8
    186          
    187          // This function will not be supported for any parts after efr32xg1x
    188          #ifdef RAIL_PA_CONVERSIONS_WEAK
    189          __WEAK
    190          #endif

   \                                 In section .text, align 2, keep-with-next
    191          RAIL_Status_t RAIL_InitTxPowerCurves(const RAIL_TxPowerCurvesConfig_t *config)
    192          {
   \                     RAIL_InitTxPowerCurves: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    193          #ifdef _SILICON_LABS_32B_SERIES_1
    194            // First PA is 2.4 GHz high power, using a piecewise fit
    195            RAIL_PaDescriptor_t *current = &powerCurvesState.curves[0];
    196            current->algorithm = RAIL_PA_ALGORITHM_PIECEWISE_LINEAR;
    197            current->segments = config->piecewiseSegments;
    198            current->min = RAIL_TX_POWER_LEVEL_2P4_HP_MIN;
    199            current->max = RAIL_TX_POWER_LEVEL_2P4_HP_MAX;
    200            static RAIL_TxPowerCurveAlt_t txPower2p4 = {
    201              .minPower = 0U,
    202              .maxPower = 0U,
    203              .powerParams = { // The current max number of piecewise segments is 8
    204                { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U },
    205                { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U },
    206              }
    207            };
    208            txPower2p4.maxPower = config->txPowerSgCurves->maxPower;
    209            txPower2p4.minPower = config->txPowerSgCurves->minPower;
    210            (void) memcpy(&txPower2p4.powerParams[0],
    211                          config->txPowerSgCurves->powerParams,
    212                          config->piecewiseSegments * sizeof(RAIL_TxPowerCurveSegment_t));
    213            current->conversion.powerCurve = &txPower2p4;
    214          
    215            // Second PA is 2.4 GHz low power, using a mapping table
    216            current = &powerCurvesState.curves[1];
    217            current->algorithm = RAIL_PA_ALGORITHM_MAPPING_TABLE;
    218            current->segments = 0U;
    219            current->min = RAIL_TX_POWER_LEVEL_2P4_LP_MIN;
    220            current->max = RAIL_TX_POWER_LEVEL_2P4_LP_MAX;
    221            current->conversion.mappingTable = config->txPower24LpCurves;
    222          
    223            // Third and final PA is Sub-GHz, using a piecewise fit
    224            current = &powerCurvesState.curves[2];
    225            current->algorithm = RAIL_PA_ALGORITHM_PIECEWISE_LINEAR;
    226            current->segments = config->piecewiseSegments;
    227            current->min = RAIL_TX_POWER_LEVEL_SUBGIG_MIN;
    228            current->max = RAIL_TX_POWER_LEVEL_SUBGIG_HP_MAX;
    229            static RAIL_TxPowerCurveAlt_t txPowerSubGig = {
    230              .minPower = 0U,
    231              .maxPower = 0U,
    232              .powerParams = { // The current max number of piecewise segments is 8
    233                { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U },
    234                { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U },
    235              }
    236            };
    237            txPowerSubGig.maxPower = config->txPowerSgCurves->maxPower;
    238            txPowerSubGig.minPower = config->txPowerSgCurves->minPower;
    239            (void) memcpy(&txPowerSubGig.powerParams[0],
    240                          config->txPowerSgCurves->powerParams,
    241                          config->piecewiseSegments * sizeof(RAIL_TxPowerCurveSegment_t));
    242            current->conversion.powerCurve = &txPowerSubGig;
    243          
    244            return RAIL_STATUS_NO_ERROR;
    245          #else
    246            (void) config;
    247            return RAIL_STATUS_INVALID_CALL;
   \        0x2   0x2003             MOVS     R0,#+3
   \        0x4   0x4770             BX       LR
    248          #endif
    249          }
    250          
    251          #ifdef RAIL_PA_CONVERSIONS_WEAK
    252          __WEAK
    253          #endif

   \                                 In section .text, align 2, keep-with-next
    254          RAIL_Status_t RAIL_InitTxPowerCurvesAlt(const RAIL_TxPowerCurvesConfigAlt_t *config)
    255          {
   \                     RAIL_InitTxPowerCurvesAlt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    256            RAIL_VerifyTxPowerCurves(config);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       RAIL_VerifyTxPowerCurves
    257          
    258            powerCurvesState = *config;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \        0xE   0x0021             MOVS     R1,R4
   \       0x10   0x2230             MOVS     R2,#+48
   \       0x12   0x.... 0x....      BL       __aeabi_memcpy4
    259          
    260            return RAIL_STATUS_NO_ERROR;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xBD10             POP      {R4,PC}
    261          }
    262          
    263          #ifdef RAIL_PA_CONVERSIONS_WEAK
    264          __WEAK
    265          #endif

   \                                 In section .text, align 2, keep-with-next
    266          const RAIL_PaPowerSetting_t *RAIL_GetPowerSettingTable(RAIL_Handle_t railHandle, RAIL_TxPowerMode_t mode,
    267                                                                 RAIL_TxPower_t *minPower, RAIL_TxPower_t *maxPower,
    268                                                                 RAIL_TxPowerLevel_t *step)
    269          {
   \                     RAIL_GetPowerSettingTable: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0004             MOVS     R4,R0
    270            (void)railHandle;
    271          #if RAIL_SUPPORTS_DBM_POWERSETTING_MAPPING_TABLE
    272            if ((mode < sizeof(supportedPaIndices))
    273                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
    274              RAIL_PaDescriptor_t *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
    275              *minPower = modeInfo->minPowerDbm;
    276              *maxPower = modeInfo->maxPowerDbm;
    277              *step = modeInfo->step;
    278              return (RAIL_PaPowerSetting_t*)(modeInfo->conversion.mappingTable);
    279            }
    280            return NULL;
    281          #else
    282            (void)mode;
    283            (void)minPower;
    284            (void)maxPower;
    285            (void)step;
    286            return NULL;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBC10             POP      {R4}
   \        0x8   0x4770             BX       LR
    287          #endif
    288          }
    289          
    290          #ifdef RAIL_PA_CONVERSIONS_WEAK
    291          __WEAK
    292          #endif

   \                                 In section .text, align 2, keep-with-next
    293          RAIL_TxPowerLevel_t RAIL_ConvertDbmToRaw(RAIL_Handle_t railHandle,
    294                                                   RAIL_TxPowerMode_t mode,
    295                                                   RAIL_TxPower_t power)
    296          {
   \                     RAIL_ConvertDbmToRaw: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000B             MOVS     R3,R1
    297            (void)railHandle;
    298            // This function is called internally from the RAIL library,
    299            // so if the user never calls RAIL_InitTxPowerCurves - even
    300            // if they never intend to use dBm values in their code -
    301            // they'll always hit the assert below. Give the user a way
    302            // to not have to call RAIL_InitTxPowerCurves if they don't
    303            // care about dBm values by picking a dBm value that returns the
    304            // highest RAIL_TxPowerLevel_t possible. In other words, when
    305            // a channel dBm limitation greater than or equal to \ref RAIL_TX_POWER_MAX
    306            // is converted to raw units, the max RAIL_TxPowerLevel_t will be
    307            // returned. When compared to the current power level of the PA,
    308            // it will always be greater, indicating that no power coercion
    309            // is necessary to comply with channel limitations.
    310            if (power >= RAIL_TX_POWER_MAX) {
   \        0x8   0x0010             MOVS     R0,R2
   \        0xA   0xF647 0x71FF      MOVW     R1,#+32767
   \        0xE   0xB200             SXTH     R0,R0
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD101             BNE.N    ??RAIL_ConvertDbmToRaw_0
    311              return 255U;
   \       0x14   0x20FF             MOVS     R0,#+255
   \       0x16   0xE0BE             B.N      ??RAIL_ConvertDbmToRaw_1
    312            }
    313          
    314            if ((mode < sizeof(supportedPaIndices))
    315                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
   \                     ??RAIL_ConvertDbmToRaw_0: (+1)
   \       0x18   0x0018             MOVS     R0,R3
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x280A             CMP      R0,#+10
   \       0x1E   0xF080 0x80B9      BCS.W    ??RAIL_ConvertDbmToRaw_2
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x26   0x0019             MOVS     R1,R3
   \       0x28   0xB2C9             UXTB     R1,R1
   \       0x2A   0x5C41             LDRB     R1,[R0, R1]
   \       0x2C   0x2905             CMP      R1,#+5
   \       0x2E   0xF080 0x80B1      BCS.W    ??RAIL_ConvertDbmToRaw_2
    316              RAIL_PaDescriptor_t const *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \       0x36   0x001D             MOVS     R5,R3
   \       0x38   0xB2ED             UXTB     R5,R5
   \       0x3A   0x5D40             LDRB     R0,[R0, R5]
   \       0x3C   0xEB01 0x05C0      ADD      R5,R1,R0, LSL #+3
    317              uint32_t minPowerLevel = MAX(modeInfo->min, PA_CONVERSION_MINIMUM_PWRLVL);
   \       0x40   0x78A8             LDRB     R0,[R5, #+2]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD001             BEQ.N    ??RAIL_ConvertDbmToRaw_3
   \       0x46   0x78AE             LDRB     R6,[R5, #+2]
   \       0x48   0xE000             B.N      ??RAIL_ConvertDbmToRaw_4
   \                     ??RAIL_ConvertDbmToRaw_3: (+1)
   \       0x4A   0x2600             MOVS     R6,#+0
    318          #if RAIL_SUPPORTS_DBM_POWERSETTING_MAPPING_TABLE
    319              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_DBM_POWERSETTING_MAPPING_TABLE) {
    320                RAIL_TxPower_t minPower = modeInfo->minPowerDbm;
    321                RAIL_TxPower_t maxPower = modeInfo->maxPowerDbm;
    322                RAIL_TxPowerLevel_t step = modeInfo->step;
    323          
    324                // Cap the power to within the range of the mapping table
    325                if (power < minPower) {
    326                  power = minPower;
    327                } else if (power > maxPower) {
    328                  power = maxPower;
    329                } else {
    330                  // Power level is within bounds (MISRA required else)
    331                }
    332          
    333                uint32_t powerIndex = (power - minPower) / step;
    334                RAIL_SetPaPowerSetting(railHandle, modeInfo->conversion.mappingTable[powerIndex], minPower, maxPower, power);
    335                return 0U;
    336              }
    337          #endif
    338          
    339              // If we're in low power mode, just use the simple lookup table
    340              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_MAPPING_TABLE) {
   \                     ??RAIL_ConvertDbmToRaw_4: (+1)
   \       0x4C   0x7828             LDRB     R0,[R5, #+0]
   \       0x4E   0x2801             CMP      R0,#+1
   \       0x50   0xD119             BNE.N    ??RAIL_ConvertDbmToRaw_5
    341                // Binary search through the lookup table to find the closest power level
    342                // without going over.
    343                uint32_t lower = 0U;
   \       0x52   0x2100             MOVS     R1,#+0
    344                // Track the high side of the estimate
    345                uint32_t powerIndex = modeInfo->max - minPowerLevel;
   \       0x54   0x78E8             LDRB     R0,[R5, #+3]
   \       0x56   0x1B80             SUBS     R0,R0,R6
    346          
    347                while (lower < powerIndex) {
   \                     ??RAIL_ConvertDbmToRaw_6: (+1)
   \       0x58   0x4281             CMP      R1,R0
   \       0x5A   0xD210             BCS.N    ??RAIL_ConvertDbmToRaw_7
    348                  // Calculate the midpoint of the current range
    349                  uint32_t index = powerIndex - (powerIndex - lower) / 2U;
   \       0x5C   0x1A47             SUBS     R7,R0,R1
   \       0x5E   0xEBB0 0x0757      SUBS     R7,R0,R7, LSR #+1
    350                  if (power < modeInfo->conversion.mappingTable[index]) {
   \       0x62   0x4694             MOV      R12,R2
   \       0x64   0xF8D5 0xE004      LDR      LR,[R5, #+4]
   \       0x68   0xF93E 0xE017      LDRSH    LR,[LR, R7, LSL #+1]
   \       0x6C   0xFA0F 0xFC8C      SXTH     R12,R12
   \       0x70   0x45F4             CMP      R12,LR
   \       0x72   0xDA02             BGE.N    ??RAIL_ConvertDbmToRaw_8
    351                    powerIndex = index - 1U;
   \       0x74   0x1E7F             SUBS     R7,R7,#+1
   \       0x76   0x0038             MOVS     R0,R7
   \       0x78   0xE7EE             B.N      ??RAIL_ConvertDbmToRaw_6
    352                  } else {
    353                    lower = index;
   \                     ??RAIL_ConvertDbmToRaw_8: (+1)
   \       0x7A   0x0039             MOVS     R1,R7
   \       0x7C   0xE7EC             B.N      ??RAIL_ConvertDbmToRaw_6
    354                  }
    355                }
    356                return (RAIL_TxPowerLevel_t)(powerIndex + minPowerLevel);
   \                     ??RAIL_ConvertDbmToRaw_7: (+1)
   \       0x7E   0x1836             ADDS     R6,R6,R0
   \       0x80   0x0030             MOVS     R0,R6
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0xE087             B.N      ??RAIL_ConvertDbmToRaw_1
    357              }
    358          
    359              // Here we know we're using the piecewise linear conversion
    360              RAIL_TxPowerCurveAlt_t const *paParams = modeInfo->conversion.powerCurve;
   \                     ??RAIL_ConvertDbmToRaw_5: (+1)
   \       0x86   0x6869             LDR      R1,[R5, #+4]
    361              // Check for valid paParams before using them
    362              if (paParams == NULL) {
   \       0x88   0x2900             CMP      R1,#+0
   \       0x8A   0xD101             BNE.N    ??RAIL_ConvertDbmToRaw_9
    363                return 0U;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xE082             B.N      ??RAIL_ConvertDbmToRaw_1
    364              }
    365          
    366              // Cap the power based on the PA settings.
    367              if (power > paParams->maxPower) {
   \                     ??RAIL_ConvertDbmToRaw_9: (+1)
   \       0x90   0xF9B1 0x7000      LDRSH    R7,[R1, #+0]
   \       0x94   0x0010             MOVS     R0,R2
   \       0x96   0xB200             SXTH     R0,R0
   \       0x98   0x4287             CMP      R7,R0
   \       0x9A   0xDA03             BGE.N    ??RAIL_ConvertDbmToRaw_10
    368                // If we go above the maximum dbm the chip supports
    369                // Then provide maximum powerLevel
    370                power = paParams->maxPower;
   \       0x9C   0xF9B1 0x0000      LDRSH    R0,[R1, #+0]
   \       0xA0   0x0002             MOVS     R2,R0
   \       0xA2   0xE008             B.N      ??RAIL_ConvertDbmToRaw_11
    371              } else if (power < paParams->minPower) {
   \                     ??RAIL_ConvertDbmToRaw_10: (+1)
   \       0xA4   0x0010             MOVS     R0,R2
   \       0xA6   0xF9B1 0x7002      LDRSH    R7,[R1, #+2]
   \       0xAA   0xB200             SXTH     R0,R0
   \       0xAC   0x42B8             CMP      R0,R7
   \       0xAE   0xDA02             BGE.N    ??RAIL_ConvertDbmToRaw_11
    372                // If we go below the minimum we want included in the curve fit, force it.
    373                power = paParams->minPower;
   \       0xB0   0xF9B1 0x0002      LDRSH    R0,[R1, #+2]
   \       0xB4   0x0002             MOVS     R2,R0
    374              } else {
    375                // Do nothing, power is OK
    376              }
    377              // Map the power value to a 0 - 7 curveIndex value
    378              //There are 8 segments of step size of RAIL_TX_POWER_CURVE_INCREMENT in deci dBm
    379              //starting from maximum RAIL_TX_POWER_CURVE_MAX in deci dBm
    380              // These are just starting points to give the code
    381              // a rough idea of which segment to use, based on
    382              // how they were fit. Adjustments are made later on
    383              // if this turns out to be incorrect.
    384              RAIL_TxPower_t txPowerMax = RAIL_TX_POWER_CURVE_DEFAULT_MAX;
   \                     ??RAIL_ConvertDbmToRaw_11: (+1)
   \       0xB6   0x27C8             MOVS     R7,#+200
    385              RAIL_TxPower_t txPowerIncrement = RAIL_TX_POWER_CURVE_DEFAULT_INCREMENT;
   \       0xB8   0xF05F 0x0C28      MOVS     R12,#+40
    386              int16_t curveIndex = 0;
   \       0xBC   0xF05F 0x0E00      MOVS     LR,#+0
    387              // if the first curve segment starts with RAIL_TX_POWER_LEVEL_INVALID
    388              //It is an extra curve segment to depict the maxpower and increment
    389              // (in deci-dBm) used while generating the curves.
    390              // The extra segment is only present when curve segment is generated by
    391              //using values different than the default - RAIL_TX_POWER_CURVE_DEFAULT_MAX
    392              // and RAIL_TX_POWER_CURVE_DEFAULT_INCREMENT.
    393              if ((paParams->powerParams[0].maxPowerLevel) == RAIL_TX_POWER_LEVEL_INVALID) {
   \       0xC0   0x8888             LDRH     R0,[R1, #+4]
   \       0xC2   0x28FF             CMP      R0,#+255
   \       0xC4   0xD106             BNE.N    ??RAIL_ConvertDbmToRaw_12
    394                curveIndex += 1;
   \       0xC6   0xF11E 0x0E01      ADDS     LR,LR,#+1
    395                txPowerMax = (RAIL_TxPower_t) paParams->powerParams[0].slope;
   \       0xCA   0xF9B1 0x0006      LDRSH    R0,[R1, #+6]
   \       0xCE   0x0007             MOVS     R7,R0
    396                txPowerIncrement = (RAIL_TxPower_t) paParams->powerParams[0].intercept;
   \       0xD0   0x6888             LDR      R0,[R1, #+8]
   \       0xD2   0x4684             MOV      R12,R0
    397              }
    398          
    399              curveIndex += (txPowerMax - power) / txPowerIncrement;
   \                     ??RAIL_ConvertDbmToRaw_12: (+1)
   \       0xD4   0x46B8             MOV      R8,R7
   \       0xD6   0xFA0F 0xF888      SXTH     R8,R8
   \       0xDA   0x0010             MOVS     R0,R2
   \       0xDC   0xB200             SXTH     R0,R0
   \       0xDE   0xEBB8 0x0800      SUBS     R8,R8,R0
   \       0xE2   0x4660             MOV      R0,R12
   \       0xE4   0xB200             SXTH     R0,R0
   \       0xE6   0xFB98 0xF0F0      SDIV     R0,R8,R0
   \       0xEA   0xEB10 0x0E0E      ADDS     LR,R0,LR
    400              if ((curveIndex > ((int16_t)modeInfo->segments - 1))
    401                  || (curveIndex < 0)) {
   \       0xEE   0xF895 0x8001      LDRB     R8,[R5, #+1]
   \       0xF2   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \       0xF6   0x4670             MOV      R0,LR
   \       0xF8   0xB200             SXTH     R0,R0
   \       0xFA   0x4580             CMP      R8,R0
   \       0xFC   0xDB03             BLT.N    ??RAIL_ConvertDbmToRaw_13
   \       0xFE   0x4670             MOV      R0,LR
   \      0x100   0xB200             SXTH     R0,R0
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD502             BPL.N    ??RAIL_ConvertDbmToRaw_14
    402                curveIndex = ((int16_t)modeInfo->segments - 1);
   \                     ??RAIL_ConvertDbmToRaw_13: (+1)
   \      0x106   0x7868             LDRB     R0,[R5, #+1]
   \      0x108   0x1E40             SUBS     R0,R0,#+1
   \      0x10A   0x4686             MOV      LR,R0
    403              }
    404          
    405              uint32_t powerLevel;
    406              do {
    407                // Select the correct piecewise segment to use for conversion.
    408                RAIL_TxPowerCurveSegment_t const *powerParams =
    409                  &paParams->powerParams[curveIndex];
   \                     ??RAIL_ConvertDbmToRaw_14: (+1)
   \                     ??RAIL_ConvertDbmToRaw_15: (+1)
   \      0x10C   0x46F0             MOV      R8,LR
   \      0x10E   0xFA0F 0xF888      SXTH     R8,R8
   \      0x112   0xEB01 0x08C8      ADD      R8,R1,R8, LSL #+3
   \      0x116   0xF118 0x0B04      ADDS     R11,R8,#+4
    410          
    411                // powerLevel can only go down to 0.
    412                int32_t powerLevelInt = powerParams->intercept + ((int32_t)powerParams->slope * (int32_t)power);
   \      0x11A   0xF8DB 0x9004      LDR      R9,[R11, #+4]
   \      0x11E   0xF9BB 0x8002      LDRSH    R8,[R11, #+2]
   \      0x122   0xFB18 0x9802      SMLABB   R8,R8,R2,R9
    413                if (powerLevelInt < 0) {
   \      0x126   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x12A   0xD502             BPL.N    ??RAIL_ConvertDbmToRaw_16
    414                  powerLevel = 0U;
   \      0x12C   0xF05F 0x0900      MOVS     R9,#+0
   \      0x130   0xE000             B.N      ??RAIL_ConvertDbmToRaw_17
    415                } else {
    416                  powerLevel = (uint32_t) powerLevelInt;
   \                     ??RAIL_ConvertDbmToRaw_16: (+1)
   \      0x132   0x46C1             MOV      R9,R8
    417                }
    418                // RAIL_LIB-8330: Modified from adding 500 to adding 92, this was tested on xg21 as being the highest
    419                // number we can use without exceeding the requested power in dBm
    420                powerLevel = ((powerLevel + 92U) / 1000U);
   \                     ??RAIL_ConvertDbmToRaw_17: (+1)
   \      0x134   0xF119 0x095C      ADDS     R9,R9,#+92
   \      0x138   0xF44F 0x707A      MOV      R0,#+1000
   \      0x13C   0xFBB9 0xF0F0      UDIV     R0,R9,R0
    421          
    422                // In case it turns out the resultant power level was too low and we have
    423                // to recalculate with the next curve...
    424                curveIndex++;
   \      0x140   0xF11E 0x0E01      ADDS     LR,LR,#+1
    425              } while ((curveIndex < (int16_t)modeInfo->segments)
    426                       && (powerLevel <= paParams->powerParams[curveIndex].maxPowerLevel));
   \      0x144   0x46F1             MOV      R9,LR
   \      0x146   0xF895 0xA001      LDRB     R10,[R5, #+1]
   \      0x14A   0xFA0F 0xF989      SXTH     R9,R9
   \      0x14E   0xFA0F 0xFA8A      SXTH     R10,R10
   \      0x152   0x45D1             CMP      R9,R10
   \      0x154   0xDA08             BGE.N    ??RAIL_ConvertDbmToRaw_18
   \      0x156   0x46F0             MOV      R8,LR
   \      0x158   0xFA0F 0xF888      SXTH     R8,R8
   \      0x15C   0xEB01 0x08C8      ADD      R8,R1,R8, LSL #+3
   \      0x160   0xF8B8 0x8004      LDRH     R8,[R8, #+4]
   \      0x164   0x4580             CMP      R8,R0
   \      0x166   0xD2D1             BCS.N    ??RAIL_ConvertDbmToRaw_15
    427          
    428              // We already know that curveIndex is at most modeInfo->segments
    429              if (powerLevel > paParams->powerParams[curveIndex - 1].maxPowerLevel) {
   \                     ??RAIL_ConvertDbmToRaw_18: (+1)
   \      0x168   0x46F0             MOV      R8,LR
   \      0x16A   0xFA0F 0xF888      SXTH     R8,R8
   \      0x16E   0xEB01 0x08C8      ADD      R8,R1,R8, LSL #+3
   \      0x172   0xF838 0x8C04      LDRH     R8,[R8, #-4]
   \      0x176   0x4580             CMP      R8,R0
   \      0x178   0xD207             BCS.N    ??RAIL_ConvertDbmToRaw_19
    430                powerLevel = paParams->powerParams[curveIndex - 1].maxPowerLevel;
   \      0x17A   0x46F0             MOV      R8,LR
   \      0x17C   0xFA0F 0xF888      SXTH     R8,R8
   \      0x180   0xEB01 0x08C8      ADD      R8,R1,R8, LSL #+3
   \      0x184   0xF838 0x8C04      LDRH     R8,[R8, #-4]
   \      0x188   0x4640             MOV      R0,R8
    431              }
    432          
    433              // If we go below the minimum we want included in the curve fit, force it.
    434              if (powerLevel < minPowerLevel) {
   \                     ??RAIL_ConvertDbmToRaw_19: (+1)
   \      0x18A   0x42B0             CMP      R0,R6
   \      0x18C   0xD200             BCS.N    ??RAIL_ConvertDbmToRaw_20
    435                powerLevel = minPowerLevel;
   \      0x18E   0x0030             MOVS     R0,R6
    436              }
    437          
    438              return (RAIL_TxPowerLevel_t)powerLevel;
   \                     ??RAIL_ConvertDbmToRaw_20: (+1)
   \      0x190   0xB2C0             UXTB     R0,R0
   \      0x192   0xE000             B.N      ??RAIL_ConvertDbmToRaw_1
    439            }
    440            return 0U;
   \                     ??RAIL_ConvertDbmToRaw_2: (+1)
   \      0x194   0x2000             MOVS     R0,#+0
   \                     ??RAIL_ConvertDbmToRaw_1: (+1)
   \      0x196   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    441          }
    442          
    443          #ifdef RAIL_PA_CONVERSIONS_WEAK
    444          __WEAK
    445          #endif

   \                                 In section .text, align 2, keep-with-next
    446          RAIL_TxPower_t RAIL_ConvertRawToDbm(RAIL_Handle_t railHandle,
    447                                              RAIL_TxPowerMode_t mode,
    448                                              RAIL_TxPowerLevel_t powerLevel)
    449          {
   \                     RAIL_ConvertRawToDbm: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
    450            (void)railHandle;
    451          
    452            if ((mode < sizeof(supportedPaIndices))
    453                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
   \        0x6   0x0008             MOVS     R0,R1
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x280A             CMP      R0,#+10
   \        0xC   0xF080 0x8091      BCS.W    ??RAIL_ConvertRawToDbm_0
   \       0x10   0x....             LDR.N    R0,??DataTable8
   \       0x12   0x000B             MOVS     R3,R1
   \       0x14   0xB2DB             UXTB     R3,R3
   \       0x16   0x5CC3             LDRB     R3,[R0, R3]
   \       0x18   0x2B05             CMP      R3,#+5
   \       0x1A   0xF080 0x808A      BCS.W    ??RAIL_ConvertRawToDbm_0
    454              RAIL_PaDescriptor_t const *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
   \       0x1E   0x....             LDR.N    R3,??DataTable8_1
   \       0x20   0x000D             MOVS     R5,R1
   \       0x22   0xB2ED             UXTB     R5,R5
   \       0x24   0x5D40             LDRB     R0,[R0, R5]
   \       0x26   0xEB03 0x05C0      ADD      R5,R3,R0, LSL #+3
    455              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_MAPPING_TABLE) {
   \       0x2A   0x7828             LDRB     R0,[R5, #+0]
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD11B             BNE.N    ??RAIL_ConvertRawToDbm_1
    456                // Limit the max power level
    457                if (powerLevel > modeInfo->max) {
   \       0x30   0x78EB             LDRB     R3,[R5, #+3]
   \       0x32   0x0010             MOVS     R0,R2
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x4283             CMP      R3,R0
   \       0x38   0xD201             BCS.N    ??RAIL_ConvertRawToDbm_2
    458                  powerLevel = modeInfo->max;
   \       0x3A   0x78E8             LDRB     R0,[R5, #+3]
   \       0x3C   0x0002             MOVS     R2,R0
    459                }
    460          
    461                // We 1-index low power PA power levels, but of course arrays are 0 indexed
    462                powerLevel -= MAX(modeInfo->min, PA_CONVERSION_MINIMUM_PWRLVL);
   \                     ??RAIL_ConvertRawToDbm_2: (+1)
   \       0x3E   0x78A8             LDRB     R0,[R5, #+2]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD001             BEQ.N    ??RAIL_ConvertRawToDbm_3
   \       0x44   0x78A8             LDRB     R0,[R5, #+2]
   \       0x46   0xE000             B.N      ??RAIL_ConvertRawToDbm_4
   \                     ??RAIL_ConvertRawToDbm_3: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??RAIL_ConvertRawToDbm_4: (+1)
   \       0x4A   0x1A12             SUBS     R2,R2,R0
    463          
    464                //If the index calculation above underflowed, then provide the lowest array index.
    465                if (powerLevel > (modeInfo->max - modeInfo->min)) {
   \       0x4C   0x78EB             LDRB     R3,[R5, #+3]
   \       0x4E   0x78A8             LDRB     R0,[R5, #+2]
   \       0x50   0x1A1B             SUBS     R3,R3,R0
   \       0x52   0x0010             MOVS     R0,R2
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0x4283             CMP      R3,R0
   \       0x58   0xDA01             BGE.N    ??RAIL_ConvertRawToDbm_5
    466                  powerLevel = 0U;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x0002             MOVS     R2,R0
    467                }
    468                return modeInfo->conversion.mappingTable[powerLevel];
   \                     ??RAIL_ConvertRawToDbm_5: (+1)
   \       0x5E   0x6868             LDR      R0,[R5, #+4]
   \       0x60   0xB2D2             UXTB     R2,R2
   \       0x62   0xF930 0x0012      LDRSH    R0,[R0, R2, LSL #+1]
   \       0x66   0xE065             B.N      ??RAIL_ConvertRawToDbm_6
    469              } else {
    470          #if defined(_SILICON_LABS_32B_SERIES_1) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    471                // Although 0 is a legitimate power on non-2.4 LP PA's and can be set via
    472                // "RAIL_SetTxPower(railHandle, 0)" it is MUCH lower than power
    473                // level 1 (approximately -50 dBm). Including it in the piecewise
    474                // linear fit would skew the curve substantially, so we exclude it
    475                // from the conversion.
    476                if (powerLevel == 0U) {
    477                  return -500;
    478                }
    479          #endif
    480          
    481                RAIL_TxPowerCurveAlt_t const *powerCurve = modeInfo->conversion.powerCurve;
   \                     ??RAIL_ConvertRawToDbm_1: (+1)
   \       0x68   0x686B             LDR      R3,[R5, #+4]
    482                // Check for a valid powerCurve pointer before using it
    483                if (powerCurve == NULL) {
   \       0x6A   0x2B00             CMP      R3,#+0
   \       0x6C   0xD101             BNE.N    ??RAIL_ConvertRawToDbm_7
    484                  return RAIL_TX_POWER_MIN;
   \       0x6E   0x....             LDR.N    R0,??DataTable8_3
   \       0x70   0xE060             B.N      ??RAIL_ConvertRawToDbm_6
    485                }
    486          
    487                RAIL_TxPowerCurveSegment_t const *powerParams = powerCurve->powerParams;
   \                     ??RAIL_ConvertRawToDbm_7: (+1)
   \       0x72   0x1D1E             ADDS     R6,R3,#+4
    488          
    489                // Hard code the extremes (i.e. don't use the curve fit) in order
    490                // to make it clear that we are reaching the extent of the chip's
    491                // capabilities
    492                if (powerLevel <= modeInfo->min) {
   \       0x74   0x78AF             LDRB     R7,[R5, #+2]
   \       0x76   0x0010             MOVS     R0,R2
   \       0x78   0xB2C0             UXTB     R0,R0
   \       0x7A   0x4287             CMP      R7,R0
   \       0x7C   0xD302             BCC.N    ??RAIL_ConvertRawToDbm_8
    493                  return powerCurve->minPower;
   \       0x7E   0xF9B3 0x0002      LDRSH    R0,[R3, #+2]
   \       0x82   0xE057             B.N      ??RAIL_ConvertRawToDbm_6
    494                } else if (powerLevel >= modeInfo->max) {
   \                     ??RAIL_ConvertRawToDbm_8: (+1)
   \       0x84   0x0017             MOVS     R7,R2
   \       0x86   0x78E8             LDRB     R0,[R5, #+3]
   \       0x88   0xB2FF             UXTB     R7,R7
   \       0x8A   0x4287             CMP      R7,R0
   \       0x8C   0xD302             BCC.N    ??RAIL_ConvertRawToDbm_9
    495                  return powerCurve->maxPower;
   \       0x8E   0xF9B3 0x0000      LDRSH    R0,[R3, #+0]
   \       0x92   0xE04F             B.N      ??RAIL_ConvertRawToDbm_6
    496                } else {
    497                  // Power level is within bounds (MISRA required else)
    498                }
    499          
    500                // Figure out which parameter to use based on the power level
    501                uint8_t x = 0;
   \                     ??RAIL_ConvertRawToDbm_9: (+1)
   \       0x94   0xF05F 0x0C00      MOVS     R12,#+0
    502                uint8_t upperBound = modeInfo->segments - 1U;
   \       0x98   0x7868             LDRB     R0,[R5, #+1]
   \       0x9A   0x1E47             SUBS     R7,R0,#+1
    503          
    504                // If the first curve segment starts with RAIL_TX_POWER_LEVEL_INVALID,
    505                // then it is an additional curve segment that stores maxpower and increment
    506                // (in deci-dBm) used to generate the curves.
    507                // The extra info segment is present only if the curves were generated using
    508                // values other than default - RAIL_TX_POWER_CURVE_DEFAULT_MAX and
    509                // RAIL_TX_POWER_CURVE_DEFAULT_INCREMENT.
    510                if ((powerParams[0].maxPowerLevel) == RAIL_TX_POWER_LEVEL_INVALID) {
   \       0x9C   0x8830             LDRH     R0,[R6, #+0]
   \       0x9E   0x28FF             CMP      R0,#+255
   \       0xA0   0xD101             BNE.N    ??RAIL_ConvertRawToDbm_10
    511                  x = 1U; // skip over the first entry
   \       0xA2   0x2001             MOVS     R0,#+1
   \       0xA4   0x4684             MOV      R12,R0
    512                }
    513          
    514                for (; x < upperBound; x++) {
   \                     ??RAIL_ConvertRawToDbm_10: (+1)
   \       0xA6   0x46E6             MOV      LR,R12
   \       0xA8   0x0038             MOVS     R0,R7
   \       0xAA   0xFA5F 0xFE8E      UXTB     LR,LR
   \       0xAE   0xB2C0             UXTB     R0,R0
   \       0xB0   0x4586             CMP      LR,R0
   \       0xB2   0xD20D             BCS.N    ??RAIL_ConvertRawToDbm_11
    515                  if (powerParams[x + 1U].maxPowerLevel < powerLevel) {
   \       0xB4   0x4660             MOV      R0,R12
   \       0xB6   0xB2C0             UXTB     R0,R0
   \       0xB8   0xEB06 0x00C0      ADD      R0,R6,R0, LSL #+3
   \       0xBC   0xF8B0 0xE008      LDRH     LR,[R0, #+8]
   \       0xC0   0x0010             MOVS     R0,R2
   \       0xC2   0xB2C0             UXTB     R0,R0
   \       0xC4   0xB280             UXTH     R0,R0
   \       0xC6   0x4586             CMP      LR,R0
   \       0xC8   0xD302             BCC.N    ??RAIL_ConvertRawToDbm_11
    516                    break;
    517                  }
    518                }
   \                     ??RAIL_ConvertRawToDbm_12: (+1)
   \       0xCA   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \       0xCE   0xE7EA             B.N      ??RAIL_ConvertRawToDbm_10
    519                int32_t power;
    520                power = ((1000 * (int32_t)(powerLevel)) - powerParams[x].intercept);
   \                     ??RAIL_ConvertRawToDbm_11: (+1)
   \       0xD0   0x0010             MOVS     R0,R2
   \       0xD2   0xB2C0             UXTB     R0,R0
   \       0xD4   0xF44F 0x7E7A      MOV      LR,#+1000
   \       0xD8   0xFB0E 0xFE00      MUL      LR,LR,R0
   \       0xDC   0x4660             MOV      R0,R12
   \       0xDE   0xB2C0             UXTB     R0,R0
   \       0xE0   0xEB06 0x00C0      ADD      R0,R6,R0, LSL #+3
   \       0xE4   0x6840             LDR      R0,[R0, #+4]
   \       0xE6   0xEBBE 0x0E00      SUBS     LR,LR,R0
    521                power = ((power + ((int32_t)powerParams[x].slope / 2)) / (int32_t)powerParams[x].slope);
   \       0xEA   0x4660             MOV      R0,R12
   \       0xEC   0xB2C0             UXTB     R0,R0
   \       0xEE   0xEB06 0x00C0      ADD      R0,R6,R0, LSL #+3
   \       0xF2   0xF9B0 0x8002      LDRSH    R8,[R0, #+2]
   \       0xF6   0x2002             MOVS     R0,#+2
   \       0xF8   0xFB98 0xF0F0      SDIV     R0,R8,R0
   \       0xFC   0xEB10 0x0E0E      ADDS     LR,R0,LR
   \      0x100   0x4660             MOV      R0,R12
   \      0x102   0xB2C0             UXTB     R0,R0
   \      0x104   0xEB06 0x00C0      ADD      R0,R6,R0, LSL #+3
   \      0x108   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \      0x10C   0xFB9E 0xFEF0      SDIV     LR,LR,R0
    522          
    523                if (power > powerCurve->maxPower) {
   \      0x110   0xF9B3 0x0000      LDRSH    R0,[R3, #+0]
   \      0x114   0x4570             CMP      R0,LR
   \      0x116   0xDA02             BGE.N    ??RAIL_ConvertRawToDbm_13
    524                  return powerCurve->maxPower;
   \      0x118   0xF9B3 0x0000      LDRSH    R0,[R3, #+0]
   \      0x11C   0xE00A             B.N      ??RAIL_ConvertRawToDbm_6
    525                } else if (power < powerCurve->minPower) {
   \                     ??RAIL_ConvertRawToDbm_13: (+1)
   \      0x11E   0xF9B3 0x0002      LDRSH    R0,[R3, #+2]
   \      0x122   0x4586             CMP      LR,R0
   \      0x124   0xDA02             BGE.N    ??RAIL_ConvertRawToDbm_14
    526                  return powerCurve->minPower;
   \      0x126   0xF9B3 0x0002      LDRSH    R0,[R3, #+2]
   \      0x12A   0xE003             B.N      ??RAIL_ConvertRawToDbm_6
    527                } else {
    528                  return (RAIL_TxPower_t)power;
   \                     ??RAIL_ConvertRawToDbm_14: (+1)
   \      0x12C   0x4670             MOV      R0,LR
   \      0x12E   0xB200             SXTH     R0,R0
   \      0x130   0xE000             B.N      ??RAIL_ConvertRawToDbm_6
    529                }
    530              }
    531            }
    532            return RAIL_TX_POWER_MIN;
   \                     ??RAIL_ConvertRawToDbm_0: (+1)
   \      0x132   0x....             LDR.N    R0,??DataTable8_3
   \                     ??RAIL_ConvertRawToDbm_6: (+1)
   \      0x134   0xE8BD 0x81F0      POP      {R4-R8,PC}
    533          }
    534          
    535          #ifdef RAIL_PA_CONVERSIONS_WEAK
    536          __WEAK
    537          #endif

   \                                 In section .text, align 2, keep-with-next
    538          RAIL_Status_t RAIL_GetTxPowerCurveLimits(RAIL_Handle_t railHandle,
    539                                                   RAIL_TxPowerMode_t mode,
    540                                                   RAIL_TxPower_t *maxPower,
    541                                                   RAIL_TxPower_t *increment)
    542          {
   \                     RAIL_GetTxPowerCurveLimits: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0004             MOVS     R4,R0
    543            (void)railHandle;
    544            if ((mode < sizeof(supportedPaIndices))
    545                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x280A             CMP      R0,#+10
   \        0xA   0xD21E             BCS.N    ??RAIL_GetTxPowerCurveLimits_0
   \        0xC   0x....             LDR.N    R0,??DataTable8
   \        0xE   0x000D             MOVS     R5,R1
   \       0x10   0xB2ED             UXTB     R5,R5
   \       0x12   0x5D45             LDRB     R5,[R0, R5]
   \       0x14   0x2D05             CMP      R5,#+5
   \       0x16   0xD218             BCS.N    ??RAIL_GetTxPowerCurveLimits_0
    546              RAIL_PaDescriptor_t const *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
   \       0x18   0x....             LDR.N    R5,??DataTable8_1
   \       0x1A   0x000E             MOVS     R6,R1
   \       0x1C   0xB2F6             UXTB     R6,R6
   \       0x1E   0x5D80             LDRB     R0,[R0, R6]
   \       0x20   0xEB05 0x05C0      ADD      R5,R5,R0, LSL #+3
    547          #if RAIL_SUPPORTS_DBM_POWERSETTING_MAPPING_TABLE
    548              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_DBM_POWERSETTING_MAPPING_TABLE) {
    549                *maxPower = modeInfo->maxPowerDbm;
    550                *increment = modeInfo->step;
    551                return RAIL_STATUS_NO_ERROR;
    552              }
    553          #endif
    554          
    555              //The power max info only for available Linear fit
    556              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_MAPPING_TABLE) {
   \       0x24   0x7828             LDRB     R0,[R5, #+0]
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD101             BNE.N    ??RAIL_GetTxPowerCurveLimits_1
    557                return RAIL_STATUS_INVALID_CALL;
   \       0x2A   0x2003             MOVS     R0,#+3
   \       0x2C   0xE00E             B.N      ??RAIL_GetTxPowerCurveLimits_2
    558              }
    559              *maxPower = RAIL_TX_POWER_CURVE_DEFAULT_MAX;
   \                     ??RAIL_GetTxPowerCurveLimits_1: (+1)
   \       0x2E   0x20C8             MOVS     R0,#+200
   \       0x30   0x8010             STRH     R0,[R2, #+0]
    560              *increment = RAIL_TX_POWER_CURVE_DEFAULT_INCREMENT;
   \       0x32   0x2028             MOVS     R0,#+40
   \       0x34   0x8018             STRH     R0,[R3, #+0]
    561              RAIL_TxPowerCurveAlt_t const *paParams = modeInfo->conversion.powerCurve;
   \       0x36   0x686E             LDR      R6,[R5, #+4]
    562              if ((paParams->powerParams[0].maxPowerLevel) == RAIL_TX_POWER_LEVEL_INVALID) {
   \       0x38   0x88B0             LDRH     R0,[R6, #+4]
   \       0x3A   0x28FF             CMP      R0,#+255
   \       0x3C   0xD103             BNE.N    ??RAIL_GetTxPowerCurveLimits_3
    563                *maxPower = paParams->powerParams[0].slope;
   \       0x3E   0x88F0             LDRH     R0,[R6, #+6]
   \       0x40   0x8010             STRH     R0,[R2, #+0]
    564                *increment = (RAIL_TxPower_t)paParams->powerParams[0].intercept;
   \       0x42   0x68B0             LDR      R0,[R6, #+8]
   \       0x44   0x8018             STRH     R0,[R3, #+0]
    565              }
    566              return RAIL_STATUS_NO_ERROR;
   \                     ??RAIL_GetTxPowerCurveLimits_3: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xE000             B.N      ??RAIL_GetTxPowerCurveLimits_2
    567            }
    568            return RAIL_STATUS_INVALID_PARAMETER;
   \                     ??RAIL_GetTxPowerCurveLimits_0: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \                     ??RAIL_GetTxPowerCurveLimits_2: (+1)
   \       0x4C   0xBC70             POP      {R4-R6}
   \       0x4E   0x4770             BX       LR
    569          }
    570          
    571          // This macro is defined when Silicon Labs builds curves into the library as WEAK
    572          // to ensure it can be overriden by customer versions of these functions. It
    573          // should *not* be defined in a customer build.
    574          #if !defined(RAIL_PA_CONVERSIONS_WEAK) && !defined(HAL_CONFIG)
    575          
    576          #include "sl_rail_util_pa_config.h"
    577          

   \                                 In section .text, align 2, keep-with-next
    578          void sl_rail_util_pa_init(void)
    579          {
   \                     sl_rail_util_pa_init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    580          #if SL_RAIL_UTIL_PA_VOLTAGE_MV > 1800
    581            (void)RAIL_InitTxPowerCurvesAlt(&RAIL_TxPowerCurvesVbat);
   \        0x2   0x....             LDR.N    R0,??DataTable8_4
   \        0x4   0x.... 0x....      BL       RAIL_InitTxPowerCurvesAlt
    582          #else
    583            (void)RAIL_InitTxPowerCurvesAlt(&RAIL_TxPowerCurvesDcdc);
    584          #endif
    585          #if SL_RAIL_UTIL_PA_CALIBRATION_ENABLE
    586            RAIL_EnablePaCal(true);
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x.... 0x....      BL       RAIL_EnablePaCal
    587          #endif
    588          }
   \        0xE   0xBD01             POP      {R0,PC}
    589          
    590          #if RAIL_SUPPORTS_2P4GHZ_BAND

   \                                 In section .data, align 4
    591          static RAIL_TxPowerConfig_t txPowerConfig2p4Ghz = {
   \                     txPowerConfig2p4Ghz:
   \        0x0   0x04               DC8 4
   \        0x1                      DS8 1
   \        0x2   0x0CE4 0x000A      DC16 3'300, 10
   \        0x6                      DS8 2
    592            .mode = SL_RAIL_UTIL_PA_SELECTION_2P4GHZ,
    593            .voltage = SL_RAIL_UTIL_PA_VOLTAGE_MV,
    594            .rampTime = SL_RAIL_UTIL_PA_RAMP_TIME_US,
    595          };
    596          #endif

   \                                 In section .text, align 2, keep-with-next
    597          RAIL_TxPowerConfig_t *sl_rail_util_pa_get_tx_power_config_2p4ghz(void)
    598          {
    599          #if RAIL_SUPPORTS_2P4GHZ_BAND
    600            return &txPowerConfig2p4Ghz;
   \                     sl_rail_util_pa_get_tx_power_config_2p4ghz: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable8_5
   \        0x2   0x4770             BX       LR
    601          #else
    602            return NULL;
    603          #endif
    604          }
    605          
    606          #if RAIL_SUPPORTS_SUBGHZ_BAND

   \                                 In section .data, align 4
    607          static RAIL_TxPowerConfig_t txPowerConfigSubGhz = {
   \                     txPowerConfigSubGhz:
   \        0x0   0x0A               DC8 10
   \        0x1                      DS8 1
   \        0x2   0x0CE4 0x000A      DC16 3'300, 10
   \        0x6                      DS8 2
    608            .mode = SL_RAIL_UTIL_PA_SELECTION_SUBGHZ,
    609            .voltage = SL_RAIL_UTIL_PA_VOLTAGE_MV,
    610            .rampTime = SL_RAIL_UTIL_PA_RAMP_TIME_US,
    611          };
    612          #endif

   \                                 In section .text, align 2, keep-with-next
    613          RAIL_TxPowerConfig_t *sl_rail_util_pa_get_tx_power_config_subghz(void)
    614          {
    615          #if RAIL_SUPPORTS_SUBGHZ_BAND
    616            return &txPowerConfigSubGhz;
   \                     sl_rail_util_pa_get_tx_power_config_subghz: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable8_6
   \        0x2   0x4770             BX       LR
    617          #else
    618            return NULL;
    619          #endif
    620          }
    621          
    622          #if RAIL_SUPPORTS_OFDM_PA
    623          #ifndef SL_RAIL_UTIL_PA_SELECTION_OFDM
    624          #define SL_RAIL_UTIL_PA_SELECTION_OFDM RAIL_TX_POWER_MODE_OFDM_PA_POWERSETTING_TABLE
    625          #endif
    626          static RAIL_TxPowerConfig_t txPowerConfigOFDM = {
    627            .mode = SL_RAIL_UTIL_PA_SELECTION_OFDM,
    628            .voltage = SL_RAIL_UTIL_PA_VOLTAGE_MV,
    629          };
    630          #endif // RAIL_SUPPORTS_OFDM_PA

   \                                 In section .text, align 2, keep-with-next
    631          RAIL_TxPowerConfig_t *sl_rail_util_pa_get_tx_power_config_ofdm(void)
    632          {
    633          #if RAIL_SUPPORTS_OFDM_PA
    634            return &txPowerConfigOFDM;
    635          #else
    636            return NULL;
   \                     sl_rail_util_pa_get_tx_power_config_ofdm: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR
    637          #endif // RAIL_SUPPORTS_OFDM_PA
    638          }
    639          

   \                                 In section .text, align 2, keep-with-next
    640          void sl_rail_util_pa_on_channel_config_change(RAIL_Handle_t rail_handle,
    641                                                        const RAIL_ChannelConfigEntry_t *entry)
    642          {
   \                     sl_rail_util_pa_on_channel_config_change: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    643            if (!RAIL_IsPaAutoModeEnabled(rail_handle)) {
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       RAIL_IsPaAutoModeEnabled
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD141             BNE.N    ??sl_rail_util_pa_on_channel_config_change_0
    644              RAIL_TxPowerConfig_t currentTxPowerConfig;
    645              RAIL_TxPowerConfig_t *newTxPowerConfigPtr;
    646              RAIL_Status_t status;
    647          
    648              // Get current TX Power Config.
    649              status = RAIL_GetTxPowerConfig(rail_handle, &currentTxPowerConfig);
   \       0x12   0x4669             MOV      R1,SP
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       RAIL_GetTxPowerConfig
   \       0x1A   0x4680             MOV      R8,R0
    650              if (status != RAIL_STATUS_NO_ERROR) {
   \       0x1C   0x4640             MOV      R0,R8
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD000             BEQ.N    ??sl_rail_util_pa_on_channel_config_change_1
    651                while (true) {
   \                     ??sl_rail_util_pa_on_channel_config_change_2: (+1)
   \       0x24   0xE7FE             B.N      ??sl_rail_util_pa_on_channel_config_change_2
    652                } // Error: Can't get TX Power Config
    653              }
    654          
    655          #if RAIL_SUPPORTS_DUAL_BAND
    656              // Determine new TX Power Config.
    657              if (entry->baseFrequency < 1000000000UL) {
   \                     ??sl_rail_util_pa_on_channel_config_change_1: (+1)
   \       0x26   0x6869             LDR      R1,[R5, #+4]
   \       0x28   0x....             LDR.N    R0,??DataTable8_7
   \       0x2A   0x4281             CMP      R1,R0
   \       0x2C   0xD201             BCS.N    ??sl_rail_util_pa_on_channel_config_change_3
    658                newTxPowerConfigPtr = &txPowerConfigSubGhz;
   \       0x2E   0x....             LDR.N    R6,??DataTable8_6
   \       0x30   0xE000             B.N      ??sl_rail_util_pa_on_channel_config_change_4
    659              } else {
    660                newTxPowerConfigPtr = &txPowerConfig2p4Ghz;
   \                     ??sl_rail_util_pa_on_channel_config_change_3: (+1)
   \       0x32   0x....             LDR.N    R6,??DataTable8_5
    661              }
    662          #else
    663              (void) entry;
    664          #if RAIL_SUPPORTS_2P4GHZ_BAND
    665              newTxPowerConfigPtr = &txPowerConfig2p4Ghz;
    666          #else
    667              newTxPowerConfigPtr = &txPowerConfigSubGhz;
    668          #endif
    669          #endif
    670          
    671          #if RAIL_IEEE802154_SUPPORTS_DUAL_PA_CONFIG
    672              if (currentTxPowerConfig.mode == RAIL_TX_POWER_MODE_NONE) {
    673          #if RAIL_SUPPORTS_OFDM_PA
    674                if (RAIL_SupportsTxPowerMode(rail_handle,
    675                                             txPowerConfigOFDM.mode,
    676                                             NULL)) {
    677                  // Apply OFDM Power Config.
    678                  status = RAIL_ConfigTxPower(rail_handle, &txPowerConfigOFDM);
    679                  if (status != RAIL_STATUS_NO_ERROR) {
    680                    while (true) {
    681                    } // Error: Can't set TX Power Config
    682                  }
    683                  // Set default TX power after RAIL_ConfigTxPower.
    684                  status = RAIL_SetTxPowerDbm(rail_handle, SL_RAIL_UTIL_PA_POWER_DECI_DBM);
    685                  if (status != RAIL_STATUS_NO_ERROR) {
    686                    while (true) {
    687                    } // Error: Can't set TX Power
    688                  }
    689                }
    690          #endif // RAIL_SUPPORTS_OFDM_PA
    691                // Apply FSK Power Config.
    692                status = RAIL_ConfigTxPower(rail_handle, newTxPowerConfigPtr);
    693                if (status != RAIL_STATUS_NO_ERROR) {
    694                  while (true) {
    695                  } // Error: Can't set TX Power Config
    696                }
    697                // Set default TX power after RAIL_ConfigTxPower.
    698                status = RAIL_SetTxPowerDbm(rail_handle, SL_RAIL_UTIL_PA_POWER_DECI_DBM);
    699                if (status != RAIL_STATUS_NO_ERROR) {
    700                  while (true) {
    701                  } // Error: Can't set TX Power
    702                }
    703              }
    704          #else
    705              // Call RAIL_ConfigTxPower only if TX Power Config mode has changed.
    706              if (currentTxPowerConfig.mode != newTxPowerConfigPtr->mode) {
   \                     ??sl_rail_util_pa_on_channel_config_change_4: (+1)
   \       0x34   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x38   0x7830             LDRB     R0,[R6, #+0]
   \       0x3A   0x4281             CMP      R1,R0
   \       0x3C   0xD02B             BEQ.N    ??sl_rail_util_pa_on_channel_config_change_0
    707                // Save current TX power before RAIL_ConfigTxPower (because not preserved).
    708                RAIL_TxPower_t txPowerDeciDbm;
    709                if (currentTxPowerConfig.mode == RAIL_TX_POWER_MODE_NONE) {
   \       0x3E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x42   0x280E             CMP      R0,#+14
   \       0x44   0xD101             BNE.N    ??sl_rail_util_pa_on_channel_config_change_5
    710                  txPowerDeciDbm = SL_RAIL_UTIL_PA_POWER_DECI_DBM;
   \       0x46   0x2764             MOVS     R7,#+100
   \       0x48   0xE003             B.N      ??sl_rail_util_pa_on_channel_config_change_6
    711                } else {
    712                  txPowerDeciDbm = RAIL_GetTxPowerDbm(rail_handle);
   \                     ??sl_rail_util_pa_on_channel_config_change_5: (+1)
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       RAIL_GetTxPowerDbm
   \       0x50   0x0007             MOVS     R7,R0
    713                }
    714          
    715                // Apply new TX Power Config.
    716                status = RAIL_ConfigTxPower(rail_handle, newTxPowerConfigPtr);
   \                     ??sl_rail_util_pa_on_channel_config_change_6: (+1)
   \       0x52   0x0031             MOVS     R1,R6
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       RAIL_ConfigTxPower
   \       0x5A   0x4681             MOV      R9,R0
    717                if (status != RAIL_STATUS_NO_ERROR) {
   \       0x5C   0x4648             MOV      R0,R9
   \       0x5E   0xB2C0             UXTB     R0,R0
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD000             BEQ.N    ??sl_rail_util_pa_on_channel_config_change_7
    718                  while (true) {
   \                     ??sl_rail_util_pa_on_channel_config_change_8: (+1)
   \       0x64   0xE7FE             B.N      ??sl_rail_util_pa_on_channel_config_change_8
    719                  } // Error: Can't set TX Power Config
    720                }
    721                // Restore TX power after RAIL_ConfigTxPower.
    722                status = RAIL_SetTxPowerDbm(rail_handle, txPowerDeciDbm);
   \                     ??sl_rail_util_pa_on_channel_config_change_7: (+1)
   \       0x66   0x0039             MOVS     R1,R7
   \       0x68   0xB209             SXTH     R1,R1
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0x.... 0x....      BL       RAIL_SetTxPowerDbm
   \       0x70   0x4680             MOV      R8,R0
    723                if (status != RAIL_STATUS_NO_ERROR) {
   \       0x72   0x4640             MOV      R0,R8
   \       0x74   0xB2C0             UXTB     R0,R0
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD000             BEQ.N    ??sl_rail_util_pa_on_channel_config_change_9
    724                  while (true) {
   \                     ??sl_rail_util_pa_on_channel_config_change_10: (+1)
   \       0x7A   0xE7FE             B.N      ??sl_rail_util_pa_on_channel_config_change_10
    725                  } // Error: Can't set TX Power
    726                }
    727                // If requested a HIGHEST setting, update it with the real one selected
    728                // to short-circuit the next time through here since HIGHEST never
    729                // matches the real PA returned by RAIL_GetTxPowerConfig(), causing
    730                // reconfiguration of the same PA on every callback.
    731                if (false
    732                   #ifdef  RAIL_TX_POWER_MODE_2P4GIG_HIGHEST
    733                    || (newTxPowerConfigPtr->mode == RAIL_TX_POWER_MODE_2P4GIG_HIGHEST)
    734                   #endif
    735                   #ifdef  RAIL_TX_POWER_MODE_SUBGIG_HIGHEST
    736                    || (newTxPowerConfigPtr->mode == RAIL_TX_POWER_MODE_SUBGIG_HIGHEST)
    737                   #endif
    738                    ) {
   \                     ??sl_rail_util_pa_on_channel_config_change_9: (+1)
   \       0x7C   0x7830             LDRB     R0,[R6, #+0]
   \       0x7E   0x2804             CMP      R0,#+4
   \       0x80   0xD002             BEQ.N    ??sl_rail_util_pa_on_channel_config_change_11
   \       0x82   0x7830             LDRB     R0,[R6, #+0]
   \       0x84   0x280A             CMP      R0,#+10
   \       0x86   0xD106             BNE.N    ??sl_rail_util_pa_on_channel_config_change_0
    739                  (void) RAIL_GetTxPowerConfig(rail_handle, &currentTxPowerConfig);
   \                     ??sl_rail_util_pa_on_channel_config_change_11: (+1)
   \       0x88   0x4669             MOV      R1,SP
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x.... 0x....      BL       RAIL_GetTxPowerConfig
    740                  newTxPowerConfigPtr->mode = currentTxPowerConfig.mode;
   \       0x90   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x94   0x7030             STRB     R0,[R6, #+0]
    741                }
    742              }
    743          #endif
    744            } // !RAIL_IsPaAutoModeEnabled
    745          }
   \                     ??sl_rail_util_pa_on_channel_config_change_0: (+1)
   \       0x96   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     supportedPaIndices

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     powerCurvesState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     `RAIL_GetTxPowerCurve::powerCurves`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0xFFFF'8000        DC32     0xffff8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     RAIL_TxPowerCurvesVbat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x....'....        DC32     txPowerConfig2p4Ghz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     txPowerConfigSubGhz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x3B9A'CA00        DC32     0x3b9aca00
    746          #endif // !RAIL_PA_CONVERSIONS_WEAK

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      36   RAIL_ConvertDbmToRaw
      24   RAIL_ConvertRawToDbm
       4   RAIL_GetPowerSettingTable
      16   RAIL_GetTxPowerCurve
        16   -> RAIL_SupportsTxPowerModeAlt
      12   RAIL_GetTxPowerCurveLimits
       0   RAIL_InitTxPowerCurves
       8   RAIL_InitTxPowerCurvesAlt
         8   -> RAIL_VerifyTxPowerCurves
         8   -> __aeabi_memcpy4
       0   sl_rail_util_pa_get_tx_power_config_2p4ghz
       0   sl_rail_util_pa_get_tx_power_config_ofdm
       0   sl_rail_util_pa_get_tx_power_config_subghz
       8   sl_rail_util_pa_init
         8   -> RAIL_EnablePaCal
         8   -> RAIL_InitTxPowerCurvesAlt
      40   sl_rail_util_pa_on_channel_config_change
        40   -> RAIL_ConfigTxPower
        40   -> RAIL_GetTxPowerConfig
        40   -> RAIL_GetTxPowerDbm
        40   -> RAIL_IsPaAutoModeEnabled
        40   -> RAIL_SetTxPowerDbm


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
     410  RAIL_ConvertDbmToRaw
     312  RAIL_ConvertRawToDbm
      10  RAIL_GetPowerSettingTable
      92  RAIL_GetTxPowerCurve
      80  RAIL_GetTxPowerCurveLimits
       6  RAIL_InitTxPowerCurves
      26  RAIL_InitTxPowerCurvesAlt
       8  powerCurves
      48  powerCurvesState
       4  sl_rail_util_pa_get_tx_power_config_2p4ghz
       4  sl_rail_util_pa_get_tx_power_config_ofdm
       4  sl_rail_util_pa_get_tx_power_config_subghz
      16  sl_rail_util_pa_init
     154  sl_rail_util_pa_on_channel_config_change
      12  supportedPaIndices
       8  txPowerConfig2p4Ghz
       8  txPowerConfigSubGhz

 
    56 bytes in section .bss
    16 bytes in section .data
    12 bytes in section .rodata
 1'150 bytes in section .text
 
 1'150 bytes of CODE  memory
    12 bytes of CONST memory
    72 bytes of DATA  memory

Errors: none
Warnings: none
