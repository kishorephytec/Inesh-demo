###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  16:51:20
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\uart_hal.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\Simplicity
#        Configurator_13668623889914588608.dir\uart_hal.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\uart_hal.c" -D
#        DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\Simplicity
#        Configurator_13668623889914588608.dir" --diag_suppress Pa050 -o
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\Simplicity
#        Configurator_13668623889914588608.dir" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\Simplicity
#        Configurator_13668623889914588608.dir\uart_hal.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\Simplicity
#        Configurator_13668623889914588608.dir\uart_hal.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\Simplicity
#        Configurator_13668623889914588608.dir\uart_hal.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\uart_hal.c
      1          /** \file uart_hal.c
      2           *******************************************************************************
      3           ** \brief  Provides APIs for UART driver
      4           **
      5           ** \cond STD_FILE_HEADER
      6           **
      7           ** COPYRIGHT(c) 2023-24 Procubed Innovations Pvt Ltd.
      8           ** All rights reserved.
      9           **
     10           ** THIS SOFTWARE IS PROVIDED BY "AS IS" AND ALL WARRANTIES OF ANY KIND,
     11           ** INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR USE,
     12           ** ARE EXPRESSLY DISCLAIMED.  THE DEVELOPER SHALL NOT BE LIABLE FOR ANY
     13           ** DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE. THIS SOFTWARE
     14           ** MAY NOT BE USED IN PRODUCTS INTENDED FOR USE IN IMPLANTATION OR OTHER
     15           ** DIRECT LIFE SUPPORT APPLICATIONS WHERE MALFUNCTION MAY RESULT IN THE DIRECT
     16           ** PHYSICAL HARM OR INJURY TO PERSONS. ALL SUCH IS USE IS EXPRESSLY PROHIBITED.
     17           **
     18           *******************************************************************************
     19           **  \endcond
     20           */
     21          
     22          
     23          /*******************************************************************************
     24          * File inclusion
     25          *******************************************************************************/
     26          
     27          #include "pin_config.h"
     28          #include "common.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __vfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....             LDR.N    R3,??DataTable12
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0xB249             SXTB     R1,R1
   \       0x16   0x0949             LSRS     R1,R1,#+5
   \       0x18   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void __NVIC_ClearPendingIRQ(IRQn_Type)
   \                     __NVIC_ClearPendingIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_ClearPendingIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....             LDR.N    R3,??DataTable12_1
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0xB249             SXTB     R1,R1
   \       0x16   0x0949             LSRS     R1,R1,#+5
   \       0x18   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \                     ??__NVIC_ClearPendingIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR
     29          #include "em_device.h"
     30          #include "em_cmu.h"
     31          #include "em_gpio.h"
     32          #include "em_usart.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void USART_IntClear(USART_TypeDef *, uint32_t)
   \                     USART_IntClear: (+1)
   \        0x0   0xF242 0x0248      MOVW     R2,#+8264
   \        0x4   0x5081             STR      R1,[R0, R2]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void USART_IntDisable(USART_TypeDef *, uint32_t)
   \                     USART_IntDisable: (+1)
   \        0x0   0x6CC2             LDR      R2,[R0, #+76]
   \        0x2   0x438A             BICS     R2,R2,R1
   \        0x4   0x64C2             STR      R2,[R0, #+76]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void USART_IntEnable(USART_TypeDef *, uint32_t)
   \                     USART_IntEnable: (+1)
   \        0x0   0x6CC2             LDR      R2,[R0, #+76]
   \        0x2   0x430A             ORRS     R2,R1,R2
   \        0x4   0x64C2             STR      R2,[R0, #+76]
   \        0x6   0x4770             BX       LR
     33          #include "uart_hal.h"
     34          #include "rail.h"
     35          #include "rail_types.h"
     36          
     37          /*
     38          ** ============================================================================
     39          ** Private Macro definitions
     40          ** ============================================================================
     41          */
     42          #ifndef UART_TX_BUF_LEN
     43          #define UART_TX_BUF_LEN	2300
     44          #endif
     45          
     46          #ifndef NUMBER_OF_UART_TX_BUFFERS
     47          #define NUMBER_OF_UART_TX_BUFFERS	0
     48          #endif
     49          
     50          
     51          #define APP_USART0_BAUDRATE 9600
     52          #define APP_USART0_TX_PORT gpioPortB
     53          #define APP_USART0_TX_PIN 3
     54          
     55          #define APP_USART0_RX_PORT gpioPortB
     56          #define APP_USART0_RX_PIN 2
     57          
     58          #define UART_TIMEOUT_US 100000 // Timeout duration in milliseconds
     59          /*
     60          ** ============================================================================
     61          ** Private Structures, Unions & enums Type Definitions
     62          ** ============================================================================
     63          */
     64          
     65          typedef struct P3_BUFFER_tag
     66          {
     67              uint8_t* p_data;
     68              uint16_t element_count;
     69              void* p_cb_param;
     70          }P3_BUFFER_t;
     71          

   \                                 In section .bss, align 4
     72          P3_BUFFER_t uart0_rx_buffer;
   \                     uart0_rx_buffer:
   \        0x0                      DS8 12
     73          

   \                                 In section .bss, align 4
     74          P3_BUFFER_t uart1_rx_buffer;
   \                     uart1_rx_buffer:
   \        0x0                      DS8 12
     75          
     76          // Define the RAIL handle

   \                                 In section .bss, align 4
     77          static RAIL_Handle_t railHandle;
   \                     railHandle:
   \        0x0                      DS8 4
     78          
     79          
     80          

   \                                 In section .bss, align 4
     81          ring_buffer_t r_buff;
   \                     r_buff:
   \        0x0                      DS8 1'028
     82          /*
     83          When Using Only Usart as commucation to meater Usae USART0 default
     84          If SPI flash is requred the make communication USART0 to EUSART0 because USART0 is used by SPI
     85          Only 1 USART phereperal is avaliable 
     86          */
     87          /* Setup UART1 in async mode for RS232*/

   \                                 In section .data, align 4
     88          static USART_TypeDef           *uart0   = USART0;
   \                     uart0:
   \        0x0   0x5005'C000        DC32 0x5005'c000
     89          
     90          
     91          /*
     92          ** ============================================================================
     93          ** Private Variable Definitions
     94          ** ============================================================================
     95          */
     96          

   \                                 In section .bss, align 4
     97          volatile uint8_t * gp_uart0_tx_address;        /* uart1 transmit buffer address */
   \                     gp_uart0_tx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
     98          volatile uint16_t  g_uart0_tx_count;           /* uart1 transmit data number */
   \                     g_uart0_tx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 4
     99          volatile uint8_t * gp_uart0_rx_address;        /* uart1 receive buffer address */
   \                     gp_uart0_rx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
    100          volatile uint16_t  g_uart0_rx_count;           /* uart1 receive data number */
   \                     g_uart0_rx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
    101          volatile uint16_t  g_uart0_rx_length;          /* uart1 receive data length */
   \                     g_uart0_rx_length:
   \        0x0                      DS8 2
    102          
    103          

   \                                 In section .bss, align 4
    104          volatile uint8_t * gp_uart1_tx_address;        /* uart1 transmit buffer address */
   \                     gp_uart1_tx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
    105          volatile uint16_t  g_uart1_tx_count;           /* uart1 transmit data number */
   \                     g_uart1_tx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 4
    106          volatile uint8_t * gp_uart1_rx_address;        /* uart1 receive buffer address */
   \                     gp_uart1_rx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
    107          volatile uint16_t  g_uart1_rx_count;           /* uart1 receive data number */
   \                     g_uart1_rx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
    108          volatile uint16_t  g_uart1_rx_length;          /* uart1 receive data length */
   \                     g_uart1_rx_length:
   \        0x0                      DS8 2
    109          
    110          /*
    111          ** ============================================================================
    112          ** Private Macro definitions
    113          ** ============================================================================
    114          */
    115          
    116          
    117          
    118          
    119          
    120          /*
    121          ** ============================================================================
    122          ** Private Structures, Unions & enums Type Definitions
    123          ** ============================================================================
    124          */
    125          
    126          
    127          
    128          /*
    129          ** ============================================================================
    130          ** Public Variable Definitions
    131          ** ============================================================================
    132          */
    133          

   \                                 In section .bss, align 4
    134          uart_hal_data_t uart_hal_info;
   \                     uart_hal_info:
   \        0x0                      DS8 8

   \                                 In section .data, align 1
    135          volatile uint8_t uart0_trigger_tx = 1;
   \                     uart0_trigger_tx:
   \        0x0   0x01               DC8 1
    136          

   \                                 In section .data, align 1
    137          volatile uint8_t uart1_trigger_tx = 1;
   \                     uart1_trigger_tx:
   \        0x0   0x01               DC8 1
    138          static uint8_t uart1_rx_byte;
    139          

   \                                 In section .bss, align 1
    140          volatile bool dataready=false;
   \                     dataready:
   \        0x0                      DS8 1
    141          
    142           // Timer for UART timeout

   \                                 In section .bss, align 1
    143          volatile bool uart_timeout = false; // Flag to indicate timeout
   \                     uart_timeout:
   \        0x0                      DS8 1
    144          
    145          /*
    146          ** ============================================================================
    147          ** External Variable Declarations
    148          ** ============================================================================
    149          */
    150          
    151              /* None */
    152          
    153          /*
    154          ** ============================================================================
    155          ** Private Function Prototypes
    156          ** ============================================================================
    157          */
    158          
    159            /* None */
    160          
    161          /*
    162          ** ============================================================================
    163          ** Public Function Definitions
    164          ** ============================================================================
    165          */
    166          // UART timeout callback function pointer

   \                                 In section .bss, align 4
    167          static void (*uart_timeout_cb)(void) = NULL;
   \                     uart_timeout_cb:
   \        0x0                      DS8 4
    168          
    169          // Timer callback function

   \                                 In section .text, align 2, keep-with-next
    170          void uart_timeout_callback(RAIL_Handle_t railHandle)
    171          {
   \                     uart_timeout_callback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    172              
    173            // Call the registered timeout callback
    174              if (uart_timeout_cb != NULL) {
   \        0x4   0x....             LDR.N    R1,??DataTable12_2
   \        0x6   0x6808             LDR      R0,[R1, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD001             BEQ.N    ??uart_timeout_callback_0
    175                  uart_timeout_cb();
   \        0xC   0x6808             LDR      R0,[R1, #+0]
   \        0xE   0x4780             BLX      R0
    176              }
    177          }
   \                     ??uart_timeout_callback_0: (+1)
   \       0x10   0xBD10             POP      {R4,PC}
    178          

   \                                 In section .text, align 2, keep-with-next
    179          void UART_init(void)
    180          {  
   \                     UART_init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
    181            
    182               /*
    183          
    184              Raka :: Needs to do clean up once UART is tested Properly  [ 13- Sep - 2022 ]
    185              */
    186          CMU_ClockEnable(cmuClock_USART0, true);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2029             MOVS     R0,#+41
   \        0x8   0x.... 0x....      BL       CMU_ClockEnable
    187              CMU_ClockEnable(cmuClock_GPIO, true);
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x203A             MOVS     R0,#+58
   \       0x10   0x.... 0x....      BL       CMU_ClockEnable
    188            
    189            // Default asynchronous initializer (115.2 Kbps, 8N1, no flow control)
    190              
    191              USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;  // this is for FG13
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x....             LDR.N    R1,??DataTable12_3
   \       0x18   0x221C             MOVS     R2,#+28
   \       0x1A   0x.... 0x....      BL       __aeabi_memcpy4
    192              
    193              
    194               /* Configure GPIO pins  for communication UART  :: LOC 22*/
    195              GPIO_PinModeSet(APP_USART0_TX_PORT, APP_USART0_TX_PIN, gpioModePushPull, 1); // tx
   \       0x1E   0x2301             MOVS     R3,#+1
   \       0x20   0x2204             MOVS     R2,#+4
   \       0x22   0x2103             MOVS     R1,#+3
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x.... 0x....      BL       GPIO_PinModeSet
    196              GPIO_PinModeSet(APP_USART0_RX_PORT, APP_USART0_RX_PIN, gpioModeInput, 0);     // rx
   \       0x2A   0x2300             MOVS     R3,#+0
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x2102             MOVS     R1,#+2
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x.... 0x....      BL       GPIO_PinModeSet
    197          
    198              
    199              // Route USART0 TX and RX to the board controller TX and RX pins
    200              GPIO->USARTROUTE[0].TXROUTE = (APP_USART0_TX_PORT << _GPIO_USART_TXROUTE_PORT_SHIFT)
    201                | (APP_USART0_TX_PIN << _GPIO_USART_TXROUTE_PIN_SHIFT);
   \       0x36   0x....             LDR.N    R1,??DataTable12_4
   \       0x38   0x....             LDR.N    R0,??DataTable12_5
   \       0x3A   0x6001             STR      R1,[R0, #+0]
    202            GPIO->USARTROUTE[0].RXROUTE = (APP_USART0_RX_PORT << _GPIO_USART_RXROUTE_PORT_SHIFT)
    203                | (APP_USART0_RX_PIN << _GPIO_USART_RXROUTE_PIN_SHIFT);
   \       0x3C   0x....             LDR.N    R1,??DataTable12_6
   \       0x3E   0x....             LDR.N    R0,??DataTable12_7
   \       0x40   0x6001             STR      R1,[R0, #+0]
    204              // Clock configuration ....
    205          
    206             // Enable RX and TX signals now that they have been routed
    207            GPIO->USARTROUTE[0].ROUTEEN = GPIO_USART_ROUTEEN_RXPEN | GPIO_USART_ROUTEEN_TXPEN;
   \       0x42   0x2114             MOVS     R1,#+20
   \       0x44   0x....             LDR.N    R0,??DataTable12_8
   \       0x46   0x6001             STR      R1,[R0, #+0]
    208              
    209                // The Baud rate for the Communication.
    210              init.baudrate = APP_USART0_BAUDRATE ;
   \       0x48   0xF44F 0x5016      MOV      R0,#+9600
   \       0x4C   0x9002             STR      R0,[SP, #+8]
    211          
    212              // Configure and enable USART0
    213              USART_InitAsync(USART0, &init);          // this is for FG13
   \       0x4E   0x....             LDR.N    R4,??DataTable12_9
   \       0x50   0x4669             MOV      R1,SP
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       USART_InitAsync
    214              
    215             
    216          
    217              
    218             //  EUSART_UartInit_TypeDef init = EUSART_UART_INIT_DEFAULT_HF;   // this is for FG23
    219           
    220             // EUSART_UartInitHf(EUSART1, &init);          // this is for FG23
    221          
    222              /* Prepare UART Rx and Tx interrupts */
    223             // USART_IntClear(uart0, _USART_IF_MASK);            // this is for FG13
    224            //   EUSART_IntClear(EUSART1, _EUSART_IEN_MASK);        // this is for FG23
    225             // USART_IntEnable(uart0, USART_IF_RXDATAV);         // this is for FG13
    226           //   EUSART_IntEnable(EUSART1, EUSART_IEN_RXFL);         // this is for FG23
    227              
    228              //// this is for FG13
    229              NVIC_ClearPendingIRQ(USART0_RX_IRQn);
   \       0x58   0x2009             MOVS     R0,#+9
   \       0x5A   0x.... 0x....      BL       __NVIC_ClearPendingIRQ
    230              USART_IntEnable(USART0, USART_IEN_RXDATAV);
   \       0x5E   0x2104             MOVS     R1,#+4
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       USART_IntEnable
    231              NVIC_EnableIRQ(USART0_RX_IRQn);
   \       0x66   0x2009             MOVS     R0,#+9
   \       0x68   0x.... 0x....      BL       __NVIC_EnableIRQ
    232              NVIC_ClearPendingIRQ(USART0_TX_IRQn);
   \       0x6C   0x200A             MOVS     R0,#+10
   \       0x6E   0x.... 0x....      BL       __NVIC_ClearPendingIRQ
    233              NVIC_EnableIRQ(USART0_TX_IRQn);
   \       0x72   0x200A             MOVS     R0,#+10
   \       0x74   0x.... 0x....      BL       __NVIC_EnableIRQ
    234              
    235              //// this is for FG23
    236          //  NVIC_ClearPendingIRQ(EUSART1_RX_IRQn);
    237          //  NVIC_ClearPendingIRQ(EUSART1_TX_IRQn);
    238          //  NVIC_EnableIRQ(EUSART1_RX_IRQn);
    239          //  NVIC_EnableIRQ(EUSART1_TX_IRQn);
    240              
    241          // this is for FG13 
    242            //for fg23 PIN loc not required
    243              // Enable RX and TX for USART0 VCOM connection
    244           //   USART0->ROUTELOC0 = USART_ROUTELOC0_RXLOC_LOC22 | USART_ROUTELOC0_TXLOC_LOC22;
    245            //  USART0->ROUTEPEN |= USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;
    246          //  g_uart0_rx_length=UART_RX_BUF_LEN;
    247          
    248              // Initialize the ring buffer
    249              r_buff.head = 0;
   \       0x78   0x....             LDR.N    R0,??DataTable12_10
   \       0x7A   0x2100             MOVS     R1,#+0
   \       0x7C   0xF8A0 0x1400      STRH     R1,[R0, #+1024]
    250              r_buff.tail = 0;
   \       0x80   0x2100             MOVS     R1,#+0
   \       0x82   0xF8A0 0x1402      STRH     R1,[R0, #+1026]
    251          }
   \       0x86   0xB008             ADD      SP,SP,#+32
   \       0x88   0xBD10             POP      {R4,PC}
    252          
    253          /* Register UART timeout callback */

   \                                 In section .text, align 2, keep-with-next
    254          void register_uart_timeout_cb(void (*callback)(void))
    255          {
    256              uart_timeout_cb = callback;
   \                     register_uart_timeout_cb: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable12_2
   \        0x2   0x6008             STR      R0,[R1, #+0]
    257          }
   \        0x4   0x4770             BX       LR
    258          
    259          /* Initialize the RAIL timer */

   \                                 In section .text, align 2, keep-with-next
    260          void UART_init_rail_timer(RAIL_Handle_t handle)
    261          {
    262              railHandle = handle;
   \                     UART_init_rail_timer: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable12_11
   \        0x2   0x6008             STR      R0,[R1, #+0]
    263          }
   \        0x4   0x4770             BX       LR
    264          /******************************************************************************/
    265          

   \                                 In section .text, align 2, keep-with-next
    266          void UART_close(void)
    267          {
   \                     UART_close: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    268            USART_Reset(uart0);         //This is for FG13
   \        0x2   0x....             LDR.N    R0,??DataTable12_12
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x.... 0x....      BL       USART_Reset
    269          //  EUSART_Reset(EUSART1);        //This is for FG23
    270          }
   \        0xA   0xBD01             POP      {R0,PC}
    271          
    272          /******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    273          int8_t uart_hal_read( uint8_t* p_data, uint16_t len )
    274          {
   \                     uart_hal_read: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    275          	uart0_rx_buffer.p_data = p_data;
   \        0x2   0x....             LDR.N    R0,??DataTable12_13
   \        0x4   0x6002             STR      R2,[R0, #+0]
    276          	uart0_rx_buffer.element_count = ( uint16_t )len;
   \        0x6   0x8081             STRH     R1,[R0, #+4]
    277                  
    278                  g_uart0_rx_count = 0U;
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x....             LDR.N    R0,??DataTable12_14
   \        0xC   0x8003             STRH     R3,[R0, #+0]
    279                  g_uart0_rx_length = ( uint16_t )len;
   \        0xE   0x....             LDR.N    R0,??DataTable12_15
   \       0x10   0x8001             STRH     R1,[R0, #+0]
    280                  gp_uart0_rx_address = p_data;
   \       0x12   0x....             LDR.N    R0,??DataTable12_16
   \       0x14   0x6002             STR      R2,[R0, #+0]
    281                  
    282          	return 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x4770             BX       LR
    283          }
    284          
    285          /******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    286          int8_t uart_hal_write( uint8_t* p_data, uint16_t len )
    287          {
   \                     uart_hal_write: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
    288              uint32_t sent = 0;
   \        0x8   0xF05F 0x0800      MOVS     R8,#+0
    289            uint8_t * _buffer = (uint8_t *) p_data;
   \        0xC   0x0025             MOVS     R5,R4
    290            
    291            while (len--)
   \                     ??uart_hal_write_0: (+1)
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x1E46             SUBS     R6,R0,#+1
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD00C             BEQ.N    ??uart_hal_write_1
    292            {
    293              USART_Tx(uart0, _buffer[sent++]);
   \       0x18   0x....             LDR.N    R7,??DataTable12_12
   \       0x1A   0xF815 0x1008      LDRB     R1,[R5, R8]
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x.... 0x....      BL       USART_Tx
   \       0x24   0xF118 0x0801      ADDS     R8,R8,#+1
    294              while (!(uart0->STATUS & USART_STATUS_TXC));
   \                     ??uart_hal_write_2: (+1)
   \       0x28   0x6838             LDR      R0,[R7, #+0]
   \       0x2A   0x6980             LDR      R0,[R0, #+24]
   \       0x2C   0x0680             LSLS     R0,R0,#+26
   \       0x2E   0xD4EE             BMI.N    ??uart_hal_write_0
   \       0x30   0xE7FA             B.N      ??uart_hal_write_2
    295            }
    296            
    297          //	if( len > UART_TX_BUF_LEN )
    298          //	{
    299          //		//let this get freed up as it is of more than the allowed UART packet size
    300          //		return -2;//
    301          //	}
    302          //
    303          //	/* Submit Outbound buffer to UART */
    304          //	if( uart0_trigger_tx )
    305          //	{
    306          //          uart0_trigger_tx = 0;
    307          //
    308          //          gp_uart0_tx_address = p_data;
    309          //          g_uart0_tx_count = len;
    310          //
    311          //          /* Enable interrupt on USART TX Buffer*/
    312          //          USART_IntEnable(uart0, USART_IF_TXBL);            //This is for FG13
    313          //          //EUSART_IntEnable(EUSART1, EUSART_IEN_TXFL);           //This is for FG23
    314          //	}
    315          //	else
    316          //	{
    317          //		//uart is busy doing transmission of a packet initiated earlier. 
    318          //		//So let this buffer be put in a queue to be processed ata a 
    319          //		//later stage
    320          //		return -1;
    321          //		//queue_item_put( &uart_tx_buf_q,  (queue_item_t*) p_uart_tx_buff );
    322          //	}
    323          //
    324          //    return 0;
    325          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "uart_hal_write"

  static uint8_t uart1_rx_byte;
                 ^
"D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\uart_hal.c",138  Warning[Pe177]: 
          variable "uart1_rx_byte" was declared but never referenced
   \                     ??uart_hal_write_1: (+1)
   \       0x32   0xE8BD 0x81F0      POP      {R4-R8,PC}
    326          
    327          /******************************************************************************/
    328          

   \                                 In section .text, align 2, keep-with-next
    329          int8_t uart_hal_register_back(uart_hal_call_back cb, void* param)
    330          {
   \                     uart_hal_register_back: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    331          	uart_hal_info.cb = cb;
   \        0x2   0x....             LDR.N    R0,??DataTable12_17
   \        0x4   0x6002             STR      R2,[R0, #+0]
    332          	uart_hal_info.param = param;
   \        0x6   0x6041             STR      R1,[R0, #+4]
    333          	return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
    334          }
    335          
    336          /*
    337          ** ============================================================================
    338          ** Private Function Definitions
    339          ** ============================================================================
    340          */
    341          

   \                                 In section .text, align 2, keep-with-next
    342          void UARTCallback( uint8_t eventid )
    343          {
   \                     UARTCallback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    344              switch (eventid) 
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??UARTCallback_0
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD012             BEQ.N    ??UARTCallback_1
   \       0x10   0xD30A             BCC.N    ??UARTCallback_2
   \       0x12   0xE011             B.N      ??UARTCallback_3
    345              {
    346                  case 0://tx complete
    347          			
    348          			/*put back the buffer in the free pool*/
    349          			uart0_trigger_tx = 1;
   \                     ??UARTCallback_0: (+1)
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x....             LDR.N    R0,??DataTable12_18
   \       0x18   0x7001             STRB     R1,[R0, #+0]
    350          
    351          			/*invoke callback informing packet tx completion*/
    352          			uart_hal_info.cb( NULL,TX_COMPLETE_EVENT,uart_hal_info.param );
   \       0x1A   0x....             LDR.N    R3,??DataTable12_17
   \       0x1C   0x685A             LDR      R2,[R3, #+4]
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x681B             LDR      R3,[R3, #+0]
   \       0x24   0x4798             BLX      R3
    353          			break;
   \       0x26   0xE007             B.N      ??UARTCallback_4
    354          		case 1://rx complete
    355          			/*invoke callback informing packet rx completion*/
    356          			uart_hal_info.cb( NULL,RX_COMPLETE_EVENT,uart_hal_info.param );
   \                     ??UARTCallback_2: (+1)
   \       0x28   0x....             LDR.N    R3,??DataTable12_17
   \       0x2A   0x685A             LDR      R2,[R3, #+4]
   \       0x2C   0x2103             MOVS     R1,#+3
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x681B             LDR      R3,[R3, #+0]
   \       0x32   0x4798             BLX      R3
    357                      break;
   \       0x34   0xE000             B.N      ??UARTCallback_4
    358          		case 2://error
    359          			break;
   \                     ??UARTCallback_1: (+1)
   \       0x36   0xE7FF             B.N      ??UARTCallback_4
    360          
    361          		default:
    362          			break;                    
    363              }
    364          }
   \                     ??UARTCallback_3: (+1)
   \                     ??UARTCallback_4: (+1)
   \       0x38   0xBD10             POP      {R4,PC}
    365          
    366          
    367          
    368          /**************************************************************************//**
    369           * @brief UART1 RX IRQ Handler
    370           *
    371           * Set up the interrupt prior to use
    372           *
    373           * Note that this function handles overflows in a very simple way.
    374           *
    375           *****************************************************************************/
    376          //uint8_t uart_debug_buff [2000] = {0};
    377          //uint16_t uart_debug_buff_Cnt = 0;
    378          

   \                                 In section .text, align 2, keep-with-next
    379          void USART0_RX_IRQHandler(void)
    380          {
   \                     USART0_RX_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    381            uint8_t rxData;
    382            /* Check for RX data valid interrupt */
    383            if (uart0->STATUS & USART_STATUS_RXDATAV) {
   \        0x2   0x....             LDR.N    R5,??DataTable12_12
   \        0x4   0x6828             LDR      R0,[R5, #+0]
   \        0x6   0x6980             LDR      R0,[R0, #+24]
   \        0x8   0x0600             LSLS     R0,R0,#+24
   \        0xA   0xD51D             BPL.N    ??USART0_RX_IRQHandler_0
    384              rxData = USART_Rx(uart0);
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x.... 0x....      BL       USART_Rx
   \       0x12   0x0004             MOVS     R4,R0
    385              USART_IntClear(uart0, USART_IF_RXDATAV);
   \       0x14   0x2104             MOVS     R1,#+4
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x.... 0x....      BL       USART_IntClear
    386          
    387              // Store the received byte in the ring buffer
    388              r_buff.buffer[r_buff.head] = rxData;
   \       0x1C   0x....             LDR.N    R0,??DataTable12_10
   \       0x1E   0xF8B0 0x1400      LDRH     R1,[R0, #+1024]
   \       0x22   0x5444             STRB     R4,[R0, R1]
    389              r_buff.head = (r_buff.head + 1) % RING_BUFFER_SIZE;
   \       0x24   0xF8B0 0x3400      LDRH     R3,[R0, #+1024]
   \       0x28   0x1C5B             ADDS     R3,R3,#+1
   \       0x2A   0xF44F 0x6180      MOV      R1,#+1024
   \       0x2E   0xFB93 0xF2F1      SDIV     R2,R3,R1
   \       0x32   0xFB01 0x3312      MLS      R3,R1,R2,R3
   \       0x36   0xF8A0 0x3400      STRH     R3,[R0, #+1024]
    390          
    391              // Restart the RAIL timer
    392              RAIL_SetTimer(railHandle, UART_TIMEOUT_US, RAIL_TIME_DELAY, uart_timeout_callback);
   \       0x3A   0x....             LDR.N    R3,??DataTable12_19
   \       0x3C   0x2201             MOVS     R2,#+1
   \       0x3E   0x....             LDR.N    R1,??DataTable12_20
   \       0x40   0x....             LDR.N    R0,??DataTable12_11
   \       0x42   0x6800             LDR      R0,[R0, #+0]
   \       0x44   0x.... 0x....      BL       RAIL_SetTimer
    393          }
    394          }
   \                     ??USART0_RX_IRQHandler_0: (+1)
   \       0x48   0xBD31             POP      {R0,R4,R5,PC}
    395          
    396          /**************************************************************************//**
    397           * @brief UART1 TX IRQ Handler
    398           *
    399           * Set up the interrupt prior to use
    400           *
    401           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    402          void USART0_TX_IRQHandler(void)
    403          {
   \                     USART0_TX_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    404            /* Check TX buffer level status */
    405            if (uart0->STATUS & USART_STATUS_TXBL)
   \        0x2   0x....             LDR.N    R4,??DataTable12_12
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6980             LDR      R0,[R0, #+24]
   \        0x8   0x0640             LSLS     R0,R0,#+25
   \        0xA   0xD51A             BPL.N    ??USART0_TX_IRQHandler_0
    406            {
    407              if (g_uart0_tx_count > 0)
   \        0xC   0x....             LDR.N    R5,??DataTable12_21
   \        0xE   0x8828             LDRH     R0,[R5, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD00C             BEQ.N    ??USART0_TX_IRQHandler_1
    408              {
    409                /* Transmit pending character */
    410                USART_Tx(uart0, *gp_uart0_tx_address++);      
   \       0x14   0x....             LDR.N    R0,??DataTable12_22
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x7809             LDRB     R1,[R1, #+0]
   \       0x1A   0x6802             LDR      R2,[R0, #+0]
   \       0x1C   0x1C52             ADDS     R2,R2,#+1
   \       0x1E   0x6002             STR      R2,[R0, #+0]
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x.... 0x....      BL       USART_Tx
    411                g_uart0_tx_count--;
   \       0x28   0x8828             LDRH     R0,[R5, #+0]
   \       0x2A   0x1E40             SUBS     R0,R0,#+1
   \       0x2C   0x8028             STRH     R0,[R5, #+0]
    412              }
    413          
    414              /* Disable Tx interrupt if no more bytes to be sent */
    415              if (g_uart0_tx_count == 0)
   \                     ??USART0_TX_IRQHandler_1: (+1)
   \       0x2E   0x8828             LDRH     R0,[R5, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD106             BNE.N    ??USART0_TX_IRQHandler_0
    416              {
    417                USART_IntDisable(uart0, USART_IF_TXBL);
   \       0x34   0x2102             MOVS     R1,#+2
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x.... 0x....      BL       USART_IntDisable
    418                //send end
    419                UARTCallback(0);
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x.... 0x....      BL       UARTCallback
    420              }
    421            }
    422          }
   \                     ??USART0_TX_IRQHandler_0: (+1)
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     uart_timeout_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x0003'0001        DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x5003'C7B0        DC32     0x5003c7b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x0002'0001        DC32     0x20001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x5003'C7A8        DC32     0x5003c7a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x5003'C798        DC32     0x5003c798

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x5005'C000        DC32     0x5005c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \        0x0   0x....'....        DC32     r_buff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \        0x0   0x....'....        DC32     railHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \        0x0   0x....'....        DC32     uart0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \        0x0   0x....'....        DC32     uart0_rx_buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \        0x0   0x....'....        DC32     g_uart0_rx_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \        0x0   0x....'....        DC32     g_uart0_rx_length

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \        0x0   0x....'....        DC32     gp_uart0_rx_address

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \        0x0   0x....'....        DC32     uart_hal_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \        0x0   0x....'....        DC32     uart0_trigger_tx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \        0x0   0x....'....        DC32     uart_timeout_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \        0x0   0x0001'86A0        DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_21:
   \        0x0   0x....'....        DC32     g_uart0_tx_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_22:
   \        0x0   0x....'....        DC32     gp_uart0_tx_address

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x05               DC8 5
   \        0x1                      DS8 3
   \        0x4   0x0000'0000        DC32 0, 115'200
   \              0x0001'C200
   \        0xC   0x00 0x05          DC8 0, 5
   \        0xE   0x0000 0x1000      DC16 0, 4'096
   \       0x12   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00
   \       0x1A                      DS8 2
    423          
    424          
    425          
    426          #if 0
    427          /**************************************************************************//**
    428          * @brief
    429          *    USART0 initialization (VCOM on xG1/xG12/xG13 boards)
    430          *****************************************************************************/
    431          void init_Usart1(void)
    432          {
    433            
    434            
    435            //CMU_ClockEnable(cmuClock_GPIO, true);
    436            
    437            
    438            /* Configure GPIO pins for Debug UART :: LOC */ 
    439            
    440            GPIO_PinModeSet(APP_USART1_TX_PORT, APP_USART1_TX_PIN, gpioModeInput, 0); //tx
    441            GPIO_PinModeSet(APP_USART1_RX_PORT, APP_USART1_RX_PIN, gpioModePushPull, 1); //rx
    442            
    443            CMU_ClockEnable(cmuClock_USART1, true);
    444            
    445            // Default asynchronous initializer (115.2 Kbps, 8N1, no flow control)
    446            USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;
    447               
    448            // The Baud rate for the Communication.
    449            init.baudrate = APP_USART1_BAUDRATE ;
    450            
    451            // Configure and enable USART0
    452            USART_InitAsync(USART1, &init);
    453            
    454            
    455            USART_IntClear(USART1, _USART_IF_MASK);
    456            USART_IntEnable(USART1, USART_IEN_RXDATAV);
    457            
    458            // Enable NVIC USART sources
    459            NVIC_ClearPendingIRQ(USART1_RX_IRQn);
    460            NVIC_EnableIRQ(USART1_RX_IRQn);
    461            NVIC_ClearPendingIRQ(USART1_TX_IRQn);
    462            NVIC_EnableIRQ(USART1_TX_IRQn);
    463            
    464            /* Enable I/O pins at UART0 location #22 */
    465            USART1->ROUTELOC0 = USART_ROUTELOC0_RXLOC_LOC25  | USART_ROUTELOC0_TXLOC_LOC27;
    466            USART1->ROUTEPEN |= USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;
    467            
    468          }
    469          /******************************************************************************/
    470          
    471          void UART1_close(void)
    472          {
    473            USART_Reset(USART1);
    474          }
    475          
    476          
    477          
    478          /******************************************************************************/
    479          
    480          int8_t raw_uart_hal_read(uint8_t* p_data, uint16_t len )
    481          {
    482            uart1_rx_buffer.p_data = p_data;
    483            uart1_rx_buffer.element_count = ( uint16_t )len;
    484            
    485            g_uart1_rx_count = 0U;
    486            g_uart1_rx_length = ( uint16_t )len;
    487            gp_uart1_rx_address = p_data;
    488            
    489            return 0;
    490          }
    491          
    492          /******************************************************************************/
    493          
    494          int8_t raw_uart_hal_write(uint8_t* p_data, uint16_t len )
    495          {
    496           
    497            /* Submit Outbound buffer to UART */
    498            if( uart1_trigger_tx )
    499            {
    500              uart1_trigger_tx = 0;
    501              
    502              gp_uart1_tx_address = p_data;
    503              g_uart1_tx_count = len;
    504              
    505              /* Enable interrupt on USART TX Buffer*/
    506              USART_IntEnable(USART1, USART_IF_TXBL);
    507            }
    508            else
    509            {
    510              //uart is busy doing transmission of a packet initiated earlier. 
    511              //So let this buffer be put in a queue to be processed ata a 
    512              //later stage
    513              return -1;
    514              
    515            }
    516            
    517            return 0;
    518          }
    519          
    520          
    521          
    522          /*
    523          ** ============================================================================
    524          ** Private Function Definitions
    525          ** ============================================================================
    526          */
    527          
    528          void UART1_Callback( uint8_t eventid )
    529          {
    530            int8_t ch;
    531            switch (eventid) 
    532            {
    533            case 0://tx complete
    534              
    535              /*put back the buffer in the free pool*/
    536              
    537              uart1_trigger_tx = 1;
    538              
    539              /*invoke callback informing packet tx completion*/
    540              uart_call_back(NULL,0,0,0);
    541              break;
    542            case 1://rx complete
    543              ch = uart1_rx_byte;
    544              
    545              raw_uart_hal_read(&uart1_rx_byte ,1 );
    546              /*invoke callback informing packet rx completion*/
    547              uart_call_back(NULL,0,1,ch);
    548              break;
    549            case 2:
    550              uart_call_back(NULL,0,2,0);
    551              break;
    552              
    553            default:
    554              break;                    
    555            }
    556            
    557          }
    558          
    559          /*
    560          ** ============================================================================
    561          ** Private Function Definitions
    562          ** ============================================================================
    563          */
    564          
    565          
    566          /**************************************************************************//**
    567          * @brief UART1 RX IRQ Handler
    568          *
    569          * Set up the interrupt prior to use
    570          *
    571          * Note that this function handles overflows in a very simple way.
    572          *
    573          *****************************************************************************/
    574          void USART1_RX_IRQHandler(void)
    575          {
    576            uint8_t rxData;
    577            /* Check for RX data valid interrupt */
    578            if (USART1->STATUS & USART_STATUS_RXDATAV)
    579            {
    580              /* Copy data into RX Buffer */
    581              rxData = USART_Rx(USART1);
    582              /* Clear RXDATAV interrupt */
    583              USART_IntClear(USART1, USART_IF_RXDATAV);
    584              if (g_uart1_rx_length > g_uart1_rx_count)
    585              {
    586                *gp_uart1_rx_address = rxData;
    587                
    588                g_uart1_rx_count++;
    589                
    590                if (g_uart1_rx_length == g_uart1_rx_count)
    591                {
    592                  UART1_Callback(1);
    593                }
    594                else
    595                {
    596                  gp_uart1_rx_address++;
    597                }
    598              }
    599            }
    600            else
    601            {
    602              USART_IntClear(USART1, USART_STATUS_RXFULL);
    603            }
    604          }
    605          
    606          /**************************************************************************//**
    607          * @brief UART1 TX IRQ Handler
    608          *
    609          * Set up the interrupt prior to use
    610          *
    611          *****************************************************************************/
    612          void USART1_TX_IRQHandler(void)
    613          {
    614            /* Check TX buffer level status */
    615            if (USART1->STATUS & USART_STATUS_TXBL)
    616            {
    617              if (g_uart1_tx_count > 0)
    618              {
    619                /* Transmit pending character */
    620                USART_Tx(USART1, *gp_uart1_tx_address++);      
    621                g_uart1_tx_count--;
    622              }
    623              
    624              /* Disable Tx interrupt if no more bytes to be sent */
    625              if (g_uart1_tx_count == 0)
    626              {
    627                USART_IntDisable(USART1, USART_IF_TXBL);
    628                //send end
    629                UART1_Callback(0);
    630              }
    631            }
    632          }
    633          
    634          /**************************************************************************//**
    635          * @brief UART1 TX IRQ Handler
    636          *
    637          * Set up the interrupt prior to use
    638          *
    639          *****************************************************************************/
    640          
    641          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UARTCallback
         8   -- Indirect call
       8   UART_close
         8   -> USART_Reset
      40   UART_init
        40   -> CMU_ClockEnable
        40   -> GPIO_PinModeSet
        40   -> USART_InitAsync
        40   -> USART_IntEnable
        40   -> __NVIC_ClearPendingIRQ
        40   -> __NVIC_EnableIRQ
        40   -> __aeabi_memcpy4
       0   UART_init_rail_timer
      16   USART0_RX_IRQHandler
        16   -> RAIL_SetTimer
        16   -> USART_IntClear
        16   -> USART_Rx
      16   USART0_TX_IRQHandler
        16   -> UARTCallback
        16   -> USART_IntDisable
        16   -> USART_Tx
       0   USART_IntClear
       0   USART_IntDisable
       0   USART_IntEnable
       0   __NVIC_ClearPendingIRQ
       0   __NVIC_EnableIRQ
       0   register_uart_timeout_cb
       0   uart_hal_read
       0   uart_hal_register_back
      24   uart_hal_write
        24   -> USART_Tx
       8   uart_timeout_callback
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      28  ?_0
      58  UARTCallback
      12  UART_close
     138  UART_init
       6  UART_init_rail_timer
      74  USART0_RX_IRQHandler
      68  USART0_TX_IRQHandler
       8  USART_IntClear
       8  USART_IntDisable
       8  USART_IntEnable
      30  __NVIC_ClearPendingIRQ
      30  __NVIC_EnableIRQ
       1  dataready
       2  g_uart0_rx_count
       2  g_uart0_rx_length
       2  g_uart0_tx_count
       2  g_uart1_rx_count
       2  g_uart1_rx_length
       2  g_uart1_tx_count
       4  gp_uart0_rx_address
       4  gp_uart0_tx_address
       4  gp_uart1_rx_address
       4  gp_uart1_tx_address
   1'028  r_buff
       4  railHandle
       6  register_uart_timeout_cb
       4  uart0
      12  uart0_rx_buffer
       1  uart0_trigger_tx
      12  uart1_rx_buffer
       1  uart1_trigger_tx
       8  uart_hal_info
      26  uart_hal_read
      12  uart_hal_register_back
      54  uart_hal_write
       1  uart_timeout
      18  uart_timeout_callback
       4  uart_timeout_cb

 
 1'098 bytes in section .bss
     6 bytes in section .data
    28 bytes in section .rodata
   648 bytes in section .text
 
   648 bytes of CODE  memory
    28 bytes of CONST memory
 1'104 bytes of DATA  memory

Errors: none
Warnings: 2
