###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:31
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_key_management.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_driver_key_management.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_key_management.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_driver_key_management.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir\sli_se_driver_key_management.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_driver_key_management.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_key_management.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Driver Key Management functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "psa/crypto.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t psa_get_key_lifetime(psa_key_attributes_t const *)
   \                     psa_get_key_lifetime: (+1)
   \        0x0   0x6840             LDR      R0,[R0, #+4]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t psa_get_key_usage_flags(psa_key_attributes_t const *)
   \                     psa_get_key_usage_flags: (+1)
   \        0x0   0x68C0             LDR      R0,[R0, #+12]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t psa_get_key_type(psa_key_attributes_t const *)
   \                     psa_get_key_type: (+1)
   \        0x0   0x8800             LDRH     R0,[R0, #+0]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t psa_get_key_bits(psa_key_attributes_t const *)
   \                     psa_get_key_bits: (+1)
   \        0x0   0x8840             LDRH     R0,[R0, #+2]
   \        0x2   0x4770             BX       LR
     36          
     37          #include "sli_se_opaque_types.h"
     38          #include "sli_se_opaque_functions.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void sli_se_key_descriptor_set_plaintext(struct <unnamed>#128 *, uint8_t const *, size_t)
   \                     sli_se_key_descriptor_set_plaintext: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x60C3             STR      R3,[R0, #+12]
   \        0x4   0x6101             STR      R1,[R0, #+16]
   \        0x6   0x1CD3             ADDS     R3,R2,#+3
   \        0x8   0x089B             LSRS     R3,R3,#+2
   \        0xA   0x009B             LSLS     R3,R3,#+2
   \        0xC   0x6143             STR      R3,[R0, #+20]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t sli_se_has_format_byte(uint16_t)
   \                     sli_se_has_format_byte: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \        0xA   0xF5B0 0x4F82      CMP      R0,#+16640
   \        0xE   0xD11B             BNE.N    ??sli_se_has_format_byte_0
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x14   0x000A             MOVS     R2,R1
   \       0x16   0xB292             UXTH     R2,R2
   \       0x18   0x4002             ANDS     R2,R0,R2
   \       0x1A   0xF5B2 0x4F82      CMP      R2,#+16640
   \       0x1E   0xD101             BNE.N    ??sli_se_has_format_byte_1
   \       0x20   0x000A             MOVS     R2,R1
   \       0x22   0xE000             B.N      ??sli_se_has_format_byte_2
   \                     ??sli_se_has_format_byte_1: (+1)
   \       0x24   0x2200             MOVS     R2,#+0
   \                     ??sli_se_has_format_byte_2: (+1)
   \       0x26   0xB2D2             UXTB     R2,R2
   \       0x28   0x2A41             CMP      R2,#+65
   \       0x2A   0xD00D             BEQ.N    ??sli_se_has_format_byte_0
   \       0x2C   0x000A             MOVS     R2,R1
   \       0x2E   0xB292             UXTH     R2,R2
   \       0x30   0x4010             ANDS     R0,R0,R2
   \       0x32   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0x36   0xD101             BNE.N    ??sli_se_has_format_byte_3
   \       0x38   0x0008             MOVS     R0,R1
   \       0x3A   0xE000             B.N      ??sli_se_has_format_byte_4
   \                     ??sli_se_has_format_byte_3: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??sli_se_has_format_byte_4: (+1)
   \       0x3E   0xB2C0             UXTB     R0,R0
   \       0x40   0x2842             CMP      R0,#+66
   \       0x42   0xD001             BEQ.N    ??sli_se_has_format_byte_0
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE000             B.N      ??sli_se_has_format_byte_5
   \                     ??sli_se_has_format_byte_0: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??sli_se_has_format_byte_5: (+1)
   \       0x4A   0x4770             BX       LR
     39          #include "sli_se_driver_key_management.h"
     40          #include "sli_psa_driver_common.h"  // sli_psa_zeroize()

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t sli_psa_validate_ecc_weierstrass_privkey(void const *, void const *, size_t)
   \                     sli_psa_validate_ecc_weierstrass_privkey: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000B             MOVS     R3,R1
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x2600             MOVS     R6,#+0
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x2700             MOVS     R7,#+0
   \                     ??sli_psa_validate_ecc_weierstrass_privkey_0: (+1)
   \        0xE   0x4297             CMP      R7,R2
   \       0x10   0xD218             BCS.N    ??sli_psa_validate_ecc_weierstrass_privkey_1
   \       0x12   0x1E50             SUBS     R0,R2,#+1
   \       0x14   0x1BC0             SUBS     R0,R0,R7
   \       0x16   0x5C20             LDRB     R0,[R4, R0]
   \       0x18   0x4305             ORRS     R5,R0,R5
   \       0x1A   0x1E50             SUBS     R0,R2,#+1
   \       0x1C   0x1BC0             SUBS     R0,R0,R7
   \       0x1E   0xF814 0xC000      LDRB     R12,[R4, R0]
   \       0x22   0x1E50             SUBS     R0,R2,#+1
   \       0x24   0x1BC0             SUBS     R0,R0,R7
   \       0x26   0x5C18             LDRB     R0,[R3, R0]
   \       0x28   0xEBBC 0x0C00      SUBS     R12,R12,R0
   \       0x2C   0x4661             MOV      R1,R12
   \       0x2E   0x2900             CMP      R1,#+0
   \       0x30   0xD101             BNE.N    ??sli_psa_validate_ecc_weierstrass_privkey_2
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xE000             B.N      ??sli_psa_validate_ecc_weierstrass_privkey_3
   \                     ??sli_psa_validate_ecc_weierstrass_privkey_2: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??sli_psa_validate_ecc_weierstrass_privkey_3: (+1)
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0x4240             RSBS     R0,R0,#+0
   \       0x3C   0x4006             ANDS     R6,R0,R6
   \       0x3E   0x430E             ORRS     R6,R1,R6
   \       0x40   0x1C7F             ADDS     R7,R7,#+1
   \       0x42   0xE7E4             B.N      ??sli_psa_validate_ecc_weierstrass_privkey_0
   \                     ??sli_psa_validate_ecc_weierstrass_privkey_1: (+1)
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD001             BEQ.N    ??sli_psa_validate_ecc_weierstrass_privkey_4
   \       0x4C   0x2E00             CMP      R6,#+0
   \       0x4E   0xD402             BMI.N    ??sli_psa_validate_ecc_weierstrass_privkey_5
   \                     ??sli_psa_validate_ecc_weierstrass_privkey_4: (+1)
   \       0x50   0xF07F 0x0086      MVNS     R0,#+134
   \       0x54   0xE000             B.N      ??sli_psa_validate_ecc_weierstrass_privkey_6
   \                     ??sli_psa_validate_ecc_weierstrass_privkey_5: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??sli_psa_validate_ecc_weierstrass_privkey_6: (+1)
   \       0x58   0xBCF0             POP      {R4-R7}
   \       0x5A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t sli_psa_zeroize(void *, size_t)
   \                     sli_psa_zeroize: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD101             BNE.N    ??sli_psa_zeroize_0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE009             B.N      ??sli_psa_zeroize_1
   \                     ??sli_psa_zeroize_0: (+1)
   \        0xA   0x0013             MOVS     R3,R2
   \                     ??sli_psa_zeroize_2: (+1)
   \        0xC   0x0008             MOVS     R0,R1
   \        0xE   0x1E41             SUBS     R1,R0,#+1
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD003             BEQ.N    ??sli_psa_zeroize_3
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x7018             STRB     R0,[R3, #+0]
   \       0x18   0x1C5B             ADDS     R3,R3,#+1
   \       0x1A   0xE7F7             B.N      ??sli_psa_zeroize_2
   \                     ??sli_psa_zeroize_3: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??sli_psa_zeroize_1: (+1)
   \       0x1E   0x4770             BX       LR
     41          #include "sli_se_version_dependencies.h"
     42          
     43          #include "sl_se_manager_key_derivation.h"
     44          #include "sl_se_manager_internal_keys.h"
     45          #include "sl_se_manager_util.h"
     46          #include "sli_se_manager_internal.h"
     47          
     48          #include <string.h>
     49          
     50          // -----------------------------------------------------------------------------
     51          // Static constants
     52          
     53          #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
     54          static const uint8_t ecc_p192_n[] = {
     55            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x99, 0xde, 0xf8, 0x36, 0x14, 0x6b, 0xc9, 0xb1, 0xb4, 0xd2, 0x28, 0x31
     56          };
     57          #endif
     58          
     59          #if defined(SLI_PSA_DRIVER_FEATURE_P224R1)
     60          static const uint8_t ecc_p224_n[] = {
     61            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0xa2, 0xe0, 0xb8, 0xf0, 0x3e, 0x13, 0xdd, 0x29, 0x45, 0x5c, 0x5c, 0x2a, 0x3d
     62          };
     63          #endif
     64          
     65          #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)

   \                                 In section .rodata, align 4
     66          static const uint8_t ecc_p256_n[] = {
   \                     ecc_p256_n:
   \        0x0   0xFF 0xFF          DC8 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF
   \        0xF   0xFF 0xBC          DC8 255, 188, 230, 250, 173, 167, 23, 158, 132, 243, 185, 202, 194, 252
   \              0xE6 0xFA    
   \              0xAD 0xA7    
   \              0x17 0x9E    
   \              0x84 0xF3    
   \              0xB9 0xCA    
   \              0xC2 0xFC
   \       0x1D   0x63 0x25          DC8 99, 37, 81
   \              0x51
     67            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51
     68          };
     69          #endif
     70          
     71          #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
     72          static const uint8_t ecc_p384_n[] = {
     73            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf, 0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73
     74          };
     75          #endif
     76          
     77          #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
     78          static const uint8_t ecc_p521_n[] = {
     79            0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f, 0x96, 0x6b, 0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09, 0xa5, 0xd0, 0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c, 0x47, 0xae, 0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38, 0x64, 0x09
     80          };
     81          #endif
     82          
     83          // -----------------------------------------------------------------------------
     84          // Static functions
     85          
     86          /**
     87           * @brief
     88           *   Clamp if Montgomery or Twisted Edwards private key
     89           *
     90           * @param attributes
     91           *   The PSA attributes struct representing a key
     92           * @param key_data
     93           *   Key data
     94           * @param key_bits
     95           *   Key size in bits
     96           * @returns
     97           *   N/A
     98           */

   \                                 In section .text, align 2, keep-with-next
     99          static void clamp_private_key_if_needed(const psa_key_attributes_t* attributes,
    100                                                  uint8_t *key_data,
    101                                                  size_t key_bits)
    102          {
   \                     clamp_private_key_if_needed: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    103            psa_key_type_t key_type = psa_get_key_type(attributes);
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       psa_get_key_type
    104          
    105            // Apply clamping
    106            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(key_type)
    107                && ((PSA_KEY_TYPE_ECC_GET_FAMILY(key_type) == PSA_ECC_FAMILY_MONTGOMERY))) {
   \        0xE   0x0001             MOVS     R1,R0
   \       0x10   0xB289             UXTH     R1,R1
   \       0x12   0xF031 0x01FF      BICS     R1,R1,#0xFF
   \       0x16   0xF5B1 0x4FE2      CMP      R1,#+28928
   \       0x1A   0xD10C             BNE.N    ??clamp_private_key_if_needed_0
   \       0x1C   0x0002             MOVS     R2,R0
   \       0x1E   0xB292             UXTH     R2,R2
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable7
   \       0x24   0x400A             ANDS     R2,R1,R2
   \       0x26   0xF5B2 0x4F82      CMP      R2,#+16640
   \       0x2A   0xD101             BNE.N    ??clamp_private_key_if_needed_1
   \       0x2C   0x0001             MOVS     R1,R0
   \       0x2E   0xE000             B.N      ??clamp_private_key_if_needed_2
   \                     ??clamp_private_key_if_needed_1: (+1)
   \       0x30   0x2100             MOVS     R1,#+0
   \                     ??clamp_private_key_if_needed_2: (+1)
   \       0x32   0xB2C9             UXTB     R1,R1
   \       0x34   0x2941             CMP      R1,#+65
    108              switch (key_bits) {
    109                #if defined(SLI_PSA_DRIVER_FEATURE_CURVE25519)
    110                case 255:
    111                  key_data[0] &= 248U;
    112                  key_data[31] &= 127U;
    113                  key_data[31] |= 64U;
    114                  break;
    115                #endif // SLI_PSA_DRIVER_FEATURE_CURVE25519
    116          
    117                #if defined(SLI_PSA_DRIVER_FEATURE_CURVE448)
    118                case 448:
    119                  key_data[0] &= 252U;
    120                  key_data[55] |= 128U;
    121                  break;
    122                #endif // SLI_PSA_DRIVER_FEATURE_CURVE448
    123          
    124                default:
    125                  (void) attributes;
    126                  (void) key_data;
    127                  (void) key_bits;
    128                  break;
    129              }
    130            }
    131          }
   \                     ??clamp_private_key_if_needed_0: (+1)
   \       0x36   0xBD70             POP      {R4-R6,PC}
    132          
    133          /**
    134           * @brief
    135           *   Validate that the key descriptor mathces the PSA attributes struct.
    136           *
    137           * @param attributes
    138           *   The PSA attributes struct representing a key
    139           * @param key_size
    140           *   Size of the key
    141           * @param key_desc
    142           *   The SE manager key struct representing the same key
    143           * @returns
    144           *   PSA_SUCCESS if the structures match,
    145           *   PSA_ERROR_INVALID_ARGUMENT otherwise
    146           */

   \                                 In section .text, align 2, keep-with-next
    147          static psa_status_t validate_key_desc(const psa_key_attributes_t* attributes,
    148                                                size_t key_size,
    149                                                const sl_se_key_descriptor_t *key_desc)
    150          {
   \                     validate_key_desc: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    151            if (key_desc == NULL || attributes == NULL || key_size == 0) {
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD003             BEQ.N    ??validate_key_desc_0
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD001             BEQ.N    ??validate_key_desc_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD102             BNE.N    ??validate_key_desc_1
    152              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??validate_key_desc_0: (+1)
   \       0x16   0xF07F 0x0086      MVNS     R0,#+134
   \       0x1A   0xE026             B.N      ??validate_key_desc_2
    153            }
    154            // Build a new key descriptor from attributes and check that they match
    155            sl_se_key_descriptor_t new_key_desc = { 0 };
   \                     ??validate_key_desc_1: (+1)
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x2120             MOVS     R1,#+32
   \       0x20   0x.... 0x....      BL       __aeabi_memclr4
    156            psa_status_t status =
    157              sli_se_key_desc_from_psa_attributes(attributes, key_size, &new_key_desc);
   \       0x24   0x466A             MOV      R2,SP
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       sli_se_key_desc_from_psa_attributes
   \       0x2E   0x0001             MOVS     R1,R0
    158            if (status != PSA_SUCCESS) {
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD002             BEQ.N    ??validate_key_desc_3
    159              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x34   0xF07F 0x0086      MVNS     R0,#+134
   \       0x38   0xE017             B.N      ??validate_key_desc_2
    160            }
    161            if (new_key_desc.type != key_desc->type
    162                || new_key_desc.size != key_desc->size
    163                || new_key_desc.flags != key_desc->flags
    164                || new_key_desc.password != key_desc->password
    165                || new_key_desc.domain != key_desc->domain) {
   \                     ??validate_key_desc_3: (+1)
   \       0x3A   0x9A00             LDR      R2,[SP, #+0]
   \       0x3C   0x6830             LDR      R0,[R6, #+0]
   \       0x3E   0x4282             CMP      R2,R0
   \       0x40   0xD10F             BNE.N    ??validate_key_desc_4
   \       0x42   0x9A01             LDR      R2,[SP, #+4]
   \       0x44   0x6870             LDR      R0,[R6, #+4]
   \       0x46   0x4282             CMP      R2,R0
   \       0x48   0xD10B             BNE.N    ??validate_key_desc_4
   \       0x4A   0x9A02             LDR      R2,[SP, #+8]
   \       0x4C   0x68B0             LDR      R0,[R6, #+8]
   \       0x4E   0x4282             CMP      R2,R0
   \       0x50   0xD107             BNE.N    ??validate_key_desc_4
   \       0x52   0x9A06             LDR      R2,[SP, #+24]
   \       0x54   0x69B0             LDR      R0,[R6, #+24]
   \       0x56   0x4282             CMP      R2,R0
   \       0x58   0xD103             BNE.N    ??validate_key_desc_4
   \       0x5A   0x9A07             LDR      R2,[SP, #+28]
   \       0x5C   0x69F0             LDR      R0,[R6, #+28]
   \       0x5E   0x4282             CMP      R2,R0
   \       0x60   0xD002             BEQ.N    ??validate_key_desc_5
    166              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??validate_key_desc_4: (+1)
   \       0x62   0xF07F 0x0086      MVNS     R0,#+134
   \       0x66   0xE000             B.N      ??validate_key_desc_2
    167            }
    168            return PSA_SUCCESS;
   \                     ??validate_key_desc_5: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??validate_key_desc_2: (+1)
   \       0x6A   0xB008             ADD      SP,SP,#+32
   \       0x6C   0xBD70             POP      {R4-R6,PC}
    169          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    170          
    171          /**
    172           * @brief
    173           *   Set the number of bytes of key buffer used for storing the key.
    174           *
    175           * @param attributes[in]
    176           *   The PSA attributes struct representing a key
    177           * @param data_size[in]
    178           *   Size of the data that has been stored (excluding the 0x04 byte for public
    179           *   keys)
    180           * @param key_buffer_length[out]
    181           *   Actually used key buffer space
    182           * @returns
    183           *   PSA_SUCCESS if key_buffer_length can be set properly,
    184           *   PSA_ERROR_NOT_SUPPORTED if unsupported location is encountered.
    185           */

   \                                 In section .text, align 2, keep-with-next
    186          static psa_status_t set_key_buffer_length(
    187            const psa_key_attributes_t *attributes,
    188            size_t data_size,
    189            size_t *key_buffer_length)
    190          {
   \                     set_key_buffer_length: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0015             MOVS     R5,R2
    191            psa_key_location_t location =
    192              PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       psa_get_key_lifetime
   \        0xE   0x0006             MOVS     R6,R0
   \       0x10   0x0A36             LSRS     R6,R6,#+8
    193            *key_buffer_length = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6028             STR      R0,[R5, #+0]
    194            switch (location) {
   \       0x16   0x2E00             CMP      R6,#+0
   \       0x18   0xD002             BEQ.N    ??set_key_buffer_length_0
   \       0x1A   0x2E01             CMP      R6,#+1
   \       0x1C   0xD00B             BEQ.N    ??set_key_buffer_length_1
   \       0x1E   0xE00E             B.N      ??set_key_buffer_length_2
    195              case PSA_KEY_LOCATION_LOCAL_STORAGE:
    196                if (sli_se_has_format_byte(psa_get_key_type(attributes))) {
   \                     ??set_key_buffer_length_0: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       psa_get_key_type
   \       0x26   0xB280             UXTH     R0,R0
   \       0x28   0x.... 0x....      BL       sli_se_has_format_byte
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD000             BEQ.N    ??set_key_buffer_length_3
    197                  data_size++; // Add the format byte offset
   \       0x30   0x1C7F             ADDS     R7,R7,#+1
    198                }
    199                *key_buffer_length =  data_size;
   \                     ??set_key_buffer_length_3: (+1)
   \       0x32   0x602F             STR      R7,[R5, #+0]
    200                break;
   \       0x34   0xE006             B.N      ??set_key_buffer_length_4
    201          
    202                #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
    203              case PSA_KEY_LOCATION_SLI_SE_OPAQUE:
    204                #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    205                data_size = sli_se_word_align(data_size);
    206                #endif
    207                *key_buffer_length = sizeof(sli_se_opaque_wrapped_key_context_t)
    208                                     + data_size;
   \                     ??set_key_buffer_length_1: (+1)
   \       0x36   0xF117 0x002C      ADDS     R0,R7,#+44
   \       0x3A   0x6028             STR      R0,[R5, #+0]
    209                break;
   \       0x3C   0xE002             B.N      ??set_key_buffer_length_4
    210                #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    211          
    212              default:
    213                return PSA_ERROR_NOT_SUPPORTED;
   \                     ??set_key_buffer_length_2: (+1)
   \       0x3E   0xF07F 0x0085      MVNS     R0,#+133
   \       0x42   0xE000             B.N      ??set_key_buffer_length_5
    214                break;
    215            }
    216          
    217            return PSA_SUCCESS;
   \                     ??set_key_buffer_length_4: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??set_key_buffer_length_5: (+1)
   \       0x46   0xBDF2             POP      {R1,R4-R7,PC}
    218          }
    219          
    220          #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
    221          

   \                                 In section .text, align 2, keep-with-next
    222          static psa_status_t sli_se_driver_validate_ecc_key(
    223            const psa_key_attributes_t *attributes,
    224            const uint8_t *data,
    225            size_t data_length,
    226            size_t *bits)
    227          {
   \                     sli_se_driver_validate_ecc_key: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB0C4             SUB      SP,SP,#+272
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
    228            // Argument check.
    229            if (attributes == NULL
    230                || data == NULL
    231                || data_length == 0
    232                || bits == NULL) {
   \        0xE   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x12   0xD005             BEQ.N    ??sli_se_driver_validate_ecc_key_0
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD003             BEQ.N    ??sli_se_driver_validate_ecc_key_0
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD001             BEQ.N    ??sli_se_driver_validate_ecc_key_0
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD102             BNE.N    ??sli_se_driver_validate_ecc_key_1
    233              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_validate_ecc_key_0: (+1)
   \       0x20   0xF07F 0x0086      MVNS     R0,#+134
   \       0x24   0xE0BD             B.N      ??sli_se_driver_validate_ecc_key_2
    234            }
    235          
    236            psa_status_t return_status = PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??sli_se_driver_validate_ecc_key_1: (+1)
   \       0x26   0xF07F 0x0996      MVNS     R9,#+150
    237            psa_key_type_t key_type = psa_get_key_type(attributes);
   \       0x2A   0x4650             MOV      R0,R10
   \       0x2C   0x.... 0x....      BL       psa_get_key_type
   \       0x30   0x0007             MOVS     R7,R0
    238          
    239            psa_ecc_family_t curve_type = PSA_KEY_TYPE_ECC_GET_FAMILY(key_type);
   \       0x32   0x0039             MOVS     R1,R7
   \       0x34   0xB289             UXTH     R1,R1
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x3A   0x4001             ANDS     R1,R0,R1
   \       0x3C   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x40   0xD101             BNE.N    ??sli_se_driver_validate_ecc_key_3
   \       0x42   0x46B8             MOV      R8,R7
   \       0x44   0xE001             B.N      ??sli_se_driver_validate_ecc_key_4
   \                     ??sli_se_driver_validate_ecc_key_3: (+1)
   \       0x46   0xF05F 0x0800      MOVS     R8,#+0
    240          
    241            switch (curve_type) {
   \                     ??sli_se_driver_validate_ecc_key_4: (+1)
   \       0x4A   0x4640             MOV      R0,R8
   \       0x4C   0xB2C0             UXTB     R0,R0
   \       0x4E   0x2812             CMP      R0,#+18
   \       0x50   0xF040 0x80A5      BNE.W    ??sli_se_driver_validate_ecc_key_5
    242              #if defined(SLI_PSA_DRIVER_FEATURE_SECPR1)
    243              case PSA_ECC_FAMILY_SECP_R1: {
    244                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(key_type)) {   // Private key.
   \       0x54   0x0038             MOVS     R0,R7
   \       0x56   0xB280             UXTH     R0,R0
   \       0x58   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0x5C   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0x60   0xD123             BNE.N    ??sli_se_driver_validate_ecc_key_6
    245                  const void *modulus_ptr = NULL;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x9000             STR      R0,[SP, #+0]
    246                  *bits = psa_get_key_bits(attributes);
   \       0x66   0x4650             MOV      R0,R10
   \       0x68   0x.... 0x....      BL       psa_get_key_bits
   \       0x6C   0x6030             STR      R0,[R6, #+0]
    247          
    248                  // Determine key bit-size
    249                  if (*bits == 0) {
   \       0x6E   0x6830             LDR      R0,[R6, #+0]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD102             BNE.N    ??sli_se_driver_validate_ecc_key_7
    250                    *bits = data_length * 8;
   \       0x74   0x00E8             LSLS     R0,R5,#+3
   \       0x76   0x6030             STR      R0,[R6, #+0]
   \       0x78   0xE007             B.N      ??sli_se_driver_validate_ecc_key_8
    251                  } else {
    252                    if (PSA_BITS_TO_BYTES(*bits) != data_length) {
   \                     ??sli_se_driver_validate_ecc_key_7: (+1)
   \       0x7A   0x6830             LDR      R0,[R6, #+0]
   \       0x7C   0x1DC0             ADDS     R0,R0,#+7
   \       0x7E   0x08C0             LSRS     R0,R0,#+3
   \       0x80   0x42A8             CMP      R0,R5
   \       0x82   0xD002             BEQ.N    ??sli_se_driver_validate_ecc_key_8
    253                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x84   0xF07F 0x0086      MVNS     R0,#+134
   \       0x88   0xE08B             B.N      ??sli_se_driver_validate_ecc_key_2
    254                    }
    255                  }
    256          
    257                  switch (*bits) {
   \                     ??sli_se_driver_validate_ecc_key_8: (+1)
   \       0x8A   0x6830             LDR      R0,[R6, #+0]
   \       0x8C   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x90   0xD108             BNE.N    ??sli_se_driver_validate_ecc_key_9
    258                    #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
    259                    case 192:
    260                      modulus_ptr = ecc_p192_n;
    261                      break;
    262                    #endif   // SLI_PSA_DRIVER_FEATURE_P192R1
    263          
    264                    #if defined(SLI_PSA_DRIVER_FEATURE_P224R1)
    265                    // Series-2-config-1 devices do not support SECP224R1.
    266                    case 224:
    267                      modulus_ptr = ecc_p224_n;
    268                      break;
    269                    #endif   // SLI_PSA_DRIVER_FEATURE_P224R1
    270          
    271                    #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)
    272                    case 256:
    273                      modulus_ptr = ecc_p256_n;
   \       0x92   0x.... 0x....      LDR.W    R11,??DataTable7_1
    274                      break;
    275                    #endif   // SLI_PSA_DRIVER_FEATURE_P256R1
    276          
    277                    #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
    278                    case 384:
    279                      modulus_ptr = ecc_p384_n;
    280                      break;
    281                    #endif   // SLI_PSA_DRIVER_FEATURE_P384R1
    282          
    283                    #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
    284                    case 521:
    285                      modulus_ptr = ecc_p521_n;
    286                      break;
    287                    case 528:
    288                      // Maybe a 521 bit long key which has been padded to 66 bytes.
    289                      // Make sure the key size is not actually 528
    290                      if (psa_get_key_bits(attributes) == 528) {
    291                        return PSA_ERROR_NOT_SUPPORTED;
    292                      }
    293                      // Actually a 521 bit long key which has been padded to 66 bytes.
    294                      *bits = 521;
    295                      modulus_ptr = ecc_p521_n;
    296                      break;
    297                    #endif   // SLI_PSA_DRIVER_FEATURE_P521R1
    298          
    299                    default:
    300                      return PSA_ERROR_NOT_SUPPORTED;
    301                      break;
    302                  }
    303          
    304                  // Validate the private key.
    305                  return_status = sli_psa_validate_ecc_weierstrass_privkey(data,
    306                                                                           modulus_ptr,
    307                                                                           data_length);
   \       0x96   0x002A             MOVS     R2,R5
   \       0x98   0x4659             MOV      R1,R11
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0x.... 0x....      BL       sli_psa_validate_ecc_weierstrass_privkey
   \       0xA0   0x4681             MOV      R9,R0
   \       0xA2   0xE07A             B.N      ??sli_se_driver_validate_ecc_key_10
   \                     ??sli_se_driver_validate_ecc_key_9: (+1)
   \       0xA4   0xF07F 0x0085      MVNS     R0,#+133
   \       0xA8   0xE07B             B.N      ??sli_se_driver_validate_ecc_key_2
    308                } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {   // Public key.
   \                     ??sli_se_driver_validate_ecc_key_6: (+1)
   \       0xAA   0x0038             MOVS     R0,R7
   \       0xAC   0xB280             UXTH     R0,R0
   \       0xAE   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0xB2   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0xB6   0xD170             BNE.N    ??sli_se_driver_validate_ecc_key_10
    309                  // Check that uncompressed representation is given.
    310                  if (data[0] != 0x04) {
   \       0xB8   0x7820             LDRB     R0,[R4, #+0]
   \       0xBA   0x2804             CMP      R0,#+4
   \       0xBC   0xD002             BEQ.N    ??sli_se_driver_validate_ecc_key_11
    311                    return PSA_ERROR_INVALID_ARGUMENT;
   \       0xBE   0xF07F 0x0086      MVNS     R0,#+134
   \       0xC2   0xE06E             B.N      ??sli_se_driver_validate_ecc_key_2
    312                  }
    313          
    314                  // Create ephemeral SE command context.
    315                  sl_se_command_context_t cmd_ctx = SL_SE_COMMAND_CONTEXT_INIT;
   \                     ??sli_se_driver_validate_ecc_key_11: (+1)
   \       0xC4   0xA819             ADD      R0,SP,#+100
   \       0xC6   0x2124             MOVS     R1,#+36
   \       0xC8   0x.... 0x....      BL       __aeabi_memclr4
    316                  sl_status_t sl_status = sl_se_init_command_context(&cmd_ctx);
   \       0xCC   0xA819             ADD      R0,SP,#+100
   \       0xCE   0x.... 0x....      BL       sl_se_init_command_context
   \       0xD2   0x9000             STR      R0,[SP, #+0]
    317                  if (sl_status != SL_STATUS_OK) {
   \       0xD4   0x9800             LDR      R0,[SP, #+0]
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD002             BEQ.N    ??sli_se_driver_validate_ecc_key_12
    318                    return PSA_ERROR_HARDWARE_FAILURE;
   \       0xDA   0xF07F 0x0092      MVNS     R0,#+146
   \       0xDE   0xE060             B.N      ??sli_se_driver_validate_ecc_key_2
    319                  }
   \                     ??sli_se_driver_validate_ecc_key_12: (+1)
   \       0xE0   0x2188             MOVS     R1,#+136
   \       0xE2   0x2200             MOVS     R2,#+0
   \       0xE4   0xA822             ADD      R0,SP,#+136
   \       0xE6   0x.... 0x....      BL       __aeabi_memset
    320          
    321                  #if defined(SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN)
    322                  // SE version 1.2.2 is first version with public key validation
    323                  // inside of the SE.
    324                  uint32_t se_version = 0;
    325                  sl_status = sl_se_get_se_version(&cmd_ctx, &se_version);
    326                  if (sl_status != SL_STATUS_OK) {
    327                    return PSA_ERROR_HARDWARE_FAILURE;
    328                  }
    329          
    330                  if ((se_version & 0x00FFFFFFU) < SLI_SE_OLDEST_VERSION_WITH_PUBLIC_KEY_VALIDATION) {
    331                    #if defined(MBEDTLS_ECP_C)       \
    332                    && defined(MBEDTLS_PSA_CRYPTO_C) \
    333                    && SL_SE_SUPPORT_FW_PRIOR_TO_1_2_2
    334                    return_status = sli_se_driver_validate_pubkey_with_fallback(
    335                      key_type,
    336                      psa_get_key_bits(attributes),
    337                      data,
    338                      data_length);
    339                    #else
    340                    // No fallback code is compiled in, cannot do public key validation
    341                    return_status = PSA_ERROR_NOT_SUPPORTED;
    342                    #endif
    343                    break;
    344                  }
    345                  #endif   // SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN
    346          
    347                  // Temporary buffer for storing ECDH input private key,
    348                  // possibly padded input public key, and output shared key.
    349                  #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    350          
    351                  // If input public key requires padding, it will be stored
    352                  // starting from the third element. By doing this, and setting
    353                  // the first half-word equal to 1, we are guaranteed to not end up
    354                  // with a private key that is acidentally greater than the order
    355                  // n of the curve group (since the fields size q is greater than n).
    356                  uint8_t tmp_key_buffer[2 + SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
    357                  #else   // SLI_SE_KEY_PADDING_REQUIRED
    358                  uint8_t tmp_key_buffer[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
    359                  #endif   // SLI_SE_KEY_PADDING_REQUIRED
    360          
    361                  // Make sure that ECDH private key is non-zero.
    362                  tmp_key_buffer[0] = 1;
   \       0xEA   0x2001             MOVS     R0,#+1
   \       0xEC   0xF88D 0x0088      STRB     R0,[SP, #+136]
    363          
    364                  // Input public key descriptor.
    365                  sl_se_key_descriptor_t input_public_key_desc = {
    366                    .storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT,
    367                    .storage.location.buffer.pointer = (uint8_t*)data + 1,
    368                    .storage.location.buffer.size = data_length - 1,
    369                  };
   \       0xF0   0xA801             ADD      R0,SP,#+4
   \       0xF2   0x2120             MOVS     R1,#+32
   \       0xF4   0x.... 0x....      BL       __aeabi_memclr4
   \       0xF8   0x1C60             ADDS     R0,R4,#+1
   \       0xFA   0x9005             STR      R0,[SP, #+20]
   \       0xFC   0x1E68             SUBS     R0,R5,#+1
   \       0xFE   0x9006             STR      R0,[SP, #+24]
    370          
    371                  // Temporary private key descriptor.
    372                  sl_se_key_descriptor_t tmp_private_key_desc = {
    373                    .storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT,
    374                    .storage.location.buffer.pointer = tmp_key_buffer,
    375                    .storage.location.buffer.size = sizeof(tmp_key_buffer),
    376                  };
   \      0x100   0xA811             ADD      R0,SP,#+68
   \      0x102   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \      0x106   0x2220             MOVS     R2,#+32
   \      0x108   0x.... 0x....      BL       __aeabi_memcpy4
   \      0x10C   0xA822             ADD      R0,SP,#+136
   \      0x10E   0x9015             STR      R0,[SP, #+84]
    377          
    378                  // Temporary shared key descriptor.
    379                  sl_se_key_descriptor_t tmp_shared_key_desc = {
    380                    .type = SL_SE_KEY_TYPE_SYMMETRIC,
    381                    .storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT,
    382                    .storage.location.buffer.pointer = tmp_key_buffer,
    383                    .storage.location.buffer.size = sizeof(tmp_key_buffer),
    384                  };
   \      0x110   0xA809             ADD      R0,SP,#+36
   \      0x112   0x.... 0x....      LDR.W    R1,??DataTable8
   \      0x116   0x2220             MOVS     R2,#+32
   \      0x118   0x.... 0x....      BL       __aeabi_memcpy4
   \      0x11C   0xA822             ADD      R0,SP,#+136
   \      0x11E   0x900D             STR      R0,[SP, #+52]
    385          
    386                  // Determine key bit size (including padding).
    387                  *bits = (data_length - 1) * 8 / 2;
   \      0x120   0x1E68             SUBS     R0,R5,#+1
   \      0x122   0x00C0             LSLS     R0,R0,#+3
   \      0x124   0x0840             LSRS     R0,R0,#+1
   \      0x126   0x6030             STR      R0,[R6, #+0]
    388          
    389                  uint8_t padding_bytes = 0;
   \      0x128   0xF05F 0x0B00      MOVS     R11,#+0
    390                  switch (*bits) {
   \      0x12C   0x6830             LDR      R0,[R6, #+0]
   \      0x12E   0x28E0             CMP      R0,#+224
   \      0x130   0xD002             BEQ.N    ??sli_se_driver_validate_ecc_key_13
   \      0x132   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x136   0xD11E             BNE.N    ??sli_se_driver_validate_ecc_key_14
    391                    #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
    392                    case 192:
    393                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P192;
    394                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P192;
    395                      break;
    396                    #endif   // SLI_PSA_DRIVER_FEATURE_P192R1
    397          
    398                    case 224:
    399                      #if defined(SLI_MBEDTLS_DEVICE_HSE_V1)
    400                      // Series-2-config-1 devices do not support SECP224R1.
    401                      return PSA_ERROR_NOT_SUPPORTED;
    402                      break;
    403                      #elif defined(SLI_PSA_DRIVER_FEATURE_P224R1)
    404                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P224;
    405                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P224;
    406                      break;
    407                      #endif
    408          
    409                      #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)
    410                    case 256:
    411                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P256;
   \                     ??sli_se_driver_validate_ecc_key_13: (+1)
   \      0x138   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \      0x13C   0x9001             STR      R0,[SP, #+4]
    412                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P256;
   \      0x13E   0x9011             STR      R0,[SP, #+68]
    413                      break;
    414                      #endif // SLI_PSA_DRIVER_FEATURE_P256R1
    415          
    416                      #if defined(SLI_MBEDTLS_DEVICE_HSE_VAULT_HIGH)
    417          
    418                      #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
    419                    case 384:
    420                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P384;
    421                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P384;
    422                      break;
    423                      #endif // SLI_PSA_DRIVER_FEATURE_P384R1
    424          
    425                      #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
    426                    case 528:
    427                      // Actually a 521 bit long key which has been padded to 66 bytes.
    428                      *bits = 521;
    429                      padding_bytes = SLI_SE_P521_PADDING_BYTES;
    430                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P521;
    431                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P521;
    432                      break;
    433                      #endif // SLI_PSA_DRIVER_FEATURE_P521R1
    434          
    435                      #else // SLI_MBEDTLS_DEVICE_HSE_VAULT_HIGH
    436          
    437                    case 384:     // fall through
    438                    case 528:
    439                      return PSA_ERROR_NOT_SUPPORTED;
    440                      break;
    441          
    442                      #endif // SLI_MBEDTLS_DEVICE_HSE_VAULT_HIGH
    443          
    444                    default:
    445                      return PSA_ERROR_INVALID_ARGUMENT;
    446                      break;
    447                  }
    448          
    449                  // Set missing key descriptor attributes.
    450                  input_public_key_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \      0x140   0x9803             LDR      R0,[SP, #+12]
   \      0x142   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \      0x146   0x9003             STR      R0,[SP, #+12]
    451                  tmp_private_key_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
   \      0x148   0x9813             LDR      R0,[SP, #+76]
   \      0x14A   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \      0x14E   0x9013             STR      R0,[SP, #+76]
    452                  tmp_shared_key_desc.size = (PSA_BITS_TO_BYTES(*bits) + padding_bytes) * 2;
   \      0x150   0x6830             LDR      R0,[R6, #+0]
   \      0x152   0x1DC0             ADDS     R0,R0,#+7
   \      0x154   0x08C0             LSRS     R0,R0,#+3
   \      0x156   0xFA50 0xF08B      UXTAB    R0,R0,R11
   \      0x15A   0x0040             LSLS     R0,R0,#+1
   \      0x15C   0x900A             STR      R0,[SP, #+40]
    453          
    454                  #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    455                  // Should currently only happen for curve P521.
    456                  if (padding_bytes > 0) {
    457                    // Pad public key. Offset +2 in order to avoid problem with invalid private key.
    458                    sli_se_pad_curve_point(tmp_key_buffer + 2,
    459                                           (uint8_t*)data + 1,
    460                                           PSA_BITS_TO_BYTES(*bits));
    461                    sli_se_key_descriptor_set_plaintext(&input_public_key_desc,
    462                                                        tmp_key_buffer + 2,
    463                                                        sizeof(tmp_key_buffer) - 2);
    464                  }
    465                  #endif   // SLI_SE_KEY_PADDING_REQUIRED
    466          
    467                  // Perform key agreement algorithm (ECDH).
    468                  sl_status = sl_se_ecdh_compute_shared_secret(&cmd_ctx,
    469                                                               &tmp_private_key_desc,
    470                                                               &input_public_key_desc,
    471                                                               &tmp_shared_key_desc);
   \      0x15E   0xAB09             ADD      R3,SP,#+36
   \      0x160   0xAA01             ADD      R2,SP,#+4
   \      0x162   0xA911             ADD      R1,SP,#+68
   \      0x164   0xA819             ADD      R0,SP,#+100
   \      0x166   0x.... 0x....      BL       sl_se_ecdh_compute_shared_secret
   \      0x16A   0x9000             STR      R0,[SP, #+0]
    472          
    473                  // Zero out intermediate results.
    474                  if (padding_bytes == 0) {
   \      0x16C   0x4658             MOV      R0,R11
   \      0x16E   0xB2C0             UXTB     R0,R0
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xD10A             BNE.N    ??sli_se_driver_validate_ecc_key_15
   \      0x174   0xE002             B.N      ??sli_se_driver_validate_ecc_key_16
   \                     ??sli_se_driver_validate_ecc_key_14: (+1)
   \      0x176   0xF07F 0x0086      MVNS     R0,#+134
   \      0x17A   0xE012             B.N      ??sli_se_driver_validate_ecc_key_2
    475                    sli_psa_zeroize(tmp_key_buffer, (PSA_BITS_TO_BYTES(*bits)) * 2);
   \                     ??sli_se_driver_validate_ecc_key_16: (+1)
   \      0x17C   0x6830             LDR      R0,[R6, #+0]
   \      0x17E   0x1DC0             ADDS     R0,R0,#+7
   \      0x180   0x08C0             LSRS     R0,R0,#+3
   \      0x182   0x0041             LSLS     R1,R0,#+1
   \      0x184   0xA822             ADD      R0,SP,#+136
   \      0x186   0x.... 0x....      BL       sli_psa_zeroize
    476                  }
    477                  #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    478                  else {
    479                    sli_psa_zeroize(tmp_key_buffer,
    480                                    2 + (PSA_BITS_TO_BYTES(*bits) + padding_bytes) * 2);
    481                  }
    482                  #endif   // SLI_SE_KEY_PADDING_REQUIRED
    483          
    484                  if (sl_status != SL_STATUS_OK) {
   \                     ??sli_se_driver_validate_ecc_key_15: (+1)
   \      0x18A   0x9800             LDR      R0,[SP, #+0]
   \      0x18C   0x2800             CMP      R0,#+0
   \      0x18E   0xD002             BEQ.N    ??sli_se_driver_validate_ecc_key_17
    485                    return PSA_ERROR_INVALID_ARGUMENT;
   \      0x190   0xF07F 0x0086      MVNS     R0,#+134
   \      0x194   0xE005             B.N      ??sli_se_driver_validate_ecc_key_2
    486                  } else {
    487                    return_status = PSA_SUCCESS;
   \                     ??sli_se_driver_validate_ecc_key_17: (+1)
   \      0x196   0x2000             MOVS     R0,#+0
   \      0x198   0x4681             MOV      R9,R0
    488                  }
    489                }
    490                break;
    491              }
    492              #endif // SLI_PSA_DRIVER_FEATURE_SECPR1
    493          
    494              #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY) || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
    495              case PSA_ECC_FAMILY_MONTGOMERY: // Explicit fallthrough
    496              case PSA_ECC_FAMILY_TWISTED_EDWARDS:
    497                // Determine key bit-size
    498                if (*bits == 0) {
    499                  *bits = data_length * 8;
    500                } else {
    501                  if (PSA_BITS_TO_BYTES(*bits) != data_length) {
    502                    return PSA_ERROR_INVALID_ARGUMENT;
    503                  }
    504                }
    505                switch (*bits) {
    506                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE25519) || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS25519)
    507                  case 255:
    508                    return_status = PSA_SUCCESS;
    509                    break;
    510                  case 256:
    511                    // Maybe a 255 bit long key which has been padded to 32 bytes.
    512                    // Make sure the key size is not actually 256
    513                    if (psa_get_key_bits(attributes) == 256) {
    514                      return PSA_ERROR_NOT_SUPPORTED;
    515                    }
    516                    *bits = 255;
    517                    return_status = PSA_SUCCESS;
    518                    break;
    519                  #endif // SLI_PSA_DRIVER_FEATURE_CURVE25519 || SLI_PSA_DRIVER_FEATURE_EDWARDS25519
    520          
    521                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE448)
    522                  case 448:
    523                    return_status = PSA_SUCCESS;
    524                    break;
    525                  #endif // SLI_PSA_DRIVER_FEATURE_CURVE448
    526          
    527                  default:
    528                    return PSA_ERROR_NOT_SUPPORTED;
    529                    break;
    530                }
    531                break;
    532              #endif  // SLI_PSA_DRIVER_FEATURE_MONTGOMERY || SLI_PSA_DRIVER_FEATURE_EDWARDS
    533          
    534              default:
    535                return PSA_ERROR_NOT_SUPPORTED;
    536                break;
    537            }
    538          
    539            return return_status;
   \                     ??sli_se_driver_validate_ecc_key_10: (+1)
   \      0x19A   0x4648             MOV      R0,R9
   \      0x19C   0xE001             B.N      ??sli_se_driver_validate_ecc_key_2
   \                     ??sli_se_driver_validate_ecc_key_5: (+1)
   \      0x19E   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??sli_se_driver_validate_ecc_key_2: (+1)
   \      0x1A2   0xB045             ADD      SP,SP,#+276
   \      0x1A4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    540          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0x0, 0x0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x00               DC8 0
   \       0x21                      DS8 3

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0x0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18                      DS8 8

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0x0, 136
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0088
   \       0x18                      DS8 8

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0x0, 136
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0088
   \       0x18                      DS8 8
    541          
    542          #endif // SLI_PSA_DRIVER_FEATURE_ECC
    543          
    544          // -----------------------------------------------------------------------------
    545          // Global helper functions
    546          
    547          // -------------------------------------
    548          // Generic helper functions
    549          
    550          /**
    551           * @brief
    552           *   Build a key descriptor from a PSA attributes struct
    553           *
    554           * @param attributes
    555           *   The PSA attributes struct representing a key
    556           * @param key_size
    557           *    Size of the key
    558           * @param key_desc
    559           *   The SE manager key struct representing the same key
    560           * @returns
    561           *   PSA_SUCCESS on success
    562           *   PSA_ERROR_INVALID_ARGUMENT on invalid attributes
    563           */

   \                                 In section .text, align 2, keep-with-next
    564          psa_status_t sli_se_key_desc_from_psa_attributes(
    565            const psa_key_attributes_t *attributes,
    566            size_t key_size,
    567            sl_se_key_descriptor_t *key_desc)
    568          {
   \                     sli_se_key_desc_from_psa_attributes: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
    569            size_t attributes_key_size =
    570              PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
   \        0xA   0x4648             MOV      R0,R9
   \        0xC   0x.... 0x....      BL       psa_get_key_bits
   \       0x10   0x0005             MOVS     R5,R0
   \       0x12   0x1DED             ADDS     R5,R5,#+7
   \       0x14   0x08ED             LSRS     R5,R5,#+3
    571            if (attributes_key_size != 0) {
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD004             BEQ.N    ??sli_se_key_desc_from_psa_attributes_0
    572              // If attributes key size is nonzero, it must be equal to key_size
    573              if (attributes_key_size != key_size) {
   \       0x1A   0x42A5             CMP      R5,R4
   \       0x1C   0xD002             BEQ.N    ??sli_se_key_desc_from_psa_attributes_0
    574                return PSA_ERROR_INVALID_ARGUMENT;
   \       0x1E   0xF07F 0x0086      MVNS     R0,#+134
   \       0x22   0xE0E0             B.N      ??sli_se_key_desc_from_psa_attributes_1
    575              }
    576            }
    577            psa_key_type_t type = psa_get_key_type(attributes);
   \                     ??sli_se_key_desc_from_psa_attributes_0: (+1)
   \       0x24   0x4648             MOV      R0,R9
   \       0x26   0x.... 0x....      BL       psa_get_key_type
   \       0x2A   0x0007             MOVS     R7,R0
    578            psa_key_usage_t usage = psa_get_key_usage_flags(attributes);
   \       0x2C   0x4648             MOV      R0,R9
   \       0x2E   0x.... 0x....      BL       psa_get_key_usage_flags
   \       0x32   0x4680             MOV      R8,R0
    579            psa_key_lifetime_t lifetime = psa_get_key_lifetime(attributes);
   \       0x34   0x4648             MOV      R0,R9
   \       0x36   0x.... 0x....      BL       psa_get_key_lifetime
   \       0x3A   0x9002             STR      R0,[SP, #+8]
    580            psa_key_location_t location = PSA_KEY_LIFETIME_GET_LOCATION(lifetime);
   \       0x3C   0x9802             LDR      R0,[SP, #+8]
   \       0x3E   0x0A00             LSRS     R0,R0,#+8
   \       0x40   0x9000             STR      R0,[SP, #+0]
    581          
    582            memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
   \       0x42   0x2020             MOVS     R0,#+32
   \       0x44   0x9001             STR      R0,[SP, #+4]
   \       0x46   0xF05F 0x0B00      MOVS     R11,#+0
   \       0x4A   0x46B2             MOV      R10,R6
   \       0x4C   0x465A             MOV      R2,R11
   \       0x4E   0x9901             LDR      R1,[SP, #+4]
   \       0x50   0x4650             MOV      R0,R10
   \       0x52   0x.... 0x....      BL       __aeabi_memset
    583          
    584            switch (location) {
   \       0x56   0x9800             LDR      R0,[SP, #+0]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD002             BEQ.N    ??sli_se_key_desc_from_psa_attributes_2
   \       0x5C   0x2801             CMP      R0,#+1
   \       0x5E   0xD003             BEQ.N    ??sli_se_key_desc_from_psa_attributes_3
   \       0x60   0xE005             B.N      ??sli_se_key_desc_from_psa_attributes_4
    585              case PSA_KEY_LOCATION_LOCAL_STORAGE:
    586                key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT;
   \                     ??sli_se_key_desc_from_psa_attributes_2: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x60F0             STR      R0,[R6, #+12]
    587                break;
   \       0x66   0xE005             B.N      ??sli_se_key_desc_from_psa_attributes_5
    588          
    589                #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
    590              case PSA_KEY_LOCATION_SLI_SE_OPAQUE:
    591                // For the time being, volatile keys directly in SE internal RAM are not
    592                // supported. Once they are, use the persistence info from the key
    593                // lifetime to switch between EXTERNAL_WRAPPED and INTERNAL_VOLATILE.
    594                key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED;
   \                     ??sli_se_key_desc_from_psa_attributes_3: (+1)
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0x60F0             STR      R0,[R6, #+12]
    595                break;
   \       0x6C   0xE002             B.N      ??sli_se_key_desc_from_psa_attributes_5
    596                #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    597          
    598              default:
    599                return PSA_ERROR_DOES_NOT_EXIST;
   \                     ??sli_se_key_desc_from_psa_attributes_4: (+1)
   \       0x6E   0xF07F 0x008B      MVNS     R0,#+139
   \       0x72   0xE0B8             B.N      ??sli_se_key_desc_from_psa_attributes_1
    600            }
    601          
    602            // Dont't accept zero-length keys
    603            if (key_size == 0) {
   \                     ??sli_se_key_desc_from_psa_attributes_5: (+1)
   \       0x74   0x2C00             CMP      R4,#+0
   \       0x76   0xD102             BNE.N    ??sli_se_key_desc_from_psa_attributes_6
    604              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x78   0xF07F 0x0086      MVNS     R0,#+134
   \       0x7C   0xE0B3             B.N      ??sli_se_key_desc_from_psa_attributes_1
    605            }
    606          
    607            if (type == PSA_KEY_TYPE_RAW_DATA
    608                || type == PSA_KEY_TYPE_HMAC
    609                || type == PSA_KEY_TYPE_DERIVE) {
   \                     ??sli_se_key_desc_from_psa_attributes_6: (+1)
   \       0x7E   0x0039             MOVS     R1,R7
   \       0x80   0xF241 0x0001      MOVW     R0,#+4097
   \       0x84   0xB289             UXTH     R1,R1
   \       0x86   0x4281             CMP      R1,R0
   \       0x88   0xD009             BEQ.N    ??sli_se_key_desc_from_psa_attributes_7
   \       0x8A   0x0038             MOVS     R0,R7
   \       0x8C   0xB280             UXTH     R0,R0
   \       0x8E   0xF5B0 0x5F88      CMP      R0,#+4352
   \       0x92   0xD004             BEQ.N    ??sli_se_key_desc_from_psa_attributes_7
   \       0x94   0x0038             MOVS     R0,R7
   \       0x96   0xB280             UXTH     R0,R0
   \       0x98   0xF5B0 0x5F90      CMP      R0,#+4608
   \       0x9C   0xD103             BNE.N    ??sli_se_key_desc_from_psa_attributes_8
    610              // Set attributes
    611              key_desc->type = SL_SE_KEY_TYPE_SYMMETRIC;
   \                     ??sli_se_key_desc_from_psa_attributes_7: (+1)
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x6030             STR      R0,[R6, #+0]
    612              key_desc->size = key_size;
   \       0xA2   0x6074             STR      R4,[R6, #+4]
   \       0xA4   0xE086             B.N      ??sli_se_key_desc_from_psa_attributes_9
    613            } else
    614          
    615            #if defined(SLI_PSA_DRIVER_FEATURE_AES)
    616            if (type == PSA_KEY_TYPE_AES) {
   \                     ??sli_se_key_desc_from_psa_attributes_8: (+1)
   \       0xA6   0x0038             MOVS     R0,R7
   \       0xA8   0xB280             UXTH     R0,R0
   \       0xAA   0xF5B0 0x5F10      CMP      R0,#+9216
   \       0xAE   0xD115             BNE.N    ??sli_se_key_desc_from_psa_attributes_10
    617              switch (key_size) {
   \       0xB0   0x0020             MOVS     R0,R4
   \       0xB2   0x2810             CMP      R0,#+16
   \       0xB4   0xD004             BEQ.N    ??sli_se_key_desc_from_psa_attributes_11
   \       0xB6   0x2818             CMP      R0,#+24
   \       0xB8   0xD005             BEQ.N    ??sli_se_key_desc_from_psa_attributes_12
   \       0xBA   0x2820             CMP      R0,#+32
   \       0xBC   0xD006             BEQ.N    ??sli_se_key_desc_from_psa_attributes_13
   \       0xBE   0xE008             B.N      ??sli_se_key_desc_from_psa_attributes_14
    618                case 16:
    619                  key_desc->type = SL_SE_KEY_TYPE_AES_128;
   \                     ??sli_se_key_desc_from_psa_attributes_11: (+1)
   \       0xC0   0x2010             MOVS     R0,#+16
   \       0xC2   0x6030             STR      R0,[R6, #+0]
    620                  break;
   \       0xC4   0xE008             B.N      ??sli_se_key_desc_from_psa_attributes_15
    621                case 24:
    622                  key_desc->type = SL_SE_KEY_TYPE_AES_192;
   \                     ??sli_se_key_desc_from_psa_attributes_12: (+1)
   \       0xC6   0x2018             MOVS     R0,#+24
   \       0xC8   0x6030             STR      R0,[R6, #+0]
    623                  break;
   \       0xCA   0xE005             B.N      ??sli_se_key_desc_from_psa_attributes_15
    624                case 32:
    625                  key_desc->type = SL_SE_KEY_TYPE_AES_256;
   \                     ??sli_se_key_desc_from_psa_attributes_13: (+1)
   \       0xCC   0x2020             MOVS     R0,#+32
   \       0xCE   0x6030             STR      R0,[R6, #+0]
    626                  break;
   \       0xD0   0xE002             B.N      ??sli_se_key_desc_from_psa_attributes_15
    627                default:
    628                  // SE doesn't support off-size AES keys
    629                  return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_key_desc_from_psa_attributes_14: (+1)
   \       0xD2   0xF07F 0x0086      MVNS     R0,#+134
   \       0xD6   0xE086             B.N      ??sli_se_key_desc_from_psa_attributes_1
    630              }
    631              key_desc->size = key_size;
   \                     ??sli_se_key_desc_from_psa_attributes_15: (+1)
   \       0xD8   0x6074             STR      R4,[R6, #+4]
   \       0xDA   0xE06B             B.N      ??sli_se_key_desc_from_psa_attributes_9
    632            } else
    633            #endif // SLI_PSA_DRIVER_FEATURE_AES
    634          
    635            #if defined(SLI_PSA_DRIVER_FEATURE_CHACHA20) \
    636            || defined(SLI_PSA_DRIVER_FEATURE_CHACHAPOLY)
    637            if (type == PSA_KEY_TYPE_CHACHA20) {
    638              if (key_size != 0x20) {
    639                return PSA_ERROR_INVALID_ARGUMENT;
    640              }
    641              // Set attributes
    642              key_desc->type = SL_SE_KEY_TYPE_CHACHA20;
    643              key_desc->size = 0x20;
    644            } else
    645            #endif // SLI_PSA_DRIVER_FEATURE_CHACHA20 || SLI_PSA_DRIVER_FEATURE_CHACHAPOLY
    646          
    647            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
    648            if (PSA_KEY_TYPE_IS_ECC(type)) {
   \                     ??sli_se_key_desc_from_psa_attributes_10: (+1)
   \       0xDC   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0xE0   0x0039             MOVS     R1,R7
   \       0xE2   0xB289             UXTH     R1,R1
   \       0xE4   0x4001             ANDS     R1,R0,R1
   \       0xE6   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0xEA   0xD160             BNE.N    ??sli_se_key_desc_from_psa_attributes_16
    649              #if defined(SLI_PSA_DRIVER_FEATURE_SECPR1)
    650              if (PSA_KEY_TYPE_ECC_GET_FAMILY(type) == PSA_ECC_FAMILY_SECP_R1) {
   \       0xEC   0x0039             MOVS     R1,R7
   \       0xEE   0xB289             UXTH     R1,R1
   \       0xF0   0x4008             ANDS     R0,R0,R1
   \       0xF2   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0xF6   0xD101             BNE.N    ??sli_se_key_desc_from_psa_attributes_17
   \       0xF8   0x0038             MOVS     R0,R7
   \       0xFA   0xE000             B.N      ??sli_se_key_desc_from_psa_attributes_18
   \                     ??sli_se_key_desc_from_psa_attributes_17: (+1)
   \       0xFC   0x2000             MOVS     R0,#+0
   \                     ??sli_se_key_desc_from_psa_attributes_18: (+1)
   \       0xFE   0xB2C0             UXTB     R0,R0
   \      0x100   0x2812             CMP      R0,#+18
   \      0x102   0xD10F             BNE.N    ??sli_se_key_desc_from_psa_attributes_19
    651                // Find key size and set key type
    652                switch (key_size) {
   \      0x104   0x2C20             CMP      R4,#+32
   \      0x106   0xD10A             BNE.N    ??sli_se_key_desc_from_psa_attributes_20
    653                  #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
    654                  case 24:
    655                    key_desc->type = SL_SE_KEY_TYPE_ECC_P192;
    656                    break;
    657                  #endif     // SLI_PSA_DRIVER_FEATURE_P192R1
    658          
    659                  #if defined(SLI_PSA_DRIVER_FEATURE_P224R1)
    660                  // Series-2-config-1 devices do not support SECP224R1.
    661                  case 28:
    662                    key_desc->type = SL_SE_KEY_TYPE_ECC_P224;
    663                    break;
    664                  #endif     // SLI_PSA_DRIVER_FEATURE_P224R1
    665          
    666                  #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)
    667                  case 32:
    668                    key_desc->type = SL_SE_KEY_TYPE_ECC_P256;
   \      0x108   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \      0x10C   0x6030             STR      R0,[R6, #+0]
    669                    break;
    670                  #endif     // SLI_PSA_DRIVER_FEATURE_P256R1
    671          
    672                  #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
    673                  case 48:
    674                    key_desc->type = SL_SE_KEY_TYPE_ECC_P384;
    675                    break;
    676                  #endif     // SLI_PSA_DRIVER_FEATURE_P384R1
    677          
    678                  #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
    679                  case 66:
    680                    key_desc->type = SL_SE_KEY_TYPE_ECC_P521;
    681                    break;
    682                  #endif     // SLI_PSA_DRIVER_FEATURE_P521R1
    683          
    684                  default:
    685                    return PSA_ERROR_NOT_SUPPORTED;
    686                }
    687              } else
    688              #endif   // SLI_PSA_DRIVER_FEATURE_SECPR1
    689          
    690              #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY)
    691              if (PSA_KEY_TYPE_ECC_GET_FAMILY(type) == PSA_ECC_FAMILY_MONTGOMERY) {
    692                // Find key size and set key type
    693                switch (key_size) {
    694                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE25519)
    695                  case 32:
    696                    key_desc->type = SL_SE_KEY_TYPE_ECC_X25519;
    697                    break;
    698                  #endif     // SLI_PSA_DRIVER_FEATURE_CURVE25519
    699          
    700                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE448)
    701                  case 56:
    702                    key_desc->type = SL_SE_KEY_TYPE_ECC_X448;
    703                    break;
    704                  #endif     // SLI_PSA_DRIVER_FEATURE_CURVE448
    705          
    706                  default:
    707                    return PSA_ERROR_NOT_SUPPORTED;
    708                }
    709              } else
    710              #endif   // SLI_PSA_DRIVER_FEATURE_MONTGOMERY
    711          
    712              #if defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
    713              if (PSA_KEY_TYPE_ECC_GET_FAMILY(type) == PSA_ECC_FAMILY_TWISTED_EDWARDS) {
    714                // Find key size and set key type
    715                switch (key_size) {
    716                  #if defined(SLI_PSA_DRIVER_FEATURE_EDWARDS25519)
    717                  case 32:
    718                    key_desc->type = SL_SE_KEY_TYPE_ECC_ED25519;
    719                    break;
    720                  #endif     // SLI_PSA_DRIVER_FEATURE_EDWARDS25519
    721                  default:
    722                    return PSA_ERROR_NOT_SUPPORTED;
    723                }
    724              } else
    725              #endif   // SLI_PSA_DRIVER_FEATURE_EDWARDS
    726          
    727              {
    728                return PSA_ERROR_NOT_SUPPORTED;
    729              }
    730          
    731              // Set asymmetric args
    732              if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(type)) {
   \      0x10E   0x0038             MOVS     R0,R7
   \      0x110   0xB280             UXTH     R0,R0
   \      0x112   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \      0x116   0xF5B0 0x4FE2      CMP      R0,#+28928
   \      0x11A   0xD10B             BNE.N    ??sli_se_key_desc_from_psa_attributes_21
   \      0x11C   0xE005             B.N      ??sli_se_key_desc_from_psa_attributes_22
   \                     ??sli_se_key_desc_from_psa_attributes_20: (+1)
   \      0x11E   0xF07F 0x0085      MVNS     R0,#+133
   \      0x122   0xE060             B.N      ??sli_se_key_desc_from_psa_attributes_1
   \                     ??sli_se_key_desc_from_psa_attributes_19: (+1)
   \      0x124   0xF07F 0x0085      MVNS     R0,#+133
   \      0x128   0xE05D             B.N      ??sli_se_key_desc_from_psa_attributes_1
    733                key_desc->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
   \                     ??sli_se_key_desc_from_psa_attributes_22: (+1)
   \      0x12A   0x68B0             LDR      R0,[R6, #+8]
   \      0x12C   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \      0x130   0x60B0             STR      R0,[R6, #+8]
   \      0x132   0xE00E             B.N      ??sli_se_key_desc_from_psa_attributes_23
    734              } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(type)) {
   \                     ??sli_se_key_desc_from_psa_attributes_21: (+1)
   \      0x134   0x0038             MOVS     R0,R7
   \      0x136   0xB280             UXTH     R0,R0
   \      0x138   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \      0x13C   0xF5B0 0x4F82      CMP      R0,#+16640
   \      0x140   0xD104             BNE.N    ??sli_se_key_desc_from_psa_attributes_24
    735                key_desc->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \      0x142   0x68B0             LDR      R0,[R6, #+8]
   \      0x144   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \      0x148   0x60B0             STR      R0,[R6, #+8]
   \      0x14A   0xE002             B.N      ??sli_se_key_desc_from_psa_attributes_23
    736              } else {
    737                return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_key_desc_from_psa_attributes_24: (+1)
   \      0x14C   0xF07F 0x0086      MVNS     R0,#+134
   \      0x150   0xE049             B.N      ??sli_se_key_desc_from_psa_attributes_1
    738              }
    739          
    740              // Decide whether the key will be used for signing or derivation
    741              bool is_signing = (usage & (PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_VERIFY_HASH | PSA_KEY_USAGE_SIGN_MESSAGE | PSA_KEY_USAGE_VERIFY_MESSAGE)) != 0;
   \                     ??sli_se_key_desc_from_psa_attributes_23: (+1)
   \      0x152   0xF418 0x5F70      TST      R8,#0x3C00
   \      0x156   0xD001             BEQ.N    ??sli_se_key_desc_from_psa_attributes_25
   \      0x158   0x2101             MOVS     R1,#+1
   \      0x15A   0xE000             B.N      ??sli_se_key_desc_from_psa_attributes_26
   \                     ??sli_se_key_desc_from_psa_attributes_25: (+1)
   \      0x15C   0x2100             MOVS     R1,#+0
    742              bool is_deriving = (usage & (PSA_KEY_USAGE_DERIVE | PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT)) != 0;
   \                     ??sli_se_key_desc_from_psa_attributes_26: (+1)
   \      0x15E   0xF418 0x4F86      TST      R8,#0x4300
   \      0x162   0xD001             BEQ.N    ??sli_se_key_desc_from_psa_attributes_27
   \      0x164   0x2201             MOVS     R2,#+1
   \      0x166   0xE000             B.N      ??sli_se_key_desc_from_psa_attributes_28
   \                     ??sli_se_key_desc_from_psa_attributes_27: (+1)
   \      0x168   0x2200             MOVS     R2,#+0
    743          
    744              if (is_signing && !is_deriving) {
   \                     ??sli_se_key_desc_from_psa_attributes_28: (+1)
   \      0x16A   0xF092 0x0301      EORS     R3,R2,#0x1
   \      0x16E   0x0008             MOVS     R0,R1
   \      0x170   0xB2C0             UXTB     R0,R0
   \      0x172   0x4218             TST      R0,R3
   \      0x174   0xD004             BEQ.N    ??sli_se_key_desc_from_psa_attributes_29
    745                key_desc->flags |= SL_SE_KEY_FLAG_ASYMMMETRIC_SIGNING_ONLY;
   \      0x176   0x68B0             LDR      R0,[R6, #+8]
   \      0x178   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x17C   0x60B0             STR      R0,[R6, #+8]
   \      0x17E   0xE019             B.N      ??sli_se_key_desc_from_psa_attributes_9
    746              } else if (!is_signing && is_deriving) {
   \                     ??sli_se_key_desc_from_psa_attributes_29: (+1)
   \      0x180   0xF092 0x0001      EORS     R0,R2,#0x1
   \      0x184   0x4308             ORRS     R0,R0,R1
   \      0x186   0xB2C0             UXTB     R0,R0
   \      0x188   0x2800             CMP      R0,#+0
   \      0x18A   0xD104             BNE.N    ??sli_se_key_desc_from_psa_attributes_30
    747                key_desc->flags = (key_desc->flags & ~SL_SE_KEY_FLAG_ASYMMMETRIC_SIGNING_ONLY);
   \      0x18C   0x68B0             LDR      R0,[R6, #+8]
   \      0x18E   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x192   0x60B0             STR      R0,[R6, #+8]
   \      0x194   0xE00E             B.N      ??sli_se_key_desc_from_psa_attributes_9
    748              } else if (is_signing && is_deriving) {
   \                     ??sli_se_key_desc_from_psa_attributes_30: (+1)
   \      0x196   0x0008             MOVS     R0,R1
   \      0x198   0xB2C0             UXTB     R0,R0
   \      0x19A   0x4210             TST      R0,R2
   \      0x19C   0xD002             BEQ.N    ??sli_se_key_desc_from_psa_attributes_31
    749                // SE does not support a key to be used for both signing and derivation operations.
    750                return PSA_ERROR_NOT_SUPPORTED;
   \      0x19E   0xF07F 0x0085      MVNS     R0,#+133
   \      0x1A2   0xE020             B.N      ??sli_se_key_desc_from_psa_attributes_1
    751              } else {
    752                // ECC key is not setup for either signing or deriving. Default to not setting
    753                // the 'sign' flag (legacy behaviour)
    754                key_desc->flags = (key_desc->flags & ~SL_SE_KEY_FLAG_ASYMMMETRIC_SIGNING_ONLY);
   \                     ??sli_se_key_desc_from_psa_attributes_31: (+1)
   \      0x1A4   0x68B0             LDR      R0,[R6, #+8]
   \      0x1A6   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x1AA   0x60B0             STR      R0,[R6, #+8]
   \      0x1AC   0xE002             B.N      ??sli_se_key_desc_from_psa_attributes_9
    755              }
    756            } else
    757            #endif // SLI_PSA_DRIVER_FEATURE_ECC
    758            {
    759              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_key_desc_from_psa_attributes_16: (+1)
   \      0x1AE   0xF07F 0x0085      MVNS     R0,#+133
   \      0x1B2   0xE018             B.N      ??sli_se_key_desc_from_psa_attributes_1
    760            }
    761          
    762            #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
    763            // Add key restrictions. Only relevant for opaque drivers. If these properties
    764            // are set for transparent drivers, key generation becomes illegal, as the SE
    765            // does not allow writing a protected key to a plaintext buffer.
    766            if (location != PSA_KEY_LOCATION_LOCAL_STORAGE) {
   \                     ??sli_se_key_desc_from_psa_attributes_9: (+1)
   \      0x1B4   0x9800             LDR      R0,[SP, #+0]
   \      0x1B6   0x2800             CMP      R0,#+0
   \      0x1B8   0xD014             BEQ.N    ??sli_se_key_desc_from_psa_attributes_32
    767              bool can_export = usage & PSA_KEY_USAGE_EXPORT;
   \      0x1BA   0xF018 0x0101      ANDS     R1,R8,#0x1
    768              bool can_copy = usage & PSA_KEY_USAGE_COPY;
   \      0x1BE   0x4642             MOV      R2,R8
   \      0x1C0   0x0852             LSRS     R2,R2,#+1
   \      0x1C2   0xF012 0x0201      ANDS     R2,R2,#0x1
    769          
    770              if (can_copy) {
   \      0x1C6   0x0010             MOVS     R0,R2
   \      0x1C8   0xB2C0             UXTB     R0,R0
   \      0x1CA   0x2800             CMP      R0,#+0
   \      0x1CC   0xD002             BEQ.N    ??sli_se_key_desc_from_psa_attributes_33
    771                // We do not support copying opaque keys (currently).
    772                return PSA_ERROR_NOT_SUPPORTED;
   \      0x1CE   0xF07F 0x0085      MVNS     R0,#+133
   \      0x1D2   0xE008             B.N      ??sli_se_key_desc_from_psa_attributes_1
    773              }
    774              if (!can_export) {
   \                     ??sli_se_key_desc_from_psa_attributes_33: (+1)
   \      0x1D4   0x0008             MOVS     R0,R1
   \      0x1D6   0xB2C0             UXTB     R0,R0
   \      0x1D8   0x2800             CMP      R0,#+0
   \      0x1DA   0xD103             BNE.N    ??sli_se_key_desc_from_psa_attributes_32
    775                key_desc->flags |= SL_SE_KEY_FLAG_NON_EXPORTABLE;
   \      0x1DC   0x68B0             LDR      R0,[R6, #+8]
   \      0x1DE   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \      0x1E2   0x60B0             STR      R0,[R6, #+8]
    776              }
    777            }
    778            #else // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    779            (void)usage;
    780            #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    781          
    782            return PSA_SUCCESS;
   \                     ??sli_se_key_desc_from_psa_attributes_32: (+1)
   \      0x1E4   0x2000             MOVS     R0,#+0
   \                     ??sli_se_key_desc_from_psa_attributes_1: (+1)
   \      0x1E6   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    783          }
    784          
    785          /**
    786           * @brief
    787           *   Get the key descriptor from the key buffer and attributes
    788           */

   \                                 In section .text, align 2, keep-with-next
    789          psa_status_t sli_se_key_desc_from_input(const psa_key_attributes_t* attributes,
    790                                                  const uint8_t *key_buffer,
    791                                                  size_t key_buffer_size,
    792                                                  sl_se_key_descriptor_t *key_desc)
    793          {
   \                     sli_se_key_desc_from_input: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB098             SUB      SP,SP,#+96
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
    794            psa_key_lifetime_t lifetime = psa_get_key_lifetime(attributes);
   \        0xE   0x4640             MOV      R0,R8
   \       0x10   0x.... 0x....      BL       psa_get_key_lifetime
   \       0x14   0x9004             STR      R0,[SP, #+16]
    795            psa_key_location_t location = PSA_KEY_LIFETIME_GET_LOCATION(lifetime);
   \       0x16   0x9804             LDR      R0,[SP, #+16]
   \       0x18   0x0A00             LSRS     R0,R0,#+8
   \       0x1A   0x9003             STR      R0,[SP, #+12]
    796            uint32_t key_size = 0; // Retrieved in different ways for different locations
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x9000             STR      R0,[SP, #+0]
    797            switch (location) {
   \       0x20   0x9803             LDR      R0,[SP, #+12]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD002             BEQ.N    ??sli_se_key_desc_from_input_0
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD03E             BEQ.N    ??sli_se_key_desc_from_input_1
   \       0x2A   0xE112             B.N      ??sli_se_key_desc_from_input_2
    798              case PSA_KEY_LOCATION_LOCAL_STORAGE:
    799              {
    800                uint8_t *actual_key_buffer = (uint8_t *)key_buffer;
   \                     ??sli_se_key_desc_from_input_0: (+1)
   \       0x2C   0x46AB             MOV      R11,R5
    801                size_t actual_key_buffer_size = key_buffer_size;
   \       0x2E   0x46B1             MOV      R9,R6
    802          
    803                #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
    804                psa_key_type_t key_type = psa_get_key_type(attributes);
   \       0x30   0x4640             MOV      R0,R8
   \       0x32   0x.... 0x....      BL       psa_get_key_type
   \       0x36   0x4682             MOV      R10,R0
    805                if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {
   \       0x38   0x4650             MOV      R0,R10
   \       0x3A   0xB280             UXTH     R0,R0
   \       0x3C   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0x40   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0x44   0xD11F             BNE.N    ??sli_se_key_desc_from_input_3
    806                  // For ECC public keys, the attributes key size is always the factor
    807                  // determining the curve size
    808                  key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0x.... 0x....      BL       psa_get_key_bits
   \       0x4C   0x1DC0             ADDS     R0,R0,#+7
   \       0x4E   0x08C0             LSRS     R0,R0,#+3
   \       0x50   0x9000             STR      R0,[SP, #+0]
    809                  if (sli_se_has_format_byte(key_type)) {
   \       0x52   0x4650             MOV      R0,R10
   \       0x54   0xB280             UXTH     R0,R0
   \       0x56   0x.... 0x....      BL       sli_se_has_format_byte
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD010             BEQ.N    ??sli_se_key_desc_from_input_4
    810                    // Need to account for the format byte
    811                    if (*key_buffer != 0x04) {
   \       0x5E   0x7828             LDRB     R0,[R5, #+0]
   \       0x60   0x2804             CMP      R0,#+4
   \       0x62   0xD002             BEQ.N    ??sli_se_key_desc_from_input_5
    812                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x64   0xF07F 0x0086      MVNS     R0,#+134
   \       0x68   0xE10C             B.N      ??sli_se_key_desc_from_input_6
    813                    }
    814                    actual_key_buffer += 1;
   \                     ??sli_se_key_desc_from_input_5: (+1)
   \       0x6A   0xF11B 0x0B01      ADDS     R11,R11,#+1
    815                    actual_key_buffer_size -= 1;
   \       0x6E   0xF1B9 0x0901      SUBS     R9,R9,#+1
    816                    if (actual_key_buffer_size != 2 * key_size) {
   \       0x72   0x9800             LDR      R0,[SP, #+0]
   \       0x74   0xEBB9 0x0F40      CMP      R9,R0, LSL #+1
   \       0x78   0xD006             BEQ.N    ??sli_se_key_desc_from_input_7
    817                      return PSA_ERROR_INVALID_ARGUMENT;
   \       0x7A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x7E   0xE101             B.N      ??sli_se_key_desc_from_input_6
    818                    }
    819                    #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY) \
    820                    || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
    821                  } else if ((PSA_KEY_TYPE_ECC_GET_FAMILY(key_type)
    822                              == PSA_ECC_FAMILY_MONTGOMERY)
    823                             || (PSA_KEY_TYPE_ECC_GET_FAMILY(key_type)
    824                                 == PSA_ECC_FAMILY_TWISTED_EDWARDS)) {
    825                    if (actual_key_buffer_size != key_size) {
    826                      return PSA_ERROR_INVALID_ARGUMENT;
    827                    }
    828                    #endif // SLI_PSA_DRIVER_FEATURE_MONTGOMERY || SLI_PSA_DRIVER_FEATURE_EDWARDS
    829                  } else {
    830                    // No other curves supported yet.
    831                    return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_key_desc_from_input_4: (+1)
   \       0x80   0xF07F 0x0085      MVNS     R0,#+133
   \       0x84   0xE0FE             B.N      ??sli_se_key_desc_from_input_6
    832                  }
    833                } else
    834                #endif // SLI_PSA_DRIVER_FEATURE_ECC
    835          
    836                {
    837                  key_size = key_buffer_size;
   \                     ??sli_se_key_desc_from_input_3: (+1)
   \       0x86   0x9600             STR      R6,[SP, #+0]
    838                }
    839          
    840                // Fill the key desc from attributes
    841                psa_status_t psa_status = sli_se_key_desc_from_psa_attributes(attributes,
    842                                                                              key_size,
    843                                                                              key_desc);
   \                     ??sli_se_key_desc_from_input_7: (+1)
   \       0x88   0x003A             MOVS     R2,R7
   \       0x8A   0x9900             LDR      R1,[SP, #+0]
   \       0x8C   0x4640             MOV      R0,R8
   \       0x8E   0x.... 0x....      BL       sli_se_key_desc_from_psa_attributes
   \       0x92   0x0004             MOVS     R4,R0
    844                if (psa_status != PSA_SUCCESS) {
   \       0x94   0x2C00             CMP      R4,#+0
   \       0x96   0xD001             BEQ.N    ??sli_se_key_desc_from_input_8
    845                  return psa_status;
   \       0x98   0x0020             MOVS     R0,R4
   \       0x9A   0xE0F3             B.N      ??sli_se_key_desc_from_input_6
    846                }
    847                sli_se_key_descriptor_set_plaintext(key_desc,
    848                                                    actual_key_buffer,
    849                                                    actual_key_buffer_size);
   \                     ??sli_se_key_desc_from_input_8: (+1)
   \       0x9C   0x464A             MOV      R2,R9
   \       0x9E   0x4659             MOV      R1,R11
   \       0xA0   0x0038             MOVS     R0,R7
   \       0xA2   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
    850                break;
   \       0xA6   0xE0D7             B.N      ??sli_se_key_desc_from_input_9
    851              }
    852          
    853                #if defined(SLI_PSA_DRIVER_FEATURE_OPAQUE_KEYS)
    854              case PSA_KEY_LOCATION_SLI_SE_OPAQUE:
    855              {
    856                if (key_buffer_size < sizeof(sli_se_opaque_key_context_header_t)) {
   \                     ??sli_se_key_desc_from_input_1: (+1)
   \       0xA8   0x2E04             CMP      R6,#+4
   \       0xAA   0xD202             BCS.N    ??sli_se_key_desc_from_input_10
    857                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0xAC   0xF07F 0x0086      MVNS     R0,#+134
   \       0xB0   0xE0E8             B.N      ??sli_se_key_desc_from_input_6
    858                }
    859          
    860                sli_se_opaque_key_context_header_t *key_context_header =
    861                  (sli_se_opaque_key_context_header_t *)key_buffer;
   \                     ??sli_se_key_desc_from_input_10: (+1)
   \       0xB2   0x9502             STR      R5,[SP, #+8]
    862          
    863                if (key_context_header->struct_version != SLI_SE_OPAQUE_KEY_CONTEXT_VERSION) {
   \       0xB4   0x9802             LDR      R0,[SP, #+8]
   \       0xB6   0x7800             LDRB     R0,[R0, #+0]
   \       0xB8   0x2801             CMP      R0,#+1
   \       0xBA   0xD002             BEQ.N    ??sli_se_key_desc_from_input_11
    864                  return PSA_ERROR_STORAGE_FAILURE;
   \       0xBC   0xF07F 0x0091      MVNS     R0,#+145
   \       0xC0   0xE0E0             B.N      ??sli_se_key_desc_from_input_6
    865                }
    866          
    867                if (key_context_header->builtin_key_id != 0) {
   \                     ??sli_se_key_desc_from_input_11: (+1)
   \       0xC2   0x9802             LDR      R0,[SP, #+8]
   \       0xC4   0x7840             LDRB     R0,[R0, #+1]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD046             BEQ.N    ??sli_se_key_desc_from_input_12
    868                  sl_se_key_descriptor_t builtin_key_desc;
    869                  switch (key_context_header->builtin_key_id) {
   \       0xCA   0x9802             LDR      R0,[SP, #+8]
   \       0xCC   0x7840             LDRB     R0,[R0, #+1]
   \       0xCE   0x28F7             CMP      R0,#+247
   \       0xD0   0xD01F             BEQ.N    ??sli_se_key_desc_from_input_13
   \       0xD2   0x28F8             CMP      R0,#+248
   \       0xD4   0xD00F             BEQ.N    ??sli_se_key_desc_from_input_14
   \       0xD6   0x28FA             CMP      R0,#+250
   \       0xD8   0xD014             BEQ.N    ??sli_se_key_desc_from_input_15
   \       0xDA   0x28FC             CMP      R0,#+252
   \       0xDC   0xD004             BEQ.N    ??sli_se_key_desc_from_input_16
   \       0xDE   0x28FE             CMP      R0,#+254
   \       0xE0   0xD01E             BEQ.N    ??sli_se_key_desc_from_input_17
   \       0xE2   0x28FF             CMP      R0,#+255
   \       0xE4   0xD023             BEQ.N    ??sli_se_key_desc_from_input_18
   \       0xE6   0xE029             B.N      ??sli_se_key_desc_from_input_19
    870                    case SL_SE_KEY_SLOT_APPLICATION_SECURE_BOOT_KEY:
    871                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_APPLICATION_SECURE_BOOT_KEY;
   \                     ??sli_se_key_desc_from_input_16: (+1)
   \       0xE8   0xA805             ADD      R0,SP,#+20
   \       0xEA   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \       0xEE   0x2220             MOVS     R2,#+32
   \       0xF0   0x.... 0x....      BL       __aeabi_memcpy4
    872                      break;
   \       0xF4   0xE025             B.N      ??sli_se_key_desc_from_input_20
    873                    case SL_SE_KEY_SLOT_APPLICATION_SECURE_DEBUG_KEY:
    874                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_APPLICATION_SECURE_DEBUG_KEY;
   \                     ??sli_se_key_desc_from_input_14: (+1)
   \       0xF6   0xA805             ADD      R0,SP,#+20
   \       0xF8   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \       0xFC   0x2220             MOVS     R2,#+32
   \       0xFE   0x.... 0x....      BL       __aeabi_memcpy4
    875                      break;
   \      0x102   0xE01E             B.N      ??sli_se_key_desc_from_input_20
    876                    case SL_SE_KEY_SLOT_APPLICATION_AES_128_KEY:
    877                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_APPLICATION_AES_128_KEY;
   \                     ??sli_se_key_desc_from_input_15: (+1)
   \      0x104   0xA805             ADD      R0,SP,#+20
   \      0x106   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \      0x10A   0x2220             MOVS     R2,#+32
   \      0x10C   0x.... 0x....      BL       __aeabi_memcpy4
    878                      break;
   \      0x110   0xE017             B.N      ??sli_se_key_desc_from_input_20
    879                    case SL_SE_KEY_SLOT_TRUSTZONE_ROOT_KEY:
    880                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_TRUSTZONE_ROOT_KEY;
   \                     ??sli_se_key_desc_from_input_13: (+1)
   \      0x112   0xA805             ADD      R0,SP,#+20
   \      0x114   0x.... 0x....      LDR.W    R1,??DataTable8_5
   \      0x118   0x2220             MOVS     R2,#+32
   \      0x11A   0x.... 0x....      BL       __aeabi_memcpy4
    881                      break;
   \      0x11E   0xE010             B.N      ??sli_se_key_desc_from_input_20
    882                      #if defined(SLI_PSA_DRIVER_FEATURE_ATTESTATION)
    883                    case SL_SE_KEY_SLOT_APPLICATION_ATTESTATION_KEY:
    884                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_APPLICATION_ATTESTATION_KEY;
   \                     ??sli_se_key_desc_from_input_17: (+1)
   \      0x120   0xA805             ADD      R0,SP,#+20
   \      0x122   0x.... 0x....      LDR.W    R1,??DataTable8_6
   \      0x126   0x2220             MOVS     R2,#+32
   \      0x128   0x.... 0x....      BL       __aeabi_memcpy4
    885                      break;
   \      0x12C   0xE009             B.N      ??sli_se_key_desc_from_input_20
    886                    case SL_SE_KEY_SLOT_SE_ATTESTATION_KEY:
    887                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_SYSTEM_ATTESTATION_KEY;
   \                     ??sli_se_key_desc_from_input_18: (+1)
   \      0x12E   0xA805             ADD      R0,SP,#+20
   \      0x130   0x.... 0x....      LDR.W    R1,??DataTable8_7
   \      0x134   0x2220             MOVS     R2,#+32
   \      0x136   0x.... 0x....      BL       __aeabi_memcpy4
    888                      break;
   \      0x13A   0xE002             B.N      ??sli_se_key_desc_from_input_20
    889                      #endif // SLI_PSA_DRIVER_FEATURE_ATTESTATION
    890                    default:
    891                      return PSA_ERROR_DOES_NOT_EXIST;
   \                     ??sli_se_key_desc_from_input_19: (+1)
   \      0x13C   0xF07F 0x008B      MVNS     R0,#+139
   \      0x140   0xE0A0             B.N      ??sli_se_key_desc_from_input_6
    892                  }
    893                  memcpy(key_desc, &builtin_key_desc, sizeof(*key_desc));
   \                     ??sli_se_key_desc_from_input_20: (+1)
   \      0x142   0xF05F 0x0A20      MOVS     R10,#+32
   \      0x146   0xAC05             ADD      R4,SP,#+20
   \      0x148   0x46B9             MOV      R9,R7
   \      0x14A   0x4652             MOV      R2,R10
   \      0x14C   0x0021             MOVS     R1,R4
   \      0x14E   0x4648             MOV      R0,R9
   \      0x150   0x.... 0x....      BL       __aeabi_memcpy
    894                  return PSA_SUCCESS;
   \      0x154   0x2000             MOVS     R0,#+0
   \      0x156   0xE095             B.N      ??sli_se_key_desc_from_input_6
    895                } else {
    896                  #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
    897                  if (key_buffer_size < sizeof(sli_se_opaque_wrapped_key_context_t)) {
   \                     ??sli_se_key_desc_from_input_12: (+1)
   \      0x158   0x2E2C             CMP      R6,#+44
   \      0x15A   0xD202             BCS.N    ??sli_se_key_desc_from_input_21
    898                    return PSA_ERROR_INVALID_ARGUMENT;
   \      0x15C   0xF07F 0x0086      MVNS     R0,#+134
   \      0x160   0xE090             B.N      ??sli_se_key_desc_from_input_6
    899                  }
    900          
    901                  // Reconstruct key_desc from the key context
    902                  memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
   \                     ??sli_se_key_desc_from_input_21: (+1)
   \      0x162   0xF05F 0x0920      MOVS     R9,#+32
   \      0x166   0x2400             MOVS     R4,#+0
   \      0x168   0x46BA             MOV      R10,R7
   \      0x16A   0x0022             MOVS     R2,R4
   \      0x16C   0x4649             MOV      R1,R9
   \      0x16E   0x4650             MOV      R0,R10
   \      0x170   0x.... 0x....      BL       __aeabi_memset
    903          
    904                  // Refer to wrapped key context in input
    905                  sli_se_opaque_wrapped_key_context_t key_context_temp;
    906                  sli_se_opaque_wrapped_key_context_t *key_context =
    907                    (sli_se_opaque_wrapped_key_context_t *)key_buffer;
   \      0x174   0x9501             STR      R5,[SP, #+4]
    908                  key_desc->storage.location.buffer.pointer =
    909                    (uint8_t *)&(key_context->wrapped_buffer);
   \      0x176   0x9801             LDR      R0,[SP, #+4]
   \      0x178   0x3010             ADDS     R0,R0,#+16
   \      0x17A   0x6138             STR      R0,[R7, #+16]
    910          
    911                  // If the key buffer is unaligned, copy the content into a
    912                  // temporary buffer in order to prevent hardfaults caused by
    913                  // instructions that do not support unaligned words (e.g. LDRD, LDM).
    914                  if ((uintptr_t)key_buffer & 0x3) {
   \      0x17C   0xF015 0x0003      ANDS     R0,R5,#0x3
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xD00A             BEQ.N    ??sli_se_key_desc_from_input_22
    915                    memcpy(&key_context_temp, key_buffer, sizeof(sli_se_opaque_wrapped_key_context_t));
   \      0x184   0x242C             MOVS     R4,#+44
   \      0x186   0x46A9             MOV      R9,R5
   \      0x188   0xF10D 0x0A34      ADD      R10,SP,#+52
   \      0x18C   0x0022             MOVS     R2,R4
   \      0x18E   0x4649             MOV      R1,R9
   \      0x190   0x4650             MOV      R0,R10
   \      0x192   0x.... 0x....      BL       __aeabi_memcpy
    916                    key_context = &key_context_temp;
   \      0x196   0xA80D             ADD      R0,SP,#+52
   \      0x198   0x9001             STR      R0,[SP, #+4]
    917                  }
    918          
    919                  key_desc->type = key_context->key_type;
   \                     ??sli_se_key_desc_from_input_22: (+1)
   \      0x19A   0x9801             LDR      R0,[SP, #+4]
   \      0x19C   0x6840             LDR      R0,[R0, #+4]
   \      0x19E   0x6038             STR      R0,[R7, #+0]
    920                  key_desc->size = key_context->key_size;
   \      0x1A0   0x9801             LDR      R0,[SP, #+4]
   \      0x1A2   0x6880             LDR      R0,[R0, #+8]
   \      0x1A4   0x6078             STR      R0,[R7, #+4]
    921                  key_desc->flags = key_context->key_flags;
   \      0x1A6   0x9801             LDR      R0,[SP, #+4]
   \      0x1A8   0x68C0             LDR      R0,[R0, #+12]
   \      0x1AA   0x60B8             STR      R0,[R7, #+8]
    922          
    923                  key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED;
   \      0x1AC   0x2001             MOVS     R0,#+1
   \      0x1AE   0x60F8             STR      R0,[R7, #+12]
    924                  key_desc->storage.location.buffer.size =
    925                    key_buffer_size - offsetof(sli_se_opaque_wrapped_key_context_t,
    926                                               wrapped_buffer);
   \      0x1B0   0xF1B6 0x0010      SUBS     R0,R6,#+16
   \      0x1B4   0x6178             STR      R0,[R7, #+20]
    927          
    928                  // Clear temporary key context
    929                  if ((uintptr_t)key_buffer & 0x3) {
   \      0x1B6   0xF015 0x0003      ANDS     R0,R5,#0x3
   \      0x1BA   0x2800             CMP      R0,#+0
   \      0x1BC   0xD009             BEQ.N    ??sli_se_key_desc_from_input_23
    930                    memset(&key_context_temp, 0, sizeof(sli_se_opaque_wrapped_key_context_t));
   \      0x1BE   0xF05F 0x0A2C      MOVS     R10,#+44
   \      0x1C2   0x2400             MOVS     R4,#+0
   \      0x1C4   0xF10D 0x0934      ADD      R9,SP,#+52
   \      0x1C8   0x0022             MOVS     R2,R4
   \      0x1CA   0x4651             MOV      R1,R10
   \      0x1CC   0x4648             MOV      R0,R9
   \      0x1CE   0x.... 0x....      BL       __aeabi_memset
    931                  }
    932          
    933                  if (sli_key_get_size(key_desc, &key_size) != SL_STATUS_OK) {
   \                     ??sli_se_key_desc_from_input_23: (+1)
   \      0x1D2   0x4669             MOV      R1,SP
   \      0x1D4   0x0038             MOVS     R0,R7
   \      0x1D6   0x.... 0x....      BL       sli_key_get_size
   \      0x1DA   0x2800             CMP      R0,#+0
   \      0x1DC   0xD00B             BEQ.N    ??sli_se_key_desc_from_input_24
    934                    memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
   \      0x1DE   0xF05F 0x0A20      MOVS     R10,#+32
   \      0x1E2   0x2400             MOVS     R4,#+0
   \      0x1E4   0x46B9             MOV      R9,R7
   \      0x1E6   0x0022             MOVS     R2,R4
   \      0x1E8   0x4651             MOV      R1,R10
   \      0x1EA   0x4648             MOV      R0,R9
   \      0x1EC   0x.... 0x....      BL       __aeabi_memset
    935                    return PSA_ERROR_INVALID_ARGUMENT;
   \      0x1F0   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1F4   0xE046             B.N      ??sli_se_key_desc_from_input_6
    936                  }
    937          
    938                  uint32_t key_full_size = key_size;
   \                     ??sli_se_key_desc_from_input_24: (+1)
   \      0x1F6   0x9C00             LDR      R4,[SP, #+0]
    939          
    940                  #if defined(SLI_PSA_DRIVER_FEATURE_SECPR1)
    941                  if (PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(attributes))
    942                      == PSA_ECC_FAMILY_SECP_R1
    943                      && PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(psa_get_key_type(attributes))) {
   \      0x1F8   0x4640             MOV      R0,R8
   \      0x1FA   0x.... 0x....      BL       psa_get_key_type
   \      0x1FE   0x.... 0x....      LDR.W    R1,??DataTable7
   \      0x202   0x4008             ANDS     R0,R1,R0
   \      0x204   0xF5B0 0x4F82      CMP      R0,#+16640
   \      0x208   0xD103             BNE.N    ??sli_se_key_desc_from_input_25
   \      0x20A   0x4640             MOV      R0,R8
   \      0x20C   0x.... 0x....      BL       psa_get_key_type
   \      0x210   0xE000             B.N      ??sli_se_key_desc_from_input_26
   \                     ??sli_se_key_desc_from_input_25: (+1)
   \      0x212   0x2000             MOVS     R0,#+0
   \                     ??sli_se_key_desc_from_input_26: (+1)
   \      0x214   0xB2C0             UXTB     R0,R0
   \      0x216   0x2812             CMP      R0,#+18
   \      0x218   0xD108             BNE.N    ??sli_se_key_desc_from_input_27
   \      0x21A   0x4640             MOV      R0,R8
   \      0x21C   0x.... 0x....      BL       psa_get_key_type
   \      0x220   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \      0x224   0xF5B0 0x4F82      CMP      R0,#+16640
   \      0x228   0xD100             BNE.N    ??sli_se_key_desc_from_input_27
    944                    key_full_size = 2 * key_full_size;
   \      0x22A   0x0064             LSLS     R4,R4,#+1
    945                  }
    946                  #endif     // SLI_PSA_DRIVER_FEATURE_SECPR1
    947          
    948                  if (key_desc->storage.location.buffer.size < key_full_size + SLI_SE_WRAPPED_KEY_OVERHEAD) {
   \                     ??sli_se_key_desc_from_input_27: (+1)
   \      0x22C   0x6979             LDR      R1,[R7, #+20]
   \      0x22E   0xF114 0x001C      ADDS     R0,R4,#+28
   \      0x232   0x4281             CMP      R1,R0
   \      0x234   0xD20C             BCS.N    ??sli_se_key_desc_from_input_28
    949                    memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
   \      0x236   0xF05F 0x0B20      MOVS     R11,#+32
   \      0x23A   0xF05F 0x0900      MOVS     R9,#+0
   \      0x23E   0x46BA             MOV      R10,R7
   \      0x240   0x464A             MOV      R2,R9
   \      0x242   0x4659             MOV      R1,R11
   \      0x244   0x4650             MOV      R0,R10
   \      0x246   0x.... 0x....      BL       __aeabi_memset
    950                    return PSA_ERROR_INVALID_ARGUMENT;
   \      0x24A   0xF07F 0x0086      MVNS     R0,#+134
   \      0x24E   0xE019             B.N      ??sli_se_key_desc_from_input_6
    951                  }
    952          
    953                  #else   // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    954                  return PSA_ERROR_NOT_SUPPORTED;
    955                  #endif   // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    956                }
    957                break;
   \                     ??sli_se_key_desc_from_input_28: (+1)
   \      0x250   0xE002             B.N      ??sli_se_key_desc_from_input_9
    958              }
    959                #endif // SLI_PSA_DRIVER_FEATURE_OPAQUE_KEYS
    960          
    961              default:
    962                return PSA_ERROR_DOES_NOT_EXIST;
   \                     ??sli_se_key_desc_from_input_2: (+1)
   \      0x252   0xF07F 0x008B      MVNS     R0,#+139
   \      0x256   0xE015             B.N      ??sli_se_key_desc_from_input_6
    963            }
    964          
    965            // Run a general validation routine once the key desc has been populated
    966            psa_status_t status = validate_key_desc(attributes, key_size, key_desc);
   \                     ??sli_se_key_desc_from_input_9: (+1)
   \      0x258   0x003A             MOVS     R2,R7
   \      0x25A   0x9900             LDR      R1,[SP, #+0]
   \      0x25C   0x4640             MOV      R0,R8
   \      0x25E   0x.... 0x....      BL       validate_key_desc
   \      0x262   0x0004             MOVS     R4,R0
    967            if (status != PSA_SUCCESS) {
   \      0x264   0x2C00             CMP      R4,#+0
   \      0x266   0xD00C             BEQ.N    ??sli_se_key_desc_from_input_29
    968              memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
   \      0x268   0xF05F 0x0920      MOVS     R9,#+32
   \      0x26C   0xF05F 0x0A00      MOVS     R10,#+0
   \      0x270   0x46BB             MOV      R11,R7
   \      0x272   0x4652             MOV      R2,R10
   \      0x274   0x4649             MOV      R1,R9
   \      0x276   0x4658             MOV      R0,R11
   \      0x278   0x.... 0x....      BL       __aeabi_memset
    969              return PSA_ERROR_INVALID_ARGUMENT;
   \      0x27C   0xF07F 0x0086      MVNS     R0,#+134
   \      0x280   0xE000             B.N      ??sli_se_key_desc_from_input_6
    970            }
    971            return PSA_SUCCESS;
   \                     ??sli_se_key_desc_from_input_29: (+1)
   \      0x282   0x2000             MOVS     R0,#+0
   \                     ??sli_se_key_desc_from_input_6: (+1)
   \      0x284   0xB019             ADD      SP,SP,#+100
   \      0x286   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    972          }
    973          
    974          /**
    975           * @brief
    976           *   Set the relevant location field of the key descriptor
    977           */

   \                                 In section .text, align 2, keep-with-next
    978          psa_status_t sli_se_set_key_desc_output(const psa_key_attributes_t* attributes,
    979                                                  uint8_t *key_buffer,
    980                                                  size_t key_buffer_size,
    981                                                  size_t key_size,
    982                                                  sl_se_key_descriptor_t *key_desc)
    983          {
   \                     sli_se_set_key_desc_output: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8018      LDR      R8,[SP, #+24]
    984            psa_key_location_t location =
    985              PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       psa_get_key_lifetime
   \       0x16   0x0001             MOVS     R1,R0
   \       0x18   0x0A09             LSRS     R1,R1,#+8
    986            switch (location) {
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD002             BEQ.N    ??sli_se_set_key_desc_output_0
   \       0x1E   0x2901             CMP      R1,#+1
   \       0x20   0xD00A             BEQ.N    ??sli_se_set_key_desc_output_1
   \       0x22   0xE019             B.N      ??sli_se_set_key_desc_output_2
    987              case PSA_KEY_LOCATION_LOCAL_STORAGE:
    988                if (key_buffer_size < key_size) {
   \                     ??sli_se_set_key_desc_output_0: (+1)
   \       0x24   0x42BE             CMP      R6,R7
   \       0x26   0xD202             BCS.N    ??sli_se_set_key_desc_output_3
    989                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x28   0xF07F 0x008C      MVNS     R0,#+140
   \       0x2C   0xE018             B.N      ??sli_se_set_key_desc_output_4
    990                }
    991                key_desc->storage.location.buffer.pointer = key_buffer;
   \                     ??sli_se_set_key_desc_output_3: (+1)
   \       0x2E   0xF8C8 0x5010      STR      R5,[R8, #+16]
    992          
    993                #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    994                key_buffer_size = sli_se_word_align(key_buffer_size);
    995                #endif
    996          
    997                key_desc->storage.location.buffer.size = key_buffer_size;
   \       0x32   0xF8C8 0x6014      STR      R6,[R8, #+20]
    998                break;
   \       0x36   0xE012             B.N      ??sli_se_set_key_desc_output_5
    999          
   1000                #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
   1001              case PSA_KEY_LOCATION_SLI_SE_OPAQUE:
   1002                #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1003                key_size = sli_se_word_align(key_size);
   1004                #endif
   1005          
   1006                if (key_buffer_size < sizeof(sli_se_opaque_wrapped_key_context_t)
   1007                    + key_size) {
   \                     ??sli_se_set_key_desc_output_1: (+1)
   \       0x38   0xF117 0x002C      ADDS     R0,R7,#+44
   \       0x3C   0x4286             CMP      R6,R0
   \       0x3E   0xD202             BCS.N    ??sli_se_set_key_desc_output_6
   1008                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x40   0xF07F 0x008C      MVNS     R0,#+140
   \       0x44   0xE00C             B.N      ??sli_se_set_key_desc_output_4
   1009                }
   1010                key_desc->storage.location.buffer.pointer =
   1011                  key_buffer + offsetof(sli_se_opaque_wrapped_key_context_t,
   1012                                        wrapped_buffer);
   \                     ??sli_se_set_key_desc_output_6: (+1)
   \       0x46   0xF115 0x0010      ADDS     R0,R5,#+16
   \       0x4A   0xF8C8 0x0010      STR      R0,[R8, #+16]
   1013                key_desc->storage.location.buffer.size =
   1014                  key_size + SLI_SE_WRAPPED_KEY_OVERHEAD;
   \       0x4E   0xF117 0x001C      ADDS     R0,R7,#+28
   \       0x52   0xF8C8 0x0014      STR      R0,[R8, #+20]
   1015                break;
   \       0x56   0xE002             B.N      ??sli_se_set_key_desc_output_5
   1016                #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
   1017          
   1018              default:
   1019                return PSA_ERROR_DOES_NOT_EXIST;
   \                     ??sli_se_set_key_desc_output_2: (+1)
   \       0x58   0xF07F 0x008B      MVNS     R0,#+139
   \       0x5C   0xE000             B.N      ??sli_se_set_key_desc_output_4
   1020            }
   1021            return PSA_SUCCESS;
   \                     ??sli_se_set_key_desc_output_5: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \                     ??sli_se_set_key_desc_output_4: (+1)
   \       0x60   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1022          }
   1023          
   1024          #if defined(SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN) \
   1025            && defined(MBEDTLS_ECP_C)                                  \
   1026            && defined(MBEDTLS_PSA_CRYPTO_C)                           \
   1027            && SL_SE_SUPPORT_FW_PRIOR_TO_1_2_2
   1028          
   1029          #include "mbedtls/ecp.h"
   1030          #include "psa_crypto_core.h"
   1031          
   1032          psa_status_t sli_se_driver_validate_pubkey_with_fallback(psa_key_type_t key_type,
   1033                                                                   size_t key_bits,
   1034                                                                   const uint8_t *data,
   1035                                                                   size_t data_length)
   1036          {
   1037            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1038          
   1039            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1040            mbedtls_ecp_group_id grp_id = MBEDTLS_ECP_DP_NONE;
   1041          
   1042            mbedtls_ecp_group pubkey_grp;
   1043            mbedtls_ecp_point pubkey_point;
   1044          
   1045            mbedtls_ecp_group_init(&pubkey_grp);
   1046            mbedtls_ecp_point_init(&pubkey_point);
   1047          
   1048            // Get software-defined curve structure
   1049            grp_id = mbedtls_ecc_group_of_psa(PSA_KEY_TYPE_ECC_GET_FAMILY(key_type),
   1050                                              key_bits,
   1051                                              1);
   1052            if (grp_id == MBEDTLS_ECP_DP_NONE) {
   1053              goto exit;
   1054            }
   1055          
   1056            psa_status = mbedtls_to_psa_error(mbedtls_ecp_group_load(&pubkey_grp,
   1057                                                                     grp_id));
   1058            if (psa_status != PSA_SUCCESS) {
   1059              goto exit;
   1060            }
   1061          
   1062            // Load public key into mbed TLS structure
   1063            psa_status = mbedtls_to_psa_error(mbedtls_ecp_point_read_binary(
   1064                                                &pubkey_grp,
   1065                                                &pubkey_point,
   1066                                                data,
   1067                                                data_length) );
   1068            if (psa_status != PSA_SUCCESS) {
   1069              goto exit;
   1070            }
   1071          
   1072            // Validate key.
   1073            psa_status = mbedtls_to_psa_error(mbedtls_ecp_check_pubkey(&pubkey_grp,
   1074                                                                       &pubkey_point));
   1075          
   1076            exit:
   1077            mbedtls_ecp_group_free(&pubkey_grp);
   1078            mbedtls_ecp_point_free(&pubkey_point);
   1079            return psa_status;
   1080          
   1081            #else // SLI_PSA_DRIVER_FEATURE_ECC
   1082          
   1083            (void) key_type;
   1084            (void) key_bits;
   1085            (void) data;
   1086            (void) data_length;
   1087          
   1088            return PSA_ERROR_NOT_SUPPORTED;
   1089          
   1090            #endif // SLI_PSA_DRIVER_FEATURE_ECC
   1091          }
   1092          
   1093          #endif // SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN ...
   1094          
   1095          // -------------------------------------
   1096          // Opaque helper functions
   1097          
   1098          #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
   1099          
   1100          /**
   1101           * @brief
   1102           *   Store the required parts of the key descriptor in the context placed the
   1103           *   start of the given key buffer.
   1104           */

   \                                 In section .text, align 2, keep-with-next
   1105          psa_status_t store_key_desc_in_context(sl_se_key_descriptor_t *key_desc,
   1106                                                 uint8_t *key_buffer,
   1107                                                 size_t key_buffer_size)
   1108          {
   \                     store_key_desc_in_context: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1109            if (key_buffer_size < sizeof(sli_se_opaque_wrapped_key_context_t)) {
   \        0xA   0x2E2C             CMP      R6,#+44
   \        0xC   0xD202             BCS.N    ??store_key_desc_in_context_0
   1110              return PSA_ERROR_BUFFER_TOO_SMALL;
   \        0xE   0xF07F 0x0089      MVNS     R0,#+137
   \       0x12   0xE016             B.N      ??store_key_desc_in_context_1
   1111            }
   1112          
   1113            sli_se_opaque_wrapped_key_context_t *key_context =
   1114              (sli_se_opaque_wrapped_key_context_t *)key_buffer;
   \                     ??store_key_desc_in_context_0: (+1)
   \       0x14   0x002F             MOVS     R7,R5
   1115            key_context->header.struct_version = SLI_SE_OPAQUE_KEY_CONTEXT_VERSION;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x7038             STRB     R0,[R7, #+0]
   1116            key_context->header.builtin_key_id = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x7078             STRB     R0,[R7, #+1]
   1117            memset(&key_context->header.reserved, 0, sizeof(key_context->header.reserved));
   \       0x1E   0xF05F 0x0802      MOVS     R8,#+2
   \       0x22   0xF05F 0x0900      MOVS     R9,#+0
   \       0x26   0xF117 0x0A02      ADDS     R10,R7,#+2
   \       0x2A   0x464A             MOV      R2,R9
   \       0x2C   0x4641             MOV      R1,R8
   \       0x2E   0x4650             MOV      R0,R10
   \       0x30   0x.... 0x....      BL       __aeabi_memset
   1118            key_context->key_type = key_desc->type;
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6078             STR      R0,[R7, #+4]
   1119            key_context->key_size = key_desc->size;
   \       0x38   0x6860             LDR      R0,[R4, #+4]
   \       0x3A   0x60B8             STR      R0,[R7, #+8]
   1120            key_context->key_flags = key_desc->flags;
   \       0x3C   0x68A0             LDR      R0,[R4, #+8]
   \       0x3E   0x60F8             STR      R0,[R7, #+12]
   1121          
   1122            return PSA_SUCCESS;
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??store_key_desc_in_context_1: (+1)
   \       0x42   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1123          }
   1124          
   1125          #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
   1126          
   1127          // -----------------------------------------------------------------------------
   1128          // Driver entry points
   1129          
   1130          // -------------------------------------
   1131          // Generic driver entry points
   1132          

   \                                 In section .text, align 2, keep-with-next
   1133          psa_status_t sli_se_driver_generate_key(const psa_key_attributes_t *attributes,
   1134                                                  uint8_t *key_buffer,
   1135                                                  size_t key_buffer_size,
   1136                                                  size_t *key_buffer_length)
   1137          {
   \                     sli_se_driver_generate_key: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x4692             MOV      R10,R2
   1138            if (attributes == NULL
   1139                || key_buffer == NULL
   1140                || key_buffer_size == 0) {
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD004             BEQ.N    ??sli_se_driver_generate_key_0
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD002             BEQ.N    ??sli_se_driver_generate_key_0
   \       0x14   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x18   0xD102             BNE.N    ??sli_se_driver_generate_key_1
   1141              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_generate_key_0: (+1)
   \       0x1A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x1E   0xE08E             B.N      ??sli_se_driver_generate_key_2
   1142            }
   1143          
   1144            size_t key_bits = psa_get_key_bits(attributes);
   \                     ??sli_se_driver_generate_key_1: (+1)
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0x.... 0x....      BL       psa_get_key_bits
   \       0x26   0x4681             MOV      R9,R0
   1145            size_t key_size = PSA_BITS_TO_BYTES(key_bits);
   \       0x28   0xF119 0x0707      ADDS     R7,R9,#+7
   \       0x2C   0x08FF             LSRS     R7,R7,#+3
   1146            if (key_size == 0) {
   \       0x2E   0x2F00             CMP      R7,#+0
   \       0x30   0xD102             BNE.N    ??sli_se_driver_generate_key_3
   1147              return PSA_ERROR_NOT_SUPPORTED;
   \       0x32   0xF07F 0x0085      MVNS     R0,#+133
   \       0x36   0xE082             B.N      ??sli_se_driver_generate_key_2
   1148            }
   1149          
   1150            psa_key_type_t key_type = psa_get_key_type(attributes);
   \                     ??sli_se_driver_generate_key_3: (+1)
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       psa_get_key_type
   \       0x3E   0x4680             MOV      R8,R0
   1151            if (PSA_KEY_TYPE_IS_UNSTRUCTURED(key_type)
   1152                && ((key_bits & 0x7) != 0)) {
   \       0x40   0x4640             MOV      R0,R8
   \       0x42   0xB280             UXTH     R0,R0
   \       0x44   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x48   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x4C   0xD006             BEQ.N    ??sli_se_driver_generate_key_4
   \       0x4E   0x4640             MOV      R0,R8
   \       0x50   0xB280             UXTH     R0,R0
   \       0x52   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x56   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x5A   0xD105             BNE.N    ??sli_se_driver_generate_key_5
   \                     ??sli_se_driver_generate_key_4: (+1)
   \       0x5C   0xF019 0x0F07      TST      R9,#0x7
   \       0x60   0xD002             BEQ.N    ??sli_se_driver_generate_key_5
   1153              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x62   0xF07F 0x0086      MVNS     R0,#+134
   \       0x66   0xE06A             B.N      ??sli_se_driver_generate_key_2
   1154            } else if (PSA_KEY_TYPE_IS_PUBLIC_KEY(key_type)) {
   \                     ??sli_se_driver_generate_key_5: (+1)
   \       0x68   0x4640             MOV      R0,R8
   \       0x6A   0xB280             UXTH     R0,R0
   \       0x6C   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x70   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x74   0xD102             BNE.N    ??sli_se_driver_generate_key_6
   1155              // PSA Crypto defines generate_key to be an invalid call with a key type
   1156              // of public key.
   1157              return PSA_ERROR_NOT_SUPPORTED;
   \       0x76   0xF07F 0x0085      MVNS     R0,#+133
   \       0x7A   0xE060             B.N      ??sli_se_driver_generate_key_2
   1158            }
   1159          
   1160            // Generate a key desc
   1161            sl_se_key_descriptor_t key_desc = { 0 };
   \                     ??sli_se_driver_generate_key_6: (+1)
   \       0x7C   0xA80A             ADD      R0,SP,#+40
   \       0x7E   0x2120             MOVS     R1,#+32
   \       0x80   0x.... 0x....      BL       __aeabi_memclr4
   1162            psa_status_t psa_status =
   1163              sli_se_key_desc_from_psa_attributes(attributes,
   1164                                                  key_size,
   1165                                                  &key_desc);
   \       0x84   0xAA0A             ADD      R2,SP,#+40
   \       0x86   0x0039             MOVS     R1,R7
   \       0x88   0x0028             MOVS     R0,R5
   \       0x8A   0x.... 0x....      BL       sli_se_key_desc_from_psa_attributes
   \       0x8E   0x4683             MOV      R11,R0
   1166            if (psa_status != PSA_SUCCESS) {
   \       0x90   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x94   0xD001             BEQ.N    ??sli_se_driver_generate_key_7
   1167              return psa_status;
   \       0x96   0x4658             MOV      R0,R11
   \       0x98   0xE051             B.N      ??sli_se_driver_generate_key_2
   1168            }
   1169          
   1170            psa_status = sli_se_set_key_desc_output(attributes,
   1171                                                    key_buffer,
   1172                                                    key_buffer_size,
   1173                                                    key_size,
   1174                                                    &key_desc);
   \                     ??sli_se_driver_generate_key_7: (+1)
   \       0x9A   0xA80A             ADD      R0,SP,#+40
   \       0x9C   0x9000             STR      R0,[SP, #+0]
   \       0x9E   0x003B             MOVS     R3,R7
   \       0xA0   0x4652             MOV      R2,R10
   \       0xA2   0x0031             MOVS     R1,R6
   \       0xA4   0x0028             MOVS     R0,R5
   \       0xA6   0x.... 0x....      BL       sli_se_set_key_desc_output
   \       0xAA   0x0004             MOVS     R4,R0
   1175            if (psa_status != PSA_SUCCESS) {
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD001             BEQ.N    ??sli_se_driver_generate_key_8
   1176              return psa_status;
   \       0xB0   0x0020             MOVS     R0,R4
   \       0xB2   0xE044             B.N      ??sli_se_driver_generate_key_2
   1177            }
   1178          
   1179            // Generate the key using SE manager
   1180            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_driver_generate_key_8: (+1)
   \       0xB4   0xA801             ADD      R0,SP,#+4
   \       0xB6   0x2124             MOVS     R1,#+36
   \       0xB8   0x.... 0x....      BL       __aeabi_memclr4
   1181            sl_status_t sl_status = sl_se_init_command_context(&cmd_ctx);
   \       0xBC   0xA801             ADD      R0,SP,#+4
   \       0xBE   0x.... 0x....      BL       sl_se_init_command_context
   \       0xC2   0x9000             STR      R0,[SP, #+0]
   1182            if (sl_status != SL_STATUS_OK) {
   \       0xC4   0x9800             LDR      R0,[SP, #+0]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD002             BEQ.N    ??sli_se_driver_generate_key_9
   1183              return PSA_ERROR_HARDWARE_FAILURE;
   \       0xCA   0xF07F 0x0092      MVNS     R0,#+146
   \       0xCE   0xE036             B.N      ??sli_se_driver_generate_key_2
   1184            }
   1185            sl_status = sl_se_generate_key(&cmd_ctx, &key_desc);
   \                     ??sli_se_driver_generate_key_9: (+1)
   \       0xD0   0xA90A             ADD      R1,SP,#+40
   \       0xD2   0xA801             ADD      R0,SP,#+4
   \       0xD4   0x.... 0x....      BL       sl_se_generate_key
   \       0xD8   0x4683             MOV      R11,R0
   1186            if (sl_status != SL_STATUS_OK) {
   \       0xDA   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xDE   0xD00A             BEQ.N    ??sli_se_driver_generate_key_10
   1187              if (sl_status == SL_STATUS_COMMAND_IS_INVALID) {
   \       0xE0   0xF1BB 0x0F48      CMP      R11,#+72
   \       0xE4   0xD103             BNE.N    ??sli_se_driver_generate_key_11
   1188                // This error will be returned if the key type isn't supported.
   1189                psa_status = PSA_ERROR_NOT_SUPPORTED;
   \       0xE6   0xF07F 0x0085      MVNS     R0,#+133
   \       0xEA   0x0004             MOVS     R4,R0
   \       0xEC   0xE002             B.N      ??sli_se_driver_generate_key_12
   1190              } else {
   1191                psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_generate_key_11: (+1)
   \       0xEE   0xF07F 0x0092      MVNS     R0,#+146
   \       0xF2   0x0004             MOVS     R4,R0
   1192              }
   1193              goto exit;
   \                     ??sli_se_driver_generate_key_12: (+1)
   \       0xF4   0xE019             B.N      ??sli_se_driver_generate_key_13
   1194            } else {
   1195              if (PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes))
   1196                  == PSA_KEY_LOCATION_LOCAL_STORAGE) {
   \                     ??sli_se_driver_generate_key_10: (+1)
   \       0xF6   0x0028             MOVS     R0,R5
   \       0xF8   0x.... 0x....      BL       psa_get_key_lifetime
   \       0xFC   0x0A00             LSRS     R0,R0,#+8
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD105             BNE.N    ??sli_se_driver_generate_key_14
   1197                // Apply clamping if this is a Montgomery key.
   1198                clamp_private_key_if_needed(attributes, key_buffer, key_bits);
   \      0x102   0x464A             MOV      R2,R9
   \      0x104   0x0031             MOVS     R1,R6
   \      0x106   0x0028             MOVS     R0,R5
   \      0x108   0x.... 0x....      BL       clamp_private_key_if_needed
   \      0x10C   0xE007             B.N      ??sli_se_driver_generate_key_15
   1199              }
   1200          
   1201              #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
   1202              else {
   1203                // Add the key desc to the output array for opaque keys.
   1204                psa_status = store_key_desc_in_context(&key_desc,
   1205                                                       key_buffer,
   1206                                                       key_buffer_size);
   \                     ??sli_se_driver_generate_key_14: (+1)
   \      0x10E   0x4652             MOV      R2,R10
   \      0x110   0x0031             MOVS     R1,R6
   \      0x112   0xA80A             ADD      R0,SP,#+40
   \      0x114   0x.... 0x....      BL       store_key_desc_in_context
   \      0x118   0x0004             MOVS     R4,R0
   1207                if (psa_status != PSA_SUCCESS) {
   \      0x11A   0x2C00             CMP      R4,#+0
   \      0x11C   0xD105             BNE.N    ??sli_se_driver_generate_key_13
   1208                  goto exit;
   1209                }
   1210              }
   1211              #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
   1212          
   1213              psa_status = set_key_buffer_length(attributes, key_size, key_buffer_length);
   \                     ??sli_se_driver_generate_key_15: (+1)
   \      0x11E   0x9A12             LDR      R2,[SP, #+72]
   \      0x120   0x0039             MOVS     R1,R7
   \      0x122   0x0028             MOVS     R0,R5
   \      0x124   0x.... 0x....      BL       set_key_buffer_length
   \      0x128   0x0004             MOVS     R4,R0
   1214            }
   1215            // Cleanup
   1216            exit:
   1217            sl_status = sl_se_deinit_command_context(&cmd_ctx);
   \                     ??sli_se_driver_generate_key_13: (+1)
   \      0x12A   0xA801             ADD      R0,SP,#+4
   \      0x12C   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x130   0x0001             MOVS     R1,R0
   1218            if (sl_status != SL_STATUS_OK) {
   \      0x132   0x2900             CMP      R1,#+0
   \      0x134   0xD002             BEQ.N    ??sli_se_driver_generate_key_16
   1219              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x136   0xF07F 0x0092      MVNS     R0,#+146
   \      0x13A   0xE000             B.N      ??sli_se_driver_generate_key_2
   1220            }
   1221            return psa_status;
   \                     ??sli_se_driver_generate_key_16: (+1)
   \      0x13C   0x0020             MOVS     R0,R4
   \                     ??sli_se_driver_generate_key_2: (+1)
   \      0x13E   0xB013             ADD      SP,SP,#+76
   \      0x140   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1222          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
   1223          

   \                                 In section .text, align 2, keep-with-next
   1224          psa_status_t sli_se_driver_export_public_key(
   1225            const psa_key_attributes_t *attributes,
   1226            const uint8_t *key_buffer,
   1227            size_t key_buffer_size,
   1228            uint8_t *data,
   1229            size_t data_size,
   1230            size_t *data_length)
   1231          {
   \                     sli_se_driver_export_public_key: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB09B             SUB      SP,SP,#+108
   \        0x6   0x0014             MOVS     R4,R2
   \        0x8   0x001D             MOVS     R5,R3
   \        0xA   0x9E26             LDR      R6,[SP, #+152]
   \        0xC   0x9F27             LDR      R7,[SP, #+156]
   1232            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1233          
   1234            if (attributes == NULL
   1235                || key_buffer == NULL
   1236                || key_buffer_size == 0
   1237                || data == NULL
   1238                || data_size == 0
   1239                || data_length == NULL) {
   \        0xE   0x981B             LDR      R0,[SP, #+108]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD00A             BEQ.N    ??sli_se_driver_export_public_key_0
   \       0x14   0x981C             LDR      R0,[SP, #+112]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD007             BEQ.N    ??sli_se_driver_export_public_key_0
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD005             BEQ.N    ??sli_se_driver_export_public_key_0
   \       0x1E   0x2D00             CMP      R5,#+0
   \       0x20   0xD003             BEQ.N    ??sli_se_driver_export_public_key_0
   \       0x22   0x2E00             CMP      R6,#+0
   \       0x24   0xD001             BEQ.N    ??sli_se_driver_export_public_key_0
   \       0x26   0x2F00             CMP      R7,#+0
   \       0x28   0xD102             BNE.N    ??sli_se_driver_export_public_key_1
   1240              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_export_public_key_0: (+1)
   \       0x2A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x2E   0xE07D             B.N      ??sli_se_driver_export_public_key_2
   1241            }
   1242          
   1243            // Build key descs for the private key
   1244            sl_se_key_descriptor_t priv_key_desc = { 0 };
   \                     ??sli_se_driver_export_public_key_1: (+1)
   \       0x30   0xA813             ADD      R0,SP,#+76
   \       0x32   0x2120             MOVS     R1,#+32
   \       0x34   0x.... 0x....      BL       __aeabi_memclr4
   1245            psa_status_t psa_status = sli_se_key_desc_from_input(attributes,
   1246                                                                 key_buffer,
   1247                                                                 key_buffer_size,
   1248                                                                 &priv_key_desc);
   \       0x38   0xAB13             ADD      R3,SP,#+76
   \       0x3A   0x0022             MOVS     R2,R4
   \       0x3C   0x991C             LDR      R1,[SP, #+112]
   \       0x3E   0x981B             LDR      R0,[SP, #+108]
   \       0x40   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x44   0x4680             MOV      R8,R0
   1249            if (psa_status != PSA_SUCCESS) {
   \       0x46   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x4A   0xD001             BEQ.N    ??sli_se_driver_export_public_key_3
   1250              return psa_status;
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0xE06D             B.N      ??sli_se_driver_export_public_key_2
   1251            }
   1252          
   1253            // ECC public keys are written in uncompressed format with a preceeding 0x04
   1254            // format byte. This byte should however not be present for Montgomery keys
   1255            uint32_t prepend_format_byte = 1;
   \                     ??sli_se_driver_export_public_key_3: (+1)
   \       0x50   0xF05F 0x0901      MOVS     R9,#+1
   1256            #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY) || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
   1257            if ((PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(attributes))
   1258                 == PSA_ECC_FAMILY_MONTGOMERY)
   1259                || (PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(attributes))
   1260                    == PSA_ECC_FAMILY_TWISTED_EDWARDS)) {
   1261              prepend_format_byte = 0;
   1262            }
   1263            #endif   // SLI_PSA_DRIVER_FEATURE_MONTGOMERY || SLI_PSA_DRIVER_FEATURE_EDWARDS
   1264          
   1265            sl_se_key_descriptor_t pub_key_desc = priv_key_desc;
   \       0x54   0xA802             ADD      R0,SP,#+8
   \       0x56   0xA913             ADD      R1,SP,#+76
   \       0x58   0x2220             MOVS     R2,#+32
   \       0x5A   0x.... 0x....      BL       __aeabi_memcpy4
   1266            size_t padding = 0;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x9001             STR      R0,[SP, #+4]
   1267          
   1268            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1269            // Since we were able to successfully build a key desc, we know that the key
   1270            // is supported. However, we must also account for non-word-aligned keys
   1271            uint8_t temp_pub_buffer[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
   1272            uint8_t temp_priv_buffer[SLI_SE_MAX_PADDED_KEY_PAIR_SIZE] = { 0 };
   1273            size_t priv_key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
   1274            if (PSA_KEY_TYPE_IS_ECC(psa_get_key_type(attributes))) {
   1275              padding = sli_se_get_padding(PSA_BITS_TO_BYTES(psa_get_key_bits(attributes)));
   1276            }
   1277            if (padding > 0) {
   1278              if (priv_key_desc.storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   1279                // We must only fix the padding for plaintext private keys. Opaque padding
   1280                // is already handled in import_key
   1281                if (key_buffer_size < priv_key_size) {
   1282                  return PSA_ERROR_INVALID_ARGUMENT;
   1283                }
   1284                sli_se_pad_big_endian(temp_priv_buffer, key_buffer, priv_key_size);
   1285                sli_se_key_descriptor_set_plaintext(&priv_key_desc,
   1286                                                    temp_priv_buffer,
   1287                                                    sizeof(temp_priv_buffer));
   1288              }
   1289              // Point the key desc to the temp buffer
   1290              sli_se_key_descriptor_set_plaintext(&pub_key_desc,
   1291                                                  temp_pub_buffer,
   1292                                                  sizeof(temp_pub_buffer));
   1293            } else
   1294            #endif   // SLI_SE_KEY_PADDING_REQUIRED
   1295          
   1296            {
   1297              // Account for format byte where applicable
   1298              sli_se_key_descriptor_set_plaintext(&pub_key_desc,
   1299                                                  data + prepend_format_byte,
   1300                                                  data_size - prepend_format_byte);
   \       0x62   0xEBB6 0x0209      SUBS     R2,R6,R9
   \       0x66   0xEB05 0x0109      ADD      R1,R5,R9
   \       0x6A   0xA802             ADD      R0,SP,#+8
   \       0x6C   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
   1301            }
   1302          
   1303            // Clear non exportable and private key flags from the public key desc,
   1304            // And set the public flag
   1305            pub_key_desc.flags &= ~(SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY
   1306                                    | SL_SE_KEY_FLAG_NON_EXPORTABLE);
   \       0x70   0x9904             LDR      R1,[SP, #+16]
   \       0x72   0x.... 0x....      LDR.W    R0,??DataTable8_8
   \       0x76   0x4001             ANDS     R1,R0,R1
   \       0x78   0x9104             STR      R1,[SP, #+16]
   1307            pub_key_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \       0x7A   0x9804             LDR      R0,[SP, #+16]
   \       0x7C   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0x80   0x9004             STR      R0,[SP, #+16]
   1308            uint32_t storage_size = 0;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x9000             STR      R0,[SP, #+0]
   1309            sl_status_t sl_status =
   1310              sli_key_get_storage_size(&pub_key_desc, &storage_size);
   \       0x86   0x4669             MOV      R1,SP
   \       0x88   0xA802             ADD      R0,SP,#+8
   \       0x8A   0x.... 0x....      BL       sli_key_get_storage_size
   \       0x8E   0x4682             MOV      R10,R0
   1311            if (sl_status != SL_STATUS_OK) {
   \       0x90   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x94   0xD002             BEQ.N    ??sli_se_driver_export_public_key_4
   1312              return PSA_ERROR_HARDWARE_FAILURE;
   \       0x96   0xF07F 0x0092      MVNS     R0,#+146
   \       0x9A   0xE047             B.N      ??sli_se_driver_export_public_key_2
   1313            }
   1314            // We must fit entire output key + possibly a format byte
   1315            // We don't have to fit the padding bytes into the data buffer.
   1316            storage_size = storage_size + prepend_format_byte - (2 * padding);
   \                     ??sli_se_driver_export_public_key_4: (+1)
   \       0x9C   0x9900             LDR      R1,[SP, #+0]
   \       0x9E   0xEB19 0x0101      ADDS     R1,R9,R1
   \       0xA2   0x9A01             LDR      R2,[SP, #+4]
   \       0xA4   0xF07F 0x0001      MVNS     R0,#+1
   \       0xA8   0xFB00 0x1102      MLA      R1,R0,R2,R1
   \       0xAC   0x9100             STR      R1,[SP, #+0]
   1317            if (data_size < storage_size) {
   \       0xAE   0x9800             LDR      R0,[SP, #+0]
   \       0xB0   0x4286             CMP      R6,R0
   \       0xB2   0xD202             BCS.N    ??sli_se_driver_export_public_key_5
   1318              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0xB4   0xF07F 0x0089      MVNS     R0,#+137
   \       0xB8   0xE038             B.N      ??sli_se_driver_export_public_key_2
   1319            }
   1320          
   1321            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_driver_export_public_key_5: (+1)
   \       0xBA   0xA80A             ADD      R0,SP,#+40
   \       0xBC   0x2124             MOVS     R1,#+36
   \       0xBE   0x.... 0x....      BL       __aeabi_memclr4
   1322            sl_status = sl_se_init_command_context(&cmd_ctx);
   \       0xC2   0xA80A             ADD      R0,SP,#+40
   \       0xC4   0x.... 0x....      BL       sl_se_init_command_context
   \       0xC8   0x4683             MOV      R11,R0
   1323            if (sl_status != SL_STATUS_OK) {
   \       0xCA   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xCE   0xD002             BEQ.N    ??sli_se_driver_export_public_key_6
   1324              return PSA_ERROR_HARDWARE_FAILURE;
   \       0xD0   0xF07F 0x0092      MVNS     R0,#+146
   \       0xD4   0xE02A             B.N      ??sli_se_driver_export_public_key_2
   1325            }
   1326          
   1327            #if defined(SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED)
   1328            psa_status = sli_se_check_eddsa_errata(attributes, &cmd_ctx);
   1329            if (psa_status != PSA_SUCCESS) {
   1330              return psa_status;
   1331            }
   1332            #endif   // SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED
   1333          
   1334            sl_status = sl_se_export_public_key(&cmd_ctx, &priv_key_desc, &pub_key_desc);
   \                     ??sli_se_driver_export_public_key_6: (+1)
   \       0xD6   0xAA02             ADD      R2,SP,#+8
   \       0xD8   0xA913             ADD      R1,SP,#+76
   \       0xDA   0xA80A             ADD      R0,SP,#+40
   \       0xDC   0x.... 0x....      BL       sl_se_export_public_key
   \       0xE0   0x4682             MOV      R10,R0
   1335            if (sl_status == SL_STATUS_FAIL) {
   \       0xE2   0xF1BA 0x0F01      CMP      R10,#+1
   \       0xE6   0xD102             BNE.N    ??sli_se_driver_export_public_key_7
   1336              // This specific code maps to 'does not exist' for builtin keys
   1337              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   \       0xE8   0xF07F 0x0B8B      MVNS     R11,#+139
   \       0xEC   0xE014             B.N      ??sli_se_driver_export_public_key_8
   1338            } else if (sl_status != SL_STATUS_OK) {
   \                     ??sli_se_driver_export_public_key_7: (+1)
   \       0xEE   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xF2   0xD008             BEQ.N    ??sli_se_driver_export_public_key_9
   1339              if (sl_status == SL_STATUS_COMMAND_IS_INVALID) {
   \       0xF4   0xF1BA 0x0F48      CMP      R10,#+72
   \       0xF8   0xD102             BNE.N    ??sli_se_driver_export_public_key_10
   1340                // This error will be returned if the key type isn't supported.
   1341                psa_status = PSA_ERROR_NOT_SUPPORTED;
   \       0xFA   0xF07F 0x0B85      MVNS     R11,#+133
   \       0xFE   0xE00B             B.N      ??sli_se_driver_export_public_key_8
   1342              } else {
   1343                psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_export_public_key_10: (+1)
   \      0x100   0xF07F 0x0B92      MVNS     R11,#+146
   \      0x104   0xE008             B.N      ??sli_se_driver_export_public_key_8
   1344              }
   1345            } else {
   1346              psa_status = PSA_SUCCESS;
   \                     ??sli_se_driver_export_public_key_9: (+1)
   \      0x106   0xF05F 0x0B00      MOVS     R11,#+0
   1347          
   1348              #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1349              if (padding > 0) {
   1350                // Now it is time to copy the actual ket from the temp buffer to the
   1351                // output buffer. Write to an offset if applicable, to account for the
   1352                // format byte
   1353                sli_se_unpad_curve_point(temp_pub_buffer,
   1354                                         data + prepend_format_byte,
   1355                                         (storage_size - prepend_format_byte) / 2);
   1356                sli_psa_zeroize(temp_priv_buffer, priv_key_size);
   1357              }
   1358              #endif   // SLI_SE_KEY_PADDING_REQUIRED
   1359          
   1360              // Write the uncompressed format byte and actual data length
   1361              if (prepend_format_byte == 1) {
   \      0x10A   0xF1B9 0x0F01      CMP      R9,#+1
   \      0x10E   0xD101             BNE.N    ??sli_se_driver_export_public_key_11
   1362                *data = 0x04;
   \      0x110   0x2004             MOVS     R0,#+4
   \      0x112   0x7028             STRB     R0,[R5, #+0]
   1363              }
   1364              *data_length = storage_size;
   \                     ??sli_se_driver_export_public_key_11: (+1)
   \      0x114   0x9800             LDR      R0,[SP, #+0]
   \      0x116   0x6038             STR      R0,[R7, #+0]
   1365            }
   1366          
   1367            // Cleanup
   1368            sl_status = sl_se_deinit_command_context(&cmd_ctx);
   \                     ??sli_se_driver_export_public_key_8: (+1)
   \      0x118   0xA80A             ADD      R0,SP,#+40
   \      0x11A   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x11E   0x0001             MOVS     R1,R0
   1369            if (sl_status != SL_STATUS_OK) {
   \      0x120   0x2900             CMP      R1,#+0
   \      0x122   0xD002             BEQ.N    ??sli_se_driver_export_public_key_12
   1370              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x124   0xF07F 0x0092      MVNS     R0,#+146
   \      0x128   0xE000             B.N      ??sli_se_driver_export_public_key_2
   1371            }
   1372            return psa_status;
   \                     ??sli_se_driver_export_public_key_12: (+1)
   \      0x12A   0x4658             MOV      R0,R11
   \                     ??sli_se_driver_export_public_key_2: (+1)
   \      0x12C   0xB01D             ADD      SP,SP,#+116
   \      0x12E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1373          
   1374            #else // SLI_PSA_DRIVER_FEATURE_ECC
   1375          
   1376            (void) attributes;
   1377            (void) key_buffer;
   1378            (void) key_buffer_size;
   1379            (void) data;
   1380            (void) data_size;
   1381            (void) data_length;
   1382          
   1383            return PSA_ERROR_NOT_SUPPORTED;
   1384          
   1385            #endif // SLI_PSA_DRIVER_FEATURE_ECC
   1386          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
   1387          
   1388          // -------------------------------------
   1389          // Opaque driver entry points
   1390          

   \                                 In section .text, align 2, keep-with-next
   1391          psa_status_t sli_se_opaque_generate_key(const psa_key_attributes_t *attributes,
   1392                                                  uint8_t *key_buffer,
   1393                                                  size_t key_buffer_size,
   1394                                                  size_t *key_buffer_length)
   1395          {
   \                     sli_se_opaque_generate_key: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001E             MOVS     R6,R3
   1396            return sli_se_driver_generate_key(attributes,
   1397                                              key_buffer,
   1398                                              key_buffer_size,
   1399                                              key_buffer_length);
   \        0xA   0x0033             MOVS     R3,R6
   \        0xC   0x002A             MOVS     R2,R5
   \        0xE   0x0021             MOVS     R1,R4
   \       0x10   0x0038             MOVS     R0,R7
   \       0x12   0x.... 0x....      BL       sli_se_driver_generate_key
   \       0x16   0xBDF2             POP      {R1,R4-R7,PC}
   1400          }
   1401          

   \                                 In section .text, align 2, keep-with-next
   1402          psa_status_t sli_se_opaque_export_public_key(
   1403            const psa_key_attributes_t *attributes,
   1404            const uint8_t *key_buffer,
   1405            size_t key_buffer_size,
   1406            uint8_t *data,
   1407            size_t data_size,
   1408            size_t *data_length)
   1409          {
   \                     sli_se_opaque_export_public_key: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   1410            return sli_se_driver_export_public_key(attributes,
   1411                                                   key_buffer,
   1412                                                   key_buffer_size,
   1413                                                   data,
   1414                                                   data_size,
   1415                                                   data_length);
   \        0xA   0x9809             LDR      R0,[SP, #+36]
   \        0xC   0x9001             STR      R0,[SP, #+4]
   \        0xE   0x9808             LDR      R0,[SP, #+32]
   \       0x10   0x9000             STR      R0,[SP, #+0]
   \       0x12   0x003B             MOVS     R3,R7
   \       0x14   0x0032             MOVS     R2,R6
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       sli_se_driver_export_public_key
   \       0x1E   0xBDFE             POP      {R1-R7,PC}
   1416          }
   1417          
   1418          #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
   1419          

   \                                 In section .text, align 2, keep-with-next
   1420          psa_status_t sli_se_opaque_copy_key(const psa_key_attributes_t *attributes,
   1421                                              const uint8_t *source_key,
   1422                                              size_t source_key_length,
   1423                                              uint8_t *target_key_buffer,
   1424                                              size_t target_key_buffer_size,
   1425                                              size_t *target_key_buffer_length)
   1426          {
   \                     sli_se_opaque_copy_key: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1427            size_t bits = 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9003             STR      R0,[SP, #+12]
   1428            return sli_se_opaque_import_key(attributes,
   1429                                            source_key,
   1430                                            source_key_length,
   1431                                            target_key_buffer,
   1432                                            target_key_buffer_size,
   1433                                            target_key_buffer_length,
   1434                                            &bits);
   \       0x10   0xA803             ADD      R0,SP,#+12
   \       0x12   0x9002             STR      R0,[SP, #+8]
   \       0x14   0x980B             LDR      R0,[SP, #+44]
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x980A             LDR      R0,[SP, #+40]
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x003B             MOVS     R3,R7
   \       0x1E   0x0032             MOVS     R2,R6
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       sli_se_opaque_import_key
   \       0x28   0xB005             ADD      SP,SP,#+20
   \       0x2A   0xBDF0             POP      {R4-R7,PC}
   1435          }
   1436          

   \                                 In section .text, align 2, keep-with-next
   1437          psa_status_t sli_se_opaque_import_key(const psa_key_attributes_t *attributes,
   1438                                                const uint8_t *data,
   1439                                                size_t data_length,
   1440                                                uint8_t *key_buffer,
   1441                                                size_t key_buffer_size,
   1442                                                size_t *key_buffer_length,
   1443                                                size_t *bits)
   1444          {
   \                     sli_se_opaque_import_key: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB09D             SUB      SP,SP,#+116
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x9F2A             LDR      R7,[SP, #+168]
   1445            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xE   0xF07F 0x0896      MVNS     R8,#+150
   1446          
   1447            if (attributes == NULL
   1448                || key_buffer == NULL
   1449                || key_buffer_size == 0
   1450                || data == NULL
   1451                || data_length == 0
   1452                || key_buffer_length == NULL
   1453                || bits == NULL) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD00E             BEQ.N    ??sli_se_opaque_import_key_0
   \       0x16   0x981E             LDR      R0,[SP, #+120]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD00B             BEQ.N    ??sli_se_opaque_import_key_0
   \       0x1C   0x9828             LDR      R0,[SP, #+160]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD008             BEQ.N    ??sli_se_opaque_import_key_0
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD006             BEQ.N    ??sli_se_opaque_import_key_0
   \       0x26   0x2E00             CMP      R6,#+0
   \       0x28   0xD004             BEQ.N    ??sli_se_opaque_import_key_0
   \       0x2A   0x9829             LDR      R0,[SP, #+164]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD001             BEQ.N    ??sli_se_opaque_import_key_0
   \       0x30   0x2F00             CMP      R7,#+0
   \       0x32   0xD102             BNE.N    ??sli_se_opaque_import_key_1
   1454              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_opaque_import_key_0: (+1)
   \       0x34   0xF07F 0x0086      MVNS     R0,#+134
   \       0x38   0xE0AF             B.N      ??sli_se_opaque_import_key_2
   1455            }
   1456            *key_buffer_length = 0;
   \                     ??sli_se_opaque_import_key_1: (+1)
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x9829             LDR      R0,[SP, #+164]
   \       0x3E   0x6001             STR      R1,[R0, #+0]
   1457          
   1458            psa_key_type_t key_type = psa_get_key_type(attributes);
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x.... 0x....      BL       psa_get_key_type
   \       0x46   0x4681             MOV      R9,R0
   1459          
   1460            // Store bits value for imported key
   1461            *bits = 8 * data_length;
   \       0x48   0x00F0             LSLS     R0,R6,#+3
   \       0x4A   0x6038             STR      R0,[R7, #+0]
   1462          
   1463            switch (PSA_KEY_TYPE_ECC_GET_FAMILY(key_type)) {
   \       0x4C   0x....             LDR.N    R0,??DataTable7
   \       0x4E   0x4649             MOV      R1,R9
   \       0x50   0xB289             UXTH     R1,R1
   \       0x52   0x4001             ANDS     R1,R0,R1
   \       0x54   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x58   0xD101             BNE.N    ??sli_se_opaque_import_key_3
   \       0x5A   0x4649             MOV      R1,R9
   \       0x5C   0xE000             B.N      ??sli_se_opaque_import_key_4
   \                     ??sli_se_opaque_import_key_3: (+1)
   \       0x5E   0x2100             MOVS     R1,#+0
   \                     ??sli_se_opaque_import_key_4: (+1)
   \       0x60   0xB2C9             UXTB     R1,R1
   \       0x62   0x2912             CMP      R1,#+18
   \       0x64   0xD114             BNE.N    ??sli_se_opaque_import_key_5
   1464              #if defined(SLI_PSA_DRIVER_FEATURE_SECPR1)
   1465              case PSA_ECC_FAMILY_SECP_R1:
   1466                if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {
   \       0x66   0x4649             MOV      R1,R9
   \       0x68   0xB289             UXTH     R1,R1
   \       0x6A   0xF031 0x01FF      BICS     R1,R1,#0xFF
   \       0x6E   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x72   0xD105             BNE.N    ??sli_se_opaque_import_key_6
   1467                  *bits -= 8;
   \       0x74   0x6839             LDR      R1,[R7, #+0]
   \       0x76   0x3908             SUBS     R1,R1,#+8
   \       0x78   0x6039             STR      R1,[R7, #+0]
   1468                  *bits /= 2;
   \       0x7A   0x6839             LDR      R1,[R7, #+0]
   \       0x7C   0x0849             LSRS     R1,R1,#+1
   \       0x7E   0x6039             STR      R1,[R7, #+0]
   1469                }
   1470                if (*bits == PSA_BITS_TO_BYTES(521) * 8) {
   \                     ??sli_se_opaque_import_key_6: (+1)
   \       0x80   0x6839             LDR      R1,[R7, #+0]
   \       0x82   0xF5B1 0x7F04      CMP      R1,#+528
   \       0x86   0xD102             BNE.N    ??sli_se_opaque_import_key_7
   1471                  *bits = 521;
   \       0x88   0xF240 0x2109      MOVW     R1,#+521
   \       0x8C   0x6039             STR      R1,[R7, #+0]
   1472                }
   1473                break;
   \                     ??sli_se_opaque_import_key_7: (+1)
   \       0x8E   0xE7FF             B.N      ??sli_se_opaque_import_key_8
   1474              #endif // SLI_PSA_DRIVER_FEATURE_SECPR1
   1475          
   1476              #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY) || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
   1477              case PSA_ECC_FAMILY_MONTGOMERY:
   1478              case PSA_ECC_FAMILY_TWISTED_EDWARDS:
   1479                if (data_length == 32) {
   1480                  *bits = 255;
   1481                }
   1482                break;
   1483              #endif // SLI_PSA_DRIVER_FEATURE_MONTGOMERY || SLI_PSA_DRIVER_FEATURE_EDWARDS
   1484          
   1485              default:
   1486                break;
   1487            }
   1488          
   1489            size_t offset = 0;
   \                     ??sli_se_opaque_import_key_5: (+1)
   \                     ??sli_se_opaque_import_key_8: (+1)
   \       0x90   0x2100             MOVS     R1,#+0
   \       0x92   0x9103             STR      R1,[SP, #+12]
   1490            size_t padding = 0;
   \       0x94   0x2100             MOVS     R1,#+0
   \       0x96   0x9102             STR      R1,[SP, #+8]
   1491            size_t key_size = 0;
   \       0x98   0x2100             MOVS     R1,#+0
   \       0x9A   0x9101             STR      R1,[SP, #+4]
   1492          
   1493            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1494            if (PSA_KEY_TYPE_IS_ECC(key_type)) {
   \       0x9C   0x4649             MOV      R1,R9
   \       0x9E   0xB289             UXTH     R1,R1
   \       0xA0   0x4008             ANDS     R0,R0,R1
   \       0xA2   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0xA6   0xD118             BNE.N    ??sli_se_opaque_import_key_9
   1495              // Validate key and get size.
   1496              psa_status = sli_se_driver_validate_ecc_key(attributes,
   1497                                                          data,
   1498                                                          data_length,
   1499                                                          &key_size);
   \       0xA8   0xAB01             ADD      R3,SP,#+4
   \       0xAA   0x0032             MOVS     R2,R6
   \       0xAC   0x0029             MOVS     R1,R5
   \       0xAE   0x0020             MOVS     R0,R4
   \       0xB0   0x.... 0x....      BL       sli_se_driver_validate_ecc_key
   \       0xB4   0x4680             MOV      R8,R0
   1500              if (psa_status != PSA_SUCCESS) {
   \       0xB6   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xBA   0xD001             BEQ.N    ??sli_se_opaque_import_key_10
   1501                return psa_status;
   \       0xBC   0x4640             MOV      R0,R8
   \       0xBE   0xE06C             B.N      ??sli_se_opaque_import_key_2
   1502              }
   1503              key_size = PSA_BITS_TO_BYTES(key_size);
   \                     ??sli_se_opaque_import_key_10: (+1)
   \       0xC0   0x9801             LDR      R0,[SP, #+4]
   \       0xC2   0x1DC0             ADDS     R0,R0,#+7
   \       0xC4   0x08C0             LSRS     R0,R0,#+3
   \       0xC6   0x9001             STR      R0,[SP, #+4]
   1504              if (sli_se_has_format_byte(key_type)) {
   \       0xC8   0x4648             MOV      R0,R9
   \       0xCA   0xB280             UXTH     R0,R0
   \       0xCC   0x.... 0x....      BL       sli_se_has_format_byte
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xD003             BEQ.N    ??sli_se_opaque_import_key_11
   1505                data_length -= 1;
   \       0xD4   0x1E76             SUBS     R6,R6,#+1
   1506                data += 1;
   \       0xD6   0x1C6D             ADDS     R5,R5,#+1
   \       0xD8   0xE000             B.N      ??sli_se_opaque_import_key_11
   1507              }
   1508          
   1509              #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1510              if (PSA_KEY_TYPE_ECC_GET_FAMILY(key_type) == PSA_ECC_FAMILY_SECP_R1) {
   1511                // We must add some padding if offset is nonzero
   1512                offset = sli_se_get_padding(key_size);
   1513              }
   1514              #endif   // SLI_SE_KEY_PADDING_REQUIRED
   1515            } else
   1516            #endif // SLI_PSA_DRIVER_FEATURE_ECC
   1517          
   1518            {
   1519              key_size = data_length;
   \                     ??sli_se_opaque_import_key_9: (+1)
   \       0xDA   0x9601             STR      R6,[SP, #+4]
   1520            }
   1521          
   1522            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1523            // Size must at least fit max ECC key size plus padding
   1524            uint8_t temp_buffer[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
   1525            #endif
   1526          
   1527            // Create a key desc that will represent the wrapped key
   1528            sl_se_key_descriptor_t imported_key_desc = { 0 };
   \                     ??sli_se_opaque_import_key_11: (+1)
   \       0xDC   0xA815             ADD      R0,SP,#+84
   \       0xDE   0x2120             MOVS     R1,#+32
   \       0xE0   0x.... 0x....      BL       __aeabi_memclr4
   1529            psa_status =
   1530              sli_se_key_desc_from_psa_attributes(attributes,
   1531                                                  key_size,
   1532                                                  &imported_key_desc);
   \       0xE4   0xAA15             ADD      R2,SP,#+84
   \       0xE6   0x9901             LDR      R1,[SP, #+4]
   \       0xE8   0x0020             MOVS     R0,R4
   \       0xEA   0x.... 0x....      BL       sli_se_key_desc_from_psa_attributes
   \       0xEE   0x4682             MOV      R10,R0
   1533            if (psa_status != PSA_SUCCESS) {
   \       0xF0   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xF4   0xD001             BEQ.N    ??sli_se_opaque_import_key_12
   1534              return psa_status;
   \       0xF6   0x4650             MOV      R0,R10
   \       0xF8   0xE04F             B.N      ??sli_se_opaque_import_key_2
   1535            }
   1536            // Create a key desc representing the plaintext input key
   1537            sl_se_key_descriptor_t plaintext_key_desc = imported_key_desc;
   \                     ??sli_se_opaque_import_key_12: (+1)
   \       0xFA   0xA80D             ADD      R0,SP,#+52
   \       0xFC   0xA915             ADD      R1,SP,#+84
   \       0xFE   0x2220             MOVS     R2,#+32
   \      0x100   0x.... 0x....      BL       __aeabi_memcpy4
   1538          
   1539            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1540            if (offset == 0) {
   1541              sli_se_key_descriptor_set_plaintext(&plaintext_key_desc, data, data_length);
   1542            } else {
   1543              // We must account for the offset.
   1544              // Write the key data to offset position in temp buffer
   1545              if (sizeof(temp_buffer) < data_length + 2 * offset) {
   1546                return PSA_ERROR_INVALID_ARGUMENT;
   1547              }
   1548          
   1549              #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1550              if (PSA_KEY_TYPE_ECC_GET_FAMILY(key_type) == PSA_ECC_FAMILY_SECP_R1) {
   1551                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(key_type)) {
   1552                  sli_se_pad_big_endian(temp_buffer, data, key_size);
   1553                  padding = offset;
   1554                } else {
   1555                  // Must be public key
   1556                  sli_se_pad_curve_point(temp_buffer, data, key_size);
   1557                  padding = 2 * offset;
   1558                }
   1559                sli_se_key_descriptor_set_plaintext(&plaintext_key_desc,
   1560                                                    temp_buffer,
   1561                                                    data_length + padding);
   1562              } else
   1563              #endif   // SLI_PSA_DRIVER_FEATURE_ECC
   1564              {
   1565                return PSA_ERROR_CORRUPTION_DETECTED;
   1566              }
   1567            }
   1568            #else // SLI_SE_KEY_PADDING_REQUIRED
   1569            (void)offset;
   1570            sli_se_key_descriptor_set_plaintext(&plaintext_key_desc, data, data_length);
   \      0x104   0x0032             MOVS     R2,R6
   \      0x106   0x0029             MOVS     R1,R5
   \      0x108   0xA80D             ADD      R0,SP,#+52
   \      0x10A   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
   1571            #endif // SLI_SE_KEY_PADDING_REQUIRED
   1572          
   1573            sl_se_command_context_t cmd_ctx = SL_SE_COMMAND_CONTEXT_INIT;
   \      0x10E   0xA804             ADD      R0,SP,#+16
   \      0x110   0x2124             MOVS     R1,#+36
   \      0x112   0x.... 0x....      BL       __aeabi_memclr4
   1574            sl_status_t sl_status = SL_STATUS_OK;
   \      0x116   0xF05F 0x0800      MOVS     R8,#+0
   1575            // Set location specific properties for the output key buffer
   1576            psa_status = sli_se_set_key_desc_output(attributes,
   1577                                                    key_buffer,
   1578                                                    key_buffer_size,
   1579                                                    data_length + padding,
   1580                                                    &imported_key_desc);
   \      0x11A   0xA815             ADD      R0,SP,#+84
   \      0x11C   0x9000             STR      R0,[SP, #+0]
   \      0x11E   0x9B02             LDR      R3,[SP, #+8]
   \      0x120   0x199B             ADDS     R3,R3,R6
   \      0x122   0x9A28             LDR      R2,[SP, #+160]
   \      0x124   0x991E             LDR      R1,[SP, #+120]
   \      0x126   0x0020             MOVS     R0,R4
   \      0x128   0x.... 0x....      BL       sli_se_set_key_desc_output
   \      0x12C   0x4683             MOV      R11,R0
   1581            if (psa_status != PSA_SUCCESS) {
   \      0x12E   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x132   0xD131             BNE.N    ??sli_se_opaque_import_key_13
   1582              goto exit;
   1583            }
   1584          
   1585            sl_status = sl_se_init_command_context(&cmd_ctx);
   \                     ??sli_se_opaque_import_key_14: (+1)
   \      0x134   0xA804             ADD      R0,SP,#+16
   \      0x136   0x.... 0x....      BL       sl_se_init_command_context
   \      0x13A   0x4680             MOV      R8,R0
   1586            if (sl_status != SL_STATUS_OK) {
   \      0x13C   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x140   0xD003             BEQ.N    ??sli_se_opaque_import_key_15
   1587              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \      0x142   0xF07F 0x0092      MVNS     R0,#+146
   \      0x146   0x4683             MOV      R11,R0
   1588              goto exit;
   \      0x148   0xE026             B.N      ??sli_se_opaque_import_key_13
   1589            }
   1590          
   1591            // Call SE manager to import the key
   1592            sl_status = sl_se_import_key(&cmd_ctx,
   1593                                         &plaintext_key_desc,
   1594                                         &imported_key_desc);
   \                     ??sli_se_opaque_import_key_15: (+1)
   \      0x14A   0xAA15             ADD      R2,SP,#+84
   \      0x14C   0xA90D             ADD      R1,SP,#+52
   \      0x14E   0xA804             ADD      R0,SP,#+16
   \      0x150   0x.... 0x....      BL       sl_se_import_key
   \      0x154   0x4680             MOV      R8,R0
   1595            if (sl_status != SL_STATUS_OK) {
   \      0x156   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x15A   0xD003             BEQ.N    ??sli_se_opaque_import_key_16
   1596              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \      0x15C   0xF07F 0x0092      MVNS     R0,#+146
   \      0x160   0x4683             MOV      R11,R0
   \      0x162   0xE00F             B.N      ??sli_se_opaque_import_key_17
   1597            } else {
   1598              // Add the key desc parameters to the output array
   1599              psa_status = store_key_desc_in_context(&imported_key_desc,
   1600                                                     key_buffer,
   1601                                                     key_buffer_size);
   \                     ??sli_se_opaque_import_key_16: (+1)
   \      0x164   0x9A28             LDR      R2,[SP, #+160]
   \      0x166   0x991E             LDR      R1,[SP, #+120]
   \      0x168   0xA815             ADD      R0,SP,#+84
   \      0x16A   0x.... 0x....      BL       store_key_desc_in_context
   \      0x16E   0x4683             MOV      R11,R0
   1602              if (psa_status != PSA_SUCCESS) {
   \      0x170   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x174   0xD110             BNE.N    ??sli_se_opaque_import_key_13
   1603                goto exit;
   1604              }
   1605          
   1606              psa_status = set_key_buffer_length(attributes,
   1607                                                 data_length + padding,
   1608                                                 key_buffer_length);
   \                     ??sli_se_opaque_import_key_18: (+1)
   \      0x176   0x9A29             LDR      R2,[SP, #+164]
   \      0x178   0x9902             LDR      R1,[SP, #+8]
   \      0x17A   0x1989             ADDS     R1,R1,R6
   \      0x17C   0x0020             MOVS     R0,R4
   \      0x17E   0x.... 0x....      BL       set_key_buffer_length
   \      0x182   0x4683             MOV      R11,R0
   1609            }
   1610          
   1611            // Cleanup
   1612            sl_status = sl_se_deinit_command_context(&cmd_ctx);
   \                     ??sli_se_opaque_import_key_17: (+1)
   \      0x184   0xA804             ADD      R0,SP,#+16
   \      0x186   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x18A   0x4680             MOV      R8,R0
   1613            if (sl_status != SL_STATUS_OK) {
   \      0x18C   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x190   0xD002             BEQ.N    ??sli_se_opaque_import_key_13
   1614              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \      0x192   0xF07F 0x0092      MVNS     R0,#+146
   \      0x196   0x4683             MOV      R11,R0
   1615            }
   1616          
   1617            exit:
   1618          
   1619            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1620            sli_psa_zeroize(temp_buffer, sizeof(temp_buffer));
   1621            #endif
   1622          
   1623            return psa_status;
   \                     ??sli_se_opaque_import_key_13: (+1)
   \      0x198   0x4658             MOV      R0,R11
   \                     ??sli_se_opaque_import_key_2: (+1)
   \      0x19A   0xB01F             ADD      SP,SP,#+124
   \      0x19C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1624          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0x0, 0x0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x00               DC8 0
   \       0x21                      DS8 3
   1625          

   \                                 In section .text, align 2, keep-with-next
   1626          psa_status_t sli_se_opaque_export_key(const psa_key_attributes_t *attributes,
   1627                                                const uint8_t *key_buffer,
   1628                                                size_t key_buffer_size,
   1629                                                uint8_t *data,
   1630                                                size_t data_size,
   1631                                                size_t *data_length)
   1632          {
   \                     sli_se_opaque_export_key: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB09D             SUB      SP,SP,#+116
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x001D             MOVS     R5,R3
   \        0xC   0x9E28             LDR      R6,[SP, #+160]
   \        0xE   0x9F29             LDR      R7,[SP, #+164]
   1633            if (attributes == NULL
   1634                || key_buffer == NULL
   1635                || key_buffer_size == 0
   1636                || data == NULL
   1637                || data_size == 0
   1638                || data_length == NULL) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD00B             BEQ.N    ??sli_se_opaque_export_key_0
   \       0x14   0x981E             LDR      R0,[SP, #+120]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD008             BEQ.N    ??sli_se_opaque_export_key_0
   \       0x1A   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x1E   0xD005             BEQ.N    ??sli_se_opaque_export_key_0
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD003             BEQ.N    ??sli_se_opaque_export_key_0
   \       0x24   0x2E00             CMP      R6,#+0
   \       0x26   0xD001             BEQ.N    ??sli_se_opaque_export_key_0
   \       0x28   0x2F00             CMP      R7,#+0
   \       0x2A   0xD102             BNE.N    ??sli_se_opaque_export_key_1
   1639              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_opaque_export_key_0: (+1)
   \       0x2C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x30   0xE078             B.N      ??sli_se_opaque_export_key_2
   1640            }
   1641            // Check that key can be exported
   1642            if (!(psa_get_key_usage_flags(attributes) & PSA_KEY_USAGE_EXPORT)) {
   \                     ??sli_se_opaque_export_key_1: (+1)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       psa_get_key_usage_flags
   \       0x38   0x07C0             LSLS     R0,R0,#+31
   \       0x3A   0xD402             BMI.N    ??sli_se_opaque_export_key_3
   1643              return PSA_ERROR_NOT_PERMITTED;
   \       0x3C   0xF07F 0x0084      MVNS     R0,#+132
   \       0x40   0xE070             B.N      ??sli_se_opaque_export_key_2
   1644            }
   1645          
   1646            sl_se_key_descriptor_t imported_key = { 0 };
   \                     ??sli_se_opaque_export_key_3: (+1)
   \       0x42   0xA815             ADD      R0,SP,#+84
   \       0x44   0x2120             MOVS     R1,#+32
   \       0x46   0x.... 0x....      BL       __aeabi_memclr4
   1647            psa_status_t psa_status = sli_se_key_desc_from_input(attributes,
   1648                                                                 key_buffer,
   1649                                                                 key_buffer_size,
   1650                                                                 &imported_key);
   \       0x4A   0xAB15             ADD      R3,SP,#+84
   \       0x4C   0x4652             MOV      R2,R10
   \       0x4E   0x991E             LDR      R1,[SP, #+120]
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x56   0x4680             MOV      R8,R0
   1651            if (psa_status != PSA_SUCCESS) {
   \       0x58   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x5C   0xD001             BEQ.N    ??sli_se_opaque_export_key_4
   1652              return psa_status;
   \       0x5E   0x4640             MOV      R0,R8
   \       0x60   0xE060             B.N      ??sli_se_opaque_export_key_2
   1653            }
   1654          
   1655            // Create a plaintext key for the output
   1656            sl_se_key_descriptor_t plaintext_key = imported_key;
   \                     ??sli_se_opaque_export_key_4: (+1)
   \       0x62   0xA80D             ADD      R0,SP,#+52
   \       0x64   0xA915             ADD      R1,SP,#+84
   \       0x66   0x2220             MOVS     R2,#+32
   \       0x68   0x.... 0x....      BL       __aeabi_memcpy4
   1657            uint32_t storage_size = 0;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   1658            psa_key_type_t key_type = psa_get_key_type(attributes);
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x.... 0x....      BL       psa_get_key_type
   \       0x76   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1659            sl_status_t sl_status = sli_key_get_storage_size(&plaintext_key, &storage_size);
   \       0x7A   0x4669             MOV      R1,SP
   \       0x7C   0xA80D             ADD      R0,SP,#+52
   \       0x7E   0x.... 0x....      BL       sli_key_get_storage_size
   \       0x82   0x9001             STR      R0,[SP, #+4]
   1660            uint32_t prepend_format_byte = sli_se_has_format_byte(key_type);
   \       0x84   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \       0x88   0x.... 0x....      BL       sli_se_has_format_byte
   \       0x8C   0x4681             MOV      R9,R0
   1661            if (prepend_format_byte == 1) {
   \       0x8E   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x92   0xD103             BNE.N    ??sli_se_opaque_export_key_5
   1662              // Make room for the format byte
   1663              *data = 0x04;
   \       0x94   0x2004             MOVS     R0,#+4
   \       0x96   0x7028             STRB     R0,[R5, #+0]
   1664              data += 1;
   \       0x98   0x1C6D             ADDS     R5,R5,#+1
   1665              data_size -= 1;
   \       0x9A   0x1E76             SUBS     R6,R6,#+1
   1666            }
   1667          
   1668            size_t key_bits = psa_get_key_bits(attributes);
   \                     ??sli_se_opaque_export_key_5: (+1)
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x.... 0x....      BL       psa_get_key_bits
   \       0xA2   0x9003             STR      R0,[SP, #+12]
   1669          
   1670            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1671            // We must handle non-word-aligned keys with a temporary buffer
   1672            uint8_t temp_key_buffer[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
   1673            size_t padding = 0;
   1674          
   1675            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1676            size_t key_size = PSA_BITS_TO_BYTES(key_bits);
   1677            if (PSA_KEY_TYPE_IS_ECC(key_type)) {
   1678              padding = sli_se_get_padding(key_size);
   1679            }
   1680            #endif   // SLI_PSA_DRIVER_FEATURE_ECC
   1681          
   1682            if (padding > 0) {
   1683              if (storage_size > sizeof(temp_key_buffer)) {
   1684                return PSA_ERROR_BUFFER_TOO_SMALL;
   1685              }
   1686              sli_se_key_descriptor_set_plaintext(&plaintext_key,
   1687                                                  temp_key_buffer,
   1688                                                  sizeof(temp_key_buffer));
   1689              storage_size -= padding;
   1690              #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1691              if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {
   1692                // Padding must be applied twice for public keys
   1693                storage_size -= padding;
   1694              }
   1695              #endif   // SLI_PSA_DRIVER_FEATURE_ECC
   1696            } else {
   1697              if ((storage_size - imported_key.size) < 4) {
   1698                // SE manager has rounded the storage size up for word-alignment
   1699                storage_size = imported_key.size;
   1700              }
   1701              sli_se_key_descriptor_set_plaintext(&plaintext_key, data, data_size);
   1702            }
   1703            #else // SLI_SE_KEY_PADDING_REQUIRED
   1704            sli_se_key_descriptor_set_plaintext(&plaintext_key, data, data_size);
   \       0xA4   0x0032             MOVS     R2,R6
   \       0xA6   0x0029             MOVS     R1,R5
   \       0xA8   0xA80D             ADD      R0,SP,#+52
   \       0xAA   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
   1705            #endif // SLI_SE_KEY_PADDING_REQUIRED
   1706          
   1707            if (sl_status != SL_STATUS_OK) {
   \       0xAE   0x9801             LDR      R0,[SP, #+4]
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD002             BEQ.N    ??sli_se_opaque_export_key_6
   1708              return PSA_ERROR_HARDWARE_FAILURE;
   \       0xB4   0xF07F 0x0092      MVNS     R0,#+146
   \       0xB8   0xE034             B.N      ??sli_se_opaque_export_key_2
   1709            }
   1710            if (storage_size > data_size) {
   \                     ??sli_se_opaque_export_key_6: (+1)
   \       0xBA   0x9800             LDR      R0,[SP, #+0]
   \       0xBC   0x4286             CMP      R6,R0
   \       0xBE   0xD202             BCS.N    ??sli_se_opaque_export_key_7
   1711              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0xC0   0xF07F 0x0089      MVNS     R0,#+137
   \       0xC4   0xE02E             B.N      ??sli_se_opaque_export_key_2
   1712            }
   1713          
   1714            // Export key
   1715            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_opaque_export_key_7: (+1)
   \       0xC6   0xA804             ADD      R0,SP,#+16
   \       0xC8   0x2124             MOVS     R1,#+36
   \       0xCA   0x.... 0x....      BL       __aeabi_memclr4
   1716            sl_status = sl_se_init_command_context(&cmd_ctx);
   \       0xCE   0xA804             ADD      R0,SP,#+16
   \       0xD0   0x.... 0x....      BL       sl_se_init_command_context
   \       0xD4   0x4683             MOV      R11,R0
   1717            if (sl_status != SL_STATUS_OK) {
   \       0xD6   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xDA   0xD002             BEQ.N    ??sli_se_opaque_export_key_8
   1718              return PSA_ERROR_HARDWARE_FAILURE;
   \       0xDC   0xF07F 0x0092      MVNS     R0,#+146
   \       0xE0   0xE020             B.N      ??sli_se_opaque_export_key_2
   1719            }
   1720            sl_status = sl_se_export_key(&cmd_ctx, &imported_key, &plaintext_key);
   \                     ??sli_se_opaque_export_key_8: (+1)
   \       0xE2   0xAA0D             ADD      R2,SP,#+52
   \       0xE4   0xA915             ADD      R1,SP,#+84
   \       0xE6   0xA804             ADD      R0,SP,#+16
   \       0xE8   0x.... 0x....      BL       sl_se_export_key
   \       0xEC   0x9001             STR      R0,[SP, #+4]
   1721            if (sl_status != SL_STATUS_OK) {
   \       0xEE   0x9801             LDR      R0,[SP, #+4]
   \       0xF0   0x2800             CMP      R0,#+0
   \       0xF2   0xD002             BEQ.N    ??sli_se_opaque_export_key_9
   1722              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \       0xF4   0xF07F 0x0B92      MVNS     R11,#+146
   \       0xF8   0xE00A             B.N      ??sli_se_opaque_export_key_10
   1723            } else {
   1724              psa_status = PSA_SUCCESS;
   \                     ??sli_se_opaque_export_key_9: (+1)
   \       0xFA   0xF05F 0x0B00      MOVS     R11,#+0
   1725          
   1726              #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1727              // Handle padding.
   1728              if (padding > 0) {
   1729                #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1730                // Copy out the padded key
   1731                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(key_type)) {
   1732                  sli_se_unpad_big_endian(temp_key_buffer, data, key_size);
   1733                  sli_psa_zeroize(temp_key_buffer, key_size);
   1734                } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {
   1735                  sli_se_unpad_curve_point(temp_key_buffer, data, key_size);
   1736                } else
   1737                #endif   // SLI_PSA_DRIVER_FEATURE_ECC
   1738                {
   1739                  // This should never happen
   1740                  return PSA_ERROR_BAD_STATE;
   1741                }
   1742              }
   1743              #endif // SLI_SE_KEY_PADDING_REQUIRED
   1744          
   1745              // Apply clamping if this is a Montgomery key.
   1746              clamp_private_key_if_needed(attributes, data, key_bits);
   \       0xFE   0x9A03             LDR      R2,[SP, #+12]
   \      0x100   0x0029             MOVS     R1,R5
   \      0x102   0x0020             MOVS     R0,R4
   \      0x104   0x.... 0x....      BL       clamp_private_key_if_needed
   1747          
   1748              // Successful operation. Set ouput length
   1749              *data_length = storage_size + prepend_format_byte;
   \      0x108   0x9800             LDR      R0,[SP, #+0]
   \      0x10A   0xEB19 0x0000      ADDS     R0,R9,R0
   \      0x10E   0x6038             STR      R0,[R7, #+0]
   1750            }
   1751          
   1752            // Cleanup
   1753            sl_status = sl_se_deinit_command_context(&cmd_ctx);
   \                     ??sli_se_opaque_export_key_10: (+1)
   \      0x110   0xA804             ADD      R0,SP,#+16
   \      0x112   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x116   0x0001             MOVS     R1,R0
   1754            if (sl_status != SL_STATUS_OK) {
   \      0x118   0x2900             CMP      R1,#+0
   \      0x11A   0xD002             BEQ.N    ??sli_se_opaque_export_key_11
   1755              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x11C   0xF07F 0x0092      MVNS     R0,#+146
   \      0x120   0xE000             B.N      ??sli_se_opaque_export_key_2
   1756            }
   1757            return psa_status;
   \                     ??sli_se_opaque_export_key_11: (+1)
   \      0x122   0x4658             MOV      R0,R11
   \                     ??sli_se_opaque_export_key_2: (+1)
   \      0x124   0xB01F             ADD      SP,SP,#+124
   \      0x126   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1758          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
   1759          
   1760          #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
   1761          
   1762          // -------------------------------------
   1763          // Transparent driver entry points
   1764          

   \                                 In section .text, align 2, keep-with-next
   1765          psa_status_t sli_se_transparent_generate_key(
   1766            const psa_key_attributes_t *attributes,
   1767            uint8_t *key_buffer,
   1768            size_t key_buffer_size,
   1769            size_t *key_buffer_length)
   1770          {
   \                     sli_se_transparent_generate_key: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1771            psa_key_type_t type = psa_get_key_type(attributes);
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       psa_get_key_type
   \       0x12   0x4680             MOV      R8,R0
   1772          
   1773            // We don't support generating symmetric keys with transparent drivers;
   1774            // it should be done by the core instead.
   1775            if (PSA_KEY_TYPE_IS_UNSTRUCTURED(type)) {
   \       0x14   0x4640             MOV      R0,R8
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x1C   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x20   0xD006             BEQ.N    ??sli_se_transparent_generate_key_0
   \       0x22   0x4640             MOV      R0,R8
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x2A   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x2E   0xD102             BNE.N    ??sli_se_transparent_generate_key_1
   1776              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_transparent_generate_key_0: (+1)
   \       0x30   0xF07F 0x0085      MVNS     R0,#+133
   \       0x34   0xE005             B.N      ??sli_se_transparent_generate_key_2
   1777            }
   1778          
   1779            return sli_se_driver_generate_key(attributes,
   1780                                              key_buffer,
   1781                                              key_buffer_size,
   1782                                              key_buffer_length);
   \                     ??sli_se_transparent_generate_key_1: (+1)
   \       0x36   0x003B             MOVS     R3,R7
   \       0x38   0x0032             MOVS     R2,R6
   \       0x3A   0x0029             MOVS     R1,R5
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       sli_se_driver_generate_key
   \                     ??sli_se_transparent_generate_key_2: (+1)
   \       0x42   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1783          }
   1784          

   \                                 In section .text, align 2, keep-with-next
   1785          psa_status_t sli_se_transparent_export_public_key(
   1786            const psa_key_attributes_t *attributes,
   1787            const uint8_t *key_buffer,
   1788            size_t key_buffer_size,
   1789            uint8_t *data,
   1790            size_t data_size,
   1791            size_t *data_length)
   1792          {
   \                     sli_se_transparent_export_public_key: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   1793            // If the key is stored transparently and is already a public key,
   1794            // let the core handle it.
   1795            if (PSA_KEY_TYPE_IS_PUBLIC_KEY(psa_get_key_type(attributes))) {
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       psa_get_key_type
   \       0x10   0xF410 0x40E0      ANDS     R0,R0,#0x7000
   \       0x14   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x18   0xD102             BNE.N    ??sli_se_transparent_export_public_key_0
   1796              return PSA_ERROR_NOT_SUPPORTED;
   \       0x1A   0xF07F 0x0085      MVNS     R0,#+133
   \       0x1E   0xE009             B.N      ??sli_se_transparent_export_public_key_1
   1797            }
   1798          
   1799            return sli_se_driver_export_public_key(attributes,
   1800                                                   key_buffer,
   1801                                                   key_buffer_size,
   1802                                                   data,
   1803                                                   data_size,
   1804                                                   data_length);
   \                     ??sli_se_transparent_export_public_key_0: (+1)
   \       0x20   0x9809             LDR      R0,[SP, #+36]
   \       0x22   0x9001             STR      R0,[SP, #+4]
   \       0x24   0x9808             LDR      R0,[SP, #+32]
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0x003B             MOVS     R3,R7
   \       0x2A   0x0032             MOVS     R2,R6
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       sli_se_driver_export_public_key
   \                     ??sli_se_transparent_export_public_key_1: (+1)
   \       0x34   0xBDFE             POP      {R1-R7,PC}
   1805          }
   1806          

   \                                 In section .text, align 2, keep-with-next
   1807          psa_status_t sli_se_transparent_import_key(const psa_key_attributes_t *attributes,
   1808                                                     const uint8_t *data,
   1809                                                     size_t data_length,
   1810                                                     uint8_t *key_buffer,
   1811                                                     size_t key_buffer_size,
   1812                                                     size_t *key_buffer_length,
   1813                                                     size_t *bits)
   1814          {
   \                     sli_se_transparent_import_key: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8034      LDR      R8,[SP, #+52]
   \       0x10   0xF8DD 0x9038      LDR      R9,[SP, #+56]
   1815            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1816          
   1817            // Our driver only handles ECC keys (since they are better done accelerated).
   1818            if (PSA_KEY_TYPE_IS_ECC(psa_get_key_type(attributes))) {
   \       0x14   0x4650             MOV      R0,R10
   \       0x16   0x.... 0x....      BL       psa_get_key_type
   \       0x1A   0x....             LDR.N    R1,??DataTable8_9
   \       0x1C   0x4008             ANDS     R0,R1,R0
   \       0x1E   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0x22   0xD122             BNE.N    ??sli_se_transparent_import_key_0
   1819              psa_status_t status = sli_se_driver_validate_ecc_key(attributes,
   1820                                                                   data,
   1821                                                                   data_length,
   1822                                                                   bits);
   \       0x24   0x464B             MOV      R3,R9
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0x4650             MOV      R0,R10
   \       0x2C   0x.... 0x....      BL       sli_se_driver_validate_ecc_key
   \       0x30   0x0004             MOVS     R4,R0
   1823              if (status != PSA_SUCCESS) {
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD001             BEQ.N    ??sli_se_transparent_import_key_1
   1824                return status;
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0xE019             B.N      ??sli_se_transparent_import_key_2
   1825              }
   1826          
   1827              if ( key_buffer_size < data_length ) {
   \                     ??sli_se_transparent_import_key_1: (+1)
   \       0x3A   0x980C             LDR      R0,[SP, #+48]
   \       0x3C   0x42B0             CMP      R0,R6
   \       0x3E   0xD202             BCS.N    ??sli_se_transparent_import_key_3
   1828                return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x40   0xF07F 0x0089      MVNS     R0,#+137
   \       0x44   0xE013             B.N      ??sli_se_transparent_import_key_2
   1829              }
   1830          
   1831              memcpy(key_buffer, data, data_length);
   \                     ??sli_se_transparent_import_key_3: (+1)
   \       0x46   0x9601             STR      R6,[SP, #+4]
   \       0x48   0x9500             STR      R5,[SP, #+0]
   \       0x4A   0x46BB             MOV      R11,R7
   \       0x4C   0x9A01             LDR      R2,[SP, #+4]
   \       0x4E   0x9900             LDR      R1,[SP, #+0]
   \       0x50   0x4658             MOV      R0,R11
   \       0x52   0x.... 0x....      BL       __aeabi_memcpy
   1832              clamp_private_key_if_needed(attributes, key_buffer, *bits);
   \       0x56   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \       0x5A   0x0039             MOVS     R1,R7
   \       0x5C   0x4650             MOV      R0,R10
   \       0x5E   0x.... 0x....      BL       clamp_private_key_if_needed
   1833              *key_buffer_length = data_length;
   \       0x62   0xF8C8 0x6000      STR      R6,[R8, #+0]
   1834          
   1835              return PSA_SUCCESS;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE001             B.N      ??sli_se_transparent_import_key_2
   1836            }
   1837          
   1838            #else // SLI_PSA_DRIVER_FEATURE_ECC
   1839          
   1840            (void)attributes;
   1841            (void)data;
   1842            (void)data_length;
   1843            (void)key_buffer;
   1844            (void)key_buffer_size;
   1845            (void)key_buffer_length;
   1846            (void)bits;
   1847          
   1848            #endif // SLI_PSA_DRIVER_FEATURE_ECC
   1849          
   1850            return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_transparent_import_key_0: (+1)
   \       0x6A   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??sli_se_transparent_import_key_2: (+1)
   \       0x6E   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1851          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     ecc_p256_n

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x8000'0020        DC32     0x80000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0xFEFF'BFFF        DC32     0xfeffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00
   1852          
   1853          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   clamp_private_key_if_needed
        16   -> psa_get_key_type
       0   psa_get_key_bits
       0   psa_get_key_lifetime
       0   psa_get_key_type
       0   psa_get_key_usage_flags
      24   set_key_buffer_length
        24   -> psa_get_key_lifetime
        24   -> psa_get_key_type
        24   -> sli_se_has_format_byte
      16   sli_psa_validate_ecc_weierstrass_privkey
       0   sli_psa_zeroize
     152   sli_se_driver_export_public_key
       152   -> __aeabi_memclr4
       152   -> __aeabi_memcpy4
       152   -> sl_se_deinit_command_context
       152   -> sl_se_export_public_key
       152   -> sl_se_init_command_context
       152   -> sli_key_get_storage_size
       152   -> sli_se_key_desc_from_input
       152   -> sli_se_key_descriptor_set_plaintext
     112   sli_se_driver_generate_key
       112   -> __aeabi_memclr4
       112   -> clamp_private_key_if_needed
       112   -> psa_get_key_bits
       112   -> psa_get_key_lifetime
       112   -> psa_get_key_type
       112   -> set_key_buffer_length
       112   -> sl_se_deinit_command_context
       112   -> sl_se_generate_key
       112   -> sl_se_init_command_context
       112   -> sli_se_key_desc_from_psa_attributes
       112   -> sli_se_set_key_desc_output
       112   -> store_key_desc_in_context
     312   sli_se_driver_validate_ecc_key
       312   -> __aeabi_memclr4
       312   -> __aeabi_memcpy4
       312   -> __aeabi_memset
       312   -> psa_get_key_bits
       312   -> psa_get_key_type
       312   -> sl_se_ecdh_compute_shared_secret
       312   -> sl_se_init_command_context
       312   -> sli_psa_validate_ecc_weierstrass_privkey
       312   -> sli_psa_zeroize
       0   sli_se_has_format_byte
     136   sli_se_key_desc_from_input
       136   -> __aeabi_memcpy
       136   -> __aeabi_memcpy4
       136   -> __aeabi_memset
       136   -> psa_get_key_bits
       136   -> psa_get_key_lifetime
       136   -> psa_get_key_type
       136   -> sli_key_get_size
       136   -> sli_se_has_format_byte
       136   -> sli_se_key_desc_from_psa_attributes
       136   -> sli_se_key_descriptor_set_plaintext
       136   -> validate_key_desc
      48   sli_se_key_desc_from_psa_attributes
        48   -> __aeabi_memset
        48   -> psa_get_key_bits
        48   -> psa_get_key_lifetime
        48   -> psa_get_key_type
        48   -> psa_get_key_usage_flags
       0   sli_se_key_descriptor_set_plaintext
      40   sli_se_opaque_copy_key
        40   -> sli_se_opaque_import_key
     160   sli_se_opaque_export_key
       160   -> __aeabi_memclr4
       160   -> __aeabi_memcpy4
       160   -> clamp_private_key_if_needed
       160   -> psa_get_key_bits
       160   -> psa_get_key_type
       160   -> psa_get_key_usage_flags
       160   -> sl_se_deinit_command_context
       160   -> sl_se_export_key
       160   -> sl_se_init_command_context
       160   -> sli_key_get_storage_size
       160   -> sli_se_has_format_byte
       160   -> sli_se_key_desc_from_input
       160   -> sli_se_key_descriptor_set_plaintext
      32   sli_se_opaque_export_public_key
        32   -> sli_se_driver_export_public_key
      24   sli_se_opaque_generate_key
        24   -> sli_se_driver_generate_key
     160   sli_se_opaque_import_key
       160   -> __aeabi_memclr4
       160   -> __aeabi_memcpy4
       160   -> psa_get_key_type
       160   -> set_key_buffer_length
       160   -> sl_se_deinit_command_context
       160   -> sl_se_import_key
       160   -> sl_se_init_command_context
       160   -> sli_se_driver_validate_ecc_key
       160   -> sli_se_has_format_byte
       160   -> sli_se_key_desc_from_psa_attributes
       160   -> sli_se_key_descriptor_set_plaintext
       160   -> sli_se_set_key_desc_output
       160   -> store_key_desc_in_context
      24   sli_se_set_key_desc_output
        24   -> psa_get_key_lifetime
      32   sli_se_transparent_export_public_key
        32   -> psa_get_key_type
        32   -> sli_se_driver_export_public_key
      24   sli_se_transparent_generate_key
        24   -> psa_get_key_type
        24   -> sli_se_driver_generate_key
      48   sli_se_transparent_import_key
        48   -> __aeabi_memcpy
        48   -> clamp_private_key_if_needed
        48   -> psa_get_key_type
        48   -> sli_se_driver_validate_ecc_key
      32   store_key_desc_in_context
        32   -> __aeabi_memset
      48   validate_key_desc
        48   -> __aeabi_memclr4
        48   -> sli_se_key_desc_from_psa_attributes


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      32  ?_0
      36  ?_1
      32  ?_11
      36  ?_12
      32  ?_13
      36  ?_14
      32  ?_15
      36  ?_16
      32  ?_17
      36  ?_18
      32  ?_2
      32  ?_3
      32  ?_4
      56  clamp_private_key_if_needed
      32  ecc_p256_n
       4  psa_get_key_bits
       4  psa_get_key_lifetime
       4  psa_get_key_type
       4  psa_get_key_usage_flags
      72  set_key_buffer_length
      92  sli_psa_validate_ecc_weierstrass_privkey
      32  sli_psa_zeroize
     306  sli_se_driver_export_public_key
     324  sli_se_driver_generate_key
     424  sli_se_driver_validate_ecc_key
      76  sli_se_has_format_byte
     650  sli_se_key_desc_from_input
     490  sli_se_key_desc_from_psa_attributes
      16  sli_se_key_descriptor_set_plaintext
      44  sli_se_opaque_copy_key
     298  sli_se_opaque_export_key
      32  sli_se_opaque_export_public_key
      24  sli_se_opaque_generate_key
     416  sli_se_opaque_import_key
     100  sli_se_set_key_desc_output
      54  sli_se_transparent_export_public_key
      70  sli_se_transparent_generate_key
     114  sli_se_transparent_import_key
      70  store_key_desc_in_context
     110  validate_key_desc
     192  -- Other

 
   660 bytes in section .rodata
 3'942 bytes in section .text
 
 3'942 bytes of CODE  memory
   660 bytes of CONST memory

Errors: none
Warnings: none
