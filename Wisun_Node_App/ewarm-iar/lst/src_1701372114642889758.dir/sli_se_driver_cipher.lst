###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:29
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_cipher.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_driver_cipher.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_cipher.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_driver_cipher.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir\sli_se_driver_cipher.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_driver_cipher.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_cipher.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Driver Cipher functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "psa/crypto.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t psa_get_key_type(psa_key_attributes_t const *)
   \                     psa_get_key_type: (+1)
   \        0x0   0x8800             LDRH     R0,[R0, #+0]
   \        0x2   0x4770             BX       LR
     36          #include "psa/crypto_extra.h"
     37          
     38          #include "sli_psa_driver_common.h"
     39          
     40          #include "sli_se_driver_cipher.h"
     41          #include "sli_se_driver_key_management.h"
     42          
     43          #include "sl_se_manager.h"
     44          #include "sl_se_manager_cipher.h"
     45          
     46          #include <string.h>
     47          
     48          // -----------------------------------------------------------------------------
     49          // Static functions
     50          
     51          #if defined(SLI_PSA_DRIVER_FEATURE_CIPHER)
     52          
     53          /**
     54           * @brief
     55           *   Validate that the given key desc has the correct properties
     56           *   to be used for a cipher operation
     57           * @param key_desc
     58           *   Pointer to a key descriptor
     59           * @return
     60           *   PSA_SUCCESS if all is good
     61           *   PSA_ERROR_INVALID_ARGUMENT otherwise
     62           */

   \                                 In section .text, align 2, keep-with-next
     63          static psa_status_t validate_key_type(const sl_se_key_descriptor_t *key_desc)
     64          {
   \                     validate_key_type: (+1)
   \        0x0   0x0002             MOVS     R2,R0
     65            sl_se_key_type_t sl_key_type = key_desc->type;
   \        0x2   0x6811             LDR      R1,[R2, #+0]
     66            // Check with if (..) since switch does not support multiple equal entries
     67            // (AES 256 and CHACHA20 has same sl_key_type value)
     68            if (sl_key_type == SL_SE_KEY_TYPE_AES_128
     69                || sl_key_type == SL_SE_KEY_TYPE_AES_192
     70                || sl_key_type == SL_SE_KEY_TYPE_AES_256
     71                #if defined(SLI_PSA_DRIVER_FEATURE_CHACHA20)
     72                || sl_key_type == SL_SE_KEY_TYPE_CHACHA20
     73                #endif
     74                ) {
   \        0x4   0x2910             CMP      R1,#+16
   \        0x6   0xD003             BEQ.N    ??validate_key_type_0
   \        0x8   0x2918             CMP      R1,#+24
   \        0xA   0xD001             BEQ.N    ??validate_key_type_0
   \        0xC   0x2920             CMP      R1,#+32
   \        0xE   0xD101             BNE.N    ??validate_key_type_1
     75              return PSA_SUCCESS;
   \                     ??validate_key_type_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE001             B.N      ??validate_key_type_2
     76            }
     77          
     78            return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??validate_key_type_1: (+1)
   \       0x14   0xF07F 0x0086      MVNS     R0,#+134
   \                     ??validate_key_type_2: (+1)
   \       0x18   0x4770             BX       LR
     79          }
     80          
     81          // Validate combination of key and algorithm

   \                                 In section .text, align 2, keep-with-next
     82          static psa_status_t validate_key_algorithm_match(
     83            psa_algorithm_t alg,
     84            const psa_key_attributes_t *attributes)
     85          {
   \                     validate_key_algorithm_match: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
     86            switch (alg) {
   \        0x6   0x0021             MOVS     R1,R4
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable4
   \        0xC   0x4281             CMP      R1,R0
   \        0xE   0xD007             BEQ.N    ??validate_key_algorithm_match_0
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \       0x14   0x4281             CMP      R1,R0
   \       0x16   0xD003             BEQ.N    ??validate_key_algorithm_match_0
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \       0x1C   0x4281             CMP      R1,R0
   \       0x1E   0xD10A             BNE.N    ??validate_key_algorithm_match_1
     87              #if defined(SLI_PSA_DRIVER_FEATURE_BLOCK_CIPHER)
     88              #if defined(SLI_PSA_DRIVER_FEATURE_AES_ECB)
     89              case PSA_ALG_ECB_NO_PADDING:
     90              #endif
     91              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CTR)
     92              case PSA_ALG_CTR:
     93              #endif
     94              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CFB)
     95              case PSA_ALG_CFB:
     96              #endif
     97              #if defined(SLI_PSA_DRIVER_FEATURE_AES_OFB)
     98              case PSA_ALG_OFB:
     99              #endif
    100              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG)
    101              case PSA_ALG_CCM_STAR_NO_TAG:
    102              #endif
    103              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_NO_PADDING)
    104              case PSA_ALG_CBC_NO_PADDING:
    105              #endif
    106              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_PKCS7)
    107              case PSA_ALG_CBC_PKCS7:
    108              #endif
    109              if (psa_get_key_type(attributes) != PSA_KEY_TYPE_AES) {
   \                     ??validate_key_algorithm_match_0: (+1)
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0x.... 0x....      BL       psa_get_key_type
   \       0x26   0xF5B0 0x5F10      CMP      R0,#+9216
   \       0x2A   0xD002             BEQ.N    ??validate_key_algorithm_match_2
    110                return PSA_ERROR_NOT_SUPPORTED;
   \       0x2C   0xF07F 0x0085      MVNS     R0,#+133
   \       0x30   0xE003             B.N      ??validate_key_algorithm_match_3
    111              }
    112              break;
    113              #endif // SLI_PSA_DRIVER_FEATURE_BLOCK_CIPHER
    114          
    115              #if defined(SLI_PSA_DRIVER_FEATURE_CHACHA20)
    116              case PSA_ALG_STREAM_CIPHER:
    117                if (psa_get_key_type(attributes) != PSA_KEY_TYPE_CHACHA20) {
    118                  return PSA_ERROR_NOT_SUPPORTED;
    119                }
    120                break;
    121              #endif
    122          
    123              default:
    124                return PSA_ERROR_NOT_SUPPORTED;
    125            }
    126          
    127            return PSA_SUCCESS;
   \                     ??validate_key_algorithm_match_2: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE001             B.N      ??validate_key_algorithm_match_3
   \                     ??validate_key_algorithm_match_1: (+1)
   \       0x36   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??validate_key_algorithm_match_3: (+1)
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
    128          }
    129          
    130          #endif // SLI_PSA_DRIVER_FEATURE_CIPHER
    131          
    132          // -----------------------------------------------------------------------------
    133          // Single-shot driver entry points
    134          

   \                                 In section .text, align 2, keep-with-next
    135          psa_status_t sli_se_driver_cipher_encrypt(const psa_key_attributes_t *attributes,
    136                                                    const uint8_t *key_buffer,
    137                                                    size_t key_buffer_size,
    138                                                    psa_algorithm_t alg,
    139                                                    const uint8_t *iv,
    140                                                    size_t iv_length,
    141                                                    const uint8_t *input,
    142                                                    size_t input_length,
    143                                                    uint8_t *output,
    144                                                    size_t output_size,
    145                                                    size_t *output_length)
    146          {
   \                     sli_se_driver_cipher_encrypt: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB0A3             SUB      SP,SP,#+140
   \        0x6   0xF8DD 0x90C8      LDR      R9,[SP, #+200]
   \        0xA   0x9C33             LDR      R4,[SP, #+204]
   \        0xC   0x9D34             LDR      R5,[SP, #+208]
   \        0xE   0x9E35             LDR      R6,[SP, #+212]
   \       0x10   0x9F36             LDR      R7,[SP, #+216]
   \       0x12   0x2110             MOVS     R1,#+16
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0xA80D             ADD      R0,SP,#+52
   \       0x18   0x.... 0x....      BL       __aeabi_memset
   \       0x1C   0x2110             MOVS     R1,#+16
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0xA809             ADD      R0,SP,#+36
   \       0x22   0x.... 0x....      BL       __aeabi_memset
    147            #if defined(SLI_PSA_DRIVER_FEATURE_CIPHER)
    148          
    149            #if defined(MBEDTLS_PSA_CRYPTO_C)
    150          
    151            #if defined(SLI_PSA_DRIVER_FEATURE_AES_CTR)            \
    152            || defined(SLI_PSA_DRIVER_FEATURE_AES_CFB)             \
    153            || defined(SLI_PSA_DRIVER_FEATURE_AES_OFB)             \
    154            || defined(SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG) \
    155            || defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_NO_PADDING)  \
    156            || defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_PKCS7)       \
    157            || defined(SLI_PSA_DRIVER_FEATURE_CHACHA20)
    158            uint8_t tmp_buf[16] = { 0 };
    159            #endif
    160          
    161            #if defined(SLI_PSA_DRIVER_FEATURE_AES_CTR)            \
    162            || defined(SLI_PSA_DRIVER_FEATURE_AES_CFB)             \
    163            || defined(SLI_PSA_DRIVER_FEATURE_AES_OFB)             \
    164            || defined(SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG) \
    165            || defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_NO_PADDING)  \
    166            || defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_PKCS7)
    167            uint8_t final_block[16] = { 0 };
    168            #endif
    169          
    170            #endif   // MBEDTLS_PSA_CRYPTO_C
    171          
    172            // Argument check
    173            if (key_buffer == NULL
    174                || key_buffer_size == 0
    175                || (input == NULL && input_length > 0)
    176                || (iv == NULL && iv_length > 0)
    177                || (output == NULL && output_size > 0)
    178                || output_length == NULL) {
   \       0x26   0x9824             LDR      R0,[SP, #+144]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD013             BEQ.N    ??sli_se_driver_cipher_encrypt_0
   \       0x2C   0x9825             LDR      R0,[SP, #+148]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD010             BEQ.N    ??sli_se_driver_cipher_encrypt_0
   \       0x32   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x36   0xD101             BNE.N    ??sli_se_driver_cipher_encrypt_1
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD10B             BNE.N    ??sli_se_driver_cipher_encrypt_0
   \                     ??sli_se_driver_cipher_encrypt_1: (+1)
   \       0x3C   0x9830             LDR      R0,[SP, #+192]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD102             BNE.N    ??sli_se_driver_cipher_encrypt_2
   \       0x42   0x9831             LDR      R0,[SP, #+196]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD105             BNE.N    ??sli_se_driver_cipher_encrypt_0
   \                     ??sli_se_driver_cipher_encrypt_2: (+1)
   \       0x48   0x2D00             CMP      R5,#+0
   \       0x4A   0xD101             BNE.N    ??sli_se_driver_cipher_encrypt_3
   \       0x4C   0x2E00             CMP      R6,#+0
   \       0x4E   0xD101             BNE.N    ??sli_se_driver_cipher_encrypt_0
   \                     ??sli_se_driver_cipher_encrypt_3: (+1)
   \       0x50   0x2F00             CMP      R7,#+0
   \       0x52   0xD102             BNE.N    ??sli_se_driver_cipher_encrypt_4
    179              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_cipher_encrypt_0: (+1)
   \       0x54   0xF07F 0x0086      MVNS     R0,#+134
   \       0x58   0xE1AD             B.N      ??sli_se_driver_cipher_encrypt_5
    180            }
    181          
    182            psa_status_t psa_status = validate_key_algorithm_match(alg, attributes);
   \                     ??sli_se_driver_cipher_encrypt_4: (+1)
   \       0x5A   0x9923             LDR      R1,[SP, #+140]
   \       0x5C   0x9826             LDR      R0,[SP, #+152]
   \       0x5E   0x.... 0x....      BL       validate_key_algorithm_match
   \       0x62   0x4680             MOV      R8,R0
    183            if (psa_status != PSA_SUCCESS) {
   \       0x64   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x68   0xD001             BEQ.N    ??sli_se_driver_cipher_encrypt_6
    184              return psa_status;
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0xE1A3             B.N      ??sli_se_driver_cipher_encrypt_5
    185            }
    186          
    187            // Ephemeral contexts
    188            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_driver_cipher_encrypt_6: (+1)
   \       0x6E   0xA819             ADD      R0,SP,#+100
   \       0x70   0x2124             MOVS     R1,#+36
   \       0x72   0x.... 0x....      BL       __aeabi_memclr4
    189            sl_se_key_descriptor_t key_desc = { 0 };
   \       0x76   0xA811             ADD      R0,SP,#+68
   \       0x78   0x2120             MOVS     R1,#+32
   \       0x7A   0x.... 0x....      BL       __aeabi_memclr4
    190          
    191            sl_status_t status = sl_se_init_command_context(&cmd_ctx);
   \       0x7E   0xA819             ADD      R0,SP,#+100
   \       0x80   0x.... 0x....      BL       sl_se_init_command_context
   \       0x84   0x4682             MOV      R10,R0
    192            if (status != SL_STATUS_OK) {
   \       0x86   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x8A   0xD002             BEQ.N    ??sli_se_driver_cipher_encrypt_7
    193              return PSA_ERROR_HARDWARE_FAILURE;
   \       0x8C   0xF07F 0x0092      MVNS     R0,#+146
   \       0x90   0xE191             B.N      ??sli_se_driver_cipher_encrypt_5
    194            }
    195          
    196            psa_status = sli_se_key_desc_from_input(attributes,
    197                                                    key_buffer,
    198                                                    key_buffer_size,
    199                                                    &key_desc);
   \                     ??sli_se_driver_cipher_encrypt_7: (+1)
   \       0x92   0xAB11             ADD      R3,SP,#+68
   \       0x94   0x9A25             LDR      R2,[SP, #+148]
   \       0x96   0x9924             LDR      R1,[SP, #+144]
   \       0x98   0x9823             LDR      R0,[SP, #+140]
   \       0x9A   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x9E   0x4683             MOV      R11,R0
    200            if (psa_status != PSA_SUCCESS) {
   \       0xA0   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xA4   0xD001             BEQ.N    ??sli_se_driver_cipher_encrypt_8
    201              return psa_status;
   \       0xA6   0x4658             MOV      R0,R11
   \       0xA8   0xE185             B.N      ??sli_se_driver_cipher_encrypt_5
    202            }
    203            psa_status = validate_key_type(&key_desc);
   \                     ??sli_se_driver_cipher_encrypt_8: (+1)
   \       0xAA   0xA811             ADD      R0,SP,#+68
   \       0xAC   0x.... 0x....      BL       validate_key_type
   \       0xB0   0x9004             STR      R0,[SP, #+16]
    204            if (psa_status != PSA_SUCCESS) {
   \       0xB2   0x9804             LDR      R0,[SP, #+16]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD001             BEQ.N    ??sli_se_driver_cipher_encrypt_9
    205              return psa_status;
   \       0xB8   0x9804             LDR      R0,[SP, #+16]
   \       0xBA   0xE17C             B.N      ??sli_se_driver_cipher_encrypt_5
    206            }
    207          
    208            if (input_length == 0) {
   \                     ??sli_se_driver_cipher_encrypt_9: (+1)
   \       0xBC   0x2C00             CMP      R4,#+0
   \       0xBE   0xD103             BNE.N    ??sli_se_driver_cipher_encrypt_10
    209              *output_length = 0;
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0x6038             STR      R0,[R7, #+0]
    210              return PSA_SUCCESS;
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0xE176             B.N      ??sli_se_driver_cipher_encrypt_5
    211            }
    212          
    213            // Our drivers only support full or no overlap between input and output
    214            // buffers. So in the case of partial overlap, copy the input buffer into
    215            // the output buffer and process it in place as if the buffers fully
    216            // overlapped.
    217            if ((output > input) && (output < (input + input_length))) {
   \                     ??sli_se_driver_cipher_encrypt_10: (+1)
   \       0xC8   0x45A9             CMP      R9,R5
   \       0xCA   0xD211             BCS.N    ??sli_se_driver_cipher_encrypt_11
   \       0xCC   0xEB09 0x0004      ADD      R0,R9,R4
   \       0xD0   0x4285             CMP      R5,R0
   \       0xD2   0xD20D             BCS.N    ??sli_se_driver_cipher_encrypt_11
    218              // Sanity check before copying. Some ciphers have a stricter requirement
    219              // than this (if an IV is included), but no ciphers will have an output
    220              // smaller than the input.
    221              if (output_size < input_length) {
   \       0xD4   0x42A6             CMP      R6,R4
   \       0xD6   0xD202             BCS.N    ??sli_se_driver_cipher_encrypt_12
    222                return PSA_ERROR_INVALID_ARGUMENT;
   \       0xD8   0xF07F 0x0086      MVNS     R0,#+134
   \       0xDC   0xE16B             B.N      ??sli_se_driver_cipher_encrypt_5
    223              }
    224          
    225              memmove(output, input, input_length);
   \                     ??sli_se_driver_cipher_encrypt_12: (+1)
   \       0xDE   0x9400             STR      R4,[SP, #+0]
   \       0xE0   0x46CB             MOV      R11,R9
   \       0xE2   0x46A8             MOV      R8,R5
   \       0xE4   0x9A00             LDR      R2,[SP, #+0]
   \       0xE6   0x4659             MOV      R1,R11
   \       0xE8   0x4640             MOV      R0,R8
   \       0xEA   0x.... 0x....      BL       __aeabi_memmove
    226              input = output;
   \       0xEE   0x46A9             MOV      R9,R5
    227            }
    228          
    229            switch (alg) {
   \                     ??sli_se_driver_cipher_encrypt_11: (+1)
   \       0xF0   0x9926             LDR      R1,[SP, #+152]
   \       0xF2   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0xF6   0x4281             CMP      R1,R0
   \       0xF8   0xF000 0x80AA      BEQ.W    ??sli_se_driver_cipher_encrypt_13
   \       0xFC   0x.... 0x....      LDR.W    R0,??DataTable5
   \      0x100   0x4281             CMP      R1,R0
   \      0x102   0xF000 0x80AB      BEQ.W    ??sli_se_driver_cipher_encrypt_14
   \      0x106   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \      0x10A   0x4281             CMP      R1,R0
   \      0x10C   0xD008             BEQ.N    ??sli_se_driver_cipher_encrypt_15
   \      0x10E   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \      0x112   0x4281             CMP      R1,R0
   \      0x114   0xD01F             BEQ.N    ??sli_se_driver_cipher_encrypt_16
   \      0x116   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \      0x11A   0x4281             CMP      R1,R0
   \      0x11C   0xD01B             BEQ.N    ??sli_se_driver_cipher_encrypt_16
   \      0x11E   0xE12F             B.N      ??sli_se_driver_cipher_encrypt_17
    230              #if defined(SLI_PSA_DRIVER_FEATURE_AES_ECB)
    231              case PSA_ALG_ECB_NO_PADDING:
    232                // Check buffer sizes
    233                if (output_size < input_length) {
   \                     ??sli_se_driver_cipher_encrypt_15: (+1)
   \      0x120   0x42A6             CMP      R6,R4
   \      0x122   0xD202             BCS.N    ??sli_se_driver_cipher_encrypt_18
    234                  return PSA_ERROR_INVALID_ARGUMENT;
   \      0x124   0xF07F 0x0086      MVNS     R0,#+134
   \      0x128   0xE145             B.N      ??sli_se_driver_cipher_encrypt_5
    235                }
    236          
    237                // We cannot do ECB on non-block sizes
    238                if (input_length % 16 != 0) {
   \                     ??sli_se_driver_cipher_encrypt_18: (+1)
   \      0x12A   0xF014 0x0F0F      TST      R4,#0xF
   \      0x12E   0xD002             BEQ.N    ??sli_se_driver_cipher_encrypt_19
    239                  return PSA_ERROR_INVALID_ARGUMENT;
   \      0x130   0xF07F 0x0086      MVNS     R0,#+134
   \      0x134   0xE13F             B.N      ??sli_se_driver_cipher_encrypt_5
    240                }
    241          
    242                // do the operation
    243                status = sl_se_aes_crypt_ecb(&cmd_ctx,
    244                                             &key_desc,
    245                                             SL_SE_ENCRYPT,
    246                                             input_length,
    247                                             input,
    248                                             output);
   \                     ??sli_se_driver_cipher_encrypt_19: (+1)
   \      0x136   0x9501             STR      R5,[SP, #+4]
   \      0x138   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \      0x13C   0x0023             MOVS     R3,R4
   \      0x13E   0x2200             MOVS     R2,#+0
   \      0x140   0xA911             ADD      R1,SP,#+68
   \      0x142   0xA819             ADD      R0,SP,#+100
   \      0x144   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \      0x148   0x4682             MOV      R10,R0
    249                if (status != PSA_SUCCESS) {
   \      0x14A   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x14E   0xF040 0x811A      BNE.W    ??sli_se_driver_cipher_encrypt_20
    250                  goto exit;
    251                }
    252                *output_length = input_length;
   \                     ??sli_se_driver_cipher_encrypt_21: (+1)
   \      0x152   0x603C             STR      R4,[R7, #+0]
    253                break;
   \      0x154   0xE117             B.N      ??sli_se_driver_cipher_encrypt_20
   \                     ??sli_se_driver_cipher_encrypt_16: (+1)
   \      0x156   0x2110             MOVS     R1,#+16
   \      0x158   0x2200             MOVS     R2,#+0
   \      0x15A   0xA805             ADD      R0,SP,#+20
   \      0x15C   0x.... 0x....      BL       __aeabi_memset
    254              #endif   // SLI_PSA_DRIVER_FEATURE_AES_ECB
    255          
    256              #if defined(MBEDTLS_PSA_CRYPTO_C)
    257          
    258              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG)
    259              case PSA_ALG_CCM_STAR_NO_TAG:     // Explicit fallthrough
    260              #endif
    261          
    262              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CTR_VARIANT)
    263              case PSA_ALG_CTR: {
    264                uint8_t iv_buf[16] = { 0 };
    265                // Check buffer sizes
    266                if (output_size < input_length) {
   \      0x160   0x42A6             CMP      R6,R4
   \      0x162   0xD202             BCS.N    ??sli_se_driver_cipher_encrypt_22
    267                  return PSA_ERROR_INVALID_ARGUMENT;
   \      0x164   0xF07F 0x0086      MVNS     R0,#+134
   \      0x168   0xE125             B.N      ??sli_se_driver_cipher_encrypt_5
    268                }
    269                #if defined(SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG)
    270                if (alg == PSA_ALG_CCM_STAR_NO_TAG) {
   \                     ??sli_se_driver_cipher_encrypt_22: (+1)
   \      0x16A   0x9926             LDR      R1,[SP, #+152]
   \      0x16C   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \      0x170   0x4281             CMP      R1,R0
   \      0x172   0xD11A             BNE.N    ??sli_se_driver_cipher_encrypt_23
    271                  if (iv_length != 13) {
   \      0x174   0x9831             LDR      R0,[SP, #+196]
   \      0x176   0x280D             CMP      R0,#+13
   \      0x178   0xD002             BEQ.N    ??sli_se_driver_cipher_encrypt_24
    272                    return PSA_ERROR_INVALID_ARGUMENT;
   \      0x17A   0xF07F 0x0086      MVNS     R0,#+134
   \      0x17E   0xE11A             B.N      ??sli_se_driver_cipher_encrypt_5
    273                  }
    274          
    275                  // AES-CCM*-no-tag is basically AES-CTR with preformatted IV
    276                  iv_buf[0] = 1;
   \                     ??sli_se_driver_cipher_encrypt_24: (+1)
   \      0x180   0x2001             MOVS     R0,#+1
   \      0x182   0xF88D 0x0014      STRB     R0,[SP, #+20]
    277                  memcpy(&iv_buf[1], iv, 13);
   \      0x186   0xF05F 0x080D      MOVS     R8,#+13
   \      0x18A   0x9830             LDR      R0,[SP, #+192]
   \      0x18C   0x9000             STR      R0,[SP, #+0]
   \      0x18E   0xF10D 0x0B15      ADD      R11,SP,#+21
   \      0x192   0x4642             MOV      R2,R8
   \      0x194   0x9900             LDR      R1,[SP, #+0]
   \      0x196   0x4658             MOV      R0,R11
   \      0x198   0x.... 0x....      BL       __aeabi_memcpy
    278                  iv_buf[14] = 0;
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0xF88D 0x0022      STRB     R0,[SP, #+34]
    279                  iv_buf[15] = 1;
   \      0x1A2   0x2001             MOVS     R0,#+1
   \      0x1A4   0xF88D 0x0023      STRB     R0,[SP, #+35]
   \      0x1A8   0xE010             B.N      ??sli_se_driver_cipher_encrypt_25
    280                } else
    281                #endif     // SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG
    282                {
    283                  if (iv_length != 16) {
   \                     ??sli_se_driver_cipher_encrypt_23: (+1)
   \      0x1AA   0x9831             LDR      R0,[SP, #+196]
   \      0x1AC   0x2810             CMP      R0,#+16
   \      0x1AE   0xD002             BEQ.N    ??sli_se_driver_cipher_encrypt_26
    284                    return PSA_ERROR_INVALID_ARGUMENT;
   \      0x1B0   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1B4   0xE0FF             B.N      ??sli_se_driver_cipher_encrypt_5
    285                  }
    286          
    287                  // Write nonce to temporary buf to be used internally by
    288                  // sl_se_aes_crypt_ctr.
    289                  memcpy(iv_buf, iv, 16);
   \                     ??sli_se_driver_cipher_encrypt_26: (+1)
   \      0x1B6   0xF05F 0x0810      MOVS     R8,#+16
   \      0x1BA   0x9830             LDR      R0,[SP, #+192]
   \      0x1BC   0x9000             STR      R0,[SP, #+0]
   \      0x1BE   0xF10D 0x0B14      ADD      R11,SP,#+20
   \      0x1C2   0x4642             MOV      R2,R8
   \      0x1C4   0x9900             LDR      R1,[SP, #+0]
   \      0x1C6   0x4658             MOV      R0,R11
   \      0x1C8   0x.... 0x....      BL       __aeabi_memcpy
    290                }
    291          
    292                // Store final block in a temporary buffer in order to avoid in being
    293                // overwritten inside of sl_se_aes_crypt_ctr() (hence the separation
    294                // into two calls).
    295                if ((input_length & 0x0F) > 0) {
   \                     ??sli_se_driver_cipher_encrypt_25: (+1)
   \      0x1CC   0xF014 0x0F0F      TST      R4,#0xF
   \      0x1D0   0xD00C             BEQ.N    ??sli_se_driver_cipher_encrypt_27
    296                  memcpy(final_block, &input[input_length & ~0x0F], 16);
   \      0x1D2   0xF05F 0x0810      MOVS     R8,#+16
   \      0x1D6   0x0920             LSRS     R0,R4,#+4
   \      0x1D8   0x0100             LSLS     R0,R0,#+4
   \      0x1DA   0x4448             ADD      R0,R9,R0
   \      0x1DC   0x9000             STR      R0,[SP, #+0]
   \      0x1DE   0xF10D 0x0B24      ADD      R11,SP,#+36
   \      0x1E2   0x4642             MOV      R2,R8
   \      0x1E4   0x9900             LDR      R1,[SP, #+0]
   \      0x1E6   0x4658             MOV      R0,R11
   \      0x1E8   0x.... 0x....      BL       __aeabi_memcpy
    297                }
    298          
    299                // Do multi-block operation if applicable.
    300                if ((input_length & ~0x0F) > 0) {
   \                     ??sli_se_driver_cipher_encrypt_27: (+1)
   \      0x1EC   0x0920             LSRS     R0,R4,#+4
   \      0x1EE   0x0100             LSLS     R0,R0,#+4
   \      0x1F0   0x2800             CMP      R0,#+0
   \      0x1F2   0xD012             BEQ.N    ??sli_se_driver_cipher_encrypt_28
    301                  status = sl_se_aes_crypt_ctr(&cmd_ctx,
    302                                               &key_desc,
    303                                               input_length & ~0x0F,
    304                                               NULL,
    305                                               iv_buf,
    306                                               tmp_buf,
    307                                               input,
    308                                               output);
   \      0x1F4   0x9503             STR      R5,[SP, #+12]
   \      0x1F6   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \      0x1FA   0xA80D             ADD      R0,SP,#+52
   \      0x1FC   0x9001             STR      R0,[SP, #+4]
   \      0x1FE   0xA805             ADD      R0,SP,#+20
   \      0x200   0x9000             STR      R0,[SP, #+0]
   \      0x202   0x2300             MOVS     R3,#+0
   \      0x204   0x0922             LSRS     R2,R4,#+4
   \      0x206   0x0112             LSLS     R2,R2,#+4
   \      0x208   0xA911             ADD      R1,SP,#+68
   \      0x20A   0xA819             ADD      R0,SP,#+100
   \      0x20C   0x.... 0x....      BL       sl_se_aes_crypt_ctr
   \      0x210   0x4682             MOV      R10,R0
    309                  if (status != PSA_SUCCESS) {
   \      0x212   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x216   0xF040 0x80B6      BNE.W    ??sli_se_driver_cipher_encrypt_20
    310                    goto exit;
    311                  }
    312                }
    313          
    314                // Encrypt final block if there is any.
    315                if ((input_length & 0x0F) > 0) {
   \                     ??sli_se_driver_cipher_encrypt_28: (+1)
   \      0x21A   0xF014 0x0F0F      TST      R4,#0xF
   \      0x21E   0xD015             BEQ.N    ??sli_se_driver_cipher_encrypt_29
    316                  status = sl_se_aes_crypt_ctr(&cmd_ctx,
    317                                               &key_desc,
    318                                               input_length & 0x0F,
    319                                               NULL,
    320                                               iv_buf,
    321                                               tmp_buf,
    322                                               final_block,
    323                                               &output[(input_length & ~0x0F)]);
   \      0x220   0x0920             LSRS     R0,R4,#+4
   \      0x222   0x0100             LSLS     R0,R0,#+4
   \      0x224   0x4428             ADD      R0,R5,R0
   \      0x226   0x9003             STR      R0,[SP, #+12]
   \      0x228   0xA809             ADD      R0,SP,#+36
   \      0x22A   0x9002             STR      R0,[SP, #+8]
   \      0x22C   0xA80D             ADD      R0,SP,#+52
   \      0x22E   0x9001             STR      R0,[SP, #+4]
   \      0x230   0xA805             ADD      R0,SP,#+20
   \      0x232   0x9000             STR      R0,[SP, #+0]
   \      0x234   0x2300             MOVS     R3,#+0
   \      0x236   0xF014 0x020F      ANDS     R2,R4,#0xF
   \      0x23A   0xA911             ADD      R1,SP,#+68
   \      0x23C   0xA819             ADD      R0,SP,#+100
   \      0x23E   0x.... 0x....      BL       sl_se_aes_crypt_ctr
   \      0x242   0x4682             MOV      R10,R0
    324                  if (status != PSA_SUCCESS) {
   \      0x244   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x248   0xF040 0x809D      BNE.W    ??sli_se_driver_cipher_encrypt_20
    325                    goto exit;
    326                  }
    327                }
    328          
    329                *output_length = input_length;
   \                     ??sli_se_driver_cipher_encrypt_29: (+1)
   \      0x24C   0x603C             STR      R4,[R7, #+0]
    330                break;
   \      0x24E   0xE09A             B.N      ??sli_se_driver_cipher_encrypt_20
    331              }
    332              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CTR_VARIANT
    333          
    334              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CFB)
    335              case PSA_ALG_CFB:
    336                // Check buffer sizes
    337                if (output_size < input_length) {
    338                  return PSA_ERROR_INVALID_ARGUMENT;
    339                }
    340          
    341                if (iv_length != 16) {
    342                  return PSA_ERROR_INVALID_ARGUMENT;
    343                }
    344          
    345                // Write IV to temporary buf to be used internally by
    346                // sl_se_aes_crypt_cbf128.
    347                memcpy(tmp_buf, iv, 16);
    348          
    349                // Store final block in a temporary buffer in order to avoid in being
    350                // overwritten inside of sl_se_aes_crypt_ctr() (hence the separation
    351                // into two calls).
    352                if ((input_length & 0x0F) > 0) {
    353                  memcpy(final_block, &input[input_length & ~0x0F], 16);
    354                }
    355          
    356                // Do multi-block operation if applicable.
    357                if ((input_length & ~0x0F) > 0) {
    358                  status = sl_se_aes_crypt_cfb128(&cmd_ctx,
    359                                                  &key_desc,
    360                                                  SL_SE_ENCRYPT,
    361                                                  input_length & ~0x0F,
    362                                                  NULL,
    363                                                  tmp_buf,
    364                                                  input,
    365                                                  output);
    366                  if (status != PSA_SUCCESS) {
    367                    goto exit;
    368                  }
    369                }
    370          
    371                // Encrypt final block if there is any.
    372                if ((input_length & 0x0F) > 0) {
    373                  status = sl_se_aes_crypt_cfb128(&cmd_ctx,
    374                                                  &key_desc,
    375                                                  SL_SE_ENCRYPT,
    376                                                  input_length & 0x0F,
    377                                                  NULL,
    378                                                  tmp_buf,
    379                                                  final_block,
    380                                                  &output[(input_length & ~0x0F)]);
    381                  if (status != PSA_SUCCESS) {
    382                    goto exit;
    383                  }
    384                }
    385          
    386                *output_length = input_length;
    387                break;
    388              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CFB
    389          
    390              #if defined(SLI_PSA_DRIVER_FEATURE_AES_OFB)
    391              case PSA_ALG_OFB:
    392              {
    393                // Check buffer sizes
    394                if (output_size < input_length) {
    395                  return PSA_ERROR_INVALID_ARGUMENT;
    396                }
    397          
    398                if (iv_length != 16) {
    399                  return PSA_ERROR_INVALID_ARGUMENT;
    400                }
    401          
    402                // Write IV to temporary buf to be used internally by
    403                // sl_se_aes_crypt_ecb.
    404                memcpy(tmp_buf, iv, 16);
    405          
    406                size_t data_length = input_length;
    407                size_t n = 0;
    408          
    409                // Use final_block as a temporary storage in order to avoid input being
    410                // overwritten by the output (in case of buffer overlap).
    411                memcpy(final_block, input, 16);
    412          
    413                // Loop over input data to create output.
    414                do {
    415                  if (n == 0) {
    416                    status = sl_se_aes_crypt_ecb(&cmd_ctx,
    417                                                 &key_desc,
    418                                                 SL_SE_ENCRYPT,
    419                                                 16,
    420                                                 tmp_buf,
    421                                                 tmp_buf);
    422                    if (status != SL_STATUS_OK) {
    423                      goto exit;
    424                    }
    425                  }
    426                  uint8_t tmp_input_val = final_block[n];
    427                  final_block[n] = input[16 + input_length - data_length];
    428                  output[input_length - data_length] = tmp_input_val ^ tmp_buf[n];
    429                  n = (n + 1) & 0x0F;
    430                } while (data_length--);
    431          
    432                *output_length = input_length;
    433              }
    434              break;
    435              #endif   // SLI_PSA_DRIVER_FEATURE_AES_OFB
    436          
    437              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT)
    438              case PSA_ALG_CBC_NO_PADDING:
    439                // We cannot do CBC without padding on non-block sizes.
    440                if (input_length % 16 != 0) {
   \                     ??sli_se_driver_cipher_encrypt_13: (+1)
   \      0x250   0xF014 0x0F0F      TST      R4,#0xF
   \      0x254   0xD002             BEQ.N    ??sli_se_driver_cipher_encrypt_14
    441                  return PSA_ERROR_INVALID_ARGUMENT;
   \      0x256   0xF07F 0x0086      MVNS     R0,#+134
   \      0x25A   0xE0AC             B.N      ??sli_se_driver_cipher_encrypt_5
    442                }
    443              // fall through
    444              case PSA_ALG_CBC_PKCS7:
    445                // Check buffer sizes
    446                if (alg == PSA_ALG_CBC_NO_PADDING) {
   \                     ??sli_se_driver_cipher_encrypt_14: (+1)
   \      0x25C   0x9826             LDR      R0,[SP, #+152]
   \      0x25E   0x.... 0x....      LDR.W    R1,??DataTable4
   \      0x262   0x4288             CMP      R0,R1
   \      0x264   0xD104             BNE.N    ??sli_se_driver_cipher_encrypt_30
    447                  if (output_size < input_length) {
   \      0x266   0x42A6             CMP      R6,R4
   \      0x268   0xD20A             BCS.N    ??sli_se_driver_cipher_encrypt_31
    448                    return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x26A   0xF07F 0x0089      MVNS     R0,#+137
   \      0x26E   0xE0A2             B.N      ??sli_se_driver_cipher_encrypt_5
    449                  }
    450                } else {
    451                  if (output_size < 16 + (input_length & ~0xF)) {
   \                     ??sli_se_driver_cipher_encrypt_30: (+1)
   \      0x270   0x0920             LSRS     R0,R4,#+4
   \      0x272   0x0100             LSLS     R0,R0,#+4
   \      0x274   0x3010             ADDS     R0,R0,#+16
   \      0x276   0x4286             CMP      R6,R0
   \      0x278   0xD202             BCS.N    ??sli_se_driver_cipher_encrypt_31
    452                    return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x27A   0xF07F 0x0089      MVNS     R0,#+137
   \      0x27E   0xE09A             B.N      ??sli_se_driver_cipher_encrypt_5
    453                  }
    454                }
    455          
    456                if (iv_length != 16) {
   \                     ??sli_se_driver_cipher_encrypt_31: (+1)
   \      0x280   0x9831             LDR      R0,[SP, #+196]
   \      0x282   0x2810             CMP      R0,#+16
   \      0x284   0xD002             BEQ.N    ??sli_se_driver_cipher_encrypt_32
    457                  return PSA_ERROR_INVALID_ARGUMENT;
   \      0x286   0xF07F 0x0086      MVNS     R0,#+134
   \      0x28A   0xE094             B.N      ??sli_se_driver_cipher_encrypt_5
    458                }
    459          
    460                // Write IV to temporary buf to be used internally by
    461                // sl_se_aes_crypt_cbf128.
    462                memcpy(tmp_buf, iv, 16);
   \                     ??sli_se_driver_cipher_encrypt_32: (+1)
   \      0x28C   0xF05F 0x0B10      MOVS     R11,#+16
   \      0x290   0x9830             LDR      R0,[SP, #+192]
   \      0x292   0x9000             STR      R0,[SP, #+0]
   \      0x294   0xF10D 0x0834      ADD      R8,SP,#+52
   \      0x298   0x465A             MOV      R2,R11
   \      0x29A   0x9900             LDR      R1,[SP, #+0]
   \      0x29C   0x4640             MOV      R0,R8
   \      0x29E   0x.... 0x....      BL       __aeabi_memcpy
    463          
    464                // Store last block (if non-blocksize input-length) to temporary
    465                // buffer to be used in padding.
    466                if (alg == PSA_ALG_CBC_PKCS7) {
   \      0x2A2   0x.... 0x....      LDR.W    R8,??DataTable5
   \      0x2A6   0x9826             LDR      R0,[SP, #+152]
   \      0x2A8   0x4540             CMP      R0,R8
   \      0x2AA   0xD10D             BNE.N    ??sli_se_driver_cipher_encrypt_33
    467                  memcpy(final_block, &input[input_length & ~0xF], input_length & 0xF);
   \      0x2AC   0xF014 0x000F      ANDS     R0,R4,#0xF
   \      0x2B0   0x9001             STR      R0,[SP, #+4]
   \      0x2B2   0x0920             LSRS     R0,R4,#+4
   \      0x2B4   0x0100             LSLS     R0,R0,#+4
   \      0x2B6   0x4448             ADD      R0,R9,R0
   \      0x2B8   0x9000             STR      R0,[SP, #+0]
   \      0x2BA   0xF10D 0x0B24      ADD      R11,SP,#+36
   \      0x2BE   0x9A01             LDR      R2,[SP, #+4]
   \      0x2C0   0x9900             LDR      R1,[SP, #+0]
   \      0x2C2   0x4658             MOV      R0,R11
   \      0x2C4   0x.... 0x....      BL       __aeabi_memcpy
    468                }
    469          
    470                // CBC-encrypt all but the last block
    471                if (input_length >= 16) {
   \                     ??sli_se_driver_cipher_encrypt_33: (+1)
   \      0x2C8   0x2C10             CMP      R4,#+16
   \      0x2CA   0xD30F             BCC.N    ??sli_se_driver_cipher_encrypt_34
    472                  status = sl_se_aes_crypt_cbc(&cmd_ctx,
    473                                               &key_desc,
    474                                               SL_SE_ENCRYPT,
    475                                               input_length & ~0xF,
    476                                               tmp_buf,
    477                                               input,
    478                                               output);
   \      0x2CC   0x9502             STR      R5,[SP, #+8]
   \      0x2CE   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \      0x2D2   0xA80D             ADD      R0,SP,#+52
   \      0x2D4   0x9000             STR      R0,[SP, #+0]
   \      0x2D6   0x0923             LSRS     R3,R4,#+4
   \      0x2D8   0x011B             LSLS     R3,R3,#+4
   \      0x2DA   0x2200             MOVS     R2,#+0
   \      0x2DC   0xA911             ADD      R1,SP,#+68
   \      0x2DE   0xA819             ADD      R0,SP,#+100
   \      0x2E0   0x.... 0x....      BL       sl_se_aes_crypt_cbc
   \      0x2E4   0x4682             MOV      R10,R0
    479                  if (status != SL_STATUS_OK) {
   \      0x2E6   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x2EA   0xD14C             BNE.N    ??sli_se_driver_cipher_encrypt_20
    480                    goto exit;
    481                  }
    482                }
    483          
    484                // Process final block.
    485                if (alg == PSA_ALG_CBC_PKCS7) {
   \                     ??sli_se_driver_cipher_encrypt_34: (+1)
   \      0x2EC   0x9826             LDR      R0,[SP, #+152]
   \      0x2EE   0x4540             CMP      R0,R8
   \      0x2F0   0xD144             BNE.N    ??sli_se_driver_cipher_encrypt_35
    486                  // Add PKCS7 padding.
    487                  memset(&final_block[input_length & 0xF],
    488                         16 - (input_length & 0xF),
    489                         16 - (input_length & 0xF));
   \      0x2F2   0xF014 0x000F      ANDS     R0,R4,#0xF
   \      0x2F6   0xF1D0 0x0010      RSBS     R0,R0,#+16
   \      0x2FA   0x9000             STR      R0,[SP, #+0]
   \      0x2FC   0xF014 0x0B0F      ANDS     R11,R4,#0xF
   \      0x300   0xF1DB 0x0B10      RSBS     R11,R11,#+16
   \      0x304   0xA909             ADD      R1,SP,#+36
   \      0x306   0xF014 0x000F      ANDS     R0,R4,#0xF
   \      0x30A   0xEB01 0x0800      ADD      R8,R1,R0
   \      0x30E   0x465A             MOV      R2,R11
   \      0x310   0x9900             LDR      R1,[SP, #+0]
   \      0x312   0x4640             MOV      R0,R8
   \      0x314   0x.... 0x....      BL       __aeabi_memset
    490          
    491                  // Store IV (last ciphertext block) in temp buffer to avoid messing
    492                  // up output.
    493                  if (input_length >= 16) {
   \      0x318   0x2C10             CMP      R4,#+16
   \      0x31A   0xD30D             BCC.N    ??sli_se_driver_cipher_encrypt_36
    494                    memcpy(tmp_buf, &output[(input_length & ~0xF) - 16], 16);
   \      0x31C   0xF05F 0x0810      MOVS     R8,#+16
   \      0x320   0x0920             LSRS     R0,R4,#+4
   \      0x322   0x0100             LSLS     R0,R0,#+4
   \      0x324   0x4428             ADD      R0,R5,R0
   \      0x326   0x3810             SUBS     R0,R0,#+16
   \      0x328   0x9000             STR      R0,[SP, #+0]
   \      0x32A   0xF10D 0x0B34      ADD      R11,SP,#+52
   \      0x32E   0x4642             MOV      R2,R8
   \      0x330   0x9900             LDR      R1,[SP, #+0]
   \      0x332   0x4658             MOV      R0,R11
   \      0x334   0x.... 0x....      BL       __aeabi_memcpy
    495                  }
    496          
    497                  // CBC-encrypt the last block.
    498                  status = sl_se_aes_crypt_cbc(&cmd_ctx,
    499                                               &key_desc,
    500                                               SL_SE_ENCRYPT,
    501                                               16,
    502                                               tmp_buf,
    503                                               final_block,
    504                                               final_block);
   \                     ??sli_se_driver_cipher_encrypt_36: (+1)
   \      0x338   0xA809             ADD      R0,SP,#+36
   \      0x33A   0x9002             STR      R0,[SP, #+8]
   \      0x33C   0xA809             ADD      R0,SP,#+36
   \      0x33E   0x9001             STR      R0,[SP, #+4]
   \      0x340   0xA80D             ADD      R0,SP,#+52
   \      0x342   0x9000             STR      R0,[SP, #+0]
   \      0x344   0x2310             MOVS     R3,#+16
   \      0x346   0x2200             MOVS     R2,#+0
   \      0x348   0xA911             ADD      R1,SP,#+68
   \      0x34A   0xA819             ADD      R0,SP,#+100
   \      0x34C   0x.... 0x....      BL       sl_se_aes_crypt_cbc
   \      0x350   0x4682             MOV      R10,R0
    505          
    506                  if (status != SL_STATUS_OK) {
   \      0x352   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x356   0xD116             BNE.N    ??sli_se_driver_cipher_encrypt_20
    507                    goto exit;
    508                  }
    509          
    510                  // Copy to output.
    511                  memcpy(&output[(input_length & ~0xF)], final_block, 16);
   \                     ??sli_se_driver_cipher_encrypt_37: (+1)
   \      0x358   0x2010             MOVS     R0,#+16
   \      0x35A   0x9000             STR      R0,[SP, #+0]
   \      0x35C   0xF10D 0x0B24      ADD      R11,SP,#+36
   \      0x360   0x0920             LSRS     R0,R4,#+4
   \      0x362   0x0100             LSLS     R0,R0,#+4
   \      0x364   0xEB05 0x0800      ADD      R8,R5,R0
   \      0x368   0x9A00             LDR      R2,[SP, #+0]
   \      0x36A   0x4659             MOV      R1,R11
   \      0x36C   0x4640             MOV      R0,R8
   \      0x36E   0x.... 0x....      BL       __aeabi_memcpy
    512                  *output_length = (input_length & ~0xF) + 16;
   \      0x372   0x0920             LSRS     R0,R4,#+4
   \      0x374   0x0100             LSLS     R0,R0,#+4
   \      0x376   0x3010             ADDS     R0,R0,#+16
   \      0x378   0x6038             STR      R0,[R7, #+0]
   \      0x37A   0xE000             B.N      ??sli_se_driver_cipher_encrypt_38
    513                } else {
    514                  *output_length = input_length;
   \                     ??sli_se_driver_cipher_encrypt_35: (+1)
   \      0x37C   0x603C             STR      R4,[R7, #+0]
    515                }
    516                break;
   \                     ??sli_se_driver_cipher_encrypt_38: (+1)
   \      0x37E   0xE002             B.N      ??sli_se_driver_cipher_encrypt_20
    517              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT
    518          
    519              #if defined(SLI_PSA_DRIVER_FEATURE_CHACHA20)
    520              case PSA_ALG_STREAM_CIPHER:
    521                if (psa_get_key_type(attributes) != PSA_KEY_TYPE_CHACHA20) {
    522                  return PSA_ERROR_INVALID_ARGUMENT;
    523                }
    524          
    525                // check buffer sizes
    526                if (output_size < input_length) {
    527                  return PSA_ERROR_INVALID_ARGUMENT;
    528                }
    529          
    530                if (iv_length != 12) {
    531                  return PSA_ERROR_INVALID_ARGUMENT;
    532                }
    533          
    534                // PSA Crypto dictates that the initial counter for ChaCha20 starts
    535                // at zero (unless using the multi-part API)
    536                memset(tmp_buf, 0, 4);
    537                memcpy(&tmp_buf[4], iv, 12);
    538          
    539                status = sl_se_chacha20_crypt(&cmd_ctx,
    540                                              SL_SE_ENCRYPT,
    541                                              &key_desc,
    542                                              input_length,
    543                                              tmp_buf,
    544                                              &tmp_buf[4],
    545                                              input,
    546                                              output);
    547                if (status != SL_STATUS_OK) {
    548                  goto exit;
    549                }
    550          
    551                *output_length = input_length;
    552                break;
    553              #endif   // SLI_PSA_DRIVER_FEATURE_CHACHA20
    554          
    555              #endif   // MBEDTLS_PSA_CRYPTO_C
    556          
    557              default:
    558                (void)attributes;
    559                (void)key_buffer;
    560                (void)key_buffer_size;
    561                (void)alg;
    562                (void)iv;
    563                (void)iv_length;
    564                (void)input;
    565                (void)input_length;
    566                (void)output;
    567                (void)output_size;
    568                (void)output_length;
    569                return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_driver_cipher_encrypt_17: (+1)
   \      0x380   0xF07F 0x0085      MVNS     R0,#+133
   \      0x384   0xE017             B.N      ??sli_se_driver_cipher_encrypt_5
    570            }
    571          
    572            exit:
    573            if (status != SL_STATUS_OK) {
   \                     ??sli_se_driver_cipher_encrypt_20: (+1)
   \      0x386   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x38A   0xD013             BEQ.N    ??sli_se_driver_cipher_encrypt_39
    574              memset(output, 0, output_size);
   \      0x38C   0x9600             STR      R6,[SP, #+0]
   \      0x38E   0xF05F 0x0B00      MOVS     R11,#+0
   \      0x392   0x46A8             MOV      R8,R5
   \      0x394   0x465A             MOV      R2,R11
   \      0x396   0x9900             LDR      R1,[SP, #+0]
   \      0x398   0x4640             MOV      R0,R8
   \      0x39A   0x.... 0x....      BL       __aeabi_memset
    575              *output_length = 0;
   \      0x39E   0x2000             MOVS     R0,#+0
   \      0x3A0   0x6038             STR      R0,[R7, #+0]
    576              if (status == SL_STATUS_FAIL) {
   \      0x3A2   0xF1BA 0x0F01      CMP      R10,#+1
   \      0x3A6   0xD102             BNE.N    ??sli_se_driver_cipher_encrypt_40
    577                // This specific code maps to 'does not exist' for builtin keys
    578                return PSA_ERROR_DOES_NOT_EXIST;
   \      0x3A8   0xF07F 0x008B      MVNS     R0,#+139
   \      0x3AC   0xE003             B.N      ??sli_se_driver_cipher_encrypt_5
    579              } else {
    580                return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_cipher_encrypt_40: (+1)
   \      0x3AE   0xF07F 0x0092      MVNS     R0,#+146
   \      0x3B2   0xE000             B.N      ??sli_se_driver_cipher_encrypt_5
    581              }
    582            } else {
    583              return PSA_SUCCESS;
   \                     ??sli_se_driver_cipher_encrypt_39: (+1)
   \      0x3B4   0x2000             MOVS     R0,#+0
   \                     ??sli_se_driver_cipher_encrypt_5: (+1)
   \      0x3B6   0xB027             ADD      SP,SP,#+156
   \      0x3B8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    584            }
    585          
    586            #else // SLI_PSA_DRIVER_FEATURE_CIPHER
    587          
    588            (void)attributes;
    589            (void)key_buffer;
    590            (void)key_buffer_size;
    591            (void)alg;
    592            (void)iv;
    593            (void)iv_length;
    594            (void)input;
    595            (void)input_length;
    596            (void)output;
    597            (void)output_size;
    598            (void)output_length;
    599          
    600            return PSA_ERROR_NOT_SUPPORTED;
    601          
    602            #endif // SLI_PSA_DRIVER_FEATURE_CIPHER
    603          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    604          

   \                                 In section .text, align 2, keep-with-next
    605          psa_status_t sli_se_driver_cipher_decrypt(const psa_key_attributes_t *attributes,
    606                                                    const uint8_t *key_buffer,
    607                                                    size_t key_buffer_size,
    608                                                    psa_algorithm_t alg,
    609                                                    const uint8_t *input,
    610                                                    size_t input_length,
    611                                                    uint8_t *output,
    612                                                    size_t output_size,
    613                                                    size_t *output_length)
    614          {
   \                     sli_se_driver_cipher_decrypt: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB09F             SUB      SP,SP,#+124
   \        0x6   0xF8DD 0x90B0      LDR      R9,[SP, #+176]
   \        0xA   0x9D2D             LDR      R5,[SP, #+180]
   \        0xC   0x9F2E             LDR      R7,[SP, #+184]
   \        0xE   0xF8DD 0x80C0      LDR      R8,[SP, #+192]
   \       0x12   0x2110             MOVS     R1,#+16
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0xA809             ADD      R0,SP,#+36
   \       0x18   0x.... 0x....      BL       __aeabi_memset
   \       0x1C   0x2110             MOVS     R1,#+16
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0xA804             ADD      R0,SP,#+16
   \       0x22   0x.... 0x....      BL       __aeabi_memset
    615            #if defined(SLI_PSA_DRIVER_FEATURE_CIPHER)
    616          
    617            #if defined(SLI_PSA_DRIVER_FEATURE_AES_CTR_VARIANT) \
    618            || defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT)
    619            uint8_t tmp_buf[16] = { 0 };
    620            #endif
    621          
    622            #if defined(SLI_PSA_DRIVER_FEATURE_AES_CTR)            \
    623            || defined(SLI_PSA_DRIVER_FEATURE_AES_CFB)             \
    624            || defined(SLI_PSA_DRIVER_FEATURE_AES_OFB)             \
    625            || defined(SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG) \
    626            || defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_NO_PADDING)  \
    627            || defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_PKCS7)       \
    628            || defined(SLI_PSA_DRIVER_FEATURE_CHACHA20)
    629            uint8_t iv_buf[16] = { 0 };
    630            #endif
    631          
    632            // Argument check.
    633            if (key_buffer == NULL
    634                || key_buffer_size == 0
    635                || (input == NULL && input_length > 0)
    636                || (output == NULL && output_size > 0)
    637                || output_length == NULL) {
   \       0x26   0x9820             LDR      R0,[SP, #+128]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD00F             BEQ.N    ??sli_se_driver_cipher_decrypt_0
   \       0x2C   0x9821             LDR      R0,[SP, #+132]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD00C             BEQ.N    ??sli_se_driver_cipher_decrypt_0
   \       0x32   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x36   0xD101             BNE.N    ??sli_se_driver_cipher_decrypt_1
   \       0x38   0x2D00             CMP      R5,#+0
   \       0x3A   0xD107             BNE.N    ??sli_se_driver_cipher_decrypt_0
   \                     ??sli_se_driver_cipher_decrypt_1: (+1)
   \       0x3C   0x2F00             CMP      R7,#+0
   \       0x3E   0xD102             BNE.N    ??sli_se_driver_cipher_decrypt_2
   \       0x40   0x982F             LDR      R0,[SP, #+188]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD102             BNE.N    ??sli_se_driver_cipher_decrypt_0
   \                     ??sli_se_driver_cipher_decrypt_2: (+1)
   \       0x46   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x4A   0xD102             BNE.N    ??sli_se_driver_cipher_decrypt_3
    638              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_cipher_decrypt_0: (+1)
   \       0x4C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x50   0xE180             B.N      ??sli_se_driver_cipher_decrypt_4
    639            }
    640          
    641            psa_status_t psa_status = validate_key_algorithm_match(alg, attributes);
   \                     ??sli_se_driver_cipher_decrypt_3: (+1)
   \       0x52   0x991F             LDR      R1,[SP, #+124]
   \       0x54   0x9822             LDR      R0,[SP, #+136]
   \       0x56   0x.... 0x....      BL       validate_key_algorithm_match
   \       0x5A   0x0006             MOVS     R6,R0
    642            if (psa_status != PSA_SUCCESS) {
   \       0x5C   0x2E00             CMP      R6,#+0
   \       0x5E   0xD001             BEQ.N    ??sli_se_driver_cipher_decrypt_5
    643              return psa_status;
   \       0x60   0x0030             MOVS     R0,R6
   \       0x62   0xE177             B.N      ??sli_se_driver_cipher_decrypt_4
    644            }
    645          
    646            // Ephemeral contexts.
    647            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_driver_cipher_decrypt_5: (+1)
   \       0x64   0xA815             ADD      R0,SP,#+84
   \       0x66   0x2124             MOVS     R1,#+36
   \       0x68   0x.... 0x....      BL       __aeabi_memclr4
    648            sl_se_key_descriptor_t key_desc = { 0 };
   \       0x6C   0xA80D             ADD      R0,SP,#+52
   \       0x6E   0x2120             MOVS     R1,#+32
   \       0x70   0x.... 0x....      BL       __aeabi_memclr4
    649          
    650            sl_status_t status = sl_se_init_command_context(&cmd_ctx);
   \       0x74   0xA815             ADD      R0,SP,#+84
   \       0x76   0x.... 0x....      BL       sl_se_init_command_context
   \       0x7A   0x0004             MOVS     R4,R0
    651            if (status != SL_STATUS_OK) {
   \       0x7C   0x2C00             CMP      R4,#+0
   \       0x7E   0xD002             BEQ.N    ??sli_se_driver_cipher_decrypt_6
    652              return PSA_ERROR_HARDWARE_FAILURE;
   \       0x80   0xF07F 0x0092      MVNS     R0,#+146
   \       0x84   0xE166             B.N      ??sli_se_driver_cipher_decrypt_4
    653            }
    654          
    655            psa_status = sli_se_key_desc_from_input(attributes,
    656                                                    key_buffer,
    657                                                    key_buffer_size,
    658                                                    &key_desc);
   \                     ??sli_se_driver_cipher_decrypt_6: (+1)
   \       0x86   0xAB0D             ADD      R3,SP,#+52
   \       0x88   0x9A21             LDR      R2,[SP, #+132]
   \       0x8A   0x9920             LDR      R1,[SP, #+128]
   \       0x8C   0x981F             LDR      R0,[SP, #+124]
   \       0x8E   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x92   0x4682             MOV      R10,R0
    659            if (psa_status != PSA_SUCCESS) {
   \       0x94   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x98   0xD001             BEQ.N    ??sli_se_driver_cipher_decrypt_7
    660              return psa_status;
   \       0x9A   0x4650             MOV      R0,R10
   \       0x9C   0xE15A             B.N      ??sli_se_driver_cipher_decrypt_4
    661            }
    662            psa_status = validate_key_type(&key_desc);
   \                     ??sli_se_driver_cipher_decrypt_7: (+1)
   \       0x9E   0xA80D             ADD      R0,SP,#+52
   \       0xA0   0x.... 0x....      BL       validate_key_type
   \       0xA4   0x0006             MOVS     R6,R0
    663            if (psa_status != PSA_SUCCESS) {
   \       0xA6   0x2E00             CMP      R6,#+0
   \       0xA8   0xD001             BEQ.N    ??sli_se_driver_cipher_decrypt_8
    664              return psa_status;
   \       0xAA   0x0030             MOVS     R0,R6
   \       0xAC   0xE152             B.N      ??sli_se_driver_cipher_decrypt_4
    665            }
    666          
    667            if (input_length == 0) {
   \                     ??sli_se_driver_cipher_decrypt_8: (+1)
   \       0xAE   0x2D00             CMP      R5,#+0
   \       0xB0   0xD104             BNE.N    ??sli_se_driver_cipher_decrypt_9
    668              *output_length = 0;
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0xF8C8 0x0000      STR      R0,[R8, #+0]
    669              return PSA_SUCCESS;
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0xE14B             B.N      ??sli_se_driver_cipher_decrypt_4
    670            }
    671          
    672            // Our drivers only support full or no overlap between input and output
    673            // buffers. So in the case of partial overlap, copy the input buffer into
    674            // the output buffer and process it in place as if the buffers fully
    675            // overlapped.
    676            if ((output > input) && (output < (input + input_length))) {
   \                     ??sli_se_driver_cipher_decrypt_9: (+1)
   \       0xBC   0x45B9             CMP      R9,R7
   \       0xBE   0xD212             BCS.N    ??sli_se_driver_cipher_decrypt_10
   \       0xC0   0xEB09 0x0005      ADD      R0,R9,R5
   \       0xC4   0x4287             CMP      R7,R0
   \       0xC6   0xD20E             BCS.N    ??sli_se_driver_cipher_decrypt_10
    677              // Sanity check before copying. Some ciphers have a stricter requirement
    678              // than this (if an IV is included), but no ciphers will have an output
    679              // smaller than the input.
    680              if (output_size < input_length) {
   \       0xC8   0x982F             LDR      R0,[SP, #+188]
   \       0xCA   0x42A8             CMP      R0,R5
   \       0xCC   0xD202             BCS.N    ??sli_se_driver_cipher_decrypt_11
    681                return PSA_ERROR_INVALID_ARGUMENT;
   \       0xCE   0xF07F 0x0086      MVNS     R0,#+134
   \       0xD2   0xE13F             B.N      ??sli_se_driver_cipher_decrypt_4
    682              }
    683          
    684              memmove(output, input, input_length);
   \                     ??sli_se_driver_cipher_decrypt_11: (+1)
   \       0xD4   0x9501             STR      R5,[SP, #+4]
   \       0xD6   0x46CA             MOV      R10,R9
   \       0xD8   0x46BB             MOV      R11,R7
   \       0xDA   0x9A01             LDR      R2,[SP, #+4]
   \       0xDC   0x4651             MOV      R1,R10
   \       0xDE   0x4658             MOV      R0,R11
   \       0xE0   0x.... 0x....      BL       __aeabi_memmove
    685              input = output;
   \       0xE4   0x46B9             MOV      R9,R7
    686            }
    687          
    688            switch (alg) {
   \                     ??sli_se_driver_cipher_decrypt_10: (+1)
   \       0xE6   0x9922             LDR      R1,[SP, #+136]
   \       0xE8   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0xEC   0x4281             CMP      R1,R0
   \       0xEE   0xD075             BEQ.N    ??sli_se_driver_cipher_decrypt_12
   \       0xF0   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0xF4   0x4281             CMP      R1,R0
   \       0xF6   0xD077             BEQ.N    ??sli_se_driver_cipher_decrypt_13
   \       0xF8   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \       0xFC   0x4281             CMP      R1,R0
   \       0xFE   0xD008             BEQ.N    ??sli_se_driver_cipher_decrypt_14
   \      0x100   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \      0x104   0x4281             CMP      R1,R0
   \      0x106   0xD01D             BEQ.N    ??sli_se_driver_cipher_decrypt_15
   \      0x108   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \      0x10C   0x4281             CMP      R1,R0
   \      0x10E   0xD019             BEQ.N    ??sli_se_driver_cipher_decrypt_15
   \      0x110   0xE105             B.N      ??sli_se_driver_cipher_decrypt_16
    689              #if defined(SLI_PSA_DRIVER_FEATURE_AES_ECB)
    690              case PSA_ALG_ECB_NO_PADDING:
    691                // Check buffer sizes.
    692                if (output_size < input_length) {
   \                     ??sli_se_driver_cipher_decrypt_14: (+1)
   \      0x112   0x982F             LDR      R0,[SP, #+188]
   \      0x114   0x42A8             CMP      R0,R5
   \      0x116   0xD202             BCS.N    ??sli_se_driver_cipher_decrypt_17
    693                  return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x118   0xF07F 0x0089      MVNS     R0,#+137
   \      0x11C   0xE11A             B.N      ??sli_se_driver_cipher_decrypt_4
    694                }
    695          
    696                // We cannot do ECB on non-block sizes.
    697                if (input_length % 16 != 0) {
   \                     ??sli_se_driver_cipher_decrypt_17: (+1)
   \      0x11E   0xF015 0x0F0F      TST      R5,#0xF
   \      0x122   0xD002             BEQ.N    ??sli_se_driver_cipher_decrypt_18
    698                  return PSA_ERROR_INVALID_ARGUMENT;
   \      0x124   0xF07F 0x0086      MVNS     R0,#+134
   \      0x128   0xE114             B.N      ??sli_se_driver_cipher_decrypt_4
    699                }
    700          
    701                // Do the operation.
    702                status = sl_se_aes_crypt_ecb(&cmd_ctx,
    703                                             &key_desc,
    704                                             SL_SE_DECRYPT,
    705                                             input_length,
    706                                             input,
    707                                             output);
   \                     ??sli_se_driver_cipher_decrypt_18: (+1)
   \      0x12A   0x9701             STR      R7,[SP, #+4]
   \      0x12C   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \      0x130   0x002B             MOVS     R3,R5
   \      0x132   0x2201             MOVS     R2,#+1
   \      0x134   0xA90D             ADD      R1,SP,#+52
   \      0x136   0xA815             ADD      R0,SP,#+84
   \      0x138   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \      0x13C   0x0004             MOVS     R4,R0
    708          
    709                *output_length = input_length;
   \      0x13E   0xF8C8 0x5000      STR      R5,[R8, #+0]
    710                break;
   \      0x142   0xE0EF             B.N      ??sli_se_driver_cipher_decrypt_19
    711              #endif   // SLI_PSA_DRIVER_FEATURE_AES_ECB
    712          
    713              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG)
    714              case PSA_ALG_CCM_STAR_NO_TAG:     // Explicit fallthrough
    715              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG
    716          
    717              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CTR_VARIANT)
    718              case PSA_ALG_CTR:
    719                // Check buffer sizes.
    720                #if defined(SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG)
    721                if (alg == PSA_ALG_CCM_STAR_NO_TAG) {
   \                     ??sli_se_driver_cipher_decrypt_15: (+1)
   \      0x144   0x9922             LDR      R1,[SP, #+136]
   \      0x146   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \      0x14A   0x4281             CMP      R1,R0
   \      0x14C   0xD11F             BNE.N    ??sli_se_driver_cipher_decrypt_20
    722                  if (output_size < input_length - 13) {
   \      0x14E   0x992F             LDR      R1,[SP, #+188]
   \      0x150   0xF1B5 0x000D      SUBS     R0,R5,#+13
   \      0x154   0x4281             CMP      R1,R0
   \      0x156   0xD202             BCS.N    ??sli_se_driver_cipher_decrypt_21
    723                    return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x158   0xF07F 0x0089      MVNS     R0,#+137
   \      0x15C   0xE0FA             B.N      ??sli_se_driver_cipher_decrypt_4
    724                  }
    725          
    726                  // AES-CCM*-no-tag is basically AES-CTR with preformatted IV
    727                  iv_buf[0] = 1;
   \                     ??sli_se_driver_cipher_decrypt_21: (+1)
   \      0x15E   0x2001             MOVS     R0,#+1
   \      0x160   0xF88D 0x0010      STRB     R0,[SP, #+16]
    728                  memcpy(&iv_buf[1], input, 13);
   \      0x164   0xF05F 0x0A0D      MOVS     R10,#+13
   \      0x168   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \      0x16C   0xF10D 0x0B11      ADD      R11,SP,#+17
   \      0x170   0x4652             MOV      R2,R10
   \      0x172   0x9901             LDR      R1,[SP, #+4]
   \      0x174   0x4658             MOV      R0,R11
   \      0x176   0x.... 0x....      BL       __aeabi_memcpy
    729                  iv_buf[14] = 0;
   \      0x17A   0x2000             MOVS     R0,#+0
   \      0x17C   0xF88D 0x001E      STRB     R0,[SP, #+30]
    730                  iv_buf[15] = 1;
   \      0x180   0x2001             MOVS     R0,#+1
   \      0x182   0xF88D 0x001F      STRB     R0,[SP, #+31]
    731                  input += 13;
   \      0x186   0xF119 0x090D      ADDS     R9,R9,#+13
    732                  input_length -= 13;
   \      0x18A   0x3D0D             SUBS     R5,R5,#+13
   \      0x18C   0xE015             B.N      ??sli_se_driver_cipher_decrypt_22
    733                } else
    734                #endif     // SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG
    735                {
    736                  if (output_size < input_length - 16) {
   \                     ??sli_se_driver_cipher_decrypt_20: (+1)
   \      0x18E   0x982F             LDR      R0,[SP, #+188]
   \      0x190   0xF1B5 0x0110      SUBS     R1,R5,#+16
   \      0x194   0x4288             CMP      R0,R1
   \      0x196   0xD202             BCS.N    ??sli_se_driver_cipher_decrypt_23
    737                    return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x198   0xF07F 0x0089      MVNS     R0,#+137
   \      0x19C   0xE0DA             B.N      ??sli_se_driver_cipher_decrypt_4
    738                  }
    739          
    740                  // Write IV to temporary buf to be used internally by
    741                  // sl_se_aes_crypt_ctr.
    742                  memcpy(iv_buf, input, 16);
   \                     ??sli_se_driver_cipher_decrypt_23: (+1)
   \      0x19E   0xF05F 0x0A10      MOVS     R10,#+16
   \      0x1A2   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \      0x1A6   0xF10D 0x0B10      ADD      R11,SP,#+16
   \      0x1AA   0x4652             MOV      R2,R10
   \      0x1AC   0x9901             LDR      R1,[SP, #+4]
   \      0x1AE   0x4658             MOV      R0,R11
   \      0x1B0   0x.... 0x....      BL       __aeabi_memcpy
    743                  input += 16;
   \      0x1B4   0xF119 0x0910      ADDS     R9,R9,#+16
    744                  input_length -= 16;
   \      0x1B8   0x3D10             SUBS     R5,R5,#+16
    745                }
    746          
    747                status = sl_se_aes_crypt_ctr(&cmd_ctx,
    748                                             &key_desc,
    749                                             input_length,
    750                                             NULL,
    751                                             iv_buf,
    752                                             tmp_buf,
    753                                             input,
    754                                             output);
   \                     ??sli_se_driver_cipher_decrypt_22: (+1)
   \      0x1BA   0x9703             STR      R7,[SP, #+12]
   \      0x1BC   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \      0x1C0   0xA809             ADD      R0,SP,#+36
   \      0x1C2   0x9001             STR      R0,[SP, #+4]
   \      0x1C4   0xA804             ADD      R0,SP,#+16
   \      0x1C6   0x9000             STR      R0,[SP, #+0]
   \      0x1C8   0x2300             MOVS     R3,#+0
   \      0x1CA   0x002A             MOVS     R2,R5
   \      0x1CC   0xA90D             ADD      R1,SP,#+52
   \      0x1CE   0xA815             ADD      R0,SP,#+84
   \      0x1D0   0x.... 0x....      BL       sl_se_aes_crypt_ctr
   \      0x1D4   0x0004             MOVS     R4,R0
    755          
    756                *output_length = input_length;
   \      0x1D6   0xF8C8 0x5000      STR      R5,[R8, #+0]
    757                break;
   \      0x1DA   0xE0A3             B.N      ??sli_se_driver_cipher_decrypt_19
    758              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CTR_VARIANT
    759          
    760              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CFB)
    761              case PSA_ALG_CFB:
    762                // Check buffer sizes.
    763                if (output_size < input_length - 16) {
    764                  return PSA_ERROR_INVALID_ARGUMENT;
    765                }
    766          
    767                // Write IV to temporary buf to be used internally by
    768                // sl_se_aes_crypt_cfb128.
    769                memcpy(iv_buf, input, 16);
    770          
    771                status = sl_se_aes_crypt_cfb128(&cmd_ctx,
    772                                                &key_desc,
    773                                                SL_SE_DECRYPT,
    774                                                input_length - 16,
    775                                                NULL,
    776                                                iv_buf,
    777                                                &input[16],
    778                                                output);
    779          
    780                *output_length = input_length - 16;
    781                break;
    782              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CFB
    783          
    784              #if defined(SLI_PSA_DRIVER_FEATURE_AES_OFB)
    785              case PSA_ALG_OFB:
    786              {
    787                // Check buffer sizes.
    788                if (output_size < input_length - 16) {
    789                  return PSA_ERROR_BUFFER_TOO_SMALL;
    790                }
    791          
    792                // Write IV to temporary buf to be used internally by
    793                // sl_se_aes_crypt_ecb.
    794                memcpy(iv_buf, input, 16);
    795          
    796                input += 16;
    797                size_t data_length = input_length - 16;
    798                size_t n = 0;
    799          
    800                // Loop over input data to create output.
    801                while (data_length--) {
    802                  if (n == 0) {
    803                    status = sl_se_aes_crypt_ecb(&cmd_ctx,
    804                                                 &key_desc,
    805                                                 SL_SE_ENCRYPT,
    806                                                 16,
    807                                                 iv_buf,
    808                                                 iv_buf);
    809                    if (status != SL_STATUS_OK) {
    810                      goto exit;
    811                    }
    812                  }
    813                  *output++ = *input++ ^ iv_buf[n];
    814          
    815                  n = (n + 1) & 0x0F;
    816                }
    817          
    818                *output_length = input_length - 16;
    819              }
    820              break;
    821              #endif   // SLI_PSA_DRIVER_FEATURE_AES_OFB
    822          
    823              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT)
    824              case PSA_ALG_CBC_NO_PADDING:
    825                // We cannot do CBC without padding on non-block sizes.
    826                if (input_length % 16 != 0) {
   \                     ??sli_se_driver_cipher_decrypt_12: (+1)
   \      0x1DC   0xF015 0x0F0F      TST      R5,#0xF
   \      0x1E0   0xD002             BEQ.N    ??sli_se_driver_cipher_decrypt_13
    827                  return PSA_ERROR_INVALID_ARGUMENT;
   \      0x1E2   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1E6   0xE0B5             B.N      ??sli_se_driver_cipher_decrypt_4
    828                }
    829              // fall through
    830          
    831              case PSA_ALG_CBC_PKCS7: {
    832                size_t full_blocks;
    833                if (alg == PSA_ALG_CBC_NO_PADDING) {
   \                     ??sli_se_driver_cipher_decrypt_13: (+1)
   \      0x1E8   0x9922             LDR      R1,[SP, #+136]
   \      0x1EA   0x....             LDR.N    R0,??DataTable4
   \      0x1EC   0x4281             CMP      R1,R0
   \      0x1EE   0xD10C             BNE.N    ??sli_se_driver_cipher_decrypt_24
    834                  if (output_size < input_length - 16) {
   \      0x1F0   0x982F             LDR      R0,[SP, #+188]
   \      0x1F2   0xF1B5 0x0110      SUBS     R1,R5,#+16
   \      0x1F6   0x4288             CMP      R0,R1
   \      0x1F8   0xD202             BCS.N    ??sli_se_driver_cipher_decrypt_25
    835                    return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x1FA   0xF07F 0x0089      MVNS     R0,#+137
   \      0x1FE   0xE0A9             B.N      ??sli_se_driver_cipher_decrypt_4
    836                  }
    837                  full_blocks = (input_length - 16) / 16;
   \                     ??sli_se_driver_cipher_decrypt_25: (+1)
   \      0x200   0xF1B5 0x0A10      SUBS     R10,R5,#+16
   \      0x204   0xEA5F 0x1A1A      LSRS     R10,R10,#+4
   \      0x208   0xE013             B.N      ??sli_se_driver_cipher_decrypt_26
    838                } else {
    839                  // Check correct input amount
    840                  if (input_length < 32
    841                      || ((input_length & 0xF) != 0)) {
   \                     ??sli_se_driver_cipher_decrypt_24: (+1)
   \      0x20A   0x2D20             CMP      R5,#+32
   \      0x20C   0xD302             BCC.N    ??sli_se_driver_cipher_decrypt_27
   \      0x20E   0xF015 0x0F0F      TST      R5,#0xF
   \      0x212   0xD002             BEQ.N    ??sli_se_driver_cipher_decrypt_28
    842                    return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_cipher_decrypt_27: (+1)
   \      0x214   0xF07F 0x0086      MVNS     R0,#+134
   \      0x218   0xE09C             B.N      ??sli_se_driver_cipher_decrypt_4
    843                  }
    844                  // Check output has enough room for at least n-1 blocks.
    845                  if (output_size < (input_length - 32)) {
   \                     ??sli_se_driver_cipher_decrypt_28: (+1)
   \      0x21A   0x992F             LDR      R1,[SP, #+188]
   \      0x21C   0xF1B5 0x0020      SUBS     R0,R5,#+32
   \      0x220   0x4281             CMP      R1,R0
   \      0x222   0xD202             BCS.N    ??sli_se_driver_cipher_decrypt_29
    846                    return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x224   0xF07F 0x0089      MVNS     R0,#+137
   \      0x228   0xE094             B.N      ??sli_se_driver_cipher_decrypt_4
    847                  }
    848                  full_blocks = (input_length - 32) / 16;
   \                     ??sli_se_driver_cipher_decrypt_29: (+1)
   \      0x22A   0xF1B5 0x0A20      SUBS     R10,R5,#+32
   \      0x22E   0xEA5F 0x1A1A      LSRS     R10,R10,#+4
    849                }
    850          
    851                // Write IV to temporary buf to be used internally by
    852                // sl_se_aes_crypt_cbc.
    853                memcpy(iv_buf, input, 16);
   \                     ??sli_se_driver_cipher_decrypt_26: (+1)
   \      0x232   0x2010             MOVS     R0,#+16
   \      0x234   0x9002             STR      R0,[SP, #+8]
   \      0x236   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \      0x23A   0xF10D 0x0B10      ADD      R11,SP,#+16
   \      0x23E   0x9A02             LDR      R2,[SP, #+8]
   \      0x240   0x9901             LDR      R1,[SP, #+4]
   \      0x242   0x4658             MOV      R0,R11
   \      0x244   0x.... 0x....      BL       __aeabi_memcpy
    854          
    855                // CBC-decrypt all but the last block.
    856                if (full_blocks > 0) {
   \      0x248   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x24C   0xD00F             BEQ.N    ??sli_se_driver_cipher_decrypt_30
    857                  status = sl_se_aes_crypt_cbc(&cmd_ctx,
    858                                               &key_desc,
    859                                               SL_SE_DECRYPT,
    860                                               full_blocks * 16,
    861                                               iv_buf,
    862                                               &input[16],
    863                                               output);
   \      0x24E   0x9702             STR      R7,[SP, #+8]
   \      0x250   0xF119 0x0010      ADDS     R0,R9,#+16
   \      0x254   0x9001             STR      R0,[SP, #+4]
   \      0x256   0xA804             ADD      R0,SP,#+16
   \      0x258   0x9000             STR      R0,[SP, #+0]
   \      0x25A   0xEA5F 0x130A      LSLS     R3,R10,#+4
   \      0x25E   0x2201             MOVS     R2,#+1
   \      0x260   0xA90D             ADD      R1,SP,#+52
   \      0x262   0xA815             ADD      R0,SP,#+84
   \      0x264   0x.... 0x....      BL       sl_se_aes_crypt_cbc
   \      0x268   0x0004             MOVS     R4,R0
    864                  if (status != SL_STATUS_OK) {
   \      0x26A   0x2C00             CMP      R4,#+0
   \      0x26C   0xD15A             BNE.N    ??sli_se_driver_cipher_decrypt_19
    865                    goto exit;
    866                  }
    867                }
    868          
    869                // Process final block.
    870                if (alg == PSA_ALG_CBC_PKCS7) {
   \                     ??sli_se_driver_cipher_decrypt_30: (+1)
   \      0x26E   0x9922             LDR      R1,[SP, #+136]
   \      0x270   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0x274   0x4281             CMP      R1,R0
   \      0x276   0xD14D             BNE.N    ??sli_se_driver_cipher_decrypt_31
    871                  // Store last block to temporary buffer to be used in removing the
    872                  // padding.
    873                  memcpy(tmp_buf, &input[input_length - 16], 16);
   \      0x278   0x2010             MOVS     R0,#+16
   \      0x27A   0x9008             STR      R0,[SP, #+32]
   \      0x27C   0xEB09 0x0005      ADD      R0,R9,R5
   \      0x280   0x3810             SUBS     R0,R0,#+16
   \      0x282   0x9003             STR      R0,[SP, #+12]
   \      0x284   0xF10D 0x0B24      ADD      R11,SP,#+36
   \      0x288   0x9A08             LDR      R2,[SP, #+32]
   \      0x28A   0x9903             LDR      R1,[SP, #+12]
   \      0x28C   0x4658             MOV      R0,R11
   \      0x28E   0x.... 0x....      BL       __aeabi_memcpy
    874          
    875                  // CBC-decrypt the last block.
    876                  status = sl_se_aes_crypt_cbc(&cmd_ctx,
    877                                               &key_desc,
    878                                               SL_SE_DECRYPT,
    879                                               16,
    880                                               iv_buf,
    881                                               tmp_buf,
    882                                               tmp_buf);
   \      0x292   0xA809             ADD      R0,SP,#+36
   \      0x294   0x9002             STR      R0,[SP, #+8]
   \      0x296   0xA809             ADD      R0,SP,#+36
   \      0x298   0x9001             STR      R0,[SP, #+4]
   \      0x29A   0xA804             ADD      R0,SP,#+16
   \      0x29C   0x9000             STR      R0,[SP, #+0]
   \      0x29E   0x2310             MOVS     R3,#+16
   \      0x2A0   0x2201             MOVS     R2,#+1
   \      0x2A2   0xA90D             ADD      R1,SP,#+52
   \      0x2A4   0xA815             ADD      R0,SP,#+84
   \      0x2A6   0x.... 0x....      BL       sl_se_aes_crypt_cbc
   \      0x2AA   0x0004             MOVS     R4,R0
    883                  if (status != SL_STATUS_OK) {
   \      0x2AC   0x2C00             CMP      R4,#+0
   \      0x2AE   0xD139             BNE.N    ??sli_se_driver_cipher_decrypt_19
    884                    goto exit;
    885                  }
    886          
    887                  // Validate padding.
    888                  size_t pad_bytes = 0;
   \                     ??sli_se_driver_cipher_decrypt_32: (+1)
   \      0x2B0   0x2000             MOVS     R0,#+0
   \      0x2B2   0x9000             STR      R0,[SP, #+0]
    889                  psa_status = sli_psa_validate_pkcs7_padding(tmp_buf,
    890                                                              16,
    891                                                              &pad_bytes);
   \      0x2B4   0x466A             MOV      R2,SP
   \      0x2B6   0x2110             MOVS     R1,#+16
   \      0x2B8   0xA809             ADD      R0,SP,#+36
   \      0x2BA   0x.... 0x....      BL       sli_psa_validate_pkcs7_padding
   \      0x2BE   0x0006             MOVS     R6,R0
    892                  if (psa_status != PSA_SUCCESS) {
   \      0x2C0   0x2E00             CMP      R6,#+0
   \      0x2C2   0xD004             BEQ.N    ??sli_se_driver_cipher_decrypt_33
    893                    *output_length = 0;
   \      0x2C4   0x2000             MOVS     R0,#+0
   \      0x2C6   0xF8C8 0x0000      STR      R0,[R8, #+0]
    894                    return psa_status;
   \      0x2CA   0x0030             MOVS     R0,R6
   \      0x2CC   0xE042             B.N      ??sli_se_driver_cipher_decrypt_4
    895                  }
    896          
    897                  if (output_size < (input_length - 16 - pad_bytes)) {
   \                     ??sli_se_driver_cipher_decrypt_33: (+1)
   \      0x2CE   0x9A2F             LDR      R2,[SP, #+188]
   \      0x2D0   0xF1B5 0x0110      SUBS     R1,R5,#+16
   \      0x2D4   0x9800             LDR      R0,[SP, #+0]
   \      0x2D6   0x1A09             SUBS     R1,R1,R0
   \      0x2D8   0x428A             CMP      R2,R1
   \      0x2DA   0xD205             BCS.N    ??sli_se_driver_cipher_decrypt_34
    898                    *output_length = 0;
   \      0x2DC   0x2000             MOVS     R0,#+0
   \      0x2DE   0xF8C8 0x0000      STR      R0,[R8, #+0]
    899                    return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x2E2   0xF07F 0x0089      MVNS     R0,#+137
   \      0x2E6   0xE035             B.N      ??sli_se_driver_cipher_decrypt_4
    900                  }
    901          
    902                  // Copy non-padding bytes.
    903                  memcpy(&output[full_blocks * 16], tmp_buf, 16 - pad_bytes);
   \                     ??sli_se_driver_cipher_decrypt_34: (+1)
   \      0x2E8   0x9800             LDR      R0,[SP, #+0]
   \      0x2EA   0xF1D0 0x0010      RSBS     R0,R0,#+16
   \      0x2EE   0x9002             STR      R0,[SP, #+8]
   \      0x2F0   0xA809             ADD      R0,SP,#+36
   \      0x2F2   0x9001             STR      R0,[SP, #+4]
   \      0x2F4   0xEA5F 0x100A      LSLS     R0,R10,#+4
   \      0x2F8   0xEB07 0x0B00      ADD      R11,R7,R0
   \      0x2FC   0x9A02             LDR      R2,[SP, #+8]
   \      0x2FE   0x9901             LDR      R1,[SP, #+4]
   \      0x300   0x4658             MOV      R0,R11
   \      0x302   0x.... 0x....      BL       __aeabi_memcpy
    904                  *output_length = input_length - 16 - pad_bytes;
   \      0x306   0xF1B5 0x0110      SUBS     R1,R5,#+16
   \      0x30A   0x9800             LDR      R0,[SP, #+0]
   \      0x30C   0x1A09             SUBS     R1,R1,R0
   \      0x30E   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \      0x312   0xE003             B.N      ??sli_se_driver_cipher_decrypt_35
    905                } else {
    906                  *output_length = input_length - 16;
   \                     ??sli_se_driver_cipher_decrypt_31: (+1)
   \      0x314   0xF1B5 0x0010      SUBS     R0,R5,#+16
   \      0x318   0xF8C8 0x0000      STR      R0,[R8, #+0]
    907                }
    908                break;
   \                     ??sli_se_driver_cipher_decrypt_35: (+1)
   \      0x31C   0xE002             B.N      ??sli_se_driver_cipher_decrypt_19
    909              }
    910              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT
    911          
    912              #if defined(SLI_PSA_DRIVER_FEATURE_CHACHA20)
    913              case PSA_ALG_STREAM_CIPHER:
    914                if (psa_get_key_type(attributes) != PSA_KEY_TYPE_CHACHA20) {
    915                  return PSA_ERROR_INVALID_ARGUMENT;
    916                }
    917          
    918                // check buffer sizes.
    919                if (output_size < input_length - 12) {
    920                  return PSA_ERROR_BUFFER_TOO_SMALL;
    921                }
    922          
    923                // PSA Crypto dictates that the initial counter for ChaCha20 starts
    924                // at zero (unless using the multi-part API)
    925                memset(iv_buf, 0, 4);
    926          
    927                status = sl_se_chacha20_crypt(&cmd_ctx,
    928                                              SL_SE_DECRYPT,
    929                                              &key_desc,
    930                                              input_length - 12,     // - 12 due to the nonce.
    931                                              iv_buf,
    932                                              input,
    933                                              &input[12],
    934                                              output);
    935          
    936                *output_length = input_length - 12;
    937                break;
    938              #endif   // SLI_PSA_DRIVER_FEATURE_CHACHA20
    939          
    940              default:
    941                return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_driver_cipher_decrypt_16: (+1)
   \      0x31E   0xF07F 0x0085      MVNS     R0,#+133
   \      0x322   0xE017             B.N      ??sli_se_driver_cipher_decrypt_4
    942            }
    943          
    944            #if defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT) \
    945            || defined(SLI_PSA_DRIVER_FEATURE_AES_OFB)
    946            exit:
    947            #endif
    948          
    949            if (status != SL_STATUS_OK) {
   \                     ??sli_se_driver_cipher_decrypt_19: (+1)
   \      0x324   0x2C00             CMP      R4,#+0
   \      0x326   0xD014             BEQ.N    ??sli_se_driver_cipher_decrypt_36
    950              memset(output, 0, output_size);
   \      0x328   0x982F             LDR      R0,[SP, #+188]
   \      0x32A   0x9001             STR      R0,[SP, #+4]
   \      0x32C   0xF05F 0x0B00      MOVS     R11,#+0
   \      0x330   0x46BA             MOV      R10,R7
   \      0x332   0x465A             MOV      R2,R11
   \      0x334   0x9901             LDR      R1,[SP, #+4]
   \      0x336   0x4650             MOV      R0,R10
   \      0x338   0x.... 0x....      BL       __aeabi_memset
    951              *output_length = 0;
   \      0x33C   0x2000             MOVS     R0,#+0
   \      0x33E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    952              if (status == SL_STATUS_FAIL) {
   \      0x342   0x2C01             CMP      R4,#+1
   \      0x344   0xD102             BNE.N    ??sli_se_driver_cipher_decrypt_37
    953                // This specific code maps to 'does not exist' for builtin keys
    954                return PSA_ERROR_DOES_NOT_EXIST;
   \      0x346   0xF07F 0x008B      MVNS     R0,#+139
   \      0x34A   0xE003             B.N      ??sli_se_driver_cipher_decrypt_4
    955              } else {
    956                return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_cipher_decrypt_37: (+1)
   \      0x34C   0xF07F 0x0092      MVNS     R0,#+146
   \      0x350   0xE000             B.N      ??sli_se_driver_cipher_decrypt_4
    957              }
    958            } else {
    959              return PSA_SUCCESS;
   \                     ??sli_se_driver_cipher_decrypt_36: (+1)
   \      0x352   0x2000             MOVS     R0,#+0
   \                     ??sli_se_driver_cipher_decrypt_4: (+1)
   \      0x354   0xB023             ADD      SP,SP,#+140
   \      0x356   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    960            }
    961          
    962            #else // SLI_PSA_DRIVER_FEATURE_CIPHER
    963          
    964            (void)attributes;
    965            (void)key_buffer;
    966            (void)key_buffer_size;
    967            (void)alg;
    968            (void)input;
    969            (void)input_length;
    970            (void)output;
    971            (void)output_size;
    972            (void)output_length;
    973          
    974            return PSA_ERROR_NOT_SUPPORTED;
    975          
    976            #endif // SLI_PSA_DRIVER_FEATURE_CIPHER
    977          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    978          
    979          // -----------------------------------------------------------------------------
    980          // Multi-part driver entry points
    981          

   \                                 In section .text, align 2, keep-with-next
    982          psa_status_t sli_se_driver_cipher_encrypt_setup(
    983            sli_se_driver_cipher_operation_t *operation,
    984            const psa_key_attributes_t *attributes,
    985            psa_algorithm_t alg)
    986          {
   \                     sli_se_driver_cipher_encrypt_setup: (+1)
   \        0x0   0xE92D 0x47F6      PUSH     {R1,R2,R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    987            #if defined(SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART)
    988          
    989            if (operation == NULL || attributes == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??sli_se_driver_cipher_encrypt_setup_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD102             BNE.N    ??sli_se_driver_cipher_encrypt_setup_1
    990              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_cipher_encrypt_setup_0: (+1)
   \       0x10   0xF07F 0x0086      MVNS     R0,#+134
   \       0x14   0xE019             B.N      ??sli_se_driver_cipher_encrypt_setup_2
    991            }
    992          
    993            // Reset context
    994            memset(operation, 0, sizeof(*operation));
   \                     ??sli_se_driver_cipher_encrypt_setup_1: (+1)
   \       0x16   0x2650             MOVS     R6,#+80
   \       0x18   0x2700             MOVS     R7,#+0
   \       0x1A   0x46A0             MOV      R8,R4
   \       0x1C   0x003A             MOVS     R2,R7
   \       0x1E   0x0031             MOVS     R1,R6
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0x.... 0x....      BL       __aeabi_memset
    995          
    996            // Set up context
    997            memcpy(&operation->alg, &alg, sizeof(alg));
   \       0x26   0xF05F 0x0804      MOVS     R8,#+4
   \       0x2A   0xF10D 0x0904      ADD      R9,SP,#+4
   \       0x2E   0xF114 0x0A24      ADDS     R10,R4,#+36
   \       0x32   0x4642             MOV      R2,R8
   \       0x34   0x4649             MOV      R1,R9
   \       0x36   0x4650             MOV      R0,R10
   \       0x38   0x.... 0x....      BL       __aeabi_memcpy
    998            operation->direction = SL_SE_ENCRYPT;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xF884 0x0020      STRB     R0,[R4, #+32]
    999          
   1000            // Validate combination of key and algorithm
   1001            return validate_key_algorithm_match(alg, attributes);
   \       0x42   0x0029             MOVS     R1,R5
   \       0x44   0x9801             LDR      R0,[SP, #+4]
   \       0x46   0x.... 0x....      BL       validate_key_algorithm_match
   \                     ??sli_se_driver_cipher_encrypt_setup_2: (+1)
   \       0x4A   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   1002          
   1003            #else // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1004          
   1005            (void)operation;
   1006            (void)attributes;
   1007            (void)alg;
   1008          
   1009            return PSA_ERROR_NOT_SUPPORTED;
   1010          
   1011            #endif // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1012          }
   1013          

   \                                 In section .text, align 2, keep-with-next
   1014          psa_status_t sli_se_driver_cipher_decrypt_setup(
   1015            sli_se_driver_cipher_operation_t *operation,
   1016            const psa_key_attributes_t *attributes,
   1017            psa_algorithm_t alg)
   1018          {
   \                     sli_se_driver_cipher_decrypt_setup: (+1)
   \        0x0   0xE92D 0x47F6      PUSH     {R1,R2,R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1019            #if defined(SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART)
   1020          
   1021            if (operation == NULL || attributes == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??sli_se_driver_cipher_decrypt_setup_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD102             BNE.N    ??sli_se_driver_cipher_decrypt_setup_1
   1022              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_cipher_decrypt_setup_0: (+1)
   \       0x10   0xF07F 0x0086      MVNS     R0,#+134
   \       0x14   0xE019             B.N      ??sli_se_driver_cipher_decrypt_setup_2
   1023            }
   1024          
   1025            // Reset context
   1026            memset(operation, 0, sizeof(*operation));
   \                     ??sli_se_driver_cipher_decrypt_setup_1: (+1)
   \       0x16   0x2650             MOVS     R6,#+80
   \       0x18   0x2700             MOVS     R7,#+0
   \       0x1A   0x46A0             MOV      R8,R4
   \       0x1C   0x003A             MOVS     R2,R7
   \       0x1E   0x0031             MOVS     R1,R6
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0x.... 0x....      BL       __aeabi_memset
   1027          
   1028            // Set up context
   1029            memcpy(&operation->alg, &alg, sizeof(alg));
   \       0x26   0xF05F 0x0804      MOVS     R8,#+4
   \       0x2A   0xF10D 0x0904      ADD      R9,SP,#+4
   \       0x2E   0xF114 0x0A24      ADDS     R10,R4,#+36
   \       0x32   0x4642             MOV      R2,R8
   \       0x34   0x4649             MOV      R1,R9
   \       0x36   0x4650             MOV      R0,R10
   \       0x38   0x.... 0x....      BL       __aeabi_memcpy
   1030            operation->direction = SL_SE_DECRYPT;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xF884 0x0020      STRB     R0,[R4, #+32]
   1031          
   1032            // Validate combination of key and algorithm
   1033            return validate_key_algorithm_match(alg, attributes);
   \       0x42   0x0029             MOVS     R1,R5
   \       0x44   0x9801             LDR      R0,[SP, #+4]
   \       0x46   0x.... 0x....      BL       validate_key_algorithm_match
   \                     ??sli_se_driver_cipher_decrypt_setup_2: (+1)
   \       0x4A   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   1034          
   1035            #else // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1036          
   1037            (void)operation;
   1038            (void)attributes;
   1039            (void)alg;
   1040          
   1041            return PSA_ERROR_NOT_SUPPORTED;
   1042          
   1043            #endif // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1044          }
   1045          

   \                                 In section .text, align 2, keep-with-next
   1046          psa_status_t sli_se_driver_cipher_set_iv(
   1047            sli_se_driver_cipher_operation_t *operation,
   1048            const uint8_t *iv,
   1049            size_t iv_length)
   1050          {
   \                     sli_se_driver_cipher_set_iv: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1051            #if defined(SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART)
   1052          
   1053            if (operation == NULL || iv == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD001             BEQ.N    ??sli_se_driver_cipher_set_iv_0
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD102             BNE.N    ??sli_se_driver_cipher_set_iv_1
   1054              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_cipher_set_iv_0: (+1)
   \       0x12   0xF07F 0x0086      MVNS     R0,#+134
   \       0x16   0xE05B             B.N      ??sli_se_driver_cipher_set_iv_2
   1055            }
   1056          
   1057            if (iv_length > sizeof(operation->iv)) {
   \                     ??sli_se_driver_cipher_set_iv_1: (+1)
   \       0x18   0x2E11             CMP      R6,#+17
   \       0x1A   0xD302             BCC.N    ??sli_se_driver_cipher_set_iv_3
   1058              // IV can't be larger than what our state can store
   1059              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x1C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x20   0xE056             B.N      ??sli_se_driver_cipher_set_iv_2
   1060            }
   1061          
   1062            if (operation->iv_len != 0) {
   \                     ??sli_se_driver_cipher_set_iv_3: (+1)
   \       0x22   0x6BA0             LDR      R0,[R4, #+56]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD002             BEQ.N    ??sli_se_driver_cipher_set_iv_4
   1063              // IV was set previously
   1064              return PSA_ERROR_BAD_STATE;
   \       0x28   0xF07F 0x0088      MVNS     R0,#+136
   \       0x2C   0xE050             B.N      ??sli_se_driver_cipher_set_iv_2
   1065            }
   1066          
   1067            switch (operation->alg) {
   \                     ??sli_se_driver_cipher_set_iv_4: (+1)
   \       0x2E   0x6A61             LDR      R1,[R4, #+36]
   \       0x30   0x....             LDR.N    R0,??DataTable4
   \       0x32   0x4281             CMP      R1,R0
   \       0x34   0xD01E             BEQ.N    ??sli_se_driver_cipher_set_iv_5
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable5
   \       0x3A   0x4281             CMP      R1,R0
   \       0x3C   0xD01A             BEQ.N    ??sli_se_driver_cipher_set_iv_5
   \       0x3E   0x....             LDR.N    R0,??DataTable4_1
   \       0x40   0x4281             CMP      R1,R0
   \       0x42   0xD010             BEQ.N    ??sli_se_driver_cipher_set_iv_6
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \       0x48   0x4281             CMP      R1,R0
   \       0x4A   0xD013             BEQ.N    ??sli_se_driver_cipher_set_iv_5
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0x50   0x4281             CMP      R1,R0
   \       0x52   0xD00F             BEQ.N    ??sli_se_driver_cipher_set_iv_5
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x58   0x4281             CMP      R1,R0
   \       0x5A   0xD00B             BEQ.N    ??sli_se_driver_cipher_set_iv_5
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \       0x60   0x4281             CMP      R1,R0
   \       0x62   0xD016             BEQ.N    ??sli_se_driver_cipher_set_iv_7
   \       0x64   0xE02F             B.N      ??sli_se_driver_cipher_set_iv_8
   1068              case PSA_ALG_ECB_NO_PADDING:
   1069                if (iv_length > 0) {
   \                     ??sli_se_driver_cipher_set_iv_6: (+1)
   \       0x66   0x2E00             CMP      R6,#+0
   \       0x68   0xD002             BEQ.N    ??sli_se_driver_cipher_set_iv_9
   1070                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x6A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x6E   0xE02F             B.N      ??sli_se_driver_cipher_set_iv_2
   1071                } else {
   1072                  return PSA_SUCCESS;
   \                     ??sli_se_driver_cipher_set_iv_9: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xE02D             B.N      ??sli_se_driver_cipher_set_iv_2
   1073                }
   1074                break;
   1075          
   1076              case PSA_ALG_CTR:   // Explicit fallthrough
   1077              case PSA_ALG_CFB:   // Explicit fallthrough
   1078              case PSA_ALG_OFB:   // Explicit fallthrough
   1079              case PSA_ALG_CBC_NO_PADDING:   // Explicit fallthrough
   1080              case PSA_ALG_CBC_PKCS7:   // Explicit fallthrough
   1081                if (iv_length != 16) {
   \                     ??sli_se_driver_cipher_set_iv_5: (+1)
   \       0x74   0x2E10             CMP      R6,#+16
   \       0x76   0xD002             BEQ.N    ??sli_se_driver_cipher_set_iv_10
   1082                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x78   0xF07F 0x0086      MVNS     R0,#+134
   \       0x7C   0xE028             B.N      ??sli_se_driver_cipher_set_iv_2
   1083                }
   1084                memcpy(operation->iv, iv, iv_length);
   \                     ??sli_se_driver_cipher_set_iv_10: (+1)
   \       0x7E   0x46B1             MOV      R9,R6
   \       0x80   0x002F             MOVS     R7,R5
   \       0x82   0xF114 0x0828      ADDS     R8,R4,#+40
   \       0x86   0x464A             MOV      R2,R9
   \       0x88   0x0039             MOVS     R1,R7
   \       0x8A   0x4640             MOV      R0,R8
   \       0x8C   0x.... 0x....      BL       __aeabi_memcpy
   1085                break;
   \       0x90   0xE01C             B.N      ??sli_se_driver_cipher_set_iv_11
   1086          
   1087              case PSA_ALG_CCM_STAR_NO_TAG:
   1088                // Preformat the IV for CCM*-no-tag here, such that the remainder
   1089                // of the processing for this algorithm boils down to AES-CTR
   1090                if (iv_length != 13) {
   \                     ??sli_se_driver_cipher_set_iv_7: (+1)
   \       0x92   0x2E0D             CMP      R6,#+13
   \       0x94   0xD002             BEQ.N    ??sli_se_driver_cipher_set_iv_12
   1091                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x96   0xF07F 0x0086      MVNS     R0,#+134
   \       0x9A   0xE019             B.N      ??sli_se_driver_cipher_set_iv_2
   1092                }
   1093                operation->iv[0] = 1;
   \                     ??sli_se_driver_cipher_set_iv_12: (+1)
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0xF884 0x0028      STRB     R0,[R4, #+40]
   1094                memcpy(&operation->iv[1], iv, iv_length);
   \       0xA2   0x0037             MOVS     R7,R6
   \       0xA4   0x46A8             MOV      R8,R5
   \       0xA6   0xF114 0x0929      ADDS     R9,R4,#+41
   \       0xAA   0x003A             MOVS     R2,R7
   \       0xAC   0x4641             MOV      R1,R8
   \       0xAE   0x4648             MOV      R0,R9
   \       0xB0   0x.... 0x....      BL       __aeabi_memcpy
   1095                operation->iv[14] = 0;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0xF884 0x0036      STRB     R0,[R4, #+54]
   1096                operation->iv[15] = 1;
   \       0xBA   0x2001             MOVS     R0,#+1
   \       0xBC   0xF884 0x0037      STRB     R0,[R4, #+55]
   1097                iv_length = 16;
   \       0xC0   0x2010             MOVS     R0,#+16
   \       0xC2   0x0006             MOVS     R6,R0
   1098                break;
   \       0xC4   0xE002             B.N      ??sli_se_driver_cipher_set_iv_11
   1099          
   1100                #if defined(SLI_PSA_DRIVER_FEATURE_CHACHA20)
   1101              case PSA_ALG_STREAM_CIPHER:
   1102                // PSA Crypto supports multiple IV input lengths for ChaCha20
   1103                // refer to the doc for PSA_ALG_STREAM_CIPHER
   1104                if (iv_length == 12) {
   1105                  // Set initial counter value to zero
   1106                  memset(operation->iv, 0, 4);
   1107                  memcpy(&operation->iv[4], iv, iv_length);
   1108                } else if (iv_length == 16) {
   1109                  // Initial counter value is stored little-endian in the first four
   1110                  // bytes. This makes our lives easier: since this driver will only
   1111                  // run on little-endian machines, we can just cast it to a uint32.
   1112                  memcpy(operation->iv, iv, iv_length);
   1113                } else if (iv_length == 8) {
   1114                  // "Original" ChaCha20: 8-byte IV and 8-byte counter (0-initialised).
   1115                  // We currently don't support this format.
   1116                  return PSA_ERROR_NOT_SUPPORTED;
   1117                } else {
   1118                  return PSA_ERROR_INVALID_ARGUMENT;
   1119                }
   1120                break;
   1121                #endif // SLI_PSA_DRIVER_FEATURE_CHACHA20
   1122          
   1123              default:
   1124                return PSA_ERROR_BAD_STATE;
   \                     ??sli_se_driver_cipher_set_iv_8: (+1)
   \       0xC6   0xF07F 0x0088      MVNS     R0,#+136
   \       0xCA   0xE001             B.N      ??sli_se_driver_cipher_set_iv_2
   1125            }
   1126          
   1127            operation->iv_len = iv_length;
   \                     ??sli_se_driver_cipher_set_iv_11: (+1)
   \       0xCC   0x63A6             STR      R6,[R4, #+56]
   1128          
   1129            return PSA_SUCCESS;
   \       0xCE   0x2000             MOVS     R0,#+0
   \                     ??sli_se_driver_cipher_set_iv_2: (+1)
   \       0xD0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1130          
   1131            #else // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1132          
   1133            (void)operation;
   1134            (void)iv;
   1135            (void)iv_length;
   1136          
   1137            return PSA_ERROR_NOT_SUPPORTED;
   1138          
   1139            #endif // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1140          }
   1141          

   \                                 In section .text, align 2, keep-with-next
   1142          psa_status_t sli_se_driver_cipher_update(
   1143            sli_se_driver_cipher_operation_t *operation,
   1144            const uint8_t *input,
   1145            size_t input_length,
   1146            uint8_t *output,
   1147            size_t output_size,
   1148            size_t *output_length)
   1149          {
   \                     sli_se_driver_cipher_update: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB091             SUB      SP,SP,#+68
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0x001F             MOVS     R7,R3
   1150            #if defined(SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART)
   1151          
   1152            // Argument check
   1153            if (operation == NULL
   1154                || (input == NULL && input_length > 0)
   1155                || (output == NULL && output_size > 0)
   1156                || output_length == NULL) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD00B             BEQ.N    ??sli_se_driver_cipher_update_0
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD101             BNE.N    ??sli_se_driver_cipher_update_1
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD107             BNE.N    ??sli_se_driver_cipher_update_0
   \                     ??sli_se_driver_cipher_update_1: (+1)
   \       0x1A   0x2F00             CMP      R7,#+0
   \       0x1C   0xD102             BNE.N    ??sli_se_driver_cipher_update_2
   \       0x1E   0x981A             LDR      R0,[SP, #+104]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD102             BNE.N    ??sli_se_driver_cipher_update_0
   \                     ??sli_se_driver_cipher_update_2: (+1)
   \       0x24   0x981B             LDR      R0,[SP, #+108]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE.N    ??sli_se_driver_cipher_update_3
   1157              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_cipher_update_0: (+1)
   \       0x2A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x2E   0xE1FB             B.N      ??sli_se_driver_cipher_update_4
   1158            }
   1159          
   1160            // Key desc has been properly set by wrapper function
   1161            const sl_se_key_descriptor_t *key_desc = &operation->key_desc;
   \                     ??sli_se_driver_cipher_update_3: (+1)
   \       0x30   0x9505             STR      R5,[SP, #+20]
   1162            psa_status_t psa_status = validate_key_type(key_desc);
   \       0x32   0x9805             LDR      R0,[SP, #+20]
   \       0x34   0x.... 0x....      BL       validate_key_type
   \       0x38   0x9007             STR      R0,[SP, #+28]
   1163            if (psa_status != PSA_SUCCESS) {
   \       0x3A   0x9807             LDR      R0,[SP, #+28]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD001             BEQ.N    ??sli_se_driver_cipher_update_5
   1164              return psa_status;
   \       0x40   0x9807             LDR      R0,[SP, #+28]
   \       0x42   0xE1F1             B.N      ??sli_se_driver_cipher_update_4
   1165            }
   1166          
   1167            bool lagging;
   1168            size_t bytes_to_boundary = 16 - (operation->processed_length % 16);
   \                     ??sli_se_driver_cipher_update_5: (+1)
   \       0x44   0xF895 0x804C      LDRB     R8,[R5, #+76]
   \       0x48   0xF018 0x080F      ANDS     R8,R8,#0xF
   \       0x4C   0xF1D8 0x0810      RSBS     R8,R8,#+16
   1169            size_t actual_output_length = 0;
   \       0x50   0xF05F 0x0900      MOVS     R9,#+0
   1170          
   1171            // We need to cache (not return) the whole last block for decryption with
   1172            // padding, otherwise it won't be possible to remove a potential padding
   1173            // block during finish.
   1174            bool cache_full_block = (operation->alg == PSA_ALG_CBC_PKCS7
   1175                                     && operation->direction == SL_SE_DECRYPT);
   \       0x54   0x6A69             LDR      R1,[R5, #+36]
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable5
   \       0x5A   0x4281             CMP      R1,R0
   \       0x5C   0xD106             BNE.N    ??sli_se_driver_cipher_update_6
   \       0x5E   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0xD102             BNE.N    ??sli_se_driver_cipher_update_6
   \       0x66   0xF05F 0x0A01      MOVS     R10,#+1
   \       0x6A   0xE001             B.N      ??sli_se_driver_cipher_update_7
   \                     ??sli_se_driver_cipher_update_6: (+1)
   \       0x6C   0xF05F 0x0A00      MOVS     R10,#+0
   1176          
   1177            // Figure out whether the operation is on a lagging or forward-looking cipher
   1178            // Lagging: needs a full block of input data before being able to output
   1179            // Non-lagging: can output the same amount of data as getting fed
   1180            switch (operation->alg) {
   \                     ??sli_se_driver_cipher_update_7: (+1)
   \       0x70   0x6A69             LDR      R1,[R5, #+36]
   \       0x72   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x76   0x4281             CMP      R1,R0
   \       0x78   0xD018             BEQ.N    ??sli_se_driver_cipher_update_8
   \       0x7A   0x.... 0x....      LDR.W    R0,??DataTable5
   \       0x7E   0x4281             CMP      R1,R0
   \       0x80   0xD014             BEQ.N    ??sli_se_driver_cipher_update_8
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \       0x86   0x4281             CMP      R1,R0
   \       0x88   0xD010             BEQ.N    ??sli_se_driver_cipher_update_8
   \       0x8A   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \       0x8E   0x4281             CMP      R1,R0
   \       0x90   0xD010             BEQ.N    ??sli_se_driver_cipher_update_9
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0x96   0x4281             CMP      R1,R0
   \       0x98   0xD00C             BEQ.N    ??sli_se_driver_cipher_update_9
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x9E   0x4281             CMP      R1,R0
   \       0xA0   0xD008             BEQ.N    ??sli_se_driver_cipher_update_9
   \       0xA2   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \       0xA6   0x4281             CMP      R1,R0
   \       0xA8   0xD004             BEQ.N    ??sli_se_driver_cipher_update_9
   \       0xAA   0xE007             B.N      ??sli_se_driver_cipher_update_10
   1181              case PSA_ALG_ECB_NO_PADDING:
   1182              case PSA_ALG_CBC_NO_PADDING:
   1183              case PSA_ALG_CBC_PKCS7:
   1184                lagging = true;
   \                     ??sli_se_driver_cipher_update_8: (+1)
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xF88D 0x0010      STRB     R0,[SP, #+16]
   1185                break;
   \       0xB2   0xE006             B.N      ??sli_se_driver_cipher_update_11
   1186          
   1187              case PSA_ALG_CTR:
   1188              case PSA_ALG_CCM_STAR_NO_TAG:
   1189              case PSA_ALG_CFB:
   1190              case PSA_ALG_OFB:
   1191                lagging = false;
   \                     ??sli_se_driver_cipher_update_9: (+1)
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0xF88D 0x0010      STRB     R0,[SP, #+16]
   1192                break;
   \       0xBA   0xE002             B.N      ??sli_se_driver_cipher_update_11
   1193          
   1194                #if defined(SLI_PSA_DRIVER_FEATURE_CHACHA20)
   1195              case PSA_ALG_STREAM_CIPHER:
   1196                lagging = false;
   1197                break;
   1198                #endif
   1199          
   1200              default:
   1201                return PSA_ERROR_BAD_STATE;
   \                     ??sli_se_driver_cipher_update_10: (+1)
   \       0xBC   0xF07F 0x0088      MVNS     R0,#+136
   \       0xC0   0xE1B2             B.N      ??sli_se_driver_cipher_update_4
   1202            }
   1203          
   1204            if (input_length == 0) {
   \                     ??sli_se_driver_cipher_update_11: (+1)
   \       0xC2   0x2C00             CMP      R4,#+0
   \       0xC4   0xD104             BNE.N    ??sli_se_driver_cipher_update_12
   1205              // We don't need to do anything if the input length is zero.
   1206              *output_length = 0;
   \       0xC6   0x2100             MOVS     R1,#+0
   \       0xC8   0x981B             LDR      R0,[SP, #+108]
   \       0xCA   0x6001             STR      R1,[R0, #+0]
   1207              return PSA_SUCCESS;
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0xE1AB             B.N      ??sli_se_driver_cipher_update_4
   1208            }
   1209          
   1210            if (lagging) {
   \                     ??sli_se_driver_cipher_update_12: (+1)
   \       0xD0   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD039             BEQ.N    ??sli_se_driver_cipher_update_13
   1211              // Early processing if not getting to a full block
   1212              if (cache_full_block
   1213                  && bytes_to_boundary == 16
   1214                  && operation->processed_length > 0) {
   \       0xD8   0x4650             MOV      R0,R10
   \       0xDA   0xB2C0             UXTB     R0,R0
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD005             BEQ.N    ??sli_se_driver_cipher_update_14
   \       0xE0   0xF1B8 0x0F10      CMP      R8,#+16
   \       0xE4   0xD102             BNE.N    ??sli_se_driver_cipher_update_14
   \       0xE6   0x6CE8             LDR      R0,[R5, #+76]
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD117             BNE.N    ??sli_se_driver_cipher_update_15
   1215                // Don't overwrite the streaming block if it's currently full.
   1216              } else {
   1217                if (input_length < bytes_to_boundary) {
   \                     ??sli_se_driver_cipher_update_14: (+1)
   \       0xEC   0x4544             CMP      R4,R8
   \       0xEE   0xD215             BCS.N    ??sli_se_driver_cipher_update_15
   1218                  memcpy(&operation->streaming_block[operation->processed_length % 16],
   1219                         input,
   1220                         input_length);
   \       0xF0   0x9401             STR      R4,[SP, #+4]
   \       0xF2   0x9600             STR      R6,[SP, #+0]
   \       0xF4   0xF895 0x004C      LDRB     R0,[R5, #+76]
   \       0xF8   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xFC   0x4428             ADD      R0,R5,R0
   \       0xFE   0xF110 0x0B3C      ADDS     R11,R0,#+60
   \      0x102   0x9A01             LDR      R2,[SP, #+4]
   \      0x104   0x9900             LDR      R1,[SP, #+0]
   \      0x106   0x4658             MOV      R0,R11
   \      0x108   0x.... 0x....      BL       __aeabi_memcpy
   1221                  operation->processed_length += input_length;
   \      0x10C   0x6CE8             LDR      R0,[R5, #+76]
   \      0x10E   0x1820             ADDS     R0,R4,R0
   \      0x110   0x64E8             STR      R0,[R5, #+76]
   1222                  *output_length = actual_output_length;
   \      0x112   0x981B             LDR      R0,[SP, #+108]
   \      0x114   0xF8C0 0x9000      STR      R9,[R0, #+0]
   1223                  return PSA_SUCCESS;
   \      0x118   0x2000             MOVS     R0,#+0
   \      0x11A   0xE185             B.N      ??sli_se_driver_cipher_update_4
   1224                }
   1225              }
   1226          
   1227              // We know we'll be computing and outputing at least the completed
   1228              // streaming block.
   1229              size_t output_blocks = 1;
   \                     ??sli_se_driver_cipher_update_15: (+1)
   \      0x11C   0x2101             MOVS     R1,#+1
   1230          
   1231              if (input_length > bytes_to_boundary) {
   \      0x11E   0x45A0             CMP      R8,R4
   \      0x120   0xD20D             BCS.N    ??sli_se_driver_cipher_update_16
   1232                // plus however many full blocks are left over after filling the stream buffer
   1233                output_blocks += (input_length - bytes_to_boundary) / 16;
   \      0x122   0xEBB4 0x0008      SUBS     R0,R4,R8
   \      0x126   0xEB11 0x1110      ADDS     R1,R1,R0, LSR #+4
   1234                // If we're caching and the sum of already-input and to-be-input data
   1235                // ends up at a block boundary, we won't be outputting the last block
   1236                if (cache_full_block && ((input_length - bytes_to_boundary) % 16 == 0)) {
   \      0x12A   0x4650             MOV      R0,R10
   \      0x12C   0xB2C0             UXTB     R0,R0
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD005             BEQ.N    ??sli_se_driver_cipher_update_16
   \      0x132   0xEBB4 0x0008      SUBS     R0,R4,R8
   \      0x136   0xF010 0x0F0F      TST      R0,#0xF
   \      0x13A   0xD100             BNE.N    ??sli_se_driver_cipher_update_16
   1237                  output_blocks -= 1;
   \      0x13C   0x1E49             SUBS     R1,R1,#+1
   1238                }
   1239              }
   1240          
   1241              if (output_size < (output_blocks * 16)) {
   \                     ??sli_se_driver_cipher_update_16: (+1)
   \      0x13E   0x981A             LDR      R0,[SP, #+104]
   \      0x140   0xEBB0 0x1F01      CMP      R0,R1, LSL #+4
   \      0x144   0xD208             BCS.N    ??sli_se_driver_cipher_update_17
   1242                return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x146   0xF07F 0x0089      MVNS     R0,#+137
   \      0x14A   0xE16D             B.N      ??sli_se_driver_cipher_update_4
   1243              }
   1244            } else {
   1245              // Early failure if output buffer is too small
   1246              if (output_size < input_length) {
   \                     ??sli_se_driver_cipher_update_13: (+1)
   \      0x14C   0x981A             LDR      R0,[SP, #+104]
   \      0x14E   0x42A0             CMP      R0,R4
   \      0x150   0xD202             BCS.N    ??sli_se_driver_cipher_update_17
   1247                return PSA_ERROR_BUFFER_TOO_SMALL;
   \      0x152   0xF07F 0x0089      MVNS     R0,#+137
   \      0x156   0xE167             B.N      ??sli_se_driver_cipher_update_4
   1248              }
   1249            }
   1250          
   1251            // Ephemeral contexts
   1252            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_driver_cipher_update_17: (+1)
   \      0x158   0xA808             ADD      R0,SP,#+32
   \      0x15A   0x2124             MOVS     R1,#+36
   \      0x15C   0x.... 0x....      BL       __aeabi_memclr4
   1253          
   1254            sl_status_t status = sl_se_init_command_context(&cmd_ctx);
   \      0x160   0xA808             ADD      R0,SP,#+32
   \      0x162   0x.... 0x....      BL       sl_se_init_command_context
   \      0x166   0x4683             MOV      R11,R0
   1255            if (status != SL_STATUS_OK) {
   \      0x168   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x16C   0xD002             BEQ.N    ??sli_se_driver_cipher_update_18
   1256              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x16E   0xF07F 0x0092      MVNS     R0,#+146
   \      0x172   0xE159             B.N      ??sli_se_driver_cipher_update_4
   1257            }
   1258          
   1259            // Our drivers only support full or no overlap between input and output
   1260            // buffers. So in the case of partial overlap, copy the input buffer into
   1261            // the output buffer and process it in place as if the buffers fully
   1262            // overlapped.
   1263            if ((output > input) && (output < (input + input_length))) {
   \                     ??sli_se_driver_cipher_update_18: (+1)
   \      0x174   0x42BE             CMP      R6,R7
   \      0x176   0xD213             BCS.N    ??sli_se_driver_cipher_update_19
   \      0x178   0xEB06 0x0004      ADD      R0,R6,R4
   \      0x17C   0x4287             CMP      R7,R0
   \      0x17E   0xD20F             BCS.N    ??sli_se_driver_cipher_update_19
   1264              // Sanity check before copying. Some ciphers have a stricter requirement
   1265              // than this (if an IV is included), but no ciphers will have an output
   1266              // smaller than the input.
   1267              if (output_size < input_length) {
   \      0x180   0x981A             LDR      R0,[SP, #+104]
   \      0x182   0x42A0             CMP      R0,R4
   \      0x184   0xD202             BCS.N    ??sli_se_driver_cipher_update_20
   1268                return PSA_ERROR_INVALID_ARGUMENT;
   \      0x186   0xF07F 0x0086      MVNS     R0,#+134
   \      0x18A   0xE14D             B.N      ??sli_se_driver_cipher_update_4
   1269              }
   1270          
   1271              memmove(output, input, input_length);
   \                     ??sli_se_driver_cipher_update_20: (+1)
   \      0x18C   0x9402             STR      R4,[SP, #+8]
   \      0x18E   0x9601             STR      R6,[SP, #+4]
   \      0x190   0x9700             STR      R7,[SP, #+0]
   \      0x192   0x9A02             LDR      R2,[SP, #+8]
   \      0x194   0x9901             LDR      R1,[SP, #+4]
   \      0x196   0x9800             LDR      R0,[SP, #+0]
   \      0x198   0x.... 0x....      BL       __aeabi_memmove
   \      0x19C   0x9800             LDR      R0,[SP, #+0]
   1272              input = output;
   \      0x19E   0x003E             MOVS     R6,R7
   1273            }
   1274          
   1275            switch (operation->alg) {
   \                     ??sli_se_driver_cipher_update_19: (+1)
   \      0x1A0   0x6A69             LDR      R1,[R5, #+36]
   \      0x1A2   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \      0x1A6   0x4281             CMP      R1,R0
   \      0x1A8   0xD05C             BEQ.N    ??sli_se_driver_cipher_update_21
   \      0x1AA   0x....             LDR.N    R0,??DataTable5
   \      0x1AC   0x4281             CMP      R1,R0
   \      0x1AE   0xD059             BEQ.N    ??sli_se_driver_cipher_update_21
   \      0x1B0   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \      0x1B4   0x4281             CMP      R1,R0
   \      0x1B6   0xD008             BEQ.N    ??sli_se_driver_cipher_update_22
   \      0x1B8   0x....             LDR.N    R0,??DataTable5_1
   \      0x1BA   0x4281             CMP      R1,R0
   \      0x1BC   0xF000 0x80D9      BEQ.W    ??sli_se_driver_cipher_update_23
   \      0x1C0   0x....             LDR.N    R0,??DataTable5_2
   \      0x1C2   0x4281             CMP      R1,R0
   \      0x1C4   0xF000 0x80D5      BEQ.W    ??sli_se_driver_cipher_update_23
   \      0x1C8   0xE0F2             B.N      ??sli_se_driver_cipher_update_24
   1276              #if defined(SLI_PSA_DRIVER_FEATURE_AES_ECB)
   1277              case PSA_ALG_ECB_NO_PADDING:
   1278                // Read in up to full streaming input block
   1279                if (bytes_to_boundary != 16) {
   \                     ??sli_se_driver_cipher_update_22: (+1)
   \      0x1CA   0xF1B8 0x0F10      CMP      R8,#+16
   \      0x1CE   0xD029             BEQ.N    ??sli_se_driver_cipher_update_25
   1280                  memcpy(&operation->streaming_block[operation->processed_length % 16],
   1281                         input,
   1282                         bytes_to_boundary);
   \      0x1D0   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \      0x1D4   0x9602             STR      R6,[SP, #+8]
   \      0x1D6   0xF895 0x004C      LDRB     R0,[R5, #+76]
   \      0x1DA   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1DE   0x4428             ADD      R0,R5,R0
   \      0x1E0   0x303C             ADDS     R0,R0,#+60
   \      0x1E2   0x9000             STR      R0,[SP, #+0]
   \      0x1E4   0x9A03             LDR      R2,[SP, #+12]
   \      0x1E6   0x9902             LDR      R1,[SP, #+8]
   \      0x1E8   0x9800             LDR      R0,[SP, #+0]
   \      0x1EA   0x.... 0x....      BL       __aeabi_memcpy
   \      0x1EE   0x9800             LDR      R0,[SP, #+0]
   1283                  input += bytes_to_boundary;
   \      0x1F0   0x4446             ADD      R6,R6,R8
   1284                  input_length -= bytes_to_boundary;
   \      0x1F2   0xEBB4 0x0408      SUBS     R4,R4,R8
   1285          
   1286                  status = sl_se_aes_crypt_ecb(&cmd_ctx,
   1287                                               key_desc,
   1288                                               operation->direction,
   1289                                               16,
   1290                                               operation->streaming_block,
   1291                                               output);
   \      0x1F6   0x9701             STR      R7,[SP, #+4]
   \      0x1F8   0xF115 0x003C      ADDS     R0,R5,#+60
   \      0x1FC   0x9000             STR      R0,[SP, #+0]
   \      0x1FE   0x2310             MOVS     R3,#+16
   \      0x200   0xF895 0x2020      LDRB     R2,[R5, #+32]
   \      0x204   0x9905             LDR      R1,[SP, #+20]
   \      0x206   0xA808             ADD      R0,SP,#+32
   \      0x208   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \      0x20C   0x4683             MOV      R11,R0
   1292                  if (status != SL_STATUS_OK) {
   \      0x20E   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x212   0xF040 0x80F6      BNE.W    ??sli_se_driver_cipher_update_26
   1293                    goto exit;
   1294                  }
   1295          
   1296                  output += 16;
   \                     ??sli_se_driver_cipher_update_27: (+1)
   \      0x216   0x3710             ADDS     R7,R7,#+16
   1297                  actual_output_length += 16;
   \      0x218   0xF119 0x0910      ADDS     R9,R9,#+16
   1298                  operation->processed_length += bytes_to_boundary;
   \      0x21C   0x6CE8             LDR      R0,[R5, #+76]
   \      0x21E   0xEB18 0x0000      ADDS     R0,R8,R0
   \      0x222   0x64E8             STR      R0,[R5, #+76]
   1299                }
   1300          
   1301                // Do multi-block operation if applicable
   1302                if (input_length >= 16) {
   \                     ??sli_se_driver_cipher_update_25: (+1)
   \      0x224   0x2C10             CMP      R4,#+16
   \      0x226   0xD31C             BCC.N    ??sli_se_driver_cipher_update_28
   1303                  size_t operation_size = (input_length / 16) * 16;
   \      0x228   0x0020             MOVS     R0,R4
   \      0x22A   0x0900             LSRS     R0,R0,#+4
   \      0x22C   0x0100             LSLS     R0,R0,#+4
   \      0x22E   0x9002             STR      R0,[SP, #+8]
   1304                  status = sl_se_aes_crypt_ecb(&cmd_ctx,
   1305                                               key_desc,
   1306                                               operation->direction,
   1307                                               operation_size,
   1308                                               input,
   1309                                               output);
   \      0x230   0x9701             STR      R7,[SP, #+4]
   \      0x232   0x9600             STR      R6,[SP, #+0]
   \      0x234   0x9B02             LDR      R3,[SP, #+8]
   \      0x236   0xF895 0x2020      LDRB     R2,[R5, #+32]
   \      0x23A   0x9905             LDR      R1,[SP, #+20]
   \      0x23C   0xA808             ADD      R0,SP,#+32
   \      0x23E   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \      0x242   0x4683             MOV      R11,R0
   1310          
   1311                  if (status != SL_STATUS_OK) {
   \      0x244   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x248   0xF040 0x80DB      BNE.W    ??sli_se_driver_cipher_update_26
   1312                    goto exit;
   1313                  }
   1314          
   1315                  input += operation_size;
   \                     ??sli_se_driver_cipher_update_29: (+1)
   \      0x24C   0x9802             LDR      R0,[SP, #+8]
   \      0x24E   0x4406             ADD      R6,R6,R0
   1316                  input_length -= operation_size;
   \      0x250   0x9802             LDR      R0,[SP, #+8]
   \      0x252   0x1A24             SUBS     R4,R4,R0
   1317                  actual_output_length += operation_size;
   \      0x254   0x9802             LDR      R0,[SP, #+8]
   \      0x256   0xEB10 0x0909      ADDS     R9,R0,R9
   1318                  operation->processed_length += operation_size;
   \      0x25A   0x6CE9             LDR      R1,[R5, #+76]
   \      0x25C   0x9802             LDR      R0,[SP, #+8]
   \      0x25E   0x1841             ADDS     R1,R0,R1
   \      0x260   0x64E9             STR      R1,[R5, #+76]
   1319                }
   1320          
   1321                // What's left over in the input buffer will be cleaned up after switch-case
   1322                break;
   \                     ??sli_se_driver_cipher_update_28: (+1)
   \      0x262   0xE0A8             B.N      ??sli_se_driver_cipher_update_30
   1323              #endif   // SLI_PSA_DRIVER_FEATURE_AES_ECB
   1324          
   1325              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT)
   1326              case PSA_ALG_CBC_NO_PADDING:     // fall through
   1327              case PSA_ALG_CBC_PKCS7:
   1328                if (bytes_to_boundary != 16) {
   \                     ??sli_se_driver_cipher_update_21: (+1)
   \      0x264   0xF1B8 0x0F10      CMP      R8,#+16
   \      0x268   0xD033             BEQ.N    ??sli_se_driver_cipher_update_31
   1329                  memcpy(&operation->streaming_block[operation->processed_length % 16],
   1330                         input,
   1331                         bytes_to_boundary);
   \      0x26A   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \      0x26E   0x9601             STR      R6,[SP, #+4]
   \      0x270   0xF895 0x004C      LDRB     R0,[R5, #+76]
   \      0x274   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x278   0x4428             ADD      R0,R5,R0
   \      0x27A   0x303C             ADDS     R0,R0,#+60
   \      0x27C   0x9000             STR      R0,[SP, #+0]
   \      0x27E   0x9A02             LDR      R2,[SP, #+8]
   \      0x280   0x9901             LDR      R1,[SP, #+4]
   \      0x282   0x9800             LDR      R0,[SP, #+0]
   \      0x284   0x.... 0x....      BL       __aeabi_memcpy
   \      0x288   0x9800             LDR      R0,[SP, #+0]
   1332                  if (cache_full_block && (bytes_to_boundary == input_length)) {
   \      0x28A   0x4650             MOV      R0,R10
   \      0x28C   0xB2C0             UXTB     R0,R0
   \      0x28E   0x2800             CMP      R0,#+0
   \      0x290   0xD001             BEQ.N    ??sli_se_driver_cipher_update_32
   \      0x292   0x45A0             CMP      R8,R4
   \      0x294   0xD015             BEQ.N    ??sli_se_driver_cipher_update_33
   1333                    // Don't process the streaming block if there is no more input data
   1334                  } else {
   1335                    status = sl_se_aes_crypt_cbc(&cmd_ctx,
   1336                                                 key_desc,
   1337                                                 operation->direction,
   1338                                                 16,
   1339                                                 operation->iv,
   1340                                                 operation->streaming_block,
   1341                                                 output);
   \                     ??sli_se_driver_cipher_update_32: (+1)
   \      0x296   0x9702             STR      R7,[SP, #+8]
   \      0x298   0xF115 0x003C      ADDS     R0,R5,#+60
   \      0x29C   0x9001             STR      R0,[SP, #+4]
   \      0x29E   0xF115 0x0028      ADDS     R0,R5,#+40
   \      0x2A2   0x9000             STR      R0,[SP, #+0]
   \      0x2A4   0x2310             MOVS     R3,#+16
   \      0x2A6   0xF895 0x2020      LDRB     R2,[R5, #+32]
   \      0x2AA   0x9905             LDR      R1,[SP, #+20]
   \      0x2AC   0xA808             ADD      R0,SP,#+32
   \      0x2AE   0x.... 0x....      BL       sl_se_aes_crypt_cbc
   \      0x2B2   0x4683             MOV      R11,R0
   1342                    if (status != PSA_SUCCESS) {
   \      0x2B4   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x2B8   0xF040 0x80A3      BNE.W    ??sli_se_driver_cipher_update_26
   1343                      goto exit;
   1344                    }
   1345                    output += 16;
   \                     ??sli_se_driver_cipher_update_34: (+1)
   \      0x2BC   0x3710             ADDS     R7,R7,#+16
   1346                    actual_output_length += 16;
   \      0x2BE   0xF119 0x0910      ADDS     R9,R9,#+16
   1347                  }
   1348          
   1349                  input += bytes_to_boundary;
   \                     ??sli_se_driver_cipher_update_33: (+1)
   \      0x2C2   0x4446             ADD      R6,R6,R8
   1350                  input_length -= bytes_to_boundary;
   \      0x2C4   0xEBB4 0x0408      SUBS     R4,R4,R8
   1351                  operation->processed_length += bytes_to_boundary;
   \      0x2C8   0x6CE8             LDR      R0,[R5, #+76]
   \      0x2CA   0xEB18 0x0000      ADDS     R0,R8,R0
   \      0x2CE   0x64E8             STR      R0,[R5, #+76]
   \      0x2D0   0xE01D             B.N      ??sli_se_driver_cipher_update_35
   1352                } else if (input_length > 0
   1353                           && cache_full_block
   1354                           && operation->processed_length > 0) {
   \                     ??sli_se_driver_cipher_update_31: (+1)
   \      0x2D2   0x2C00             CMP      R4,#+0
   \      0x2D4   0xD01B             BEQ.N    ??sli_se_driver_cipher_update_35
   \      0x2D6   0x4650             MOV      R0,R10
   \      0x2D8   0xB2C0             UXTB     R0,R0
   \      0x2DA   0x2800             CMP      R0,#+0
   \      0x2DC   0xD017             BEQ.N    ??sli_se_driver_cipher_update_35
   \      0x2DE   0x6CE8             LDR      R0,[R5, #+76]
   \      0x2E0   0x2800             CMP      R0,#+0
   \      0x2E2   0xD014             BEQ.N    ??sli_se_driver_cipher_update_35
   1355                  // We know there's processing to be done, and that we haven't processed
   1356                  // the full block in the streaming buffer yet. Process it now.
   1357                  status = sl_se_aes_crypt_cbc(&cmd_ctx,
   1358                                               key_desc,
   1359                                               operation->direction,
   1360                                               16,
   1361                                               operation->iv,
   1362                                               operation->streaming_block,
   1363                                               output);
   \      0x2E4   0x9702             STR      R7,[SP, #+8]
   \      0x2E6   0xF115 0x003C      ADDS     R0,R5,#+60
   \      0x2EA   0x9001             STR      R0,[SP, #+4]
   \      0x2EC   0xF115 0x0028      ADDS     R0,R5,#+40
   \      0x2F0   0x9000             STR      R0,[SP, #+0]
   \      0x2F2   0x2310             MOVS     R3,#+16
   \      0x2F4   0xF895 0x2020      LDRB     R2,[R5, #+32]
   \      0x2F8   0x9905             LDR      R1,[SP, #+20]
   \      0x2FA   0xA808             ADD      R0,SP,#+32
   \      0x2FC   0x.... 0x....      BL       sl_se_aes_crypt_cbc
   \      0x300   0x4683             MOV      R11,R0
   1364                  if (status != PSA_SUCCESS) {
   \      0x302   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x306   0xD17C             BNE.N    ??sli_se_driver_cipher_update_26
   1365                    goto exit;
   1366                  }
   1367                  output += 16;
   \                     ??sli_se_driver_cipher_update_36: (+1)
   \      0x308   0x3710             ADDS     R7,R7,#+16
   1368                  actual_output_length += 16;
   \      0x30A   0xF119 0x0910      ADDS     R9,R9,#+16
   1369                }
   1370          
   1371                // Do multi-block operation if applicable
   1372                if (input_length >= 16) {
   \                     ??sli_se_driver_cipher_update_35: (+1)
   \      0x30E   0x2C10             CMP      R4,#+16
   \      0x310   0xD32E             BCC.N    ??sli_se_driver_cipher_update_37
   1373                  size_t operation_size = (input_length / 16) * 16;
   \      0x312   0x0020             MOVS     R0,R4
   \      0x314   0x0900             LSRS     R0,R0,#+4
   \      0x316   0x0100             LSLS     R0,R0,#+4
   \      0x318   0x9003             STR      R0,[SP, #+12]
   1374                  if (cache_full_block && (input_length % 16 == 0)) {
   \      0x31A   0x4650             MOV      R0,R10
   \      0x31C   0xB2C0             UXTB     R0,R0
   \      0x31E   0x2800             CMP      R0,#+0
   \      0x320   0xD005             BEQ.N    ??sli_se_driver_cipher_update_38
   \      0x322   0xF014 0x0F0F      TST      R4,#0xF
   \      0x326   0xD102             BNE.N    ??sli_se_driver_cipher_update_38
   1375                    // Don't decrypt the last block until finish is called, so that we
   1376                    // can properly remove the padding before returning it.
   1377                    operation_size -= 16;
   \      0x328   0x9803             LDR      R0,[SP, #+12]
   \      0x32A   0x3810             SUBS     R0,R0,#+16
   \      0x32C   0x9003             STR      R0,[SP, #+12]
   1378                  }
   1379          
   1380                  if (operation_size > 0) {
   \                     ??sli_se_driver_cipher_update_38: (+1)
   \      0x32E   0x9803             LDR      R0,[SP, #+12]
   \      0x330   0x2800             CMP      R0,#+0
   \      0x332   0xD010             BEQ.N    ??sli_se_driver_cipher_update_39
   1381                    status = sl_se_aes_crypt_cbc(&cmd_ctx,
   1382                                                 key_desc,
   1383                                                 operation->direction,
   1384                                                 operation_size,
   1385                                                 operation->iv,
   1386                                                 input,
   1387                                                 output);
   \      0x334   0x9702             STR      R7,[SP, #+8]
   \      0x336   0x9601             STR      R6,[SP, #+4]
   \      0x338   0xF115 0x0028      ADDS     R0,R5,#+40
   \      0x33C   0x9000             STR      R0,[SP, #+0]
   \      0x33E   0x9B03             LDR      R3,[SP, #+12]
   \      0x340   0xF895 0x2020      LDRB     R2,[R5, #+32]
   \      0x344   0x9905             LDR      R1,[SP, #+20]
   \      0x346   0xA808             ADD      R0,SP,#+32
   \      0x348   0x.... 0x....      BL       sl_se_aes_crypt_cbc
   \      0x34C   0x4683             MOV      R11,R0
   1388                    if (status != PSA_SUCCESS) {
   \      0x34E   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x352   0xD002             BEQ.N    ??sli_se_driver_cipher_update_40
   1389                      goto exit;
   \      0x354   0xE055             B.N      ??sli_se_driver_cipher_update_26
   1390                    }
   1391                  } else {
   1392                    status = PSA_SUCCESS;
   \                     ??sli_se_driver_cipher_update_39: (+1)
   \      0x356   0x2000             MOVS     R0,#+0
   \      0x358   0x4683             MOV      R11,R0
   1393                  }
   1394          
   1395                  input += operation_size;
   \                     ??sli_se_driver_cipher_update_40: (+1)
   \      0x35A   0x9803             LDR      R0,[SP, #+12]
   \      0x35C   0x4406             ADD      R6,R6,R0
   1396                  input_length -= operation_size;
   \      0x35E   0x9803             LDR      R0,[SP, #+12]
   \      0x360   0x1A24             SUBS     R4,R4,R0
   1397                  actual_output_length += operation_size;
   \      0x362   0x9803             LDR      R0,[SP, #+12]
   \      0x364   0xEB10 0x0909      ADDS     R9,R0,R9
   1398                  operation->processed_length += operation_size;
   \      0x368   0x6CE9             LDR      R1,[R5, #+76]
   \      0x36A   0x9803             LDR      R0,[SP, #+12]
   \      0x36C   0x1841             ADDS     R1,R0,R1
   \      0x36E   0x64E9             STR      R1,[R5, #+76]
   1399                }
   1400          
   1401                // What's left over in the input buffer will be cleaned up after switch-case
   1402                break;
   \                     ??sli_se_driver_cipher_update_37: (+1)
   \      0x370   0xE021             B.N      ??sli_se_driver_cipher_update_30
   1403              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT
   1404          
   1405              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG)
   1406              case PSA_ALG_CCM_STAR_NO_TAG:     // Explicit fallthrough
   1407              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CCM_STAR_NO_TAG
   1408          
   1409              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CTR_VARIANT)
   1410              case PSA_ALG_CTR:
   1411              {
   1412                uint32_t offset = operation->processed_length % 16;
   \                     ??sli_se_driver_cipher_update_23: (+1)
   \      0x372   0xF895 0x004C      LDRB     R0,[R5, #+76]
   \      0x376   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x37A   0x9006             STR      R0,[SP, #+24]
   1413          
   1414                status = sl_se_aes_crypt_ctr(&cmd_ctx,
   1415                                             key_desc,
   1416                                             input_length,
   1417                                             &offset,
   1418                                             operation->iv,
   1419                                             operation->streaming_block,
   1420                                             input,
   1421                                             output);
   \      0x37C   0x9703             STR      R7,[SP, #+12]
   \      0x37E   0x9602             STR      R6,[SP, #+8]
   \      0x380   0xF115 0x003C      ADDS     R0,R5,#+60
   \      0x384   0x9001             STR      R0,[SP, #+4]
   \      0x386   0xF115 0x0028      ADDS     R0,R5,#+40
   \      0x38A   0x9000             STR      R0,[SP, #+0]
   \      0x38C   0xAB06             ADD      R3,SP,#+24
   \      0x38E   0x0022             MOVS     R2,R4
   \      0x390   0x9905             LDR      R1,[SP, #+20]
   \      0x392   0xA808             ADD      R0,SP,#+32
   \      0x394   0x.... 0x....      BL       sl_se_aes_crypt_ctr
   \      0x398   0x4683             MOV      R11,R0
   1422          
   1423                if (status != SL_STATUS_OK) {
   \      0x39A   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x39E   0xD130             BNE.N    ??sli_se_driver_cipher_update_26
   1424                  goto exit;
   1425                }
   1426          
   1427                input += input_length;
   \                     ??sli_se_driver_cipher_update_41: (+1)
   \      0x3A0   0x4426             ADD      R6,R6,R4
   1428                actual_output_length += input_length;
   \      0x3A2   0xEB14 0x0909      ADDS     R9,R4,R9
   1429                operation->processed_length += input_length;
   \      0x3A6   0x6CE8             LDR      R0,[R5, #+76]
   \      0x3A8   0x1820             ADDS     R0,R4,R0
   \      0x3AA   0x64E8             STR      R0,[R5, #+76]
   1430                input_length -= input_length;
   \      0x3AC   0x1B24             SUBS     R4,R4,R4
   1431                break;
   \      0x3AE   0xE002             B.N      ??sli_se_driver_cipher_update_30
   1432              }
   1433              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CTR_VARIANT
   1434          
   1435              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CFB)
   1436              case PSA_ALG_CFB:
   1437              {
   1438                uint32_t offset = operation->processed_length % 16;
   1439                status = sl_se_aes_crypt_cfb128(&cmd_ctx,
   1440                                                key_desc,
   1441                                                operation->direction,
   1442                                                input_length,
   1443                                                &offset,
   1444                                                operation->iv,
   1445                                                input,
   1446                                                output);
   1447          
   1448                if (status != SL_STATUS_OK) {
   1449                  goto exit;
   1450                }
   1451          
   1452                input += input_length;
   1453                actual_output_length += input_length;
   1454                operation->processed_length += input_length;
   1455                input_length -= input_length;
   1456                break;
   1457              }
   1458              #endif   // SLI_PSA_DRIVER_FEATURE_AES_CFB
   1459          
   1460              #if defined(SLI_PSA_DRIVER_FEATURE_AES_OFB)
   1461              case PSA_ALG_OFB:
   1462              {
   1463                size_t data_length = input_length;
   1464                size_t n = operation->processed_length % 16;
   1465          
   1466                // loop over input data to create output
   1467                while (data_length--) {
   1468                  if (n == 0) {
   1469                    status = sl_se_aes_crypt_ecb(&cmd_ctx,
   1470                                                 key_desc,
   1471                                                 SL_SE_ENCRYPT,
   1472                                                 16,
   1473                                                 operation->iv,
   1474                                                 operation->iv);
   1475                    if (status != SL_STATUS_OK) {
   1476                      goto exit;
   1477                    }
   1478                  }
   1479                  *output++ =  *input++ ^ operation->iv[n];
   1480          
   1481                  n = (n + 1) & 0x0F;
   1482                }
   1483          
   1484                input += input_length;
   1485                actual_output_length += input_length;
   1486                operation->processed_length += input_length;
   1487                input_length -= input_length;
   1488                break;
   1489              }
   1490              #endif   // SLI_PSA_DRIVER_FEATURE_AES_OFB
   1491          
   1492              #if defined(SLI_PSA_DRIVER_FEATURE_CHACHA20)
   1493              case PSA_ALG_STREAM_CIPHER:
   1494              {
   1495                // counter value is at the start of the IV buffer
   1496                uint32_t ctr_value = *((uint32_t*)operation->iv);
   1497          
   1498                // If the counter would wrap, refuse the operation
   1499                if (ctr_value > (ctr_value + (input_length / 64))) {
   1500                  return PSA_ERROR_BAD_STATE;
   1501                }
   1502          
   1503                if (operation->processed_length % 64 != 0) {
   1504                  // Perform partial block operation until block boundary or end of input
   1505                  uint8_t chacha20_block[64] = { 0 };
   1506                  size_t offset_in_block = operation->processed_length
   1507                                           % sizeof(chacha20_block);
   1508                  size_t length_in_block =
   1509                    input_length < (sizeof(chacha20_block) - offset_in_block)
   1510                    ? input_length
   1511                    : (sizeof(chacha20_block) - offset_in_block);
   1512                  uint32_t counter_bytes = __REV(ctr_value);
   1513          
   1514                  // Retrieve streaming block
   1515                  status = sl_se_chacha20_crypt(&cmd_ctx,
   1516                                                SL_SE_ENCRYPT,
   1517                                                key_desc,
   1518                                                sizeof(chacha20_block),
   1519                                                (const unsigned char*)&counter_bytes,
   1520                                                &operation->iv[4],
   1521                                                chacha20_block,
   1522                                                chacha20_block);
   1523          
   1524                  if (status != SL_STATUS_OK) {
   1525                    goto exit;
   1526                  }
   1527          
   1528                  // Calculate stream output
   1529                  for (size_t i = 0; i < length_in_block; i++) {
   1530                    output[i] = input[i] ^ chacha20_block[offset_in_block + i];
   1531                  }
   1532          
   1533                  input += length_in_block;
   1534                  actual_output_length += length_in_block;
   1535                  operation->processed_length += length_in_block;
   1536                  input_length -= length_in_block;
   1537          
   1538                  // Update the counter if the block is complete
   1539                  if (offset_in_block + length_in_block == sizeof(chacha20_block)) {
   1540                    ctr_value++;
   1541                  }
   1542                }
   1543          
   1544                if (input_length > 0) {
   1545                  // Perform remainder of operation in a single call
   1546                  uint32_t counter_bytes = __REV(ctr_value);
   1547          
   1548                  status = sl_se_chacha20_crypt(&cmd_ctx,
   1549                                                SL_SE_ENCRYPT,
   1550                                                key_desc,
   1551                                                input_length,
   1552                                                (const unsigned char*)&counter_bytes,
   1553                                                &operation->iv[4],
   1554                                                input,
   1555                                                &output[actual_output_length]);
   1556          
   1557                  if (status != SL_STATUS_OK) {
   1558                    goto exit;
   1559                  }
   1560          
   1561                  // Update the counter with the amount of full blocks processed
   1562                  ctr_value += input_length / 64;
   1563          
   1564                  input += input_length;
   1565                  actual_output_length += input_length;
   1566                  operation->processed_length += input_length;
   1567                  input_length -= input_length;
   1568                }
   1569          
   1570                // Store the updated counter number to the IV buffer
   1571                *((uint32_t*)operation->iv) = ctr_value;
   1572                break;
   1573              }
   1574              #endif   // SLI_PSA_DRIVER_FEATURE_CHACHA20
   1575          
   1576              default:
   1577                return PSA_ERROR_BAD_STATE;
   \                     ??sli_se_driver_cipher_update_24: (+1)
   \      0x3B0   0xF07F 0x0088      MVNS     R0,#+136
   \      0x3B4   0xE038             B.N      ??sli_se_driver_cipher_update_4
   1578            }
   1579          
   1580            // If there's anything left in the input buffer, copy it to the context
   1581            // This'll only be the case for lagging ciphers
   1582            if (input_length > 0) {
   \                     ??sli_se_driver_cipher_update_30: (+1)
   \      0x3B6   0x2C00             CMP      R4,#+0
   \      0x3B8   0xD023             BEQ.N    ??sli_se_driver_cipher_update_26
   1583              if (!lagging
   1584                  || (input_length >= 16 && !cache_full_block)
   1585                  || (input_length > 16 && cache_full_block)) {
   \      0x3BA   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \      0x3BE   0x2800             CMP      R0,#+0
   \      0x3C0   0xD00B             BEQ.N    ??sli_se_driver_cipher_update_42
   \      0x3C2   0x2C10             CMP      R4,#+16
   \      0x3C4   0xD303             BCC.N    ??sli_se_driver_cipher_update_43
   \      0x3C6   0x4650             MOV      R0,R10
   \      0x3C8   0xB2C0             UXTB     R0,R0
   \      0x3CA   0x2800             CMP      R0,#+0
   \      0x3CC   0xD005             BEQ.N    ??sli_se_driver_cipher_update_42
   \                     ??sli_se_driver_cipher_update_43: (+1)
   \      0x3CE   0x2C11             CMP      R4,#+17
   \      0x3D0   0xD309             BCC.N    ??sli_se_driver_cipher_update_44
   \      0x3D2   0x4650             MOV      R0,R10
   \      0x3D4   0xB2C0             UXTB     R0,R0
   \      0x3D6   0x2800             CMP      R0,#+0
   \      0x3D8   0xD005             BEQ.N    ??sli_se_driver_cipher_update_44
   1586                *output_length = 0;
   \                     ??sli_se_driver_cipher_update_42: (+1)
   \      0x3DA   0x2100             MOVS     R1,#+0
   \      0x3DC   0x981B             LDR      R0,[SP, #+108]
   \      0x3DE   0x6001             STR      R1,[R0, #+0]
   1587                return PSA_ERROR_BAD_STATE;
   \      0x3E0   0xF07F 0x0088      MVNS     R0,#+136
   \      0x3E4   0xE020             B.N      ??sli_se_driver_cipher_update_4
   1588              }
   1589          
   1590              memcpy(operation->streaming_block,
   1591                     input,
   1592                     input_length);
   \                     ??sli_se_driver_cipher_update_44: (+1)
   \      0x3E6   0x9402             STR      R4,[SP, #+8]
   \      0x3E8   0x9601             STR      R6,[SP, #+4]
   \      0x3EA   0xF115 0x003C      ADDS     R0,R5,#+60
   \      0x3EE   0x9000             STR      R0,[SP, #+0]
   \      0x3F0   0x9A02             LDR      R2,[SP, #+8]
   \      0x3F2   0x9901             LDR      R1,[SP, #+4]
   \      0x3F4   0x9800             LDR      R0,[SP, #+0]
   \      0x3F6   0x.... 0x....      BL       __aeabi_memcpy
   \      0x3FA   0x9800             LDR      R0,[SP, #+0]
   1593              operation->processed_length += input_length;
   \      0x3FC   0x6CE8             LDR      R0,[R5, #+76]
   \      0x3FE   0x1820             ADDS     R0,R4,R0
   \      0x400   0x64E8             STR      R0,[R5, #+76]
   1594            }
   1595          
   1596            exit:
   1597            if (status != SL_STATUS_OK) {
   \                     ??sli_se_driver_cipher_update_26: (+1)
   \      0x402   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x406   0xD00B             BEQ.N    ??sli_se_driver_cipher_update_45
   1598              *output_length = 0;
   \      0x408   0x2100             MOVS     R1,#+0
   \      0x40A   0x981B             LDR      R0,[SP, #+108]
   \      0x40C   0x6001             STR      R1,[R0, #+0]
   1599              if (status == SL_STATUS_FAIL) {
   \      0x40E   0xF1BB 0x0F01      CMP      R11,#+1
   \      0x412   0xD102             BNE.N    ??sli_se_driver_cipher_update_46
   1600                // This specific code maps to 'does not exist' for builtin keys
   1601                return PSA_ERROR_DOES_NOT_EXIST;
   \      0x414   0xF07F 0x008B      MVNS     R0,#+139
   \      0x418   0xE006             B.N      ??sli_se_driver_cipher_update_4
   1602              } else {
   1603                return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_cipher_update_46: (+1)
   \      0x41A   0xF07F 0x0092      MVNS     R0,#+146
   \      0x41E   0xE003             B.N      ??sli_se_driver_cipher_update_4
   1604              }
   1605            } else {
   1606              *output_length = actual_output_length;
   \                     ??sli_se_driver_cipher_update_45: (+1)
   \      0x420   0x981B             LDR      R0,[SP, #+108]
   \      0x422   0xF8C0 0x9000      STR      R9,[R0, #+0]
   1607              return PSA_SUCCESS;
   \      0x426   0x2000             MOVS     R0,#+0
   \                     ??sli_se_driver_cipher_update_4: (+1)
   \      0x428   0xB011             ADD      SP,SP,#+68
   \      0x42A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1608            }
   1609          
   1610            #else // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1611          
   1612            (void)operation;
   1613            (void)input;
   1614            (void)input_length;
   1615            (void)output;
   1616            (void)output_size;
   1617            (void)output_length;
   1618          
   1619            return PSA_ERROR_NOT_SUPPORTED;
   1620          
   1621            #endif // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1622          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
   1623          

   \                                 In section .text, align 2, keep-with-next
   1624          psa_status_t sli_se_driver_cipher_finish(
   1625            sli_se_driver_cipher_operation_t *operation,
   1626            uint8_t *output,
   1627            size_t output_size,
   1628            size_t *output_length)
   1629          {
   \                     sli_se_driver_cipher_finish: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1630            #if defined(SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART)
   1631          
   1632            // Finalize cipher operation. This will only output data for algorithms
   1633            // which include padding. This is currently only AES-CBC with PKCS#7.
   1634          
   1635            // Argument check
   1636            if (operation == NULL
   1637                || (output == NULL && output_size > 0)
   1638                || output_length == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD005             BEQ.N    ??sli_se_driver_cipher_finish_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD101             BNE.N    ??sli_se_driver_cipher_finish_1
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD101             BNE.N    ??sli_se_driver_cipher_finish_0
   \                     ??sli_se_driver_cipher_finish_1: (+1)
   \       0x18   0x2F00             CMP      R7,#+0
   \       0x1A   0xD102             BNE.N    ??sli_se_driver_cipher_finish_2
   1639              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_cipher_finish_0: (+1)
   \       0x1C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x20   0xE033             B.N      ??sli_se_driver_cipher_finish_3
   1640            }
   1641          
   1642            // Key desc has been properly set by wrapper function
   1643            const sl_se_key_descriptor_t *key_desc = &operation->key_desc;
   \                     ??sli_se_driver_cipher_finish_2: (+1)
   \       0x22   0x46A0             MOV      R8,R4
   1644            psa_status_t psa_status = validate_key_type(key_desc);
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x.... 0x....      BL       validate_key_type
   1645            if (psa_status != PSA_SUCCESS) {
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD12D             BNE.N    ??sli_se_driver_cipher_finish_3
   1646              return psa_status;
   1647            }
   1648          
   1649            switch (operation->alg) {
   \                     ??sli_se_driver_cipher_finish_4: (+1)
   \       0x2E   0x6A62             LDR      R2,[R4, #+36]
   \       0x30   0x....             LDR.N    R1,??DataTable6_3
   \       0x32   0x428A             CMP      R2,R1
   \       0x34   0xD012             BEQ.N    ??sli_se_driver_cipher_finish_5
   \       0x36   0x....             LDR.N    R1,??DataTable6_4
   \       0x38   0x428A             CMP      R2,R1
   \       0x3A   0xD00F             BEQ.N    ??sli_se_driver_cipher_finish_5
   \       0x3C   0x....             LDR.N    R1,??DataTable6_5
   \       0x3E   0x428A             CMP      R2,R1
   \       0x40   0xD018             BEQ.N    ??sli_se_driver_cipher_finish_6
   \       0x42   0x....             LDR.N    R1,??DataTable6_6
   \       0x44   0x428A             CMP      R2,R1
   \       0x46   0xD015             BEQ.N    ??sli_se_driver_cipher_finish_6
   \       0x48   0x....             LDR.N    R1,??DataTable6_1
   \       0x4A   0x428A             CMP      R2,R1
   \       0x4C   0xD012             BEQ.N    ??sli_se_driver_cipher_finish_6
   \       0x4E   0x....             LDR.N    R1,??DataTable6_2
   \       0x50   0x428A             CMP      R2,R1
   \       0x52   0xD00F             BEQ.N    ??sli_se_driver_cipher_finish_6
   \       0x54   0x....             LDR.N    R1,??DataTable6_7
   \       0x56   0x428A             CMP      R2,R1
   \       0x58   0xD00C             BEQ.N    ??sli_se_driver_cipher_finish_6
   \       0x5A   0xE00F             B.N      ??sli_se_driver_cipher_finish_7
   1650              #if defined(SLI_PSA_DRIVER_FEATURE_AES_ECB) || defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT)
   1651              case PSA_ALG_ECB_NO_PADDING:     // Explicit fallthrough
   1652              case PSA_ALG_CBC_NO_PADDING:
   1653                // No-padding operations can't finish if they haven't processed block-size input
   1654                *output_length = 0;
   \                     ??sli_se_driver_cipher_finish_5: (+1)
   \       0x5C   0x2100             MOVS     R1,#+0
   \       0x5E   0x6039             STR      R1,[R7, #+0]
   1655                if (operation->processed_length % 16 != 0) {
   \       0x60   0xF894 0x104C      LDRB     R1,[R4, #+76]
   \       0x64   0xF011 0x0F0F      TST      R1,#0xF
   \       0x68   0xD002             BEQ.N    ??sli_se_driver_cipher_finish_8
   1656                  psa_status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x6A   0xF07F 0x0186      MVNS     R1,#+134
   \       0x6E   0xE000             B.N      ??sli_se_driver_cipher_finish_9
   1657                } else {
   1658                  psa_status = PSA_SUCCESS;
   \                     ??sli_se_driver_cipher_finish_8: (+1)
   \       0x70   0x2100             MOVS     R1,#+0
   1659                }
   1660                break;
   \                     ??sli_se_driver_cipher_finish_9: (+1)
   \       0x72   0xE005             B.N      ??sli_se_driver_cipher_finish_10
   1661              #endif // SLI_PSA_DRIVER_FEATURE_AES_ECB || SLI_PSA_DRIVER_FEATURE_AES_CBC_VARIANT
   1662          
   1663              #if defined(SLI_PSA_DRIVER_FEATURE_AES_CBC_PKCS7)
   1664              case PSA_ALG_CBC_PKCS7:
   1665              {
   1666                // Ephemeral contexts
   1667                sl_se_command_context_t cmd_ctx = { 0 };
   1668          
   1669                sl_status_t status = sl_se_init_command_context(&cmd_ctx);
   1670                if (status != SL_STATUS_OK) {
   1671                  psa_status = PSA_ERROR_HARDWARE_FAILURE;
   1672                  break;
   1673                }
   1674          
   1675                // Calculate padding, update, output final block
   1676                if (operation->direction == SL_SE_ENCRYPT) {
   1677                  if (output_size < 16) {
   1678                    psa_status = PSA_ERROR_BUFFER_TOO_SMALL;
   1679                    break;
   1680                  }
   1681                  size_t padding_bytes = 16 - (operation->processed_length % 16);
   1682                  memset(&operation->streaming_block[16 - padding_bytes],
   1683                         padding_bytes,
   1684                         padding_bytes);
   1685          
   1686                  status = sl_se_aes_crypt_cbc(&cmd_ctx,
   1687                                               key_desc,
   1688                                               SL_SE_ENCRYPT,
   1689                                               16,
   1690                                               operation->iv,
   1691                                               operation->streaming_block,
   1692                                               output);
   1693                  if (status != SL_STATUS_OK) {
   1694                    *output_length = 0;
   1695                    psa_status = PSA_ERROR_HARDWARE_FAILURE;
   1696                  } else {
   1697                    *output_length = 16;
   1698                    psa_status = PSA_SUCCESS;
   1699                  }
   1700                } else {
   1701                  // Expect full-block input
   1702                  if (operation->processed_length % 16 != 0
   1703                      || operation->processed_length < 16) {
   1704                    psa_status = PSA_ERROR_INVALID_ARGUMENT;
   1705                    break;
   1706                  }
   1707          
   1708                  uint8_t out_buf[16];
   1709          
   1710                  // Decrypt the last block
   1711                  status = sl_se_aes_crypt_cbc(&cmd_ctx,
   1712                                               key_desc,
   1713                                               SL_SE_DECRYPT,
   1714                                               16,
   1715                                               operation->iv,
   1716                                               operation->streaming_block,
   1717                                               out_buf);
   1718          
   1719                  if (status != SL_STATUS_OK) {
   1720                    *output_length = 0;
   1721                    psa_status = PSA_ERROR_HARDWARE_FAILURE;
   1722                    break;
   1723                  } else {
   1724                    psa_status = PSA_SUCCESS;
   1725                  }
   1726          
   1727                  size_t padding_bytes = 0;
   1728                  psa_status = sli_psa_validate_pkcs7_padding(out_buf,
   1729                                                              16,
   1730                                                              &padding_bytes);
   1731          
   1732                  if (psa_status == PSA_SUCCESS) {
   1733                    // The padding was valid
   1734                    if (output_size < 16 - padding_bytes) {
   1735                      psa_status = PSA_ERROR_BUFFER_TOO_SMALL;
   1736                      break;
   1737                    }
   1738                    memcpy(output, out_buf, 16 - padding_bytes);
   1739                    *output_length = 16 - padding_bytes;
   1740                  }
   1741                }
   1742              }
   1743              break;
   1744              #endif // SLI_PSA_DRIVER_FEATURE_AES_CBC_PKCS7
   1745          
   1746              case PSA_ALG_CTR:
   1747              case PSA_ALG_CCM_STAR_NO_TAG:
   1748              case PSA_ALG_CFB:
   1749              case PSA_ALG_OFB:
   1750              case PSA_ALG_STREAM_CIPHER:
   1751                // Actual stream ciphers: nothing to do here.
   1752                *output_length = 0;
   \                     ??sli_se_driver_cipher_finish_6: (+1)
   \       0x74   0x2100             MOVS     R1,#+0
   \       0x76   0x6039             STR      R1,[R7, #+0]
   1753                psa_status = PSA_SUCCESS;
   \       0x78   0x2100             MOVS     R1,#+0
   1754                break;
   \       0x7A   0xE001             B.N      ??sli_se_driver_cipher_finish_10
   1755          
   1756              default:
   1757                psa_status = PSA_ERROR_BAD_STATE;
   \                     ??sli_se_driver_cipher_finish_7: (+1)
   \       0x7C   0xF07F 0x0188      MVNS     R1,#+136
   1758            }
   1759            if (psa_status != PSA_SUCCESS) {
   \                     ??sli_se_driver_cipher_finish_10: (+1)
   \       0x80   0x2900             CMP      R1,#+0
   \       0x82   0xD001             BEQ.N    ??sli_se_driver_cipher_finish_11
   1760              *output_length = 0;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x6038             STR      R0,[R7, #+0]
   1761            }
   1762            return psa_status;
   \                     ??sli_se_driver_cipher_finish_11: (+1)
   \       0x88   0x0008             MOVS     R0,R1
   \                     ??sli_se_driver_cipher_finish_3: (+1)
   \       0x8A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1763          
   1764            #else // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1765          
   1766            (void)operation;
   1767            (void)output;
   1768            (void)output_size;
   1769            (void)output_length;
   1770          
   1771            return PSA_ERROR_NOT_SUPPORTED;
   1772          
   1773            #endif // SLI_PSA_DRIVER_FEATURE_CIPHER_MULTIPART
   1774          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x0440'4000        DC32     0x4404000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x0440'4400        DC32     0x4404400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x04C0'1300        DC32     0x4c01300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x0440'4100        DC32     0x4404100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x04C0'1000        DC32     0x4c01000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x04C0'1300        DC32     0x4c01300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x0440'4100        DC32     0x4404100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x04C0'1100        DC32     0x4c01100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x04C0'1200        DC32     0x4c01200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x0440'4000        DC32     0x4404000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x0440'4400        DC32     0x4404400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x0480'0100        DC32     0x4800100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x04C0'1000        DC32     0x4c01000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0x04C0'1300        DC32     0x4c01300
   1775          
   1776          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   psa_get_key_type
     176   sli_se_driver_cipher_decrypt
       176   -> __aeabi_memclr4
       176   -> __aeabi_memcpy
       176   -> __aeabi_memmove
       176   -> __aeabi_memset
       176   -> sl_se_aes_crypt_cbc
       176   -> sl_se_aes_crypt_ctr
       176   -> sl_se_aes_crypt_ecb
       176   -> sl_se_init_command_context
       176   -> sli_psa_validate_pkcs7_padding
       176   -> sli_se_key_desc_from_input
       176   -> validate_key_algorithm_match
       176   -> validate_key_type
      40   sli_se_driver_cipher_decrypt_setup
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> validate_key_algorithm_match
     192   sli_se_driver_cipher_encrypt
       192   -> __aeabi_memclr4
       192   -> __aeabi_memcpy
       192   -> __aeabi_memmove
       192   -> __aeabi_memset
       192   -> sl_se_aes_crypt_cbc
       192   -> sl_se_aes_crypt_ctr
       192   -> sl_se_aes_crypt_ecb
       192   -> sl_se_init_command_context
       192   -> sli_se_key_desc_from_input
       192   -> validate_key_algorithm_match
       192   -> validate_key_type
      40   sli_se_driver_cipher_encrypt_setup
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> validate_key_algorithm_match
      24   sli_se_driver_cipher_finish
        24   -> validate_key_type
      32   sli_se_driver_cipher_set_iv
        32   -> __aeabi_memcpy
     104   sli_se_driver_cipher_update
       104   -> __aeabi_memclr4
       104   -> __aeabi_memcpy
       104   -> __aeabi_memmove
       104   -> sl_se_aes_crypt_cbc
       104   -> sl_se_aes_crypt_ctr
       104   -> sl_se_aes_crypt_ecb
       104   -> sl_se_init_command_context
       104   -> validate_key_type
      16   validate_key_algorithm_match
        16   -> psa_get_key_type
       0   validate_key_type


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
      36  ?_0
      32  ?_1
      36  ?_2
      32  ?_3
      36  ?_4
       4  psa_get_key_type
     858  sli_se_driver_cipher_decrypt
      78  sli_se_driver_cipher_decrypt_setup
     956  sli_se_driver_cipher_encrypt
      78  sli_se_driver_cipher_encrypt_setup
     142  sli_se_driver_cipher_finish
     212  sli_se_driver_cipher_set_iv
   1'070  sli_se_driver_cipher_update
      60  validate_key_algorithm_match
      26  validate_key_type

 
   172 bytes in section .rodata
 3'540 bytes in section .text
 
 3'540 bytes of CODE  memory
   172 bytes of CONST memory

Errors: none
Warnings: none
