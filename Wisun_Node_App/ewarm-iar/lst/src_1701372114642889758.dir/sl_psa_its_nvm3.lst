###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:06
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sl_psa_its_nvm3.c
#    Command line                 =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sl_psa_its_nvm3.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sl_psa_its_nvm3.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sl_psa_its_nvm3.o.iar_deps"
#    Locale                       =  C
#    List file                    =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir\sl_psa_its_nvm3.lst
#    Object file                  =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sl_psa_its_nvm3.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sl_psa_its_nvm3.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief PSA ITS implementation based on Silicon Labs NVM3
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          // The psa_driver_wrappers.h file that we're including here assumes that it has
     32          // access to private struct members. Define this here in order to avoid
     33          // compilation errors.
     34          #define MBEDTLS_ALLOW_PRIVATE_ACCESS
     35          
     36          // -------------------------------------
     37          // Includes
     38          
     39          #include <mbedtls/build_info.h>
     40          
     41          #if defined(MBEDTLS_PSA_CRYPTO_STORAGE_C) && !defined(MBEDTLS_PSA_ITS_FILE_C)
     42          
     43          #include "psa/internal_trusted_storage.h"
     44          #include "psa/sli_internal_trusted_storage.h"
     45          #include "nvm3_default.h"
     46          #include "mbedtls/platform.h"
     47          #include <stdbool.h>
     48          #include <string.h>
     49          
     50          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
     51            #include <arm_cmse.h>
     52            #include "psa/storage_common.h"
     53          #endif // TFM_CONFIG_SL_SECURE_LIBRARY
     54          
     55          #if defined(SLI_PSA_ITS_ENCRYPTED)
     56            #include "psa_crypto_core.h"
     57            #include "psa_crypto_driver_wrappers.h"
     58            #if defined(SEMAILBOX_PRESENT)
     59              #include "psa/crypto_extra.h"
     60              #include "sl_psa_values.h"
     61              #include "sli_se_opaque_functions.h"
     62            #endif // defined(SEMAILBOX_PRESENT)
     63          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
     64          
     65          // SLI_STATIC_TESTABLE is used to expose otherwise-static variables during
     66          // internal testing.
     67          #if defined(SLI_STATIC_TESTABLE)
     68            #define SLI_STATIC
     69          #else
     70            #define SLI_STATIC static
     71          #endif
     72          
     73          // -------------------------------------
     74          // Threading support
     75          
     76          #if defined(MBEDTLS_THREADING_C)
     77            #include "cmsis_os2.h"
     78            #include "mbedtls/threading.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void THREADING_SetRecursive(mbedtls_threading_mutex_t *)
   \                     THREADING_SetRecursive: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD003             BEQ.N    ??THREADING_SetRecursive_0
   \                     ??THREADING_SetRecursive_1: (+1)
   \        0x4   0x6841             LDR      R1,[R0, #+4]
   \        0x6   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0xA   0x6041             STR      R1,[R0, #+4]
   \                     ??THREADING_SetRecursive_0: (+1)
   \        0xC   0x4770             BX       LR
     79          
     80          // Mutex for protecting access to the ITS instance

   \                                 In section .bss, align 4
     81          SLI_STATIC mbedtls_threading_mutex_t its_mutex MUTEX_INIT;
   \                     its_mutex:
   \        0x0                      DS8 20

   \                                 In section .bss, align 1
     82          static volatile bool its_mutex_inited = false;
   \                     its_mutex_inited:
   \        0x0                      DS8 1
     83          
     84          /**
     85           * \brief          Lock all task switches
     86           *
     87           * \return         Previous lock state
     88           *
     89           */

   \                                 In section .text, align 2, keep-with-next
     90          static inline int32_t lock_task_switches(void)
     91          {
   \                     lock_task_switches: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
     92            int32_t kernel_lock_state = 0;
   \        0x2   0x2500             MOVS     R5,#+0
     93            osKernelState_t kernel_state = osKernelGetState();
   \        0x4   0x.... 0x....      BL       osKernelGetState
   \        0x8   0x0004             MOVS     R4,R0
     94            if (kernel_state != osKernelInactive && kernel_state != osKernelReady) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD004             BEQ.N    ??lock_task_switches_0
   \        0xE   0x2C01             CMP      R4,#+1
   \       0x10   0xD002             BEQ.N    ??lock_task_switches_0
     95              kernel_lock_state = osKernelLock();
   \       0x12   0x.... 0x....      BL       osKernelLock
   \       0x16   0x0005             MOVS     R5,R0
     96            }
     97            return kernel_lock_state;
   \                     ??lock_task_switches_0: (+1)
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xBD32             POP      {R1,R4,R5,PC}
     98          }
     99          
    100          /**
    101           * \brief          Restores the previous lock state
    102           */

   \                                 In section .text, align 2, keep-with-next
    103          static inline void restore_lock_state(int32_t kernel_lock_state)
    104          {
   \                     restore_lock_state: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
    105            osKernelState_t kernel_state = osKernelGetState();
   \        0x4   0x.... 0x....      BL       osKernelGetState
   \        0x8   0x0004             MOVS     R4,R0
    106            if (kernel_state != osKernelInactive && kernel_state != osKernelReady) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD00B             BEQ.N    ??restore_lock_state_0
   \        0xE   0x2C01             CMP      R4,#+1
   \       0x10   0xD009             BEQ.N    ??restore_lock_state_0
    107              if (osKernelRestoreLock(kernel_lock_state) < 0) {
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       osKernelRestoreLock
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD504             BPL.N    ??restore_lock_state_0
    108                EFM_ASSERT(false);
   \       0x1C   0x216C             MOVS     R1,#+108
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable16
   \       0x22   0x.... 0x....      BL       assertEFM
    109              }
    110            }
    111          }
   \                     ??restore_lock_state_0: (+1)
   \       0x26   0xBD31             POP      {R0,R4,R5,PC}
    112          
    113          #endif // defined(MBEDTLS_THREADING_C)
    114          
    115          /**
    116           * \brief Pend on the ITS mutex
    117           */

   \                                 In section .text, align 2, keep-with-next
    118          void sli_its_acquire_mutex(void)
    119          {
   \                     sli_its_acquire_mutex: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    120          #if defined(MBEDTLS_THREADING_C)
    121            if (!its_mutex_inited) {
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable16_1
   \        0x6   0x7820             LDRB     R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD114             BNE.N    ??sli_its_acquire_mutex_0
    122              int32_t kernel_lock_state = lock_task_switches();
   \        0xC   0x.... 0x....      BL       lock_task_switches
   \       0x10   0x0005             MOVS     R5,R0
    123              if (!its_mutex_inited) {
   \       0x12   0x7820             LDRB     R0,[R4, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD10B             BNE.N    ??sli_its_acquire_mutex_1
    124                // The ITS mutex needs to be recursive since the same thread may need
    125                // to acquire it more than one time.
    126                THREADING_SetRecursive(&its_mutex);
   \       0x18   0x.... 0x....      LDR.W    R6,??DataTable16_2
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0x.... 0x....      BL       THREADING_SetRecursive
    127                mbedtls_mutex_init(&its_mutex);
   \       0x22   0x0030             MOVS     R0,R6
   \       0x24   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \       0x28   0x6809             LDR      R1,[R1, #+0]
   \       0x2A   0x4788             BLX      R1
    128                its_mutex_inited = true;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x7020             STRB     R0,[R4, #+0]
    129              }
    130              restore_lock_state(kernel_lock_state);
   \                     ??sli_its_acquire_mutex_1: (+1)
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x.... 0x....      BL       restore_lock_state
    131            }
    132            if (mbedtls_mutex_lock(&its_mutex) != 0) {
   \                     ??sli_its_acquire_mutex_0: (+1)
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \       0x3A   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \       0x3E   0x6809             LDR      R1,[R1, #+0]
   \       0x40   0x4788             BLX      R1
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD004             BEQ.N    ??sli_its_acquire_mutex_2
    133              EFM_ASSERT(false);
   \       0x46   0x2185             MOVS     R1,#+133
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable16
   \       0x4C   0x.... 0x....      BL       assertEFM
    134            }
    135          #endif
    136          }
   \                     ??sli_its_acquire_mutex_2: (+1)
   \       0x50   0xBD70             POP      {R4-R6,PC}
    137          
    138          /**
    139           * \brief Free the ITS mutex.
    140           */

   \                                 In section .text, align 2, keep-with-next
    141          void sli_its_release_mutex(void)
    142          {
   \                     sli_its_release_mutex: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    143          #if defined(MBEDTLS_THREADING_C)
    144            if (its_mutex_inited) {
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD005             BEQ.N    ??sli_its_release_mutex_0
    145              mbedtls_mutex_unlock(&its_mutex);
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0x4788             BLX      R1
    146            }
    147          #endif
    148          }
   \                     ??sli_its_release_mutex_0: (+1)
   \       0x18   0xBD01             POP      {R0,PC}
    149          
    150          // -------------------------------------
    151          // Defines
    152          
    153          #if (!SL_PSA_ITS_SUPPORT_V3_DRIVER)
    154          #define SLI_PSA_ITS_NVM3_RANGE_START SLI_PSA_ITS_NVM3_RANGE_BASE
    155          #define SLI_PSA_ITS_NVM3_RANGE_END   SLI_PSA_ITS_NVM3_RANGE_START + SL_PSA_ITS_MAX_FILES
    156          
    157          #define SLI_PSA_ITS_NVM3_INVALID_KEY (0)
    158          #define SLI_PSA_ITS_NVM3_UNKNOWN_KEY (1)
    159          
    160          #if SL_PSA_ITS_MAX_FILES > SLI_PSA_ITS_NVM3_RANGE_SIZE
    161          #error "Trying to store more ITS files then our NVM3 range allows for"
    162          #endif
    163          
    164          #define SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE 16
    165          
    166          // Enable backwards-compatibility with keys stored with a v1 header unless disabled.
    167          #if !defined(SL_PSA_ITS_REMOVE_V1_HEADER_SUPPORT)
    168          #define SLI_PSA_ITS_SUPPORT_V1_FORMAT
    169          #endif
    170          
    171          // Internal error codes local to this compile unit
    172          #define SLI_PSA_ITS_ECODE_NO_VALID_HEADER (ECODE_EMDRV_NVM3_BASE - 1)
    173          #define SLI_PSA_ITS_ECODE_NEEDS_UPGRADE   (ECODE_EMDRV_NVM3_BASE - 2)
    174          
    175          #if defined(SLI_PSA_ITS_ENCRYPTED)
    176          // Define some cryptographic constants if not already set. This depends on the underlying
    177          // crypto accelerator in use (CRYPTOACC has these defines, but not SEMAILBOX).
    178          #if !defined(AES_MAC_SIZE)
    179          #define AES_MAC_SIZE 16
    180          #endif
    181          
    182          #if !defined(AES_IV_GCM_SIZE)
    183          #define AES_IV_GCM_SIZE 12
    184          #endif
    185          
    186          #define SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD  (AES_IV_GCM_SIZE + AES_MAC_SIZE)
    187          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    188          
    189          // -------------------------------------
    190          // Local global static variables
    191          
    192          SLI_STATIC bool nvm3_uid_set_cache_initialized = false;
    193          SLI_STATIC uint32_t nvm3_uid_set_cache[(SL_PSA_ITS_MAX_FILES + 31) / 32] = { 0 };
    194          
    195          typedef struct {
    196            psa_storage_uid_t uid;
    197            nvm3_ObjectKey_t object_id;
    198            bool set;
    199          } previous_lookup_t;
    200          
    201          static previous_lookup_t previous_lookup = {
    202            0, 0, false
    203          };
    204          
    205          #if defined(SLI_PSA_ITS_ENCRYPTED)
    206          // The root key is an AES-256 key, and is therefore 32 bytes.
    207          #define ROOT_KEY_SIZE     (32)
    208          // The session key is derived from CMAC, which means it is equal to the AES block size, i.e. 16 bytes
    209          #define SESSION_KEY_SIZE  (16)
    210          
    211          #if !defined(SEMAILBOX_PRESENT)
    212          typedef struct {
    213            bool initialized;
    214            uint8_t data[ROOT_KEY_SIZE];
    215          } root_key_t;
    216          
    217          static root_key_t g_root_key = {
    218            .initialized = false,
    219            .data = { 0 },
    220          };
    221          #endif // !defined(SEMAILBOX_PRESENT)
    222          
    223          typedef struct {
    224            bool active;
    225            psa_storage_uid_t uid;
    226            uint8_t data[SESSION_KEY_SIZE];
    227          } session_key_t;
    228          
    229          static session_key_t g_cached_session_key = {
    230            .active = false,
    231            .uid = 0,
    232            .data = { 0 },
    233          };
    234          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    235          
    236          // -------------------------------------
    237          // Structs
    238          
    239          #if defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT)
    240          typedef struct {
    241            uint32_t magic;
    242            psa_storage_uid_t uid;
    243            psa_storage_create_flags_t flags;
    244          } sl_its_file_meta_v1_t;
    245          #endif // defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT)
    246          
    247          // Due to alignment constraints on the 64-bit UID, the v2 header struct is
    248          // serialized to 16 bytes instead of the 24 bytes the v1 header compiles to.
    249          typedef struct {
    250            uint32_t magic;
    251            psa_storage_create_flags_t flags;
    252            psa_storage_uid_t uid;
    253          } sli_its_file_meta_v2_t;
    254          
    255          #if defined(SLI_PSA_ITS_ENCRYPTED)
    256          typedef struct {
    257            uint8_t iv[AES_IV_GCM_SIZE];
    258            // When encrypted & authenticated, MAC is stored at the end of the data array
    259            uint8_t data[];
    260          } sli_its_encrypted_blob_t;
    261          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    262          
    263          // -------------------------------------
    264          // Local function prototypes
    265          
    266          static nvm3_ObjectKey_t get_nvm3_id(psa_storage_uid_t uid, bool find_empty_slot);
    267          static nvm3_ObjectKey_t prepare_its_get_nvm3_id(psa_storage_uid_t uid);
    268          
    269          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    270          static inline bool object_lives_in_s(const void *object, size_t object_size);
    271          #endif // defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    272          
    273          #if defined(SLI_PSA_ITS_ENCRYPTED)
    274          static psa_status_t derive_session_key(uint8_t *iv,
    275                                                 size_t iv_size,
    276                                                 uint8_t *session_key,
    277                                                 size_t session_key_size);
    278          
    279          static psa_status_t encrypt_its_file(sli_its_file_meta_v2_t *metadata,
    280                                               uint8_t *plaintext,
    281                                               size_t plaintext_size,
    282                                               sli_its_encrypted_blob_t *blob,
    283                                               size_t blob_size,
    284                                               size_t *blob_length);
    285          
    286          static psa_status_t decrypt_its_file(sli_its_file_meta_v2_t *metadata,
    287                                               sli_its_encrypted_blob_t *blob,
    288                                               size_t blob_size,
    289                                               uint8_t *plaintext,
    290                                               size_t plaintext_size,
    291                                               size_t *plaintext_length);
    292          
    293          static psa_status_t authenticate_its_file(nvm3_ObjectKey_t nvm3_object_id,
    294                                                    psa_storage_uid_t *authenticated_uid);
    295          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    296          
    297          // -------------------------------------
    298          // Local function definitions
    299          
    300          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    301          // If an object of given size is fully encapsulated in a region of
    302          // secure domain the function returns true.
    303          static inline bool object_lives_in_s(const void *object, size_t object_size)
    304          {
    305            cmse_address_info_t cmse_flags;
    306          
    307            for (size_t i = 0u; i < object_size; i++) {
    308              cmse_flags = cmse_TTA((uint32_t *)object + i);
    309              if (!cmse_flags.flags.secure) {
    310                return false;
    311              }
    312            }
    313          
    314            return true;
    315          }
    316          #endif // defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    317          
    318          static inline void cache_set(nvm3_ObjectKey_t key)
    319          {
    320            uint32_t i = key - SLI_PSA_ITS_NVM3_RANGE_START;
    321            uint32_t bin = i / 32;
    322            uint32_t offset = i - 32 * bin;
    323            nvm3_uid_set_cache[bin] |= (1 << offset);
    324          }
    325          
    326          static inline void cache_clear(nvm3_ObjectKey_t key)
    327          {
    328            uint32_t i = key - SLI_PSA_ITS_NVM3_RANGE_START;
    329            uint32_t bin = i / 32;
    330            uint32_t offset = i - 32 * bin;
    331            nvm3_uid_set_cache[bin] ^= (1 << offset);
    332          }
    333          
    334          static inline bool cache_lookup(nvm3_ObjectKey_t key)
    335          {
    336            uint32_t i = key - SLI_PSA_ITS_NVM3_RANGE_START;
    337            uint32_t bin = i / 32;
    338            uint32_t offset = i - 32 * bin;
    339            return (bool)((nvm3_uid_set_cache[bin] >> offset) & 0x1);
    340          }
    341          
    342          static void init_cache(void)
    343          {
    344            size_t num_keys_referenced_by_nvm3;
    345            nvm3_ObjectKey_t keys_referenced_by_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = { 0 };
    346          
    347            for (nvm3_ObjectKey_t range_start = SLI_PSA_ITS_NVM3_RANGE_START;
    348                 range_start < SLI_PSA_ITS_NVM3_RANGE_END;
    349                 range_start += SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE) {
    350              nvm3_ObjectKey_t range_end = range_start + SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE;
    351              if (range_end > SLI_PSA_ITS_NVM3_RANGE_END) {
    352                range_end = SLI_PSA_ITS_NVM3_RANGE_END;
    353              }
    354          
    355              num_keys_referenced_by_nvm3 = nvm3_enumObjects(nvm3_defaultHandle,
    356                                                             keys_referenced_by_nvm3,
    357                                                             sizeof(keys_referenced_by_nvm3) / sizeof(nvm3_ObjectKey_t),
    358                                                             range_start,
    359                                                             range_end - 1);
    360          
    361              for (size_t i = 0; i < num_keys_referenced_by_nvm3; i++) {
    362                cache_set(keys_referenced_by_nvm3[i]);
    363              }
    364            }
    365          
    366            nvm3_uid_set_cache_initialized = true;
    367          }
    368          
    369          // Read the file metadata for a specific NVM3 ID
    370          static Ecode_t get_file_metadata(nvm3_ObjectKey_t key,
    371                                           sli_its_file_meta_v2_t* metadata,
    372                                           size_t* its_file_offset,
    373                                           size_t* its_file_size)
    374          {
    375            // Initialize output variables to safe default
    376            if (its_file_offset != NULL) {
    377              *its_file_offset = 0;
    378            }
    379            if (its_file_size != NULL) {
    380              *its_file_size = 0;
    381            }
    382          
    383            Ecode_t status = nvm3_readPartialData(nvm3_defaultHandle,
    384                                                  key,
    385                                                  metadata,
    386                                                  0,
    387                                                  sizeof(sli_its_file_meta_v2_t));
    388            if (status != ECODE_NVM3_OK) {
    389              return status;
    390            }
    391          
    392          #if defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT)
    393            // Re-read in v1 header format and translate to the latest structure version
    394            if (metadata->magic == SLI_PSA_ITS_META_MAGIC_V1) {
    395              sl_its_file_meta_v1_t key_meta_v1 = { 0 };
    396              status = nvm3_readPartialData(nvm3_defaultHandle,
    397                                            key,
    398                                            &key_meta_v1,
    399                                            0,
    400                                            sizeof(sl_its_file_meta_v1_t));
    401          
    402              if (status != ECODE_NVM3_OK) {
    403                return status;
    404              }
    405          
    406              metadata->flags = key_meta_v1.flags;
    407              metadata->uid = key_meta_v1.uid;
    408              metadata->magic = SLI_PSA_ITS_META_MAGIC_V2;
    409          
    410              if (its_file_offset != NULL) {
    411                *its_file_offset = sizeof(sl_its_file_meta_v1_t);
    412              }
    413          
    414              status = SLI_PSA_ITS_ECODE_NEEDS_UPGRADE;
    415            } else
    416          #endif
    417            {
    418              if (its_file_offset != NULL) {
    419                *its_file_offset = sizeof(sli_its_file_meta_v2_t);
    420              }
    421            }
    422          
    423            if (metadata->magic != SLI_PSA_ITS_META_MAGIC_V2) {
    424              // No valid header found in this object
    425              return SLI_PSA_ITS_ECODE_NO_VALID_HEADER;
    426            }
    427          
    428            if (its_file_offset != NULL && its_file_size != NULL) {
    429              // Calculate the ITS file size if requested
    430              uint32_t obj_type;
    431              Ecode_t info_status = nvm3_getObjectInfo(nvm3_defaultHandle,
    432                                                       key,
    433                                                       &obj_type,
    434                                                       its_file_size);
    435              if (info_status != ECODE_NVM3_OK) {
    436                return info_status;
    437              }
    438          
    439              *its_file_size = *its_file_size - *its_file_offset;
    440            }
    441          
    442            return status;
    443          }
    444          
    445          // Search through NVM3 for uid
    446          static nvm3_ObjectKey_t get_nvm3_id(psa_storage_uid_t uid, bool find_empty_slot)
    447          {
    448            Ecode_t status;
    449            sli_its_file_meta_v2_t key_meta;
    450          
    451            if (find_empty_slot) {
    452              for (size_t i = 0; i < SL_PSA_ITS_MAX_FILES; i++) {
    453                if (!cache_lookup(i + SLI_PSA_ITS_NVM3_RANGE_START)) {
    454                  return i + SLI_PSA_ITS_NVM3_RANGE_START;
    455                }
    456              }
    457            } else {
    458              if (previous_lookup.set) {
    459                if (previous_lookup.uid == uid) {
    460                  return previous_lookup.object_id;
    461                }
    462              }
    463          
    464              for (size_t i = 0; i < SL_PSA_ITS_MAX_FILES; i++) {
    465                if (!cache_lookup(i + SLI_PSA_ITS_NVM3_RANGE_START)) {
    466                  continue;
    467                }
    468                nvm3_ObjectKey_t object_id = i + SLI_PSA_ITS_NVM3_RANGE_START;
    469          
    470                status = get_file_metadata(object_id, &key_meta, NULL, NULL);
    471          
    472                if (status == ECODE_NVM3_OK
    473                    || status == SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
    474                  if (key_meta.uid == uid) {
    475                    previous_lookup.set = true;
    476                    previous_lookup.object_id = object_id;
    477                    previous_lookup.uid = uid;
    478          
    479                    return object_id;
    480                  } else {
    481                    continue;
    482                  }
    483                }
    484          
    485                if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER
    486                    || status == ECODE_NVM3_ERR_READ_DATA_SIZE) {
    487                  // we don't expect any other data in our range then PSA ITS files.
    488                  // delete the file if the magic doesn't match or the object on disk
    489                  // is too small to even have full metadata.
    490                  status = nvm3_deleteObject(nvm3_defaultHandle, object_id);
    491                  if (status != ECODE_NVM3_OK) {
    492                    return SLI_PSA_ITS_NVM3_RANGE_END + 1U;
    493                  }
    494                }
    495              }
    496            }
    497          
    498            return SLI_PSA_ITS_NVM3_RANGE_END + 1U;
    499          }
    500          
    501          // Perform NVM3 open and fill the look-up table.
    502          // Try to find the mapping NVM3 object ID with PSA ITS UID.
    503          static nvm3_ObjectKey_t prepare_its_get_nvm3_id(psa_storage_uid_t uid)
    504          {
    505          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    506            // With SKL the NVM3 instance must be initialized by the NS app. We therefore check that
    507            // it has been opened (which is done on init) rather than actually doing the init.
    508            if (!nvm3_defaultHandle->hasBeenOpened) {
    509          #else
    510            if (nvm3_initDefault() != ECODE_NVM3_OK) {
    511          #endif
    512              return SLI_PSA_ITS_NVM3_RANGE_END + 1U;
    513            }
    514          
    515            if (nvm3_uid_set_cache_initialized == false) {
    516              init_cache();
    517            }
    518          
    519            return get_nvm3_id(uid, false);
    520          }
    521          
    522          #if defined(SLI_PSA_ITS_ENCRYPTED)
    523          static inline void cache_session_key(uint8_t *session_key, psa_storage_uid_t uid)
    524          {
    525            // Cache the session key
    526            memcpy(g_cached_session_key.data, session_key, sizeof(g_cached_session_key.data));
    527            g_cached_session_key.uid = uid;
    528            g_cached_session_key.active = true;
    529          }
    530          
    531          /**
    532           * \brief Derive a session key for ITS file encryption from the initialized root key and provided IV.
    533           *
    534           * \param[in] iv                Pointer to array containing the initialization vector to be used in the key derivation.
    535           * \param[in] iv_size           Size of the IV buffer in bytes. Must be 12 bytes (AES-GCM IV size).
    536           * \param[out] session_key      Pointer to array where derived session key shall be stored.
    537           * \param[out] session_key_size Size of the derived session key output array. Must be at least 32 bytes (AES-256 key size).
    538           *
    539           * \return      A status indicating the success/failure of the operation
    540           *
    541           * \retval      PSA_SUCCESS                      The operation completed successfully
    542           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
    543           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because iv or session_key is NULL, or their sizes are incorrect.
    544           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    545           */
    546          static psa_status_t derive_session_key(uint8_t *iv, size_t iv_size, uint8_t *session_key, size_t session_key_size)
    547          {
    548            if (iv == NULL
    549                || iv_size != AES_IV_GCM_SIZE
    550                || session_key == NULL
    551                || session_key_size < SESSION_KEY_SIZE) {
    552              return PSA_ERROR_INVALID_ARGUMENT;
    553            }
    554          
    555            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    556            psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    557          
    558          #if defined(SEMAILBOX_PRESENT)
    559            // For HSE devices, use the builtin TrustZone Root Key
    560            psa_set_key_id(&attributes, SL_SE_BUILTIN_KEY_TRUSTZONE_ID);
    561          
    562            psa_key_lifetime_t reported_lifetime;
    563            psa_drv_slot_number_t reported_slot;
    564            status = mbedtls_psa_platform_get_builtin_key(psa_get_key_id(&attributes),
    565                                                          &reported_lifetime,
    566                                                          &reported_slot);
    567          
    568            if (status != PSA_SUCCESS) {
    569              return status;
    570            }
    571          
    572            psa_set_key_lifetime(&attributes, reported_lifetime);
    573          
    574            uint8_t key_buffer[sizeof(sli_se_opaque_key_context_header_t)];
    575            size_t key_buffer_size;
    576            status = sli_se_opaque_get_builtin_key(reported_slot,
    577                                                   &attributes,
    578                                                   key_buffer,
    579                                                   sizeof(key_buffer),
    580                                                   &key_buffer_size);
    581            if (status != PSA_SUCCESS) {
    582              return status;
    583            }
    584          #else // defined(SEMAILBOX_PRESENT)
    585            // For VSE devices, use the previously initialized root key
    586            if (!g_root_key.initialized) {
    587              return PSA_ERROR_BAD_STATE;
    588            }
    589          
    590            // Prepare root key attributes
    591            psa_set_key_algorithm(&attributes, PSA_ALG_CMAC);
    592            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    593            psa_set_key_bits(&attributes, ROOT_KEY_SIZE * 8);
    594          
    595            // Point the key buffer to the global root key
    596            uint8_t *key_buffer = (uint8_t*)g_root_key.data;
    597            size_t key_buffer_size = sizeof(g_root_key.data);
    598          #endif // defined(SEMAILBOX_PRESENT)
    599          
    600            // Use CMAC as a key derivation function
    601            size_t session_key_length;
    602            status = psa_driver_wrapper_mac_compute(
    603              &attributes,
    604              key_buffer,
    605              key_buffer_size,
    606              PSA_ALG_CMAC,
    607              iv,
    608              iv_size,
    609              session_key,
    610              session_key_size,
    611              &session_key_length);
    612          
    613            // Verify that the key derivation was successful before transferring the key to the caller
    614            if (status != PSA_SUCCESS || session_key_length != SESSION_KEY_SIZE) {
    615              memset(session_key, 0, session_key_size);
    616              return PSA_ERROR_HARDWARE_FAILURE;
    617            }
    618          
    619            return status;
    620          }
    621          
    622          /**
    623           * \brief Encrypt and authenticate ITS data with AES-128-GCM, storing the result in an encrypted blob.
    624           *
    625           * \param[in] metadata        ITS metadata to be used as authenticated additional data.
    626           * \param[in] plaintext       Pointer to array containing data to be encrypted.
    627           * \param[in] plaintext_size  Size of provided plaintext data array.
    628           * \param[out] blob           Pointer to array where the resulting encrypted blob shall be placed.
    629           * \param[in] blob_size       Size of the output array. Must be at least as big as plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
    630           * \param[out] blob_length    Resulting size of the output blob.
    631           *
    632           * \return      A status indicating the success/failure of the operation
    633           *
    634           * \retval      PSA_SUCCESS                      The operation completed successfully
    635           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
    636           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
    637           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    638           */
    639          static psa_status_t encrypt_its_file(sli_its_file_meta_v2_t *metadata,
    640                                               uint8_t *plaintext,
    641                                               size_t plaintext_size,
    642                                               sli_its_encrypted_blob_t *blob,
    643                                               size_t blob_size,
    644                                               size_t *blob_length)
    645          {
    646            if (metadata == NULL
    647                || (plaintext == NULL && plaintext_size > 0)
    648                || blob == NULL
    649                || blob_size < plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
    650                || blob_length == NULL) {
    651              return PSA_ERROR_INVALID_ARGUMENT;
    652            }
    653          
    654            // Generate IV
    655            size_t iv_length = 0;
    656            psa_status_t psa_status = mbedtls_psa_external_get_random(NULL, blob->iv, AES_IV_GCM_SIZE, &iv_length);
    657          
    658            if (psa_status != PSA_SUCCESS || iv_length != AES_IV_GCM_SIZE) {
    659              return PSA_ERROR_HARDWARE_FAILURE;
    660            }
    661          
    662            // Prepare encryption key
    663            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    664            psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    665            psa_set_key_algorithm(&attributes, PSA_ALG_GCM);
    666            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    667            psa_set_key_bits(&attributes, SESSION_KEY_SIZE * 8);
    668          
    669            uint8_t session_key[SESSION_KEY_SIZE];
    670            psa_status = derive_session_key(blob->iv, AES_IV_GCM_SIZE, session_key, sizeof(session_key));
    671            if (psa_status != PSA_SUCCESS) {
    672              return psa_status;
    673            }
    674          
    675            cache_session_key(session_key, metadata->uid);
    676          
    677            // Retrieve data to be encrypted
    678            if (plaintext_size != 0U) {
    679              memcpy(blob->data, ((uint8_t*)plaintext), plaintext_size);
    680            }
    681          
    682            // Encrypt and authenticate blob
    683            size_t output_length = 0;
    684            psa_status = psa_driver_wrapper_aead_encrypt(
    685              &attributes,
    686              session_key, sizeof(session_key),
    687              PSA_ALG_GCM,
    688              blob->iv, sizeof(blob->iv),
    689              (uint8_t*)metadata, sizeof(sli_its_file_meta_v2_t),    // metadata is AAD
    690              blob->data, plaintext_size,
    691              blob->data, plaintext_size + AES_MAC_SIZE,    // output == input for in-place encryption
    692              &output_length);
    693          
    694            // Clear the local session key immediately after we're done using it
    695            memset(session_key, 0, sizeof(session_key));
    696          
    697            if (psa_status != PSA_SUCCESS) {
    698              return PSA_ERROR_HARDWARE_FAILURE;
    699            }
    700          
    701            if (output_length != plaintext_size + AES_MAC_SIZE) {
    702              return PSA_ERROR_HARDWARE_FAILURE;
    703            }
    704          
    705            *blob_length = output_length + AES_IV_GCM_SIZE;
    706          
    707            return PSA_SUCCESS;
    708          }
    709          
    710          /**
    711           * \brief Decrypt and authenticate encrypted ITS data.
    712           *
    713           * \param[in] metadata          ITS metadata to be used as authenticated additional data. Must be identical to the metadata used during encryption.
    714           * \param[in] blob              Encrypted blob containing data to be decrypted.
    715           * \param[in] blob_size         Size of the encrypted blob in bytes.
    716           * \param[out] plaintext        Pointer to array where the decrypted plaintext shall be placed.
    717           * \param[in] plaintext_size    Size of the plaintext array. Must be equal to sizeof(blob->data) - AES_MAC_SIZE.
    718           * \param[out] plaintext_length Resulting length of the decrypted plaintext.
    719           *
    720           * \return      A status indicating the success/failure of the operation
    721           *
    722           * \retval      PSA_SUCCESS                      The operation completed successfully
    723           * \retval      PSA_ERROR_INVALID_SIGANTURE      The operation failed because authentication of the decrypted data failed.
    724           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
    725           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
    726           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    727           */
    728          static psa_status_t decrypt_its_file(sli_its_file_meta_v2_t *metadata,
    729                                               sli_its_encrypted_blob_t *blob,
    730                                               size_t blob_size,
    731                                               uint8_t *plaintext,
    732                                               size_t plaintext_size,
    733                                               size_t *plaintext_length)
    734          {
    735            if (metadata == NULL
    736                || blob == NULL
    737                || blob_size < plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
    738                || (plaintext == NULL && plaintext_size > 0)
    739                || plaintext_length == NULL) {
    740              return PSA_ERROR_INVALID_ARGUMENT;
    741            }
    742          
    743            // Prepare decryption key
    744            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    745            psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
    746            psa_set_key_algorithm(&attributes, PSA_ALG_GCM);
    747            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    748            psa_set_key_bits(&attributes, SESSION_KEY_SIZE * 8);
    749          
    750            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
    751            uint8_t session_key[SESSION_KEY_SIZE];
    752          
    753            if (g_cached_session_key.active && g_cached_session_key.uid == metadata->uid) {
    754              // Use cached session key if it's already set and UID matches
    755              memcpy(session_key, g_cached_session_key.data, sizeof(session_key));
    756            } else {
    757              psa_status = derive_session_key(blob->iv, AES_IV_GCM_SIZE, session_key, sizeof(session_key));
    758              if (psa_status != PSA_SUCCESS) {
    759                return psa_status;
    760              }
    761              cache_session_key(session_key, metadata->uid);
    762            }
    763          
    764            // Decrypt and authenticate blob
    765            size_t output_length = 0;
    766            psa_status = psa_driver_wrapper_aead_decrypt(
    767              &attributes,
    768              session_key, sizeof(session_key),
    769              PSA_ALG_GCM,
    770              blob->iv, sizeof(blob->iv),
    771              (uint8_t*)metadata, sizeof(sli_its_file_meta_v2_t),    // metadata is AAD
    772              blob->data, plaintext_size + AES_MAC_SIZE,
    773              plaintext, plaintext_size,
    774              &output_length);
    775          
    776            // Clear the session key immediately after we're done using it
    777            memset(session_key, 0, sizeof(session_key));
    778          
    779            // Invalid signature likely means that NVM data was tampered with
    780            if (psa_status == PSA_ERROR_INVALID_SIGNATURE) {
    781              return PSA_ERROR_INVALID_SIGNATURE;
    782            }
    783          
    784            if (psa_status != PSA_SUCCESS
    785                || output_length != plaintext_size) {
    786              return PSA_ERROR_HARDWARE_FAILURE;
    787            }
    788          
    789            *plaintext_length = output_length;
    790          
    791            return PSA_SUCCESS;
    792          }
    793          
    794          /**
    795           * \brief Authenticate encrypted ITS data and return the UID of the ITS file that was authenticated.
    796           *
    797           * \details NOTE: This function will run decrypt_its_file() internally. The difference from the decrypt_its_file()
    798           *          function is that authenticate_its_file() reads the NVM3 data, decrypts it in order to authenticate the
    799           *          stored data, and then discards the plaintext. This is needed since PSA Crypto doesn't support the
    800           *          GMAC primitive directly, which means we have to run a full GCM decrypt for authentication.
    801           *
    802           * \param[in] nvm3_object_id      The NVM3 id corresponding to the stored ITS file.
    803           * \param[out] authenticated_uid  UID for the authenticated ITS file.
    804           *
    805           * \return      A status indicating the success/failure of the operation
    806           *
    807           * \retval      PSA_SUCCESS                      The operation completed successfully
    808           * \retval      PSA_ERROR_INVALID_SIGANTURE      The operation failed because authentication of the decrypted data failed.
    809           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
    810           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
    811           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    812           */
    813          static psa_status_t authenticate_its_file(nvm3_ObjectKey_t nvm3_object_id,
    814                                                    psa_storage_uid_t *authenticated_uid)
    815          {
    816            psa_status_t ret = PSA_ERROR_CORRUPTION_DETECTED;
    817            sli_its_file_meta_v2_t *its_file_meta = NULL;
    818            sli_its_encrypted_blob_t *blob = NULL;
    819          
    820            uint32_t obj_type;
    821            size_t its_file_size = 0;
    822            Ecode_t status = nvm3_getObjectInfo(nvm3_defaultHandle,
    823                                                nvm3_object_id,
    824                                                &obj_type,
    825                                                &its_file_size);
    826            if (status != ECODE_NVM3_OK) {
    827              return PSA_ERROR_STORAGE_FAILURE;
    828            }
    829          
    830            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size);
    831            if (its_file_buffer == NULL) {
    832              return PSA_ERROR_INSUFFICIENT_MEMORY;
    833            }
    834            memset(its_file_buffer, 0, its_file_size);
    835          
    836            status = nvm3_readData(nvm3_defaultHandle,
    837                                   nvm3_object_id,
    838                                   its_file_buffer,
    839                                   its_file_size);
    840            if (status != ECODE_NVM3_OK) {
    841              ret = PSA_ERROR_STORAGE_FAILURE;
    842              goto cleanup;
    843            }
    844          
    845            its_file_meta = (sli_its_file_meta_v2_t*)its_file_buffer;
    846            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
    847          
    848            // Decrypt and authenticate blob
    849            size_t plaintext_length;
    850            ret = decrypt_its_file(its_file_meta,
    851                                   blob,
    852                                   its_file_size - sizeof(sli_its_file_meta_v2_t),
    853                                   blob->data,
    854                                   its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
    855                                   &plaintext_length);
    856          
    857            if (ret != PSA_SUCCESS) {
    858              goto cleanup;
    859            }
    860          
    861            if (plaintext_length != (its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
    862              ret = PSA_ERROR_INVALID_SIGNATURE;
    863              goto cleanup;
    864            }
    865          
    866            if (authenticated_uid != NULL) {
    867              *authenticated_uid = its_file_meta->uid;
    868            }
    869          
    870            ret = PSA_SUCCESS;
    871          
    872            cleanup:
    873          
    874            // Discard output, as we're only interested in whether the authentication check passed or not.
    875            memset(its_file_buffer, 0, its_file_size);
    876            mbedtls_free(its_file_buffer);
    877          
    878            return ret;
    879          }
    880          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    881          
    882          // -------------------------------------
    883          // Global function definitions
    884          
    885          /**
    886           * \brief create a new or modify an existing uid/value pair
    887           *
    888           * \param[in] uid           the identifier for the data
    889           * \param[in] data_length   The size in bytes of the data in `p_data`
    890           * \param[in] p_data        A buffer containing the data
    891           * \param[in] create_flags  The flags that the data will be stored with
    892           *
    893           * \return      A status indicating the success/failure of the operation
    894           *
    895           * \retval      PSA_SUCCESS                      The operation completed successfully
    896           * \retval      PSA_ERROR_NOT_PERMITTED          The operation failed because the provided `uid` value was already created with PSA_STORAGE_FLAG_WRITE_ONCE
    897           * \retval      PSA_ERROR_NOT_SUPPORTED          The operation failed because one or more of the flags provided in `create_flags` is not supported or is not valid
    898           * \retval      PSA_ERROR_INSUFFICIENT_STORAGE   The operation failed because there was insufficient space on the storage medium
    899           * \retval      PSA_ERROR_STORAGE_FAILURE        The operation failed because the physical storage has failed (Fatal error)
    900           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one of the provided pointers(`p_data`)
    901           *                                               is invalid, for example is `NULL` or references memory the caller cannot access
    902           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    903           */
    904          psa_status_t psa_its_set(psa_storage_uid_t uid,
    905                                   uint32_t data_length,
    906                                   const void *p_data,
    907                                   psa_storage_create_flags_t create_flags)
    908          {
    909            if (data_length > NVM3_MAX_OBJECT_SIZE) {
    910              return PSA_ERROR_STORAGE_FAILURE;
    911            }
    912            if ((data_length != 0U) && (p_data == NULL)) {
    913              return PSA_ERROR_INVALID_ARGUMENT;
    914            }
    915          
    916            if (create_flags != PSA_STORAGE_FLAG_WRITE_ONCE
    917                && create_flags != PSA_STORAGE_FLAG_NONE
    918          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    919                && create_flags != PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
    920          #endif
    921                ) {
    922              return PSA_ERROR_NOT_SUPPORTED;
    923            }
    924          
    925          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    926            if ((create_flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE)
    927                && (!object_lives_in_s(p_data, data_length))) {
    928              // The flag indicates that this data should not be set by the non-secure domain
    929              return PSA_ERROR_INVALID_ARGUMENT;
    930            }
    931          #endif
    932            sli_its_acquire_mutex();
    933            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(uid);
    934            Ecode_t status;
    935            psa_status_t ret = PSA_SUCCESS;
    936            sli_its_file_meta_v2_t* its_file_meta;
    937          
    938          #if defined(SLI_PSA_ITS_ENCRYPTED)
    939            psa_storage_uid_t authenticated_uid;
    940            sli_its_encrypted_blob_t *blob = NULL;
    941            size_t blob_length = 0u;
    942            psa_status_t psa_status;
    943          
    944            size_t its_file_size = data_length + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
    945          #else
    946            size_t its_file_size = data_length;
    947          #endif
    948          
    949            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size + sizeof(sli_its_file_meta_v2_t));
    950            if (its_file_buffer == NULL) {
    951              ret = PSA_ERROR_INSUFFICIENT_MEMORY;
    952              goto exit;
    953            }
    954            memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
    955          
    956            its_file_meta = (sli_its_file_meta_v2_t *)its_file_buffer;
    957            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
    958              // ITS UID was not found. Request a new.
    959              nvm3_object_id = get_nvm3_id(0ULL, true);
    960              if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
    961                // The storage is full, or an error was returned during cleanup.
    962                ret = PSA_ERROR_INSUFFICIENT_STORAGE;
    963              } else {
    964                its_file_meta->uid = uid;
    965                its_file_meta->magic = SLI_PSA_ITS_META_MAGIC_V2;
    966              }
    967            } else {
    968              // ITS UID was found. Read ITS meta data.
    969              status = get_file_metadata(nvm3_object_id, its_file_meta, NULL, NULL);
    970          
    971              if (status != ECODE_NVM3_OK
    972                  && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
    973                ret = PSA_ERROR_STORAGE_FAILURE;
    974                goto exit;
    975              }
    976          
    977              if (its_file_meta->flags == PSA_STORAGE_FLAG_WRITE_ONCE
    978          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    979                  || its_file_meta->flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
    980          #endif
    981                  ) {
    982                ret = PSA_ERROR_NOT_PERMITTED;
    983                goto exit;
    984              }
    985          
    986          #if defined(SLI_PSA_ITS_ENCRYPTED)
    987              // If the UID already exists, authenticate the existing value and make sure the stored UID is the same.
    988              ret = authenticate_its_file(nvm3_object_id, &authenticated_uid);
    989              if (ret != PSA_SUCCESS) {
    990                goto exit;
    991              }
    992          
    993              if (authenticated_uid != uid) {
    994                ret = PSA_ERROR_NOT_PERMITTED;
    995                goto exit;
    996              }
    997          #endif
    998            }
    999          
   1000            its_file_meta->flags = create_flags;
   1001          
   1002          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1003            // Everything after the file metadata will make up the encrypted & authenticated blob
   1004            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
   1005          
   1006            // Encrypt and authenticate the provided data
   1007            psa_status = encrypt_its_file(its_file_meta,
   1008                                          (uint8_t*)p_data,
   1009                                          data_length,
   1010                                          blob,
   1011                                          its_file_size,
   1012                                          &blob_length);
   1013          
   1014            if (psa_status != PSA_SUCCESS) {
   1015              ret = psa_status;
   1016              goto exit;
   1017            }
   1018          
   1019            if (blob_length != its_file_size) {
   1020              ret = PSA_ERROR_HARDWARE_FAILURE;
   1021              goto exit;
   1022            }
   1023          
   1024          #else
   1025            if (data_length != 0U) {
   1026              memcpy(its_file_buffer + sizeof(sli_its_file_meta_v2_t), ((uint8_t*)p_data), data_length);
   1027            }
   1028          #endif
   1029          
   1030            status = nvm3_writeData(nvm3_defaultHandle,
   1031                                    nvm3_object_id,
   1032                                    its_file_buffer, its_file_size + sizeof(sli_its_file_meta_v2_t));
   1033          
   1034            if (status == ECODE_NVM3_OK) {
   1035              // Power-loss might occur, however upon boot, the look-up table will be
   1036              // re-filled as long as the data has been successfully written to NVM3.
   1037              cache_set(nvm3_object_id);
   1038            } else {
   1039              ret = PSA_ERROR_STORAGE_FAILURE;
   1040            }
   1041          
   1042            exit:
   1043            if (its_file_buffer != NULL) {
   1044              // Clear and free key buffer before return.
   1045              memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   1046              mbedtls_free(its_file_buffer);
   1047            }
   1048            sli_its_release_mutex();
   1049            return ret;
   1050          }
   1051          
   1052          /**
   1053           * \brief Retrieve the value associated with a provided uid
   1054           *
   1055           * \param[in] uid               The uid value
   1056           * \param[in] data_offset       The starting offset of the data requested
   1057           * \param[in] data_length       the amount of data requested (and the minimum allocated size of the `p_data` buffer)
   1058           * \param[out] p_data           The buffer where the data will be placed upon successful completion
   1059           * \param[out] p_data_length    The amount of data returned in the p_data buffer
   1060           *
   1061           *
   1062           * \return      A status indicating the success/failure of the operation
   1063           *
   1064           * \retval      PSA_SUCCESS                  The operation completed successfully
   1065           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided `uid` value was not found in the storage
   1066           * \retval      PSA_ERROR_BUFFER_TOO_SMALL   The operation failed because the data associated with provided uid is larger than `data_size`
   1067           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   1068           * \retval      PSA_ERROR_INVALID_ARGUMENT   The operation failed because one of the provided pointers(`p_data`, `p_data_length`)
   1069           *                                           is invalid. For example is `NULL` or references memory the caller cannot access.
   1070           *                                           In addition, this can also happen if an invalid offset was provided.
   1071           */
   1072          psa_status_t psa_its_get(psa_storage_uid_t uid,
   1073                                   uint32_t data_offset,
   1074                                   uint32_t data_length,
   1075                                   void *p_data,
   1076                                   size_t *p_data_length)
   1077          {
   1078            psa_status_t ret = PSA_ERROR_CORRUPTION_DETECTED;
   1079          
   1080            if ((data_length != 0U) && (p_data_length == NULL)) {
   1081              return PSA_ERROR_INVALID_ARGUMENT;
   1082            }
   1083          
   1084            if (data_length != 0U) {
   1085              // If the request amount of data is 0, allow invalid pointer of the output buffer.
   1086              if ((p_data == NULL)
   1087                  || ((uint32_t)p_data < SRAM_BASE)
   1088                  || ((uint32_t)p_data > (SRAM_BASE + SRAM_SIZE - data_length))) {
   1089                return PSA_ERROR_INVALID_ARGUMENT;
   1090              }
   1091            }
   1092          
   1093          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1094            sli_its_encrypted_blob_t *blob = NULL;
   1095            size_t plaintext_length;
   1096            psa_status_t psa_status;
   1097          #endif
   1098            size_t its_file_data_size = 0u;
   1099            Ecode_t status;
   1100            sli_its_file_meta_v2_t its_file_meta = { 0 };
   1101            size_t its_file_size = 0;
   1102            size_t its_file_offset = 0;
   1103          
   1104            sli_its_acquire_mutex();
   1105            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(uid);
   1106            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
   1107              ret = PSA_ERROR_DOES_NOT_EXIST;
   1108              goto exit;
   1109            }
   1110          
   1111            status = get_file_metadata(nvm3_object_id, &its_file_meta, &its_file_offset, &its_file_size);
   1112            if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   1113              ret = PSA_ERROR_DOES_NOT_EXIST;
   1114              goto exit;
   1115            }
   1116            if (status != ECODE_NVM3_OK
   1117                && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   1118              ret = PSA_ERROR_STORAGE_FAILURE;
   1119              goto exit;
   1120            }
   1121          
   1122          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   1123            if (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   1124                && !object_lives_in_s(p_data, data_length)) {
   1125              // The flag indicates that this data should not be read back to the non-secure domain
   1126              ret = PSA_ERROR_INVALID_ARGUMENT;
   1127              goto exit;
   1128            }
   1129          #endif
   1130          
   1131          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1132            // Subtract IV and MAC from ITS file as the below checks concern the actual data size
   1133            its_file_data_size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   1134          #else
   1135            its_file_data_size = its_file_size;
   1136          #endif
   1137          
   1138            if (data_length != 0U) {
   1139              if ((data_offset >= its_file_data_size) && (its_file_data_size != 0U)) {
   1140                ret = PSA_ERROR_INVALID_ARGUMENT;
   1141                goto exit;
   1142              }
   1143          
   1144              if ((its_file_data_size == 0U) && (data_offset != 0U)) {
   1145                ret = PSA_ERROR_INVALID_ARGUMENT;
   1146                goto exit;
   1147              }
   1148            } else {
   1149              // Allow the offset at the data size boundary if the requested amount of data is zero.
   1150              if (data_offset > its_file_data_size) {
   1151                ret = PSA_ERROR_INVALID_ARGUMENT;
   1152                goto exit;
   1153              }
   1154            }
   1155          
   1156            if (data_length > (its_file_data_size - data_offset)) {
   1157              *p_data_length = its_file_data_size - data_offset;
   1158            } else {
   1159              *p_data_length = data_length;
   1160            }
   1161          
   1162          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1163            // its_file_size includes size of sli_its_encrypted_blob_t struct
   1164            blob = (sli_its_encrypted_blob_t*)mbedtls_calloc(1, its_file_size);
   1165            if (blob == NULL) {
   1166              ret = PSA_ERROR_INSUFFICIENT_MEMORY;
   1167              goto exit;
   1168            }
   1169            memset(blob, 0, its_file_size);
   1170          
   1171            status = nvm3_readPartialData(nvm3_defaultHandle,
   1172                                          nvm3_object_id,
   1173                                          blob,
   1174                                          its_file_offset,
   1175                                          its_file_size);
   1176            if (status != ECODE_NVM3_OK) {
   1177              ret = PSA_ERROR_STORAGE_FAILURE;
   1178              goto exit;
   1179            }
   1180          
   1181            // Decrypt and authenticate blob
   1182            psa_status = decrypt_its_file(&its_file_meta,
   1183                                          blob,
   1184                                          its_file_size,
   1185                                          blob->data,
   1186                                          its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   1187                                          &plaintext_length);
   1188          
   1189            if (psa_status != PSA_SUCCESS) {
   1190              ret = psa_status;
   1191              goto exit;
   1192            }
   1193          
   1194            if (plaintext_length != (its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   1195              ret = PSA_ERROR_INVALID_SIGNATURE;
   1196              goto exit;
   1197            }
   1198          
   1199            // Verify that the requested UID is equal to the retrieved and authenticated UID
   1200            if (uid != its_file_meta.uid) {
   1201              ret = PSA_ERROR_INVALID_ARGUMENT;
   1202              goto exit;
   1203            }
   1204          
   1205            if (*p_data_length > 0) {
   1206              memcpy(p_data, blob->data + data_offset, *p_data_length);
   1207            }
   1208            ret = PSA_SUCCESS;
   1209          
   1210            exit:
   1211            if (blob != NULL) {
   1212              memset(blob, 0, its_file_size);
   1213              mbedtls_free(blob);
   1214            }
   1215            sli_its_release_mutex();
   1216          #else
   1217            // If no encryption is used, just read out the data and write it directly to the output buffer
   1218            status = nvm3_readPartialData(nvm3_defaultHandle, nvm3_object_id, p_data, its_file_offset + data_offset, *p_data_length);
   1219          
   1220            if (status != ECODE_NVM3_OK) {
   1221              ret = PSA_ERROR_STORAGE_FAILURE;
   1222            } else {
   1223              ret = PSA_SUCCESS;
   1224            }
   1225          
   1226            exit:
   1227            sli_its_release_mutex();
   1228          #endif
   1229          
   1230            return ret;
   1231          }
   1232          
   1233          /**
   1234           * \brief Retrieve the metadata about the provided uid
   1235           *
   1236           * \param[in] uid           The uid value
   1237           * \param[out] p_info       A pointer to the `psa_storage_info_t` struct that will be populated with the metadata
   1238           *
   1239           * \return      A status indicating the success/failure of the operation
   1240           *
   1241           * \retval      PSA_SUCCESS                  The operation completed successfully
   1242           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided uid value was not found in the storage
   1243           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   1244           * \retval      PSA_ERROR_INVALID_ARGUMENT   The operation failed because one of the provided pointers(`p_info`)
   1245           *                                           is invalid, for example is `NULL` or references memory the caller cannot access
   1246           * \retval      PSA_ERROR_INVALID_SIGANTURE  The operation failed because authentication of the stored metadata failed.
   1247           */
   1248          psa_status_t psa_its_get_info(psa_storage_uid_t uid,
   1249                                        struct psa_storage_info_t *p_info)
   1250          {
   1251            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1252          
   1253            if (p_info == NULL) {
   1254              return PSA_ERROR_INVALID_ARGUMENT;
   1255            }
   1256            Ecode_t status;
   1257            sli_its_file_meta_v2_t its_file_meta = { 0 };
   1258            size_t its_file_size = 0;
   1259            size_t its_file_offset = 0;
   1260          
   1261            sli_its_acquire_mutex();
   1262            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(uid);
   1263            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
   1264              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1265              goto exit;
   1266            }
   1267          
   1268            status = get_file_metadata(nvm3_object_id, &its_file_meta, &its_file_offset, &its_file_size);
   1269            if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   1270              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1271              goto exit;
   1272            }
   1273            if (status != ECODE_NVM3_OK
   1274                && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   1275              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1276              goto exit;
   1277            }
   1278          
   1279          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1280            // Authenticate the ITS file (both metadata and ciphertext) before returning the metadata.
   1281            // Note that this can potentially induce a significant performance hit.
   1282            psa_storage_uid_t authenticated_uid;
   1283            psa_status = authenticate_its_file(nvm3_object_id, &authenticated_uid);
   1284            if (psa_status != PSA_SUCCESS) {
   1285              goto exit;
   1286            }
   1287          
   1288            if (authenticated_uid != uid) {
   1289              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   1290              goto exit;
   1291            }
   1292          #endif
   1293          
   1294            p_info->flags = its_file_meta.flags;
   1295            p_info->size = its_file_size;
   1296          
   1297            psa_status = PSA_SUCCESS;
   1298          
   1299          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1300            // Remove IV and MAC size from file size
   1301            p_info->size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   1302          #endif
   1303            exit:
   1304            sli_its_release_mutex();
   1305            return psa_status;
   1306          }
   1307          
   1308          /**
   1309           * \brief Remove the provided key and its associated data from the storage
   1310           *
   1311           * \param[in] uid   The uid value
   1312           *
   1313           * \return  A status indicating the success/failure of the operation
   1314           *
   1315           * \retval      PSA_SUCCESS                  The operation completed successfully
   1316           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided key value was not found in the storage
   1317           * \retval      PSA_ERROR_NOT_PERMITTED      The operation failed because the provided key value was created with PSA_STORAGE_FLAG_WRITE_ONCE
   1318           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   1319           */
   1320          psa_status_t psa_its_remove(psa_storage_uid_t uid)
   1321          {
   1322            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1323            Ecode_t status;
   1324            sli_its_file_meta_v2_t its_file_meta = { 0 };
   1325            size_t its_file_size = 0;
   1326            size_t its_file_offset = 0;
   1327          
   1328            sli_its_acquire_mutex();
   1329            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(uid);
   1330            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
   1331              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1332              goto exit;
   1333            }
   1334          
   1335            status = get_file_metadata(nvm3_object_id, &its_file_meta, &its_file_offset, &its_file_size);
   1336            if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   1337              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1338              goto exit;
   1339            }
   1340            if (status != ECODE_NVM3_OK
   1341                && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   1342              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1343              goto exit;
   1344            }
   1345          
   1346            if (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE
   1347          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   1348                || its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   1349          #endif
   1350                ) {
   1351              psa_status = PSA_ERROR_NOT_PERMITTED;
   1352              goto exit;
   1353            }
   1354          
   1355          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1356            // If the UID already exists, authenticate the existing value and make sure the stored UID is the same.
   1357            psa_storage_uid_t authenticated_uid;
   1358            psa_status = authenticate_its_file(nvm3_object_id, &authenticated_uid);
   1359            if (psa_status != PSA_SUCCESS) {
   1360              goto exit;
   1361            }
   1362          
   1363            if (authenticated_uid != uid) {
   1364              psa_status = PSA_ERROR_NOT_PERMITTED;
   1365              goto exit;
   1366            }
   1367          #endif
   1368          
   1369            status = nvm3_deleteObject(nvm3_defaultHandle, nvm3_object_id);
   1370          
   1371            if (status == ECODE_NVM3_OK) {
   1372              // Power-loss might occur, however upon boot, the look-up table will be
   1373              // re-filled as long as the data has been successfully written to NVM3.
   1374              if (previous_lookup.set && previous_lookup.uid == uid) {
   1375                previous_lookup.set = false;
   1376              }
   1377              cache_clear(nvm3_object_id);
   1378          
   1379              psa_status = PSA_SUCCESS;
   1380            } else {
   1381              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1382            }
   1383          
   1384            exit:
   1385            sli_its_release_mutex();
   1386            return psa_status;
   1387          }
   1388          
   1389          // -------------------------------------
   1390          // Silicon Labs extensions
   1391          static psa_storage_uid_t psa_its_identifier_of_slot(mbedtls_svc_key_id_t key)
   1392          {
   1393          #if defined(MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER)
   1394            // Encode the owner in the upper 32 bits. This means that if
   1395            // owner values are nonzero (as they are on a PSA platform),
   1396            // no key file will ever have a value less than 0x100000000, so
   1397            // the whole range 0..0xffffffff is available for non-key files.
   1398            uint32_t unsigned_owner_id = MBEDTLS_SVC_KEY_ID_GET_OWNER_ID(key);
   1399            return ((uint64_t)unsigned_owner_id << 32) | MBEDTLS_SVC_KEY_ID_GET_KEY_ID(key);
   1400          #else
   1401            // Use the key id directly as a file name.
   1402            // psa_is_key_id_valid() in psa_crypto_slot_management.c
   1403            // is responsible for ensuring that key identifiers do not have a
   1404            // value that is reserved for non-key files.
   1405            return key;
   1406          #endif
   1407          }
   1408          
   1409          psa_status_t sli_psa_its_change_key_id(mbedtls_svc_key_id_t old_id,
   1410                                                 mbedtls_svc_key_id_t new_id)
   1411          {
   1412            psa_storage_uid_t old_uid = psa_its_identifier_of_slot(old_id);
   1413            psa_storage_uid_t new_uid = psa_its_identifier_of_slot(new_id);
   1414            Ecode_t status;
   1415            uint32_t obj_type;
   1416            size_t its_file_size = 0;
   1417            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1418            int8_t *its_file_buffer = NULL;
   1419            sli_its_file_meta_v2_t* metadata = NULL;
   1420          
   1421          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1422            sli_its_encrypted_blob_t *blob = NULL;
   1423            size_t plaintext_length;
   1424            size_t blob_length;
   1425            psa_status_t encrypt_status;
   1426            psa_status_t decrypt_status;
   1427          #endif
   1428            sli_its_acquire_mutex();
   1429          
   1430            // Check whether the key to migrate exists on disk
   1431            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(old_uid);
   1432            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
   1433              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1434              goto exit;
   1435            }
   1436          
   1437            // Get total length to allocate
   1438            status = nvm3_getObjectInfo(nvm3_defaultHandle,
   1439                                        nvm3_object_id,
   1440                                        &obj_type,
   1441                                        &its_file_size);
   1442            if (status != ECODE_NVM3_OK) {
   1443              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1444              goto exit;
   1445            }
   1446          
   1447            // Allocate temporary buffer and cast it to the metadata format
   1448            its_file_buffer = mbedtls_calloc(1, its_file_size);
   1449            if (its_file_buffer == NULL) {
   1450              psa_status = PSA_ERROR_INSUFFICIENT_MEMORY;
   1451              goto exit;
   1452            }
   1453            metadata = (sli_its_file_meta_v2_t*) its_file_buffer;
   1454          
   1455            // Read contents of pre-existing key into the temporary buffer
   1456            status = nvm3_readData(nvm3_defaultHandle,
   1457                                   nvm3_object_id,
   1458                                   its_file_buffer,
   1459                                   its_file_size);
   1460            if (status != ECODE_NVM3_OK) {
   1461              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1462              goto exit;
   1463            }
   1464          
   1465          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1466            // Decrypt and authenticate blob
   1467            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
   1468            decrypt_status = decrypt_its_file(metadata,
   1469                                              blob,
   1470                                              its_file_size - sizeof(sli_its_file_meta_v2_t),
   1471                                              blob->data,
   1472                                              its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   1473                                              &plaintext_length);
   1474          
   1475            if (decrypt_status != PSA_SUCCESS) {
   1476              psa_status = decrypt_status;
   1477              goto exit;
   1478            }
   1479          
   1480            if (plaintext_length != (its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   1481              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   1482              goto exit;
   1483            }
   1484          #endif
   1485          
   1486            // Swap out the old UID for the new one
   1487          #if defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT)
   1488            if (metadata->magic == SLI_PSA_ITS_META_MAGIC_V1) {
   1489              // Recast as v1 metadata
   1490              sl_its_file_meta_v1_t* metadata_v1 = (sl_its_file_meta_v1_t*) its_file_buffer;
   1491              if (metadata_v1->uid != old_uid) {
   1492                psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1493                goto exit;
   1494              }
   1495              metadata_v1->uid = new_uid;
   1496            } else
   1497          #endif
   1498            if (metadata->magic == SLI_PSA_ITS_META_MAGIC_V2) {
   1499              if (metadata->uid != old_uid) {
   1500                psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1501                goto exit;
   1502              }
   1503              metadata->uid = new_uid;
   1504            } else {
   1505              psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1506              goto exit;
   1507            }
   1508          
   1509          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1510            // Encrypt and authenticate the modified data data
   1511            encrypt_status = encrypt_its_file(metadata,
   1512                                              blob->data,
   1513                                              plaintext_length,
   1514                                              blob,
   1515                                              its_file_size - sizeof(sli_its_file_meta_v2_t),
   1516                                              &blob_length);
   1517          
   1518            if (encrypt_status != PSA_SUCCESS) {
   1519              psa_status = encrypt_status;
   1520              goto exit;
   1521            }
   1522          
   1523            if (blob_length != (its_file_size - sizeof(sli_its_file_meta_v2_t))) {
   1524              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   1525              goto exit;
   1526            }
   1527          #endif
   1528          
   1529            // Overwrite the NVM3 token with the changed buffer
   1530            status = nvm3_writeData(nvm3_defaultHandle,
   1531                                    nvm3_object_id,
   1532                                    its_file_buffer,
   1533                                    its_file_size);
   1534            if (status == ECODE_NVM3_OK) {
   1535              // Update last lookup and report success
   1536              if (previous_lookup.set) {
   1537                if (previous_lookup.uid == old_uid) {
   1538                  previous_lookup.uid = new_uid;
   1539                }
   1540              }
   1541              psa_status = PSA_SUCCESS;
   1542            } else {
   1543              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1544            }
   1545          
   1546            exit:
   1547            if (its_file_buffer != NULL) {
   1548              // Clear and free key buffer before return.
   1549              memset(its_file_buffer, 0, its_file_size);
   1550              mbedtls_free(its_file_buffer);
   1551            }
   1552            sli_its_release_mutex();
   1553            return psa_status;
   1554          }
   1555          
   1556          /**
   1557           * \brief Check if the ITS encryption is enabled
   1558           */
   1559          psa_status_t sli_psa_its_encrypted(void)
   1560          {
   1561            #if defined(SLI_PSA_ITS_ENCRYPTED)
   1562            return PSA_SUCCESS;
   1563            #else
   1564            return PSA_ERROR_NOT_SUPPORTED;
   1565            #endif
   1566          }
   1567          
   1568          #if defined(SLI_PSA_ITS_ENCRYPTED) && !defined(SEMAILBOX_PRESENT)
   1569          /**
   1570           * \brief Set the root key to be used when deriving session keys for ITS encryption.
   1571           *
   1572           * \param[in] root_key        Buffer containing the root key.
   1573           * \param[in] root_key_size   Size of the root key in bytes. Must be 32 (256 bits).
   1574           *
   1575           * \return  A status indicating the success/failure of the operation
   1576           *
   1577           * \retval      PSA_SUCCESS                  The key was successfully set.
   1578           * \retval      PSA_ERROR_INVALID_ARGUMENT   The root key was NULL or had an invalid size.
   1579           * \retval      PSA_ERROR_ALREADY_EXISTS     The root key has already been initialized.
   1580           */
   1581          psa_status_t sli_psa_its_set_root_key(uint8_t *root_key, size_t root_key_size)
   1582          {
   1583            // Check that arguments are valid
   1584            if (root_key == NULL || root_key_size != sizeof(g_root_key.data)) {
   1585              return PSA_ERROR_INVALID_ARGUMENT;
   1586            }
   1587          
   1588            // Check that the root key has not already been set
   1589            // (This is possibly too restrictive. For TrustZone usage this can be enforced by
   1590            // not exposing the function to NS instead.)
   1591            if (g_root_key.initialized) {
   1592              return PSA_ERROR_ALREADY_EXISTS;
   1593            }
   1594          
   1595            // Store the provided root key and mark it as initialized
   1596            memcpy(g_root_key.data, root_key, sizeof(g_root_key.data));
   1597            g_root_key.initialized = true;
   1598          
   1599            return PSA_SUCCESS;
   1600          }
   1601          #endif // defined(SLI_PSA_ITS_ENCRYPTED) && !defined(SEMAILBOX_PRESENT)
   1602          
   1603          #else // (!SL_PSA_ITS_SUPPORT_V3_DRIVER)
   1604          
   1605          // -------------------------------------
   1606          // Defines
   1607          #define SLI_PSA_ITS_V3_DRIVER               (0x3A)
   1608          #define SLI_PSA_ITS_V2_DRIVER               (0x74)
   1609          #define SLI_PSA_ITS_NOT_CHECKED             (0xE8)
   1610          #define SLI_PSA_ITS_V2_DRIVER_FLAG_NVM3_ID  (SLI_PSA_ITS_NVM3_RANGE_START - 1)
   1611          #define SLI_PSA_ITS_NVM3_INVALID_KEY        (0)
   1612          #define SLI_PSA_ITS_NVM3_UNKNOWN_KEY        (1)
   1613          
   1614          #if SL_PSA_ITS_MAX_FILES > SLI_PSA_ITS_NVM3_RANGE_SIZE
   1615          #error "Trying to store more ITS files then our NVM3 range allows for"
   1616          #endif
   1617          
   1618          #define SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE 16
   1619          
   1620          // Internal error codes local to this compile unit
   1621          #define SLI_PSA_ITS_ECODE_NO_VALID_HEADER (ECODE_EMDRV_NVM3_BASE - 1)
   1622          #define SLI_PSA_ITS_ECODE_NEEDS_UPGRADE   (ECODE_EMDRV_NVM3_BASE - 2)
   1623          
   1624          // -------------------------------------
   1625          // Local global static variables
   1626          

   \                                 In section .bss, align 1
   1627          SLI_STATIC bool nvm3_uid_set_cache_initialized = false;
   \                     nvm3_uid_set_cache_initialized:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
   1628          SLI_STATIC uint32_t nvm3_uid_set_cache[(SL_PSA_ITS_MAX_FILES + 31) / 32] = { 0 };
   \                     nvm3_uid_set_cache:
   \        0x0                      DS8 20

   \                                 In section .bss, align 4
   1629          SLI_STATIC uint32_t nvm3_uid_tomb_cache[(SL_PSA_ITS_MAX_FILES + 31) / 32] = { 0 };
   \                     nvm3_uid_tomb_cache:
   \        0x0                      DS8 20
   1630          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   1631          SLI_STATIC uint32_t its_driver_version = SLI_PSA_ITS_NOT_CHECKED;
   1632          #endif // SL_PSA_ITS_SUPPORT_V2_DRIVER
   1633          
   1634          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1635          // The root key is an AES-256 key, and is therefore 32 bytes.
   1636          #define ROOT_KEY_SIZE     (32)
   1637          // The session key is derived from CMAC, which means it is equal to the AES block size, i.e. 16 bytes
   1638          #define SESSION_KEY_SIZE  (16)
   1639          
   1640          #if !defined(SEMAILBOX_PRESENT)
   1641          typedef struct {
   1642            bool initialized;
   1643            uint8_t data[ROOT_KEY_SIZE];
   1644          } root_key_t;
   1645          
   1646          static root_key_t g_root_key = {
   1647            .initialized = false,
   1648            .data = { 0 },
   1649          };
   1650          #endif // !defined(SEMAILBOX_PRESENT)
   1651          
   1652          typedef struct {
   1653            bool active;
   1654            psa_storage_uid_t uid;
   1655            uint8_t data[SESSION_KEY_SIZE];
   1656          } session_key_t;
   1657          
   1658          static session_key_t g_cached_session_key = {
   1659            .active = false,
   1660            .uid = 0,
   1661            .data = { 0 },
   1662          };
   1663          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
   1664          
   1665          // -------------------------------------
   1666          // Structs
   1667          
   1668          #if defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   1669          typedef struct {
   1670            uint32_t magic;
   1671            psa_storage_uid_t uid;
   1672            psa_storage_create_flags_t flags;
   1673          } sl_its_file_meta_v1_t;
   1674          #endif // defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   1675          
   1676          // -------------------------------------
   1677          // Local function prototypes
   1678          
   1679          static psa_status_t find_nvm3_id(psa_storage_uid_t uid,
   1680                                           bool find_empty_slot,
   1681                                           sli_its_file_meta_v2_t* its_file_meta,
   1682                                           size_t* its_file_offset,
   1683                                           size_t* its_file_size,
   1684                                           nvm3_ObjectKey_t * output_nvm3_id);
   1685          static nvm3_ObjectKey_t derive_nvm3_id(psa_storage_uid_t uid);
   1686          
   1687          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   1688          static inline bool object_lives_in_s(const void *object, size_t object_size);
   1689          #endif
   1690          
   1691          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1692          static psa_status_t derive_session_key(uint8_t *iv,
   1693                                                 size_t iv_size,
   1694                                                 uint8_t *session_key,
   1695                                                 size_t session_key_size);
   1696          
   1697          static psa_status_t sli_decrypt_its_file(sli_its_file_meta_v2_t *metadata,
   1698                                                   sli_its_encrypted_blob_t *blob,
   1699                                                   size_t blob_size,
   1700                                                   uint8_t *plaintext,
   1701                                                   size_t plaintext_size,
   1702                                                   size_t *plaintext_length);
   1703          
   1704          static psa_status_t authenticate_its_file(nvm3_ObjectKey_t nvm3_object_id,
   1705                                                    psa_storage_uid_t *authenticated_uid);
   1706          #endif
   1707          
   1708          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   1709          static psa_status_t psa_its_get_legacy(nvm3_ObjectKey_t nvm3_object_id,
   1710                                                 sli_its_file_meta_v2_t* its_file_meta,
   1711                                                 size_t its_file_size,
   1712                                                 size_t its_file_offset, void *p_data);
   1713          static psa_status_t detect_legacy_versions();
   1714          static psa_status_t upgrade_all_keys();
   1715          
   1716          #if defined (SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   1717          psa_status_t psa_its_set_v1(psa_storage_uid_t uid,
   1718                                      uint32_t data_length,
   1719                                      const void *p_data,
   1720                                      psa_storage_create_flags_t create_flags);
   1721          #endif // SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL
   1722          #endif // SL_PSA_ITS_SUPPORT_V2_DRIVER
   1723          
   1724          // -------------------------------------
   1725          // Local function definitions

   \                                 In section .text, align 2, keep-with-next
   1726          static inline uint32_t get_index(nvm3_ObjectKey_t key)
   1727          {
   1728            return (key - (SLI_PSA_ITS_NVM3_RANGE_START)) / 32;
   \                     get_index: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \        0x4   0x1808             ADDS     R0,R1,R0
   \        0x6   0x0940             LSRS     R0,R0,#+5
   \        0x8   0x4770             BX       LR
   1729          }
   1730          

   \                                 In section .text, align 2, keep-with-next
   1731          static inline uint32_t get_offset(nvm3_ObjectKey_t key)
   1732          {
   1733            return (key - (SLI_PSA_ITS_NVM3_RANGE_START)) % 32;
   \                     get_offset: (+1)
   \        0x0   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \        0x4   0x4770             BX       LR
   1734          }
   1735          

   \                                 In section .text, align 2, keep-with-next
   1736          static inline void set_cache(nvm3_ObjectKey_t key)
   1737          {
   \                     set_cache: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1738            nvm3_uid_set_cache[get_index(key)] |= (1 << get_offset(key));
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       get_index
   \        0xC   0x4680             MOV      R8,R0
   \        0xE   0x2501             MOVS     R5,#+1
   \       0x10   0x.... 0x....      LDR.W    R6,??DataTable16_7
   \       0x14   0xF856 0x7028      LDR      R7,[R6, R8, LSL #+2]
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       get_offset
   \       0x1E   0xFA15 0xF000      LSLS     R0,R5,R0
   \       0x22   0x4307             ORRS     R7,R0,R7
   \       0x24   0xF846 0x7028      STR      R7,[R6, R8, LSL #+2]
   1739            nvm3_uid_tomb_cache[get_index(key)] &= ~(1 << get_offset(key));
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       get_index
   \       0x2E   0x4680             MOV      R8,R0
   \       0x30   0x.... 0x....      LDR.W    R6,??DataTable16_8
   \       0x34   0xF856 0x7028      LDR      R7,[R6, R8, LSL #+2]
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       get_offset
   \       0x3E   0x4085             LSLS     R5,R5,R0
   \       0x40   0xEA37 0x0505      BICS     R5,R7,R5
   \       0x44   0xF846 0x5028      STR      R5,[R6, R8, LSL #+2]
   1740          }
   \       0x48   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1741          

   \                                 In section .text, align 2, keep-with-next
   1742          static inline void set_tomb(nvm3_ObjectKey_t key)
   1743          {
   \                     set_tomb: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1744            nvm3_uid_tomb_cache[get_index(key)] |= (1 << get_offset(key));
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       get_index
   \        0xC   0x4680             MOV      R8,R0
   \        0xE   0x.... 0x....      LDR.W    R5,??DataTable16_8
   \       0x12   0xF855 0x6028      LDR      R6,[R5, R8, LSL #+2]
   \       0x16   0x2701             MOVS     R7,#+1
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       get_offset
   \       0x1E   0x4087             LSLS     R7,R7,R0
   \       0x20   0x433E             ORRS     R6,R7,R6
   \       0x22   0xF845 0x6028      STR      R6,[R5, R8, LSL #+2]
   1745          
   1746            uint32_t cache_not_empty = 0;
   \       0x26   0x2000             MOVS     R0,#+0
   1747            for ( size_t i = 0; i < (((SL_PSA_ITS_MAX_FILES) +31) / 32); i++ ) {
   \       0x28   0x2200             MOVS     R2,#+0
   \                     ??set_tomb_0: (+1)
   \       0x2A   0x2A05             CMP      R2,#+5
   \       0x2C   0xD206             BCS.N    ??set_tomb_1
   1748              cache_not_empty += nvm3_uid_set_cache[i];
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \       0x32   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \       0x36   0x1808             ADDS     R0,R1,R0
   1749            }
   \       0x38   0x1C52             ADDS     R2,R2,#+1
   \       0x3A   0xE7F6             B.N      ??set_tomb_0
   1750            if (cache_not_empty == 0) {
   \                     ??set_tomb_1: (+1)
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD107             BNE.N    ??set_tomb_2
   1751              for ( size_t i = 0; i < (((SL_PSA_ITS_MAX_FILES) +31) / 32); i++ ) {
   \       0x40   0x2200             MOVS     R2,#+0
   \                     ??set_tomb_3: (+1)
   \       0x42   0x2A05             CMP      R2,#+5
   \       0x44   0xD204             BCS.N    ??set_tomb_2
   1752                nvm3_uid_tomb_cache[i] = 0;
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0xF845 0x1022      STR      R1,[R5, R2, LSL #+2]
   1753              }
   \       0x4C   0x1C52             ADDS     R2,R2,#+1
   \       0x4E   0xE7F8             B.N      ??set_tomb_3
   1754            }
   1755          }
   \                     ??set_tomb_2: (+1)
   \       0x50   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1756          
   1757          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   1758          static inline psa_status_t write_driver_v3()
   1759          {
   1760            uint8_t driver_verison = SLI_PSA_ITS_V3_DRIVER;
   1761            Ecode_t status;
   1762            status = nvm3_writeData(nvm3_defaultHandle,
   1763                                    SLI_PSA_ITS_V2_DRIVER_FLAG_NVM3_ID,
   1764                                    &driver_verison, sizeof(uint8_t));
   1765            if ( status != ECODE_NVM3_OK ) {
   1766              return PSA_ERROR_STORAGE_FAILURE;
   1767            }
   1768            return PSA_SUCCESS;
   1769          }
   1770          #endif
   1771          
   1772          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   1773          // If an object of given size is fully encapsulated in a region of
   1774          // secure domain the function returns true.
   1775          static inline bool object_lives_in_s(const void *object, size_t object_size)
   1776          {
   1777            cmse_address_info_t cmse_flags;
   1778          
   1779            for (size_t i = 0u; i < object_size; i++) {
   1780              cmse_flags = cmse_TTA((uint32_t *)object + i);
   1781              if (!cmse_flags.flags.secure) {
   1782                return false;
   1783              }
   1784            }
   1785          
   1786            return true;
   1787          }
   1788          #endif
   1789          

   \                                 In section .text, align 2, keep-with-next
   1790          static inline void clear_cache(nvm3_ObjectKey_t key)
   1791          {
   \                     clear_cache: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   1792            nvm3_uid_set_cache[get_index(key)] ^= (1 << get_offset(key));
   \        0x6   0x4640             MOV      R0,R8
   \        0x8   0x.... 0x....      BL       get_index
   \        0xC   0x0004             MOVS     R4,R0
   \        0xE   0x.... 0x....      LDR.W    R5,??DataTable16_7
   \       0x12   0xF855 0x6024      LDR      R6,[R5, R4, LSL #+2]
   \       0x16   0x2701             MOVS     R7,#+1
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0x.... 0x....      BL       get_offset
   \       0x1E   0x4087             LSLS     R7,R7,R0
   \       0x20   0x407E             EORS     R6,R7,R6
   \       0x22   0xF845 0x6024      STR      R6,[R5, R4, LSL #+2]
   1793          }
   \       0x26   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1794          

   \                                 In section .text, align 2, keep-with-next
   1795          static inline bool lookup_cache(nvm3_ObjectKey_t key)
   1796          {
   \                     lookup_cache: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1797            return (bool)((nvm3_uid_set_cache[get_index(key)] >> get_offset(key)) & 0x1);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       get_index
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \        0xE   0xF851 0x5020      LDR      R5,[R1, R0, LSL #+2]
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       get_offset
   \       0x18   0x40C5             LSRS     R5,R5,R0
   \       0x1A   0xF015 0x0501      ANDS     R5,R5,#0x1
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
   1798          }
   1799          

   \                                 In section .text, align 2, keep-with-next
   1800          static inline bool lookup_tomb(nvm3_ObjectKey_t key)
   1801          {
   \                     lookup_tomb: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1802            return (bool)((nvm3_uid_tomb_cache[get_index(key)] >> get_offset(key)) & 0x1);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       get_index
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \        0xE   0xF851 0x5020      LDR      R5,[R1, R0, LSL #+2]
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       get_offset
   \       0x18   0x40C5             LSRS     R5,R5,R0
   \       0x1A   0xF015 0x0501      ANDS     R5,R5,#0x1
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
   1803          }
   1804          

   \                                 In section .text, align 2, keep-with-next
   1805          static inline nvm3_ObjectKey_t increment_obj_id(nvm3_ObjectKey_t id)
   1806          {
   1807            return SLI_PSA_ITS_NVM3_RANGE_START + ((id - SLI_PSA_ITS_NVM3_RANGE_START + 1)
   1808                                                   % SL_PSA_ITS_MAX_FILES);
   \                     increment_obj_id: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable16_9
   \        0x4   0x1808             ADDS     R0,R1,R0
   \        0x6   0x228A             MOVS     R2,#+138
   \        0x8   0xFBB0 0xF1F2      UDIV     R1,R0,R2
   \        0xC   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \       0x10   0xF500 0x2000      ADD      R0,R0,#+524288
   \       0x14   0xF510 0x40DA      ADDS     R0,R0,#+27904
   \       0x18   0x4770             BX       LR
   1809          }

   \                                 In section .text, align 2, keep-with-next
   1810          static inline nvm3_ObjectKey_t prng(psa_storage_uid_t uid)
   1811          {
   \                     prng: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0002             MOVS     R2,R0
   \        0x4   0x000B             MOVS     R3,R1
   1812          // Squash uid down to a 32 bit word
   1813            nvm3_ObjectKey_t uid_32 = uid & 0xFFFFFFFF;
   \        0x6   0x0010             MOVS     R0,R2
   1814            nvm3_ObjectKey_t xored_32 = (uid >> 32) ^ uid_32;
   \        0x8   0x0019             MOVS     R1,R3
   \        0xA   0x4041             EORS     R1,R0,R1
   1815            nvm3_ObjectKey_t temp;
   1816          // Accumulate all "entropy" towards the LSB, since that is where we need it
   1817            for ( size_t i = 1; i < 4; i++ ) {
   \        0xC   0x2501             MOVS     R5,#+1
   \                     ??prng_0: (+1)
   \        0xE   0x2D04             CMP      R5,#+4
   \       0x10   0xD20D             BCS.N    ??prng_1
   1818              temp = xored_32 ^ (xored_32 >> (8 * i));
   \       0x12   0x002E             MOVS     R6,R5
   \       0x14   0xB2F6             UXTB     R6,R6
   \       0x16   0x00F7             LSLS     R7,R6,#+3
   \       0x18   0x000E             MOVS     R6,R1
   \       0x1A   0x40FE             LSRS     R6,R6,R7
   \       0x1C   0x404E             EORS     R6,R6,R1
   \       0x1E   0x0034             MOVS     R4,R6
   1819              if ((temp & 0x3) != 0 ) {
   \       0x20   0xF014 0x0F03      TST      R4,#0x3
   \       0x24   0xD000             BEQ.N    ??prng_2
   1820                temp = temp << 2;
   \       0x26   0x00A4             LSLS     R4,R4,#+2
   1821              }
   1822              uid_32 = (uid_32 + temp);
   \                     ??prng_2: (+1)
   \       0x28   0x1820             ADDS     R0,R4,R0
   1823            }
   \       0x2A   0x1C6D             ADDS     R5,R5,#+1
   \       0x2C   0xE7EF             B.N      ??prng_0
   1824            return uid_32;
   \                     ??prng_1: (+1)
   \       0x2E   0xBCF0             POP      {R4-R7}
   \       0x30   0x4770             BX       LR
   1825          }
   1826          

   \                                 In section .text, align 2, keep-with-next
   1827          static inline nvm3_ObjectKey_t derive_nvm3_id(psa_storage_uid_t uid)
   1828          {
   \                     derive_nvm3_id: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1829            return SLI_PSA_ITS_NVM3_RANGE_START + (prng(uid) % (SL_PSA_ITS_MAX_FILES));
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x.... 0x....      BL       prng
   \        0xE   0x228A             MOVS     R2,#+138
   \       0x10   0xFBB0 0xF1F2      UDIV     R1,R0,R2
   \       0x14   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \       0x18   0xF500 0x2000      ADD      R0,R0,#+524288
   \       0x1C   0xF510 0x40DA      ADDS     R0,R0,#+27904
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
   1830          }
   1831          

   \                                 In section .text, align 2, keep-with-next
   1832          static void init_cache(void)
   1833          {
   \                     init_cache: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB0A1             SUB      SP,SP,#+132
   \        0x6   0x2140             MOVS     R1,#+64
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0xAD11             ADD      R5,SP,#+68
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       __aeabi_memset
   \       0x12   0x2140             MOVS     R1,#+64
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0xAE01             ADD      R6,SP,#+4
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x.... 0x....      BL       __aeabi_memset
   1834            size_t num_keys_referenced_by_nvm3;
   1835            nvm3_ObjectKey_t keys_referenced_by_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = { 0 };
   1836            size_t num_del_keys_from_nvm3;
   1837            nvm3_ObjectKey_t deleted_keys_from_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = { 0 };
   1838            for (nvm3_ObjectKey_t range_start = SLI_PSA_ITS_NVM3_RANGE_START;
   \       0x1E   0x.... 0x....      LDR.W    R6,??DataTable16_10
   1839                 range_start < SLI_PSA_ITS_NVM3_RANGE_END;
   \                     ??init_cache_0: (+1)
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable16_11
   \       0x26   0x428E             CMP      R6,R1
   \       0x28   0xD236             BCS.N    ??init_cache_1
   1840                 range_start += SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE) {
   1841              nvm3_ObjectKey_t range_end = range_start + SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE;
   \       0x2A   0xF116 0x0710      ADDS     R7,R6,#+16
   1842              if (range_end > SLI_PSA_ITS_NVM3_RANGE_END) {
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \       0x32   0x4287             CMP      R7,R0
   \       0x34   0xD300             BCC.N    ??init_cache_2
   1843                range_end = SLI_PSA_ITS_NVM3_RANGE_END;
   \       0x36   0x000F             MOVS     R7,R1
   1844              }
   1845          
   1846              num_keys_referenced_by_nvm3 = nvm3_enumObjects(nvm3_defaultHandle,
   1847                                                             keys_referenced_by_nvm3,
   1848                                                             sizeof(keys_referenced_by_nvm3) / sizeof(nvm3_ObjectKey_t),
   1849                                                             range_start,
   1850                                                             range_end - 1);
   \                     ??init_cache_2: (+1)
   \       0x38   0x.... 0x....      LDR.W    R8,??DataTable16_13
   \       0x3C   0x1E78             SUBS     R0,R7,#+1
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0x0033             MOVS     R3,R6
   \       0x42   0x2210             MOVS     R2,#+16
   \       0x44   0xA911             ADD      R1,SP,#+68
   \       0x46   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x4A   0x.... 0x....      BL       nvm3_enumObjects
   \       0x4E   0x0004             MOVS     R4,R0
   1851          
   1852              for (size_t i = 0; i < num_keys_referenced_by_nvm3; i++) {
   \       0x50   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??init_cache_3: (+1)
   \       0x54   0x45A1             CMP      R9,R4
   \       0x56   0xD207             BCS.N    ??init_cache_4
   1853                set_cache(keys_referenced_by_nvm3[i]);
   \       0x58   0xA811             ADD      R0,SP,#+68
   \       0x5A   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \       0x5E   0x.... 0x....      BL       set_cache
   1854              }
   \       0x62   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x66   0xE7F5             B.N      ??init_cache_3
   1855              num_del_keys_from_nvm3 = nvm3_enumDeletedObjects(nvm3_defaultHandle,
   1856                                                               deleted_keys_from_nvm3,
   1857                                                               sizeof(deleted_keys_from_nvm3) / sizeof(nvm3_ObjectKey_t),
   1858                                                               range_start,
   1859                                                               range_end - 1);
   \                     ??init_cache_4: (+1)
   \       0x68   0x1E78             SUBS     R0,R7,#+1
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0x0033             MOVS     R3,R6
   \       0x6E   0x2210             MOVS     R2,#+16
   \       0x70   0xA901             ADD      R1,SP,#+4
   \       0x72   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x76   0x.... 0x....      BL       nvm3_enumDeletedObjects
   \       0x7A   0x0005             MOVS     R5,R0
   1860              for (size_t i = 0; i < num_del_keys_from_nvm3; i++) {
   \       0x7C   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??init_cache_5: (+1)
   \       0x80   0x45A8             CMP      R8,R5
   \       0x82   0xD207             BCS.N    ??init_cache_6
   1861                set_tomb(deleted_keys_from_nvm3[i]);
   \       0x84   0xA801             ADD      R0,SP,#+4
   \       0x86   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \       0x8A   0x.... 0x....      BL       set_tomb
   1862              }
   \       0x8E   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x92   0xE7F5             B.N      ??init_cache_5
   1863            }
   \                     ??init_cache_6: (+1)
   \       0x94   0x3610             ADDS     R6,R6,#+16
   \       0x96   0xE7C4             B.N      ??init_cache_0
   1864            nvm3_uid_set_cache_initialized = true;
   \                     ??init_cache_1: (+1)
   \       0x98   0x2101             MOVS     R1,#+1
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable16_14
   \       0x9E   0x7001             STRB     R1,[R0, #+0]
   1865          }
   \       0xA0   0xB021             ADD      SP,SP,#+132
   \       0xA2   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1866          
   1867          // Read the file metadata for a specific NVM3 ID

   \                                 In section .text, align 2, keep-with-next
   1868          static Ecode_t get_file_metadata(nvm3_ObjectKey_t key,
   1869                                           sli_its_file_meta_v2_t* metadata,
   1870                                           size_t* its_file_offset,
   1871                                           size_t* its_file_size)
   1872          {
   \                     get_file_metadata: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
   1873            // Initialize output variables to safe default
   1874            if (its_file_offset != NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD001             BEQ.N    ??get_file_metadata_0
   1875              *its_file_offset = 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x6020             STR      R0,[R4, #+0]
   1876            }
   1877            if (its_file_size != NULL) {
   \                     ??get_file_metadata_0: (+1)
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD001             BEQ.N    ??get_file_metadata_1
   1878              *its_file_size = 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6028             STR      R0,[R5, #+0]
   1879            }
   1880          
   1881            Ecode_t status = nvm3_readPartialData(nvm3_defaultHandle,
   1882                                                  key,
   1883                                                  metadata,
   1884                                                  0,
   1885                                                  sizeof(sli_its_file_meta_v2_t));
   \                     ??get_file_metadata_1: (+1)
   \       0x1C   0x.... 0x....      LDR.W    R9,??DataTable16_13
   \       0x20   0x2010             MOVS     R0,#+16
   \       0x22   0x9000             STR      R0,[SP, #+0]
   \       0x24   0x2300             MOVS     R3,#+0
   \       0x26   0x4642             MOV      R2,R8
   \       0x28   0x0039             MOVS     R1,R7
   \       0x2A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x2E   0x.... 0x....      BL       nvm3_readPartialData
   \       0x32   0x0006             MOVS     R6,R0
   1886            if (status != ECODE_NVM3_OK) {
   \       0x34   0x2E00             CMP      R6,#+0
   \       0x36   0xD001             BEQ.N    ??get_file_metadata_2
   1887              return status;
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0xE01E             B.N      ??get_file_metadata_3
   1888            }
   1889          
   1890          #if defined (SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   1891            // Re-read in v1 header format and translate to the latest structure version
   1892            if (metadata->magic == SLI_PSA_ITS_META_MAGIC_V1) {
   1893              sl_its_file_meta_v1_t key_meta_v1 = { 0 };
   1894              status = nvm3_readPartialData(nvm3_defaultHandle,
   1895                                            key,
   1896                                            &key_meta_v1,
   1897                                            0,
   1898                                            sizeof(sl_its_file_meta_v1_t));
   1899          
   1900              if (status != ECODE_NVM3_OK) {
   1901                return status;
   1902              }
   1903          
   1904              metadata->flags = key_meta_v1.flags;
   1905              metadata->uid = key_meta_v1.uid;
   1906              metadata->magic = SLI_PSA_ITS_META_MAGIC_V2;
   1907          
   1908              if (its_file_offset != NULL) {
   1909                *its_file_offset = sizeof(sl_its_file_meta_v1_t);
   1910              }
   1911          
   1912              status = SLI_PSA_ITS_ECODE_NEEDS_UPGRADE;
   1913            } else
   1914          #endif
   1915            {
   1916              if (its_file_offset != NULL) {
   \                     ??get_file_metadata_2: (+1)
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD001             BEQ.N    ??get_file_metadata_4
   1917                *its_file_offset = sizeof(sli_its_file_meta_v2_t);
   \       0x40   0x2010             MOVS     R0,#+16
   \       0x42   0x6020             STR      R0,[R4, #+0]
   1918              }
   1919            }
   1920          
   1921            if (metadata->magic != SLI_PSA_ITS_META_MAGIC_V2) {
   \                     ??get_file_metadata_4: (+1)
   \       0x44   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable16_15
   \       0x4C   0x4281             CMP      R1,R0
   \       0x4E   0xD002             BEQ.N    ??get_file_metadata_5
   1922              // No valid header found in this object
   1923              return SLI_PSA_ITS_ECODE_NO_VALID_HEADER;
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable16_16
   \       0x54   0xE011             B.N      ??get_file_metadata_3
   1924            }
   1925          
   1926            if (its_file_offset != NULL && its_file_size != NULL) {
   \                     ??get_file_metadata_5: (+1)
   \       0x56   0x2C00             CMP      R4,#+0
   \       0x58   0xD00E             BEQ.N    ??get_file_metadata_6
   \       0x5A   0x2D00             CMP      R5,#+0
   \       0x5C   0xD00C             BEQ.N    ??get_file_metadata_6
   1927              // Calculate the ITS file size if requested
   1928              uint32_t obj_type;
   1929              Ecode_t info_status = nvm3_getObjectInfo(nvm3_defaultHandle,
   1930                                                       key,
   1931                                                       &obj_type,
   1932                                                       its_file_size);
   \       0x5E   0x002B             MOVS     R3,R5
   \       0x60   0x466A             MOV      R2,SP
   \       0x62   0x0039             MOVS     R1,R7
   \       0x64   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x68   0x.... 0x....      BL       nvm3_getObjectInfo
   1933              if (info_status != ECODE_NVM3_OK) {
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD104             BNE.N    ??get_file_metadata_3
   1934                return info_status;
   1935              }
   1936          
   1937              *its_file_size = *its_file_size - *its_file_offset;
   \                     ??get_file_metadata_7: (+1)
   \       0x70   0x682A             LDR      R2,[R5, #+0]
   \       0x72   0x6821             LDR      R1,[R4, #+0]
   \       0x74   0x1A52             SUBS     R2,R2,R1
   \       0x76   0x602A             STR      R2,[R5, #+0]
   1938            }
   1939          
   1940            return status;
   \                     ??get_file_metadata_6: (+1)
   \       0x78   0x0030             MOVS     R0,R6
   \                     ??get_file_metadata_3: (+1)
   \       0x7A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1941          }
   1942          
   1943          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   1944          static psa_status_t psa_its_get_legacy(nvm3_ObjectKey_t nvm3_object_id,
   1945                                                 sli_its_file_meta_v2_t* its_file_meta,
   1946                                                 size_t its_file_size,
   1947                                                 size_t its_file_offset,
   1948                                                 void *p_data)
   1949          {
   1950            Ecode_t status;
   1951            if (its_file_size == 0) {
   1952              if (its_file_meta != NULL) {
   1953                return PSA_ERROR_DATA_INVALID;
   1954              }
   1955            }
   1956          
   1957          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1958            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1959            sli_its_encrypted_blob_t *blob = NULL;
   1960            size_t plaintext_length;
   1961          
   1962            // its_file_size includes size of sli_its_encrypted_blob_t struct
   1963            blob = (sli_its_encrypted_blob_t*)mbedtls_calloc(1, its_file_size);
   1964            if (blob == NULL) {
   1965              return PSA_ERROR_INSUFFICIENT_MEMORY;
   1966            }
   1967            memset(blob, 0, its_file_size);
   1968          
   1969            status = nvm3_readPartialData(nvm3_defaultHandle,
   1970                                          nvm3_object_id,
   1971                                          blob,
   1972                                          its_file_offset,
   1973                                          its_file_size);
   1974            if (status != ECODE_NVM3_OK) {
   1975              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1976              goto cleanup;
   1977            }
   1978          
   1979            // Decrypt and authenticate blob
   1980            psa_status = sli_decrypt_its_file(its_file_meta,
   1981                                              blob,
   1982                                              its_file_size,
   1983                                              blob->data,
   1984                                              its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   1985                                              &plaintext_length);
   1986          
   1987            if (psa_status != PSA_SUCCESS) {
   1988              goto cleanup;
   1989            }
   1990          
   1991            if (plaintext_length != (its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   1992              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   1993              goto cleanup;
   1994            }
   1995          
   1996            if (its_file_size + its_file_offset > 0) {
   1997              memcpy(p_data, blob->data, its_file_size + its_file_offset);
   1998            }
   1999            psa_status = PSA_SUCCESS;
   2000          
   2001            cleanup:
   2002            if (blob != NULL) {
   2003              memset(blob, 0, its_file_size);
   2004              mbedtls_free(blob);
   2005            }
   2006            return psa_status;
   2007          #else
   2008            // If no encryption is used, just read out the data and write it directly to the output buffer
   2009            status = nvm3_readPartialData(nvm3_defaultHandle, nvm3_object_id, p_data,
   2010                                          its_file_offset, its_file_size);
   2011          
   2012            if (status != ECODE_NVM3_OK) {
   2013              return PSA_ERROR_STORAGE_FAILURE;
   2014            } else {
   2015              return PSA_SUCCESS;
   2016            }
   2017          #endif
   2018          }
   2019          
   2020          // Function sets detect the presence of v1 and v2 its driver. If there is something
   2021          // stored in v1/v2 driver range, it sets its_driver_version to SLI_PSA_ITS_V2_DRIVER.
   2022          static psa_status_t detect_legacy_versions()
   2023          {
   2024            uint8_t driver_verison = 0;
   2025            Ecode_t status;
   2026            status = nvm3_readData(nvm3_defaultHandle, SLI_PSA_ITS_V2_DRIVER_FLAG_NVM3_ID,
   2027                                   &driver_verison, sizeof(uint8_t));
   2028            if ((status != ECODE_NVM3_OK) && (status != ECODE_NVM3_ERR_KEY_NOT_FOUND)) {
   2029              return PSA_ERROR_STORAGE_FAILURE;
   2030            }
   2031            if (driver_verison == SLI_PSA_ITS_V3_DRIVER) {
   2032              its_driver_version = SLI_PSA_ITS_V3_DRIVER;
   2033              return PSA_SUCCESS;
   2034            }
   2035          
   2036            size_t num_keys_referenced_by_nvm3;
   2037          
   2038            nvm3_ObjectKey_t keys_referenced_by_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = {
   2039              0
   2040            };
   2041          
   2042            for ( nvm3_ObjectKey_t range_start = SLI_PSA_ITS_NVM3_RANGE_START_V2_DRIVER;
   2043                  range_start < SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER;
   2044                  range_start += SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE ) {
   2045              nvm3_ObjectKey_t range_end =
   2046                range_start + SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE;
   2047              if (range_end > SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER ) {
   2048                range_end = SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER;
   2049              }
   2050          
   2051              num_keys_referenced_by_nvm3 = nvm3_enumObjects(nvm3_defaultHandle,
   2052                                                             keys_referenced_by_nvm3,
   2053                                                             sizeof(keys_referenced_by_nvm3)
   2054                                                             / sizeof(nvm3_ObjectKey_t),
   2055                                                             range_start,
   2056                                                             range_end - 1);
   2057          
   2058              if (num_keys_referenced_by_nvm3 > 0) {
   2059                sli_its_file_meta_v2_t its_file_meta = { 0 };
   2060                size_t its_file_size = 0;
   2061                size_t its_file_offset = 0;
   2062                status = get_file_metadata(keys_referenced_by_nvm3[0],
   2063                                           &its_file_meta, &its_file_offset,
   2064                                           &its_file_size);
   2065                if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   2066                  return PSA_ERROR_DOES_NOT_EXIST;
   2067                }
   2068                if (status != ECODE_NVM3_OK
   2069                    && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   2070                  return PSA_ERROR_STORAGE_FAILURE;
   2071                }
   2072          
   2073                if ((its_file_meta.magic == SLI_PSA_ITS_META_MAGIC_V1)
   2074                    || (its_file_meta.magic == SLI_PSA_ITS_META_MAGIC_V2)) {
   2075                  its_driver_version = SLI_PSA_ITS_V2_DRIVER;
   2076                  return PSA_SUCCESS;
   2077                } else {
   2078                  return PSA_ERROR_STORAGE_FAILURE;
   2079                }
   2080              }
   2081            }
   2082            its_driver_version = SLI_PSA_ITS_V3_DRIVER;
   2083            return PSA_SUCCESS;
   2084          }
   2085          
   2086          static psa_status_t upgrade_all_keys()
   2087          {
   2088            size_t num_keys_referenced_by_nvm3;
   2089            nvm3_ObjectKey_t keys_referenced_by_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = {
   2090              0
   2091            };
   2092            Ecode_t status;
   2093            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2094          
   2095            sli_its_file_meta_v2_t its_file_meta = { 0 };
   2096            size_t its_file_data_size;
   2097            uint8_t * its_file_buffer = NULL;
   2098          
   2099            size_t its_file_size = 0;
   2100            size_t its_file_offset;
   2101          
   2102            for ( nvm3_ObjectKey_t range_start = SLI_PSA_ITS_NVM3_RANGE_START_V2_DRIVER;
   2103                  range_start < SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER;
   2104                  range_start += SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE ) {
   2105              nvm3_ObjectKey_t range_end =
   2106                range_start + SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE;
   2107              if (range_end >= SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER ) {
   2108                range_end = SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER;
   2109              }
   2110          
   2111              num_keys_referenced_by_nvm3 = nvm3_enumObjects(nvm3_defaultHandle,
   2112                                                             keys_referenced_by_nvm3,
   2113                                                             sizeof(keys_referenced_by_nvm3)
   2114                                                             /
   2115                                                             sizeof(nvm3_ObjectKey_t),
   2116                                                             range_start,
   2117                                                             range_end - 1);
   2118              for ( size_t i = 0; i < num_keys_referenced_by_nvm3; i++ ) {
   2119                its_file_size = 0;
   2120                its_file_offset = 0;
   2121                status = get_file_metadata(keys_referenced_by_nvm3[i],
   2122                                           &(its_file_meta), &its_file_offset,
   2123                                           &its_file_size);
   2124                if ( status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   2125                  return PSA_ERROR_DOES_NOT_EXIST;
   2126                }
   2127                if ( status != ECODE_NVM3_OK
   2128                     && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   2129                  return PSA_ERROR_STORAGE_FAILURE;
   2130                }
   2131          
   2132          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2133                // Subtract IV and MAC from ITS file as the below checks concern the actual data size
   2134                its_file_data_size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   2135          #else
   2136                its_file_data_size = its_file_size;
   2137          #endif
   2138          
   2139                if ((its_file_meta.magic != SLI_PSA_ITS_META_MAGIC_V2)
   2140                    && (its_file_meta.magic != SLI_PSA_ITS_META_MAGIC_V1)) {
   2141                  return PSA_ERROR_STORAGE_FAILURE;
   2142                }
   2143                its_file_buffer = mbedtls_calloc(1, its_file_size + sizeof(sli_its_file_meta_v2_t));
   2144                if (its_file_buffer == NULL) {
   2145                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   2146                }
   2147          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2148                psa_status = psa_its_get_legacy(keys_referenced_by_nvm3[i],
   2149                                                &(its_file_meta),
   2150                                                its_file_size,
   2151                                                its_file_offset,
   2152                                                its_file_buffer);
   2153          #else
   2154                psa_status = psa_its_get_legacy(keys_referenced_by_nvm3[i],
   2155                                                NULL,
   2156                                                its_file_size,
   2157                                                its_file_offset,
   2158                                                its_file_buffer);
   2159          #endif
   2160                if (psa_status != PSA_SUCCESS) {
   2161                  psa_status = PSA_ERROR_STORAGE_FAILURE;
   2162                  goto exit;
   2163                }
   2164          
   2165          #if defined (SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   2166                if (its_file_meta.magic == SLI_PSA_ITS_META_MAGIC_V1) {
   2167                  psa_status = psa_its_set_v1(its_file_meta.uid, its_file_data_size,
   2168                                              its_file_buffer, its_file_meta.flags);
   2169                } else if (its_file_meta.magic == SLI_PSA_ITS_META_MAGIC_V2)
   2170          #endif
   2171                {
   2172                  psa_status = psa_its_set(its_file_meta.uid, its_file_data_size,
   2173                                           its_file_buffer, its_file_meta.flags);
   2174                }
   2175          
   2176                if ((psa_status != PSA_SUCCESS) && (psa_status
   2177                                                    != PSA_ERROR_NOT_PERMITTED)) {
   2178                  goto exit;
   2179                }
   2180                status = nvm3_deleteObject(nvm3_defaultHandle,
   2181                                           keys_referenced_by_nvm3[i]);
   2182          
   2183                if ( status != ECODE_NVM3_OK ) {
   2184                  psa_status = PSA_ERROR_STORAGE_FAILURE;
   2185                  goto exit;
   2186                }
   2187                memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   2188                mbedtls_free(its_file_buffer);
   2189              }
   2190            }
   2191            return PSA_SUCCESS;
   2192          
   2193            exit:
   2194            // Clear and free key buffer before return.
   2195            memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   2196            mbedtls_free(its_file_buffer);
   2197            return psa_status;
   2198          }
   2199          
   2200          #if defined (SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   2201          psa_status_t psa_its_set_v1(psa_storage_uid_t uid,
   2202                                      uint32_t data_length,
   2203                                      const void *p_data,
   2204                                      psa_storage_create_flags_t create_flags)
   2205          {
   2206            if ((data_length != 0U) && (p_data == NULL)) {
   2207              return PSA_ERROR_INVALID_ARGUMENT;
   2208            }
   2209          
   2210            if (create_flags != PSA_STORAGE_FLAG_WRITE_ONCE
   2211                && create_flags != PSA_STORAGE_FLAG_NONE
   2212          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2213                && create_flags != PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   2214          #endif
   2215                ) {
   2216              return PSA_ERROR_NOT_SUPPORTED;
   2217            }
   2218          
   2219          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2220            if ((create_flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE)
   2221                && (!object_lives_in_s(p_data, data_length))) {
   2222              // The flag indicates that this data should not be set by the non-secure domain
   2223              return PSA_ERROR_INVALID_ARGUMENT;
   2224            }
   2225          #endif
   2226          
   2227            Ecode_t status;
   2228            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2229            sl_its_file_meta_v1_t* its_file_meta;
   2230            nvm3_ObjectKey_t nvm3_object_id = 0;
   2231            size_t its_file_size = data_length;
   2232          
   2233            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size + sizeof(sl_its_file_meta_v1_t));
   2234            if (its_file_buffer == NULL) {
   2235              return PSA_ERROR_INSUFFICIENT_MEMORY;
   2236            }
   2237            memset(its_file_buffer, 0, its_file_size + sizeof(sl_its_file_meta_v1_t));
   2238          
   2239            its_file_meta = (sl_its_file_meta_v1_t *)its_file_buffer;
   2240            sli_its_file_meta_v2_t its_file_meta_v2;
   2241          
   2242            sli_its_acquire_mutex();
   2243            psa_status = find_nvm3_id(uid, true, &its_file_meta_v2, NULL, NULL,
   2244                                      &nvm3_object_id);
   2245            if (psa_status != PSA_SUCCESS) {
   2246              if (psa_status == PSA_ERROR_DOES_NOT_EXIST) {
   2247                psa_status = PSA_ERROR_INSUFFICIENT_STORAGE;
   2248              }
   2249              goto exit;
   2250            }
   2251          
   2252            its_file_meta->magic = SLI_PSA_ITS_META_MAGIC_V1;
   2253            its_file_meta->uid = uid;
   2254            its_file_meta->flags = create_flags;
   2255          
   2256            if (data_length != 0U) {
   2257              memcpy(its_file_buffer + sizeof(sl_its_file_meta_v1_t), ((uint8_t*)
   2258                                                                       p_data), data_length);
   2259            }
   2260          
   2261            status = nvm3_writeData(nvm3_defaultHandle,
   2262                                    nvm3_object_id,
   2263                                    its_file_buffer, its_file_size + sizeof
   2264                                    (sl_its_file_meta_v1_t));
   2265          
   2266            if (status == ECODE_NVM3_OK) {
   2267              // Power-loss might occur, however upon boot, the look-up table will be
   2268              // re-filled as long as the data has been successfully written to NVM3.
   2269              set_cache(nvm3_object_id);
   2270            } else {
   2271              psa_status = PSA_ERROR_STORAGE_FAILURE;
   2272            }
   2273          
   2274            exit:
   2275            // Clear and free key buffer before return.
   2276            memset(its_file_buffer, 0, its_file_size + sizeof(sl_its_file_meta_v1_t));
   2277            mbedtls_free(its_file_buffer);
   2278            sli_its_release_mutex();
   2279            return psa_status;
   2280          }
   2281          #endif //SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL
   2282          #endif //SL_PSA_ITS_SUPPORT_V1_DRIVER
   2283          
   2284          /**
   2285           * \brief Search through NVM3 for correct uid
   2286           *
   2287           * \param[in] uid               UID under what we want to store the data
   2288           * \param[in] find_empty_slot   Indicates whether we want to find existing data or empty space for storing new.
   2289           * \param[out] its_file_meta    Meta information of ITS file
   2290           * \param[out] its_file_offset  Offset of ITS file
   2291           * \param[out] its_file_size    Size of ITS file
   2292           * \param[out] output_nvm3_id   NVM3 ID corresponding to UID.
   2293           *
   2294           * \return      A status indicating the success/failure of the operation
   2295           *
   2296           * \retval      PSA_SUCCESS                      The operation completed successfully
   2297           * \retval      PSA_ERROR_DOES_NOT_EXIST         The data with this UID are not stored in NVM3
   2298           * \retval      PSA_ERROR_NOT_PERMITTED          The requested operation is not permitted
   2299           */

   \                                 In section .text, align 2, keep-with-next
   2300          static psa_status_t find_nvm3_id(psa_storage_uid_t uid,
   2301                                           bool find_empty_slot,
   2302                                           sli_its_file_meta_v2_t* its_file_meta,
   2303                                           size_t* its_file_offset,
   2304                                           size_t* its_file_size,
   2305                                           nvm3_ObjectKey_t * output_nvm3_id)
   2306          {
   \                     find_nvm3_id: (+1)
   \        0x0   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x469A             MOV      R10,R3
   \        0xA   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   2307            Ecode_t status;
   2308            nvm3_ObjectKey_t tmp_id = 0;
   \        0xE   0x2700             MOVS     R7,#+0
   2309            nvm3_ObjectKey_t nvm3_object_id = 0;
   \       0x10   0xF05F 0x0800      MOVS     R8,#+0
   2310            nvm3_object_id = derive_nvm3_id(uid);
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0x.... 0x....      BL       derive_nvm3_id
   \       0x1C   0x4681             MOV      R9,R0
   2311          
   2312            if (nvm3_uid_set_cache_initialized == false) {
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable16_14
   \       0x22   0x7800             LDRB     R0,[R0, #+0]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD108             BNE.N    ??find_nvm3_id_0
   2313          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY) \
   2314              // With SKL the NVM3 instance must be initialized by the NS app. We therefore check that
   2315              // it has been opened (which is done on init) rather than actually doing the init.
   2316              if (!nvm3_defaultHandle->hasBeenOpened) {
   2317          #else
   2318              if (nvm3_initDefault() != ECODE_NVM3_OK) {
   \       0x28   0x.... 0x....      BL       nvm3_initDefault
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD002             BEQ.N    ??find_nvm3_id_1
   2319          #endif
   2320                return PSA_ERROR_STORAGE_FAILURE;
   \       0x30   0xF07F 0x0091      MVNS     R0,#+145
   \       0x34   0xE076             B.N      ??find_nvm3_id_2
   2321              }
   2322          
   2323          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   2324              if ( its_driver_version == SLI_PSA_ITS_NOT_CHECKED ) {
   2325                if ( detect_legacy_versions() != PSA_SUCCESS ) {
   2326                  return PSA_ERROR_STORAGE_FAILURE;
   2327                }
   2328                if ( its_driver_version == SLI_PSA_ITS_V2_DRIVER ) {
   2329                  psa_status_t psa_status = upgrade_all_keys();
   2330                  if ( psa_status != PSA_SUCCESS ) {
   2331                    return psa_status;
   2332                  }
   2333                  psa_status = write_driver_v3();
   2334                  if ( psa_status != PSA_SUCCESS ) {
   2335                    return psa_status;
   2336                  }
   2337                } else {
   2338                  init_cache();
   2339                }
   2340              } else {
   2341                init_cache();
   2342              }
   2343          #else
   2344              init_cache();
   \                     ??find_nvm3_id_1: (+1)
   \       0x36   0x.... 0x....      BL       init_cache
   2345          #endif
   2346            }
   2347          
   2348            for (size_t i = 0; i < SL_PSA_ITS_MAX_FILES; ++i ) {
   \                     ??find_nvm3_id_0: (+1)
   \       0x3A   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??find_nvm3_id_3: (+1)
   \       0x3E   0xF1B8 0x0F8A      CMP      R8,#+138
   \       0x42   0xD263             BCS.N    ??find_nvm3_id_4
   2349              if (!lookup_cache(nvm3_object_id)) {
   \       0x44   0x4648             MOV      R0,R9
   \       0x46   0x.... 0x....      BL       lookup_cache
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD11D             BNE.N    ??find_nvm3_id_5
   2350                // dont exist
   2351                if (lookup_tomb(nvm3_object_id)) {
   \       0x4E   0x4648             MOV      R0,R9
   \       0x50   0x.... 0x....      BL       lookup_tomb
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD007             BEQ.N    ??find_nvm3_id_6
   2352                  // tombstone
   2353                  if (tmp_id == 0 ) {
   \       0x58   0x2F00             CMP      R7,#+0
   \       0x5A   0xD100             BNE.N    ??find_nvm3_id_7
   2354                    // mark first empty space
   2355                    tmp_id = nvm3_object_id;
   \       0x5C   0x464F             MOV      R7,R9
   2356                  }
   2357                  nvm3_object_id = increment_obj_id(nvm3_object_id);
   \                     ??find_nvm3_id_7: (+1)
   \       0x5E   0x4648             MOV      R0,R9
   \       0x60   0x.... 0x....      BL       increment_obj_id
   \       0x64   0x4681             MOV      R9,R0
   2358                  continue;
   \       0x66   0xE04E             B.N      ??find_nvm3_id_8
   2359                } else {
   2360                  // empty space
   2361                  if (find_empty_slot) {
   \                     ??find_nvm3_id_6: (+1)
   \       0x68   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD009             BEQ.N    ??find_nvm3_id_9
   2362                    if (tmp_id != 0) {
   \       0x70   0x2F00             CMP      R7,#+0
   \       0x72   0xD003             BEQ.N    ??find_nvm3_id_10
   2363                      *output_nvm3_id = tmp_id;
   \       0x74   0xF8CB 0x7000      STR      R7,[R11, #+0]
   2364                      return PSA_SUCCESS;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0xE053             B.N      ??find_nvm3_id_2
   2365                    }
   2366                    *output_nvm3_id = nvm3_object_id;
   \                     ??find_nvm3_id_10: (+1)
   \       0x7C   0xF8CB 0x9000      STR      R9,[R11, #+0]
   2367                    return PSA_SUCCESS;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xE04F             B.N      ??find_nvm3_id_2
   2368                  } else {
   2369                    return PSA_ERROR_DOES_NOT_EXIST;
   \                     ??find_nvm3_id_9: (+1)
   \       0x84   0xF07F 0x008B      MVNS     R0,#+139
   \       0x88   0xE04C             B.N      ??find_nvm3_id_2
   2370                  }
   2371                }
   2372              }
   2373              status = get_file_metadata(nvm3_object_id, its_file_meta, its_file_offset,
   2374                                         its_file_size);
   \                     ??find_nvm3_id_5: (+1)
   \       0x8A   0x9B0B             LDR      R3,[SP, #+44]
   \       0x8C   0x9A0A             LDR      R2,[SP, #+40]
   \       0x8E   0x4651             MOV      R1,R10
   \       0x90   0x4648             MOV      R0,R9
   \       0x92   0x.... 0x....      BL       get_file_metadata
   \       0x96   0x0006             MOVS     R6,R0
   2375          
   2376              if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER
   2377                  || status == ECODE_NVM3_ERR_READ_DATA_SIZE) {
   \       0x98   0x.... 0x....      LDR.W    R0,??DataTable16_16
   \       0x9C   0x4286             CMP      R6,R0
   \       0x9E   0xD003             BEQ.N    ??find_nvm3_id_11
   \       0xA0   0x.... 0x....      LDR.W    R0,??DataTable16_17
   \       0xA4   0x4286             CMP      R6,R0
   \       0xA6   0xD10B             BNE.N    ??find_nvm3_id_12
   2378                // we don't expect any other data in our range then PSA ITS files.
   2379                // delete the file if the magic doesn't match or the object on disk
   2380                // is too small to even have full metadata.
   2381                status = nvm3_deleteObject(nvm3_defaultHandle, nvm3_object_id);
   \                     ??find_nvm3_id_11: (+1)
   \       0xA8   0x4649             MOV      R1,R9
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \       0xAE   0x6800             LDR      R0,[R0, #+0]
   \       0xB0   0x.... 0x....      BL       nvm3_deleteObject
   \       0xB4   0x0006             MOVS     R6,R0
   2382                if (status != ECODE_NVM3_OK) {
   \       0xB6   0x2E00             CMP      R6,#+0
   \       0xB8   0xD002             BEQ.N    ??find_nvm3_id_12
   2383                  return PSA_ERROR_DOES_NOT_EXIST;
   \       0xBA   0xF07F 0x008B      MVNS     R0,#+139
   \       0xBE   0xE031             B.N      ??find_nvm3_id_2
   2384                }
   2385              }
   2386          
   2387              if (status != ECODE_NVM3_OK
   2388                  && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   \                     ??find_nvm3_id_12: (+1)
   \       0xC0   0x2E00             CMP      R6,#+0
   \       0xC2   0xD006             BEQ.N    ??find_nvm3_id_13
   \       0xC4   0x.... 0x....      LDR.W    R0,??DataTable16_18
   \       0xC8   0x4286             CMP      R6,R0
   \       0xCA   0xD002             BEQ.N    ??find_nvm3_id_13
   2389                return PSA_ERROR_STORAGE_FAILURE;
   \       0xCC   0xF07F 0x0091      MVNS     R0,#+145
   \       0xD0   0xE028             B.N      ??find_nvm3_id_2
   2390              }
   2391          
   2392              if (its_file_meta->uid != uid) {
   \                     ??find_nvm3_id_13: (+1)
   \       0xD2   0xE9DA 0x0102      LDRD     R0,R1,[R10, #+8]
   \       0xD6   0x42A9             CMP      R1,R5
   \       0xD8   0xD101             BNE.N    ??find_nvm3_id_14
   \       0xDA   0x42A0             CMP      R0,R4
   \       0xDC   0xD004             BEQ.N    ??find_nvm3_id_15
   2393                nvm3_object_id = increment_obj_id(nvm3_object_id);
   \                     ??find_nvm3_id_14: (+1)
   \       0xDE   0x4648             MOV      R0,R9
   \       0xE0   0x.... 0x....      BL       increment_obj_id
   \       0xE4   0x4681             MOV      R9,R0
   \       0xE6   0xE00E             B.N      ??find_nvm3_id_8
   2394              } else {
   2395                if (find_empty_slot) {
   \                     ??find_nvm3_id_15: (+1)
   \       0xE8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD006             BEQ.N    ??find_nvm3_id_16
   2396                  if (its_file_meta->flags == PSA_STORAGE_FLAG_WRITE_ONCE
   2397          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2398                      || its_file_meta->flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   2399          #endif
   2400                      ) {
   \       0xF0   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0xF4   0x2801             CMP      R0,#+1
   \       0xF6   0xD102             BNE.N    ??find_nvm3_id_16
   2401                    return PSA_ERROR_NOT_PERMITTED;
   \       0xF8   0xF07F 0x0084      MVNS     R0,#+132
   \       0xFC   0xE012             B.N      ??find_nvm3_id_2
   2402                  }
   2403                }
   2404          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2405                // If the UID already exists, authenticate the existing value and make sure the stored UID is the same.
   2406                // Note that this can potentially induce a significant performance hit.
   2407                psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2408                psa_storage_uid_t authenticated_uid = 0;
   2409                psa_status = authenticate_its_file(nvm3_object_id, &authenticated_uid);
   2410                if (psa_status != PSA_SUCCESS) {
   2411                  return psa_status;
   2412                }
   2413          
   2414                if (authenticated_uid != uid) {
   2415                  return PSA_ERROR_INVALID_SIGNATURE;
   2416                }
   2417          #endif
   2418                *output_nvm3_id = nvm3_object_id;
   \                     ??find_nvm3_id_16: (+1)
   \       0xFE   0xF8CB 0x9000      STR      R9,[R11, #+0]
   2419                return PSA_SUCCESS;
   \      0x102   0x2000             MOVS     R0,#+0
   \      0x104   0xE00E             B.N      ??find_nvm3_id_2
   2420              }
   2421            }
   \                     ??find_nvm3_id_8: (+1)
   \      0x106   0xF118 0x0801      ADDS     R8,R8,#+1
   \      0x10A   0xE798             B.N      ??find_nvm3_id_3
   2422            if (find_empty_slot) {
   \                     ??find_nvm3_id_4: (+1)
   \      0x10C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD005             BEQ.N    ??find_nvm3_id_17
   2423              if (tmp_id != 0) {
   \      0x114   0x2F00             CMP      R7,#+0
   \      0x116   0xD003             BEQ.N    ??find_nvm3_id_17
   2424                *output_nvm3_id = tmp_id;
   \      0x118   0xF8CB 0x7000      STR      R7,[R11, #+0]
   2425                return PSA_SUCCESS;
   \      0x11C   0x2000             MOVS     R0,#+0
   \      0x11E   0xE001             B.N      ??find_nvm3_id_2
   2426              }
   2427            }
   2428            return PSA_ERROR_DOES_NOT_EXIST;
   \                     ??find_nvm3_id_17: (+1)
   \      0x120   0xF07F 0x008B      MVNS     R0,#+139
   \                     ??find_nvm3_id_2: (+1)
   \      0x124   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   2429          }
   2430          
   2431          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2432          static inline void cache_session_key(uint8_t *session_key, psa_storage_uid_t uid)
   2433          {
   2434            // Cache the session key
   2435            memcpy(g_cached_session_key.data, session_key, sizeof(g_cached_session_key.data));
   2436            g_cached_session_key.uid = uid;
   2437            g_cached_session_key.active = true;
   2438          }
   2439          
   2440          /**
   2441           * \brief Derive a session key for ITS file encryption from the initialized root key and provided IV.
   2442           *
   2443           * \param[in] iv                Pointer to array containing the initialization vector to be used in the key derivation.
   2444           * \param[in] iv_size           Size of the IV buffer in bytes. Must be 12 bytes (AES-GCM IV size).
   2445           * \param[out] session_key      Pointer to array where derived session key shall be stored.
   2446           * \param[out] session_key_size Size of the derived session key output array. Must be at least 32 bytes (AES-256 key size).
   2447           *
   2448           * \return      A status indicating the success/failure of the operation
   2449           *
   2450           * \retval      PSA_SUCCESS                      The operation completed successfully
   2451           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
   2452           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because iv or session_key is NULL, or their sizes are incorrect.
   2453           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2454           */
   2455          static psa_status_t derive_session_key(uint8_t *iv, size_t iv_size, uint8_t *session_key, size_t session_key_size)
   2456          {
   2457            if (iv == NULL
   2458                || iv_size != AES_GCM_IV_SIZE
   2459                || session_key == NULL
   2460                || session_key_size < SESSION_KEY_SIZE) {
   2461              return PSA_ERROR_INVALID_ARGUMENT;
   2462            }
   2463          
   2464            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   2465            psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   2466          
   2467          #if defined(SEMAILBOX_PRESENT)
   2468            // For HSE devices, use the builtin TrustZone Root Key
   2469            psa_set_key_id(&attributes, SL_SE_BUILTIN_KEY_TRUSTZONE_ID);
   2470          
   2471            psa_key_lifetime_t reported_lifetime;
   2472            psa_drv_slot_number_t reported_slot;
   2473            status = mbedtls_psa_platform_get_builtin_key(psa_get_key_id(&attributes),
   2474                                                          &reported_lifetime,
   2475                                                          &reported_slot);
   2476          
   2477            if (status != PSA_SUCCESS) {
   2478              return status;
   2479            }
   2480          
   2481            psa_set_key_lifetime(&attributes, reported_lifetime);
   2482          
   2483            uint8_t key_buffer[sizeof(sli_se_opaque_key_context_header_t)];
   2484            size_t key_buffer_size;
   2485            status = sli_se_opaque_get_builtin_key(reported_slot,
   2486                                                   &attributes,
   2487                                                   key_buffer,
   2488                                                   sizeof(key_buffer),
   2489                                                   &key_buffer_size);
   2490            if (status != PSA_SUCCESS) {
   2491              return status;
   2492            }
   2493          #else // defined(SEMAILBOX_PRESENT)
   2494            // For VSE devices, use the previously initialized root key
   2495            if (!g_root_key.initialized) {
   2496              return PSA_ERROR_BAD_STATE;
   2497            }
   2498          
   2499            // Prepare root key attributes
   2500            psa_set_key_algorithm(&attributes, PSA_ALG_CMAC);
   2501            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
   2502            psa_set_key_bits(&attributes, ROOT_KEY_SIZE * 8);
   2503          
   2504            // Point the key buffer to the global root key
   2505            uint8_t *key_buffer = (uint8_t*)g_root_key.data;
   2506            size_t key_buffer_size = sizeof(g_root_key.data);
   2507          #endif // defined(SEMAILBOX_PRESENT)
   2508          
   2509            // Use CMAC as a key derivation function
   2510            size_t session_key_length;
   2511            status = psa_driver_wrapper_mac_compute(
   2512              &attributes,
   2513              key_buffer,
   2514              key_buffer_size,
   2515              PSA_ALG_CMAC,
   2516              iv,
   2517              iv_size,
   2518              session_key,
   2519              session_key_size,
   2520              &session_key_length);
   2521          
   2522            // Verify that the key derivation was successful before transferring the key to the caller
   2523            if (status != PSA_SUCCESS || session_key_length != SESSION_KEY_SIZE) {
   2524              memset(session_key, 0, session_key_size);
   2525              return PSA_ERROR_HARDWARE_FAILURE;
   2526            }
   2527          
   2528            return status;
   2529          }
   2530          
   2531          /**
   2532           * \brief Encrypt and authenticate ITS data with AES-128-GCM, storing the result in an encrypted blob.
   2533           *
   2534           * \param[in] metadata        ITS metadata to be used as authenticated additional data.
   2535           * \param[in] plaintext       Pointer to array containing data to be encrypted.
   2536           * \param[in] plaintext_size  Size of provided plaintext data array.
   2537           * \param[out] blob           Pointer to array where the resulting encrypted blob shall be placed.
   2538           * \param[in] blob_size       Size of the output array. Must be at least as big as plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
   2539           * \param[out] blob_length    Resulting size of the output blob.
   2540           *
   2541           * \return      A status indicating the success/failure of the operation
   2542           *
   2543           * \retval      PSA_SUCCESS                      The operation completed successfully
   2544           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
   2545           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
   2546           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2547           */
   2548          psa_status_t sli_encrypt_its_file(sli_its_file_meta_v2_t *metadata,
   2549                                            uint8_t *plaintext,
   2550                                            size_t plaintext_size,
   2551                                            sli_its_encrypted_blob_t *blob,
   2552                                            size_t blob_size,
   2553                                            size_t *blob_length)
   2554          {
   2555            if (metadata == NULL
   2556                || (plaintext == NULL && plaintext_size > 0)
   2557                || blob == NULL
   2558                || blob_size < plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
   2559                || blob_length == NULL) {
   2560              return PSA_ERROR_INVALID_ARGUMENT;
   2561            }
   2562          
   2563            // Generate IV
   2564            size_t iv_length = 0;
   2565            psa_status_t psa_status = mbedtls_psa_external_get_random(NULL, blob->iv, AES_GCM_IV_SIZE, &iv_length);
   2566          
   2567            if (psa_status != PSA_SUCCESS || iv_length != AES_GCM_IV_SIZE) {
   2568              return PSA_ERROR_HARDWARE_FAILURE;
   2569            }
   2570          
   2571            // Prepare encryption key
   2572            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   2573            psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
   2574            psa_set_key_algorithm(&attributes, PSA_ALG_GCM);
   2575            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
   2576            psa_set_key_bits(&attributes, SESSION_KEY_SIZE * 8);
   2577          
   2578            uint8_t session_key[SESSION_KEY_SIZE];
   2579            psa_status = derive_session_key(blob->iv, AES_GCM_IV_SIZE, session_key, sizeof(session_key));
   2580            if (psa_status != PSA_SUCCESS) {
   2581              return psa_status;
   2582            }
   2583          
   2584            cache_session_key(session_key, metadata->uid);
   2585          
   2586            // Retrieve data to be encrypted
   2587            if (plaintext_size != 0U) {
   2588              memcpy(blob->data, ((uint8_t*)plaintext), plaintext_size);
   2589            }
   2590          
   2591            // Encrypt and authenticate blob
   2592            size_t output_length = 0;
   2593            psa_status = psa_driver_wrapper_aead_encrypt(
   2594              &attributes,
   2595              session_key, sizeof(session_key),
   2596              PSA_ALG_GCM,
   2597              blob->iv, sizeof(blob->iv),
   2598              (uint8_t*)metadata, sizeof(sli_its_file_meta_v2_t),    // metadata is AAD
   2599              blob->data, plaintext_size,
   2600              blob->data, plaintext_size + AES_GCM_MAC_SIZE,    // output == input for in-place encryption
   2601              &output_length);
   2602          
   2603            // Clear the local session key immediately after we're done using it
   2604            memset(session_key, 0, sizeof(session_key));
   2605          
   2606            if (psa_status != PSA_SUCCESS) {
   2607              return PSA_ERROR_HARDWARE_FAILURE;
   2608            }
   2609          
   2610            if (output_length != plaintext_size + AES_GCM_MAC_SIZE) {
   2611              return PSA_ERROR_HARDWARE_FAILURE;
   2612            }
   2613          
   2614            *blob_length = output_length + AES_GCM_IV_SIZE;
   2615          
   2616            return PSA_SUCCESS;
   2617          }
   2618          
   2619          /**
   2620           * \brief Decrypt and authenticate encrypted ITS data.
   2621           *
   2622           * \param[in] metadata          ITS metadata to be used as authenticated additional data. Must be identical to the metadata used during encryption.
   2623           * \param[in] blob              Encrypted blob containing data to be decrypted.
   2624           * \param[in] blob_size         Size of the encrypted blob in bytes.
   2625           * \param[out] plaintext        Pointer to array where the decrypted plaintext shall be placed.
   2626           * \param[in] plaintext_size    Size of the plaintext array. Must be equal to sizeof(blob->data) - AES_GCM_MAC_SIZE.
   2627           * \param[out] plaintext_length Resulting length of the decrypted plaintext.
   2628           *
   2629           * \return      A status indicating the success/failure of the operation
   2630           *
   2631           * \retval      PSA_SUCCESS                      The operation completed successfully
   2632           * \retval      PSA_ERROR_INVALID_SIGANTURE      The operation failed because authentication of the decrypted data failed.
   2633           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
   2634           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
   2635           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2636           */
   2637          static psa_status_t sli_decrypt_its_file(sli_its_file_meta_v2_t *metadata,
   2638                                                   sli_its_encrypted_blob_t *blob,
   2639                                                   size_t blob_size,
   2640                                                   uint8_t *plaintext,
   2641                                                   size_t plaintext_size,
   2642                                                   size_t *plaintext_length)
   2643          {
   2644            if (metadata == NULL
   2645                || blob == NULL
   2646                || blob_size < plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
   2647                || (plaintext == NULL && plaintext_size > 0)
   2648                || plaintext_length == NULL) {
   2649              return PSA_ERROR_INVALID_ARGUMENT;
   2650            }
   2651          
   2652            // Prepare decryption key
   2653            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   2654            psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
   2655            psa_set_key_algorithm(&attributes, PSA_ALG_GCM);
   2656            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
   2657            psa_set_key_bits(&attributes, SESSION_KEY_SIZE * 8);
   2658          
   2659            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2660            uint8_t session_key[SESSION_KEY_SIZE];
   2661          
   2662            if (g_cached_session_key.active && g_cached_session_key.uid == metadata->uid) {
   2663              // Use cached session key if it's already set and UID matches
   2664              memcpy(session_key, g_cached_session_key.data, sizeof(session_key));
   2665            } else {
   2666              psa_status = derive_session_key(blob->iv, AES_GCM_IV_SIZE, session_key, sizeof(session_key));
   2667              if (psa_status != PSA_SUCCESS) {
   2668                return psa_status;
   2669              }
   2670              cache_session_key(session_key, metadata->uid);
   2671            }
   2672          
   2673            // Decrypt and authenticate blob
   2674            size_t output_length = 0;
   2675            psa_status = psa_driver_wrapper_aead_decrypt(
   2676              &attributes,
   2677              session_key, sizeof(session_key),
   2678              PSA_ALG_GCM,
   2679              blob->iv, sizeof(blob->iv),
   2680              (uint8_t*)metadata, sizeof(sli_its_file_meta_v2_t),    // metadata is AAD
   2681              blob->data, plaintext_size + AES_GCM_MAC_SIZE,
   2682              plaintext, plaintext_size,
   2683              &output_length);
   2684          
   2685            // Clear the session key immediately after we're done using it
   2686            memset(session_key, 0, sizeof(session_key));
   2687          
   2688            // Invalid signature likely means that NVM data was tampered with
   2689            if (psa_status == PSA_ERROR_INVALID_SIGNATURE) {
   2690              return PSA_ERROR_INVALID_SIGNATURE;
   2691            }
   2692          
   2693            if (psa_status != PSA_SUCCESS
   2694                || output_length != plaintext_size) {
   2695              return PSA_ERROR_HARDWARE_FAILURE;
   2696            }
   2697          
   2698            *plaintext_length = output_length;
   2699          
   2700            return PSA_SUCCESS;
   2701          }
   2702          
   2703          /**
   2704           * \brief Authenticate encrypted ITS data and return the UID of the ITS file that was authenticated.
   2705           *
   2706           * \details NOTE: This function will run sli_decrypt_its_file() internally. The difference from the sli_decrypt_its_file()
   2707           *          function is that authenticate_its_file() reads the NVM3 data, decrypts it in order to authenticate the
   2708           *          stored data, and then discards the plaintext. This is needed since PSA Crypto doesn't support the
   2709           *          GMAC primitive directly, which means we have to run a full GCM decrypt for authentication.
   2710           *
   2711           * \param[in] nvm3_object_id      The NVM3 id corresponding to the stored ITS file.
   2712           * \param[out] authenticated_uid  UID for the authenticated ITS file.
   2713           *
   2714           * \return      A status indicating the success/failure of the operation
   2715           *
   2716           * \retval      PSA_SUCCESS                      The operation completed successfully
   2717           * \retval      PSA_ERROR_INVALID_SIGANTURE      The operation failed because authentication of the decrypted data failed.
   2718           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
   2719           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
   2720           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2721           */
   2722          static psa_status_t authenticate_its_file(nvm3_ObjectKey_t nvm3_object_id,
   2723                                                    psa_storage_uid_t *authenticated_uid)
   2724          {
   2725            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2726            sli_its_file_meta_v2_t *its_file_meta = NULL;
   2727            sli_its_encrypted_blob_t *blob = NULL;
   2728          
   2729            uint32_t obj_type;
   2730            size_t its_file_size = 0;
   2731            Ecode_t status = nvm3_getObjectInfo(nvm3_defaultHandle,
   2732                                                nvm3_object_id,
   2733                                                &obj_type,
   2734                                                &its_file_size);
   2735            if (status != ECODE_NVM3_OK) {
   2736              return PSA_ERROR_STORAGE_FAILURE;
   2737            }
   2738          
   2739            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size);
   2740            if (its_file_buffer == NULL) {
   2741              return PSA_ERROR_INSUFFICIENT_MEMORY;
   2742            }
   2743            memset(its_file_buffer, 0, its_file_size);
   2744          
   2745            status = nvm3_readData(nvm3_defaultHandle,
   2746                                   nvm3_object_id,
   2747                                   its_file_buffer,
   2748                                   its_file_size);
   2749            if (status != ECODE_NVM3_OK) {
   2750              psa_status = PSA_ERROR_STORAGE_FAILURE;
   2751              goto cleanup;
   2752            }
   2753          
   2754            its_file_meta = (sli_its_file_meta_v2_t*)its_file_buffer;
   2755            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
   2756          
   2757            // Decrypt and authenticate blob
   2758            size_t plaintext_length;
   2759            psa_status = sli_decrypt_its_file(its_file_meta,
   2760                                              blob,
   2761                                              its_file_size - sizeof(sli_its_file_meta_v2_t),
   2762                                              blob->data,
   2763                                              its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   2764                                              &plaintext_length);
   2765          
   2766            if (psa_status != PSA_SUCCESS) {
   2767              goto cleanup;
   2768            }
   2769          
   2770            if (plaintext_length != (its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   2771              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   2772              goto cleanup;
   2773            }
   2774          
   2775            if (authenticated_uid != NULL) {
   2776              *authenticated_uid = its_file_meta->uid;
   2777            }
   2778          
   2779            psa_status = PSA_SUCCESS;
   2780          
   2781            cleanup:
   2782          
   2783            // Discard output, as we're only interested in whether the authentication check passed or not.
   2784            memset(its_file_buffer, 0, its_file_size);
   2785            mbedtls_free(its_file_buffer);
   2786          
   2787            return psa_status;
   2788          }
   2789          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
   2790          
   2791          // -------------------------------------
   2792          // Global function definitions
   2793          
   2794          /**
   2795           * \brief create a new or modify an existing uid/value pair
   2796           *
   2797           * \param[in] uid           the identifier for the data
   2798           * \param[in] data_length   The size in bytes of the data in `p_data`
   2799           * \param[in] p_data        A buffer containing the data
   2800           * \param[in] create_flags  The flags that the data will be stored with
   2801           *
   2802           * \return      A status indicating the success/failure of the operation
   2803           *
   2804           * \retval      PSA_SUCCESS                      The operation completed successfully
   2805           * \retval      PSA_ERROR_NOT_PERMITTED          The operation failed because the provided `uid` value was already created with PSA_STORAGE_FLAG_WRITE_ONCE
   2806           * \retval      PSA_ERROR_NOT_SUPPORTED          The operation failed because one or more of the flags provided in `create_flags` is not supported or is not valid
   2807           * \retval      PSA_ERROR_INSUFFICIENT_STORAGE   The operation failed because there was insufficient space on the storage medium
   2808           * \retval      PSA_ERROR_STORAGE_FAILURE        The operation failed because the physical storage has failed (Fatal error)
   2809           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one of the provided pointers(`p_data`)
   2810           *                                               is invalid, for example is `NULL` or references memory the caller cannot access
   2811           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2812           * \retval      PSA_ERROR_INVALID_SIGNATURE      The operation failed because the provided `uid` doesnt match the autenticated uid from the storage
   2813           */

   \                                 In section .text, align 2, keep-with-next
   2814          psa_status_t psa_its_set(psa_storage_uid_t uid,
   2815                                   uint32_t data_length,
   2816                                   const void *p_data,
   2817                                   psa_storage_create_flags_t create_flags)
   2818          {
   \                     psa_its_set: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x9F12             LDR      R7,[SP, #+72]
   2819            if ((data_length != 0U) && (p_data == NULL)) {
   \        0xE   0x2E00             CMP      R6,#+0
   \       0x10   0xD005             BEQ.N    ??psa_its_set_0
   \       0x12   0x9808             LDR      R0,[SP, #+32]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD102             BNE.N    ??psa_its_set_0
   2820              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x18   0xF07F 0x0086      MVNS     R0,#+134
   \       0x1C   0xE07C             B.N      ??psa_its_set_1
   2821            }
   2822            if ((data_length > NVM3_MAX_OBJECT_SIZE)) {
   \                     ??psa_its_set_0: (+1)
   \       0x1E   0xF240 0x706D      MOVW     R0,#+1901
   \       0x22   0x4286             CMP      R6,R0
   \       0x24   0xD302             BCC.N    ??psa_its_set_2
   2823              return PSA_ERROR_STORAGE_FAILURE;
   \       0x26   0xF07F 0x0091      MVNS     R0,#+145
   \       0x2A   0xE075             B.N      ??psa_its_set_1
   2824            }
   2825          
   2826            if (create_flags != PSA_STORAGE_FLAG_WRITE_ONCE
   2827                && create_flags != PSA_STORAGE_FLAG_NONE
   2828          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2829                && create_flags != PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   2830          #endif
   2831                ) {
   \                     ??psa_its_set_2: (+1)
   \       0x2C   0x2F01             CMP      R7,#+1
   \       0x2E   0xD004             BEQ.N    ??psa_its_set_3
   \       0x30   0x2F00             CMP      R7,#+0
   \       0x32   0xD002             BEQ.N    ??psa_its_set_3
   2832              return PSA_ERROR_NOT_SUPPORTED;
   \       0x34   0xF07F 0x0085      MVNS     R0,#+133
   \       0x38   0xE06E             B.N      ??psa_its_set_1
   2833            }
   2834          
   2835          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2836            if ((create_flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE)
   2837                && (!object_lives_in_s(p_data, data_length))) {
   2838              // The flag indicates that this data should not be set by the non-secure domain
   2839              return PSA_ERROR_INVALID_ARGUMENT;
   2840            }
   2841          #endif
   2842          
   2843            Ecode_t status;
   2844            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??psa_its_set_3: (+1)
   \       0x3A   0xF07F 0x0A96      MVNS     R10,#+150
   2845            sli_its_file_meta_v2_t* its_file_meta;
   2846            nvm3_ObjectKey_t nvm3_object_id = 0;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x9004             STR      R0,[SP, #+16]
   2847          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2848            sli_its_encrypted_blob_t *blob = NULL;
   2849            size_t its_file_size = data_length + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   2850            size_t blob_length = 0u;
   2851          #else
   2852            size_t its_file_size = data_length;
   \       0x42   0x9603             STR      R6,[SP, #+12]
   2853          #endif
   2854          
   2855            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size + sizeof(sli_its_file_meta_v2_t));
   \       0x44   0x9903             LDR      R1,[SP, #+12]
   \       0x46   0x3110             ADDS     R1,R1,#+16
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0x.... 0x....      BL       sl_calloc
   \       0x4E   0x4680             MOV      R8,R0
   2856            if (its_file_buffer == NULL) {
   \       0x50   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x54   0xD102             BNE.N    ??psa_its_set_4
   2857              return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x56   0xF07F 0x008C      MVNS     R0,#+140
   \       0x5A   0xE05D             B.N      ??psa_its_set_1
   2858            }
   2859            memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   \                     ??psa_its_set_4: (+1)
   \       0x5C   0x9803             LDR      R0,[SP, #+12]
   \       0x5E   0x3010             ADDS     R0,R0,#+16
   \       0x60   0x9007             STR      R0,[SP, #+28]
   \       0x62   0xF05F 0x0900      MOVS     R9,#+0
   \       0x66   0x46C3             MOV      R11,R8
   \       0x68   0x464A             MOV      R2,R9
   \       0x6A   0x9907             LDR      R1,[SP, #+28]
   \       0x6C   0x4658             MOV      R0,R11
   \       0x6E   0x.... 0x....      BL       __aeabi_memset
   2860          
   2861            its_file_meta = (sli_its_file_meta_v2_t *)its_file_buffer;
   \       0x72   0xF8CD 0x8014      STR      R8,[SP, #+20]
   2862          
   2863            sli_its_acquire_mutex();
   \       0x76   0x.... 0x....      BL       sli_its_acquire_mutex
   2864            psa_status = find_nvm3_id(uid, true, its_file_meta, NULL, NULL, &nvm3_object_id);
   \       0x7A   0xA804             ADD      R0,SP,#+16
   \       0x7C   0x9002             STR      R0,[SP, #+8]
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x9001             STR      R0,[SP, #+4]
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x9B05             LDR      R3,[SP, #+20]
   \       0x88   0x2201             MOVS     R2,#+1
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x0029             MOVS     R1,R5
   \       0x8E   0x.... 0x....      BL       find_nvm3_id
   \       0x92   0x4683             MOV      R11,R0
   2865            if (psa_status != PSA_SUCCESS) {
   \       0x94   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x98   0xD006             BEQ.N    ??psa_its_set_5
   2866              if (psa_status == PSA_ERROR_DOES_NOT_EXIST) {
   \       0x9A   0xF11B 0x0F8C      CMN      R11,#+140
   \       0x9E   0xD102             BNE.N    ??psa_its_set_6
   2867                psa_status = PSA_ERROR_INSUFFICIENT_STORAGE;
   \       0xA0   0xF07F 0x008D      MVNS     R0,#+141
   \       0xA4   0x4683             MOV      R11,R0
   2868              }
   2869              goto exit;
   \                     ??psa_its_set_6: (+1)
   \       0xA6   0xE026             B.N      ??psa_its_set_7
   2870            }
   2871          
   2872            its_file_meta->magic = SLI_PSA_ITS_META_MAGIC_V2;
   \                     ??psa_its_set_5: (+1)
   \       0xA8   0x....             LDR.N    R0,??DataTable16_15
   \       0xAA   0x9905             LDR      R1,[SP, #+20]
   \       0xAC   0x6008             STR      R0,[R1, #+0]
   2873            its_file_meta->uid = uid;
   \       0xAE   0x9805             LDR      R0,[SP, #+20]
   \       0xB0   0xE9C0 0x4502      STRD     R4,R5,[R0, #+8]
   2874            its_file_meta->flags = create_flags;
   \       0xB4   0x9805             LDR      R0,[SP, #+20]
   \       0xB6   0x6047             STR      R7,[R0, #+4]
   2875          
   2876          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2877            // Everything after the the file metadata will make up the encrypted & authenticated blob
   2878            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
   2879          
   2880            // Encrypt and authenticate the provided data
   2881            psa_status = sli_encrypt_its_file(its_file_meta,
   2882                                              (uint8_t*)p_data,
   2883                                              data_length,
   2884                                              blob,
   2885                                              its_file_size,
   2886                                              &blob_length);
   2887          
   2888            if (psa_status != PSA_SUCCESS) {
   2889              goto exit;
   2890            }
   2891          
   2892            if (blob_length != its_file_size) {
   2893              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   2894              goto exit;
   2895            }
   2896          
   2897          #else
   2898            if (data_length != 0U) {
   \       0xB8   0x2E00             CMP      R6,#+0
   \       0xBA   0xD009             BEQ.N    ??psa_its_set_8
   2899              memcpy(its_file_buffer + sizeof(sli_its_file_meta_v2_t), ((uint8_t*)p_data), data_length);
   \       0xBC   0x9601             STR      R6,[SP, #+4]
   \       0xBE   0x9808             LDR      R0,[SP, #+32]
   \       0xC0   0x9000             STR      R0,[SP, #+0]
   \       0xC2   0xF118 0x0910      ADDS     R9,R8,#+16
   \       0xC6   0x9A01             LDR      R2,[SP, #+4]
   \       0xC8   0x9900             LDR      R1,[SP, #+0]
   \       0xCA   0x4648             MOV      R0,R9
   \       0xCC   0x.... 0x....      BL       __aeabi_memcpy
   2900            }
   2901          #endif
   2902          
   2903            status = nvm3_writeData(nvm3_defaultHandle,
   2904                                    nvm3_object_id,
   2905                                    its_file_buffer, its_file_size + sizeof(sli_its_file_meta_v2_t));
   \                     ??psa_its_set_8: (+1)
   \       0xD0   0x9B03             LDR      R3,[SP, #+12]
   \       0xD2   0x3310             ADDS     R3,R3,#+16
   \       0xD4   0x4642             MOV      R2,R8
   \       0xD6   0x9904             LDR      R1,[SP, #+16]
   \       0xD8   0x....             LDR.N    R0,??DataTable16_13
   \       0xDA   0x6800             LDR      R0,[R0, #+0]
   \       0xDC   0x.... 0x....      BL       nvm3_writeData
   \       0xE0   0x9006             STR      R0,[SP, #+24]
   2906          
   2907            if (status == ECODE_NVM3_OK) {
   \       0xE2   0x9806             LDR      R0,[SP, #+24]
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD103             BNE.N    ??psa_its_set_9
   2908              // Power-loss might occur, however upon boot, the look-up table will be
   2909              // re-filled as long as the data has been successfully written to NVM3.
   2910              set_cache(nvm3_object_id);
   \       0xE8   0x9804             LDR      R0,[SP, #+16]
   \       0xEA   0x.... 0x....      BL       set_cache
   \       0xEE   0xE002             B.N      ??psa_its_set_7
   2911            } else {
   2912              psa_status = PSA_ERROR_STORAGE_FAILURE;
   \                     ??psa_its_set_9: (+1)
   \       0xF0   0xF07F 0x0091      MVNS     R0,#+145
   \       0xF4   0x4683             MOV      R11,R0
   2913            }
   2914          
   2915            exit:
   2916            // Clear and free key buffer before return.
   2917            memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   \                     ??psa_its_set_7: (+1)
   \       0xF6   0x9803             LDR      R0,[SP, #+12]
   \       0xF8   0x3010             ADDS     R0,R0,#+16
   \       0xFA   0x9000             STR      R0,[SP, #+0]
   \       0xFC   0xF05F 0x0A00      MOVS     R10,#+0
   \      0x100   0x46C1             MOV      R9,R8
   \      0x102   0x4652             MOV      R2,R10
   \      0x104   0x9900             LDR      R1,[SP, #+0]
   \      0x106   0x4648             MOV      R0,R9
   \      0x108   0x.... 0x....      BL       __aeabi_memset
   2918            mbedtls_free(its_file_buffer);
   \      0x10C   0x4640             MOV      R0,R8
   \      0x10E   0x.... 0x....      BL       sl_free
   2919            sli_its_release_mutex();
   \      0x112   0x.... 0x....      BL       sli_its_release_mutex
   2920            return psa_status;
   \      0x116   0x4658             MOV      R0,R11
   \                     ??psa_its_set_1: (+1)
   \      0x118   0xB009             ADD      SP,SP,#+36
   \      0x11A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2921          }
   2922          
   2923          /**
   2924           * \brief Retrieve the value associated with a provided uid
   2925           *
   2926           * \param[in] uid               The uid value
   2927           * \param[in] data_offset       The starting offset of the data requested
   2928           * \param[in] data_length       the amount of data requested (and the minimum allocated size of the `p_data` buffer)
   2929           * \param[out] p_data           The buffer where the data will be placed upon successful completion
   2930           * \param[out] p_data_length    The amount of data returned in the p_data buffer
   2931           *
   2932           *
   2933           * \return      A status indicating the success/failure of the operation
   2934           *
   2935           * \retval      PSA_SUCCESS                  The operation completed successfully
   2936           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided `uid` value was not found in the storage
   2937           * \retval      PSA_ERROR_BUFFER_TOO_SMALL   The operation failed because the data associated with provided uid is larger than `data_size`
   2938           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   2939           * \retval      PSA_ERROR_INVALID_ARGUMENT   The operation failed because one of the provided pointers(`p_data`, `p_data_length`)
   2940           *                                           is invalid. For example is `NULL` or references memory the caller cannot access.
   2941           *                                           In addition, this can also happen if an invalid offset was provided.
   2942           */

   \                                 In section .text, align 2, keep-with-next
   2943          psa_status_t psa_its_get(psa_storage_uid_t uid,
   2944                                   uint32_t data_offset,
   2945                                   uint32_t data_length,
   2946                                   void *p_data,
   2947                                   size_t *p_data_length)
   2948          {
   \                     psa_its_get: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x468B             MOV      R11,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x001C             MOVS     R4,R3
   \        0xE   0x9E16             LDR      R6,[SP, #+88]
   \       0x10   0x9F17             LDR      R7,[SP, #+92]
   2949            if ((data_length != 0U) && (p_data_length == NULL)) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD004             BEQ.N    ??psa_its_get_0
   \       0x16   0x2F00             CMP      R7,#+0
   \       0x18   0xD102             BNE.N    ??psa_its_get_0
   2950              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x1A   0xF07F 0x0086      MVNS     R0,#+134
   \       0x1E   0xE069             B.N      ??psa_its_get_1
   2951            }
   2952          
   2953            if (data_length != 0U) {
   \                     ??psa_its_get_0: (+1)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD00B             BEQ.N    ??psa_its_get_2
   2954              // If the request amount of data is 0, allow invalid pointer of the output buffer.
   2955              if ((p_data == NULL)
   2956                  || ((uint32_t)p_data < SRAM_BASE)
   2957                  || ((uint32_t)p_data > (SRAM_BASE + SRAM_SIZE - data_length))) {
   \       0x24   0x2E00             CMP      R6,#+0
   \       0x26   0xD006             BEQ.N    ??psa_its_get_3
   \       0x28   0xF1B6 0x5F00      CMP      R6,#+536870912
   \       0x2C   0xD303             BCC.N    ??psa_its_get_3
   \       0x2E   0x....             LDR.N    R0,??DataTable16_19
   \       0x30   0x1B00             SUBS     R0,R0,R4
   \       0x32   0x42B0             CMP      R0,R6
   \       0x34   0xD202             BCS.N    ??psa_its_get_2
   2958                return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_its_get_3: (+1)
   \       0x36   0xF07F 0x0086      MVNS     R0,#+134
   \       0x3A   0xE05B             B.N      ??psa_its_get_1
   2959              }
   2960            }
   2961          
   2962          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2963            size_t plaintext_length;
   2964            sli_its_encrypted_blob_t *blob = NULL;
   2965          #endif
   2966            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??psa_its_get_2: (+1)
   \       0x3C   0xF07F 0x0096      MVNS     R0,#+150
   \       0x40   0x9007             STR      R0,[SP, #+28]
   \       0x42   0x2110             MOVS     R1,#+16
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0xAD08             ADD      R5,SP,#+32
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0x.... 0x....      BL       __aeabi_memset
   2967            Ecode_t status;
   2968            sli_its_file_meta_v2_t its_file_meta = { 0 };
   2969            size_t its_file_size = 0u;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x9004             STR      R0,[SP, #+16]
   2970            size_t its_file_data_size = 0u;
   \       0x52   0x2500             MOVS     R5,#+0
   2971            size_t its_file_offset = 0u;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x9003             STR      R0,[SP, #+12]
   2972            nvm3_ObjectKey_t nvm3_object_id;
   2973          
   2974            sli_its_acquire_mutex();
   \       0x58   0x.... 0x....      BL       sli_its_acquire_mutex
   2975            psa_status = find_nvm3_id(uid, false, &its_file_meta, &its_file_offset, &its_file_size, &nvm3_object_id);
   \       0x5C   0xA805             ADD      R0,SP,#+20
   \       0x5E   0x9002             STR      R0,[SP, #+8]
   \       0x60   0xA804             ADD      R0,SP,#+16
   \       0x62   0x9001             STR      R0,[SP, #+4]
   \       0x64   0xA803             ADD      R0,SP,#+12
   \       0x66   0x9000             STR      R0,[SP, #+0]
   \       0x68   0xAB08             ADD      R3,SP,#+32
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x4650             MOV      R0,R10
   \       0x6E   0x4659             MOV      R1,R11
   \       0x70   0x.... 0x....      BL       find_nvm3_id
   \       0x74   0x4681             MOV      R9,R0
   2976            if (psa_status != PSA_SUCCESS) {
   \       0x76   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x7A   0xD138             BNE.N    ??psa_its_get_4
   2977              goto exit;
   2978            }
   2979          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2980            if (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   2981                && !object_lives_in_s(p_data, data_length)) {
   2982              // The flag indicates that this data should not be read back to the non-secure domain
   2983              psa_status = PSA_ERROR_INVALID_ARGUMENT;
   2984              goto exit;
   2985            }
   2986          #endif
   2987          
   2988          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2989            // Subtract IV and MAC from ITS file as the below checks concern the actual data size
   2990            its_file_data_size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   2991          #else
   2992            its_file_data_size = its_file_size;
   \                     ??psa_its_get_5: (+1)
   \       0x7C   0x9804             LDR      R0,[SP, #+16]
   \       0x7E   0x0005             MOVS     R5,R0
   2993          #endif
   2994          
   2995            if (data_length != 0U) {
   \       0x80   0x2C00             CMP      R4,#+0
   \       0x82   0xD010             BEQ.N    ??psa_its_get_6
   2996              if ((data_offset >= its_file_data_size) && (its_file_data_size != 0U)) {
   \       0x84   0x45A8             CMP      R8,R5
   \       0x86   0xD305             BCC.N    ??psa_its_get_7
   \       0x88   0x2D00             CMP      R5,#+0
   \       0x8A   0xD003             BEQ.N    ??psa_its_get_7
   2997                psa_status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x8C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x90   0x4681             MOV      R9,R0
   2998                goto exit;
   \       0x92   0xE02C             B.N      ??psa_its_get_4
   2999              }
   3000          
   3001              if ((its_file_data_size == 0U) && (data_offset != 0U)) {
   \                     ??psa_its_get_7: (+1)
   \       0x94   0x2D00             CMP      R5,#+0
   \       0x96   0xD10C             BNE.N    ??psa_its_get_8
   \       0x98   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x9C   0xD009             BEQ.N    ??psa_its_get_8
   3002                psa_status = PSA_ERROR_INVALID_ARGUMENT;
   \       0x9E   0xF07F 0x0086      MVNS     R0,#+134
   \       0xA2   0x4681             MOV      R9,R0
   3003                goto exit;
   \       0xA4   0xE023             B.N      ??psa_its_get_4
   3004              }
   3005            } else {
   3006              // Allow the offset at the data size boundary if the requested amount of data is zero.
   3007              if (data_offset > its_file_data_size) {
   \                     ??psa_its_get_6: (+1)
   \       0xA6   0x4545             CMP      R5,R8
   \       0xA8   0xD203             BCS.N    ??psa_its_get_8
   3008                psa_status = PSA_ERROR_INVALID_ARGUMENT;
   \       0xAA   0xF07F 0x0086      MVNS     R0,#+134
   \       0xAE   0x4681             MOV      R9,R0
   3009                goto exit;
   \       0xB0   0xE01D             B.N      ??psa_its_get_4
   3010              }
   3011            }
   3012          
   3013            if (data_length > (its_file_data_size - data_offset)) {
   \                     ??psa_its_get_8: (+1)
   \       0xB2   0xEBB5 0x0008      SUBS     R0,R5,R8
   \       0xB6   0x42A0             CMP      R0,R4
   \       0xB8   0xD203             BCS.N    ??psa_its_get_9
   3014              *p_data_length = its_file_data_size - data_offset;
   \       0xBA   0xEBB5 0x0008      SUBS     R0,R5,R8
   \       0xBE   0x6038             STR      R0,[R7, #+0]
   \       0xC0   0xE000             B.N      ??psa_its_get_10
   3015            } else {
   3016              *p_data_length = data_length;
   \                     ??psa_its_get_9: (+1)
   \       0xC2   0x603C             STR      R4,[R7, #+0]
   3017            }
   3018          
   3019          #if defined(SLI_PSA_ITS_ENCRYPTED)
   3020            // its_file_size includes size of sli_its_encrypted_blob_t struct
   3021            blob = (sli_its_encrypted_blob_t*)mbedtls_calloc(1, its_file_size);
   3022            if (blob == NULL) {
   3023              psa_status = PSA_ERROR_INSUFFICIENT_MEMORY;
   3024              goto exit;
   3025            }
   3026            memset(blob, 0, its_file_size);
   3027          
   3028            status = nvm3_readPartialData(nvm3_defaultHandle,
   3029                                          nvm3_object_id,
   3030                                          blob,
   3031                                          its_file_offset,
   3032                                          its_file_size);
   3033            if (status != ECODE_NVM3_OK) {
   3034              psa_status = PSA_ERROR_STORAGE_FAILURE;
   3035              goto exit;
   3036            }
   3037          
   3038            // Decrypt and authenticate blob
   3039            psa_status = sli_decrypt_its_file(&its_file_meta,
   3040                                              blob,
   3041                                              its_file_size,
   3042                                              blob->data,
   3043                                              its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   3044                                              &plaintext_length);
   3045          
   3046            if (psa_status != PSA_SUCCESS) {
   3047              goto exit;
   3048            }
   3049          
   3050            if (plaintext_length != (its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   3051              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   3052              goto exit;
   3053            }
   3054          
   3055            // Verify that the requested UID is equal to the retrieved and authenticated UID
   3056            if (uid != its_file_meta.uid) {
   3057              psa_status = PSA_ERROR_INVALID_ARGUMENT;
   3058              goto exit;
   3059            }
   3060          
   3061            if (*p_data_length > 0) {
   3062              memcpy(p_data, blob->data + data_offset, *p_data_length);
   3063            }
   3064            psa_status = PSA_SUCCESS;
   3065          
   3066            exit:
   3067            if (blob != NULL) {
   3068              memset(blob, 0, its_file_size);
   3069              mbedtls_free(blob);
   3070            }
   3071            sli_its_release_mutex();
   3072          #else
   3073            // If no encryption is used, just read out the data and write it directly to the output buffer
   3074            status = nvm3_readPartialData(nvm3_defaultHandle, nvm3_object_id, p_data, its_file_offset + data_offset, *p_data_length);
   \                     ??psa_its_get_10: (+1)
   \       0xC4   0x6838             LDR      R0,[R7, #+0]
   \       0xC6   0x9000             STR      R0,[SP, #+0]
   \       0xC8   0x9B03             LDR      R3,[SP, #+12]
   \       0xCA   0xEB18 0x0303      ADDS     R3,R8,R3
   \       0xCE   0x0032             MOVS     R2,R6
   \       0xD0   0x9905             LDR      R1,[SP, #+20]
   \       0xD2   0x....             LDR.N    R0,??DataTable16_13
   \       0xD4   0x6800             LDR      R0,[R0, #+0]
   \       0xD6   0x.... 0x....      BL       nvm3_readPartialData
   \       0xDA   0x9006             STR      R0,[SP, #+24]
   3075          
   3076            if (status != ECODE_NVM3_OK) {
   \       0xDC   0x9806             LDR      R0,[SP, #+24]
   \       0xDE   0x2800             CMP      R0,#+0
   \       0xE0   0xD003             BEQ.N    ??psa_its_get_11
   3077              psa_status = PSA_ERROR_STORAGE_FAILURE;
   \       0xE2   0xF07F 0x0091      MVNS     R0,#+145
   \       0xE6   0x4681             MOV      R9,R0
   \       0xE8   0xE001             B.N      ??psa_its_get_4
   3078            } else {
   3079              psa_status = PSA_SUCCESS;
   \                     ??psa_its_get_11: (+1)
   \       0xEA   0x2000             MOVS     R0,#+0
   \       0xEC   0x4681             MOV      R9,R0
   3080            }
   3081          
   3082            exit:
   3083            sli_its_release_mutex();
   \                     ??psa_its_get_4: (+1)
   \       0xEE   0x.... 0x....      BL       sli_its_release_mutex
   3084          #endif
   3085          
   3086            return psa_status;
   \       0xF2   0x4648             MOV      R0,R9
   \                     ??psa_its_get_1: (+1)
   \       0xF4   0xB00D             ADD      SP,SP,#+52
   \       0xF6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3087          }
   3088          
   3089          /**
   3090           * \brief Retrieve the metadata about the provided uid
   3091           *
   3092           * \param[in] uid           The uid value
   3093           * \param[out] p_info       A pointer to the `psa_storage_info_t` struct that will be populated with the metadata
   3094           *
   3095           * \return      A status indicating the success/failure of the operation
   3096           *
   3097           * \retval      PSA_SUCCESS                  The operation completed successfully
   3098           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided uid value was not found in the storage
   3099           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   3100           * \retval      PSA_ERROR_INVALID_ARGUMENT   The operation failed because one of the provided pointers(`p_info`)
   3101           *                                           is invalid, for example is `NULL` or references memory the caller cannot access
   3102           * \retval      PSA_ERROR_INVALID_SIGANTURE  The operation failed because authentication of the stored metadata failed.
   3103           */

   \                                 In section .text, align 2, keep-with-next
   3104          psa_status_t psa_its_get_info(psa_storage_uid_t uid,
   3105                                        struct psa_storage_info_t *p_info)
   3106          {
   \                     psa_its_get_info: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   3107            if (p_info == NULL) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD102             BNE.N    ??psa_its_get_info_0
   3108              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x10   0xF07F 0x0086      MVNS     R0,#+134
   \       0x14   0xE027             B.N      ??psa_its_get_info_1
   3109            }
   3110          
   3111            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \                     ??psa_its_get_info_0: (+1)
   \       0x16   0xF07F 0x0896      MVNS     R8,#+150
   \       0x1A   0x2110             MOVS     R1,#+16
   \       0x1C   0x2200             MOVS     R2,#+0
   \       0x1E   0xAF06             ADD      R7,SP,#+24
   \       0x20   0x0038             MOVS     R0,R7
   \       0x22   0x.... 0x....      BL       __aeabi_memset
   3112            sli_its_file_meta_v2_t its_file_meta = { 0 };
   3113            size_t its_file_size = 0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x9003             STR      R0,[SP, #+12]
   3114            size_t its_file_offset = 0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x9004             STR      R0,[SP, #+16]
   3115            nvm3_ObjectKey_t nvm3_object_id;
   3116          
   3117            sli_its_acquire_mutex();
   \       0x2E   0x.... 0x....      BL       sli_its_acquire_mutex
   3118            psa_status = find_nvm3_id(uid, false, &its_file_meta, &its_file_offset, &its_file_size, &nvm3_object_id);
   \       0x32   0xA805             ADD      R0,SP,#+20
   \       0x34   0x9002             STR      R0,[SP, #+8]
   \       0x36   0xA803             ADD      R0,SP,#+12
   \       0x38   0x9001             STR      R0,[SP, #+4]
   \       0x3A   0xA804             ADD      R0,SP,#+16
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   \       0x3E   0xAB06             ADD      R3,SP,#+24
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x0029             MOVS     R1,R5
   \       0x46   0x.... 0x....      BL       find_nvm3_id
   \       0x4A   0x0007             MOVS     R7,R0
   3119            if (psa_status != PSA_SUCCESS) {
   \       0x4C   0x2F00             CMP      R7,#+0
   \       0x4E   0xD003             BEQ.N    ??psa_its_get_info_2
   3120              sli_its_release_mutex();
   \       0x50   0x.... 0x....      BL       sli_its_release_mutex
   3121              return psa_status;
   \       0x54   0x0038             MOVS     R0,R7
   \       0x56   0xE006             B.N      ??psa_its_get_info_1
   3122            }
   3123          
   3124            p_info->flags = its_file_meta.flags;
   \                     ??psa_its_get_info_2: (+1)
   \       0x58   0x9807             LDR      R0,[SP, #+28]
   \       0x5A   0x6070             STR      R0,[R6, #+4]
   3125            p_info->size = its_file_size;
   \       0x5C   0x9803             LDR      R0,[SP, #+12]
   \       0x5E   0x6030             STR      R0,[R6, #+0]
   3126          
   3127          #if defined(SLI_PSA_ITS_ENCRYPTED)
   3128            // Remove IV and MAC size from file size
   3129            p_info->size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   3130          #endif
   3131            sli_its_release_mutex();
   \       0x60   0x.... 0x....      BL       sli_its_release_mutex
   3132            return PSA_SUCCESS;
   \       0x64   0x2000             MOVS     R0,#+0
   \                     ??psa_its_get_info_1: (+1)
   \       0x66   0xB00A             ADD      SP,SP,#+40
   \       0x68   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3133          }
   3134          
   3135          /**
   3136           * \brief Remove the provided key and its associated data from the storage
   3137           *
   3138           * \param[in] uid   The uid value
   3139           *
   3140           * \return  A status indicating the success/failure of the operation
   3141           *
   3142           * \retval      PSA_SUCCESS                  The operation completed successfully
   3143           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided key value was not found in the storage
   3144           * \retval      PSA_ERROR_NOT_PERMITTED      The operation failed because the provided key value was created with PSA_STORAGE_FLAG_WRITE_ONCE
   3145           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   3146           */

   \                                 In section .text, align 2, keep-with-next
   3147          psa_status_t psa_its_remove(psa_storage_uid_t uid)
   3148          {
   \                     psa_its_remove: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   3149            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0xA   0xF07F 0x0896      MVNS     R8,#+150
   \        0xE   0x2110             MOVS     R1,#+16
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0xAF06             ADD      R7,SP,#+24
   \       0x14   0x0038             MOVS     R0,R7
   \       0x16   0x.... 0x....      BL       __aeabi_memset
   3150            Ecode_t status;
   3151            sli_its_file_meta_v2_t its_file_meta = { 0 };
   3152            size_t its_file_size = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9005             STR      R0,[SP, #+20]
   3153            size_t its_file_offset = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x9004             STR      R0,[SP, #+16]
   3154            nvm3_ObjectKey_t nvm3_object_id;
   3155          
   3156            sli_its_acquire_mutex();
   \       0x22   0x.... 0x....      BL       sli_its_acquire_mutex
   3157            psa_status = find_nvm3_id(uid, false, &its_file_meta, &its_file_offset, &its_file_size, &nvm3_object_id);
   \       0x26   0xA803             ADD      R0,SP,#+12
   \       0x28   0x9002             STR      R0,[SP, #+8]
   \       0x2A   0xA805             ADD      R0,SP,#+20
   \       0x2C   0x9001             STR      R0,[SP, #+4]
   \       0x2E   0xA804             ADD      R0,SP,#+16
   \       0x30   0x9000             STR      R0,[SP, #+0]
   \       0x32   0xAB06             ADD      R3,SP,#+24
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x0029             MOVS     R1,R5
   \       0x3A   0x.... 0x....      BL       find_nvm3_id
   \       0x3E   0x0007             MOVS     R7,R0
   3158            if (psa_status != PSA_SUCCESS) {
   \       0x40   0x2F00             CMP      R7,#+0
   \       0x42   0xD11A             BNE.N    ??psa_its_remove_0
   3159              goto exit;
   3160            }
   3161            if (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE
   3162          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   3163                || (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE)
   3164          #endif
   3165                ) {
   \                     ??psa_its_remove_1: (+1)
   \       0x44   0x9807             LDR      R0,[SP, #+28]
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD103             BNE.N    ??psa_its_remove_2
   3166              psa_status = PSA_ERROR_NOT_PERMITTED;
   \       0x4A   0xF07F 0x0084      MVNS     R0,#+132
   \       0x4E   0x0007             MOVS     R7,R0
   3167              goto exit;
   \       0x50   0xE013             B.N      ??psa_its_remove_0
   3168            }
   3169            status = nvm3_deleteObject(nvm3_defaultHandle, nvm3_object_id);
   \                     ??psa_its_remove_2: (+1)
   \       0x52   0x9903             LDR      R1,[SP, #+12]
   \       0x54   0x....             LDR.N    R0,??DataTable16_13
   \       0x56   0x6800             LDR      R0,[R0, #+0]
   \       0x58   0x.... 0x....      BL       nvm3_deleteObject
   \       0x5C   0x0006             MOVS     R6,R0
   3170            if (status == ECODE_NVM3_OK) {
   \       0x5E   0x2E00             CMP      R6,#+0
   \       0x60   0xD108             BNE.N    ??psa_its_remove_3
   3171              // Power-loss might occur, however upon boot, the look-up table will be
   3172              // re-filled as long as the data has been successfully written to NVM3.
   3173              clear_cache(nvm3_object_id);
   \       0x62   0x9803             LDR      R0,[SP, #+12]
   \       0x64   0x.... 0x....      BL       clear_cache
   3174              set_tomb(nvm3_object_id);
   \       0x68   0x9803             LDR      R0,[SP, #+12]
   \       0x6A   0x.... 0x....      BL       set_tomb
   3175              psa_status = PSA_SUCCESS;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x0007             MOVS     R7,R0
   \       0x72   0xE002             B.N      ??psa_its_remove_0
   3176            } else {
   3177              psa_status = PSA_ERROR_STORAGE_FAILURE;
   \                     ??psa_its_remove_3: (+1)
   \       0x74   0xF07F 0x0091      MVNS     R0,#+145
   \       0x78   0x0007             MOVS     R7,R0
   3178            }
   3179          
   3180            exit:
   3181            sli_its_release_mutex();
   \                     ??psa_its_remove_0: (+1)
   \       0x7A   0x.... 0x....      BL       sli_its_release_mutex
   3182            return psa_status;
   \       0x7E   0x0038             MOVS     R0,R7
   \       0x80   0xB00A             ADD      SP,SP,#+40
   \       0x82   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3183          }
   3184          
   3185          // -------------------------------------
   3186          // Silicon Labs extensions
   3187          

   \                                 In section .text, align 2, keep-with-next
   3188          static psa_storage_uid_t psa_its_identifier_of_slot(mbedtls_svc_key_id_t key)
   3189          {
   3190          #if defined(MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER)
   3191            /* Encode the owner in the upper 32 bits. This means that if
   3192             * owner values are nonzero (as they are on a PSA platform),
   3193             * no key file will ever have a value less than 0x100000000, so
   3194             * the whole range 0..0xffffffff is available for non-key files. */
   3195            uint32_t unsigned_owner_id = MBEDTLS_SVC_KEY_ID_GET_OWNER_ID(key);
   3196            return ((uint64_t) unsigned_owner_id << 32) | MBEDTLS_SVC_KEY_ID_GET_KEY_ID(key);
   3197          #else
   3198            /* Use the key id directly as a file name.
   3199             * psa_is_key_id_valid() in psa_crypto_slot_management.c
   3200             * is responsible for ensuring that key identifiers do not have a
   3201             * value that is reserved for non-key files. */
   3202            return key;
   \                     psa_its_identifier_of_slot: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x4770             BX       LR
   3203          #endif
   3204          }
   3205          

   \                                 In section .text, align 2, keep-with-next
   3206          psa_status_t sli_psa_its_change_key_id(mbedtls_svc_key_id_t old_id,
   3207                                                 mbedtls_svc_key_id_t new_id)
   3208          {
   \                     sli_psa_its_change_key_id: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   3209            psa_storage_uid_t old_uid = psa_its_identifier_of_slot(old_id);
   \        0x6   0x9805             LDR      R0,[SP, #+20]
   \        0x8   0x.... 0x....      BL       psa_its_identifier_of_slot
   \        0xC   0x0004             MOVS     R4,R0
   \        0xE   0x000D             MOVS     R5,R1
   3210            psa_storage_uid_t new_uid = psa_its_identifier_of_slot(new_id);
   \       0x10   0x9806             LDR      R0,[SP, #+24]
   \       0x12   0x.... 0x....      BL       psa_its_identifier_of_slot
   \       0x16   0x0006             MOVS     R6,R0
   \       0x18   0x000F             MOVS     R7,R1
   3211            size_t its_file_size = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9002             STR      R0,[SP, #+8]
   3212            psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x1E   0xF07F 0x0896      MVNS     R8,#+150
   3213            if (old_id == new_id) {
   \       0x22   0x9905             LDR      R1,[SP, #+20]
   \       0x24   0x9806             LDR      R0,[SP, #+24]
   \       0x26   0x4281             CMP      R1,R0
   \       0x28   0xD101             BNE.N    ??sli_psa_its_change_key_id_0
   3214              return PSA_SUCCESS;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xE044             B.N      ??sli_psa_its_change_key_id_1
   3215            }
   3216            // Check whether the key to migrate exists on disk
   3217            struct psa_storage_info_t p_info;
   3218            status = psa_its_get_info(old_uid, &p_info);
   \                     ??sli_psa_its_change_key_id_0: (+1)
   \       0x2E   0xAA03             ADD      R2,SP,#+12
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x0029             MOVS     R1,R5
   \       0x34   0x.... 0x....      BL       psa_its_get_info
   \       0x38   0x4682             MOV      R10,R0
   3219            if (status != PSA_SUCCESS) {
   \       0x3A   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x3E   0xD001             BEQ.N    ??sli_psa_its_change_key_id_2
   3220              return status;
   \       0x40   0x4650             MOV      R0,R10
   \       0x42   0xE039             B.N      ??sli_psa_its_change_key_id_1
   3221            }
   3222          
   3223            // Allocate temporary buffer and cast it to the metadata format
   3224            uint8_t *its_file_buffer = mbedtls_calloc(1, p_info.size);
   \                     ??sli_psa_its_change_key_id_2: (+1)
   \       0x44   0x9903             LDR      R1,[SP, #+12]
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0x.... 0x....      BL       sl_calloc
   \       0x4C   0x4681             MOV      R9,R0
   3225            if (its_file_buffer == NULL) {
   \       0x4E   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x52   0xD102             BNE.N    ??sli_psa_its_change_key_id_3
   3226              return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x54   0xF07F 0x008C      MVNS     R0,#+140
   \       0x58   0xE02E             B.N      ??sli_psa_its_change_key_id_1
   3227            }
   3228            // Read contents of pre-existing key into the temporary buffer
   3229            status = psa_its_get(old_uid, 0, p_info.size, its_file_buffer,
   3230                                 &its_file_size);
   \                     ??sli_psa_its_change_key_id_3: (+1)
   \       0x5A   0xA802             ADD      R0,SP,#+8
   \       0x5C   0x9001             STR      R0,[SP, #+4]
   \       0x5E   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x62   0x9B03             LDR      R3,[SP, #+12]
   \       0x64   0x2200             MOVS     R2,#+0
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x0029             MOVS     R1,R5
   \       0x6A   0x.... 0x....      BL       psa_its_get
   \       0x6E   0x4680             MOV      R8,R0
   3231          
   3232            if (status != PSA_SUCCESS) {
   \       0x70   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x74   0xD112             BNE.N    ??sli_psa_its_change_key_id_4
   3233              goto exit;
   3234            }
   3235          
   3236            status = psa_its_set(new_uid, its_file_size, its_file_buffer,
   3237                                 p_info.flags);
   \                     ??sli_psa_its_change_key_id_5: (+1)
   \       0x76   0x9804             LDR      R0,[SP, #+16]
   \       0x78   0x9000             STR      R0,[SP, #+0]
   \       0x7A   0x464B             MOV      R3,R9
   \       0x7C   0x9A02             LDR      R2,[SP, #+8]
   \       0x7E   0x0030             MOVS     R0,R6
   \       0x80   0x0039             MOVS     R1,R7
   \       0x82   0x.... 0x....      BL       psa_its_set
   \       0x86   0x4680             MOV      R8,R0
   3238          
   3239            if (status != PSA_SUCCESS) {
   \       0x88   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x8C   0xD106             BNE.N    ??sli_psa_its_change_key_id_4
   3240              goto exit;
   3241            }
   3242          
   3243            status = psa_its_remove(old_uid);
   \                     ??sli_psa_its_change_key_id_6: (+1)
   \       0x8E   0x0020             MOVS     R0,R4
   \       0x90   0x0029             MOVS     R1,R5
   \       0x92   0x.... 0x....      BL       psa_its_remove
   \       0x96   0x4680             MOV      R8,R0
   3244          
   3245            if (status != PSA_SUCCESS) {
   \       0x98   0xF1B8 0x0F00      CMP      R8,#+0
   3246              goto exit;
   3247            }
   3248          
   3249            exit:
   3250            // Clear and free key buffer before return.
   3251            memset(its_file_buffer, 0, its_file_size);
   \                     ??sli_psa_its_change_key_id_4: (+1)
   \       0x9C   0x9802             LDR      R0,[SP, #+8]
   \       0x9E   0x9000             STR      R0,[SP, #+0]
   \       0xA0   0xF05F 0x0B00      MOVS     R11,#+0
   \       0xA4   0x46CA             MOV      R10,R9
   \       0xA6   0x465A             MOV      R2,R11
   \       0xA8   0x9900             LDR      R1,[SP, #+0]
   \       0xAA   0x4650             MOV      R0,R10
   \       0xAC   0x.... 0x....      BL       __aeabi_memset
   3252            mbedtls_free(its_file_buffer);
   \       0xB0   0x4648             MOV      R0,R9
   \       0xB2   0x.... 0x....      BL       sl_free
   3253            return status;
   \       0xB6   0x4640             MOV      R0,R8
   \                     ??sli_psa_its_change_key_id_1: (+1)
   \       0xB8   0xB007             ADD      SP,SP,#+28
   \       0xBA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3254          }
   3255          
   3256          /**
   3257           * \brief Check if the ITS encryption is enabled
   3258           */

   \                                 In section .text, align 2, keep-with-next
   3259          psa_status_t sli_psa_its_encrypted(void)
   3260          {
   3261          #if defined(SLI_PSA_ITS_ENCRYPTED)
   3262            return PSA_SUCCESS;
   3263          #else
   3264            return PSA_ERROR_NOT_SUPPORTED;
   \                     sli_psa_its_encrypted: (+1)
   \        0x0   0xF07F 0x0085      MVNS     R0,#+133
   \        0x4   0x4770             BX       LR
   3265          #endif
   3266          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     its_mutex_inited

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x....'....        DC32     its_mutex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x....'....        DC32     mbedtls_mutex_init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x....'....        DC32     mbedtls_mutex_lock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x....'....        DC32     mbedtls_mutex_unlock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0xFFF7'9300        DC32     0xfff79300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x....'....        DC32     nvm3_uid_set_cache

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0x....'....        DC32     nvm3_uid_tomb_cache

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0xFFF7'9301        DC32     0xfff79301

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x0008'6D00        DC32     0x86d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \        0x0   0x0008'7100        DC32     0x87100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \        0x0   0x0008'7101        DC32     0x87101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \        0x0   0x....'....        DC32     nvm3_defaultHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \        0x0   0x....'....        DC32     nvm3_uid_set_cache_initialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \        0x0   0x5E17'5D10        DC32     0x5e175d10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \        0x0   0xF000'DFFF        DC32     0xf000dfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \        0x0   0xF000'E011        DC32     0xf000e011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \        0x0   0xF000'DFFE        DC32     0xf000dffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \        0x0   0x2004'0000        DC32     0x20040000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x44 0x3A          DC8 0x44, 0x3A, 0x5C, 0x49, 0x6E, 0x65, 0x73, 0x68
   \              0x5C 0x49    
   \              0x6E 0x65    
   \              0x73 0x68
   \        0x8   0x5F 0x77          DC8 0x5F, 0x77, 0x69, 0x73, 0x75, 0x6E, 0x5C, 0x57
   \              0x69 0x73    
   \              0x75 0x6E    
   \              0x5C 0x57
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F, 0x64
   \              0x75 0x6E    
   \              0x5F 0x4E    
   \              0x6F 0x64
   \       0x18   0x65 0x5F          DC8 0x65, 0x5F, 0x41, 0x70, 0x70, 0x20, 0x31, 0x5C
   \              0x41 0x70    
   \              0x70 0x20    
   \              0x31 0x5C
   \       0x20   0x57 0x69          DC8 0x57, 0x69, 0x73, 0x75, 0x6E, 0x5F, 0x4E, 0x6F
   \              0x73 0x75    
   \              0x6E 0x5F    
   \              0x4E 0x6F
   \       0x28   0x64 0x65          DC8 0x64, 0x65, 0x5F, 0x41, 0x70, 0x70, 0x5C, 0x67
   \              0x5F 0x41    
   \              0x70 0x70    
   \              0x5C 0x67
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64, 0x6B
   \              0x6B 0x6F    
   \              0x5F 0x73    
   \              0x64 0x6B
   \       0x38   0x5F 0x34          DC8 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x35, 0x5C, 0x70
   \              0x2E 0x34    
   \              0x2E 0x35    
   \              0x5C 0x70
   \       0x40   0x6C 0x61          DC8 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x5C
   \              0x74 0x66    
   \              0x6F 0x72    
   \              0x6D 0x5C
   \       0x48   0x73 0x65          DC8 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79
   \              0x63 0x75    
   \              0x72 0x69    
   \              0x74 0x79
   \       0x50   0x5C 0x73          DC8 0x5C, 0x73, 0x6C, 0x5F, 0x63, 0x6F, 0x6D, 0x70
   \              0x6C 0x5F    
   \              0x63 0x6F    
   \              0x6D 0x70
   \       0x58   0x6F 0x6E          DC8 0x6F, 0x6E, 0x65, 0x6E, 0x74, 0x5C, 0x73, 0x6C
   \              0x65 0x6E    
   \              0x74 0x5C    
   \              0x73 0x6C
   \       0x60   0x5F 0x70          DC8 0x5F, 0x70, 0x73, 0x61, 0x5F, 0x64, 0x72, 0x69
   \              0x73 0x61    
   \              0x5F 0x64    
   \              0x72 0x69
   \       0x68   0x76 0x65          DC8 0x76, 0x65, 0x72, 0x5C, 0x73, 0x72, 0x63, 0x5C
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C
   \       0x70   0x73 0x6C          DC8 0x73, 0x6C, 0x5F, 0x70, 0x73, 0x61, 0x5F, 0x69
   \              0x5F 0x70    
   \              0x73 0x61    
   \              0x5F 0x69
   \       0x78   0x74 0x73          DC8 0x74, 0x73, 0x5F, 0x6E, 0x76, 0x6D, 0x33, 0x2E
   \              0x5F 0x6E    
   \              0x76 0x6D    
   \              0x33 0x2E
   \       0x80   0x63 0x00          DC8 0x63, 0
   \       0x82                      DS8 2
   3267          
   3268          #if defined(SLI_PSA_ITS_ENCRYPTED) && !defined(SEMAILBOX_PRESENT)
   3269          /**
   3270           * \brief Set the root key to be used when deriving session keys for ITS encryption.
   3271           *
   3272           * \param[in] root_key        Buffer containing the root key.
   3273           * \param[in] root_key_size   Size of the root key in bytes. Must be 32 (256 bits).
   3274           *
   3275           * \return  A status indicating the success/failure of the operation
   3276           *
   3277           * \retval      PSA_SUCCESS                  The key was successfully set.
   3278           * \retval      PSA_ERROR_INVALID_ARGUMENT   The root key was NULL or had an invalid size.
   3279           * \retval      PSA_ERROR_ALREADY_EXISTS     The root key has already been initialized.
   3280           */
   3281          psa_status_t sli_psa_its_set_root_key(uint8_t *root_key, size_t root_key_size)
   3282          {
   3283            // Check that arguments are valid
   3284            if (root_key == NULL || root_key_size != sizeof(g_root_key.data)) {
   3285              return PSA_ERROR_INVALID_ARGUMENT;
   3286            }
   3287          
   3288            // Check that the root key has not already been set
   3289            // (This is possibly too restrictive. For TrustZone usage this can be enforced by
   3290            // not exposing the function to NS instead.)
   3291            if (g_root_key.initialized) {
   3292              return PSA_ERROR_ALREADY_EXISTS;
   3293            }
   3294          
   3295            // Store the provided root key and mark it as initialized
   3296            memcpy(g_root_key.data, root_key, sizeof(g_root_key.data));
   3297            g_root_key.initialized = true;
   3298          
   3299            return PSA_SUCCESS;
   3300          }
   3301          #endif // defined(SLI_PSA_ITS_ENCRYPTED) && !defined(SEMAILBOX_PRESENT)
   3302          #endif // (!SL_PSA_ITS_SUPPORT_V3_DRIVER)
   3303          #endif // MBEDTLS_PSA_CRYPTO_STORAGE_C && !MBEDTLS_PSA_ITS_FILE_C

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   THREADING_SetRecursive
      24   clear_cache
        24   -> get_index
        24   -> get_offset
      16   derive_nvm3_id
        16   -> prng
      40   find_nvm3_id
        40   -> derive_nvm3_id
        40   -> get_file_metadata
        40   -> increment_obj_id
        40   -> init_cache
        40   -> lookup_cache
        40   -> lookup_tomb
        40   -> nvm3_deleteObject
        40   -> nvm3_initDefault
      32   get_file_metadata
        32   -> nvm3_getObjectInfo
        32   -> nvm3_readPartialData
       0   get_index
       0   get_offset
       0   increment_obj_id
     160   init_cache
       160   -> __aeabi_memset
       160   -> nvm3_enumDeletedObjects
       160   -> nvm3_enumObjects
       160   -> set_cache
       160   -> set_tomb
      16   lock_task_switches
        16   -> osKernelGetState
        16   -> osKernelLock
      16   lookup_cache
        16   -> get_index
        16   -> get_offset
      16   lookup_tomb
        16   -> get_index
        16   -> get_offset
      16   prng
      88   psa_its_get
        88   -> __aeabi_memset
        88   -> find_nvm3_id
        88   -> nvm3_readPartialData
        88   -> sli_its_acquire_mutex
        88   -> sli_its_release_mutex
      64   psa_its_get_info
        64   -> __aeabi_memset
        64   -> find_nvm3_id
        64   -> sli_its_acquire_mutex
        64   -> sli_its_release_mutex
       0   psa_its_identifier_of_slot
      64   psa_its_remove
        64   -> __aeabi_memset
        64   -> clear_cache
        64   -> find_nvm3_id
        64   -> nvm3_deleteObject
        64   -> set_tomb
        64   -> sli_its_acquire_mutex
        64   -> sli_its_release_mutex
      72   psa_its_set
        72   -> __aeabi_memcpy
        72   -> __aeabi_memset
        72   -> find_nvm3_id
        72   -> nvm3_writeData
        72   -> set_cache
        72   -> sl_calloc
        72   -> sl_free
        72   -> sli_its_acquire_mutex
        72   -> sli_its_release_mutex
      16   restore_lock_state
        16   -> assertEFM
        16   -> osKernelGetState
        16   -> osKernelRestoreLock
      24   set_cache
        24   -> get_index
        24   -> get_offset
      24   set_tomb
        24   -> get_index
        24   -> get_offset
      16   sli_its_acquire_mutex
        16   -- Indirect call
        16   -> THREADING_SetRecursive
        16   -> assertEFM
        16   -> lock_task_switches
        16   -> restore_lock_state
       8   sli_its_release_mutex
         8   -- Indirect call
      64   sli_psa_its_change_key_id
        64   -> __aeabi_memset
        64   -> psa_its_get
        64   -> psa_its_get_info
        64   -> psa_its_identifier_of_slot
        64   -> psa_its_remove
        64   -> psa_its_set
        64   -> sl_calloc
        64   -> sl_free
       0   sli_psa_its_encrypted


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
     132  ?_0
      14  THREADING_SetRecursive
      42  clear_cache
      34  derive_nvm3_id
     296  find_nvm3_id
     126  get_file_metadata
      10  get_index
       6  get_offset
      26  increment_obj_id
     166  init_cache
      20  its_mutex
       1  its_mutex_inited
      28  lock_task_switches
      34  lookup_cache
      34  lookup_tomb
      20  nvm3_uid_set_cache
       1  nvm3_uid_set_cache_initialized
      20  nvm3_uid_tomb_cache
      50  prng
     250  psa_its_get
     108  psa_its_get_info
       4  psa_its_identifier_of_slot
     134  psa_its_remove
     286  psa_its_set
      40  restore_lock_state
      76  set_cache
      84  set_tomb
      82  sli_its_acquire_mutex
      26  sli_its_release_mutex
     190  sli_psa_its_change_key_id
       6  sli_psa_its_encrypted

 
    62 bytes in section .bss
   132 bytes in section .rodata
 2'232 bytes in section .text
 
 2'232 bytes of CODE  memory
   132 bytes of CONST memory
    62 bytes of DATA  memory

Errors: none
Warnings: none
