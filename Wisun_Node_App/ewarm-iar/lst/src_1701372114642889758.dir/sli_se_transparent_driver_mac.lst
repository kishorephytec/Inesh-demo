###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:36
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_transparent_driver_mac.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_transparent_driver_mac.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_transparent_driver_mac.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_transparent_driver_mac.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir\sli_se_transparent_driver_mac.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_transparent_driver_mac.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_transparent_driver_mac.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Transparent Driver Mac functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "psa/crypto.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t psa_get_key_type(psa_key_attributes_t const *)
   \                     psa_get_key_type: (+1)
   \        0x0   0x8800             LDRH     R0,[R0, #+0]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t psa_get_key_bits(psa_key_attributes_t const *)
   \                     psa_get_key_bits: (+1)
   \        0x0   0x8840             LDRH     R0,[R0, #+2]
   \        0x2   0x4770             BX       LR
     36          
     37          #include "sli_se_transparent_types.h"
     38          #include "sli_se_transparent_functions.h"
     39          #include "sli_psa_driver_common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint8_t sli_psa_safer_memcmp(uint8_t const *, uint8_t const *, size_t)
   \                     sli_psa_safer_memcmp: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x2400             MOVS     R4,#+0
   \                     ??sli_psa_safer_memcmp_0: (+1)
   \        0x8   0x4294             CMP      R4,R2
   \        0xA   0xD205             BCS.N    ??sli_psa_safer_memcmp_1
   \        0xC   0x5D35             LDRB     R5,[R6, R4]
   \        0xE   0x5D0B             LDRB     R3,[R1, R4]
   \       0x10   0x405D             EORS     R5,R3,R5
   \       0x12   0x4328             ORRS     R0,R5,R0
   \       0x14   0x1C64             ADDS     R4,R4,#+1
   \       0x16   0xE7F7             B.N      ??sli_psa_safer_memcmp_0
   \                     ??sli_psa_safer_memcmp_1: (+1)
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0xBC70             POP      {R4-R6}
   \       0x1C   0x4770             BX       LR
     40          
     41          #include <string.h>
     42          
     43          //------------------------------------------------------------------------------
     44          // Static asserts
     45          
     46          // Make sure that the two locations of 'alg' are in the same place, since we
     47          // access them interchangeably.
     48          #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
     49          _Static_assert(offsetof(sli_se_transparent_mac_operation_t, hmac.alg)
     50                         == offsetof(sli_se_transparent_mac_operation_t,
     51                                     cipher_mac.operation.alg),
     52                         "hmac.alg and cipher_mac.oepration.alg are not aliases");
     53          #endif // SLI_PSA_DRIVER_FEATURE_MAC
     54          
     55          //------------------------------------------------------------------------------
     56          // Static functions
     57          
     58          #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
     59          
     60          static psa_status_t sli_se_transparent_driver_symmetric_key_from_context(
     61            sl_se_key_descriptor_t* key_desc,
     62            sli_se_transparent_mac_operation_t* operation)
     63          {
     64            // Point to transparent key buffer as storage location
     65            key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT;
     66            key_desc->storage.location.buffer.pointer = operation->cipher_mac.key;
     67            key_desc->storage.location.buffer.size = sizeof(operation->cipher_mac.key);
     68            key_desc->size = operation->cipher_mac.key_len;
     69          
     70            switch (PSA_ALG_FULL_LENGTH_MAC(operation->cipher_mac.operation.alg)) {
     71              case PSA_ALG_CBC_MAC:
     72              case PSA_ALG_CMAC:
     73                if (key_desc->size == 16) {
     74                  key_desc->type = SL_SE_KEY_TYPE_AES_128;
     75                } else if (key_desc->size == 24) {
     76                  key_desc->type = SL_SE_KEY_TYPE_AES_192;
     77                } else if (key_desc->size == 32) {
     78                  key_desc->type = SL_SE_KEY_TYPE_AES_256;
     79                } else {
     80                  return PSA_ERROR_BAD_STATE;
     81                }
     82                break;
     83              default:
     84                return PSA_ERROR_BAD_STATE;
     85            }
     86          
     87            return PSA_SUCCESS;
     88          }
     89          
     90          #endif // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
     91          
     92          #if defined(SLI_PSA_DRIVER_FEATURE_MAC)
     93          

   \                                 In section .text, align 2, keep-with-next
     94          static psa_status_t sli_se_transparent_driver_symmetric_key_from_psa(
     95            sl_se_key_descriptor_t* key_desc,
     96            const psa_key_attributes_t *attributes,
     97            const uint8_t *key_buffer,
     98            size_t key_buffer_size)
     99          {
   \                     sli_se_transparent_driver_symmetric_key_from_psa: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    100            // Point to transparent key buffer as storage location
    101            key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x60E0             STR      R0,[R4, #+12]
    102            key_desc->storage.location.buffer.pointer = (uint8_t *)key_buffer;
   \       0x10   0x6126             STR      R6,[R4, #+16]
    103            key_desc->storage.location.buffer.size = key_buffer_size;
   \       0x12   0x6167             STR      R7,[R4, #+20]
    104          
    105            // Verify and set key attributes
    106            psa_key_type_t keytype = psa_get_key_type(attributes);
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0x.... 0x....      BL       psa_get_key_type
   \       0x1A   0x4680             MOV      R8,R0
    107          
    108            switch (keytype) {
   \       0x1C   0x4640             MOV      R0,R8
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0xF5B0 0x5F88      CMP      R0,#+4352
   \       0x24   0xD10A             BNE.N    ??sli_se_transparent_driver_symmetric_key_from__0
    109              #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    110              case PSA_KEY_TYPE_AES: {
    111                switch (psa_get_key_bits(attributes)) {
    112                  case 128:
    113                    key_desc->size = 16;
    114                    key_desc->type = SL_SE_KEY_TYPE_AES_128;
    115                    break;
    116                  case 192:
    117                    key_desc->size = 24;
    118                    key_desc->type = SL_SE_KEY_TYPE_AES_192;
    119                    break;
    120                  case 256:
    121                    key_desc->size = 32;
    122                    key_desc->type = SL_SE_KEY_TYPE_AES_256;
    123                    break;
    124                  default:
    125                    return PSA_ERROR_NOT_SUPPORTED;
    126                }
    127                break;
    128              }
    129              #endif // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    130          
    131              #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
    132              case PSA_KEY_TYPE_HMAC: {
    133                key_desc->size = psa_get_key_bits(attributes) / 8;
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       psa_get_key_bits
   \       0x2C   0x08C0             LSRS     R0,R0,#+3
   \       0x2E   0x6060             STR      R0,[R4, #+4]
    134                key_desc->type = SL_SE_KEY_TYPE_SYMMETRIC;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6020             STR      R0,[R4, #+0]
    135                break;
    136              }
    137              #endif // SLI_PSA_DRIVER_FEATURE_HMAC
    138          
    139              default:
    140                return PSA_ERROR_INVALID_ARGUMENT;
    141                break;
    142            }
    143          
    144            if (key_buffer_size < key_desc->size) {
   \       0x34   0x6860             LDR      R0,[R4, #+4]
   \       0x36   0x4287             CMP      R7,R0
   \       0x38   0xD206             BCS.N    ??sli_se_transparent_driver_symmetric_key_from__1
   \       0x3A   0xE002             B.N      ??sli_se_transparent_driver_symmetric_key_from__2
   \                     ??sli_se_transparent_driver_symmetric_key_from__0: (+1)
   \       0x3C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x40   0xE003             B.N      ??sli_se_transparent_driver_symmetric_key_from__3
    145              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_transparent_driver_symmetric_key_from__2: (+1)
   \       0x42   0xF07F 0x0086      MVNS     R0,#+134
   \       0x46   0xE000             B.N      ??sli_se_transparent_driver_symmetric_key_from__3
    146            }
    147          
    148            return PSA_SUCCESS;
   \                     ??sli_se_transparent_driver_symmetric_key_from__1: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??sli_se_transparent_driver_symmetric_key_from__3: (+1)
   \       0x4A   0xE8BD 0x81F0      POP      {R4-R8,PC}
    149          }
    150          
    151          #endif // SLI_PSA_DRIVER_FEATURE_MAC
    152          
    153          //------------------------------------------------------------------------------
    154          // Single-shot driver entry points
    155          

   \                                 In section .text, align 2, keep-with-next
    156          psa_status_t sli_se_transparent_mac_compute(
    157            const psa_key_attributes_t *attributes,
    158            const uint8_t *key_buffer,
    159            size_t key_buffer_size,
    160            psa_algorithm_t alg,
    161            const uint8_t *input,
    162            size_t input_length,
    163            uint8_t *mac,
    164            size_t mac_size,
    165            size_t *mac_length)
    166          {
   \                     sli_se_transparent_mac_compute: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x001E             MOVS     R6,R3
   \        0xE   0x9F14             LDR      R7,[SP, #+80]
   \       0x10   0xF8DD 0x8054      LDR      R8,[SP, #+84]
    167            #if defined(SLI_PSA_DRIVER_FEATURE_MAC)
    168          
    169            if (key_buffer == NULL
    170                || attributes == NULL) {
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD001             BEQ.N    ??sli_se_transparent_mac_compute_0
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD102             BNE.N    ??sli_se_transparent_mac_compute_1
    171              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_transparent_mac_compute_0: (+1)
   \       0x1C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x20   0xE01B             B.N      ??sli_se_transparent_mac_compute_2
    172            }
    173          
    174            // Ephemeral contexts
    175            sl_se_key_descriptor_t key_desc = { 0 };
   \                     ??sli_se_transparent_mac_compute_1: (+1)
   \       0x22   0xA803             ADD      R0,SP,#+12
   \       0x24   0x2120             MOVS     R1,#+32
   \       0x26   0x.... 0x....      BL       __aeabi_memclr4
    176            psa_status_t psa_status
    177              = sli_se_transparent_driver_symmetric_key_from_psa(&key_desc,
    178                                                                 attributes,
    179                                                                 key_buffer,
    180                                                                 key_buffer_size);
   \       0x2A   0x464B             MOV      R3,R9
   \       0x2C   0x002A             MOVS     R2,R5
   \       0x2E   0x0021             MOVS     R1,R4
   \       0x30   0xA803             ADD      R0,SP,#+12
   \       0x32   0x.... 0x....      BL       sli_se_transparent_driver_symmetric_key_from_psa
   \       0x36   0x4682             MOV      R10,R0
    181            if (psa_status != PSA_SUCCESS) {
   \       0x38   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x3C   0xD001             BEQ.N    ??sli_se_transparent_mac_compute_3
    182              return psa_status;
   \       0x3E   0x4650             MOV      R0,R10
   \       0x40   0xE00B             B.N      ??sli_se_transparent_mac_compute_2
    183            }
    184          
    185            return sli_se_driver_mac_compute(&key_desc,
    186                                             alg,
    187                                             input,
    188                                             input_length,
    189                                             mac,
    190                                             mac_size,
    191                                             mac_length);
   \                     ??sli_se_transparent_mac_compute_3: (+1)
   \       0x42   0x9818             LDR      R0,[SP, #+96]
   \       0x44   0x9002             STR      R0,[SP, #+8]
   \       0x46   0x9817             LDR      R0,[SP, #+92]
   \       0x48   0x9001             STR      R0,[SP, #+4]
   \       0x4A   0x9816             LDR      R0,[SP, #+88]
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x4643             MOV      R3,R8
   \       0x50   0x003A             MOVS     R2,R7
   \       0x52   0x0031             MOVS     R1,R6
   \       0x54   0xA803             ADD      R0,SP,#+12
   \       0x56   0x.... 0x....      BL       sli_se_driver_mac_compute
   \                     ??sli_se_transparent_mac_compute_2: (+1)
   \       0x5A   0xB00C             ADD      SP,SP,#+48
   \       0x5C   0xE8BD 0x87F0      POP      {R4-R10,PC}
    192          
    193            #else // SLI_PSA_DRIVER_FEATURE_MAC
    194          
    195            (void)attributes;
    196            (void)key_buffer;
    197            (void)key_buffer_size;
    198            (void)alg;
    199            (void)input;
    200            (void)input_length;
    201            (void)mac;
    202            (void)mac_size;
    203            (void)mac_length;
    204          
    205            return PSA_ERROR_NOT_SUPPORTED;
    206          
    207            #endif // SLI_PSA_DRIVER_FEATURE_MAC
    208          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    209          
    210          //------------------------------------------------------------------------------
    211          // Multi-part driver entry points
    212          

   \                                 In section .text, align 2, keep-with-next
    213          psa_status_t sli_se_transparent_mac_sign_setup(
    214            sli_se_transparent_mac_operation_t *operation,
    215            const psa_key_attributes_t *attributes,
    216            const uint8_t *key_buffer,
    217            size_t key_buffer_size,
    218            psa_algorithm_t alg)
    219          {
   \                     sli_se_transparent_mac_sign_setup: (+1)
   \        0x0   0xE92D 0x4FFA      PUSH     {R1,R3-R11,LR}
   \        0x4   0xB083             SUB      SP,SP,#+12
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0xF8DD 0xA038      LDR      R10,[SP, #+56]
    220            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    221          
    222            if (operation == NULL
    223                || attributes == NULL
    224                || (key_buffer == NULL && key_buffer_size > 0)) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD007             BEQ.N    ??sli_se_transparent_mac_sign_setup_0
   \       0x12   0x9803             LDR      R0,[SP, #+12]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD004             BEQ.N    ??sli_se_transparent_mac_sign_setup_0
   \       0x18   0x2E00             CMP      R6,#+0
   \       0x1A   0xD105             BNE.N    ??sli_se_transparent_mac_sign_setup_1
   \       0x1C   0x9804             LDR      R0,[SP, #+16]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD002             BEQ.N    ??sli_se_transparent_mac_sign_setup_1
    225              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_transparent_mac_sign_setup_0: (+1)
   \       0x22   0xF07F 0x0086      MVNS     R0,#+134
   \       0x26   0xE12F             B.N      ??sli_se_transparent_mac_sign_setup_2
    226            }
    227          
    228            psa_status_t status;
    229          
    230            // start by resetting context
    231            memset(operation, 0, sizeof(*operation));
   \                     ??sli_se_transparent_mac_sign_setup_1: (+1)
   \       0x28   0xF44F 0x74AE      MOV      R4,#+348
   \       0x2C   0x2700             MOVS     R7,#+0
   \       0x2E   0x46A8             MOV      R8,R5
   \       0x30   0x003A             MOVS     R2,R7
   \       0x32   0x0021             MOVS     R1,R4
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0x.... 0x....      BL       __aeabi_memset
    232          
    233            #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
    234            if (PSA_ALG_IS_HMAC(alg)) {
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable3
   \       0x3E   0xEA10 0x000A      ANDS     R0,R0,R10
   \       0x42   0xF1B0 0x7F60      CMP      R0,#+58720256
   \       0x46   0xF040 0x811D      BNE.W    ??sli_se_transparent_mac_sign_setup_3
    235              // SE does not support multipart HMAC. Construct it from hashing instead.
    236              // Check key type and output size
    237              if (psa_get_key_type(attributes) != PSA_KEY_TYPE_HMAC) {
   \       0x4A   0x9803             LDR      R0,[SP, #+12]
   \       0x4C   0x.... 0x....      BL       psa_get_key_type
   \       0x50   0xF5B0 0x5F88      CMP      R0,#+4352
   \       0x54   0xD002             BEQ.N    ??sli_se_transparent_mac_sign_setup_4
    238                // For HMAC, key type is strictly enforced
    239                return PSA_ERROR_INVALID_ARGUMENT;
   \       0x56   0xF07F 0x0086      MVNS     R0,#+134
   \       0x5A   0xE115             B.N      ??sli_se_transparent_mac_sign_setup_2
    240              }
    241          
    242              psa_algorithm_t hash_alg = PSA_ALG_HMAC_GET_HASH(alg);
   \                     ??sli_se_transparent_mac_sign_setup_4: (+1)
   \       0x5C   0xF00A 0x07FF      AND      R7,R10,#0xFF
   \       0x60   0xF057 0x7700      ORRS     R7,R7,#0x2000000
    243              size_t digest_len = PSA_HASH_LENGTH(hash_alg);
   \       0x64   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0x68   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \       0x70   0x4281             CMP      R1,R0
   \       0x72   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_5
   \       0x74   0xF05F 0x0810      MOVS     R8,#+16
   \       0x78   0xE080             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_5: (+1)
   \       0x7A   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0x7E   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \       0x86   0x4281             CMP      R1,R0
   \       0x88   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_7
   \       0x8A   0xF05F 0x0814      MOVS     R8,#+20
   \       0x8E   0xE075             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_7: (+1)
   \       0x90   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0x94   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x98   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \       0x9C   0x4281             CMP      R1,R0
   \       0x9E   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_8
   \       0xA0   0xF05F 0x0814      MOVS     R8,#+20
   \       0xA4   0xE06A             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_8: (+1)
   \       0xA6   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xAA   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xAE   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \       0xB2   0x4281             CMP      R1,R0
   \       0xB4   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_9
   \       0xB6   0xF05F 0x081C      MOVS     R8,#+28
   \       0xBA   0xE05F             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_9: (+1)
   \       0xBC   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xC0   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xC4   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \       0xC8   0x4281             CMP      R1,R0
   \       0xCA   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_10
   \       0xCC   0xF05F 0x0820      MOVS     R8,#+32
   \       0xD0   0xE054             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_10: (+1)
   \       0xD2   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xD6   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xDA   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \       0xDE   0x4281             CMP      R1,R0
   \       0xE0   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_11
   \       0xE2   0xF05F 0x0830      MOVS     R8,#+48
   \       0xE6   0xE049             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_11: (+1)
   \       0xE8   0xF007 0x01FF      AND      R1,R7,#0xFF
   \       0xEC   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0xF0   0x.... 0x....      LDR.W    R0,??DataTable3_7
   \       0xF4   0x4281             CMP      R1,R0
   \       0xF6   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_12
   \       0xF8   0xF05F 0x0840      MOVS     R8,#+64
   \       0xFC   0xE03E             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_12: (+1)
   \       0xFE   0xF007 0x01FF      AND      R1,R7,#0xFF
   \      0x102   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x106   0x.... 0x....      LDR.W    R0,??DataTable3_8
   \      0x10A   0x4281             CMP      R1,R0
   \      0x10C   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_13
   \      0x10E   0xF05F 0x081C      MOVS     R8,#+28
   \      0x112   0xE033             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_13: (+1)
   \      0x114   0xF007 0x01FF      AND      R1,R7,#0xFF
   \      0x118   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x11C   0x....             LDR.N    R0,??DataTable3_9
   \      0x11E   0x4281             CMP      R1,R0
   \      0x120   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_14
   \      0x122   0xF05F 0x0820      MOVS     R8,#+32
   \      0x126   0xE029             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_14: (+1)
   \      0x128   0xF007 0x01FF      AND      R1,R7,#0xFF
   \      0x12C   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x130   0x....             LDR.N    R0,??DataTable3_10
   \      0x132   0x4281             CMP      R1,R0
   \      0x134   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_15
   \      0x136   0xF05F 0x081C      MOVS     R8,#+28
   \      0x13A   0xE01F             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_15: (+1)
   \      0x13C   0xF007 0x00FF      AND      R0,R7,#0xFF
   \      0x140   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x144   0x....             LDR.N    R1,??DataTable3_11
   \      0x146   0x4288             CMP      R0,R1
   \      0x148   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_16
   \      0x14A   0xF05F 0x0820      MOVS     R8,#+32
   \      0x14E   0xE015             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_16: (+1)
   \      0x150   0xF007 0x00FF      AND      R0,R7,#0xFF
   \      0x154   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \      0x158   0x....             LDR.N    R1,??DataTable3_12
   \      0x15A   0x4288             CMP      R0,R1
   \      0x15C   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_17
   \      0x15E   0xF05F 0x0830      MOVS     R8,#+48
   \      0x162   0xE00B             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_17: (+1)
   \      0x164   0xF007 0x01FF      AND      R1,R7,#0xFF
   \      0x168   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \      0x16C   0x....             LDR.N    R0,??DataTable3_13
   \      0x16E   0x4281             CMP      R1,R0
   \      0x170   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_18
   \      0x172   0xF05F 0x0840      MOVS     R8,#+64
   \      0x176   0xE001             B.N      ??sli_se_transparent_mac_sign_setup_6
   \                     ??sli_se_transparent_mac_sign_setup_18: (+1)
   \      0x178   0xF05F 0x0800      MOVS     R8,#+0
    244          
    245              if (PSA_MAC_TRUNCATED_LENGTH(alg) > digest_len) {
   \                     ??sli_se_transparent_mac_sign_setup_6: (+1)
   \      0x17C   0xF3CA 0x4005      UBFX     R0,R10,#+16,#+6
   \      0x180   0x4580             CMP      R8,R0
   \      0x182   0xD202             BCS.N    ??sli_se_transparent_mac_sign_setup_19
    246                return PSA_ERROR_INVALID_ARGUMENT;
   \      0x184   0xF07F 0x0086      MVNS     R0,#+134
   \      0x188   0xE07E             B.N      ??sli_se_transparent_mac_sign_setup_2
    247              }
    248          
    249              // Setup the hash accumulator first, such that we can return early for non-
    250              // supported hash functions and avoid potentially overflowing buffer lengths.
    251              status = sli_se_transparent_hash_setup(&operation->hmac.hash_ctx,
    252                                                     hash_alg);
   \                     ??sli_se_transparent_mac_sign_setup_19: (+1)
   \      0x18A   0x0039             MOVS     R1,R7
   \      0x18C   0x1D28             ADDS     R0,R5,#+4
   \      0x18E   0x.... 0x....      BL       sli_se_transparent_hash_setup
   \      0x192   0x0004             MOVS     R4,R0
    253              if (status != PSA_SUCCESS) {
   \      0x194   0x2C00             CMP      R4,#+0
   \      0x196   0xD001             BEQ.N    ??sli_se_transparent_mac_sign_setup_20
    254                return status;
   \      0x198   0x0020             MOVS     R0,R4
   \      0x19A   0xE075             B.N      ??sli_se_transparent_mac_sign_setup_2
    255              }
    256          
    257              size_t keylen = psa_get_key_bits(attributes) / 8;
   \                     ??sli_se_transparent_mac_sign_setup_20: (+1)
   \      0x19C   0x9803             LDR      R0,[SP, #+12]
   \      0x19E   0x.... 0x....      BL       psa_get_key_bits
   \      0x1A2   0x08C0             LSRS     R0,R0,#+3
   \      0x1A4   0x9002             STR      R0,[SP, #+8]
    258              size_t blocklen
    259                = (hash_alg == PSA_ALG_SHA_384 || hash_alg == PSA_ALG_SHA_512) ? 128 : 64;
   \      0x1A6   0x....             LDR.N    R0,??DataTable3_6
   \      0x1A8   0x4287             CMP      R7,R0
   \      0x1AA   0xD002             BEQ.N    ??sli_se_transparent_mac_sign_setup_21
   \      0x1AC   0x....             LDR.N    R0,??DataTable3_7
   \      0x1AE   0x4287             CMP      R7,R0
   \      0x1B0   0xD102             BNE.N    ??sli_se_transparent_mac_sign_setup_22
   \                     ??sli_se_transparent_mac_sign_setup_21: (+1)
   \      0x1B2   0xF05F 0x0980      MOVS     R9,#+128
   \      0x1B6   0xE001             B.N      ??sli_se_transparent_mac_sign_setup_23
   \                     ??sli_se_transparent_mac_sign_setup_22: (+1)
   \      0x1B8   0xF05F 0x0940      MOVS     R9,#+64
    260          
    261              if (key_buffer_size < keylen) {
   \                     ??sli_se_transparent_mac_sign_setup_23: (+1)
   \      0x1BC   0x9804             LDR      R0,[SP, #+16]
   \      0x1BE   0x9902             LDR      R1,[SP, #+8]
   \      0x1C0   0x4288             CMP      R0,R1
   \      0x1C2   0xD202             BCS.N    ??sli_se_transparent_mac_sign_setup_24
    262                return PSA_ERROR_INVALID_ARGUMENT;
   \      0x1C4   0xF07F 0x0086      MVNS     R0,#+134
   \      0x1C8   0xE05E             B.N      ??sli_se_transparent_mac_sign_setup_2
    263              }
    264          
    265              // Reduce the key if larger than a block
    266              if (keylen > blocklen) {
   \                     ??sli_se_transparent_mac_sign_setup_24: (+1)
   \      0x1CA   0x9802             LDR      R0,[SP, #+8]
   \      0x1CC   0x4581             CMP      R9,R0
   \      0x1CE   0xD20F             BCS.N    ??sli_se_transparent_mac_sign_setup_25
    267                status = sli_se_transparent_hash_compute(
    268                  hash_alg,
    269                  key_buffer,
    270                  keylen,
    271                  operation->hmac.opad,
    272                  sizeof(operation->hmac.opad),
    273                  &keylen);
   \      0x1D0   0xA802             ADD      R0,SP,#+8
   \      0x1D2   0x9001             STR      R0,[SP, #+4]
   \      0x1D4   0x2080             MOVS     R0,#+128
   \      0x1D6   0x9000             STR      R0,[SP, #+0]
   \      0x1D8   0xF115 0x03DC      ADDS     R3,R5,#+220
   \      0x1DC   0x9A02             LDR      R2,[SP, #+8]
   \      0x1DE   0x0031             MOVS     R1,R6
   \      0x1E0   0x0038             MOVS     R0,R7
   \      0x1E2   0x.... 0x....      BL       sli_se_transparent_hash_compute
   \      0x1E6   0x0004             MOVS     R4,R0
    274                if (status != PSA_SUCCESS) {
   \      0x1E8   0x2C00             CMP      R4,#+0
   \      0x1EA   0xD00E             BEQ.N    ??sli_se_transparent_mac_sign_setup_26
    275                  return status;
   \      0x1EC   0x0020             MOVS     R0,R4
   \      0x1EE   0xE04B             B.N      ??sli_se_transparent_mac_sign_setup_2
    276                }
    277              } else if (keylen > 0) {
   \                     ??sli_se_transparent_mac_sign_setup_25: (+1)
   \      0x1F0   0x9802             LDR      R0,[SP, #+8]
   \      0x1F2   0x2800             CMP      R0,#+0
   \      0x1F4   0xD009             BEQ.N    ??sli_se_transparent_mac_sign_setup_26
    278                memcpy(operation->hmac.opad, key_buffer, keylen);
   \      0x1F6   0x9802             LDR      R0,[SP, #+8]
   \      0x1F8   0x9001             STR      R0,[SP, #+4]
   \      0x1FA   0x9600             STR      R6,[SP, #+0]
   \      0x1FC   0xF115 0x0BDC      ADDS     R11,R5,#+220
   \      0x200   0x9A01             LDR      R2,[SP, #+4]
   \      0x202   0x9900             LDR      R1,[SP, #+0]
   \      0x204   0x4658             MOV      R0,R11
   \      0x206   0x.... 0x....      BL       __aeabi_memcpy
    279              }
    280          
    281              // Calculate inner padding in opad buffer and start a multipart hash with it
    282              for (size_t i = 0; i < keylen; i++) {
   \                     ??sli_se_transparent_mac_sign_setup_26: (+1)
   \      0x20A   0x2000             MOVS     R0,#+0
   \                     ??sli_se_transparent_mac_sign_setup_27: (+1)
   \      0x20C   0x9902             LDR      R1,[SP, #+8]
   \      0x20E   0x4288             CMP      R0,R1
   \      0x210   0xD20B             BCS.N    ??sli_se_transparent_mac_sign_setup_28
    283                operation->hmac.opad[i] ^= 0x36;
   \      0x212   0xEB05 0x0100      ADD      R1,R5,R0
   \      0x216   0xF891 0x20DC      LDRB     R2,[R1, #+220]
   \      0x21A   0xF092 0x0236      EORS     R2,R2,#0x36
   \      0x21E   0xEB05 0x0100      ADD      R1,R5,R0
   \      0x222   0xF881 0x20DC      STRB     R2,[R1, #+220]
    284              }
   \      0x226   0x1C40             ADDS     R0,R0,#+1
   \      0x228   0xE7F0             B.N      ??sli_se_transparent_mac_sign_setup_27
    285              memset(&operation->hmac.opad[keylen], 0x36, blocklen - keylen);
   \                     ??sli_se_transparent_mac_sign_setup_28: (+1)
   \      0x22A   0x9802             LDR      R0,[SP, #+8]
   \      0x22C   0xEBB9 0x0000      SUBS     R0,R9,R0
   \      0x230   0x9001             STR      R0,[SP, #+4]
   \      0x232   0x2036             MOVS     R0,#+54
   \      0x234   0x9000             STR      R0,[SP, #+0]
   \      0x236   0x9802             LDR      R0,[SP, #+8]
   \      0x238   0x4428             ADD      R0,R5,R0
   \      0x23A   0xF110 0x0BDC      ADDS     R11,R0,#+220
   \      0x23E   0x9A00             LDR      R2,[SP, #+0]
   \      0x240   0x9901             LDR      R1,[SP, #+4]
   \      0x242   0x4658             MOV      R0,R11
   \      0x244   0x.... 0x....      BL       __aeabi_memset
    286          
    287              status = sli_se_transparent_hash_update(
    288                &operation->hmac.hash_ctx,
    289                operation->hmac.opad, blocklen);
   \      0x248   0x464A             MOV      R2,R9
   \      0x24A   0xF115 0x01DC      ADDS     R1,R5,#+220
   \      0x24E   0x1D28             ADDS     R0,R5,#+4
   \      0x250   0x.... 0x....      BL       sli_se_transparent_hash_update
   \      0x254   0x0001             MOVS     R1,R0
    290              if (status != PSA_SUCCESS) {
   \      0x256   0x2900             CMP      R1,#+0
   \      0x258   0xD001             BEQ.N    ??sli_se_transparent_mac_sign_setup_29
    291                return status;
   \      0x25A   0x0008             MOVS     R0,R1
   \      0x25C   0xE014             B.N      ??sli_se_transparent_mac_sign_setup_2
    292              }
    293          
    294              // Calculate outer padding and store it for finalisation
    295              for (size_t i = 0; i < blocklen; i++) {
   \                     ??sli_se_transparent_mac_sign_setup_29: (+1)
   \      0x25E   0x2000             MOVS     R0,#+0
   \                     ??sli_se_transparent_mac_sign_setup_30: (+1)
   \      0x260   0x4548             CMP      R0,R9
   \      0x262   0xD20B             BCS.N    ??sli_se_transparent_mac_sign_setup_31
    296                operation->hmac.opad[i] ^= 0x36 ^ 0x5C;
   \      0x264   0xEB05 0x0200      ADD      R2,R5,R0
   \      0x268   0xF892 0x20DC      LDRB     R2,[R2, #+220]
   \      0x26C   0xF092 0x026A      EORS     R2,R2,#0x6A
   \      0x270   0xEB05 0x0300      ADD      R3,R5,R0
   \      0x274   0xF883 0x20DC      STRB     R2,[R3, #+220]
    297              }
   \      0x278   0x1C40             ADDS     R0,R0,#+1
   \      0x27A   0xE7F1             B.N      ??sli_se_transparent_mac_sign_setup_30
    298          
    299              operation->hmac.alg = alg;
   \                     ??sli_se_transparent_mac_sign_setup_31: (+1)
   \      0x27C   0xF8C5 0xA000      STR      R10,[R5, #+0]
    300              return PSA_SUCCESS;
   \      0x280   0x2000             MOVS     R0,#+0
   \      0x282   0xE001             B.N      ??sli_se_transparent_mac_sign_setup_2
    301            }
    302            #endif   // SLI_PSA_DRIVER_FEATURE_HMAC
    303          
    304            #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    305            status = sli_se_driver_mac_sign_setup(&(operation->cipher_mac.operation),
    306                                                  attributes,
    307                                                  alg);
    308            if (status != PSA_SUCCESS) {
    309              return status;
    310            }
    311          
    312            operation->cipher_mac.key_len = psa_get_key_bits(attributes) / 8;
    313            switch (operation->cipher_mac.key_len) {
    314              case 16:
    315                if (key_buffer_size < 16) {
    316                  return PSA_ERROR_INVALID_ARGUMENT;
    317                }
    318                memcpy(operation->cipher_mac.key, key_buffer, 16);
    319                break;
    320              case 24:
    321                if (key_buffer_size < 24) {
    322                  return PSA_ERROR_INVALID_ARGUMENT;
    323                }
    324                memcpy(operation->cipher_mac.key, key_buffer, 24);
    325                break;
    326              case 32:
    327                if (key_buffer_size < 32) {
    328                  return PSA_ERROR_INVALID_ARGUMENT;
    329                }
    330                memcpy(operation->cipher_mac.key, key_buffer, 32);
    331                break;
    332              default:
    333                return PSA_ERROR_INVALID_ARGUMENT;
    334            }
    335          
    336            return PSA_SUCCESS;
    337            #else   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    338            return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_transparent_mac_sign_setup_3: (+1)
   \      0x284   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??sli_se_transparent_mac_sign_setup_2: (+1)
   \      0x288   0xB005             ADD      SP,SP,#+20
   \      0x28A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    339            #endif   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    340          
    341            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    342          
    343            (void)operation;
    344            (void)attributes;
    345            (void)key_buffer;
    346            (void)key_buffer_size;
    347            (void)alg;
    348          
    349            return PSA_ERROR_NOT_SUPPORTED;
    350          
    351            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    352          }
    353          

   \                                 In section .text, align 2, keep-with-next
    354          psa_status_t sli_se_transparent_mac_verify_setup(
    355            sli_se_transparent_mac_operation_t *operation,
    356            const psa_key_attributes_t *attributes,
    357            const uint8_t *key_buffer,
    358            size_t key_buffer_size,
    359            psa_algorithm_t alg)
    360          {
   \                     sli_se_transparent_mac_verify_setup: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
    361            // Since the PSA Crypto core exposes the verify functionality of the drivers
    362            // without actually implementing the fallback to 'sign' when the driver
    363            // doesn't support verify, we need to do this ourselves for the time being.
    364            return sli_se_transparent_mac_sign_setup(operation,
    365                                                     attributes,
    366                                                     key_buffer,
    367                                                     key_buffer_size,
    368                                                     alg);
   \        0xA   0x9806             LDR      R0,[SP, #+24]
   \        0xC   0x9000             STR      R0,[SP, #+0]
   \        0xE   0x003B             MOVS     R3,R7
   \       0x10   0x0032             MOVS     R2,R6
   \       0x12   0x0029             MOVS     R1,R5
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       sli_se_transparent_mac_sign_setup
   \       0x1A   0xBDF2             POP      {R1,R4-R7,PC}
    369          }
    370          

   \                                 In section .text, align 2, keep-with-next
    371          psa_status_t sli_se_transparent_mac_update(
    372            sli_se_transparent_mac_operation_t *operation,
    373            const uint8_t *input,
    374            size_t input_length)
    375          {
   \                     sli_se_transparent_mac_update: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    376            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    377          
    378            if (operation == NULL
    379                || (input == NULL && input_length > 0)) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD003             BEQ.N    ??sli_se_transparent_mac_update_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD104             BNE.N    ??sli_se_transparent_mac_update_1
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD002             BEQ.N    ??sli_se_transparent_mac_update_1
    380              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_transparent_mac_update_0: (+1)
   \       0x14   0xF07F 0x0086      MVNS     R0,#+134
   \       0x18   0xE00D             B.N      ??sli_se_transparent_mac_update_2
    381            }
    382          
    383            #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
    384            if (PSA_ALG_IS_HMAC(operation->hmac.alg)) {
   \                     ??sli_se_transparent_mac_update_1: (+1)
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x....             LDR.N    R0,??DataTable3
   \       0x1E   0x4001             ANDS     R1,R0,R1
   \       0x20   0xF1B1 0x7F60      CMP      R1,#+58720256
   \       0x24   0xD105             BNE.N    ??sli_se_transparent_mac_update_3
    385              return sli_se_transparent_hash_update(
    386                &operation->hmac.hash_ctx,
    387                input,
    388                input_length);
   \       0x26   0x0032             MOVS     R2,R6
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0x1D20             ADDS     R0,R4,#+4
   \       0x2C   0x.... 0x....      BL       sli_se_transparent_hash_update
   \       0x30   0xE001             B.N      ??sli_se_transparent_mac_update_2
    389            }
    390            #endif   // SLI_PSA_DRIVER_FEATURE_HMAC
    391          
    392            #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    393            // Ephemeral contexts
    394            sl_se_key_descriptor_t key_desc = { 0 };
    395          
    396            psa_status_t psa_status
    397              = sli_se_transparent_driver_symmetric_key_from_context(&key_desc,
    398                                                                     operation);
    399            if (psa_status != PSA_SUCCESS) {
    400              return psa_status;
    401            }
    402          
    403            return sli_se_driver_mac_update(&(operation->cipher_mac.operation),
    404                                            &key_desc,
    405                                            input,
    406                                            input_length);
    407            #else   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    408            return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_transparent_mac_update_3: (+1)
   \       0x32   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??sli_se_transparent_mac_update_2: (+1)
   \       0x36   0xBD70             POP      {R4-R6,PC}
    409            #endif   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    410          
    411            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    412          
    413            (void)operation;
    414            (void)input;
    415            (void)input_length;
    416          
    417            return PSA_ERROR_NOT_SUPPORTED;
    418          
    419            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    420          }
    421          

   \                                 In section .text, align 2, keep-with-next
    422          psa_status_t sli_se_transparent_mac_sign_finish(
    423            sli_se_transparent_mac_operation_t *operation,
    424            uint8_t *mac,
    425            size_t mac_size,
    426            size_t *mac_length)
    427          {
   \                     sli_se_transparent_mac_sign_finish: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB0B4             SUB      SP,SP,#+208
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x001D             MOVS     R5,R3
    428            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    429          
    430            if (operation == NULL
    431                || mac == NULL
    432                || mac_size == 0
    433                || mac_length == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD007             BEQ.N    ??sli_se_transparent_mac_sign_finish_0
   \        0xE   0x9835             LDR      R0,[SP, #+212]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD004             BEQ.N    ??sli_se_transparent_mac_sign_finish_0
   \       0x14   0x9836             LDR      R0,[SP, #+216]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??sli_se_transparent_mac_sign_finish_0
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD102             BNE.N    ??sli_se_transparent_mac_sign_finish_1
    434              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_transparent_mac_sign_finish_0: (+1)
   \       0x1E   0xF07F 0x0086      MVNS     R0,#+134
   \       0x22   0xE07F             B.N      ??sli_se_transparent_mac_sign_finish_2
    435            }
    436          
    437            #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
    438            if (PSA_ALG_IS_HMAC(operation->hmac.alg)) {
   \                     ??sli_se_transparent_mac_sign_finish_1: (+1)
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x....             LDR.N    R0,??DataTable3
   \       0x28   0x4001             ANDS     R1,R0,R1
   \       0x2A   0xF1B1 0x7F60      CMP      R1,#+58720256
   \       0x2E   0xD177             BNE.N    ??sli_se_transparent_mac_sign_finish_3
    439              uint8_t buffer[sizeof(operation->hmac.opad)
    440                             + (sizeof(operation->hmac.opad) / 2)];
    441              size_t olen = 0;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x9002             STR      R0,[SP, #+8]
    442              psa_algorithm_t hash_alg = PSA_ALG_HMAC_GET_HASH(operation->hmac.alg);
   \       0x34   0xF894 0x9000      LDRB     R9,[R4, #+0]
   \       0x38   0xF009 0x09FF      AND      R9,R9,#0xFF
   \       0x3C   0xF059 0x7900      ORRS     R9,R9,#0x2000000
    443          
    444              #if !defined(SLI_PSA_DRIVER_FEATURE_HASH_STATE_64)
    445              if (hash_alg == PSA_ALG_SHA_384 || hash_alg == PSA_ALG_SHA_512) {
   \       0x40   0x....             LDR.N    R0,??DataTable3_6
   \       0x42   0x4581             CMP      R9,R0
   \       0x44   0xD002             BEQ.N    ??sli_se_transparent_mac_sign_finish_4
   \       0x46   0x....             LDR.N    R0,??DataTable3_7
   \       0x48   0x4581             CMP      R9,R0
   \       0x4A   0xD102             BNE.N    ??sli_se_transparent_mac_sign_finish_5
    446                // Could only reach here if the programmer has made some errors. Take the
    447                // safe approach of checking just in case, in order to avoid certain
    448                // buffer overflows.
    449                return PSA_ERROR_BAD_STATE;
   \                     ??sli_se_transparent_mac_sign_finish_4: (+1)
   \       0x4C   0xF07F 0x0088      MVNS     R0,#+136
   \       0x50   0xE068             B.N      ??sli_se_transparent_mac_sign_finish_2
    450              }
    451              size_t blocklen = 64;
   \                     ??sli_se_transparent_mac_sign_finish_5: (+1)
   \       0x52   0xF05F 0x0840      MOVS     R8,#+64
    452              #else
    453              size_t blocklen
    454                = (hash_alg == PSA_ALG_SHA_384 || hash_alg == PSA_ALG_SHA_512) ? 128 : 64;
    455              #endif
    456          
    457              // Construct outer hash input from opad and hash result
    458              memcpy(buffer, operation->hmac.opad, blocklen);
   \       0x56   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x5A   0xF114 0x0BDC      ADDS     R11,R4,#+220
   \       0x5E   0xAE04             ADD      R6,SP,#+16
   \       0x60   0x9A00             LDR      R2,[SP, #+0]
   \       0x62   0x4659             MOV      R1,R11
   \       0x64   0x0030             MOVS     R0,R6
   \       0x66   0x.... 0x....      BL       __aeabi_memcpy
    459              memset(operation->hmac.opad, 0, sizeof(operation->hmac.opad));
   \       0x6A   0x2680             MOVS     R6,#+128
   \       0x6C   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x70   0xF114 0x07DC      ADDS     R7,R4,#+220
   \       0x74   0x4652             MOV      R2,R10
   \       0x76   0x0031             MOVS     R1,R6
   \       0x78   0x0038             MOVS     R0,R7
   \       0x7A   0x.... 0x....      BL       __aeabi_memset
    460          
    461              psa_status_t status = sli_se_transparent_hash_finish(
    462                &operation->hmac.hash_ctx,
    463                &buffer[blocklen],
    464                sizeof(buffer) - blocklen,
    465                &olen);
   \       0x7E   0xAB02             ADD      R3,SP,#+8
   \       0x80   0xF1D8 0x02C0      RSBS     R2,R8,#+192
   \       0x84   0xA804             ADD      R0,SP,#+16
   \       0x86   0xEB00 0x0108      ADD      R1,R0,R8
   \       0x8A   0x1D20             ADDS     R0,R4,#+4
   \       0x8C   0x.... 0x....      BL       sli_se_transparent_hash_finish
   \       0x90   0x0007             MOVS     R7,R0
    466              if (status != PSA_SUCCESS) {
   \       0x92   0x2F00             CMP      R7,#+0
   \       0x94   0xD001             BEQ.N    ??sli_se_transparent_mac_sign_finish_6
    467                return status;
   \       0x96   0x0038             MOVS     R0,R7
   \       0x98   0xE044             B.N      ??sli_se_transparent_mac_sign_finish_2
    468              }
    469          
    470              // Calculate HMAC
    471              status = sli_se_transparent_hash_compute(
    472                hash_alg,
    473                buffer,
    474                blocklen + olen,
    475                buffer,
    476                sizeof(buffer),
    477                &olen);
   \                     ??sli_se_transparent_mac_sign_finish_6: (+1)
   \       0x9A   0xA802             ADD      R0,SP,#+8
   \       0x9C   0x9001             STR      R0,[SP, #+4]
   \       0x9E   0x20C0             MOVS     R0,#+192
   \       0xA0   0x9000             STR      R0,[SP, #+0]
   \       0xA2   0xAB04             ADD      R3,SP,#+16
   \       0xA4   0x9A02             LDR      R2,[SP, #+8]
   \       0xA6   0xEB12 0x0208      ADDS     R2,R2,R8
   \       0xAA   0xA904             ADD      R1,SP,#+16
   \       0xAC   0x4648             MOV      R0,R9
   \       0xAE   0x.... 0x....      BL       sli_se_transparent_hash_compute
   \       0xB2   0x0006             MOVS     R6,R0
    478              if (status != PSA_SUCCESS) {
   \       0xB4   0x2E00             CMP      R6,#+0
   \       0xB6   0xD001             BEQ.N    ??sli_se_transparent_mac_sign_finish_7
    479                return status;
   \       0xB8   0x0030             MOVS     R0,R6
   \       0xBA   0xE033             B.N      ??sli_se_transparent_mac_sign_finish_2
    480              }
    481          
    482              // Copy out a potentially truncated HMAC
    483              size_t requested_length = PSA_MAC_TRUNCATED_LENGTH(operation->hmac.alg);
   \                     ??sli_se_transparent_mac_sign_finish_7: (+1)
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0xF3C0 0x4005      UBFX     R0,R0,#+16,#+6
   \       0xC2   0x9000             STR      R0,[SP, #+0]
    484              if (requested_length == 0) {
   \       0xC4   0x9800             LDR      R0,[SP, #+0]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD101             BNE.N    ??sli_se_transparent_mac_sign_finish_8
    485                requested_length = olen;
   \       0xCA   0x9802             LDR      R0,[SP, #+8]
   \       0xCC   0x9000             STR      R0,[SP, #+0]
    486              }
    487          
    488              if (requested_length > mac_size) {
   \                     ??sli_se_transparent_mac_sign_finish_8: (+1)
   \       0xCE   0x9836             LDR      R0,[SP, #+216]
   \       0xD0   0x9900             LDR      R1,[SP, #+0]
   \       0xD2   0x4288             CMP      R0,R1
   \       0xD4   0xD20C             BCS.N    ??sli_se_transparent_mac_sign_finish_9
    489                memset(buffer, 0, sizeof(buffer));
   \       0xD6   0xF05F 0x0BC0      MOVS     R11,#+192
   \       0xDA   0x2700             MOVS     R7,#+0
   \       0xDC   0xF10D 0x0A10      ADD      R10,SP,#+16
   \       0xE0   0x003A             MOVS     R2,R7
   \       0xE2   0x4659             MOV      R1,R11
   \       0xE4   0x4650             MOV      R0,R10
   \       0xE6   0x.... 0x....      BL       __aeabi_memset
    490                return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0xEA   0xF07F 0x0089      MVNS     R0,#+137
   \       0xEE   0xE019             B.N      ??sli_se_transparent_mac_sign_finish_2
    491              }
    492          
    493              memcpy(mac, buffer, requested_length);
   \                     ??sli_se_transparent_mac_sign_finish_9: (+1)
   \       0xF0   0x9800             LDR      R0,[SP, #+0]
   \       0xF2   0x9003             STR      R0,[SP, #+12]
   \       0xF4   0xA804             ADD      R0,SP,#+16
   \       0xF6   0x9001             STR      R0,[SP, #+4]
   \       0xF8   0x9F35             LDR      R7,[SP, #+212]
   \       0xFA   0x9A03             LDR      R2,[SP, #+12]
   \       0xFC   0x9901             LDR      R1,[SP, #+4]
   \       0xFE   0x0038             MOVS     R0,R7
   \      0x100   0x.... 0x....      BL       __aeabi_memcpy
    494              *mac_length = requested_length;
   \      0x104   0x9800             LDR      R0,[SP, #+0]
   \      0x106   0x6028             STR      R0,[R5, #+0]
    495              memset(buffer, 0, sizeof(buffer));
   \      0x108   0x27C0             MOVS     R7,#+192
   \      0x10A   0xF05F 0x0A00      MOVS     R10,#+0
   \      0x10E   0xF10D 0x0B10      ADD      R11,SP,#+16
   \      0x112   0x4652             MOV      R2,R10
   \      0x114   0x0039             MOVS     R1,R7
   \      0x116   0x4658             MOV      R0,R11
   \      0x118   0x.... 0x....      BL       __aeabi_memset
    496              return PSA_SUCCESS;
   \      0x11C   0x2000             MOVS     R0,#+0
   \      0x11E   0xE001             B.N      ??sli_se_transparent_mac_sign_finish_2
    497            }
    498            #endif   // SLI_PSA_DRIVER_FEATURE_HMAC
    499          
    500            #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    501            // Ephemeral contexts
    502            sl_se_key_descriptor_t key_desc = { 0 };
    503          
    504            psa_status_t status = sli_se_transparent_driver_symmetric_key_from_context(
    505              &key_desc,
    506              operation);
    507            if (status != PSA_SUCCESS) {
    508              return status;
    509            }
    510          
    511            return sli_se_driver_mac_sign_finish(&(operation->cipher_mac.operation),
    512                                                 &key_desc,
    513                                                 mac,
    514                                                 mac_size,
    515                                                 mac_length);
    516            #else   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    517            return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_transparent_mac_sign_finish_3: (+1)
   \      0x120   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??sli_se_transparent_mac_sign_finish_2: (+1)
   \      0x124   0xB037             ADD      SP,SP,#+220
   \      0x126   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    518            #endif   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    519          
    520            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    521          
    522            (void)operation;
    523            (void)mac;
    524            (void)mac_size;
    525            (void)mac_length;
    526          
    527            return PSA_ERROR_NOT_SUPPORTED;
    528          
    529            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    530          }
    531          

   \                                 In section .text, align 2, keep-with-next
    532          psa_status_t sli_se_transparent_mac_verify_finish(
    533            sli_se_transparent_mac_operation_t *operation,
    534            const uint8_t *mac,
    535            size_t mac_length)
    536          {
   \                     sli_se_transparent_mac_verify_finish: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x2120             MOVS     R1,#+32
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0xA801             ADD      R0,SP,#+4
   \       0x12   0x.... 0x....      BL       __aeabi_memset
    537            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    538          
    539            // Since the PSA Crypto core exposes the verify functionality of the drivers
    540            // without actually implementing the fallback to 'sign' when the driver
    541            // doesn't support verify, we need to do this ourselves for the time being.
    542            uint8_t calculated_mac[PSA_MAC_MAX_SIZE] = { 0 };
    543            size_t calculated_length = PSA_MAC_MAX_SIZE;
   \       0x16   0x2020             MOVS     R0,#+32
   \       0x18   0x9000             STR      R0,[SP, #+0]
    544          
    545            psa_status_t status = sli_se_transparent_mac_sign_finish(
    546              operation,
    547              calculated_mac, sizeof(calculated_mac), &calculated_length);
   \       0x1A   0x466B             MOV      R3,SP
   \       0x1C   0x2220             MOVS     R2,#+32
   \       0x1E   0xA901             ADD      R1,SP,#+4
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0x.... 0x....      BL       sli_se_transparent_mac_sign_finish
   \       0x26   0x0004             MOVS     R4,R0
    548            if (status != PSA_SUCCESS) {
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD001             BEQ.N    ??sli_se_transparent_mac_verify_finish_0
    549              return status;
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0xE01B             B.N      ??sli_se_transparent_mac_verify_finish_1
    550            }
    551          
    552            if (mac_length > sizeof(calculated_mac)) {
   \                     ??sli_se_transparent_mac_verify_finish_0: (+1)
   \       0x30   0x2F21             CMP      R7,#+33
   \       0x32   0xD302             BCC.N    ??sli_se_transparent_mac_verify_finish_2
    553              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x34   0xF07F 0x0086      MVNS     R0,#+134
   \       0x38   0xE016             B.N      ??sli_se_transparent_mac_verify_finish_1
    554            }
    555          
    556            if (sli_psa_safer_memcmp(mac, calculated_mac, mac_length) != 0) {
   \                     ??sli_se_transparent_mac_verify_finish_2: (+1)
   \       0x3A   0x003A             MOVS     R2,R7
   \       0x3C   0xA901             ADD      R1,SP,#+4
   \       0x3E   0x0030             MOVS     R0,R6
   \       0x40   0x.... 0x....      BL       sli_psa_safer_memcmp
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD002             BEQ.N    ??sli_se_transparent_mac_verify_finish_3
    557              status = PSA_ERROR_INVALID_SIGNATURE;
   \       0x48   0xF07F 0x0894      MVNS     R8,#+148
   \       0x4C   0xE001             B.N      ??sli_se_transparent_mac_verify_finish_4
    558            } else {
    559              status = PSA_SUCCESS;
   \                     ??sli_se_transparent_mac_verify_finish_3: (+1)
   \       0x4E   0xF05F 0x0800      MOVS     R8,#+0
    560            }
    561          
    562            memset(calculated_mac, 0, sizeof(calculated_mac));
   \                     ??sli_se_transparent_mac_verify_finish_4: (+1)
   \       0x52   0xF05F 0x0A20      MOVS     R10,#+32
   \       0x56   0x2400             MOVS     R4,#+0
   \       0x58   0xF10D 0x0904      ADD      R9,SP,#+4
   \       0x5C   0x0022             MOVS     R2,R4
   \       0x5E   0x4651             MOV      R1,R10
   \       0x60   0x4648             MOV      R0,R9
   \       0x62   0x.... 0x....      BL       __aeabi_memset
    563            return status;
   \       0x66   0x4640             MOV      R0,R8
   \                     ??sli_se_transparent_mac_verify_finish_1: (+1)
   \       0x68   0xB00A             ADD      SP,SP,#+40
   \       0x6A   0xE8BD 0x87F0      POP      {R4-R10,PC}
    564          
    565            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    566          
    567            (void)operation;
    568            (void)mac;
    569            (void)mac_length;
    570          
    571            return PSA_ERROR_NOT_SUPPORTED;
    572            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    573          }
    574          

   \                                 In section .text, align 2, keep-with-next
    575          psa_status_t sli_se_transparent_mac_abort(
    576            sli_se_transparent_mac_operation_t *operation)
    577          {
   \                     sli_se_transparent_mac_abort: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    578            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    579          
    580            // There's no state in hardware that we need to preserve, so zeroing out the
    581            // context suffices.
    582            if (operation == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD102             BNE.N    ??sli_se_transparent_mac_abort_0
    583              return PSA_ERROR_INVALID_ARGUMENT;
   \        0x8   0xF07F 0x0086      MVNS     R0,#+134
   \        0xC   0xE009             B.N      ??sli_se_transparent_mac_abort_1
    584            }
    585          
    586            memset(operation, 0, sizeof(*operation));
   \                     ??sli_se_transparent_mac_abort_0: (+1)
   \        0xE   0xF44F 0x77AE      MOV      R7,#+348
   \       0x12   0x2500             MOVS     R5,#+0
   \       0x14   0x0026             MOVS     R6,R4
   \       0x16   0x002A             MOVS     R2,R5
   \       0x18   0x0039             MOVS     R1,R7
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x.... 0x....      BL       __aeabi_memset
    587          
    588            return PSA_SUCCESS;
   \       0x20   0x2000             MOVS     R0,#+0
   \                     ??sli_se_transparent_mac_abort_1: (+1)
   \       0x22   0xBDF2             POP      {R1,R4-R7,PC}
    589          
    590            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    591          
    592            (void)operation;
    593          
    594            return PSA_ERROR_NOT_SUPPORTED;
    595            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    596          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x7FC0'0000        DC32     0x7fc00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x0200'0003        DC32     0x2000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x0200'0004        DC32     0x2000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x0200'0005        DC32     0x2000005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x0200'0008        DC32     0x2000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x0200'0009        DC32     0x2000009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x0200'000A        DC32     0x200000a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x0200'000B        DC32     0x200000b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0x0200'000C        DC32     0x200000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \        0x0   0x0200'000D        DC32     0x200000d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \        0x0   0x0200'0010        DC32     0x2000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \        0x0   0x0200'0011        DC32     0x2000011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \        0x0   0x0200'0012        DC32     0x2000012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \        0x0   0x0200'0013        DC32     0x2000013
    597          
    598          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   psa_get_key_bits
       0   psa_get_key_type
      12   sli_psa_safer_memcmp
      24   sli_se_transparent_driver_symmetric_key_from_psa
        24   -> psa_get_key_bits
        24   -> psa_get_key_type
      24   sli_se_transparent_mac_abort
        24   -> __aeabi_memset
      80   sli_se_transparent_mac_compute
        80   -> __aeabi_memclr4
        80   -> sli_se_driver_mac_compute
        80   -> sli_se_transparent_driver_symmetric_key_from_psa
     256   sli_se_transparent_mac_sign_finish
       256   -> __aeabi_memcpy
       256   -> __aeabi_memset
       256   -> sli_se_transparent_hash_compute
       256   -> sli_se_transparent_hash_finish
      56   sli_se_transparent_mac_sign_setup
        56   -> __aeabi_memcpy
        56   -> __aeabi_memset
        56   -> psa_get_key_bits
        56   -> psa_get_key_type
        56   -> sli_se_transparent_hash_compute
        56   -> sli_se_transparent_hash_setup
        56   -> sli_se_transparent_hash_update
      16   sli_se_transparent_mac_update
        16   -> sli_se_transparent_hash_update
      72   sli_se_transparent_mac_verify_finish
        72   -> __aeabi_memset
        72   -> sli_psa_safer_memcmp
        72   -> sli_se_transparent_mac_sign_finish
      24   sli_se_transparent_mac_verify_setup
        24   -> sli_se_transparent_mac_sign_setup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      32  ?_0
       4  psa_get_key_bits
       4  psa_get_key_type
      30  sli_psa_safer_memcmp
      78  sli_se_transparent_driver_symmetric_key_from_psa
      36  sli_se_transparent_mac_abort
      96  sli_se_transparent_mac_compute
     298  sli_se_transparent_mac_sign_finish
     654  sli_se_transparent_mac_sign_setup
      56  sli_se_transparent_mac_update
     110  sli_se_transparent_mac_verify_finish
      28  sli_se_transparent_mac_verify_setup

 
    32 bytes in section .rodata
 1'450 bytes in section .text
 
 1'450 bytes of CODE  memory
    32 bytes of CONST memory

Errors: none
Warnings: none
