###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:32
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_signature.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_driver_signature.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_signature.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_driver_signature.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_1701372114642889758.dir\sli_se_driver_signature.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_1701372114642889758.dir\sli_se_driver_signature.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_signature.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Secure Engine Signature Driver functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "psa/crypto.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint16_t psa_get_key_type(psa_key_attributes_t const *)
   \                     psa_get_key_type: (+1)
   \        0x0   0x8800             LDRH     R0,[R0, #+0]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t psa_get_key_bits(psa_key_attributes_t const *)
   \                     psa_get_key_bits: (+1)
   \        0x0   0x8840             LDRH     R0,[R0, #+2]
   \        0x2   0x4770             BX       LR
     36          
     37          #include "sli_psa_driver_common.h"  // sli_psa_zeroize()
     38          #include "sli_se_transparent_types.h"
     39          #include "sli_se_transparent_functions.h"
     40          #include "sli_se_driver_key_management.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void sli_se_key_descriptor_set_plaintext(struct <unnamed>#128 *, uint8_t const *, size_t)
   \                     sli_se_key_descriptor_set_plaintext: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x60C3             STR      R3,[R0, #+12]
   \        0x4   0x6101             STR      R1,[R0, #+16]
   \        0x6   0x1CD3             ADDS     R3,R2,#+3
   \        0x8   0x089B             LSRS     R3,R3,#+2
   \        0xA   0x009B             LSLS     R3,R3,#+2
   \        0xC   0x6143             STR      R3,[R0, #+20]
   \        0xE   0x4770             BX       LR
     41          #include "sli_se_version_dependencies.h"
     42          
     43          #include "sl_se_manager.h"
     44          #include "sli_se_manager_internal.h"
     45          #include "sl_se_manager_signature.h"
     46          
     47          #include <string.h>
     48          
     49          // -----------------------------------------------------------------------------
     50          // Static functions
     51          
     52          // -------------------------------------
     53          // Helpers
     54          
     55          #if defined(SLI_PSA_DRIVER_FEATURE_SIGNATURE)
     56          
     57          /**
     58           * @brief
     59           *   Validate that the curve and algorithm combination is supported by hardware
     60           */

   \                                 In section .text, align 2, keep-with-next
     61          static psa_status_t check_curve_availability(
     62            const psa_key_attributes_t *attributes,
     63            psa_algorithm_t alg)
     64          {
   \                     check_curve_availability: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
     65            psa_key_type_t key_type = psa_get_key_type(attributes);
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       psa_get_key_type
   \        0xC   0x0006             MOVS     R6,R0
     66            psa_ecc_family_t curvetype = PSA_KEY_TYPE_ECC_GET_FAMILY(key_type);
   \        0xE   0x0031             MOVS     R1,R6
   \       0x10   0xB289             UXTH     R1,R1
   \       0x12   0x....             LDR.N    R0,??DataTable2
   \       0x14   0x4001             ANDS     R1,R0,R1
   \       0x16   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x1A   0xD101             BNE.N    ??check_curve_availability_0
   \       0x1C   0x0037             MOVS     R7,R6
   \       0x1E   0xE000             B.N      ??check_curve_availability_1
   \                     ??check_curve_availability_0: (+1)
   \       0x20   0x2700             MOVS     R7,#+0
     67          
     68            if (PSA_ALG_IS_RSA_PSS(alg) || PSA_ALG_IS_RSA_PKCS1V15_SIGN(alg)) {
   \                     ??check_curve_availability_1: (+1)
   \       0x22   0x0A29             LSRS     R1,R5,#+8
   \       0x24   0x0209             LSLS     R1,R1,#+8
   \       0x26   0x....             LDR.N    R0,??DataTable2_1
   \       0x28   0x4281             CMP      R1,R0
   \       0x2A   0xD009             BEQ.N    ??check_curve_availability_2
   \       0x2C   0x0A29             LSRS     R1,R5,#+8
   \       0x2E   0x0209             LSLS     R1,R1,#+8
   \       0x30   0x....             LDR.N    R0,??DataTable2_2
   \       0x32   0x4281             CMP      R1,R0
   \       0x34   0xD004             BEQ.N    ??check_curve_availability_2
   \       0x36   0x0A29             LSRS     R1,R5,#+8
   \       0x38   0x0209             LSLS     R1,R1,#+8
   \       0x3A   0x....             LDR.N    R0,??DataTable2_3
   \       0x3C   0x4281             CMP      R1,R0
   \       0x3E   0xD102             BNE.N    ??check_curve_availability_3
     69              // We shouldn't have a RSA-type alg for a ECC key.
     70              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??check_curve_availability_2: (+1)
   \       0x40   0xF07F 0x0086      MVNS     R0,#+134
   \       0x44   0xE027             B.N      ??check_curve_availability_4
     71            }
     72          
     73            #if defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
     74            if (curvetype == PSA_ECC_FAMILY_SECP_R1) {
   \                     ??check_curve_availability_3: (+1)
   \       0x46   0x0038             MOVS     R0,R7
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0x2812             CMP      R0,#+18
   \       0x4C   0xD112             BNE.N    ??check_curve_availability_5
     75              switch (psa_get_key_bits(attributes)) {
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       psa_get_key_bits
   \       0x54   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x58   0xD109             BNE.N    ??check_curve_availability_6
     76                #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
     77                case 192:     // Intentional
     78                #endif
     79                #if defined(SLI_PSA_DRIVER_FEATURE_P224R1)
     80                case 224:     // Intentional
     81                #endif
     82                #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)
     83                case 256:     // Intentional
     84                #endif
     85                #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
     86                case 384:     // Intentional
     87                #endif
     88                #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
     89                case 521:
     90                #endif
     91                // Only randomized ECDSA is supported on secp-r1 curves
     92                if (!PSA_ALG_IS_RANDOMIZED_ECDSA(alg)) {
   \       0x5A   0x0A28             LSRS     R0,R5,#+8
   \       0x5C   0x0200             LSLS     R0,R0,#+8
   \       0x5E   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x62   0xD002             BEQ.N    ??check_curve_availability_7
     93                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x64   0xF07F 0x0085      MVNS     R0,#+133
   \       0x68   0xE015             B.N      ??check_curve_availability_4
     94                }
     95                break;     // This break catches all the supported curves
     96                default:
     97                  return PSA_ERROR_NOT_SUPPORTED;
     98              }
     99            } else if (curvetype == PSA_ECC_FAMILY_SECP_K1) {
    100              // Only randomized ECDSA is supported on secp-k1 curves
    101              if (!PSA_ALG_IS_RANDOMIZED_ECDSA(alg)) {
    102                return PSA_ERROR_NOT_SUPPORTED;
    103              }
    104              // TODO: introduce custom domains to enable secpxxxk1
    105              return PSA_ERROR_NOT_SUPPORTED;
    106            } else
    107            #endif // SLI_PSA_DRIVER_FEATURE_ECDSA
    108          
    109            #if defined(SLI_PSA_DRIVER_FEATURE_EDDSA)
    110            if (curvetype == PSA_ECC_FAMILY_TWISTED_EDWARDS) {
    111              switch (psa_get_key_bits(attributes)) {
    112                #if defined(SLI_PSA_DRIVER_FEATURE_EDWARDS25519)
    113                case 255:
    114                  // Only Ed25519 is supported (and only in context of EdDSA)
    115                  if (alg != PSA_ALG_PURE_EDDSA) {
    116                    return PSA_ERROR_NOT_SUPPORTED;
    117                  }
    118                  break;
    119                #endif   // SLI_PSA_DRIVER_FEATURE_EDWARDS25519
    120                default:
    121                  return PSA_ERROR_NOT_SUPPORTED;
    122              }
    123            } else
    124            #endif // SLI_PSA_DRIVER_FEATURE_EDDSA
    125          
    126            {
    127              return PSA_ERROR_NOT_SUPPORTED;
    128            }
    129          
    130            return PSA_SUCCESS;
   \                     ??check_curve_availability_7: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xE013             B.N      ??check_curve_availability_4
   \                     ??check_curve_availability_6: (+1)
   \       0x6E   0xF07F 0x0085      MVNS     R0,#+133
   \       0x72   0xE010             B.N      ??check_curve_availability_4
   \                     ??check_curve_availability_5: (+1)
   \       0x74   0x0038             MOVS     R0,R7
   \       0x76   0xB2C0             UXTB     R0,R0
   \       0x78   0x2817             CMP      R0,#+23
   \       0x7A   0xD10A             BNE.N    ??check_curve_availability_8
   \       0x7C   0x0A28             LSRS     R0,R5,#+8
   \       0x7E   0x0200             LSLS     R0,R0,#+8
   \       0x80   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x84   0xD002             BEQ.N    ??check_curve_availability_9
   \       0x86   0xF07F 0x0085      MVNS     R0,#+133
   \       0x8A   0xE004             B.N      ??check_curve_availability_4
   \                     ??check_curve_availability_9: (+1)
   \       0x8C   0xF07F 0x0085      MVNS     R0,#+133
   \       0x90   0xE001             B.N      ??check_curve_availability_4
   \                     ??check_curve_availability_8: (+1)
   \       0x92   0xF07F 0x0085      MVNS     R0,#+133
   \                     ??check_curve_availability_4: (+1)
   \       0x96   0xBDF2             POP      {R1,R4-R7,PC}
    131          }
    132          

   \                                 In section .text, align 2, keep-with-next
    133          static sl_se_hash_type_t get_hash_for_algorithm(psa_algorithm_t alg)
    134          {
   \                     get_hash_for_algorithm: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    135            #if defined(SLI_PSA_DRIVER_FEATURE_EDDSA)
    136            if (alg == PSA_ALG_PURE_EDDSA) {
    137              // The hash alg parameter is ignored for EdDSA, as it is decided uniqely by
    138              // the alorithm. Return magic value which isn't SL_SE_HASH_NONE.
    139              return (sl_se_hash_type_t)255;
    140            }
    141            #endif // SLI_PSA_DRIVER_FEATURE_EDDSA
    142          
    143            switch (PSA_ALG_SIGN_GET_HASH(alg)) {
   \        0x2   0x0A0A             LSRS     R2,R1,#+8
   \        0x4   0x0212             LSLS     R2,R2,#+8
   \        0x6   0x....             LDR.N    R0,??DataTable2_1
   \        0x8   0x4282             CMP      R2,R0
   \        0xA   0xD018             BEQ.N    ??get_hash_for_algorithm_0
   \        0xC   0x0A0A             LSRS     R2,R1,#+8
   \        0xE   0x0212             LSLS     R2,R2,#+8
   \       0x10   0x....             LDR.N    R0,??DataTable2_2
   \       0x12   0x4282             CMP      R2,R0
   \       0x14   0xD013             BEQ.N    ??get_hash_for_algorithm_0
   \       0x16   0x0A0A             LSRS     R2,R1,#+8
   \       0x18   0x0212             LSLS     R2,R2,#+8
   \       0x1A   0x....             LDR.N    R0,??DataTable2_3
   \       0x1C   0x4282             CMP      R2,R0
   \       0x1E   0xD00E             BEQ.N    ??get_hash_for_algorithm_0
   \       0x20   0x0A48             LSRS     R0,R1,#+9
   \       0x22   0x0240             LSLS     R0,R0,#+9
   \       0x24   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x28   0xD009             BEQ.N    ??get_hash_for_algorithm_0
   \       0x2A   0x0A0A             LSRS     R2,R1,#+8
   \       0x2C   0x0212             LSLS     R2,R2,#+8
   \       0x2E   0x....             LDR.N    R0,??DataTable2_4
   \       0x30   0x4282             CMP      R2,R0
   \       0x32   0xD004             BEQ.N    ??get_hash_for_algorithm_0
   \       0x34   0x0A4A             LSRS     R2,R1,#+9
   \       0x36   0x0252             LSLS     R2,R2,#+9
   \       0x38   0x....             LDR.N    R0,??DataTable2_5
   \       0x3A   0x4282             CMP      R2,R0
   \       0x3C   0xD106             BNE.N    ??get_hash_for_algorithm_1
   \                     ??get_hash_for_algorithm_0: (+1)
   \       0x3E   0x0608             LSLS     R0,R1,#+24
   \       0x40   0xD004             BEQ.N    ??get_hash_for_algorithm_1
   \       0x42   0xF001 0x02FF      AND      R2,R1,#0xFF
   \       0x46   0xF052 0x7200      ORRS     R2,R2,#0x2000000
   \       0x4A   0xE000             B.N      ??get_hash_for_algorithm_2
   \                     ??get_hash_for_algorithm_1: (+1)
   \       0x4C   0x2200             MOVS     R2,#+0
   \                     ??get_hash_for_algorithm_2: (+1)
   \       0x4E   0x....             LDR.N    R0,??DataTable2_6
   \       0x50   0x1A12             SUBS     R2,R2,R0
   \       0x52   0xD004             BEQ.N    ??get_hash_for_algorithm_3
   \       0x54   0x1ED2             SUBS     R2,R2,#+3
   \       0x56   0xD004             BEQ.N    ??get_hash_for_algorithm_4
   \       0x58   0x1E52             SUBS     R2,R2,#+1
   \       0x5A   0xD004             BEQ.N    ??get_hash_for_algorithm_5
   \       0x5C   0xE005             B.N      ??get_hash_for_algorithm_6
    144              #if defined(SLI_PSA_DRIVER_FEATURE_SHA1)
    145              case PSA_ALG_SHA_1:
    146                return SL_SE_HASH_SHA1;
   \                     ??get_hash_for_algorithm_3: (+1)
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xE004             B.N      ??get_hash_for_algorithm_7
    147              #endif // SLI_PSA_DRIVER_FEATURE_SHA1
    148          
    149              #if defined(SLI_PSA_DRIVER_FEATURE_SHA224)
    150              case PSA_ALG_SHA_224:
    151                return SL_SE_HASH_SHA224;
   \                     ??get_hash_for_algorithm_4: (+1)
   \       0x62   0x2002             MOVS     R0,#+2
   \       0x64   0xE002             B.N      ??get_hash_for_algorithm_7
    152              #endif // SLI_PSA_DRIVER_FEATURE_SHA224
    153          
    154              #if defined(SLI_PSA_DRIVER_FEATURE_SHA256)
    155              case PSA_ALG_SHA_256:
    156                return SL_SE_HASH_SHA256;
   \                     ??get_hash_for_algorithm_5: (+1)
   \       0x66   0x2003             MOVS     R0,#+3
   \       0x68   0xE000             B.N      ??get_hash_for_algorithm_7
    157              #endif // SLI_PSA_DRIVER_FEATURE_SHA256
    158          
    159              #if defined(SLI_PSA_DRIVER_FEATURE_SHA384)
    160              case PSA_ALG_SHA_384:
    161                return SL_SE_HASH_SHA384;
    162              #endif // SLI_PSA_DRIVER_FEATURE_SHA384
    163          
    164              #if defined(SLI_PSA_DRIVER_FEATURE_SHA512)
    165              case PSA_ALG_SHA_512:
    166                return SL_SE_HASH_SHA512;
    167              #endif // SLI_PSA_DRIVER_FEATURE_SHA512
    168          
    169              default:
    170                return SL_SE_HASH_NONE;
   \                     ??get_hash_for_algorithm_6: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \                     ??get_hash_for_algorithm_7: (+1)
   \       0x6C   0x4770             BX       LR
    171            }
    172          }
    173          
    174          #endif // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    175          
    176          // -------------------------------------
    177          // Generic (indirect) driver entry points
    178          

   \                                 In section .text, align 2, keep-with-next
    179          static psa_status_t sli_se_sign_message(
    180            const psa_key_attributes_t *attributes,
    181            const uint8_t *key_buffer,
    182            size_t key_buffer_size,
    183            psa_algorithm_t alg,
    184            const uint8_t *input,
    185            size_t input_length,
    186            uint8_t *signature,
    187            size_t signature_size,
    188            size_t *signature_length)
    189          {
   \                     sli_se_sign_message: (+1)
   \        0x0   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \        0x4   0xB097             SUB      SP,SP,#+92
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x4699             MOV      R9,R3
   \        0xA   0x9D25             LDR      R5,[SP, #+148]
    190            #if defined(SLI_PSA_DRIVER_FEATURE_SIGNATURE)
    191          
    192            uint8_t* tmp_signature_p = signature;
   \        0xC   0x9824             LDR      R0,[SP, #+144]
   \        0xE   0x9005             STR      R0,[SP, #+20]
    193            size_t tmp_signature_size = signature_size;
   \       0x10   0x46A8             MOV      R8,R5
    194            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xF07F 0x0796      MVNS     R7,#+150
    195          
    196            // Argument check
    197            if (attributes == NULL
    198                || key_buffer == NULL
    199                || key_buffer_size == 0
    200                || (input == NULL && input_length > 0)
    201                || signature == NULL
    202                || signature_size == 0
    203                || signature_length == NULL) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD013             BEQ.N    ??sli_se_sign_message_0
   \       0x1A   0x9817             LDR      R0,[SP, #+92]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD010             BEQ.N    ??sli_se_sign_message_0
   \       0x20   0x9818             LDR      R0,[SP, #+96]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD00D             BEQ.N    ??sli_se_sign_message_0
   \       0x26   0x9822             LDR      R0,[SP, #+136]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD102             BNE.N    ??sli_se_sign_message_1
   \       0x2C   0x9823             LDR      R0,[SP, #+140]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??sli_se_sign_message_0
   \                     ??sli_se_sign_message_1: (+1)
   \       0x32   0x9824             LDR      R0,[SP, #+144]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD004             BEQ.N    ??sli_se_sign_message_0
   \       0x38   0x2D00             CMP      R5,#+0
   \       0x3A   0xD002             BEQ.N    ??sli_se_sign_message_0
   \       0x3C   0x9826             LDR      R0,[SP, #+152]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD102             BNE.N    ??sli_se_sign_message_2
    204              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_sign_message_0: (+1)
   \       0x42   0xF07F 0x0086      MVNS     R0,#+134
   \       0x46   0xE091             B.N      ??sli_se_sign_message_3
    205            }
    206          
    207            // Check the requested algorithm is supported
    208            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(psa_get_key_type(attributes))) {
   \                     ??sli_se_sign_message_2: (+1)
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       psa_get_key_type
   \       0x4E   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0x52   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0x56   0xD10E             BNE.N    ??sli_se_sign_message_4
    209              psa_status = check_curve_availability(attributes, alg);
   \       0x58   0x4649             MOV      R1,R9
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       check_curve_availability
   \       0x60   0x0006             MOVS     R6,R0
    210              if (psa_status != PSA_SUCCESS) {
   \       0x62   0x2E00             CMP      R6,#+0
   \       0x64   0xD001             BEQ.N    ??sli_se_sign_message_5
    211                return psa_status;
   \       0x66   0x0030             MOVS     R0,R6
   \       0x68   0xE080             B.N      ??sli_se_sign_message_3
    212              }
    213            } else {
    214              // Not able to sign using non-ECC keys, or using public keys
    215              return PSA_ERROR_INVALID_ARGUMENT;
    216            }
    217          
    218            // Check the requested hashing algorithm is supported
    219            if (get_hash_for_algorithm(alg) == SL_SE_HASH_NONE) {
   \                     ??sli_se_sign_message_5: (+1)
   \       0x6A   0x4648             MOV      R0,R9
   \       0x6C   0x.... 0x....      BL       get_hash_for_algorithm
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD106             BNE.N    ??sli_se_sign_message_6
   \       0x74   0xE002             B.N      ??sli_se_sign_message_7
   \                     ??sli_se_sign_message_4: (+1)
   \       0x76   0xF07F 0x0086      MVNS     R0,#+134
   \       0x7A   0xE077             B.N      ??sli_se_sign_message_3
    220              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_sign_message_7: (+1)
   \       0x7C   0xF07F 0x0085      MVNS     R0,#+133
   \       0x80   0xE074             B.N      ??sli_se_sign_message_3
    221            }
    222          
    223            // Ephemeral contexts
    224            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_sign_message_6: (+1)
   \       0x82   0xA80E             ADD      R0,SP,#+56
   \       0x84   0x2124             MOVS     R1,#+36
   \       0x86   0x.... 0x....      BL       __aeabi_memclr4
    225            sl_se_key_descriptor_t key_desc = { 0 };
   \       0x8A   0xA806             ADD      R0,SP,#+24
   \       0x8C   0x2120             MOVS     R1,#+32
   \       0x8E   0x.... 0x....      BL       __aeabi_memclr4
    226          
    227            // Initialize key descriptor and verify key buffer size
    228            psa_status = sli_se_key_desc_from_input(attributes,
    229                                                    key_buffer,
    230                                                    key_buffer_size,
    231                                                    &key_desc);
   \       0x92   0xAB06             ADD      R3,SP,#+24
   \       0x94   0x9A18             LDR      R2,[SP, #+96]
   \       0x96   0x9917             LDR      R1,[SP, #+92]
   \       0x98   0x0020             MOVS     R0,R4
   \       0x9A   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x9E   0x0007             MOVS     R7,R0
    232            if (psa_status != PSA_SUCCESS) {
   \       0xA0   0x2F00             CMP      R7,#+0
   \       0xA2   0xD001             BEQ.N    ??sli_se_sign_message_8
    233              return psa_status;
   \       0xA4   0x0038             MOVS     R0,R7
   \       0xA6   0xE061             B.N      ??sli_se_sign_message_3
    234            }
    235          
    236            // Validate that the output buffer can contain the full signature.
    237            // Both ECDSA and EdDSA share the same signature size.
    238            if (signature_size
    239                < PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes))) {
   \                     ??sli_se_sign_message_8: (+1)
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x.... 0x....      BL       psa_get_key_bits
   \       0xAE   0x1DC0             ADDS     R0,R0,#+7
   \       0xB0   0x08C0             LSRS     R0,R0,#+3
   \       0xB2   0xEBB5 0x0F40      CMP      R5,R0, LSL #+1
   \       0xB6   0xD202             BCS.N    ??sli_se_sign_message_9
    240              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0xB8   0xF07F 0x0089      MVNS     R0,#+137
   \       0xBC   0xE056             B.N      ??sli_se_sign_message_3
    241            }
    242          
    243            size_t key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
   \                     ??sli_se_sign_message_9: (+1)
   \       0xBE   0x0020             MOVS     R0,R4
   \       0xC0   0x.... 0x....      BL       psa_get_key_bits
   \       0xC4   0x4683             MOV      R11,R0
   \       0xC6   0xF11B 0x0B07      ADDS     R11,R11,#+7
   \       0xCA   0xEA5F 0x0BDB      LSRS     R11,R11,#+3
    244          
    245            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    246            size_t offset = sli_se_get_padding(key_size);
    247            #else
    248            size_t offset = 0;
   \       0xCE   0xF05F 0x0A00      MOVS     R10,#+0
    249            #endif
    250          
    251            #if defined(SLI_SE_KEY_PADDING_REQUIRED) && defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    252            // P-521 (or any curve size that's not word-multiple) requires alignment on
    253            // word boundaries, instead of byte boundaries such as PSA Crypto defines as
    254            // input here.
    255            uint8_t temp_key_buf[SLI_SE_MAX_PADDED_KEY_PAIR_SIZE] = { 0 };
    256            uint8_t temp_signature_buffer[SLI_SE_MAX_PADDED_SIGNATURE_SIZE] = { 0 };
    257            psa_key_location_t location =
    258              PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
    259          
    260            if (offset > 0) {
    261              // We can only manipulate the input key for transparent keys.
    262              // For opaque keys, we will just have to rely on the key import operation
    263              // handling this
    264              if (location == PSA_KEY_LOCATION_LOCAL_STORAGE) {
    265                if ((offset + key_buffer_size) > sizeof(temp_key_buf)) {
    266                  return PSA_ERROR_INVALID_ARGUMENT;
    267                }
    268                sli_se_pad_big_endian(temp_key_buf, key_buffer, key_buffer_size);
    269                // Since we know that this must be a plaintext key, we can freely
    270                // modify the key descriptor
    271                key_desc.storage.location.buffer.pointer = temp_key_buf;
    272                key_desc.storage.location.buffer.size = sizeof(temp_key_buf);
    273              }
    274          
    275              tmp_signature_p = temp_signature_buffer;
    276              tmp_signature_size = sizeof(temp_signature_buffer);
    277            }
    278            #endif   // SLI_SE_KEY_PADDING_REQUIRED || SLI_PSA_DRIVER_FEATURE_ECDSA
    279          
    280            if (tmp_signature_size < 2 * (offset + key_size)) {
   \       0xD2   0xEB1B 0x000A      ADDS     R0,R11,R10
   \       0xD6   0xEBB8 0x0F40      CMP      R8,R0, LSL #+1
   \       0xDA   0xD202             BCS.N    ??sli_se_sign_message_10
    281              return PSA_ERROR_INVALID_ARGUMENT;
   \       0xDC   0xF07F 0x0086      MVNS     R0,#+134
   \       0xE0   0xE044             B.N      ??sli_se_sign_message_3
    282            }
    283            tmp_signature_size = 2 * (offset + key_size);
   \                     ??sli_se_sign_message_10: (+1)
   \       0xE2   0xEB1B 0x000A      ADDS     R0,R11,R10
   \       0xE6   0x0040             LSLS     R0,R0,#+1
   \       0xE8   0x9004             STR      R0,[SP, #+16]
    284          
    285            sl_status_t status = sl_se_init_command_context(&cmd_ctx);
   \       0xEA   0xA80E             ADD      R0,SP,#+56
   \       0xEC   0x.... 0x....      BL       sl_se_init_command_context
   \       0xF0   0x0006             MOVS     R6,R0
    286            if (status != SL_STATUS_OK) {
   \       0xF2   0x2E00             CMP      R6,#+0
   \       0xF4   0xD002             BEQ.N    ??sli_se_sign_message_11
    287              return PSA_ERROR_HARDWARE_FAILURE;
   \       0xF6   0xF07F 0x0092      MVNS     R0,#+146
   \       0xFA   0xE037             B.N      ??sli_se_sign_message_3
    288            }
    289          
    290            #if defined(SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED)
    291            psa_status = sli_se_check_eddsa_errata(attributes, &cmd_ctx);
    292            if (psa_status != PSA_SUCCESS) {
    293              return psa_status;
    294            }
    295            #endif   // SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED
    296          
    297            // Run signature generation
    298            status = sl_se_ecc_sign(&cmd_ctx,
    299                                    &key_desc,
    300                                    get_hash_for_algorithm(alg),
    301                                    false,
    302                                    input,
    303                                    input_length,
    304                                    tmp_signature_p,
    305                                    tmp_signature_size
    306                                    );
   \                     ??sli_se_sign_message_11: (+1)
   \       0xFC   0x4648             MOV      R0,R9
   \       0xFE   0x.... 0x....      BL       get_hash_for_algorithm
   \      0x102   0x9904             LDR      R1,[SP, #+16]
   \      0x104   0x9103             STR      R1,[SP, #+12]
   \      0x106   0x9905             LDR      R1,[SP, #+20]
   \      0x108   0x9102             STR      R1,[SP, #+8]
   \      0x10A   0x9923             LDR      R1,[SP, #+140]
   \      0x10C   0x9101             STR      R1,[SP, #+4]
   \      0x10E   0x9922             LDR      R1,[SP, #+136]
   \      0x110   0x9100             STR      R1,[SP, #+0]
   \      0x112   0x2300             MOVS     R3,#+0
   \      0x114   0x0002             MOVS     R2,R0
   \      0x116   0xB2D2             UXTB     R2,R2
   \      0x118   0xA906             ADD      R1,SP,#+24
   \      0x11A   0xA80E             ADD      R0,SP,#+56
   \      0x11C   0x.... 0x....      BL       sl_se_ecc_sign
   \      0x120   0x4680             MOV      R8,R0
    307          
    308            #if defined(SLI_SE_KEY_PADDING_REQUIRED) && defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    309            if (offset > 0) {
    310              sli_psa_zeroize(temp_key_buf, sizeof(temp_key_buf));
    311              // Copy over from temp signature
    312              sli_se_unpad_curve_point(temp_signature_buffer, signature, key_size);
    313            }
    314            #endif // SLI_SE_KEY_PADDING_REQUIRED && SLI_PSA_DRIVER_FEATURE_ECDSA
    315          
    316            if (status == SL_STATUS_OK) {
   \      0x122   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x126   0xD109             BNE.N    ??sli_se_sign_message_12
    317              *signature_length = PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes));
   \      0x128   0x0020             MOVS     R0,R4
   \      0x12A   0x.... 0x....      BL       psa_get_key_bits
   \      0x12E   0x1DC0             ADDS     R0,R0,#+7
   \      0x130   0x08C0             LSRS     R0,R0,#+3
   \      0x132   0x0041             LSLS     R1,R0,#+1
   \      0x134   0x9826             LDR      R0,[SP, #+152]
   \      0x136   0x6001             STR      R1,[R0, #+0]
    318              psa_status = PSA_SUCCESS;
   \      0x138   0x2600             MOVS     R6,#+0
   \      0x13A   0xE00D             B.N      ??sli_se_sign_message_13
    319            } else {
    320              if (status == SL_STATUS_FAIL) {
   \                     ??sli_se_sign_message_12: (+1)
   \      0x13C   0xF1B8 0x0F01      CMP      R8,#+1
   \      0x140   0xD102             BNE.N    ??sli_se_sign_message_14
    321                // Will be returned for missing built-in keys.
    322                psa_status = PSA_ERROR_DOES_NOT_EXIST;
   \      0x142   0xF07F 0x068B      MVNS     R6,#+139
   \      0x146   0xE007             B.N      ??sli_se_sign_message_13
    323              } else if (status == SL_STATUS_COMMAND_IS_INVALID) {
   \                     ??sli_se_sign_message_14: (+1)
   \      0x148   0xF1B8 0x0F48      CMP      R8,#+72
   \      0x14C   0xD102             BNE.N    ??sli_se_sign_message_15
    324                // Will be returned if a key type is not supported (for example).
    325                psa_status = PSA_ERROR_NOT_SUPPORTED;
   \      0x14E   0xF07F 0x0685      MVNS     R6,#+133
   \      0x152   0xE001             B.N      ??sli_se_sign_message_13
    326              } else {
    327                psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_sign_message_15: (+1)
   \      0x154   0xF07F 0x0692      MVNS     R6,#+146
    328              }
    329            }
    330          
    331            // Cleanup
    332            status = sl_se_deinit_command_context(&cmd_ctx);
   \                     ??sli_se_sign_message_13: (+1)
   \      0x158   0xA80E             ADD      R0,SP,#+56
   \      0x15A   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x15E   0x0001             MOVS     R1,R0
    333            if (status != SL_STATUS_OK) {
   \      0x160   0x2900             CMP      R1,#+0
   \      0x162   0xD002             BEQ.N    ??sli_se_sign_message_16
    334              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x164   0xF07F 0x0092      MVNS     R0,#+146
   \      0x168   0xE000             B.N      ??sli_se_sign_message_3
    335            }
    336            return psa_status;
   \                     ??sli_se_sign_message_16: (+1)
   \      0x16A   0x0030             MOVS     R0,R6
   \                     ??sli_se_sign_message_3: (+1)
   \      0x16C   0xB019             ADD      SP,SP,#+100
   \      0x16E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    337          
    338            #else // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    339          
    340            (void) attributes;
    341            (void) key_buffer;
    342            (void) key_buffer_size;
    343            (void) alg;
    344            (void) input;
    345            (void) input_length;
    346            (void) signature;
    347            (void) signature_size;
    348            (void) signature_length;
    349          
    350            return PSA_ERROR_NOT_SUPPORTED;
    351          
    352            #endif // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    353          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    354          

   \                                 In section .text, align 2, keep-with-next
    355          static psa_status_t sli_se_sign_hash(
    356            const psa_key_attributes_t *attributes,
    357            const uint8_t *key_buffer,
    358            size_t key_buffer_size,
    359            psa_algorithm_t alg,
    360            const uint8_t *hash,
    361            size_t hash_length,
    362            uint8_t *signature,
    363            size_t signature_size,
    364            size_t *signature_length)
    365          {
   \                     sli_se_sign_hash: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB098             SUB      SP,SP,#+96
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x9D27             LDR      R5,[SP, #+156]
    366            #if defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    367            uint8_t* tmp_signature_p = signature;
   \        0xA   0x9826             LDR      R0,[SP, #+152]
   \        0xC   0x9006             STR      R0,[SP, #+24]
    368            size_t tmp_signature_size = signature_size;
   \        0xE   0x9504             STR      R5,[SP, #+16]
    369          
    370            // Argument check
    371            if (attributes == NULL
    372                || key_buffer == NULL
    373                || key_buffer_size == 0
    374                || hash == NULL
    375                || hash_length == 0
    376                || signature == NULL
    377                || signature_size == 0
    378                || signature_length == NULL) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD013             BEQ.N    ??sli_se_sign_hash_0
   \       0x14   0x9818             LDR      R0,[SP, #+96]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD010             BEQ.N    ??sli_se_sign_hash_0
   \       0x1A   0x9819             LDR      R0,[SP, #+100]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD00D             BEQ.N    ??sli_se_sign_hash_0
   \       0x20   0x9824             LDR      R0,[SP, #+144]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD00A             BEQ.N    ??sli_se_sign_hash_0
   \       0x26   0x9825             LDR      R0,[SP, #+148]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD007             BEQ.N    ??sli_se_sign_hash_0
   \       0x2C   0x9826             LDR      R0,[SP, #+152]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD004             BEQ.N    ??sli_se_sign_hash_0
   \       0x32   0x2D00             CMP      R5,#+0
   \       0x34   0xD002             BEQ.N    ??sli_se_sign_hash_0
   \       0x36   0x9828             LDR      R0,[SP, #+160]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD102             BNE.N    ??sli_se_sign_hash_1
    379              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_sign_hash_0: (+1)
   \       0x3C   0xF07F 0x0086      MVNS     R0,#+134
   \       0x40   0xE08B             B.N      ??sli_se_sign_hash_2
    380            }
    381          
    382            // Check the requested algorithm is ECDSA with randomized k
    383            if (!PSA_ALG_IS_RANDOMIZED_ECDSA(alg)) {
   \                     ??sli_se_sign_hash_1: (+1)
   \       0x42   0x981A             LDR      R0,[SP, #+104]
   \       0x44   0x0A00             LSRS     R0,R0,#+8
   \       0x46   0x0200             LSLS     R0,R0,#+8
   \       0x48   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x4C   0xD002             BEQ.N    ??sli_se_sign_hash_3
    384              return PSA_ERROR_NOT_SUPPORTED;
   \       0x4E   0xF07F 0x0085      MVNS     R0,#+133
   \       0x52   0xE082             B.N      ??sli_se_sign_hash_2
    385            }
    386          
    387            // Ephemeral contexts
    388            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_sign_hash_3: (+1)
   \       0x54   0xA80F             ADD      R0,SP,#+60
   \       0x56   0x2124             MOVS     R1,#+36
   \       0x58   0x.... 0x....      BL       __aeabi_memclr4
    389            sl_se_key_descriptor_t key_desc = { 0 };
   \       0x5C   0xA807             ADD      R0,SP,#+28
   \       0x5E   0x2120             MOVS     R1,#+32
   \       0x60   0x.... 0x....      BL       __aeabi_memclr4
    390          
    391            // Initialize key descriptor and verify key buffer size
    392            psa_status_t psa_status = sli_se_key_desc_from_input(attributes,
    393                                                                 key_buffer,
    394                                                                 key_buffer_size,
    395                                                                 &key_desc);
   \       0x64   0xAB07             ADD      R3,SP,#+28
   \       0x66   0x9A19             LDR      R2,[SP, #+100]
   \       0x68   0x9918             LDR      R1,[SP, #+96]
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x70   0x0007             MOVS     R7,R0
    396            if (psa_status != PSA_SUCCESS) {
   \       0x72   0x2F00             CMP      R7,#+0
   \       0x74   0xD001             BEQ.N    ??sli_se_sign_hash_4
    397              return psa_status;
   \       0x76   0x0038             MOVS     R0,R7
   \       0x78   0xE06F             B.N      ??sli_se_sign_hash_2
    398            }
    399          
    400            // Verify and set key attributes
    401            psa_key_type_t keytype = psa_get_key_type(attributes);
   \                     ??sli_se_sign_hash_4: (+1)
   \       0x7A   0x0020             MOVS     R0,R4
   \       0x7C   0x.... 0x....      BL       psa_get_key_type
   \       0x80   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    402          
    403            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
   \       0x84   0xF8BD 0x0014      LDRH     R0,[SP, #+20]
   \       0x88   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0x8C   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0x90   0xD124             BNE.N    ??sli_se_sign_hash_5
    404              // Validate that the input
    405              psa_status = check_curve_availability(attributes, alg);
   \       0x92   0x991A             LDR      R1,[SP, #+104]
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0x.... 0x....      BL       check_curve_availability
   \       0x9A   0x0006             MOVS     R6,R0
    406              if (psa_status != PSA_SUCCESS) {
   \       0x9C   0x2E00             CMP      R6,#+0
   \       0x9E   0xD001             BEQ.N    ??sli_se_sign_hash_6
    407                return psa_status;
   \       0xA0   0x0030             MOVS     R0,R6
   \       0xA2   0xE05A             B.N      ??sli_se_sign_hash_2
    408              }
    409              if (signature_size
    410                  < PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes))) {
   \                     ??sli_se_sign_hash_6: (+1)
   \       0xA4   0x0020             MOVS     R0,R4
   \       0xA6   0x.... 0x....      BL       psa_get_key_bits
   \       0xAA   0x1DC0             ADDS     R0,R0,#+7
   \       0xAC   0x08C0             LSRS     R0,R0,#+3
   \       0xAE   0xEBB5 0x0F40      CMP      R5,R0, LSL #+1
   \       0xB2   0xD202             BCS.N    ??sli_se_sign_hash_7
    411                return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0xB4   0xF07F 0x0089      MVNS     R0,#+137
   \       0xB8   0xE04F             B.N      ??sli_se_sign_hash_2
    412              }
    413            } else {
    414              // Not able to sign using non-ECC keys, or using public keys
    415              return PSA_ERROR_INVALID_ARGUMENT;
    416            }
    417          
    418            size_t key_bits = psa_get_key_bits(attributes);
   \                     ??sli_se_sign_hash_7: (+1)
   \       0xBA   0x0020             MOVS     R0,R4
   \       0xBC   0x.... 0x....      BL       psa_get_key_bits
   \       0xC0   0x4683             MOV      R11,R0
    419            size_t key_size = PSA_BITS_TO_BYTES(key_bits);
   \       0xC2   0xF11B 0x0907      ADDS     R9,R11,#+7
   \       0xC6   0xEA5F 0x09D9      LSRS     R9,R9,#+3
    420          
    421            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    422            size_t offset = sli_se_get_padding(key_size);
    423            #else
    424            size_t offset = 0;
   \       0xCA   0xF05F 0x0A00      MOVS     R10,#+0
    425            #endif
    426          
    427            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    428            // P-521 (or any curve size that's not word-multiple) requires alignment on
    429            // word boundaries, instead of byte boundaries such as PSA Crypto defines as
    430            // input here.
    431            uint8_t temp_key_buf[SLI_SE_MAX_PADDED_KEY_PAIR_SIZE] = { 0 };
    432            uint8_t temp_signature_buffer[SLI_SE_MAX_PADDED_SIGNATURE_SIZE] = { 0 };
    433            psa_key_location_t location =
    434              PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
    435          
    436            if (offset > 0) {
    437              // We can only manipulate the input key for transparent keys.
    438              // For opaque keys, we will just have to rely on the key import operation
    439              // handling this
    440              if (location == PSA_KEY_LOCATION_LOCAL_STORAGE) {
    441                if ((offset + key_buffer_size) > sizeof(temp_key_buf)) {
    442                  return PSA_ERROR_INVALID_ARGUMENT;
    443                }
    444                sli_se_pad_big_endian(temp_key_buf, key_buffer, key_buffer_size);
    445                // Since we know that this must be a plaintext key, we can freely
    446                // modify the key descriptor
    447                key_desc.storage.location.buffer.pointer = temp_key_buf;
    448                key_desc.storage.location.buffer.size = sizeof(temp_key_buf);
    449              }
    450          
    451              tmp_signature_p = temp_signature_buffer;
    452              tmp_signature_size = sizeof(temp_signature_buffer);
    453            }
    454            #endif   // SLI_SE_KEY_PADDING_REQUIRED
    455          
    456            if (tmp_signature_size < 2 * (offset + key_size)) {
   \       0xCE   0x9904             LDR      R1,[SP, #+16]
   \       0xD0   0xEB19 0x000A      ADDS     R0,R9,R10
   \       0xD4   0xEBB1 0x0F40      CMP      R1,R0, LSL #+1
   \       0xD8   0xD206             BCS.N    ??sli_se_sign_hash_8
   \       0xDA   0xE002             B.N      ??sli_se_sign_hash_9
   \                     ??sli_se_sign_hash_5: (+1)
   \       0xDC   0xF07F 0x0086      MVNS     R0,#+134
   \       0xE0   0xE03B             B.N      ??sli_se_sign_hash_2
    457              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_sign_hash_9: (+1)
   \       0xE2   0xF07F 0x0086      MVNS     R0,#+134
   \       0xE6   0xE038             B.N      ??sli_se_sign_hash_2
    458            }
    459            tmp_signature_size = 2 * (offset + key_size);
   \                     ??sli_se_sign_hash_8: (+1)
   \       0xE8   0xEB19 0x000A      ADDS     R0,R9,R10
   \       0xEC   0x0040             LSLS     R0,R0,#+1
   \       0xEE   0x9004             STR      R0,[SP, #+16]
    460          
    461            sl_status_t status = sl_se_init_command_context(&cmd_ctx);
   \       0xF0   0xA80F             ADD      R0,SP,#+60
   \       0xF2   0x.... 0x....      BL       sl_se_init_command_context
   \       0xF6   0x0007             MOVS     R7,R0
    462            if (status != SL_STATUS_OK) {
   \       0xF8   0x2F00             CMP      R7,#+0
   \       0xFA   0xD002             BEQ.N    ??sli_se_sign_hash_10
    463              return PSA_ERROR_HARDWARE_FAILURE;
   \       0xFC   0xF07F 0x0092      MVNS     R0,#+146
   \      0x100   0xE02B             B.N      ??sli_se_sign_hash_2
    464            }
    465          
    466            // Run signature generation
    467            status = sl_se_ecc_sign(&cmd_ctx,
    468                                    &key_desc,
    469                                    SL_SE_HASH_NONE,
    470                                    true,
    471                                    hash,
    472                                    hash_length,
    473                                    tmp_signature_p,
    474                                    tmp_signature_size);
   \                     ??sli_se_sign_hash_10: (+1)
   \      0x102   0x9804             LDR      R0,[SP, #+16]
   \      0x104   0x9003             STR      R0,[SP, #+12]
   \      0x106   0x9806             LDR      R0,[SP, #+24]
   \      0x108   0x9002             STR      R0,[SP, #+8]
   \      0x10A   0x9825             LDR      R0,[SP, #+148]
   \      0x10C   0x9001             STR      R0,[SP, #+4]
   \      0x10E   0x9824             LDR      R0,[SP, #+144]
   \      0x110   0x9000             STR      R0,[SP, #+0]
   \      0x112   0x2301             MOVS     R3,#+1
   \      0x114   0x2200             MOVS     R2,#+0
   \      0x116   0xA907             ADD      R1,SP,#+28
   \      0x118   0xA80F             ADD      R0,SP,#+60
   \      0x11A   0x.... 0x....      BL       sl_se_ecc_sign
   \      0x11E   0x4680             MOV      R8,R0
    475          
    476            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    477            if (offset > 0) {
    478              sli_psa_zeroize(temp_key_buf, sizeof(temp_key_buf));
    479              // Copy over from temp signature
    480              sli_se_unpad_curve_point(temp_signature_buffer, signature, key_size);
    481            }
    482            #endif   // SLI_SE_KEY_PADDING_REQUIRED
    483          
    484            if (status == SL_STATUS_OK) {
   \      0x120   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x124   0xD107             BNE.N    ??sli_se_sign_hash_11
    485              *signature_length = PSA_ECDSA_SIGNATURE_SIZE(key_bits);
   \      0x126   0xF11B 0x0007      ADDS     R0,R11,#+7
   \      0x12A   0x08C0             LSRS     R0,R0,#+3
   \      0x12C   0x0041             LSLS     R1,R0,#+1
   \      0x12E   0x9828             LDR      R0,[SP, #+160]
   \      0x130   0x6001             STR      R1,[R0, #+0]
    486              psa_status = PSA_SUCCESS;
   \      0x132   0x2700             MOVS     R7,#+0
   \      0x134   0xE007             B.N      ??sli_se_sign_hash_12
    487            } else {
    488              if (status == SL_STATUS_FAIL) {
   \                     ??sli_se_sign_hash_11: (+1)
   \      0x136   0xF1B8 0x0F01      CMP      R8,#+1
   \      0x13A   0xD102             BNE.N    ??sli_se_sign_hash_13
    489                psa_status = PSA_ERROR_DOES_NOT_EXIST;
   \      0x13C   0xF07F 0x078B      MVNS     R7,#+139
   \      0x140   0xE001             B.N      ??sli_se_sign_hash_12
    490              } else {
    491                psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_sign_hash_13: (+1)
   \      0x142   0xF07F 0x0792      MVNS     R7,#+146
    492              }
    493            }
    494          
    495            // Cleanup
    496            status = sl_se_deinit_command_context(&cmd_ctx);
   \                     ??sli_se_sign_hash_12: (+1)
   \      0x146   0xA80F             ADD      R0,SP,#+60
   \      0x148   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x14C   0x0001             MOVS     R1,R0
    497            if (status != SL_STATUS_OK) {
   \      0x14E   0x2900             CMP      R1,#+0
   \      0x150   0xD002             BEQ.N    ??sli_se_sign_hash_14
    498              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x152   0xF07F 0x0092      MVNS     R0,#+146
   \      0x156   0xE000             B.N      ??sli_se_sign_hash_2
    499            }
    500            return psa_status;
   \                     ??sli_se_sign_hash_14: (+1)
   \      0x158   0x0038             MOVS     R0,R7
   \                     ??sli_se_sign_hash_2: (+1)
   \      0x15A   0xB01B             ADD      SP,SP,#+108
   \      0x15C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    501          
    502            #else // SLI_PSA_DRIVER_FEATURE_ECDSA
    503          
    504            (void) attributes;
    505            (void) key_buffer;
    506            (void) key_buffer_size;
    507            (void) alg;
    508            (void) hash;
    509            (void) hash_length;
    510            (void) signature;
    511            (void) signature_size;
    512            (void) signature_length;
    513          
    514            return PSA_ERROR_NOT_SUPPORTED;
    515          
    516            #endif  // SLI_PSA_DRIVER_FEATURE_ECDSA
    517          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    518          

   \                                 In section .text, align 2, keep-with-next
    519          static psa_status_t sli_se_verify_message(
    520            const psa_key_attributes_t *attributes,
    521            const uint8_t *key_buffer,
    522            size_t key_buffer_size,
    523            psa_algorithm_t alg,
    524            const uint8_t *input,
    525            size_t input_length,
    526            const uint8_t *signature,
    527            size_t signature_length)
    528          {
   \                     sli_se_verify_message: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB0C0             SUB      SP,SP,#+256
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x4699             MOV      R9,R3
   \        0xA   0x9D4D             LDR      R5,[SP, #+308]
   \        0xC   0x9E4E             LDR      R6,[SP, #+312]
   \        0xE   0x9F4F             LDR      R7,[SP, #+316]
    529            #if defined(SLI_PSA_DRIVER_FEATURE_SIGNATURE)
    530          
    531            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x10   0xF07F 0x0A96      MVNS     R10,#+150
    532          
    533            // Argument check.
    534            if (attributes == NULL
    535                || key_buffer == NULL
    536                || key_buffer_size == 0
    537                || (input == NULL && input_length > 0)
    538                || signature == NULL) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD00C             BEQ.N    ??sli_se_verify_message_0
   \       0x18   0x9841             LDR      R0,[SP, #+260]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD009             BEQ.N    ??sli_se_verify_message_0
   \       0x1E   0x9842             LDR      R0,[SP, #+264]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD006             BEQ.N    ??sli_se_verify_message_0
   \       0x24   0x984C             LDR      R0,[SP, #+304]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD101             BNE.N    ??sli_se_verify_message_1
   \       0x2A   0x2D00             CMP      R5,#+0
   \       0x2C   0xD101             BNE.N    ??sli_se_verify_message_0
   \                     ??sli_se_verify_message_1: (+1)
   \       0x2E   0x2E00             CMP      R6,#+0
   \       0x30   0xD102             BNE.N    ??sli_se_verify_message_2
    539              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_verify_message_0: (+1)
   \       0x32   0xF07F 0x0086      MVNS     R0,#+134
   \       0x36   0xE0D1             B.N      ??sli_se_verify_message_3
    540            }
    541          
    542            // Verify can happen with a public or private key
    543            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(psa_get_key_type(attributes))
    544                || PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(psa_get_key_type(attributes))) {
   \                     ??sli_se_verify_message_2: (+1)
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       psa_get_key_type
   \       0x3E   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0x42   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0x46   0xD007             BEQ.N    ??sli_se_verify_message_4
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       psa_get_key_type
   \       0x4E   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0x52   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0x56   0xD10F             BNE.N    ??sli_se_verify_message_5
    545              // Check the requested algorithm is supported and matches the key type
    546              psa_status = check_curve_availability(attributes, alg);
   \                     ??sli_se_verify_message_4: (+1)
   \       0x58   0x4649             MOV      R1,R9
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       check_curve_availability
   \       0x60   0x4680             MOV      R8,R0
    547              if (psa_status != PSA_SUCCESS) {
   \       0x62   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x66   0xD001             BEQ.N    ??sli_se_verify_message_6
    548                return psa_status;
   \       0x68   0x4640             MOV      R0,R8
   \       0x6A   0xE0B7             B.N      ??sli_se_verify_message_3
    549              }
    550            } else {
    551              return PSA_ERROR_NOT_SUPPORTED;
    552            }
    553          
    554            // Check the requested hashing algorithm is supported
    555            if (get_hash_for_algorithm(alg) == SL_SE_HASH_NONE) {
   \                     ??sli_se_verify_message_6: (+1)
   \       0x6C   0x4648             MOV      R0,R9
   \       0x6E   0x.... 0x....      BL       get_hash_for_algorithm
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD106             BNE.N    ??sli_se_verify_message_7
   \       0x76   0xE002             B.N      ??sli_se_verify_message_8
   \                     ??sli_se_verify_message_5: (+1)
   \       0x78   0xF07F 0x0085      MVNS     R0,#+133
   \       0x7C   0xE0AE             B.N      ??sli_se_verify_message_3
    556              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_verify_message_8: (+1)
   \       0x7E   0xF07F 0x0085      MVNS     R0,#+133
   \       0x82   0xE0AB             B.N      ??sli_se_verify_message_3
    557            }
    558          
    559            if (signature_length == 0) {
   \                     ??sli_se_verify_message_7: (+1)
   \       0x84   0x2F00             CMP      R7,#+0
   \       0x86   0xD102             BNE.N    ??sli_se_verify_message_9
    560              return PSA_ERROR_INVALID_SIGNATURE;
   \       0x88   0xF07F 0x0094      MVNS     R0,#+148
   \       0x8C   0xE0A6             B.N      ??sli_se_verify_message_3
    561            }
    562          
    563            // Ephemeral contexts
    564            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_verify_message_9: (+1)
   \       0x8E   0xA815             ADD      R0,SP,#+84
   \       0x90   0x2124             MOVS     R1,#+36
   \       0x92   0x.... 0x....      BL       __aeabi_memclr4
    565            sl_se_key_descriptor_t key_desc = { 0 };
   \       0x96   0xA80D             ADD      R0,SP,#+52
   \       0x98   0x2120             MOVS     R1,#+32
   \       0x9A   0x.... 0x....      BL       __aeabi_memclr4
    566          
    567            psa_status = sli_se_key_desc_from_input(attributes,
    568                                                    key_buffer,
    569                                                    key_buffer_size,
    570                                                    &key_desc);
   \       0x9E   0xAB0D             ADD      R3,SP,#+52
   \       0xA0   0x9A42             LDR      R2,[SP, #+264]
   \       0xA2   0x9941             LDR      R1,[SP, #+260]
   \       0xA4   0x0020             MOVS     R0,R4
   \       0xA6   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0xAA   0x4682             MOV      R10,R0
    571            if (psa_status != PSA_SUCCESS) {
   \       0xAC   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xB0   0xD001             BEQ.N    ??sli_se_verify_message_10
    572              return psa_status;
   \       0xB2   0x4650             MOV      R0,R10
   \       0xB4   0xE092             B.N      ??sli_se_verify_message_3
    573            }
    574          
    575            // Validate that the signature input is of the expected length.
    576            // Both ECDSA and EdDSA share the same signature size.
    577            if (signature_length
    578                != PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes))) {
   \                     ??sli_se_verify_message_10: (+1)
   \       0xB6   0x0020             MOVS     R0,R4
   \       0xB8   0x.... 0x....      BL       psa_get_key_bits
   \       0xBC   0x1DC0             ADDS     R0,R0,#+7
   \       0xBE   0x08C0             LSRS     R0,R0,#+3
   \       0xC0   0xEBB7 0x0F40      CMP      R7,R0, LSL #+1
   \       0xC4   0xD002             BEQ.N    ??sli_se_verify_message_11
    579              return PSA_ERROR_INVALID_SIGNATURE;
   \       0xC6   0xF07F 0x0094      MVNS     R0,#+148
   \       0xCA   0xE087             B.N      ??sli_se_verify_message_3
    580            }
   \                     ??sli_se_verify_message_11: (+1)
   \       0xCC   0x2188             MOVS     R1,#+136
   \       0xCE   0x2200             MOVS     R2,#+0
   \       0xD0   0xA81E             ADD      R0,SP,#+120
   \       0xD2   0x.... 0x....      BL       __aeabi_memset
    581          
    582            // Verify and set key attributes
    583            uint8_t temp_key_buf[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
    584            psa_key_type_t keytype = psa_get_key_type(attributes);
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x.... 0x....      BL       psa_get_key_type
   \       0xDC   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    585          
    586            #if defined(SLI_SE_KEY_PADDING_REQUIRED) && defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    587            // P-521 (or any curve size that's not word-multiple) requires alignment on word
    588            // boundaries, instead of byte boundaries such as PSA Crypto defines as input here.
    589            uint8_t temp_signature_buffer[SLI_SE_MAX_PADDED_SIGNATURE_SIZE] = { 0 };
    590            size_t key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
    591            size_t offset = sli_se_get_padding(key_size);
    592            if (offset > 0) {
    593              psa_key_location_t location =
    594                PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
    595          
    596              // Only pad transparent keys.
    597              if (location == PSA_KEY_LOCATION_LOCAL_STORAGE) {
    598                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
    599                  if (offset + key_size > sizeof(temp_key_buf)) {
    600                    return PSA_ERROR_INVALID_ARGUMENT;
    601                  }
    602                  sli_se_pad_big_endian(temp_key_buf,
    603                                        key_desc.storage.location.buffer.pointer,
    604                                        key_size);
    605                } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(keytype)) {
    606                  if ((2 * (offset + key_size)) > sizeof(temp_key_buf)) {
    607                    return PSA_ERROR_INVALID_ARGUMENT;
    608                  }
    609                  sli_se_pad_curve_point(temp_key_buf,
    610                                         key_desc.storage.location.buffer.pointer,
    611                                         key_size);
    612                } else {
    613                  return PSA_ERROR_CORRUPTION_DETECTED;
    614                }
    615                key_desc.storage.location.buffer.pointer = temp_key_buf;
    616                key_desc.storage.location.buffer.size = sizeof(temp_key_buf);
    617              }
    618          
    619              // Always pad signature
    620              if ((2 * (offset + key_size)) > sizeof(temp_signature_buffer)) {
    621                return PSA_ERROR_INVALID_ARGUMENT;
    622              }
    623              sli_se_pad_curve_point(temp_signature_buffer, signature, key_size);
    624          
    625              signature = temp_signature_buffer;
    626              signature_length = signature_length + 2 * offset;
    627            }
    628            #endif   // SLI_SE_KEY_PADDING_REQUIRED && SLI_PSA_DRIVER_FEATURE_ECDSA
    629          
    630            // SE manager only accepts public keys for signature verification,
    631            // so we must generate a public key if we are passed a private one
    632            sl_status_t status = SL_STATUS_INVALID_PARAMETER;
   \       0xE0   0xF05F 0x0B21      MOVS     R11,#+33
    633            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
   \       0xE4   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \       0xE8   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0xEC   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0xF0   0xD136             BNE.N    ??sli_se_verify_message_12
    634              #if defined(SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED)
    635              psa_status = sli_se_check_eddsa_errata(attributes, &cmd_ctx);
    636              if (psa_status != PSA_SUCCESS) {
    637                return psa_status;
    638              }
    639              #endif   // SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED
    640          
    641              // Create similar key descriptor for temporary public key.
    642              sl_se_key_descriptor_t pubkey_desc = key_desc;
   \       0xF2   0xA805             ADD      R0,SP,#+20
   \       0xF4   0xA90D             ADD      R1,SP,#+52
   \       0xF6   0x2220             MOVS     R2,#+32
   \       0xF8   0x.... 0x....      BL       __aeabi_memcpy4
    643              pubkey_desc.flags &= ~SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
   \       0xFC   0x9807             LDR      R0,[SP, #+28]
   \       0xFE   0xF430 0x4080      BICS     R0,R0,#0x4000
   \      0x102   0x9007             STR      R0,[SP, #+28]
    644              pubkey_desc.flags &= ~SL_SE_KEY_FLAG_IS_RESTRICTED;
   \      0x104   0x9807             LDR      R0,[SP, #+28]
   \      0x106   0xF030 0x7040      BICS     R0,R0,#0x3000000
   \      0x10A   0x9007             STR      R0,[SP, #+28]
    645              pubkey_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \      0x10C   0x9807             LDR      R0,[SP, #+28]
   \      0x10E   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \      0x112   0x9007             STR      R0,[SP, #+28]
    646              sli_se_key_descriptor_set_plaintext(&pubkey_desc, temp_key_buf, sizeof(temp_key_buf));
   \      0x114   0x2288             MOVS     R2,#+136
   \      0x116   0xA91E             ADD      R1,SP,#+120
   \      0x118   0xA805             ADD      R0,SP,#+20
   \      0x11A   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
    647          
    648              status = sl_se_init_command_context(&cmd_ctx);
   \      0x11E   0xA815             ADD      R0,SP,#+84
   \      0x120   0x.... 0x....      BL       sl_se_init_command_context
   \      0x124   0x4680             MOV      R8,R0
    649              if (status != SL_STATUS_OK) {
   \      0x126   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x12A   0xD002             BEQ.N    ??sli_se_verify_message_13
    650                return PSA_ERROR_HARDWARE_FAILURE;
   \      0x12C   0xF07F 0x0092      MVNS     R0,#+146
   \      0x130   0xE054             B.N      ??sli_se_verify_message_3
    651              }
    652          
    653              status = sl_se_export_public_key(&cmd_ctx, &key_desc, &pubkey_desc);
   \                     ??sli_se_verify_message_13: (+1)
   \      0x132   0xAA05             ADD      R2,SP,#+20
   \      0x134   0xA90D             ADD      R1,SP,#+52
   \      0x136   0xA815             ADD      R0,SP,#+84
   \      0x138   0x.... 0x....      BL       sl_se_export_public_key
   \      0x13C   0x4683             MOV      R11,R0
    654              if (status != SL_STATUS_OK) {
   \      0x13E   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x142   0xD008             BEQ.N    ??sli_se_verify_message_14
    655                if (status == SL_STATUS_COMMAND_IS_INVALID) {
   \      0x144   0xF1BB 0x0F48      CMP      R11,#+72
   \      0x148   0xD102             BNE.N    ??sli_se_verify_message_15
    656                  // This error will be returned if the key type isn't supported.
    657                  return PSA_ERROR_NOT_SUPPORTED;
   \      0x14A   0xF07F 0x0085      MVNS     R0,#+133
   \      0x14E   0xE045             B.N      ??sli_se_verify_message_3
    658                } else {
    659                  return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_verify_message_15: (+1)
   \      0x150   0xF07F 0x0092      MVNS     R0,#+146
   \      0x154   0xE042             B.N      ??sli_se_verify_message_3
    660                }
    661              }
    662          
    663              // Set the key desc to the public key, and move on.
    664              key_desc = pubkey_desc;
   \                     ??sli_se_verify_message_14: (+1)
   \      0x156   0xA80D             ADD      R0,SP,#+52
   \      0x158   0xA905             ADD      R1,SP,#+20
   \      0x15A   0x2220             MOVS     R2,#+32
   \      0x15C   0x.... 0x....      BL       __aeabi_memcpy4
    665            }
    666          
    667            status = sl_se_init_command_context(&cmd_ctx);
   \                     ??sli_se_verify_message_12: (+1)
   \      0x160   0xA815             ADD      R0,SP,#+84
   \      0x162   0x.... 0x....      BL       sl_se_init_command_context
   \      0x166   0x4680             MOV      R8,R0
    668            if (status != SL_STATUS_OK) {
   \      0x168   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x16C   0xD002             BEQ.N    ??sli_se_verify_message_16
    669              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x16E   0xF07F 0x0092      MVNS     R0,#+146
   \      0x172   0xE033             B.N      ??sli_se_verify_message_3
    670            }
    671          
    672            // Run signature verification
    673            status = sl_se_ecc_verify(&cmd_ctx,
    674                                      &key_desc,
    675                                      get_hash_for_algorithm(alg),
    676                                      false,
    677                                      input,
    678                                      input_length,
    679                                      signature,
    680                                      signature_length);
   \                     ??sli_se_verify_message_16: (+1)
   \      0x174   0x4648             MOV      R0,R9
   \      0x176   0x.... 0x....      BL       get_hash_for_algorithm
   \      0x17A   0x9703             STR      R7,[SP, #+12]
   \      0x17C   0x9602             STR      R6,[SP, #+8]
   \      0x17E   0x9501             STR      R5,[SP, #+4]
   \      0x180   0x994C             LDR      R1,[SP, #+304]
   \      0x182   0x9100             STR      R1,[SP, #+0]
   \      0x184   0x2300             MOVS     R3,#+0
   \      0x186   0x0002             MOVS     R2,R0
   \      0x188   0xB2D2             UXTB     R2,R2
   \      0x18A   0xA90D             ADD      R1,SP,#+52
   \      0x18C   0xA815             ADD      R0,SP,#+84
   \      0x18E   0x.... 0x....      BL       sl_se_ecc_verify
   \      0x192   0x4683             MOV      R11,R0
    681          
    682            if (status == SL_STATUS_OK) {
   \      0x194   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x198   0xD102             BNE.N    ??sli_se_verify_message_17
    683              psa_status = PSA_SUCCESS;
   \      0x19A   0xF05F 0x0800      MOVS     R8,#+0
   \      0x19E   0xE013             B.N      ??sli_se_verify_message_18
    684            } else if (status == SL_STATUS_INVALID_SIGNATURE) {
   \                     ??sli_se_verify_message_17: (+1)
   \      0x1A0   0xF1BB 0x0F2C      CMP      R11,#+44
   \      0x1A4   0xD102             BNE.N    ??sli_se_verify_message_19
    685              // Signature was invalid.
    686              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   \      0x1A6   0xF07F 0x0894      MVNS     R8,#+148
   \      0x1AA   0xE00D             B.N      ??sli_se_verify_message_18
    687            } else if (status == SL_STATUS_FAIL) {
   \                     ??sli_se_verify_message_19: (+1)
   \      0x1AC   0xF1BB 0x0F01      CMP      R11,#+1
   \      0x1B0   0xD102             BNE.N    ??sli_se_verify_message_20
    688              // Built-in key does not exist.
    689              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   \      0x1B2   0xF07F 0x088B      MVNS     R8,#+139
   \      0x1B6   0xE007             B.N      ??sli_se_verify_message_18
    690            } else if (status == SL_STATUS_COMMAND_IS_INVALID) {
   \                     ??sli_se_verify_message_20: (+1)
   \      0x1B8   0xF1BB 0x0F48      CMP      R11,#+72
   \      0x1BC   0xD102             BNE.N    ??sli_se_verify_message_21
    691              // Key type is not supported.
    692              psa_status = PSA_ERROR_NOT_SUPPORTED;
   \      0x1BE   0xF07F 0x0885      MVNS     R8,#+133
   \      0x1C2   0xE001             B.N      ??sli_se_verify_message_18
    693            } else {
    694              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_verify_message_21: (+1)
   \      0x1C4   0xF07F 0x0892      MVNS     R8,#+146
    695            }
    696          
    697            // Cleanup
    698            status = sl_se_deinit_command_context(&cmd_ctx);
   \                     ??sli_se_verify_message_18: (+1)
   \      0x1C8   0xA815             ADD      R0,SP,#+84
   \      0x1CA   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x1CE   0x0001             MOVS     R1,R0
    699            if (status != SL_STATUS_OK) {
   \      0x1D0   0x2900             CMP      R1,#+0
   \      0x1D2   0xD002             BEQ.N    ??sli_se_verify_message_22
    700              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x1D4   0xF07F 0x0092      MVNS     R0,#+146
   \      0x1D8   0xE000             B.N      ??sli_se_verify_message_3
    701            }
    702          
    703            return psa_status;
   \                     ??sli_se_verify_message_22: (+1)
   \      0x1DA   0x4640             MOV      R0,R8
   \                     ??sli_se_verify_message_3: (+1)
   \      0x1DC   0xB043             ADD      SP,SP,#+268
   \      0x1DE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    704          
    705            #else // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    706          
    707            (void) attributes;
    708            (void) key_buffer;
    709            (void) key_buffer_size;
    710            (void) alg;
    711            (void) input;
    712            (void) input_length;
    713            (void) signature;
    714            (void) signature_length;
    715          
    716            return PSA_ERROR_NOT_SUPPORTED;
    717          
    718            #endif  // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    719          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    720          

   \                                 In section .text, align 2, keep-with-next
    721          static psa_status_t sli_se_verify_hash(
    722            const psa_key_attributes_t *attributes,
    723            const uint8_t *key_buffer,
    724            size_t key_buffer_size,
    725            psa_algorithm_t alg,
    726            const uint8_t *hash,
    727            size_t hash_length,
    728            const uint8_t *signature,
    729            size_t signature_length)
    730          {
   \                     sli_se_verify_hash: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB0C0             SUB      SP,SP,#+256
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x9D4C             LDR      R5,[SP, #+304]
   \        0xA   0x9E4D             LDR      R6,[SP, #+308]
   \        0xC   0x9F4E             LDR      R7,[SP, #+312]
   \        0xE   0xF8DD 0x813C      LDR      R8,[SP, #+316]
    731            #if defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    732          
    733            // Argument check.
    734            if (attributes == NULL
    735                || key_buffer == NULL
    736                || key_buffer_size == 0
    737                || hash == NULL
    738                || hash_length == 0
    739                || signature == NULL) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD00B             BEQ.N    ??sli_se_verify_hash_0
   \       0x16   0x9840             LDR      R0,[SP, #+256]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD008             BEQ.N    ??sli_se_verify_hash_0
   \       0x1C   0x9841             LDR      R0,[SP, #+260]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD005             BEQ.N    ??sli_se_verify_hash_0
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD003             BEQ.N    ??sli_se_verify_hash_0
   \       0x26   0x2E00             CMP      R6,#+0
   \       0x28   0xD001             BEQ.N    ??sli_se_verify_hash_0
   \       0x2A   0x2F00             CMP      R7,#+0
   \       0x2C   0xD102             BNE.N    ??sli_se_verify_hash_1
    740              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_verify_hash_0: (+1)
   \       0x2E   0xF07F 0x0086      MVNS     R0,#+134
   \       0x32   0xE0B7             B.N      ??sli_se_verify_hash_2
    741            }
    742          
    743            if (signature_length == 0) {
   \                     ??sli_se_verify_hash_1: (+1)
   \       0x34   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x38   0xD102             BNE.N    ??sli_se_verify_hash_3
    744              return PSA_ERROR_INVALID_SIGNATURE;
   \       0x3A   0xF07F 0x0094      MVNS     R0,#+148
   \       0x3E   0xE0B1             B.N      ??sli_se_verify_hash_2
    745            }
    746          
    747            // Check the requested algorithm is ECDSA with randomized k
    748            if (!PSA_ALG_IS_RANDOMIZED_ECDSA(alg)) {
   \                     ??sli_se_verify_hash_3: (+1)
   \       0x40   0x9842             LDR      R0,[SP, #+264]
   \       0x42   0x0A00             LSRS     R0,R0,#+8
   \       0x44   0x0200             LSLS     R0,R0,#+8
   \       0x46   0xF1B0 0x2F06      CMP      R0,#+100664832
   \       0x4A   0xD002             BEQ.N    ??sli_se_verify_hash_4
    749              return PSA_ERROR_NOT_SUPPORTED;
   \       0x4C   0xF07F 0x0085      MVNS     R0,#+133
   \       0x50   0xE0A8             B.N      ??sli_se_verify_hash_2
    750            }
    751          
    752            // Ephemeral contexts
    753            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_verify_hash_4: (+1)
   \       0x52   0xA815             ADD      R0,SP,#+84
   \       0x54   0x2124             MOVS     R1,#+36
   \       0x56   0x.... 0x....      BL       __aeabi_memclr4
    754            sl_se_key_descriptor_t key_desc = { 0 };
   \       0x5A   0xA80D             ADD      R0,SP,#+52
   \       0x5C   0x2120             MOVS     R1,#+32
   \       0x5E   0x.... 0x....      BL       __aeabi_memclr4
    755          
    756            psa_status_t psa_status = sli_se_key_desc_from_input(attributes,
    757                                                                 key_buffer,
    758                                                                 key_buffer_size,
    759                                                                 &key_desc);
   \       0x62   0xAB0D             ADD      R3,SP,#+52
   \       0x64   0x9A41             LDR      R2,[SP, #+260]
   \       0x66   0x9940             LDR      R1,[SP, #+256]
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x6E   0x4681             MOV      R9,R0
    760            if (psa_status != PSA_SUCCESS) {
   \       0x70   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x74   0xD001             BEQ.N    ??sli_se_verify_hash_5
    761              return psa_status;
   \       0x76   0x4648             MOV      R0,R9
   \       0x78   0xE094             B.N      ??sli_se_verify_hash_2
    762            }
    763          
    764            // Verify and set key attributes
    765            if (signature_length
    766                != PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes))) {
   \                     ??sli_se_verify_hash_5: (+1)
   \       0x7A   0x0020             MOVS     R0,R4
   \       0x7C   0x.... 0x....      BL       psa_get_key_bits
   \       0x80   0x1DC0             ADDS     R0,R0,#+7
   \       0x82   0x08C0             LSRS     R0,R0,#+3
   \       0x84   0xEBB8 0x0F40      CMP      R8,R0, LSL #+1
   \       0x88   0xD002             BEQ.N    ??sli_se_verify_hash_6
    767              return PSA_ERROR_INVALID_SIGNATURE;
   \       0x8A   0xF07F 0x0094      MVNS     R0,#+148
   \       0x8E   0xE089             B.N      ??sli_se_verify_hash_2
    768            }
    769            psa_status = check_curve_availability(attributes, alg);
   \                     ??sli_se_verify_hash_6: (+1)
   \       0x90   0x9942             LDR      R1,[SP, #+264]
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x.... 0x....      BL       check_curve_availability
   \       0x98   0x4683             MOV      R11,R0
    770            if (psa_status != PSA_SUCCESS) {
   \       0x9A   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x9E   0xD001             BEQ.N    ??sli_se_verify_hash_7
    771              return psa_status;
   \       0xA0   0x4658             MOV      R0,R11
   \       0xA2   0xE07F             B.N      ??sli_se_verify_hash_2
    772            }
   \                     ??sli_se_verify_hash_7: (+1)
   \       0xA4   0x2188             MOVS     R1,#+136
   \       0xA6   0x2200             MOVS     R2,#+0
   \       0xA8   0xA81E             ADD      R0,SP,#+120
   \       0xAA   0x.... 0x....      BL       __aeabi_memset
    773          
    774            uint8_t temp_key_buf[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
    775            psa_key_type_t keytype = psa_get_key_type(attributes);
   \       0xAE   0x0020             MOVS     R0,R4
   \       0xB0   0x.... 0x....      BL       psa_get_key_type
   \       0xB4   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    776          
    777            #if defined(SLI_SE_KEY_PADDING_REQUIRED) && defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    778            // P-521 (or any curve size that's not word-multiple) requires alignment on word
    779            // boundaries, instead of byte boundaries such as PSA Crypto defines as input here.
    780            uint8_t temp_signature_buffer[SLI_SE_MAX_PADDED_SIGNATURE_SIZE] = { 0 };
    781            size_t key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
    782            size_t offset = sli_se_get_padding(key_size);
    783            if (offset > 0) {
    784              psa_key_location_t location =
    785                PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
    786          
    787              // Only pad transparent keys.
    788              if (location == PSA_KEY_LOCATION_LOCAL_STORAGE) {
    789                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
    790                  if (offset + key_size > sizeof(temp_key_buf)) {
    791                    return PSA_ERROR_INVALID_ARGUMENT;
    792                  }
    793                  sli_se_pad_big_endian(temp_key_buf,
    794                                        key_desc.storage.location.buffer.pointer,
    795                                        key_size);
    796                } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(keytype)) {
    797                  if ((2 * (offset + key_size)) > sizeof(temp_key_buf)) {
    798                    return PSA_ERROR_INVALID_ARGUMENT;
    799                  }
    800                  sli_se_pad_curve_point(temp_key_buf,
    801                                         key_desc.storage.location.buffer.pointer,
    802                                         key_size);
    803                } else {
    804                  return PSA_ERROR_CORRUPTION_DETECTED;
    805                }
    806                key_desc.storage.location.buffer.pointer = temp_key_buf;
    807                key_desc.storage.location.buffer.size = sizeof(temp_key_buf);
    808              }
    809          
    810              // Always pad signature
    811              if ((2 * (offset + key_size)) > sizeof(temp_signature_buffer)) {
    812                return PSA_ERROR_INVALID_ARGUMENT;
    813              }
    814              sli_se_pad_curve_point(temp_signature_buffer, signature, key_size);
    815          
    816              signature = temp_signature_buffer;
    817              signature_length = signature_length + 2 * offset;
    818            }
    819            #endif   // SLI_SE_KEY_PADDING_REQUIRED && SLI_PSA_DRIVER_FEATURE_ECDSA
    820          
    821            // SE manager only accepts public keys for signature verification,
    822            // so we must generate a public key if we are passed a private one
    823            sl_status_t status = SL_STATUS_INVALID_PARAMETER;
   \       0xB8   0xF05F 0x0921      MOVS     R9,#+33
    824            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
   \       0xBC   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \       0xC0   0xF030 0x00FF      BICS     R0,R0,#0xFF
   \       0xC4   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0xC8   0xD138             BNE.N    ??sli_se_verify_hash_8
    825              sl_se_key_descriptor_t pubkey_desc = key_desc;
   \       0xCA   0xA805             ADD      R0,SP,#+20
   \       0xCC   0xA90D             ADD      R1,SP,#+52
   \       0xCE   0x2220             MOVS     R2,#+32
   \       0xD0   0x.... 0x....      BL       __aeabi_memcpy4
    826              // Unset private key flag and set public
    827              pubkey_desc.flags &= ~SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
   \       0xD4   0x9807             LDR      R0,[SP, #+28]
   \       0xD6   0xF430 0x4080      BICS     R0,R0,#0x4000
   \       0xDA   0x9007             STR      R0,[SP, #+28]
    828              pubkey_desc.flags &= ~SL_SE_KEY_FLAG_IS_RESTRICTED;
   \       0xDC   0x9807             LDR      R0,[SP, #+28]
   \       0xDE   0xF030 0x7040      BICS     R0,R0,#0x3000000
   \       0xE2   0x9007             STR      R0,[SP, #+28]
    829              pubkey_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \       0xE4   0x9807             LDR      R0,[SP, #+28]
   \       0xE6   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0xEA   0x9007             STR      R0,[SP, #+28]
    830              sli_se_key_descriptor_set_plaintext(&pubkey_desc, temp_key_buf, sizeof(temp_key_buf));
   \       0xEC   0x2288             MOVS     R2,#+136
   \       0xEE   0xA91E             ADD      R1,SP,#+120
   \       0xF0   0xA805             ADD      R0,SP,#+20
   \       0xF2   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
    831              // Same input output region
    832              status = sl_se_init_command_context(&cmd_ctx);
   \       0xF6   0xA815             ADD      R0,SP,#+84
   \       0xF8   0x.... 0x....      BL       sl_se_init_command_context
   \       0xFC   0x4682             MOV      R10,R0
    833              if (status != SL_STATUS_OK) {
   \       0xFE   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x102   0xD002             BEQ.N    ??sli_se_verify_hash_9
    834                return PSA_ERROR_HARDWARE_FAILURE;
   \      0x104   0xF07F 0x0092      MVNS     R0,#+146
   \      0x108   0xE04C             B.N      ??sli_se_verify_hash_2
    835              }
    836              status = sl_se_export_public_key(&cmd_ctx, &key_desc, &pubkey_desc);
   \                     ??sli_se_verify_hash_9: (+1)
   \      0x10A   0xAA05             ADD      R2,SP,#+20
   \      0x10C   0xA90D             ADD      R1,SP,#+52
   \      0x10E   0xA815             ADD      R0,SP,#+84
   \      0x110   0x.... 0x....      BL       sl_se_export_public_key
   \      0x114   0x4681             MOV      R9,R0
    837              if (sl_se_deinit_command_context(&cmd_ctx) != SL_STATUS_OK) {
   \      0x116   0xA815             ADD      R0,SP,#+84
   \      0x118   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD002             BEQ.N    ??sli_se_verify_hash_10
    838                return PSA_ERROR_HARDWARE_FAILURE;
   \      0x120   0xF07F 0x0092      MVNS     R0,#+146
   \      0x124   0xE03E             B.N      ??sli_se_verify_hash_2
    839              }
    840              if (status) {
   \                     ??sli_se_verify_hash_10: (+1)
   \      0x126   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x12A   0xD002             BEQ.N    ??sli_se_verify_hash_11
    841                return PSA_ERROR_HARDWARE_FAILURE;
   \      0x12C   0xF07F 0x0092      MVNS     R0,#+146
   \      0x130   0xE038             B.N      ??sli_se_verify_hash_2
    842              }
    843              // Set the key desc to the public key, and go on
    844              key_desc = pubkey_desc;
   \                     ??sli_se_verify_hash_11: (+1)
   \      0x132   0xA80D             ADD      R0,SP,#+52
   \      0x134   0xA905             ADD      R1,SP,#+20
   \      0x136   0x2220             MOVS     R2,#+32
   \      0x138   0x.... 0x....      BL       __aeabi_memcpy4
    845            }
    846          
    847            status = sl_se_init_command_context(&cmd_ctx);
   \                     ??sli_se_verify_hash_8: (+1)
   \      0x13C   0xA815             ADD      R0,SP,#+84
   \      0x13E   0x.... 0x....      BL       sl_se_init_command_context
   \      0x142   0x4682             MOV      R10,R0
    848            if (status != SL_STATUS_OK) {
   \      0x144   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x148   0xD002             BEQ.N    ??sli_se_verify_hash_12
    849              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x14A   0xF07F 0x0092      MVNS     R0,#+146
   \      0x14E   0xE029             B.N      ??sli_se_verify_hash_2
    850            }
    851          
    852            // Run signature verification
    853            status = sl_se_ecc_verify(&cmd_ctx,
    854                                      &key_desc,
    855                                      SL_SE_HASH_NONE,
    856                                      true,
    857                                      hash,
    858                                      hash_length,
    859                                      signature,
    860                                      signature_length);
   \                     ??sli_se_verify_hash_12: (+1)
   \      0x150   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \      0x154   0x9702             STR      R7,[SP, #+8]
   \      0x156   0x9601             STR      R6,[SP, #+4]
   \      0x158   0x9500             STR      R5,[SP, #+0]
   \      0x15A   0x2301             MOVS     R3,#+1
   \      0x15C   0x2200             MOVS     R2,#+0
   \      0x15E   0xA90D             ADD      R1,SP,#+52
   \      0x160   0xA815             ADD      R0,SP,#+84
   \      0x162   0x.... 0x....      BL       sl_se_ecc_verify
   \      0x166   0x4681             MOV      R9,R0
    861          
    862            if (status == SL_STATUS_OK) {
   \      0x168   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x16C   0xD102             BNE.N    ??sli_se_verify_hash_13
    863              psa_status = PSA_SUCCESS;
   \      0x16E   0xF05F 0x0A00      MOVS     R10,#+0
   \      0x172   0xE00D             B.N      ??sli_se_verify_hash_14
    864            } else if (status == SL_STATUS_INVALID_SIGNATURE) {
   \                     ??sli_se_verify_hash_13: (+1)
   \      0x174   0xF1B9 0x0F2C      CMP      R9,#+44
   \      0x178   0xD102             BNE.N    ??sli_se_verify_hash_15
    865              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   \      0x17A   0xF07F 0x0A94      MVNS     R10,#+148
   \      0x17E   0xE007             B.N      ??sli_se_verify_hash_14
    866            } else if (status == SL_STATUS_FAIL) {
   \                     ??sli_se_verify_hash_15: (+1)
   \      0x180   0xF1B9 0x0F01      CMP      R9,#+1
   \      0x184   0xD102             BNE.N    ??sli_se_verify_hash_16
    867              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   \      0x186   0xF07F 0x0A8B      MVNS     R10,#+139
   \      0x18A   0xE001             B.N      ??sli_se_verify_hash_14
    868            } else {
    869              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_verify_hash_16: (+1)
   \      0x18C   0xF07F 0x0A92      MVNS     R10,#+146
    870            }
    871          
    872            // Cleanup
    873            status = sl_se_deinit_command_context(&cmd_ctx);
   \                     ??sli_se_verify_hash_14: (+1)
   \      0x190   0xA815             ADD      R0,SP,#+84
   \      0x192   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x196   0x0001             MOVS     R1,R0
    874            if (status != SL_STATUS_OK) {
   \      0x198   0x2900             CMP      R1,#+0
   \      0x19A   0xD002             BEQ.N    ??sli_se_verify_hash_17
    875              return PSA_ERROR_HARDWARE_FAILURE;
   \      0x19C   0xF07F 0x0092      MVNS     R0,#+146
   \      0x1A0   0xE000             B.N      ??sli_se_verify_hash_2
    876            }
    877          
    878            return psa_status;
   \                     ??sli_se_verify_hash_17: (+1)
   \      0x1A2   0x4650             MOV      R0,R10
   \                     ??sli_se_verify_hash_2: (+1)
   \      0x1A4   0xB043             ADD      SP,SP,#+268
   \      0x1A6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    879          
    880            #else // SLI_PSA_DRIVER_FEATURE_ECDSA
    881          
    882            (void) attributes;
    883            (void) key_buffer;
    884            (void) key_buffer_size;
    885            (void) alg;
    886            (void) hash;
    887            (void) hash_length;
    888            (void) signature;
    889            (void) signature_length;
    890          
    891            return PSA_ERROR_NOT_SUPPORTED;
    892          
    893            #endif // SLI_PSA_DRIVER_FEATURE_ECDSA
    894          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    895          
    896          // -----------------------------------------------------------------------------
    897          // Opaque driver entry points
    898          

   \                                 In section .text, align 2, keep-with-next
    899          psa_status_t sli_se_opaque_sign_message(const psa_key_attributes_t *attributes,
    900                                                  const uint8_t *key_buffer,
    901                                                  size_t key_buffer_size,
    902                                                  psa_algorithm_t alg,
    903                                                  const uint8_t *input,
    904                                                  size_t input_length,
    905                                                  uint8_t *signature,
    906                                                  size_t signature_size,
    907                                                  size_t *signature_length)
    908          {
   \                     sli_se_opaque_sign_message: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    909            return sli_se_sign_message(attributes,
    910                                       key_buffer,
    911                                       key_buffer_size,
    912                                       alg,
    913                                       input,
    914                                       input_length,
    915                                       signature,
    916                                       signature_size,
    917                                       signature_length);
   \        0xC   0x980E             LDR      R0,[SP, #+56]
   \        0xE   0x9004             STR      R0,[SP, #+16]
   \       0x10   0x980D             LDR      R0,[SP, #+52]
   \       0x12   0x9003             STR      R0,[SP, #+12]
   \       0x14   0x980C             LDR      R0,[SP, #+48]
   \       0x16   0x9002             STR      R0,[SP, #+8]
   \       0x18   0x980B             LDR      R0,[SP, #+44]
   \       0x1A   0x9001             STR      R0,[SP, #+4]
   \       0x1C   0x980A             LDR      R0,[SP, #+40]
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   \       0x20   0x003B             MOVS     R3,R7
   \       0x22   0x0032             MOVS     R2,R6
   \       0x24   0x0029             MOVS     R1,R5
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       sli_se_sign_message
   \       0x2C   0xB005             ADD      SP,SP,#+20
   \       0x2E   0xBDF0             POP      {R4-R7,PC}
    918          }
    919          

   \                                 In section .text, align 2, keep-with-next
    920          psa_status_t sli_se_opaque_sign_hash(const psa_key_attributes_t *attributes,
    921                                               const uint8_t *key_buffer,
    922                                               size_t key_buffer_size,
    923                                               psa_algorithm_t alg,
    924                                               const uint8_t *hash,
    925                                               size_t hash_length,
    926                                               uint8_t *signature,
    927                                               size_t signature_size,
    928                                               size_t *signature_length)
    929          {
   \                     sli_se_opaque_sign_hash: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    930            return sli_se_sign_hash(attributes,
    931                                    key_buffer,
    932                                    key_buffer_size,
    933                                    alg,
    934                                    hash,
    935                                    hash_length,
    936                                    signature,
    937                                    signature_size,
    938                                    signature_length);
   \        0xC   0x980E             LDR      R0,[SP, #+56]
   \        0xE   0x9004             STR      R0,[SP, #+16]
   \       0x10   0x980D             LDR      R0,[SP, #+52]
   \       0x12   0x9003             STR      R0,[SP, #+12]
   \       0x14   0x980C             LDR      R0,[SP, #+48]
   \       0x16   0x9002             STR      R0,[SP, #+8]
   \       0x18   0x980B             LDR      R0,[SP, #+44]
   \       0x1A   0x9001             STR      R0,[SP, #+4]
   \       0x1C   0x980A             LDR      R0,[SP, #+40]
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   \       0x20   0x003B             MOVS     R3,R7
   \       0x22   0x0032             MOVS     R2,R6
   \       0x24   0x0029             MOVS     R1,R5
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       sli_se_sign_hash
   \       0x2C   0xB005             ADD      SP,SP,#+20
   \       0x2E   0xBDF0             POP      {R4-R7,PC}
    939          }
    940          

   \                                 In section .text, align 2, keep-with-next
    941          psa_status_t sli_se_opaque_verify_message(const psa_key_attributes_t *attributes,
    942                                                    const uint8_t *key_buffer,
    943                                                    size_t key_buffer_size,
    944                                                    psa_algorithm_t alg,
    945                                                    const uint8_t * input,
    946                                                    size_t input_length,
    947                                                    const uint8_t * signature,
    948                                                    size_t signature_length)
    949          {
   \                     sli_se_opaque_verify_message: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    950            return sli_se_verify_message(attributes,
    951                                         key_buffer,
    952                                         key_buffer_size,
    953                                         alg,
    954                                         input,
    955                                         input_length,
    956                                         signature,
    957                                         signature_length);
   \        0xC   0x980D             LDR      R0,[SP, #+52]
   \        0xE   0x9003             STR      R0,[SP, #+12]
   \       0x10   0x980C             LDR      R0,[SP, #+48]
   \       0x12   0x9002             STR      R0,[SP, #+8]
   \       0x14   0x980B             LDR      R0,[SP, #+44]
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x980A             LDR      R0,[SP, #+40]
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x003B             MOVS     R3,R7
   \       0x1E   0x0032             MOVS     R2,R6
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       sli_se_verify_message
   \       0x28   0xB005             ADD      SP,SP,#+20
   \       0x2A   0xBDF0             POP      {R4-R7,PC}
    958          }
    959          

   \                                 In section .text, align 2, keep-with-next
    960          psa_status_t sli_se_opaque_verify_hash(const psa_key_attributes_t *attributes,
    961                                                 const uint8_t *key_buffer,
    962                                                 size_t key_buffer_size,
    963                                                 psa_algorithm_t alg,
    964                                                 const uint8_t *hash,
    965                                                 size_t hash_length,
    966                                                 const uint8_t *signature,
    967                                                 size_t signature_length)
    968          {
   \                     sli_se_opaque_verify_hash: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    969            return sli_se_verify_hash(attributes,
    970                                      key_buffer,
    971                                      key_buffer_size,
    972                                      alg,
    973                                      hash,
    974                                      hash_length,
    975                                      signature,
    976                                      signature_length);
   \        0xC   0x980D             LDR      R0,[SP, #+52]
   \        0xE   0x9003             STR      R0,[SP, #+12]
   \       0x10   0x980C             LDR      R0,[SP, #+48]
   \       0x12   0x9002             STR      R0,[SP, #+8]
   \       0x14   0x980B             LDR      R0,[SP, #+44]
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x980A             LDR      R0,[SP, #+40]
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x003B             MOVS     R3,R7
   \       0x1E   0x0032             MOVS     R2,R6
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       sli_se_verify_hash
   \       0x28   0xB005             ADD      SP,SP,#+20
   \       0x2A   0xBDF0             POP      {R4-R7,PC}
    977          }
    978          
    979          // -----------------------------------------------------------------------------
    980          // Transparent driver entry points
    981          

   \                                 In section .text, align 2, keep-with-next
    982          psa_status_t sli_se_transparent_sign_message(
    983            const psa_key_attributes_t *attributes,
    984            const uint8_t *key_buffer,
    985            size_t key_buffer_size,
    986            psa_algorithm_t alg,
    987            const uint8_t *input,
    988            size_t input_length,
    989            uint8_t *signature,
    990            size_t signature_size,
    991            size_t *signature_length)
    992          {
   \                     sli_se_transparent_sign_message: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    993            return sli_se_sign_message(attributes,
    994                                       key_buffer,
    995                                       key_buffer_size,
    996                                       alg,
    997                                       input,
    998                                       input_length,
    999                                       signature,
   1000                                       signature_size,
   1001                                       signature_length);
   \        0xC   0x980E             LDR      R0,[SP, #+56]
   \        0xE   0x9004             STR      R0,[SP, #+16]
   \       0x10   0x980D             LDR      R0,[SP, #+52]
   \       0x12   0x9003             STR      R0,[SP, #+12]
   \       0x14   0x980C             LDR      R0,[SP, #+48]
   \       0x16   0x9002             STR      R0,[SP, #+8]
   \       0x18   0x980B             LDR      R0,[SP, #+44]
   \       0x1A   0x9001             STR      R0,[SP, #+4]
   \       0x1C   0x980A             LDR      R0,[SP, #+40]
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   \       0x20   0x003B             MOVS     R3,R7
   \       0x22   0x0032             MOVS     R2,R6
   \       0x24   0x0029             MOVS     R1,R5
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       sli_se_sign_message
   \       0x2C   0xB005             ADD      SP,SP,#+20
   \       0x2E   0xBDF0             POP      {R4-R7,PC}
   1002          }
   1003          

   \                                 In section .text, align 2, keep-with-next
   1004          psa_status_t sli_se_transparent_sign_hash(const psa_key_attributes_t *attributes,
   1005                                                    const uint8_t *key_buffer,
   1006                                                    size_t key_buffer_size,
   1007                                                    psa_algorithm_t alg,
   1008                                                    const uint8_t *hash,
   1009                                                    size_t hash_length,
   1010                                                    uint8_t *signature,
   1011                                                    size_t signature_size,
   1012                                                    size_t *signature_length)
   1013          {
   \                     sli_se_transparent_sign_hash: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1014            return sli_se_sign_hash(attributes,
   1015                                    key_buffer,
   1016                                    key_buffer_size,
   1017                                    alg,
   1018                                    hash,
   1019                                    hash_length,
   1020                                    signature,
   1021                                    signature_size,
   1022                                    signature_length);
   \        0xC   0x980E             LDR      R0,[SP, #+56]
   \        0xE   0x9004             STR      R0,[SP, #+16]
   \       0x10   0x980D             LDR      R0,[SP, #+52]
   \       0x12   0x9003             STR      R0,[SP, #+12]
   \       0x14   0x980C             LDR      R0,[SP, #+48]
   \       0x16   0x9002             STR      R0,[SP, #+8]
   \       0x18   0x980B             LDR      R0,[SP, #+44]
   \       0x1A   0x9001             STR      R0,[SP, #+4]
   \       0x1C   0x980A             LDR      R0,[SP, #+40]
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   \       0x20   0x003B             MOVS     R3,R7
   \       0x22   0x0032             MOVS     R2,R6
   \       0x24   0x0029             MOVS     R1,R5
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       sli_se_sign_hash
   \       0x2C   0xB005             ADD      SP,SP,#+20
   \       0x2E   0xBDF0             POP      {R4-R7,PC}
   1023          }
   1024          

   \                                 In section .text, align 2, keep-with-next
   1025          psa_status_t sli_se_transparent_verify_message(
   1026            const psa_key_attributes_t *attributes,
   1027            const uint8_t *key_buffer,
   1028            size_t key_buffer_size,
   1029            psa_algorithm_t alg,
   1030            const uint8_t *input,
   1031            size_t input_length,
   1032            const uint8_t *signature,
   1033            size_t signature_length)
   1034          {
   \                     sli_se_transparent_verify_message: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1035            return sli_se_verify_message(attributes,
   1036                                         key_buffer,
   1037                                         key_buffer_size,
   1038                                         alg,
   1039                                         input,
   1040                                         input_length,
   1041                                         signature,
   1042                                         signature_length);
   \        0xC   0x980D             LDR      R0,[SP, #+52]
   \        0xE   0x9003             STR      R0,[SP, #+12]
   \       0x10   0x980C             LDR      R0,[SP, #+48]
   \       0x12   0x9002             STR      R0,[SP, #+8]
   \       0x14   0x980B             LDR      R0,[SP, #+44]
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x980A             LDR      R0,[SP, #+40]
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x003B             MOVS     R3,R7
   \       0x1E   0x0032             MOVS     R2,R6
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       sli_se_verify_message
   \       0x28   0xB005             ADD      SP,SP,#+20
   \       0x2A   0xBDF0             POP      {R4-R7,PC}
   1043          }
   1044          

   \                                 In section .text, align 2, keep-with-next
   1045          psa_status_t sli_se_transparent_verify_hash(
   1046            const psa_key_attributes_t *attributes,
   1047            const uint8_t *key_buffer,
   1048            size_t key_buffer_size,
   1049            psa_algorithm_t alg,
   1050            const uint8_t *hash,
   1051            size_t hash_length,
   1052            const uint8_t *signature,
   1053            size_t signature_length)
   1054          {
   \                     sli_se_transparent_verify_hash: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1055            return sli_se_verify_hash(attributes,
   1056                                      key_buffer,
   1057                                      key_buffer_size,
   1058                                      alg,
   1059                                      hash,
   1060                                      hash_length,
   1061                                      signature,
   1062                                      signature_length);
   \        0xC   0x980D             LDR      R0,[SP, #+52]
   \        0xE   0x9003             STR      R0,[SP, #+12]
   \       0x10   0x980C             LDR      R0,[SP, #+48]
   \       0x12   0x9002             STR      R0,[SP, #+8]
   \       0x14   0x980B             LDR      R0,[SP, #+44]
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x980A             LDR      R0,[SP, #+40]
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x003B             MOVS     R3,R7
   \       0x1E   0x0032             MOVS     R2,R6
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       sli_se_verify_hash
   \       0x28   0xB005             ADD      SP,SP,#+20
   \       0x2A   0xBDF0             POP      {R4-R7,PC}
   1063          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x0600'0300        DC32     0x6000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x0600'1300        DC32     0x6001300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x0600'0200        DC32     0x6000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x0600'0900        DC32     0x6000900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x0600'0400        DC32     0x6000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x0200'0005        DC32     0x2000005
   1064          
   1065          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   check_curve_availability
        24   -> psa_get_key_bits
        24   -> psa_get_key_type
       0   get_hash_for_algorithm
       0   psa_get_key_bits
       0   psa_get_key_type
       0   sli_se_key_descriptor_set_plaintext
      40   sli_se_opaque_sign_hash
        40   -> sli_se_sign_hash
      40   sli_se_opaque_sign_message
        40   -> sli_se_sign_message
      40   sli_se_opaque_verify_hash
        40   -> sli_se_verify_hash
      40   sli_se_opaque_verify_message
        40   -> sli_se_verify_message
     144   sli_se_sign_hash
       144   -> __aeabi_memclr4
       144   -> check_curve_availability
       144   -> psa_get_key_bits
       144   -> psa_get_key_type
       144   -> sl_se_deinit_command_context
       144   -> sl_se_ecc_sign
       144   -> sl_se_init_command_context
       144   -> sli_se_key_desc_from_input
     136   sli_se_sign_message
       136   -> __aeabi_memclr4
       136   -> check_curve_availability
       136   -> get_hash_for_algorithm
       136   -> psa_get_key_bits
       136   -> psa_get_key_type
       136   -> sl_se_deinit_command_context
       136   -> sl_se_ecc_sign
       136   -> sl_se_init_command_context
       136   -> sli_se_key_desc_from_input
      40   sli_se_transparent_sign_hash
        40   -> sli_se_sign_hash
      40   sli_se_transparent_sign_message
        40   -> sli_se_sign_message
      40   sli_se_transparent_verify_hash
        40   -> sli_se_verify_hash
      40   sli_se_transparent_verify_message
        40   -> sli_se_verify_message
     304   sli_se_verify_hash
       304   -> __aeabi_memclr4
       304   -> __aeabi_memcpy4
       304   -> __aeabi_memset
       304   -> check_curve_availability
       304   -> psa_get_key_bits
       304   -> psa_get_key_type
       304   -> sl_se_deinit_command_context
       304   -> sl_se_ecc_verify
       304   -> sl_se_export_public_key
       304   -> sl_se_init_command_context
       304   -> sli_se_key_desc_from_input
       304   -> sli_se_key_descriptor_set_plaintext
     304   sli_se_verify_message
       304   -> __aeabi_memclr4
       304   -> __aeabi_memcpy4
       304   -> __aeabi_memset
       304   -> check_curve_availability
       304   -> get_hash_for_algorithm
       304   -> psa_get_key_bits
       304   -> psa_get_key_type
       304   -> sl_se_deinit_command_context
       304   -> sl_se_ecc_verify
       304   -> sl_se_export_public_key
       304   -> sl_se_init_command_context
       304   -> sli_se_key_desc_from_input
       304   -> sli_se_key_descriptor_set_plaintext


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
      36  ?_0
      32  ?_1
      36  ?_2
      32  ?_3
      36  ?_4
      32  ?_5
      36  ?_6
      32  ?_7
     152  check_curve_availability
     110  get_hash_for_algorithm
       4  psa_get_key_bits
       4  psa_get_key_type
      16  sli_se_key_descriptor_set_plaintext
      48  sli_se_opaque_sign_hash
      48  sli_se_opaque_sign_message
      44  sli_se_opaque_verify_hash
      44  sli_se_opaque_verify_message
     352  sli_se_sign_hash
     370  sli_se_sign_message
      48  sli_se_transparent_sign_hash
      48  sli_se_transparent_sign_message
      44  sli_se_transparent_verify_hash
      44  sli_se_transparent_verify_message
     426  sli_se_verify_hash
     482  sli_se_verify_message

 
   272 bytes in section .rodata
 2'312 bytes in section .text
 
 2'312 bytes of CODE  memory
   272 bytes of CONST memory

Errors: none
Warnings: none
