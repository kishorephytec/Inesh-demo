###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:09
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_key_handling.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_key_handling.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_key_handling.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_10044205007528117694.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_key_handling.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_10044205007528117694.dir\sl_se_manager_key_handling.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_key_handling.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_key_handling.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs Secure Engine Manager key handling.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include <string.h>
     32          #include "sl_se_manager.h"
     33          
     34          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
     35          
     36          #include "sli_se_manager_internal.h"
     37          #include "sl_se_manager_key_handling.h"
     38          
     39          /***************************************************************************//**
     40           * \addtogroup sl_se_key SE key handling API
     41           * @{
     42           ******************************************************************************/
     43          
     44          // -----------------------------------------------------------------------------
     45          // Defines
     46          
     47          #define KEYSPEC_TYPE_MASK                   0xf0000000
     48          #define KEYSPEC_TYPE_OFFSET                 28
     49          #define KEYSPEC_TYPE_RAW                    (uint32_t)(0x0UL << KEYSPEC_TYPE_OFFSET)
     50          
     51          #define KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME  (uint32_t)(0x8UL << KEYSPEC_TYPE_OFFSET)
     52          
     53          #define KEYSPEC_MODE_MASK                   0x0c000000
     54          #define KEYSPEC_MODE_OFFSET                 26
     55          #define KEYSPEC_MODE_UNPROTECTED            (0UL << KEYSPEC_MODE_OFFSET)
     56          #define KEYSPEC_MODE_VOLATILE               (1UL << KEYSPEC_MODE_OFFSET)
     57          
     58          #define KEYSPEC_RESTRICTION_MASK            0x03000000U
     59          #define KEYSPEC_RESTRICTION_OFFSET          24U
     60          
     61          #define KEYSPEC_RESTRICTION_UNLOCKED        (0U << KEYSPEC_RESTRICTION_OFFSET)
     62          
     63          #define KEYSPEC_INDEX_MASK                  0x00ff0000U
     64          #define KEYSPEC_INDEX_OFFSET                16U
     65          
     66          #define KEYSPEC_TRANSFER_MODE_MASK          0x00000300U
     67          #define KEYSPEC_TRANSFER_MODE_OFFSET        8U
     68          #define KEYSPEC_TRANSFER_INDEX_MASK         0x000000ffU
     69          #define KEYSPEC_TRANSFER_INDEX_OFFSET       0U
     70          #define KEYSPEC_TRANSFER_PROT_BIT_MASK      0xffe00000U
     71          #define KEYSPEC_TRANSFER_PROT_BIT_OFFSET    21U
     72          
     73          #define KEYSPEC_NOPROT_MASK                 0x00008000U
     74          #define KEYSPEC_NOPROT_OFFSET               15U
     75          
     76          #define KEYSPEC_ATTRIBUTES_MASK             0x00007fffU
     77          #define KEYSPEC_ATTRIBUTES_OFFSET           0U
     78          
     79          #define KEYSPEC_ATTRIBUTES_ECC_PRIVATE_MASK (1U << 14)
     80          #define KEYSPEC_ATTRIBUTES_ECC_PUBLIC_MASK  (1U << 13)
     81          #define KEYSPEC_ATTRIBUTES_ECC_DOMAIN       (1U << 12)
     82          #define KEYSPEC_ATTRIBUTES_ECC_SIGN         (1U << 10)
     83          #define KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK    0x0000007fU
     84          
     85          #define KEYSPEC_TYPE_ECC_EDWARDS    ((uint32_t)(0xaUL << KEYSPEC_TYPE_OFFSET))
     86          #define KEYSPEC_TYPE_ECC_MONTGOMERY ((uint32_t)(0xbUL << KEYSPEC_TYPE_OFFSET))
     87          #define KEYSPEC_TYPE_ECC_EDDSA      ((uint32_t)(0xcUL << KEYSPEC_TYPE_OFFSET))
     88          
     89          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
     90          
     91            #define KEYSPEC_MODE_WRAPPED \
     92            (2UL << KEYSPEC_MODE_OFFSET)
     93          
     94            #define KEYSPEC_ECC_WEIERSTRASS_PRIME_A_IS_ZERO \
     95            (1U << 9)
     96            #define KEYSPEC_ECC_WEIERSTRASS_PRIME_A_IS_MINUS_THREE \
     97            (1U << 8)
     98          
     99          #endif
    100          
    101          #define KEYSPEC_RESTRICTION_LOCKED          (1UL << KEYSPEC_RESTRICTION_OFFSET)
    102          #define KEYSPEC_RESTRICTION_INTERNAL        (2UL << KEYSPEC_RESTRICTION_OFFSET)
    103          #define KEYSPEC_RESTRICTION_RESTRICTED      (3UL << KEYSPEC_RESTRICTION_OFFSET)
    104          
    105          // -----------------------------------------------------------------------------
    106          // Local Functions
    107          

   \                                 In section .text, align 2, keep-with-next
    108          sl_status_t sli_key_get_storage_size(const sl_se_key_descriptor_t* key,
    109                                               uint32_t *storage_size)
    110          {
   \                     sli_key_get_storage_size: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    111            if (key == NULL || storage_size == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??sli_key_get_storage_size_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??sli_key_get_storage_size_1
    112              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_key_get_storage_size_0: (+1)
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE05C             B.N      ??sli_key_get_storage_size_2
    113            }
    114          
    115            uint32_t key_size = 0;
   \                     ??sli_key_get_storage_size_1: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9000             STR      R0,[SP, #+0]
    116            sl_status_t status = sli_key_get_size(key, &key_size);
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       sli_key_get_size
   \       0x20   0x0001             MOVS     R1,R0
    117            if (status != SL_STATUS_OK) {
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD001             BEQ.N    ??sli_key_get_storage_size_3
    118              return status;
   \       0x26   0x0008             MOVS     R0,R1
   \       0x28   0xE051             B.N      ??sli_key_get_storage_size_2
    119            }
    120          
    121            uint32_t key_type = (key->type & KEYSPEC_TYPE_MASK);
   \                     ??sli_key_get_storage_size_3: (+1)
   \       0x2A   0x6822             LDR      R2,[R4, #+0]
   \       0x2C   0xF012 0x4270      ANDS     R2,R2,#0xF0000000
    122          
    123            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    124            // Round up to word length
    125            key_size = (key_size + 3U) & ~0x03U;
    126            #endif
    127          
    128            if (key_type == KEYSPEC_TYPE_RAW) {
   \       0x30   0x2A00             CMP      R2,#+0
   \       0x32   0xD103             BNE.N    ??sli_key_get_storage_size_4
    129              *storage_size = key_size;
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0x6028             STR      R0,[R5, #+0]
    130              return SL_STATUS_OK;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE048             B.N      ??sli_key_get_storage_size_2
    131            }
    132          
    133            bool has_private_key =
    134              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY) != 0);
   \                     ??sli_key_get_storage_size_4: (+1)
   \       0x3C   0x68A3             LDR      R3,[R4, #+8]
   \       0x3E   0x0B9B             LSRS     R3,R3,#+14
   \       0x40   0xF013 0x0301      ANDS     R3,R3,#0x1
    135            bool has_public_key =
    136              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY) != 0);
   \       0x44   0x68A6             LDR      R6,[R4, #+8]
   \       0x46   0x0B76             LSRS     R6,R6,#+13
   \       0x48   0xF016 0x0601      ANDS     R6,R6,#0x1
    137          
    138            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    139            bool has_custom_curve =
    140              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) != 0);
   \       0x4C   0x68A7             LDR      R7,[R4, #+8]
   \       0x4E   0x0B3F             LSRS     R7,R7,#+12
   \       0x50   0xF017 0x0701      ANDS     R7,R7,#0x1
    141            #else
    142            bool has_custom_curve = false;
    143            #endif
    144          
    145            if ((key_type == KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME)) {
   \       0x54   0xF1B2 0x4F00      CMP      R2,#+2147483648
   \       0x58   0xD111             BNE.N    ??sli_key_get_storage_size_5
    146              *storage_size = key_size * (1 * has_private_key + 2 * has_public_key + 6 * has_custom_curve);
   \       0x5A   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0x5E   0x0030             MOVS     R0,R6
   \       0x60   0xB2C0             UXTB     R0,R0
   \       0x62   0x0040             LSLS     R0,R0,#+1
   \       0x64   0xFA50 0xF883      UXTAB    R8,R0,R3
   \       0x68   0x46BE             MOV      LR,R7
   \       0x6A   0xFA5F 0xFE8E      UXTB     LR,LR
   \       0x6E   0x2006             MOVS     R0,#+6
   \       0x70   0xFB00 0x880E      MLA      R8,R0,LR,R8
   \       0x74   0xFB08 0xFC0C      MUL      R12,R8,R12
   \       0x78   0xF8C5 0xC000      STR      R12,[R5, #+0]
   \       0x7C   0xE026             B.N      ??sli_key_get_storage_size_6
    147            } else if (key_type == KEYSPEC_TYPE_ECC_EDWARDS) {
   \                     ??sli_key_get_storage_size_5: (+1)
   \       0x7E   0xF1B2 0x4F20      CMP      R2,#+2684354560
   \       0x82   0xD110             BNE.N    ??sli_key_get_storage_size_7
    148              *storage_size = key_size * (has_private_key + has_public_key + 5 * has_custom_curve);
   \       0x84   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0x88   0x0030             MOVS     R0,R6
   \       0x8A   0xB2C0             UXTB     R0,R0
   \       0x8C   0xFA50 0xF883      UXTAB    R8,R0,R3
   \       0x90   0x46BE             MOV      LR,R7
   \       0x92   0xFA5F 0xFE8E      UXTB     LR,LR
   \       0x96   0x2005             MOVS     R0,#+5
   \       0x98   0xFB00 0x880E      MLA      R8,R0,LR,R8
   \       0x9C   0xFB08 0xFC0C      MUL      R12,R8,R12
   \       0xA0   0xF8C5 0xC000      STR      R12,[R5, #+0]
   \       0xA4   0xE012             B.N      ??sli_key_get_storage_size_6
    149            } else if ((key_type == KEYSPEC_TYPE_ECC_MONTGOMERY)
    150                       || (key_type == KEYSPEC_TYPE_ECC_EDDSA)) {
   \                     ??sli_key_get_storage_size_7: (+1)
   \       0xA6   0xF1B2 0x4F30      CMP      R2,#+2952790016
   \       0xAA   0xD002             BEQ.N    ??sli_key_get_storage_size_8
   \       0xAC   0xF1B2 0x4F40      CMP      R2,#+3221225472
   \       0xB0   0xD10A             BNE.N    ??sli_key_get_storage_size_9
    151              *storage_size = key_size * (has_private_key + has_public_key);
   \                     ??sli_key_get_storage_size_8: (+1)
   \       0xB2   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0xB6   0x0030             MOVS     R0,R6
   \       0xB8   0xB2C0             UXTB     R0,R0
   \       0xBA   0xFA50 0xF083      UXTAB    R0,R0,R3
   \       0xBE   0xFB00 0xFC0C      MUL      R12,R0,R12
   \       0xC2   0xF8C5 0xC000      STR      R12,[R5, #+0]
   \       0xC6   0xE001             B.N      ??sli_key_get_storage_size_6
    152            } else {
    153              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_key_get_storage_size_9: (+1)
   \       0xC8   0x2021             MOVS     R0,#+33
   \       0xCA   0xE000             B.N      ??sli_key_get_storage_size_2
    154            }
    155          
    156            return SL_STATUS_OK;
   \                     ??sli_key_get_storage_size_6: (+1)
   \       0xCC   0x2000             MOVS     R0,#+0
   \                     ??sli_key_get_storage_size_2: (+1)
   \       0xCE   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    157          }
    158          
    159          #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    160          /***************************************************************************//**
    161           * @brief
    162           *   Clear the additional bytes of a key that is not word-aligned.
    163           *   Does nothing for aligned or asymmetric keys, or non-plaintext keys.
    164           *
    165           * @param key
    166           *   Key descriptor for the key.
    167           *
    168           * @returns
    169           *   Status code, @ref sl_status.h.
    170           ******************************************************************************/
    171          static sl_status_t clear_padding(const sl_se_key_descriptor_t *key)
    172          {
    173            if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT
    174                && (key->type & KEYSPEC_TYPE_MASK) == KEYSPEC_TYPE_RAW) {
    175              uint32_t key_size = 0;
    176              if (sli_key_get_size(key, &key_size) != SL_STATUS_OK) {
    177                return SL_STATUS_INVALID_PARAMETER;
    178              }
    179              if (key_size & 0x03) {
    180                if (key_size > key->storage.location.buffer.size) {
    181                  return SL_STATUS_WOULD_OVERFLOW;
    182                }
    183                uint8_t *padding_ptr = key->storage.location.buffer.pointer + key_size;
    184                uint32_t padding_size = (key->storage.location.buffer.size - key_size) & 0x3;
    185                memset(padding_ptr, 0, padding_size);
    186              }
    187            }
    188            return SL_STATUS_OK;
    189          }
    190          #endif
    191          
    192          // -----------------------------------------------------------------------------
    193          // Global Functions
    194          

   \                                 In section .text, align 2, keep-with-next
    195          sl_status_t sli_key_get_size(const sl_se_key_descriptor_t *key, uint32_t *size)
    196          {
   \                     sli_key_get_size: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
    197            if (key == NULL || size == NULL) {
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD001             BEQ.N    ??sli_key_get_size_0
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD101             BNE.N    ??sli_key_get_size_1
    198              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_key_get_size_0: (+1)
   \        0xC   0x2021             MOVS     R0,#+33
   \        0xE   0xE03D             B.N      ??sli_key_get_size_2
    199            }
    200          
    201            // Find size from key_type
    202            uint32_t key_type = (key->type & KEYSPEC_TYPE_MASK);
   \                     ??sli_key_get_size_1: (+1)
   \       0x10   0x6813             LDR      R3,[R2, #+0]
   \       0x12   0xF013 0x4370      ANDS     R3,R3,#0xF0000000
    203            if (key_type == KEYSPEC_TYPE_RAW) {
   \       0x16   0x2B00             CMP      R3,#+0
   \       0x18   0xD104             BNE.N    ??sli_key_get_size_3
    204              *size = (key->type & KEYSPEC_ATTRIBUTES_MASK);
   \       0x1A   0x6810             LDR      R0,[R2, #+0]
   \       0x1C   0x0440             LSLS     R0,R0,#+17
   \       0x1E   0x0C40             LSRS     R0,R0,#+17
   \       0x20   0x6008             STR      R0,[R1, #+0]
   \       0x22   0xE028             B.N      ??sli_key_get_size_4
    205            } else if ((key_type == KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME)
    206                       || (key_type == KEYSPEC_TYPE_ECC_EDWARDS)
    207                       || (key_type == KEYSPEC_TYPE_ECC_MONTGOMERY)
    208                       || (key_type == KEYSPEC_TYPE_ECC_EDDSA)) {
   \                     ??sli_key_get_size_3: (+1)
   \       0x24   0xF1B3 0x4F00      CMP      R3,#+2147483648
   \       0x28   0xD008             BEQ.N    ??sli_key_get_size_5
   \       0x2A   0xF1B3 0x4F20      CMP      R3,#+2684354560
   \       0x2E   0xD005             BEQ.N    ??sli_key_get_size_5
   \       0x30   0xF1B3 0x4F30      CMP      R3,#+2952790016
   \       0x34   0xD002             BEQ.N    ??sli_key_get_size_5
   \       0x36   0xF1B3 0x4F40      CMP      R3,#+3221225472
   \       0x3A   0xD11A             BNE.N    ??sli_key_get_size_6
    209          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    210              bool has_custom_curve =
    211                ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) != 0);
   \                     ??sli_key_get_size_5: (+1)
   \       0x3C   0x6894             LDR      R4,[R2, #+8]
   \       0x3E   0x0B24             LSRS     R4,R4,#+12
   \       0x40   0xF014 0x0401      ANDS     R4,R4,#0x1
    212          #endif
    213          
    214          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    215              if (has_custom_curve) {
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD00D             BEQ.N    ??sli_key_get_size_7
    216                if (key->domain == NULL) {
   \       0x4C   0x69D0             LDR      R0,[R2, #+28]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD101             BNE.N    ??sli_key_get_size_8
    217                  return SL_STATUS_INVALID_PARAMETER;
   \       0x52   0x2021             MOVS     R0,#+33
   \       0x54   0xE01A             B.N      ??sli_key_get_size_2
    218                }
    219                if (key->type & SL_SE_KEY_TYPE_ECC_WEIERSTRASS_PRIME_CUSTOM) {
   \                     ??sli_key_get_size_8: (+1)
   \       0x56   0x6810             LDR      R0,[R2, #+0]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD503             BPL.N    ??sli_key_get_size_9
    220                  sl_se_custom_weierstrass_prime_domain_t *domain = (sl_se_custom_weierstrass_prime_domain_t*)key->domain;
   \       0x5C   0x69D0             LDR      R0,[R2, #+28]
    221                  *size = domain->size;
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0x6008             STR      R0,[R1, #+0]
   \       0x62   0xE008             B.N      ??sli_key_get_size_4
    222                } else {
    223                  return SL_STATUS_NOT_SUPPORTED;
   \                     ??sli_key_get_size_9: (+1)
   \       0x64   0x200F             MOVS     R0,#+15
   \       0x66   0xE011             B.N      ??sli_key_get_size_2
    224                }
    225              } else
    226          #endif
    227              {
    228                *size = (key->type & KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK);
   \                     ??sli_key_get_size_7: (+1)
   \       0x68   0x7810             LDRB     R0,[R2, #+0]
   \       0x6A   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \       0x6E   0x6008             STR      R0,[R1, #+0]
   \       0x70   0xE001             B.N      ??sli_key_get_size_4
    229              }
    230            } else {
    231              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_key_get_size_6: (+1)
   \       0x72   0x2021             MOVS     R0,#+33
   \       0x74   0xE00A             B.N      ??sli_key_get_size_2
    232            }
    233          
    234          // If the key type didn't contain a size, use the one in the dedicated size
    235          // field
    236            if (*size == 0) {
   \                     ??sli_key_get_size_4: (+1)
   \       0x76   0x6808             LDR      R0,[R1, #+0]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD106             BNE.N    ??sli_key_get_size_10
    237              if (key->size == 0) {
   \       0x7C   0x6850             LDR      R0,[R2, #+4]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD101             BNE.N    ??sli_key_get_size_11
    238                return SL_STATUS_INVALID_PARAMETER;
   \       0x82   0x2021             MOVS     R0,#+33
   \       0x84   0xE002             B.N      ??sli_key_get_size_2
    239              }
    240              *size = key->size;
   \                     ??sli_key_get_size_11: (+1)
   \       0x86   0x6850             LDR      R0,[R2, #+4]
   \       0x88   0x6008             STR      R0,[R1, #+0]
    241            }
    242          
    243            return SL_STATUS_OK;
   \                     ??sli_key_get_size_10: (+1)
   \       0x8A   0x2000             MOVS     R0,#+0
   \                     ??sli_key_get_size_2: (+1)
   \       0x8C   0xBC10             POP      {R4}
   \       0x8E   0x4770             BX       LR
    244          }
    245          

   \                                 In section .text, align 2, keep-with-next
    246          sl_status_t sli_key_check_equivalent(const sl_se_key_descriptor_t *key_1,
    247                                               const sl_se_key_descriptor_t *key_2,
    248                                               bool check_key_flag,
    249                                               bool public_export)
    250          {
   \                     sli_key_check_equivalent: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001F             MOVS     R7,R3
    251            sl_status_t status;
    252          
    253            if (key_1 == NULL || key_2 == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD001             BEQ.N    ??sli_key_check_equivalent_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD101             BNE.N    ??sli_key_check_equivalent_1
    254              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_key_check_equivalent_0: (+1)
   \       0x14   0x2021             MOVS     R0,#+33
   \       0x16   0xE073             B.N      ??sli_key_check_equivalent_2
    255            }
    256          
    257            if (key_1->type != key_2->type) {
   \                     ??sli_key_check_equivalent_1: (+1)
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6828             LDR      R0,[R5, #+0]
   \       0x1C   0x4281             CMP      R1,R0
   \       0x1E   0xD02D             BEQ.N    ??sli_key_check_equivalent_3
    258              // The type fields are different, but this may be due to one of the keys
    259              // not containing the size in the type, but rather in the size field.
    260              if (((key_1->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)
    261                   == SL_SE_KEY_TYPE_ECC_WEIERSTRASS_PRIME_CUSTOM)
    262                  || ((key_1->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)
    263                      == SL_SE_KEY_TYPE_ECC_EDDSA)) {
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \       0x26   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \       0x2A   0xD005             BEQ.N    ??sli_key_check_equivalent_4
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \       0x32   0xF1B0 0x4F40      CMP      R0,#+3221225472
   \       0x36   0xD11F             BNE.N    ??sli_key_check_equivalent_5
    264                if ((key_1->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)
    265                    == (key_2->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)) {
   \                     ??sli_key_check_equivalent_4: (+1)
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0xF011 0x4170      ANDS     R1,R1,#0xF0000000
   \       0x3E   0x6828             LDR      R0,[R5, #+0]
   \       0x40   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \       0x44   0x4281             CMP      R1,R0
   \       0x46   0xD119             BNE.N    ??sli_key_check_equivalent_3
    266                  // Assume that the sizes are equal for now (this will be checked later)
    267                  uint32_t key_size = 0;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x9000             STR      R0,[SP, #+0]
    268                  if (sli_key_get_size(key_1, &key_size) == SL_STATUS_OK) {
   \       0x4C   0x4669             MOV      R1,SP
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       sli_key_get_size
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD10D             BNE.N    ??sli_key_check_equivalent_6
    269                    // Add the key sizes to both key types, and check for equality then
    270                    sl_se_key_type_t type_1 = key_1->type | (SL_SE_KEY_TYPE_ATTRIBUTES_MASK & key_size);
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x9900             LDR      R1,[SP, #+0]
   \       0x5C   0x0449             LSLS     R1,R1,#+17
   \       0x5E   0x0C49             LSRS     R1,R1,#+17
   \       0x60   0x4301             ORRS     R1,R1,R0
    271                    sl_se_key_type_t type_2 = key_2->type | (SL_SE_KEY_TYPE_ATTRIBUTES_MASK & key_size);
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x9A00             LDR      R2,[SP, #+0]
   \       0x66   0x0452             LSLS     R2,R2,#+17
   \       0x68   0x0C52             LSRS     R2,R2,#+17
   \       0x6A   0x4302             ORRS     R2,R2,R0
    272                    if (type_1 != type_2) {
   \       0x6C   0x4291             CMP      R1,R2
   \       0x6E   0xD005             BEQ.N    ??sli_key_check_equivalent_3
    273                      return SL_STATUS_INVALID_PARAMETER;
   \       0x70   0x2021             MOVS     R0,#+33
   \       0x72   0xE045             B.N      ??sli_key_check_equivalent_2
    274                    }
    275                  } else {
    276                    return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_key_check_equivalent_6: (+1)
   \       0x74   0x2021             MOVS     R0,#+33
   \       0x76   0xE043             B.N      ??sli_key_check_equivalent_2
    277                  }
    278                }
    279              } else {
    280                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_key_check_equivalent_5: (+1)
   \       0x78   0x2021             MOVS     R0,#+33
   \       0x7A   0xE041             B.N      ??sli_key_check_equivalent_2
    281              }
    282            }
    283          
    284            // Verify asymmetry flags
    285            if ((key_1->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)
    286                >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \                     ??sli_key_check_equivalent_3: (+1)
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \       0x82   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \       0x86   0xD31E             BCC.N    ??sli_key_check_equivalent_7
    287              uint32_t consistent_flags =
    288                (public_export) ? SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN
    289                : (SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY
    290                   | SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY
    291                   | SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN);
   \       0x88   0x0038             MOVS     R0,R7
   \       0x8A   0xB2C0             UXTB     R0,R0
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD002             BEQ.N    ??sli_key_check_equivalent_8
   \       0x90   0xF44F 0x5180      MOV      R1,#+4096
   \       0x94   0xE001             B.N      ??sli_key_check_equivalent_9
   \                     ??sli_key_check_equivalent_8: (+1)
   \       0x96   0xF44F 0x41E0      MOV      R1,#+28672
    292              if (check_key_flag && (key_1->flags & consistent_flags) ^ (key_2->flags & consistent_flags)) {
   \                     ??sli_key_check_equivalent_9: (+1)
   \       0x9A   0x4640             MOV      R0,R8
   \       0x9C   0xB2C0             UXTB     R0,R0
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD008             BEQ.N    ??sli_key_check_equivalent_10
   \       0xA2   0x68A2             LDR      R2,[R4, #+8]
   \       0xA4   0x400A             ANDS     R2,R1,R2
   \       0xA6   0x68A8             LDR      R0,[R5, #+8]
   \       0xA8   0x4008             ANDS     R0,R1,R0
   \       0xAA   0xEA90 0x0F02      TEQ      R0,R2
   \       0xAE   0xD001             BEQ.N    ??sli_key_check_equivalent_10
    293                return SL_STATUS_INVALID_PARAMETER;
   \       0xB0   0x2021             MOVS     R0,#+33
   \       0xB2   0xE025             B.N      ??sli_key_check_equivalent_2
    294              }
    295          
    296              if (public_export
    297                  && (!(key_2->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY))) {
   \                     ??sli_key_check_equivalent_10: (+1)
   \       0xB4   0x0038             MOVS     R0,R7
   \       0xB6   0xB2C0             UXTB     R0,R0
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD004             BEQ.N    ??sli_key_check_equivalent_7
   \       0xBC   0x68A8             LDR      R0,[R5, #+8]
   \       0xBE   0x0480             LSLS     R0,R0,#+18
   \       0xC0   0xD401             BMI.N    ??sli_key_check_equivalent_7
    298                return SL_STATUS_INVALID_PARAMETER;
   \       0xC2   0x2021             MOVS     R0,#+33
   \       0xC4   0xE01C             B.N      ??sli_key_check_equivalent_2
    299              }
    300            }
    301          
    302            // Verify key sizes
    303            uint32_t key_1_size = 0;
   \                     ??sli_key_check_equivalent_7: (+1)
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0x9002             STR      R0,[SP, #+8]
    304            status = sli_key_get_size(key_1, &key_1_size);
   \       0xCA   0xA902             ADD      R1,SP,#+8
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0x.... 0x....      BL       sli_key_get_size
   \       0xD2   0x0006             MOVS     R6,R0
    305            if (status != SL_STATUS_OK) {
   \       0xD4   0x2E00             CMP      R6,#+0
   \       0xD6   0xD001             BEQ.N    ??sli_key_check_equivalent_11
    306              return status;
   \       0xD8   0x0030             MOVS     R0,R6
   \       0xDA   0xE011             B.N      ??sli_key_check_equivalent_2
    307            }
    308            uint32_t key_2_size = 0;
   \                     ??sli_key_check_equivalent_11: (+1)
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0x9001             STR      R0,[SP, #+4]
    309            status = sli_key_get_size(key_2, &key_2_size);
   \       0xE0   0xA901             ADD      R1,SP,#+4
   \       0xE2   0x0028             MOVS     R0,R5
   \       0xE4   0x.... 0x....      BL       sli_key_get_size
   \       0xE8   0x0001             MOVS     R1,R0
    310            if (status != SL_STATUS_OK) {
   \       0xEA   0x2900             CMP      R1,#+0
   \       0xEC   0xD001             BEQ.N    ??sli_key_check_equivalent_12
    311              return status;
   \       0xEE   0x0008             MOVS     R0,R1
   \       0xF0   0xE006             B.N      ??sli_key_check_equivalent_2
    312            }
    313          
    314            if (key_1_size != key_2_size) {
   \                     ??sli_key_check_equivalent_12: (+1)
   \       0xF2   0x9802             LDR      R0,[SP, #+8]
   \       0xF4   0x9A01             LDR      R2,[SP, #+4]
   \       0xF6   0x4290             CMP      R0,R2
   \       0xF8   0xD001             BEQ.N    ??sli_key_check_equivalent_13
    315              return SL_STATUS_INVALID_PARAMETER;
   \       0xFA   0x2021             MOVS     R0,#+33
   \       0xFC   0xE000             B.N      ??sli_key_check_equivalent_2
    316            }
    317          
    318            return SL_STATUS_OK;
   \                     ??sli_key_check_equivalent_13: (+1)
   \       0xFE   0x2000             MOVS     R0,#+0
   \                     ??sli_key_check_equivalent_2: (+1)
   \      0x100   0xB004             ADD      SP,SP,#+16
   \      0x102   0xE8BD 0x81F0      POP      {R4-R8,PC}
    319          }
    320          
    321          /***************************************************************************//**
    322           * @brief
    323           *   Convert key descriptor struct to a 32-bit keyspec value to pass into an SE
    324           *   command.
    325           *
    326           * @return
    327           *   Status code, @ref sl_status.h.
    328           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    329          sl_status_t sli_se_key_to_keyspec(const sl_se_key_descriptor_t *key,
    330                                            uint32_t *keyspec)
    331          {
   \                     sli_se_key_to_keyspec: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    332            if (key == NULL || keyspec == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??sli_se_key_to_keyspec_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??sli_se_key_to_keyspec_1
    333              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_key_to_keyspec_0: (+1)
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE11E             B.N      ??sli_se_key_to_keyspec_2
    334            }
    335          
    336            // Clear output
    337            *keyspec = 0;
   \                     ??sli_se_key_to_keyspec_1: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6028             STR      R0,[R5, #+0]
    338          
    339            // ---------------------
    340            // Key type [31-28]
    341          
    342            *keyspec = (key->type & KEYSPEC_TYPE_MASK);
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \       0x1E   0x6028             STR      R0,[R5, #+0]
    343          
    344            // ---------------------
    345            // Key mode [27-26]
    346          
    347            switch (key->storage.method) {
   \       0x20   0x68E0             LDR      R0,[R4, #+12]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD005             BEQ.N    ??sli_se_key_to_keyspec_3
   \       0x26   0x2802             CMP      R0,#+2
   \       0x28   0xD00B             BEQ.N    ??sli_se_key_to_keyspec_4
   \       0x2A   0xD305             BCC.N    ??sli_se_key_to_keyspec_5
   \       0x2C   0x2803             CMP      R0,#+3
   \       0x2E   0xD00D             BEQ.N    ??sli_se_key_to_keyspec_6
   \       0x30   0xE011             B.N      ??sli_se_key_to_keyspec_7
    348              case SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT:
    349                *keyspec |= KEYSPEC_MODE_UNPROTECTED;
   \                     ??sli_se_key_to_keyspec_3: (+1)
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x6028             STR      R0,[R5, #+0]
    350                break;
   \       0x36   0xE010             B.N      ??sli_se_key_to_keyspec_8
    351          
    352          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    353              case SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED:
    354                *keyspec |= KEYSPEC_MODE_WRAPPED;
   \                     ??sli_se_key_to_keyspec_5: (+1)
   \       0x38   0x6828             LDR      R0,[R5, #+0]
   \       0x3A   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \       0x3E   0x6028             STR      R0,[R5, #+0]
    355                break;
   \       0x40   0xE00B             B.N      ??sli_se_key_to_keyspec_8
    356          
    357              case SL_SE_KEY_STORAGE_INTERNAL_VOLATILE:
    358                *keyspec |= KEYSPEC_MODE_VOLATILE;
   \                     ??sli_se_key_to_keyspec_4: (+1)
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \       0x48   0x6028             STR      R0,[R5, #+0]
    359                break;
   \       0x4A   0xE006             B.N      ??sli_se_key_to_keyspec_8
    360          #endif
    361          
    362              case SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE:
    363                *keyspec |= KEYSPEC_MODE_VOLATILE;
   \                     ??sli_se_key_to_keyspec_6: (+1)
   \       0x4C   0x6828             LDR      R0,[R5, #+0]
   \       0x4E   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \       0x52   0x6028             STR      R0,[R5, #+0]
    364                break;
   \       0x54   0xE001             B.N      ??sli_se_key_to_keyspec_8
    365          
    366              default:
    367                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_key_to_keyspec_7: (+1)
   \       0x56   0x2021             MOVS     R0,#+33
   \       0x58   0xE0FB             B.N      ??sli_se_key_to_keyspec_2
    368            }
    369          
    370            // ---------------------
    371            // Key restriction [25-24]
    372          
    373            uint32_t keyspec_restriction = 0;
   \                     ??sli_se_key_to_keyspec_8: (+1)
   \       0x5A   0x2600             MOVS     R6,#+0
    374            if (key->flags & SL_SE_KEY_FLAG_NON_EXPORTABLE) {
   \       0x5C   0x68A0             LDR      R0,[R4, #+8]
   \       0x5E   0x01C0             LSLS     R0,R0,#+7
   \       0x60   0xD502             BPL.N    ??sli_se_key_to_keyspec_9
    375              keyspec_restriction = KEYSPEC_RESTRICTION_LOCKED;
   \       0x62   0xF05F 0x7080      MOVS     R0,#+16777216
   \       0x66   0x0006             MOVS     R6,R0
    376            }
    377            if (key->flags & SL_SE_KEY_FLAG_IS_DEVICE_GENERATED) {
   \                     ??sli_se_key_to_keyspec_9: (+1)
   \       0x68   0x68A0             LDR      R0,[R4, #+8]
   \       0x6A   0x0180             LSLS     R0,R0,#+6
   \       0x6C   0xD502             BPL.N    ??sli_se_key_to_keyspec_10
    378              keyspec_restriction = KEYSPEC_RESTRICTION_INTERNAL;
   \       0x6E   0xF05F 0x7000      MOVS     R0,#+33554432
   \       0x72   0x0006             MOVS     R6,R0
    379            }
    380            if ((key->flags & SL_SE_KEY_FLAG_IS_RESTRICTED) == SL_SE_KEY_FLAG_IS_RESTRICTED) {
   \                     ??sli_se_key_to_keyspec_10: (+1)
   \       0x74   0x68A0             LDR      R0,[R4, #+8]
   \       0x76   0xF010 0x7040      ANDS     R0,R0,#0x3000000
   \       0x7A   0xF1B0 0x7F40      CMP      R0,#+50331648
   \       0x7E   0xD102             BNE.N    ??sli_se_key_to_keyspec_11
    381              keyspec_restriction = KEYSPEC_RESTRICTION_RESTRICTED;
   \       0x80   0xF05F 0x7040      MOVS     R0,#+50331648
   \       0x84   0x0006             MOVS     R6,R0
    382            }
    383            // Key restrictions are only applicable to volatile and wrapped keys
    384            if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   \                     ??sli_se_key_to_keyspec_11: (+1)
   \       0x86   0x68E0             LDR      R0,[R4, #+12]
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD103             BNE.N    ??sli_se_key_to_keyspec_12
    385              if (keyspec_restriction != 0) {
   \       0x8C   0x2E00             CMP      R6,#+0
   \       0x8E   0xD001             BEQ.N    ??sli_se_key_to_keyspec_12
    386                return SL_STATUS_INVALID_PARAMETER;
   \       0x90   0x2021             MOVS     R0,#+33
   \       0x92   0xE0DE             B.N      ??sli_se_key_to_keyspec_2
    387              }
    388            }
    389          
    390            *keyspec = (*keyspec & ~KEYSPEC_RESTRICTION_MASK)
    391                       | (keyspec_restriction & KEYSPEC_RESTRICTION_MASK);
   \                     ??sli_se_key_to_keyspec_12: (+1)
   \       0x94   0x0031             MOVS     R1,R6
   \       0x96   0x0E09             LSRS     R1,R1,#+24
   \       0x98   0x6828             LDR      R0,[R5, #+0]
   \       0x9A   0xF361 0x6019      BFI      R0,R1,#+24,#+2
   \       0x9E   0x6028             STR      R0,[R5, #+0]
    392          
    393            // ---------------------
    394            // Key index [23-16]
    395          
    396          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    397            if (key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_VOLATILE) {
   \       0xA0   0x68E0             LDR      R0,[R4, #+12]
   \       0xA2   0x2802             CMP      R0,#+2
   \       0xA4   0xD109             BNE.N    ??sli_se_key_to_keyspec_13
    398              if (key->storage.location.slot > SL_SE_KEY_SLOT_VOLATILE_3) {
   \       0xA6   0x6920             LDR      R0,[R4, #+16]
   \       0xA8   0x2804             CMP      R0,#+4
   \       0xAA   0xD301             BCC.N    ??sli_se_key_to_keyspec_14
    399                return SL_STATUS_INVALID_PARAMETER;
   \       0xAC   0x2021             MOVS     R0,#+33
   \       0xAE   0xE0D0             B.N      ??sli_se_key_to_keyspec_2
    400              }
    401              *keyspec = (*keyspec & ~KEYSPEC_INDEX_MASK)
    402                         | ((key->storage.location.slot << KEYSPEC_INDEX_OFFSET)
    403                            & KEYSPEC_INDEX_MASK);
   \                     ??sli_se_key_to_keyspec_14: (+1)
   \       0xB0   0x6921             LDR      R1,[R4, #+16]
   \       0xB2   0x6828             LDR      R0,[R5, #+0]
   \       0xB4   0xF361 0x4017      BFI      R0,R1,#+16,#+8
   \       0xB8   0x6028             STR      R0,[R5, #+0]
    404            }
    405          #endif
    406          
    407            if (key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE) {
   \                     ??sli_se_key_to_keyspec_13: (+1)
   \       0xBA   0x68E0             LDR      R0,[R4, #+12]
   \       0xBC   0x2803             CMP      R0,#+3
   \       0xBE   0xD109             BNE.N    ??sli_se_key_to_keyspec_15
    408              if (key->storage.location.slot
    409                  < SL_SE_KEY_SLOT_INTERNAL_MIN) {
   \       0xC0   0x6920             LDR      R0,[R4, #+16]
   \       0xC2   0x28F7             CMP      R0,#+247
   \       0xC4   0xD201             BCS.N    ??sli_se_key_to_keyspec_16
    410                return SL_STATUS_INVALID_PARAMETER;
   \       0xC6   0x2021             MOVS     R0,#+33
   \       0xC8   0xE0C3             B.N      ??sli_se_key_to_keyspec_2
    411              }
    412              *keyspec = (*keyspec & ~KEYSPEC_INDEX_MASK)
    413                         | ((key->storage.location.slot << KEYSPEC_INDEX_OFFSET)
    414                            & KEYSPEC_INDEX_MASK);
   \                     ??sli_se_key_to_keyspec_16: (+1)
   \       0xCA   0x6921             LDR      R1,[R4, #+16]
   \       0xCC   0x6828             LDR      R0,[R5, #+0]
   \       0xCE   0xF361 0x4017      BFI      R0,R1,#+16,#+8
   \       0xD2   0x6028             STR      R0,[R5, #+0]
    415            }
    416          
    417            // ---------------------
    418            // Key NoProt [15]
    419          
    420            if (key->flags & SL_SE_KEY_FLAG_ALLOW_ANY_ACCESS) {
   \                     ??sli_se_key_to_keyspec_15: (+1)
   \       0xD4   0x68A0             LDR      R0,[R4, #+8]
   \       0xD6   0x0400             LSLS     R0,R0,#+16
   \       0xD8   0xD503             BPL.N    ??sli_se_key_to_keyspec_17
    421              *keyspec = (*keyspec & ~KEYSPEC_NOPROT_MASK) | (1 << KEYSPEC_NOPROT_OFFSET);
   \       0xDA   0x6828             LDR      R0,[R5, #+0]
   \       0xDC   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0xE0   0x6028             STR      R0,[R5, #+0]
    422            }
    423          
    424            // ---------------------
    425            // Key attributes [14-0]
    426          
    427            // Set general properties from key->type
    428            if (key->storage.method != SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE) {
   \                     ??sli_se_key_to_keyspec_17: (+1)
   \       0xE2   0x68E0             LDR      R0,[R4, #+12]
   \       0xE4   0x2803             CMP      R0,#+3
   \       0xE6   0xD004             BEQ.N    ??sli_se_key_to_keyspec_18
    429              *keyspec = (*keyspec & ~KEYSPEC_ATTRIBUTES_MASK)
    430                         | (key->type & KEYSPEC_ATTRIBUTES_MASK);
   \       0xE8   0x6820             LDR      R0,[R4, #+0]
   \       0xEA   0x6829             LDR      R1,[R5, #+0]
   \       0xEC   0xF360 0x010E      BFI      R1,R0,#+0,#+15
   \       0xF0   0x6029             STR      R1,[R5, #+0]
    431            }
    432          
    433            // Set public/private flags
    434            bool has_private_key =
    435              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY) != 0);
   \                     ??sli_se_key_to_keyspec_18: (+1)
   \       0xF2   0xF8D4 0xA008      LDR      R10,[R4, #+8]
   \       0xF6   0xEA5F 0x3A9A      LSRS     R10,R10,#+14
   \       0xFA   0xF01A 0x0A01      ANDS     R10,R10,#0x1
    436            bool has_public_key =
    437              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY) != 0);
   \       0xFE   0x68A7             LDR      R7,[R4, #+8]
   \      0x100   0x0B7F             LSRS     R7,R7,#+13
   \      0x102   0xF017 0x0701      ANDS     R7,R7,#0x1
    438          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    439            bool has_custom_curve =
    440              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) != 0);
   \      0x106   0xF8D4 0x8008      LDR      R8,[R4, #+8]
   \      0x10A   0xEA5F 0x3818      LSRS     R8,R8,#+12
   \      0x10E   0xF018 0x0801      ANDS     R8,R8,#0x1
    441          #endif
    442            bool signing_only =
    443              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_SIGNING_ONLY) != 0);
   \      0x112   0xF8D4 0x9008      LDR      R9,[R4, #+8]
   \      0x116   0xEA5F 0x2999      LSRS     R9,R9,#+10
   \      0x11A   0xF019 0x0901      ANDS     R9,R9,#0x1
    444          
    445            if ((key->type & KEYSPEC_TYPE_MASK) >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \      0x11E   0x6820             LDR      R0,[R4, #+0]
   \      0x120   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \      0x124   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0x128   0xD31E             BCC.N    ??sli_se_key_to_keyspec_19
    446              if (has_private_key) {
   \      0x12A   0x4650             MOV      R0,R10
   \      0x12C   0xB2C0             UXTB     R0,R0
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD003             BEQ.N    ??sli_se_key_to_keyspec_20
    447                *keyspec |= KEYSPEC_ATTRIBUTES_ECC_PRIVATE_MASK;
   \      0x132   0x6828             LDR      R0,[R5, #+0]
   \      0x134   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \      0x138   0x6028             STR      R0,[R5, #+0]
    448              }
    449              if (has_public_key) {
   \                     ??sli_se_key_to_keyspec_20: (+1)
   \      0x13A   0x0038             MOVS     R0,R7
   \      0x13C   0xB2C0             UXTB     R0,R0
   \      0x13E   0x2800             CMP      R0,#+0
   \      0x140   0xD003             BEQ.N    ??sli_se_key_to_keyspec_21
    450                *keyspec |= KEYSPEC_ATTRIBUTES_ECC_PUBLIC_MASK;
   \      0x142   0x6828             LDR      R0,[R5, #+0]
   \      0x144   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \      0x148   0x6028             STR      R0,[R5, #+0]
    451              }
    452            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    453              if (has_custom_curve) {
   \                     ??sli_se_key_to_keyspec_21: (+1)
   \      0x14A   0x4640             MOV      R0,R8
   \      0x14C   0xB2C0             UXTB     R0,R0
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD003             BEQ.N    ??sli_se_key_to_keyspec_22
    454                *keyspec |= KEYSPEC_ATTRIBUTES_ECC_DOMAIN;
   \      0x152   0x6828             LDR      R0,[R5, #+0]
   \      0x154   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x158   0x6028             STR      R0,[R5, #+0]
    455              }
    456            #endif
    457              if (!(has_private_key || has_public_key)) {
   \                     ??sli_se_key_to_keyspec_22: (+1)
   \      0x15A   0xEA57 0x000A      ORRS     R0,R7,R10
   \      0x15E   0xB2C0             UXTB     R0,R0
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD101             BNE.N    ??sli_se_key_to_keyspec_19
    458                return SL_STATUS_INVALID_PARAMETER;
   \      0x164   0x2021             MOVS     R0,#+33
   \      0x166   0xE074             B.N      ??sli_se_key_to_keyspec_2
    459              }
    460            }
    461          
    462            if ((key->type & KEYSPEC_TYPE_MASK) >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME
    463                && (key->type & KEYSPEC_TYPE_MASK) < KEYSPEC_TYPE_ECC_EDDSA) {
   \                     ??sli_se_key_to_keyspec_19: (+1)
   \      0x168   0x6820             LDR      R0,[R4, #+0]
   \      0x16A   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \      0x16E   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0x172   0xD30D             BCC.N    ??sli_se_key_to_keyspec_23
   \      0x174   0x6820             LDR      R0,[R4, #+0]
   \      0x176   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \      0x17A   0xF1B0 0x4F40      CMP      R0,#+3221225472
   \      0x17E   0xD207             BCS.N    ??sli_se_key_to_keyspec_23
    464              if (signing_only) {
   \      0x180   0x4648             MOV      R0,R9
   \      0x182   0xB2C0             UXTB     R0,R0
   \      0x184   0x2800             CMP      R0,#+0
   \      0x186   0xD003             BEQ.N    ??sli_se_key_to_keyspec_23
    465                *keyspec |= KEYSPEC_ATTRIBUTES_ECC_SIGN;
   \      0x188   0x6828             LDR      R0,[R5, #+0]
   \      0x18A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x18E   0x6028             STR      R0,[R5, #+0]
    466              }
    467            }
    468          
    469            // Ensure that symmetric keys don't have asymmetric flags
    470            if ((key->type & KEYSPEC_TYPE_MASK) < KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \                     ??sli_se_key_to_keyspec_23: (+1)
   \      0x190   0x6820             LDR      R0,[R4, #+0]
   \      0x192   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
   \      0x196   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0x19A   0xD208             BCS.N    ??sli_se_key_to_keyspec_24
    471              if (has_private_key || has_public_key || signing_only) {
   \      0x19C   0xEA57 0x000A      ORRS     R0,R7,R10
   \      0x1A0   0xEA59 0x0000      ORRS     R0,R9,R0
   \      0x1A4   0xB2C0             UXTB     R0,R0
   \      0x1A6   0x2800             CMP      R0,#+0
   \      0x1A8   0xD001             BEQ.N    ??sli_se_key_to_keyspec_24
    472                return SL_STATUS_INVALID_PARAMETER;
   \      0x1AA   0x2021             MOVS     R0,#+33
   \      0x1AC   0xE051             B.N      ??sli_se_key_to_keyspec_2
    473              }
    474            }
    475          
    476            // Set or adjust the key attributes for different key types
    477            uint32_t size = 0;
   \                     ??sli_se_key_to_keyspec_24: (+1)
   \      0x1AE   0x2000             MOVS     R0,#+0
   \      0x1B0   0x9000             STR      R0,[SP, #+0]
    478            sl_status_t status;
    479            status = sli_key_get_size(key, &size);
   \      0x1B2   0x4669             MOV      R1,SP
   \      0x1B4   0x0020             MOVS     R0,R4
   \      0x1B6   0x.... 0x....      BL       sli_key_get_size
   \      0x1BA   0x0001             MOVS     R1,R0
    480            if (status != SL_STATUS_OK) {
   \      0x1BC   0x2900             CMP      R1,#+0
   \      0x1BE   0xD001             BEQ.N    ??sli_se_key_to_keyspec_25
    481              return status;
   \      0x1C0   0x0008             MOVS     R0,R1
   \      0x1C2   0xE046             B.N      ??sli_se_key_to_keyspec_2
    482            }
    483          
    484            // Symmetric and raw keys
    485            uint32_t key_type = (key->type & KEYSPEC_TYPE_MASK);
   \                     ??sli_se_key_to_keyspec_25: (+1)
   \      0x1C4   0x6822             LDR      R2,[R4, #+0]
   \      0x1C6   0xF012 0x4270      ANDS     R2,R2,#0xF0000000
    486            if (key_type == KEYSPEC_TYPE_RAW) {
   \      0x1CA   0x2A00             CMP      R2,#+0
   \      0x1CC   0xD105             BNE.N    ??sli_se_key_to_keyspec_26
    487              *keyspec = (*keyspec & ~KEYSPEC_ATTRIBUTES_MASK)
    488                         | (size & KEYSPEC_ATTRIBUTES_MASK);
   \      0x1CE   0x9B00             LDR      R3,[SP, #+0]
   \      0x1D0   0x6828             LDR      R0,[R5, #+0]
   \      0x1D2   0xF363 0x000E      BFI      R0,R3,#+0,#+15
   \      0x1D6   0x6028             STR      R0,[R5, #+0]
   \      0x1D8   0xE014             B.N      ??sli_se_key_to_keyspec_27
    489            } else if ((key_type == KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME)
    490                       || (key_type == KEYSPEC_TYPE_ECC_EDWARDS)
    491                       || (key_type == KEYSPEC_TYPE_ECC_MONTGOMERY)
    492                       || (key_type == KEYSPEC_TYPE_ECC_EDDSA)) {
   \                     ??sli_se_key_to_keyspec_26: (+1)
   \      0x1DA   0xF1B2 0x4F00      CMP      R2,#+2147483648
   \      0x1DE   0xD008             BEQ.N    ??sli_se_key_to_keyspec_28
   \      0x1E0   0xF1B2 0x4F20      CMP      R2,#+2684354560
   \      0x1E4   0xD005             BEQ.N    ??sli_se_key_to_keyspec_28
   \      0x1E6   0xF1B2 0x4F30      CMP      R2,#+2952790016
   \      0x1EA   0xD002             BEQ.N    ??sli_se_key_to_keyspec_28
   \      0x1EC   0xF1B2 0x4F40      CMP      R2,#+3221225472
   \      0x1F0   0xD106             BNE.N    ??sli_se_key_to_keyspec_29
    493              *keyspec = (*keyspec & ~KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK)
    494                         | ((size - 1) & KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK);
   \                     ??sli_se_key_to_keyspec_28: (+1)
   \      0x1F2   0x9800             LDR      R0,[SP, #+0]
   \      0x1F4   0x1E40             SUBS     R0,R0,#+1
   \      0x1F6   0x682B             LDR      R3,[R5, #+0]
   \      0x1F8   0xF360 0x0306      BFI      R3,R0,#+0,#+7
   \      0x1FC   0x602B             STR      R3,[R5, #+0]
   \      0x1FE   0xE001             B.N      ??sli_se_key_to_keyspec_27
    495            } else {
    496              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_key_to_keyspec_29: (+1)
   \      0x200   0x2021             MOVS     R0,#+33
   \      0x202   0xE026             B.N      ??sli_se_key_to_keyspec_2
    497            }
    498          
    499            // Custom domain
    500          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    501            if (has_custom_curve) {
   \                     ??sli_se_key_to_keyspec_27: (+1)
   \      0x204   0x4640             MOV      R0,R8
   \      0x206   0xB2C0             UXTB     R0,R0
   \      0x208   0x2800             CMP      R0,#+0
   \      0x20A   0xD021             BEQ.N    ??sli_se_key_to_keyspec_30
    502              if (key->domain == NULL) {
   \      0x20C   0x69E0             LDR      R0,[R4, #+28]
   \      0x20E   0x2800             CMP      R0,#+0
   \      0x210   0xD101             BNE.N    ??sli_se_key_to_keyspec_31
    503                return SL_STATUS_INVALID_PARAMETER;
   \      0x212   0x2021             MOVS     R0,#+33
   \      0x214   0xE01D             B.N      ??sli_se_key_to_keyspec_2
    504              }
    505              if (key_type == SL_SE_KEY_TYPE_ECC_WEIERSTRASS_PRIME_CUSTOM) {
   \                     ??sli_se_key_to_keyspec_31: (+1)
   \      0x216   0xF1B2 0x4F00      CMP      R2,#+2147483648
   \      0x21A   0xD117             BNE.N    ??sli_se_key_to_keyspec_32
    506                sl_se_custom_weierstrass_prime_domain_t *domain = (sl_se_custom_weierstrass_prime_domain_t*)key->domain;
   \      0x21C   0x69E3             LDR      R3,[R4, #+28]
    507                if (domain->a_is_zero && signing_only) {
   \      0x21E   0x7F18             LDRB     R0,[R3, #+28]
   \      0x220   0x2800             CMP      R0,#+0
   \      0x222   0xD007             BEQ.N    ??sli_se_key_to_keyspec_33
   \      0x224   0x4648             MOV      R0,R9
   \      0x226   0xB2C0             UXTB     R0,R0
   \      0x228   0x2800             CMP      R0,#+0
   \      0x22A   0xD003             BEQ.N    ??sli_se_key_to_keyspec_33
    508                  *keyspec |= KEYSPEC_ECC_WEIERSTRASS_PRIME_A_IS_ZERO;
   \      0x22C   0x6828             LDR      R0,[R5, #+0]
   \      0x22E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x232   0x6028             STR      R0,[R5, #+0]
    509                }
    510                if (domain->a_is_minus_three && signing_only) {
   \                     ??sli_se_key_to_keyspec_33: (+1)
   \      0x234   0x7F58             LDRB     R0,[R3, #+29]
   \      0x236   0x2800             CMP      R0,#+0
   \      0x238   0xD00A             BEQ.N    ??sli_se_key_to_keyspec_30
   \      0x23A   0x4648             MOV      R0,R9
   \      0x23C   0xB2C0             UXTB     R0,R0
   \      0x23E   0x2800             CMP      R0,#+0
   \      0x240   0xD006             BEQ.N    ??sli_se_key_to_keyspec_30
    511                  *keyspec |= KEYSPEC_ECC_WEIERSTRASS_PRIME_A_IS_MINUS_THREE;
   \      0x242   0x6828             LDR      R0,[R5, #+0]
   \      0x244   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x248   0x6028             STR      R0,[R5, #+0]
   \      0x24A   0xE001             B.N      ??sli_se_key_to_keyspec_30
    512                }
    513              } else {
    514                return SL_STATUS_NOT_SUPPORTED;
   \                     ??sli_se_key_to_keyspec_32: (+1)
   \      0x24C   0x200F             MOVS     R0,#+15
   \      0x24E   0xE000             B.N      ??sli_se_key_to_keyspec_2
    515              }
    516            }
    517          #endif
    518          
    519            return SL_STATUS_OK;
   \                     ??sli_se_key_to_keyspec_30: (+1)
   \      0x250   0x2000             MOVS     R0,#+0
   \                     ??sli_se_key_to_keyspec_2: (+1)
   \      0x252   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    520          }
    521          
    522          /***************************************************************************//**
    523           * @brief
    524           *   Convert a 32-bit SE compatible keyspec value to a key descriptor struct.
    525           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    526          sl_status_t sli_se_keyspec_to_key(const uint32_t keyspec,
    527                                            sl_se_key_descriptor_t* key)
    528          {
   \                     sli_se_keyspec_to_key: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0003             MOVS     R3,R0
    529            if (key == NULL) {
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??sli_se_keyspec_to_key_0
    530              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE0D1             B.N      ??sli_se_keyspec_to_key_1
    531            }
    532          
    533            // Clear output
    534            key->type = 0;
   \                     ??sli_se_keyspec_to_key_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6008             STR      R0,[R1, #+0]
    535            key->storage.method = 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x60C8             STR      R0,[R1, #+12]
    536            key->storage.location.slot = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6108             STR      R0,[R1, #+16]
    537            key->size = 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6048             STR      R0,[R1, #+4]
    538            key->flags = 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x6088             STR      R0,[R1, #+8]
    539          
    540            // ---------------------
    541            // Key type [31-28]
    542            key->type = keyspec & KEYSPEC_TYPE_MASK;
   \       0x20   0xF013 0x4070      ANDS     R0,R3,#0xF0000000
   \       0x24   0x6008             STR      R0,[R1, #+0]
    543          
    544            // ---------------------
    545            // Key mode [27-26] and key index [23-16]
    546          
    547            if ((keyspec & KEYSPEC_MODE_MASK) == KEYSPEC_MODE_UNPROTECTED) {
   \       0x26   0xF013 0x6F40      TST      R3,#0xC000000
   \       0x2A   0xD102             BNE.N    ??sli_se_keyspec_to_key_2
    548              key->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x60C8             STR      R0,[R1, #+12]
   \       0x30   0xE020             B.N      ??sli_se_keyspec_to_key_3
    549            }
    550          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    551            else if ((keyspec & KEYSPEC_MODE_MASK) == KEYSPEC_MODE_WRAPPED) {
   \                     ??sli_se_keyspec_to_key_2: (+1)
   \       0x32   0xF013 0x6040      ANDS     R0,R3,#0xC000000
   \       0x36   0xF1B0 0x6F00      CMP      R0,#+134217728
   \       0x3A   0xD102             BNE.N    ??sli_se_keyspec_to_key_4
    552              key->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x60C8             STR      R0,[R1, #+12]
   \       0x40   0xE018             B.N      ??sli_se_keyspec_to_key_3
    553            }
    554          #endif
    555            else if ((keyspec & KEYSPEC_MODE_MASK) == KEYSPEC_MODE_VOLATILE) {
   \                     ??sli_se_keyspec_to_key_4: (+1)
   \       0x42   0xF013 0x6040      ANDS     R0,R3,#0xC000000
   \       0x46   0xF1B0 0x6F80      CMP      R0,#+67108864
   \       0x4A   0xD111             BNE.N    ??sli_se_keyspec_to_key_5
    556              // Volatile can mean either internal-volatile or internal-immutable
    557              // Check which is which based on key index
    558              uint32_t key_index = (keyspec & KEYSPEC_INDEX_MASK) >> KEYSPEC_INDEX_OFFSET;
   \       0x4C   0xF3C3 0x4207      UBFX     R2,R3,#+16,#+8
    559          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    560              if (key_index <= SL_SE_KEY_SLOT_VOLATILE_3) {
   \       0x50   0x2A04             CMP      R2,#+4
   \       0x52   0xD202             BCS.N    ??sli_se_keyspec_to_key_6
    561                key->storage.method = SL_SE_KEY_STORAGE_INTERNAL_VOLATILE;
   \       0x54   0x2002             MOVS     R0,#+2
   \       0x56   0x60C8             STR      R0,[R1, #+12]
   \       0x58   0xE008             B.N      ??sli_se_keyspec_to_key_7
    562              } else
    563          #endif
    564              if ((key_index <= SL_SE_KEY_SLOT_APPLICATION_ATTESTATION_KEY)
    565                  && (key_index >= SL_SE_KEY_SLOT_INTERNAL_MIN)) {
   \                     ??sli_se_keyspec_to_key_6: (+1)
   \       0x5A   0x2AFF             CMP      R2,#+255
   \       0x5C   0xD204             BCS.N    ??sli_se_keyspec_to_key_8
   \       0x5E   0x2AF7             CMP      R2,#+247
   \       0x60   0xD302             BCC.N    ??sli_se_keyspec_to_key_8
    566                key->storage.method = SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE;
   \       0x62   0x2003             MOVS     R0,#+3
   \       0x64   0x60C8             STR      R0,[R1, #+12]
   \       0x66   0xE001             B.N      ??sli_se_keyspec_to_key_7
    567              } else {
    568                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_keyspec_to_key_8: (+1)
   \       0x68   0x2021             MOVS     R0,#+33
   \       0x6A   0xE0A1             B.N      ??sli_se_keyspec_to_key_1
    569              }
    570              key->storage.location.slot = key_index;
   \                     ??sli_se_keyspec_to_key_7: (+1)
   \       0x6C   0x610A             STR      R2,[R1, #+16]
   \       0x6E   0xE001             B.N      ??sli_se_keyspec_to_key_3
    571            } else {
    572              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_keyspec_to_key_5: (+1)
   \       0x70   0x2021             MOVS     R0,#+33
   \       0x72   0xE09D             B.N      ??sli_se_keyspec_to_key_1
    573            }
    574          
    575            // ---------------------
    576            // Key restriction [25-24]
    577          
    578            uint32_t keyspec_restriction = (keyspec & KEYSPEC_RESTRICTION_MASK);
   \                     ??sli_se_keyspec_to_key_3: (+1)
   \       0x74   0xF013 0x7240      ANDS     R2,R3,#0x3000000
    579            if (keyspec_restriction == KEYSPEC_RESTRICTION_LOCKED) {
   \       0x78   0xF1B2 0x7F80      CMP      R2,#+16777216
   \       0x7C   0xD104             BNE.N    ??sli_se_keyspec_to_key_9
    580              key->flags |= SL_SE_KEY_FLAG_NON_EXPORTABLE;
   \       0x7E   0x6888             LDR      R0,[R1, #+8]
   \       0x80   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \       0x84   0x6088             STR      R0,[R1, #+8]
   \       0x86   0xE013             B.N      ??sli_se_keyspec_to_key_10
    581            } else if (keyspec_restriction == KEYSPEC_RESTRICTION_UNLOCKED) {
   \                     ??sli_se_keyspec_to_key_9: (+1)
   \       0x88   0x2A00             CMP      R2,#+0
   \       0x8A   0xD011             BEQ.N    ??sli_se_keyspec_to_key_10
    582              // no-op
    583            }
    584          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    585            else if (keyspec_restriction == KEYSPEC_RESTRICTION_INTERNAL) {
   \       0x8C   0xF1B2 0x7F00      CMP      R2,#+33554432
   \       0x90   0xD104             BNE.N    ??sli_se_keyspec_to_key_11
    586              key->flags |= SL_SE_KEY_FLAG_IS_DEVICE_GENERATED;
   \       0x92   0x6888             LDR      R0,[R1, #+8]
   \       0x94   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \       0x98   0x6088             STR      R0,[R1, #+8]
   \       0x9A   0xE009             B.N      ??sli_se_keyspec_to_key_10
    587            } else if (keyspec_restriction == KEYSPEC_RESTRICTION_RESTRICTED) {
   \                     ??sli_se_keyspec_to_key_11: (+1)
   \       0x9C   0xF1B2 0x7F40      CMP      R2,#+50331648
   \       0xA0   0xD104             BNE.N    ??sli_se_keyspec_to_key_12
    588              key->flags |= SL_SE_KEY_FLAG_IS_RESTRICTED;
   \       0xA2   0x6888             LDR      R0,[R1, #+8]
   \       0xA4   0xF050 0x7040      ORRS     R0,R0,#0x3000000
   \       0xA8   0x6088             STR      R0,[R1, #+8]
   \       0xAA   0xE001             B.N      ??sli_se_keyspec_to_key_10
    589            }
    590          #endif
    591            else {
    592              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_keyspec_to_key_12: (+1)
   \       0xAC   0x2021             MOVS     R0,#+33
   \       0xAE   0xE07F             B.N      ??sli_se_keyspec_to_key_1
    593            }
    594          
    595            // Key restrictions are only applicable to volatile and wrapped keys
    596            if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   \                     ??sli_se_keyspec_to_key_10: (+1)
   \       0xB0   0x68C8             LDR      R0,[R1, #+12]
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD103             BNE.N    ??sli_se_keyspec_to_key_13
    597              if (keyspec_restriction != 0) {
   \       0xB6   0x2A00             CMP      R2,#+0
   \       0xB8   0xD001             BEQ.N    ??sli_se_keyspec_to_key_13
    598                return SL_STATUS_INVALID_PARAMETER;
   \       0xBA   0x2021             MOVS     R0,#+33
   \       0xBC   0xE078             B.N      ??sli_se_keyspec_to_key_1
    599              }
    600            }
    601          
    602            // ---------------------
    603            // Key NoProt [15]
    604          
    605            if ((keyspec & KEYSPEC_NOPROT_MASK) == (1 << KEYSPEC_NOPROT_OFFSET)) {
   \                     ??sli_se_keyspec_to_key_13: (+1)
   \       0xBE   0x0418             LSLS     R0,R3,#+16
   \       0xC0   0xD503             BPL.N    ??sli_se_keyspec_to_key_14
    606              key->flags |= SL_SE_KEY_FLAG_ALLOW_ANY_ACCESS;
   \       0xC2   0x6888             LDR      R0,[R1, #+8]
   \       0xC4   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0xC8   0x6088             STR      R0,[R1, #+8]
    607            }
    608          
    609            // ---------------------
    610            // Key attributes [14-0]
    611          
    612            // Set public/private flags
    613            bool has_private_key = ((keyspec & KEYSPEC_ATTRIBUTES_ECC_PRIVATE_MASK) != 0);
   \                     ??sli_se_keyspec_to_key_14: (+1)
   \       0xCA   0x001C             MOVS     R4,R3
   \       0xCC   0x0BA4             LSRS     R4,R4,#+14
   \       0xCE   0xF014 0x0401      ANDS     R4,R4,#0x1
    614            bool has_public_key = ((keyspec & KEYSPEC_ATTRIBUTES_ECC_PUBLIC_MASK) != 0);
   \       0xD2   0x001D             MOVS     R5,R3
   \       0xD4   0x0B6D             LSRS     R5,R5,#+13
   \       0xD6   0xF015 0x0501      ANDS     R5,R5,#0x1
    615          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    616            bool has_custom_curve = ((keyspec & KEYSPEC_ATTRIBUTES_ECC_DOMAIN) != 0);
   \       0xDA   0x001E             MOVS     R6,R3
   \       0xDC   0x0B36             LSRS     R6,R6,#+12
   \       0xDE   0xF016 0x0601      ANDS     R6,R6,#0x1
    617          #endif
    618            bool signing_only = ((keyspec & KEYSPEC_ATTRIBUTES_ECC_SIGN) != 0);
   \       0xE2   0x001F             MOVS     R7,R3
   \       0xE4   0x0ABF             LSRS     R7,R7,#+10
   \       0xE6   0xF017 0x0701      ANDS     R7,R7,#0x1
    619          
    620            if ((keyspec & KEYSPEC_TYPE_MASK) >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \       0xEA   0xF013 0x4070      ANDS     R0,R3,#0xF0000000
   \       0xEE   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \       0xF2   0xD32D             BCC.N    ??sli_se_keyspec_to_key_15
    621              if (has_private_key) {
   \       0xF4   0x0020             MOVS     R0,R4
   \       0xF6   0xB2C0             UXTB     R0,R0
   \       0xF8   0x2800             CMP      R0,#+0
   \       0xFA   0xD003             BEQ.N    ??sli_se_keyspec_to_key_16
    622                key->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
   \       0xFC   0x6888             LDR      R0,[R1, #+8]
   \       0xFE   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \      0x102   0x6088             STR      R0,[R1, #+8]
    623              }
    624              if (has_public_key) {
   \                     ??sli_se_keyspec_to_key_16: (+1)
   \      0x104   0x0028             MOVS     R0,R5
   \      0x106   0xB2C0             UXTB     R0,R0
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD003             BEQ.N    ??sli_se_keyspec_to_key_17
    625                key->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \      0x10C   0x6888             LDR      R0,[R1, #+8]
   \      0x10E   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \      0x112   0x6088             STR      R0,[R1, #+8]
    626              }
    627          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    628              if (has_custom_curve) {
   \                     ??sli_se_keyspec_to_key_17: (+1)
   \      0x114   0x0030             MOVS     R0,R6
   \      0x116   0xB2C0             UXTB     R0,R0
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD005             BEQ.N    ??sli_se_keyspec_to_key_18
    629                key->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN;
   \      0x11C   0x6888             LDR      R0,[R1, #+8]
   \      0x11E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x122   0x6088             STR      R0,[R1, #+8]
    630          
    631                // TODO: custom curve parameter injection?
    632                return SL_STATUS_NOT_SUPPORTED;
   \      0x124   0x200F             MOVS     R0,#+15
   \      0x126   0xE043             B.N      ??sli_se_keyspec_to_key_1
    633              }
    634          #endif
    635              if (!(has_private_key || has_public_key)) {
   \                     ??sli_se_keyspec_to_key_18: (+1)
   \      0x128   0xEA55 0x0004      ORRS     R0,R5,R4
   \      0x12C   0xB2C0             UXTB     R0,R0
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD101             BNE.N    ??sli_se_keyspec_to_key_19
    636                return SL_STATUS_INVALID_PARAMETER;
   \      0x132   0x2021             MOVS     R0,#+33
   \      0x134   0xE03C             B.N      ??sli_se_keyspec_to_key_1
    637              }
    638          
    639              // For ECC keys, their length is encoded in the type
    640              key->type = (key->type & ~SL_SE_KEY_TYPE_ATTRIBUTES_MASK) | ((keyspec & KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK) + 1);
   \                     ??sli_se_keyspec_to_key_19: (+1)
   \      0x136   0xF8D1 0xC000      LDR      R12,[R1, #+0]
   \      0x13A   0xEA5F 0x3CDC      LSRS     R12,R12,#+15
   \      0x13E   0xEA5F 0x3CCC      LSLS     R12,R12,#+15
   \      0x142   0xF013 0x007F      ANDS     R0,R3,#0x7F
   \      0x146   0x1C40             ADDS     R0,R0,#+1
   \      0x148   0xEA50 0x0C0C      ORRS     R12,R0,R12
   \      0x14C   0xF8C1 0xC000      STR      R12,[R1, #+0]
    641            }
    642          
    643            if ((keyspec & KEYSPEC_TYPE_MASK) >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME
    644                && (keyspec & KEYSPEC_TYPE_MASK) < KEYSPEC_TYPE_ECC_EDDSA) {
   \                     ??sli_se_keyspec_to_key_15: (+1)
   \      0x150   0xF013 0x4070      ANDS     R0,R3,#0xF0000000
   \      0x154   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0x158   0xD30C             BCC.N    ??sli_se_keyspec_to_key_20
   \      0x15A   0xF013 0x4070      ANDS     R0,R3,#0xF0000000
   \      0x15E   0xF1B0 0x4F40      CMP      R0,#+3221225472
   \      0x162   0xD207             BCS.N    ??sli_se_keyspec_to_key_20
    645              if (signing_only) {
   \      0x164   0x0038             MOVS     R0,R7
   \      0x166   0xB2C0             UXTB     R0,R0
   \      0x168   0x2800             CMP      R0,#+0
   \      0x16A   0xD003             BEQ.N    ??sli_se_keyspec_to_key_20
    646                key->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_SIGNING_ONLY;
   \      0x16C   0x6888             LDR      R0,[R1, #+8]
   \      0x16E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x172   0x6088             STR      R0,[R1, #+8]
    647              }
    648            }
    649          
    650            // Ensure that symmetric keys don't have asymmetric flags
    651            if ((keyspec & KEYSPEC_TYPE_MASK) < KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \                     ??sli_se_keyspec_to_key_20: (+1)
   \      0x174   0xF013 0x4070      ANDS     R0,R3,#0xF0000000
   \      0x178   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0x17C   0xD217             BCS.N    ??sli_se_keyspec_to_key_21
    652              if (has_private_key || has_public_key || signing_only) {
   \      0x17E   0xEA55 0x0004      ORRS     R0,R5,R4
   \      0x182   0x4338             ORRS     R0,R7,R0
   \      0x184   0xB2C0             UXTB     R0,R0
   \      0x186   0x2800             CMP      R0,#+0
   \      0x188   0xD001             BEQ.N    ??sli_se_keyspec_to_key_22
    653                return SL_STATUS_INVALID_PARAMETER;
   \      0x18A   0x2021             MOVS     R0,#+33
   \      0x18C   0xE010             B.N      ??sli_se_keyspec_to_key_1
    654              }
    655          
    656              key->size = keyspec & KEYSPEC_ATTRIBUTES_MASK;
   \                     ??sli_se_keyspec_to_key_22: (+1)
   \      0x18E   0x0458             LSLS     R0,R3,#+17
   \      0x190   0x0C40             LSRS     R0,R0,#+17
   \      0x192   0x6048             STR      R0,[R1, #+4]
    657          
    658              switch ((keyspec & KEYSPEC_ATTRIBUTES_MASK)) {
   \      0x194   0x0458             LSLS     R0,R3,#+17
   \      0x196   0x0C40             LSRS     R0,R0,#+17
   \      0x198   0x2810             CMP      R0,#+16
   \      0x19A   0xD003             BEQ.N    ??sli_se_keyspec_to_key_23
   \      0x19C   0x2818             CMP      R0,#+24
   \      0x19E   0xD001             BEQ.N    ??sli_se_keyspec_to_key_23
   \      0x1A0   0x2820             CMP      R0,#+32
   \      0x1A2   0xD104             BNE.N    ??sli_se_keyspec_to_key_24
    659                case SL_SE_KEY_TYPE_AES_128:
    660                case SL_SE_KEY_TYPE_AES_192:
    661                case SL_SE_KEY_TYPE_AES_256:
    662                  key->type = keyspec & (KEYSPEC_TYPE_MASK | KEYSPEC_ATTRIBUTES_MASK);
   \                     ??sli_se_keyspec_to_key_23: (+1)
   \      0x1A4   0x0018             MOVS     R0,R3
   \      0x1A6   0xF36F 0x30DB      BFC      R0,#+15,#+13
   \      0x1AA   0x6008             STR      R0,[R1, #+0]
    663                  break;
   \      0x1AC   0xE7FF             B.N      ??sli_se_keyspec_to_key_21
    664                default:
    665                  break;
    666              }
    667            }
    668          
    669            return SL_STATUS_OK;
   \                     ??sli_se_keyspec_to_key_24: (+1)
   \                     ??sli_se_keyspec_to_key_21: (+1)
   \      0x1AE   0x2000             MOVS     R0,#+0
   \                     ??sli_se_keyspec_to_key_1: (+1)
   \      0x1B0   0xBCF0             POP      {R4-R7}
   \      0x1B2   0x4770             BX       LR
    670          }
    671          
    672          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)

   \                                 In section .rodata, align 4
    673          static const uint32_t default_auth_data[2] = { 0 };
   \                     default_auth_data:
   \        0x0   0x0000'0000        DC32 0, 0
   \              0x0000'0000
    674          #endif
    675          

   \                                 In section .text, align 2, keep-with-next
    676          sl_status_t sli_se_get_auth_buffer(const sl_se_key_descriptor_t *key,
    677                                             SE_DataTransfer_t *auth_buffer)
    678          {
   \                     sli_se_get_auth_buffer: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    679            if (key == NULL || auth_buffer == NULL) {
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD001             BEQ.N    ??sli_se_get_auth_buffer_0
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??sli_se_get_auth_buffer_1
    680              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_get_auth_buffer_0: (+1)
   \        0xA   0x2021             MOVS     R0,#+33
   \        0xC   0xE01B             B.N      ??sli_se_get_auth_buffer_2
    681            }
    682          
    683            auth_buffer->next = (void*)SE_DATATRANSFER_STOP;
   \                     ??sli_se_get_auth_buffer_1: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x6048             STR      R0,[R1, #+4]
    684          
    685          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    686            if ((key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
    687                || (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED)) {
   \       0x12   0x68D0             LDR      R0,[R2, #+12]
   \       0x14   0x2802             CMP      R0,#+2
   \       0x16   0xD002             BEQ.N    ??sli_se_get_auth_buffer_3
   \       0x18   0x68D0             LDR      R0,[R2, #+12]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10F             BNE.N    ??sli_se_get_auth_buffer_4
    688              if (key->password) {
   \                     ??sli_se_get_auth_buffer_3: (+1)
   \       0x1E   0x6990             LDR      R0,[R2, #+24]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD005             BEQ.N    ??sli_se_get_auth_buffer_5
    689                auth_buffer->data = key->password;
   \       0x24   0x6990             LDR      R0,[R2, #+24]
   \       0x26   0x6008             STR      R0,[R1, #+0]
    690                auth_buffer->length = sizeof(default_auth_data) | SE_DATATRANSFER_REALIGN;
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable3
   \       0x2C   0x6088             STR      R0,[R1, #+8]
   \       0x2E   0xE009             B.N      ??sli_se_get_auth_buffer_6
    691              } else {
    692                auth_buffer->data = (void*)default_auth_data;
   \                     ??sli_se_get_auth_buffer_5: (+1)
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \       0x34   0x6008             STR      R0,[R1, #+0]
    693                auth_buffer->length = sizeof(default_auth_data) | SE_DATATRANSFER_REALIGN;
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable3
   \       0x3A   0x6088             STR      R0,[R1, #+8]
   \       0x3C   0xE002             B.N      ??sli_se_get_auth_buffer_6
    694              }
    695            } else {
    696              auth_buffer->length = 0 | SE_DATATRANSFER_REALIGN;
   \                     ??sli_se_get_auth_buffer_4: (+1)
   \       0x3E   0xF05F 0x5000      MOVS     R0,#+536870912
   \       0x42   0x6088             STR      R0,[R1, #+8]
    697            }
    698          #else
    699            (void)key;
    700            auth_buffer->length = 0 | SE_DATATRANSFER_REALIGN;
    701          #endif
    702          
    703            return SL_STATUS_OK;
   \                     ??sli_se_get_auth_buffer_6: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??sli_se_get_auth_buffer_2: (+1)
   \       0x46   0x4770             BX       LR
    704          }
    705          

   \                                 In section .text, align 2, keep-with-next
    706          sl_status_t sli_se_get_key_input_output(const sl_se_key_descriptor_t *key,
    707                                                  SE_DataTransfer_t *buffer)
    708          {
   \                     sli_se_get_key_input_output: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    709            if (key == NULL || buffer == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sli_se_get_key_input_output_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sli_se_get_key_input_output_1
    710              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_get_key_input_output_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE036             B.N      ??sli_se_get_key_input_output_2
    711            }
    712          
    713            buffer->next = (void*)SE_DATATRANSFER_STOP;
   \                     ??sli_se_get_key_input_output_1: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x6068             STR      R0,[R5, #+4]
    714          
    715            if ((key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
    716          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    717                || (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED)
    718          #endif
    719                ) {
   \       0x16   0x68E0             LDR      R0,[R4, #+12]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD002             BEQ.N    ??sli_se_get_key_input_output_3
   \       0x1C   0x68E0             LDR      R0,[R4, #+12]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD122             BNE.N    ??sli_se_get_key_input_output_4
    720              // Set or adjust the key attributes for different key types
    721              uint32_t storage_size = 0;
   \                     ??sli_se_get_key_input_output_3: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9000             STR      R0,[SP, #+0]
    722              sl_status_t status = sli_key_get_storage_size(key, &storage_size);
   \       0x26   0x4669             MOV      R1,SP
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       sli_key_get_storage_size
   \       0x2E   0x0001             MOVS     R1,R0
    723              if (status != SL_STATUS_OK) {
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD001             BEQ.N    ??sli_se_get_key_input_output_5
    724                return status;
   \       0x34   0x0008             MOVS     R0,R1
   \       0x36   0xE023             B.N      ??sli_se_get_key_input_output_2
    725              }
    726          
    727              uint32_t total_storage_size = 0;
   \                     ??sli_se_get_key_input_output_5: (+1)
   \       0x38   0x2200             MOVS     R2,#+0
    728              if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   \       0x3A   0x68E0             LDR      R0,[R4, #+12]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD102             BNE.N    ??sli_se_get_key_input_output_6
    729                total_storage_size = storage_size;
   \       0x40   0x9800             LDR      R0,[SP, #+0]
   \       0x42   0x0002             MOVS     R2,R0
   \       0x44   0xE005             B.N      ??sli_se_get_key_input_output_7
    730              }
    731          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    732              else if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED) {
   \                     ??sli_se_get_key_input_output_6: (+1)
   \       0x46   0x68E0             LDR      R0,[R4, #+12]
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD102             BNE.N    ??sli_se_get_key_input_output_7
    733                total_storage_size = storage_size + SLI_SE_WRAPPED_KEY_OVERHEAD;
   \       0x4C   0x9800             LDR      R0,[SP, #+0]
   \       0x4E   0x301C             ADDS     R0,R0,#+28
   \       0x50   0x0002             MOVS     R2,R0
    734              }
    735          #endif
    736          
    737              if (total_storage_size > key->storage.location.buffer.size) {
   \                     ??sli_se_get_key_input_output_7: (+1)
   \       0x52   0x6960             LDR      R0,[R4, #+20]
   \       0x54   0x4290             CMP      R0,R2
   \       0x56   0xD201             BCS.N    ??sli_se_get_key_input_output_8
    738                return SL_STATUS_WOULD_OVERFLOW;
   \       0x58   0x201D             MOVS     R0,#+29
   \       0x5A   0xE011             B.N      ??sli_se_get_key_input_output_2
    739              }
    740          
    741              buffer->data = key->storage.location.buffer.pointer;
   \                     ??sli_se_get_key_input_output_8: (+1)
   \       0x5C   0x6920             LDR      R0,[R4, #+16]
   \       0x5E   0x6028             STR      R0,[R5, #+0]
    742              buffer->length = total_storage_size | SE_DATATRANSFER_REALIGN;
   \       0x60   0xF052 0x5200      ORRS     R2,R2,#0x20000000
   \       0x64   0x60AA             STR      R2,[R5, #+8]
   \       0x66   0xE00A             B.N      ??sli_se_get_key_input_output_9
    743            } else if ((key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE)
    744          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    745                       || (key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
    746          #endif
    747                       ) {
   \                     ??sli_se_get_key_input_output_4: (+1)
   \       0x68   0x68E0             LDR      R0,[R4, #+12]
   \       0x6A   0x2803             CMP      R0,#+3
   \       0x6C   0xD002             BEQ.N    ??sli_se_get_key_input_output_10
   \       0x6E   0x68E0             LDR      R0,[R4, #+12]
   \       0x70   0x2802             CMP      R0,#+2
   \       0x72   0xD102             BNE.N    ??sli_se_get_key_input_output_11
    748              buffer->length = 0;
   \                     ??sli_se_get_key_input_output_10: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x60A8             STR      R0,[R5, #+8]
   \       0x78   0xE001             B.N      ??sli_se_get_key_input_output_9
    749            } else {
    750              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_get_key_input_output_11: (+1)
   \       0x7A   0x2021             MOVS     R0,#+33
   \       0x7C   0xE000             B.N      ??sli_se_get_key_input_output_2
    751            }
    752          
    753            return SL_STATUS_OK;
   \                     ??sli_se_get_key_input_output_9: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \                     ??sli_se_get_key_input_output_2: (+1)
   \       0x80   0xBD32             POP      {R1,R4,R5,PC}
    754          }
    755          
    756          /***************************************************************************//**
    757           * Validate key descriptor.
    758           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    759          sl_status_t sl_se_validate_key(const sl_se_key_descriptor_t *key)
    760          {
   \                     sl_se_validate_key: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
    761            sl_status_t status = SL_STATUS_OK;
   \        0x6   0x2500             MOVS     R5,#+0
    762            uint32_t keyspec = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
    763          
    764            if (key == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD101             BNE.N    ??sl_se_validate_key_0
    765              return SL_STATUS_INVALID_PARAMETER;
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE017             B.N      ??sl_se_validate_key_1
    766            }
    767          
    768            status = sli_se_key_to_keyspec(key, &keyspec);
   \                     ??sl_se_validate_key_0: (+1)
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x1C   0x0006             MOVS     R6,R0
    769            if (status != SL_STATUS_OK) {
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD001             BEQ.N    ??sl_se_validate_key_2
    770              return status;
   \       0x22   0x0030             MOVS     R0,R6
   \       0x24   0xE00E             B.N      ??sl_se_validate_key_1
    771            }
    772          
    773            SE_DataTransfer_t auth_buffer;
    774            status = sli_se_get_auth_buffer(key, &auth_buffer);
   \                     ??sl_se_validate_key_2: (+1)
   \       0x26   0xA904             ADD      R1,SP,#+16
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x2E   0x0005             MOVS     R5,R0
    775            if (status != SL_STATUS_OK) {
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xD001             BEQ.N    ??sl_se_validate_key_3
    776              return status;
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0xE005             B.N      ??sl_se_validate_key_1
    777            }
    778          
    779            SE_DataTransfer_t key_buffer;
    780            status = sli_se_get_key_input_output(key, &key_buffer);
   \                     ??sl_se_validate_key_3: (+1)
   \       0x38   0xA901             ADD      R1,SP,#+4
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       sli_se_get_key_input_output
    781            if (status != SL_STATUS_OK) {
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD1FF             BNE.N    ??sl_se_validate_key_1
    782              return status;
    783            }
    784          
    785            return status;
   \                     ??sl_se_validate_key_4: (+1)
   \                     ??sl_se_validate_key_1: (+1)
   \       0x44   0xB008             ADD      SP,SP,#+32
   \       0x46   0xBD70             POP      {R4-R6,PC}
    786          }
    787          
    788          /***************************************************************************//**
    789           * Generate a random key adhering to the given key descriptor
    790           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    791          sl_status_t sl_se_generate_key(sl_se_command_context_t *cmd_ctx,
    792                                         const sl_se_key_descriptor_t *key_out)
    793          {
   \                     sl_se_generate_key: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB099             SUB      SP,SP,#+100
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
    794            sl_status_t status;
    795          
    796            if (cmd_ctx == NULL || key_out == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD001             BEQ.N    ??sl_se_generate_key_0
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD101             BNE.N    ??sl_se_generate_key_1
    797              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_generate_key_0: (+1)
   \       0x12   0x2021             MOVS     R0,#+33
   \       0x14   0xE07C             B.N      ??sl_se_generate_key_2
    798            }
    799          
    800            // Initialize command
    801            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CREATE_KEY);
   \                     ??sl_se_generate_key_1: (+1)
   \       0x16   0xF05F 0x7000      MOVS     R0,#+33554432
   \       0x1A   0x6020             STR      R0,[R4, #+0]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x6060             STR      R0,[R4, #+4]
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x60A0             STR      R0,[R4, #+8]
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x61E0             STR      R0,[R4, #+28]
    802          
    803            // Add key parameters to command
    804            sli_add_key_parameters(cmd_ctx, key_out, status);
   \       0x28   0x4669             MOV      R1,SP
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x30   0x0006             MOVS     R6,R0
   \       0x32   0x2E00             CMP      R6,#+0
   \       0x34   0xD001             BEQ.N    ??sl_se_generate_key_3
   \       0x36   0x0030             MOVS     R0,R6
   \       0x38   0xE06A             B.N      ??sl_se_generate_key_2
   \                     ??sl_se_generate_key_3: (+1)
   \       0x3A   0x9900             LDR      R1,[SP, #+0]
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       SE_addParameter
    805          
    806          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    807            SE_Command_t *se_cmd = &cmd_ctx->command;
   \       0x42   0x46A0             MOV      R8,R4
    808            // Custom curve domain
    809            SE_DataTransfer_t domain_p_buffer;
    810            SE_DataTransfer_t domain_N_buffer;
    811            SE_DataTransfer_t domain_Gx_buffer;
    812            SE_DataTransfer_t domain_Gy_buffer;
    813            SE_DataTransfer_t domain_a_buffer;
    814            SE_DataTransfer_t domain_b_buffer;
    815          
    816            if (key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) {
   \       0x44   0x68A8             LDR      R0,[R5, #+8]
   \       0x46   0x04C0             LSLS     R0,R0,#+19
   \       0x48   0xD545             BPL.N    ??sl_se_generate_key_4
    817              if (key_out->type & SL_SE_KEY_TYPE_ECC_WEIERSTRASS_PRIME_CUSTOM) {
   \       0x4A   0x6828             LDR      R0,[R5, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD540             BPL.N    ??sl_se_generate_key_5
    818                sl_se_custom_weierstrass_prime_domain_t *domain = (sl_se_custom_weierstrass_prime_domain_t*)key_out->domain;
   \       0x50   0xF8D5 0x901C      LDR      R9,[R5, #+28]
    819                uint32_t domain_size = domain->size;
   \       0x54   0xF8D9 0x7000      LDR      R7,[R9, #+0]
    820          
    821                domain_p_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0x9011             STR      R0,[SP, #+68]
    822                domain_p_buffer.data = (void*)domain->p;
   \       0x5C   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x60   0x9010             STR      R0,[SP, #+64]
    823                domain_p_buffer.length = domain_size;
   \       0x62   0x9712             STR      R7,[SP, #+72]
    824                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_p_buffer);
   \       0x64   0xA910             ADD      R1,SP,#+64
   \       0x66   0x4640             MOV      R0,R8
   \       0x68   0x.... 0x....      BL       SE_addDataInput
    825          
    826                domain_N_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0x900E             STR      R0,[SP, #+56]
    827                domain_N_buffer.data = (void*)domain->N;
   \       0x70   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x74   0x900D             STR      R0,[SP, #+52]
    828                domain_N_buffer.length = domain_size;
   \       0x76   0x970F             STR      R7,[SP, #+60]
    829                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_N_buffer);
   \       0x78   0xA90D             ADD      R1,SP,#+52
   \       0x7A   0x4640             MOV      R0,R8
   \       0x7C   0x.... 0x....      BL       SE_addDataInput
    830          
    831                domain_Gx_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0x900B             STR      R0,[SP, #+44]
    832                domain_Gx_buffer.data = (void*)domain->Gx;
   \       0x84   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0x88   0x900A             STR      R0,[SP, #+40]
    833                domain_Gx_buffer.length = domain_size;
   \       0x8A   0x970C             STR      R7,[SP, #+48]
    834                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_Gx_buffer);
   \       0x8C   0xA90A             ADD      R1,SP,#+40
   \       0x8E   0x4640             MOV      R0,R8
   \       0x90   0x.... 0x....      BL       SE_addDataInput
    835          
    836                domain_Gy_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0x9008             STR      R0,[SP, #+32]
    837                domain_Gy_buffer.data = (void*)domain->Gy;
   \       0x98   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x9C   0x9007             STR      R0,[SP, #+28]
    838                domain_Gy_buffer.length = domain_size;
   \       0x9E   0x9709             STR      R7,[SP, #+36]
    839                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_Gy_buffer);
   \       0xA0   0xA907             ADD      R1,SP,#+28
   \       0xA2   0x4640             MOV      R0,R8
   \       0xA4   0x.... 0x....      BL       SE_addDataInput
    840          
    841                domain_a_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0x9005             STR      R0,[SP, #+20]
    842                domain_a_buffer.data = (void*)domain->a;
   \       0xAC   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \       0xB0   0x9004             STR      R0,[SP, #+16]
    843                domain_a_buffer.length = domain_size;
   \       0xB2   0x9706             STR      R7,[SP, #+24]
    844                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_a_buffer);
   \       0xB4   0xA904             ADD      R1,SP,#+16
   \       0xB6   0x4640             MOV      R0,R8
   \       0xB8   0x.... 0x....      BL       SE_addDataInput
    845          
    846                domain_b_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0xBC   0x2001             MOVS     R0,#+1
   \       0xBE   0x9002             STR      R0,[SP, #+8]
    847                domain_b_buffer.data = (void*)domain->b;
   \       0xC0   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \       0xC4   0x9001             STR      R0,[SP, #+4]
    848                domain_b_buffer.length = domain_size;
   \       0xC6   0x9703             STR      R7,[SP, #+12]
    849                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_b_buffer);
   \       0xC8   0xA901             ADD      R1,SP,#+4
   \       0xCA   0x4640             MOV      R0,R8
   \       0xCC   0x.... 0x....      BL       SE_addDataInput
   \       0xD0   0xE001             B.N      ??sl_se_generate_key_4
    850              } else {
    851                return SL_STATUS_NOT_SUPPORTED;
   \                     ??sl_se_generate_key_5: (+1)
   \       0xD2   0x200F             MOVS     R0,#+15
   \       0xD4   0xE01C             B.N      ??sl_se_generate_key_2
    852              }
    853            }
    854          #endif
    855          
    856            // Add key metadata block to command
    857            sli_add_key_metadata(cmd_ctx, key_out, status);
   \                     ??sl_se_generate_key_4: (+1)
   \       0xD6   0xA916             ADD      R1,SP,#+88
   \       0xD8   0x0028             MOVS     R0,R5
   \       0xDA   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xDE   0x0007             MOVS     R7,R0
   \       0xE0   0x2F00             CMP      R7,#+0
   \       0xE2   0xD001             BEQ.N    ??sl_se_generate_key_6
   \       0xE4   0x0038             MOVS     R0,R7
   \       0xE6   0xE013             B.N      ??sl_se_generate_key_2
   \                     ??sl_se_generate_key_6: (+1)
   \       0xE8   0xA916             ADD      R1,SP,#+88
   \       0xEA   0x0020             MOVS     R0,R4
   \       0xEC   0x.... 0x....      BL       SE_addDataInput
    858            // Add key output block to command
    859            sli_add_key_output(cmd_ctx, key_out, status);
   \       0xF0   0xA913             ADD      R1,SP,#+76
   \       0xF2   0x0028             MOVS     R0,R5
   \       0xF4   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xF8   0x0006             MOVS     R6,R0
   \       0xFA   0x2E00             CMP      R6,#+0
   \       0xFC   0xD001             BEQ.N    ??sl_se_generate_key_7
   \       0xFE   0x0030             MOVS     R0,R6
   \      0x100   0xE006             B.N      ??sl_se_generate_key_2
   \                     ??sl_se_generate_key_7: (+1)
   \      0x102   0xA913             ADD      R1,SP,#+76
   \      0x104   0x0020             MOVS     R0,R4
   \      0x106   0x.... 0x....      BL       SE_addDataOutput
    860          
    861            // Execute command
    862            status = sli_se_execute_and_wait(cmd_ctx);
   \      0x10A   0x0020             MOVS     R0,R4
   \      0x10C   0x.... 0x....      BL       sli_se_execute_and_wait
    863          
    864            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    865            // Clear padding for plaintext keys upon success
    866            if (status == SL_STATUS_OK) {
    867              status = clear_padding(key_out);
    868            }
    869            #endif
    870          
    871            return status;
   \                     ??sl_se_generate_key_2: (+1)
   \      0x110   0xB019             ADD      SP,SP,#+100
   \      0x112   0xE8BD 0x83F0      POP      {R4-R9,PC}
    872          }
    873          
    874          /***************************************************************************//**
    875           * Export the public key of an ECC keypair
    876           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    877          sl_status_t sl_se_export_public_key(sl_se_command_context_t *cmd_ctx,
    878                                              const sl_se_key_descriptor_t *key_in,
    879                                              const sl_se_key_descriptor_t *key_out)
    880          {
   \                     sl_se_export_public_key: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
    881            if (cmd_ctx == NULL || key_in == NULL || key_out == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD003             BEQ.N    ??sl_se_export_public_key_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD001             BEQ.N    ??sl_se_export_public_key_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD101             BNE.N    ??sl_se_export_public_key_1
    882              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_export_public_key_0: (+1)
   \       0x18   0x2021             MOVS     R0,#+33
   \       0x1A   0xE086             B.N      ??sl_se_export_public_key_2
    883            }
    884          
    885            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_export_public_key_1: (+1)
   \       0x1C   0x46A1             MOV      R9,R4
    886            sl_status_t status;
    887          
    888            // Check input/output key type and size relationship
    889            status = sli_key_check_equivalent(key_in, key_out, true, true);
   \       0x1E   0x2301             MOVS     R3,#+1
   \       0x20   0x2201             MOVS     R2,#+1
   \       0x22   0x0031             MOVS     R1,R6
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       sli_key_check_equivalent
   \       0x2A   0x0007             MOVS     R7,R0
    890            if (status != SL_STATUS_OK) {
   \       0x2C   0x2F00             CMP      R7,#+0
   \       0x2E   0xD001             BEQ.N    ??sl_se_export_public_key_3
    891              return status;
   \       0x30   0x0038             MOVS     R0,R7
   \       0x32   0xE07A             B.N      ??sl_se_export_public_key_2
    892            }
    893          
    894            // Check that the input key has a private or public key
    895            if (!(key_in->flags & (SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY
    896                                   | SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY))) {
   \                     ??sl_se_export_public_key_3: (+1)
   \       0x34   0x68A8             LDR      R0,[R5, #+8]
   \       0x36   0xF410 0x4FC0      TST      R0,#0x6000
   \       0x3A   0xD101             BNE.N    ??sl_se_export_public_key_4
    897              return SL_STATUS_INVALID_PARAMETER;
   \       0x3C   0x2021             MOVS     R0,#+33
   \       0x3E   0xE074             B.N      ??sl_se_export_public_key_2
    898            }
    899            if (!(key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY)
    900                || (key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY)) {
   \                     ??sl_se_export_public_key_4: (+1)
   \       0x40   0x68B0             LDR      R0,[R6, #+8]
   \       0x42   0xF410 0x40C0      ANDS     R0,R0,#0x6000
   \       0x46   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x4A   0xD001             BEQ.N    ??sl_se_export_public_key_5
    901              return SL_STATUS_INVALID_PARAMETER;
   \       0x4C   0x2021             MOVS     R0,#+33
   \       0x4E   0xE06C             B.N      ??sl_se_export_public_key_2
    902            }
    903          
    904            // Initialize command
    905            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READPUB_KEY);
   \                     ??sl_se_export_public_key_5: (+1)
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \       0x54   0x6020             STR      R0,[R4, #+0]
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x6060             STR      R0,[R4, #+4]
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x60A0             STR      R0,[R4, #+8]
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x61E0             STR      R0,[R4, #+28]
    906          
    907            // Add key parameters to command
    908            sli_add_key_parameters(cmd_ctx, key_in, status);
   \       0x62   0xA901             ADD      R1,SP,#+4
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x6A   0x4680             MOV      R8,R0
   \       0x6C   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x70   0xD001             BEQ.N    ??sl_se_export_public_key_6
   \       0x72   0x4640             MOV      R0,R8
   \       0x74   0xE059             B.N      ??sl_se_export_public_key_2
   \                     ??sl_se_export_public_key_6: (+1)
   \       0x76   0x9901             LDR      R1,[SP, #+4]
   \       0x78   0x0020             MOVS     R0,R4
   \       0x7A   0x.... 0x....      BL       SE_addParameter
    909            // Add key metadata block to command
    910            sli_add_key_metadata(cmd_ctx, key_in, status);
   \       0x7E   0xA908             ADD      R1,SP,#+32
   \       0x80   0x0028             MOVS     R0,R5
   \       0x82   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x86   0x0007             MOVS     R7,R0
   \       0x88   0x2F00             CMP      R7,#+0
   \       0x8A   0xD001             BEQ.N    ??sl_se_export_public_key_7
   \       0x8C   0x0038             MOVS     R0,R7
   \       0x8E   0xE04C             B.N      ??sl_se_export_public_key_2
   \                     ??sl_se_export_public_key_7: (+1)
   \       0x90   0xA908             ADD      R1,SP,#+32
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x.... 0x....      BL       SE_addDataInput
    911            // Add key input block to command
    912            sli_add_key_input(cmd_ctx, key_in, status);
   \       0x98   0xA905             ADD      R1,SP,#+20
   \       0x9A   0x0028             MOVS     R0,R5
   \       0x9C   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xA0   0x4680             MOV      R8,R0
   \       0xA2   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xA6   0xD001             BEQ.N    ??sl_se_export_public_key_8
   \       0xA8   0x4640             MOV      R0,R8
   \       0xAA   0xE03E             B.N      ??sl_se_export_public_key_2
   \                     ??sl_se_export_public_key_8: (+1)
   \       0xAC   0xA905             ADD      R1,SP,#+20
   \       0xAE   0x0020             MOVS     R0,R4
   \       0xB0   0x.... 0x....      BL       SE_addDataInput
    913          
    914            // Pubkey buffer
    915            // Check for correct storage and flags
    916            if ((key_out->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
    917                || (key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY)
    918                || !(key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY)) {
   \       0xB4   0x68F0             LDR      R0,[R6, #+12]
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD105             BNE.N    ??sl_se_export_public_key_9
   \       0xBA   0x68B0             LDR      R0,[R6, #+8]
   \       0xBC   0xF410 0x40C0      ANDS     R0,R0,#0x6000
   \       0xC0   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0xC4   0xD001             BEQ.N    ??sl_se_export_public_key_10
    919              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_export_public_key_9: (+1)
   \       0xC6   0x2021             MOVS     R0,#+33
   \       0xC8   0xE02F             B.N      ??sl_se_export_public_key_2
    920            }
    921          
    922            uint32_t required_storage_size;
    923            status = sli_key_get_storage_size(key_out, &required_storage_size);
   \                     ??sl_se_export_public_key_10: (+1)
   \       0xCA   0x4669             MOV      R1,SP
   \       0xCC   0x0030             MOVS     R0,R6
   \       0xCE   0x.... 0x....      BL       sli_key_get_storage_size
   \       0xD2   0x0007             MOVS     R7,R0
    924            if (status != SL_STATUS_OK) {
   \       0xD4   0x2F00             CMP      R7,#+0
   \       0xD6   0xD001             BEQ.N    ??sl_se_export_public_key_11
    925              return status;
   \       0xD8   0x0038             MOVS     R0,R7
   \       0xDA   0xE026             B.N      ??sl_se_export_public_key_2
    926            }
    927          
    928            if (required_storage_size > key_out->storage.location.buffer.size) {
   \                     ??sl_se_export_public_key_11: (+1)
   \       0xDC   0x6971             LDR      R1,[R6, #+20]
   \       0xDE   0x9800             LDR      R0,[SP, #+0]
   \       0xE0   0x4281             CMP      R1,R0
   \       0xE2   0xD201             BCS.N    ??sl_se_export_public_key_12
    929              return SL_STATUS_WOULD_OVERFLOW;
   \       0xE4   0x201D             MOVS     R0,#+29
   \       0xE6   0xE020             B.N      ??sl_se_export_public_key_2
    930            }
    931          
    932            SE_DataTransfer_t pubkey_buffer = SE_DATATRANSFER_DEFAULT(
    933              key_out->storage.location.buffer.pointer, required_storage_size);
   \                     ??sl_se_export_public_key_12: (+1)
   \       0xE8   0xF10D 0x0C08      ADD      R12,SP,#+8
   \       0xEC   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \       0xF0   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xF4   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xF8   0x6930             LDR      R0,[R6, #+16]
   \       0xFA   0x9002             STR      R0,[SP, #+8]
   \       0xFC   0x9800             LDR      R0,[SP, #+0]
   \       0xFE   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x102   0x9004             STR      R0,[SP, #+16]
    934            SE_addDataOutput(se_cmd, &pubkey_buffer);
   \      0x104   0xA902             ADD      R1,SP,#+8
   \      0x106   0x4648             MOV      R0,R9
   \      0x108   0x.... 0x....      BL       SE_addDataOutput
    935          
    936            // Execute command.
    937            // The retries are necessary in order to reduce the risk of random failures
    938            // in the accelerated point multiplication. This mainly affects very small or
    939            // large scalars, which in this case would be the private key.
    940            for (size_t i = 0; i < SLI_SE_MAX_POINT_MULT_RETRIES; ++i) {
   \      0x10C   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??sl_se_export_public_key_13: (+1)
   \      0x110   0xF1B8 0x0F03      CMP      R8,#+3
   \      0x114   0xD208             BCS.N    ??sl_se_export_public_key_14
    941              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x116   0x0020             MOVS     R0,R4
   \      0x118   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x11C   0x0007             MOVS     R7,R0
    942              if (status != SL_STATUS_FAIL) {
   \      0x11E   0x2F01             CMP      R7,#+1
   \      0x120   0xD102             BNE.N    ??sl_se_export_public_key_14
    943                break;
    944              }
    945            }
   \                     ??sl_se_export_public_key_15: (+1)
   \      0x122   0xF118 0x0801      ADDS     R8,R8,#+1
   \      0x126   0xE7F3             B.N      ??sl_se_export_public_key_13
    946            return status;
   \                     ??sl_se_export_public_key_14: (+1)
   \      0x128   0x0038             MOVS     R0,R7
   \                     ??sl_se_export_public_key_2: (+1)
   \      0x12A   0xB00B             ADD      SP,SP,#+44
   \      0x12C   0xE8BD 0x83F0      POP      {R4-R9,PC}
    947          }

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    948          
    949          /***************************************************************************//**
    950           * Returns the required storage size for the given key
    951           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    952          sl_status_t sl_se_get_storage_size(const sl_se_key_descriptor_t *key, uint32_t *storage_size)
    953          {
   \                     sl_se_get_storage_size: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    954            if (key == NULL || storage_size == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sl_se_get_storage_size_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sl_se_get_storage_size_1
    955              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_storage_size_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE01E             B.N      ??sl_se_get_storage_size_2
    956            }
    957          
    958            if ((key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
    959          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    960                || (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED)
    961          #endif
    962                ) {
   \                     ??sl_se_get_storage_size_1: (+1)
   \       0x12   0x68E0             LDR      R0,[R4, #+12]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??sl_se_get_storage_size_3
   \       0x18   0x68E0             LDR      R0,[R4, #+12]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10C             BNE.N    ??sl_se_get_storage_size_4
    963              // Set or adjust the key attributes for different key types
    964              sl_status_t status = sli_key_get_storage_size(key, storage_size);
   \                     ??sl_se_get_storage_size_3: (+1)
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       sli_key_get_storage_size
    965              if (status != SL_STATUS_OK) {
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD112             BNE.N    ??sl_se_get_storage_size_2
    966                return status;
    967              }
    968          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    969              if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED) {
   \                     ??sl_se_get_storage_size_5: (+1)
   \       0x2A   0x68E1             LDR      R1,[R4, #+12]
   \       0x2C   0x2901             CMP      R1,#+1
   \       0x2E   0xD10E             BNE.N    ??sl_se_get_storage_size_6
    970                *storage_size = *storage_size + SLI_SE_WRAPPED_KEY_OVERHEAD;
   \       0x30   0x6829             LDR      R1,[R5, #+0]
   \       0x32   0x311C             ADDS     R1,R1,#+28
   \       0x34   0x6029             STR      R1,[R5, #+0]
   \       0x36   0xE00A             B.N      ??sl_se_get_storage_size_6
    971              }
    972          #endif
    973            } else if ((key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE)
    974          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    975                       || (key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
    976          #endif
    977                       ) {
   \                     ??sl_se_get_storage_size_4: (+1)
   \       0x38   0x68E0             LDR      R0,[R4, #+12]
   \       0x3A   0x2803             CMP      R0,#+3
   \       0x3C   0xD002             BEQ.N    ??sl_se_get_storage_size_7
   \       0x3E   0x68E0             LDR      R0,[R4, #+12]
   \       0x40   0x2802             CMP      R0,#+2
   \       0x42   0xD102             BNE.N    ??sl_se_get_storage_size_8
    978              *storage_size = 0;
   \                     ??sl_se_get_storage_size_7: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x6028             STR      R0,[R5, #+0]
   \       0x48   0xE001             B.N      ??sl_se_get_storage_size_6
    979            } else {
    980              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_storage_size_8: (+1)
   \       0x4A   0x2021             MOVS     R0,#+33
   \       0x4C   0xE000             B.N      ??sl_se_get_storage_size_2
    981            }
    982          
    983            return SL_STATUS_OK;
   \                     ??sl_se_get_storage_size_6: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??sl_se_get_storage_size_2: (+1)
   \       0x50   0xBD32             POP      {R1,R4,R5,PC}
    984          }
    985          
    986          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    987          /***************************************************************************//**
    988           * Protect a plaintext key using the SE
    989           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    990          sl_status_t sl_se_import_key(sl_se_command_context_t *cmd_ctx,
    991                                       const sl_se_key_descriptor_t *key_in,
    992                                       const sl_se_key_descriptor_t *key_out)
    993          {
   \                     sl_se_import_key: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
    994            sl_status_t status;
    995          
    996            if (cmd_ctx == NULL || key_in == NULL || key_out == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD003             BEQ.N    ??sl_se_import_key_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD001             BEQ.N    ??sl_se_import_key_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD101             BNE.N    ??sl_se_import_key_1
    997              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_import_key_0: (+1)
   \       0x18   0x2021             MOVS     R0,#+33
   \       0x1A   0xE057             B.N      ??sl_se_import_key_2
    998            }
    999          
   1000            // Check input/output key type and size relationship
   1001            status = sli_key_check_equivalent(key_in, key_out, true, false);
   \                     ??sl_se_import_key_1: (+1)
   \       0x1C   0x2300             MOVS     R3,#+0
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0x0031             MOVS     R1,R6
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       sli_key_check_equivalent
   \       0x28   0x0007             MOVS     R7,R0
   1002            if (status != SL_STATUS_OK) {
   \       0x2A   0x2F00             CMP      R7,#+0
   \       0x2C   0xD001             BEQ.N    ??sl_se_import_key_3
   1003              return status;
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0xE04C             B.N      ??sl_se_import_key_2
   1004            }
   1005          
   1006            if ((key_in->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
   1007                || ((key_out->storage.method != SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
   1008                    && (key_out->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED))) {
   \                     ??sl_se_import_key_3: (+1)
   \       0x32   0x68E8             LDR      R0,[R5, #+12]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD105             BNE.N    ??sl_se_import_key_4
   \       0x38   0x68F0             LDR      R0,[R6, #+12]
   \       0x3A   0x2802             CMP      R0,#+2
   \       0x3C   0xD004             BEQ.N    ??sl_se_import_key_5
   \       0x3E   0x68F0             LDR      R0,[R6, #+12]
   \       0x40   0x2801             CMP      R0,#+1
   \       0x42   0xD001             BEQ.N    ??sl_se_import_key_5
   1009              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_import_key_4: (+1)
   \       0x44   0x2021             MOVS     R0,#+33
   \       0x46   0xE041             B.N      ??sl_se_import_key_2
   1010            }
   1011          
   1012            // Initialize command
   1013            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_WRAP_KEY);
   \                     ??sl_se_import_key_5: (+1)
   \       0x48   0xF05F 0x7080      MOVS     R0,#+16777216
   \       0x4C   0x6020             STR      R0,[R4, #+0]
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x6060             STR      R0,[R4, #+4]
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x60A0             STR      R0,[R4, #+8]
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x61E0             STR      R0,[R4, #+28]
   1014          
   1015            // Add key parameters to command
   1016            sli_add_key_parameters(cmd_ctx, key_out, status);
   \       0x5A   0x4669             MOV      R1,SP
   \       0x5C   0x0030             MOVS     R0,R6
   \       0x5E   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x62   0x4680             MOV      R8,R0
   \       0x64   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x68   0xD001             BEQ.N    ??sl_se_import_key_6
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0xE02E             B.N      ??sl_se_import_key_2
   \                     ??sl_se_import_key_6: (+1)
   \       0x6E   0x9900             LDR      R1,[SP, #+0]
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x.... 0x....      BL       SE_addParameter
   1017          
   1018            // Add key input block to command
   1019            sli_add_key_input(cmd_ctx, key_in, status);
   \       0x76   0xA907             ADD      R1,SP,#+28
   \       0x78   0x0028             MOVS     R0,R5
   \       0x7A   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x7E   0x0007             MOVS     R7,R0
   \       0x80   0x2F00             CMP      R7,#+0
   \       0x82   0xD001             BEQ.N    ??sl_se_import_key_7
   \       0x84   0x0038             MOVS     R0,R7
   \       0x86   0xE021             B.N      ??sl_se_import_key_2
   \                     ??sl_se_import_key_7: (+1)
   \       0x88   0xA907             ADD      R1,SP,#+28
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x.... 0x....      BL       SE_addDataInput
   1020          
   1021            // Add key metadata block to command
   1022            sli_add_key_metadata(cmd_ctx, key_out, status);
   \       0x90   0xA904             ADD      R1,SP,#+16
   \       0x92   0x0030             MOVS     R0,R6
   \       0x94   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x98   0x4680             MOV      R8,R0
   \       0x9A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x9E   0xD001             BEQ.N    ??sl_se_import_key_8
   \       0xA0   0x4640             MOV      R0,R8
   \       0xA2   0xE013             B.N      ??sl_se_import_key_2
   \                     ??sl_se_import_key_8: (+1)
   \       0xA4   0xA904             ADD      R1,SP,#+16
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0x.... 0x....      BL       SE_addDataInput
   1023          
   1024            // Add key output block to command
   1025            sli_add_key_output(cmd_ctx, key_out, status);
   \       0xAC   0xA901             ADD      R1,SP,#+4
   \       0xAE   0x0030             MOVS     R0,R6
   \       0xB0   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xB4   0x0007             MOVS     R7,R0
   \       0xB6   0x2F00             CMP      R7,#+0
   \       0xB8   0xD001             BEQ.N    ??sl_se_import_key_9
   \       0xBA   0x0038             MOVS     R0,R7
   \       0xBC   0xE006             B.N      ??sl_se_import_key_2
   \                     ??sl_se_import_key_9: (+1)
   \       0xBE   0xA901             ADD      R1,SP,#+4
   \       0xC0   0x0020             MOVS     R0,R4
   \       0xC2   0x.... 0x....      BL       SE_addDataOutput
   1026          
   1027            status = sli_se_execute_and_wait(cmd_ctx);
   \       0xC6   0x0020             MOVS     R0,R4
   \       0xC8   0x.... 0x....      BL       sli_se_execute_and_wait
   1028            return status;
   \                     ??sl_se_import_key_2: (+1)
   \       0xCC   0xB00A             ADD      SP,SP,#+40
   \       0xCE   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1029          }
   1030          
   1031          /***************************************************************************//**
   1032           * Export a volatile or wrapped key back to plaintext if allowed
   1033           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1034          sl_status_t sl_se_export_key(sl_se_command_context_t *cmd_ctx,
   1035                                       const sl_se_key_descriptor_t *key_in,
   1036                                       const sl_se_key_descriptor_t *key_out)
   1037          {
   \                     sl_se_export_key: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   1038            sl_status_t status;
   1039          
   1040            if (cmd_ctx == NULL || key_in == NULL || key_out == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD003             BEQ.N    ??sl_se_export_key_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD001             BEQ.N    ??sl_se_export_key_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD101             BNE.N    ??sl_se_export_key_1
   1041              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_export_key_0: (+1)
   \       0x18   0x2021             MOVS     R0,#+33
   \       0x1A   0xE057             B.N      ??sl_se_export_key_2
   1042            }
   1043          
   1044            // Check input/output key type and size relationship
   1045            status = sli_key_check_equivalent(key_in, key_out, true, false);
   \                     ??sl_se_export_key_1: (+1)
   \       0x1C   0x2300             MOVS     R3,#+0
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0x0031             MOVS     R1,R6
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       sli_key_check_equivalent
   \       0x28   0x0007             MOVS     R7,R0
   1046            if (status != SL_STATUS_OK) {
   \       0x2A   0x2F00             CMP      R7,#+0
   \       0x2C   0xD001             BEQ.N    ??sl_se_export_key_3
   1047              return status;
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0xE04C             B.N      ??sl_se_export_key_2
   1048            }
   1049          
   1050            if ((key_out->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
   1051                || ((key_in->storage.method != SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
   1052                    && (key_in->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED))) {
   \                     ??sl_se_export_key_3: (+1)
   \       0x32   0x68F0             LDR      R0,[R6, #+12]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD105             BNE.N    ??sl_se_export_key_4
   \       0x38   0x68E8             LDR      R0,[R5, #+12]
   \       0x3A   0x2802             CMP      R0,#+2
   \       0x3C   0xD004             BEQ.N    ??sl_se_export_key_5
   \       0x3E   0x68E8             LDR      R0,[R5, #+12]
   \       0x40   0x2801             CMP      R0,#+1
   \       0x42   0xD001             BEQ.N    ??sl_se_export_key_5
   1053              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_export_key_4: (+1)
   \       0x44   0x2021             MOVS     R0,#+33
   \       0x46   0xE041             B.N      ??sl_se_export_key_2
   1054            }
   1055          
   1056            // Initialize command
   1057            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_UNWRAP_KEY);
   \                     ??sl_se_export_key_5: (+1)
   \       0x48   0xF05F 0x7081      MOVS     R0,#+16908288
   \       0x4C   0x6020             STR      R0,[R4, #+0]
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x6060             STR      R0,[R4, #+4]
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x60A0             STR      R0,[R4, #+8]
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x61E0             STR      R0,[R4, #+28]
   1058          
   1059            // Add key parameters to command
   1060            sli_add_key_parameters(cmd_ctx, key_in, status);
   \       0x5A   0x4669             MOV      R1,SP
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x62   0x4680             MOV      R8,R0
   \       0x64   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x68   0xD001             BEQ.N    ??sl_se_export_key_6
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0xE02E             B.N      ??sl_se_export_key_2
   \                     ??sl_se_export_key_6: (+1)
   \       0x6E   0x9900             LDR      R1,[SP, #+0]
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x.... 0x....      BL       SE_addParameter
   1061          
   1062            // Add key metadata block to command
   1063            sli_add_key_metadata(cmd_ctx, key_in, status);
   \       0x76   0xA907             ADD      R1,SP,#+28
   \       0x78   0x0028             MOVS     R0,R5
   \       0x7A   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x7E   0x0007             MOVS     R7,R0
   \       0x80   0x2F00             CMP      R7,#+0
   \       0x82   0xD001             BEQ.N    ??sl_se_export_key_7
   \       0x84   0x0038             MOVS     R0,R7
   \       0x86   0xE021             B.N      ??sl_se_export_key_2
   \                     ??sl_se_export_key_7: (+1)
   \       0x88   0xA907             ADD      R1,SP,#+28
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x.... 0x....      BL       SE_addDataInput
   1064          
   1065            // Add key input block to command
   1066            sli_add_key_input(cmd_ctx, key_in, status);
   \       0x90   0xA904             ADD      R1,SP,#+16
   \       0x92   0x0028             MOVS     R0,R5
   \       0x94   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x98   0x4680             MOV      R8,R0
   \       0x9A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x9E   0xD001             BEQ.N    ??sl_se_export_key_8
   \       0xA0   0x4640             MOV      R0,R8
   \       0xA2   0xE013             B.N      ??sl_se_export_key_2
   \                     ??sl_se_export_key_8: (+1)
   \       0xA4   0xA904             ADD      R1,SP,#+16
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0x.... 0x....      BL       SE_addDataInput
   1067          
   1068            // Add key output block to command
   1069            sli_add_key_output(cmd_ctx, key_out, status);
   \       0xAC   0xA901             ADD      R1,SP,#+4
   \       0xAE   0x0030             MOVS     R0,R6
   \       0xB0   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xB4   0x0007             MOVS     R7,R0
   \       0xB6   0x2F00             CMP      R7,#+0
   \       0xB8   0xD001             BEQ.N    ??sl_se_export_key_9
   \       0xBA   0x0038             MOVS     R0,R7
   \       0xBC   0xE006             B.N      ??sl_se_export_key_2
   \                     ??sl_se_export_key_9: (+1)
   \       0xBE   0xA901             ADD      R1,SP,#+4
   \       0xC0   0x0020             MOVS     R0,R4
   \       0xC2   0x.... 0x....      BL       SE_addDataOutput
   1070          
   1071            status = sli_se_execute_and_wait(cmd_ctx);
   \       0xC6   0x0020             MOVS     R0,R4
   \       0xC8   0x.... 0x....      BL       sli_se_execute_and_wait
   1072          
   1073            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1074            // The SE will only output word-aligned data. Clear the extra padding before
   1075            // returning
   1076            if (status == SL_STATUS_OK) {
   1077              status = clear_padding(key_out);
   1078            }
   1079            #endif
   1080          
   1081            return status;
   \                     ??sl_se_export_key_2: (+1)
   \       0xCC   0xB00A             ADD      SP,SP,#+40
   \       0xCE   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1082          }
   1083          
   1084          /***************************************************************************//**
   1085           * Transfer a protected (volatile/wrapped) key
   1086           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1087          sl_status_t sl_se_transfer_key(sl_se_command_context_t *cmd_ctx,
   1088                                         const sl_se_key_descriptor_t *key_in,
   1089                                         const sl_se_key_descriptor_t *key_out)
   1090          {
   \                     sl_se_transfer_key: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08E             SUB      SP,SP,#+56
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   1091            if (cmd_ctx == NULL || key_in == NULL || key_out == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD003             BEQ.N    ??sl_se_transfer_key_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD001             BEQ.N    ??sl_se_transfer_key_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD101             BNE.N    ??sl_se_transfer_key_1
   1092              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_transfer_key_0: (+1)
   \       0x18   0x2021             MOVS     R0,#+33
   \       0x1A   0xE088             B.N      ??sl_se_transfer_key_2
   1093            }
   1094          
   1095            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_transfer_key_1: (+1)
   \       0x1C   0x46A2             MOV      R10,R4
   1096            sl_status_t status;
   1097            SE_DataTransfer_t auth_buffer_out;
   1098            uint32_t key_update_index;
   1099            uint32_t key_update_mode;
   1100          
   1101            // Check input/output key type and size relationship
   1102            status = sli_key_check_equivalent(key_in, key_out, true, false);
   \       0x1E   0x2300             MOVS     R3,#+0
   \       0x20   0x2201             MOVS     R2,#+1
   \       0x22   0x0031             MOVS     R1,R6
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       sli_key_check_equivalent
   \       0x2A   0x0007             MOVS     R7,R0
   1103            if (status != SL_STATUS_OK) {
   \       0x2C   0x2F00             CMP      R7,#+0
   \       0x2E   0xD001             BEQ.N    ??sl_se_transfer_key_3
   1104              return status;
   \       0x30   0x0038             MOVS     R0,R7
   \       0x32   0xE07C             B.N      ??sl_se_transfer_key_2
   1105            }
   1106          
   1107            if ((key_in->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
   1108                || (key_in->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE)
   1109                || (key_out->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
   1110                || (key_out->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE)) {
   \                     ??sl_se_transfer_key_3: (+1)
   \       0x34   0x68E8             LDR      R0,[R5, #+12]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD008             BEQ.N    ??sl_se_transfer_key_4
   \       0x3A   0x68E8             LDR      R0,[R5, #+12]
   \       0x3C   0x2803             CMP      R0,#+3
   \       0x3E   0xD005             BEQ.N    ??sl_se_transfer_key_4
   \       0x40   0x68F0             LDR      R0,[R6, #+12]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD002             BEQ.N    ??sl_se_transfer_key_4
   \       0x46   0x68F0             LDR      R0,[R6, #+12]
   \       0x48   0x2803             CMP      R0,#+3
   \       0x4A   0xD101             BNE.N    ??sl_se_transfer_key_5
   1111              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_transfer_key_4: (+1)
   \       0x4C   0x2021             MOVS     R0,#+33
   \       0x4E   0xE06E             B.N      ??sl_se_transfer_key_2
   1112            }
   1113          
   1114            // Create command
   1115            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_TRANSFER_KEY);
   \                     ??sl_se_transfer_key_5: (+1)
   \       0x50   0xF05F 0x7083      MOVS     R0,#+17170432
   \       0x54   0x6020             STR      R0,[R4, #+0]
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x6060             STR      R0,[R4, #+4]
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x60A0             STR      R0,[R4, #+8]
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x61E0             STR      R0,[R4, #+28]
   1116          
   1117            // Add key input parameters to command
   1118            sli_add_key_parameters(cmd_ctx, key_in, status);
   \       0x62   0xA901             ADD      R1,SP,#+4
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x6A   0x4680             MOV      R8,R0
   \       0x6C   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x70   0xD001             BEQ.N    ??sl_se_transfer_key_6
   \       0x72   0x4640             MOV      R0,R8
   \       0x74   0xE05B             B.N      ??sl_se_transfer_key_2
   \                     ??sl_se_transfer_key_6: (+1)
   \       0x76   0x9901             LDR      R1,[SP, #+4]
   \       0x78   0x0020             MOVS     R0,R4
   \       0x7A   0x.... 0x....      BL       SE_addParameter
   1119          
   1120            // Add key update parameters to command
   1121            uint32_t keyspec_out;
   1122            status = sli_se_key_to_keyspec(key_out, &keyspec_out);
   \       0x7E   0x4669             MOV      R1,SP
   \       0x80   0x0030             MOVS     R0,R6
   \       0x82   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x86   0x0007             MOVS     R7,R0
   1123            if (status != SL_STATUS_OK) {
   \       0x88   0x2F00             CMP      R7,#+0
   \       0x8A   0xD001             BEQ.N    ??sl_se_transfer_key_7
   1124              return status;
   \       0x8C   0x0038             MOVS     R0,R7
   \       0x8E   0xE04E             B.N      ??sl_se_transfer_key_2
   1125            }
   1126            key_update_index = ((keyspec_out & KEYSPEC_INDEX_MASK) >> KEYSPEC_INDEX_OFFSET);
   \                     ??sl_se_transfer_key_7: (+1)
   \       0x90   0x9800             LDR      R0,[SP, #+0]
   \       0x92   0xF3C0 0x4807      UBFX     R8,R0,#+16,#+8
   1127            key_update_mode = ((keyspec_out & KEYSPEC_MODE_MASK) >> KEYSPEC_MODE_OFFSET);
   \       0x96   0x9800             LDR      R0,[SP, #+0]
   \       0x98   0xF3C0 0x6981      UBFX     R9,R0,#+26,#+2
   1128            keyspec_out = (keyspec_out & ~KEYSPEC_TRANSFER_INDEX_MASK)
   1129                          | ((key_update_index << KEYSPEC_TRANSFER_INDEX_OFFSET)
   1130                             & KEYSPEC_TRANSFER_INDEX_MASK);
   \       0x9C   0x9800             LDR      R0,[SP, #+0]
   \       0x9E   0xF368 0x0007      BFI      R0,R8,#+0,#+8
   \       0xA2   0x9000             STR      R0,[SP, #+0]
   1131            keyspec_out = (keyspec_out & ~KEYSPEC_TRANSFER_MODE_MASK)
   1132                          | ((key_update_mode << KEYSPEC_TRANSFER_MODE_OFFSET)
   1133                             & KEYSPEC_TRANSFER_MODE_MASK);
   \       0xA4   0x9800             LDR      R0,[SP, #+0]
   \       0xA6   0xF369 0x2009      BFI      R0,R9,#+8,#+2
   \       0xAA   0x9000             STR      R0,[SP, #+0]
   1134            keyspec_out = (keyspec_out & ~KEYSPEC_TRANSFER_PROT_BIT_MASK);
   \       0xAC   0x9800             LDR      R0,[SP, #+0]
   \       0xAE   0x02C0             LSLS     R0,R0,#+11
   \       0xB0   0x0AC0             LSRS     R0,R0,#+11
   \       0xB2   0x9000             STR      R0,[SP, #+0]
   1135            SE_addParameter(se_cmd, keyspec_out);
   \       0xB4   0x9900             LDR      R1,[SP, #+0]
   \       0xB6   0x4650             MOV      R0,R10
   \       0xB8   0x.... 0x....      BL       SE_addParameter
   1136          
   1137            // Add key input metadata block to command
   1138            sli_add_key_metadata(cmd_ctx, key_in, status);
   \       0xBC   0xA908             ADD      R1,SP,#+32
   \       0xBE   0x0028             MOVS     R0,R5
   \       0xC0   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xC4   0x4683             MOV      R11,R0
   \       0xC6   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xCA   0xD001             BEQ.N    ??sl_se_transfer_key_8
   \       0xCC   0x4658             MOV      R0,R11
   \       0xCE   0xE02E             B.N      ??sl_se_transfer_key_2
   \                     ??sl_se_transfer_key_8: (+1)
   \       0xD0   0xA908             ADD      R1,SP,#+32
   \       0xD2   0x0020             MOVS     R0,R4
   \       0xD4   0x.... 0x....      BL       SE_addDataInput
   1139            // Add key input block to command
   1140            sli_add_key_input(cmd_ctx, key_in, status);
   \       0xD8   0xA905             ADD      R1,SP,#+20
   \       0xDA   0x0028             MOVS     R0,R5
   \       0xDC   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xE0   0x0007             MOVS     R7,R0
   \       0xE2   0x2F00             CMP      R7,#+0
   \       0xE4   0xD001             BEQ.N    ??sl_se_transfer_key_9
   \       0xE6   0x0038             MOVS     R0,R7
   \       0xE8   0xE021             B.N      ??sl_se_transfer_key_2
   \                     ??sl_se_transfer_key_9: (+1)
   \       0xEA   0xA905             ADD      R1,SP,#+20
   \       0xEC   0x0020             MOVS     R0,R4
   \       0xEE   0x.... 0x....      BL       SE_addDataInput
   1141          
   1142            // Add key output metadata block to command
   1143            status = sli_se_get_auth_buffer(key_out, &auth_buffer_out);
   \       0xF2   0xA90B             ADD      R1,SP,#+44
   \       0xF4   0x0030             MOVS     R0,R6
   \       0xF6   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xFA   0x4683             MOV      R11,R0
   1144            if (status != SL_STATUS_OK) {
   \       0xFC   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x100   0xD001             BEQ.N    ??sl_se_transfer_key_10
   1145              return status;
   \      0x102   0x4658             MOV      R0,R11
   \      0x104   0xE013             B.N      ??sl_se_transfer_key_2
   1146            }
   1147            SE_addDataInput(se_cmd, &auth_buffer_out);
   \                     ??sl_se_transfer_key_10: (+1)
   \      0x106   0xA90B             ADD      R1,SP,#+44
   \      0x108   0x4650             MOV      R0,R10
   \      0x10A   0x.... 0x....      BL       SE_addDataInput
   1148          
   1149            // Add key output block to command
   1150            sli_add_key_output(cmd_ctx, key_out, status);
   \      0x10E   0xA902             ADD      R1,SP,#+8
   \      0x110   0x0030             MOVS     R0,R6
   \      0x112   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x116   0x0007             MOVS     R7,R0
   \      0x118   0x2F00             CMP      R7,#+0
   \      0x11A   0xD001             BEQ.N    ??sl_se_transfer_key_11
   \      0x11C   0x0038             MOVS     R0,R7
   \      0x11E   0xE006             B.N      ??sl_se_transfer_key_2
   \                     ??sl_se_transfer_key_11: (+1)
   \      0x120   0xA902             ADD      R1,SP,#+8
   \      0x122   0x0020             MOVS     R0,R4
   \      0x124   0x.... 0x....      BL       SE_addDataOutput
   1151          
   1152            status = sli_se_execute_and_wait(cmd_ctx);
   \      0x128   0x0020             MOVS     R0,R4
   \      0x12A   0x.... 0x....      BL       sli_se_execute_and_wait
   1153          
   1154            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1155            // Clear padding bytes for plaintext keys upon success
   1156            if (status == SL_STATUS_OK) {
   1157              status = clear_padding(key_out);
   1158            }
   1159            #endif
   1160          
   1161            return status;
   \                     ??sl_se_transfer_key_2: (+1)
   \      0x12E   0xB00F             ADD      SP,SP,#+60
   \      0x130   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1162          }
   1163          
   1164          /***************************************************************************//**
   1165           * Delete a key a volatile SE storage slot
   1166           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1167          sl_status_t sl_se_delete_key(sl_se_command_context_t *cmd_ctx,
   1168                                       const sl_se_key_descriptor_t *key)
   1169          {
   \                     sl_se_delete_key: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1170            sl_status_t status;
   1171          
   1172            if (cmd_ctx == NULL || key == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??sl_se_delete_key_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??sl_se_delete_key_1
   1173              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_delete_key_0: (+1)
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE024             B.N      ??sl_se_delete_key_2
   1174            }
   1175          
   1176            // Initialize command
   1177            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DELETE_KEY);
   \                     ??sl_se_delete_key_1: (+1)
   \       0x14   0x....             LDR.N    R0,??DataTable3_4
   \       0x16   0x6020             STR      R0,[R4, #+0]
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6060             STR      R0,[R4, #+4]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x60A0             STR      R0,[R4, #+8]
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x61E0             STR      R0,[R4, #+28]
   1178          
   1179            // Add key parameters to command
   1180            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x2C   0x0007             MOVS     R7,R0
   \       0x2E   0x2F00             CMP      R7,#+0
   \       0x30   0xD001             BEQ.N    ??sl_se_delete_key_3
   \       0x32   0x0038             MOVS     R0,R7
   \       0x34   0xE013             B.N      ??sl_se_delete_key_2
   \                     ??sl_se_delete_key_3: (+1)
   \       0x36   0x9900             LDR      R1,[SP, #+0]
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       SE_addParameter
   1181            // Add key metadata block to command
   1182            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x3E   0xA901             ADD      R1,SP,#+4
   \       0x40   0x0028             MOVS     R0,R5
   \       0x42   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x46   0x0006             MOVS     R6,R0
   \       0x48   0x2E00             CMP      R6,#+0
   \       0x4A   0xD001             BEQ.N    ??sl_se_delete_key_4
   \       0x4C   0x0030             MOVS     R0,R6
   \       0x4E   0xE006             B.N      ??sl_se_delete_key_2
   \                     ??sl_se_delete_key_4: (+1)
   \       0x50   0xA901             ADD      R1,SP,#+4
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       SE_addDataInput
   1183          
   1184            // Execute command
   1185            status = sli_se_execute_and_wait(cmd_ctx);
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x.... 0x....      BL       sli_se_execute_and_wait
   1186            return status;
   \                     ??sl_se_delete_key_2: (+1)
   \       0x5E   0xB005             ADD      SP,SP,#+20
   \       0x60   0xBDF0             POP      {R4-R7,PC}
   1187          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x2000'0008        DC32     0x20000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     default_auth_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x0201'0000        DC32     0x2010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x0105'0000        DC32     0x1050000
   1188          #endif
   1189          
   1190          /** @} (end addtogroup sl_se_key) */
   1191          
   1192          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   sl_se_delete_key
        40   -> SE_addDataInput
        40   -> SE_addParameter
        40   -> sli_se_execute_and_wait
        40   -> sli_se_get_auth_buffer
        40   -> sli_se_key_to_keyspec
      64   sl_se_export_key
        64   -> SE_addDataInput
        64   -> SE_addDataOutput
        64   -> SE_addParameter
        64   -> sli_key_check_equivalent
        64   -> sli_se_execute_and_wait
        64   -> sli_se_get_auth_buffer
        64   -> sli_se_get_key_input_output
        64   -> sli_se_key_to_keyspec
      72   sl_se_export_public_key
        72   -> SE_addDataInput
        72   -> SE_addDataOutput
        72   -> SE_addParameter
        72   -> sli_key_check_equivalent
        72   -> sli_key_get_storage_size
        72   -> sli_se_execute_and_wait
        72   -> sli_se_get_auth_buffer
        72   -> sli_se_get_key_input_output
        72   -> sli_se_key_to_keyspec
     128   sl_se_generate_key
       128   -> SE_addDataInput
       128   -> SE_addDataOutput
       128   -> SE_addParameter
       128   -> sli_se_execute_and_wait
       128   -> sli_se_get_auth_buffer
       128   -> sli_se_get_key_input_output
       128   -> sli_se_key_to_keyspec
      16   sl_se_get_storage_size
        16   -> sli_key_get_storage_size
      64   sl_se_import_key
        64   -> SE_addDataInput
        64   -> SE_addDataOutput
        64   -> SE_addParameter
        64   -> sli_key_check_equivalent
        64   -> sli_se_execute_and_wait
        64   -> sli_se_get_auth_buffer
        64   -> sli_se_get_key_input_output
        64   -> sli_se_key_to_keyspec
      96   sl_se_transfer_key
        96   -> SE_addDataInput
        96   -> SE_addDataOutput
        96   -> SE_addParameter
        96   -> sli_key_check_equivalent
        96   -> sli_se_execute_and_wait
        96   -> sli_se_get_auth_buffer
        96   -> sli_se_get_key_input_output
        96   -> sli_se_key_to_keyspec
      48   sl_se_validate_key
        48   -> sli_se_get_auth_buffer
        48   -> sli_se_get_key_input_output
        48   -> sli_se_key_to_keyspec
      40   sli_key_check_equivalent
        40   -> sli_key_get_size
       4   sli_key_get_size
      32   sli_key_get_storage_size
        32   -> sli_key_get_size
       0   sli_se_get_auth_buffer
      16   sli_se_get_key_input_output
        16   -> sli_key_get_storage_size
      40   sli_se_key_to_keyspec
        40   -> sli_key_get_size
      16   sli_se_keyspec_to_key


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
      12  ?_0
       8  default_auth_data
      98  sl_se_delete_key
     210  sl_se_export_key
     304  sl_se_export_public_key
     278  sl_se_generate_key
      82  sl_se_get_storage_size
     210  sl_se_import_key
     308  sl_se_transfer_key
      72  sl_se_validate_key
     262  sli_key_check_equivalent
     144  sli_key_get_size
     210  sli_key_get_storage_size
      72  sli_se_get_auth_buffer
     130  sli_se_get_key_input_output
     598  sli_se_key_to_keyspec
     436  sli_se_keyspec_to_key

 
    20 bytes in section .rodata
 3'434 bytes in section .text
 
 3'434 bytes of CODE  memory
    20 bytes of CONST memory

Errors: none
Warnings: none
