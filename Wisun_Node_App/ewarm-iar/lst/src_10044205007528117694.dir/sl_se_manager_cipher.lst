###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:11
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_cipher.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_cipher.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_cipher.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_10044205007528117694.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_cipher.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_10044205007528117694.dir\sl_se_manager_cipher.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_cipher.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_cipher.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs Secure Engine Manager API.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sl_se_manager.h"
     32          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
     33          
     34          #include "sli_se_manager_internal.h"
     35          #include "em_se.h"
     36          #include "sl_assert.h"
     37          #include <string.h>
     38          
     39          /// @addtogroup sl_se_manager
     40          /// @{
     41          

   \                                 In section .text, align 2, keep-with-next
     42          uint32_t memcmp_time_cst(uint8_t *in1, uint8_t *in2, uint32_t size)
     43          {
   \                     memcmp_time_cst: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
     44            //Don't try to optimise this function for performance, it's time constant for security reasons
     45            uint32_t diff = 0;
   \        0x2   0x2300             MOVS     R3,#+0
     46            uint32_t i = 0;
   \        0x4   0x2400             MOVS     R4,#+0
     47            for (i = 0; i < size; i++) {
   \        0x6   0x2500             MOVS     R5,#+0
   \                     ??memcmp_time_cst_0: (+1)
   \        0x8   0x4295             CMP      R5,R2
   \        0xA   0xD205             BCS.N    ??memcmp_time_cst_1
     48              diff |= (*(in1 + i) ^ (*(in2 + i)));
   \        0xC   0x5D46             LDRB     R6,[R0, R5]
   \        0xE   0x5D4C             LDRB     R4,[R1, R5]
   \       0x10   0x4066             EORS     R6,R4,R6
   \       0x12   0x4333             ORRS     R3,R6,R3
     49            }
   \       0x14   0x1C6D             ADDS     R5,R5,#+1
   \       0x16   0xE7F7             B.N      ??memcmp_time_cst_0
     50          
     51            return (diff > 0);
   \                     ??memcmp_time_cst_1: (+1)
   \       0x18   0x2B00             CMP      R3,#+0
   \       0x1A   0xD001             BEQ.N    ??memcmp_time_cst_2
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE000             B.N      ??memcmp_time_cst_3
   \                     ??memcmp_time_cst_2: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \                     ??memcmp_time_cst_3: (+1)
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0xBC70             POP      {R4-R6}
   \       0x26   0x4770             BX       LR
     52          }
     53          
     54          // -----------------------------------------------------------------------------
     55          // Global Functions
     56          
     57          /***************************************************************************//**
     58           * AES-ECB block encryption/decryption.
     59           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     60          sl_status_t sl_se_aes_crypt_ecb(sl_se_command_context_t *cmd_ctx,
     61                                          const sl_se_key_descriptor_t *key,
     62                                          sl_se_cipher_operation_t mode,
     63                                          size_t length,
     64                                          const unsigned char *input,
     65                                          unsigned char *output)
     66          {
   \                     sl_se_aes_crypt_ecb: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08E             SUB      SP,SP,#+56
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x4693             MOV      R11,R2
   \        0xC   0x469A             MOV      R10,R3
   \        0xE   0x9E18             LDR      R6,[SP, #+96]
   \       0x10   0x9F19             LDR      R7,[SP, #+100]
     67            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL
     68                || (length & 0xFU) != 0U) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD008             BEQ.N    ??sl_se_aes_crypt_ecb_0
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD006             BEQ.N    ??sl_se_aes_crypt_ecb_0
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD004             BEQ.N    ??sl_se_aes_crypt_ecb_0
   \       0x1E   0x2F00             CMP      R7,#+0
   \       0x20   0xD002             BEQ.N    ??sl_se_aes_crypt_ecb_0
   \       0x22   0xF01A 0x0F0F      TST      R10,#0xF
   \       0x26   0xD001             BEQ.N    ??sl_se_aes_crypt_ecb_1
     69              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_ecb_0: (+1)
   \       0x28   0x2021             MOVS     R0,#+33
   \       0x2A   0xE063             B.N      ??sl_se_aes_crypt_ecb_2
     70            }
     71          
     72            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_aes_crypt_ecb_1: (+1)
   \       0x2C   0x9400             STR      R4,[SP, #+0]
     73            sl_status_t status;
     74          
     75            sli_se_command_init(cmd_ctx,
     76                                (mode == SL_SE_ENCRYPT
     77                                 ? SLI_SE_COMMAND_AES_ENCRYPT : SLI_SE_COMMAND_AES_DECRYPT)
     78                                | SLI_SE_COMMAND_OPTION_MODE_ECB
     79                                | SLI_SE_COMMAND_OPTION_CONTEXT_WHOLE);
   \       0x2E   0x4658             MOV      R0,R11
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD102             BNE.N    ??sl_se_aes_crypt_ecb_3
   \       0x36   0xF05F 0x6080      MOVS     R0,#+67108864
   \       0x3A   0xE001             B.N      ??sl_se_aes_crypt_ecb_4
   \                     ??sl_se_aes_crypt_ecb_3: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable6
   \                     ??sl_se_aes_crypt_ecb_4: (+1)
   \       0x40   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x44   0x6020             STR      R0,[R4, #+0]
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x6060             STR      R0,[R4, #+4]
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x60A0             STR      R0,[R4, #+8]
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x61E0             STR      R0,[R4, #+28]
     80          
     81            // Add key parameters to command
     82            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x52   0xA901             ADD      R1,SP,#+4
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x5A   0x4680             MOV      R8,R0
   \       0x5C   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x60   0xD001             BEQ.N    ??sl_se_aes_crypt_ecb_5
   \       0x62   0x4640             MOV      R0,R8
   \       0x64   0xE046             B.N      ??sl_se_aes_crypt_ecb_2
   \                     ??sl_se_aes_crypt_ecb_5: (+1)
   \       0x66   0x9901             LDR      R1,[SP, #+4]
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       SE_addParameter
     83            // Message size (number of bytes)
     84            SE_addParameter(se_cmd, length);
   \       0x6E   0x4651             MOV      R1,R10
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   \       0x72   0x.... 0x....      BL       SE_addParameter
     85          
     86            // Add key metadata block to command
     87            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x76   0xA90B             ADD      R1,SP,#+44
   \       0x78   0x0028             MOVS     R0,R5
   \       0x7A   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x7E   0x4681             MOV      R9,R0
   \       0x80   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x84   0xD001             BEQ.N    ??sl_se_aes_crypt_ecb_6
   \       0x86   0x4648             MOV      R0,R9
   \       0x88   0xE034             B.N      ??sl_se_aes_crypt_ecb_2
   \                     ??sl_se_aes_crypt_ecb_6: (+1)
   \       0x8A   0xA90B             ADD      R1,SP,#+44
   \       0x8C   0x0020             MOVS     R0,R4
   \       0x8E   0x.... 0x....      BL       SE_addDataInput
     88            // Add key input block to command
     89            sli_add_key_input(cmd_ctx, key, status);
   \       0x92   0xA908             ADD      R1,SP,#+32
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x9A   0x4680             MOV      R8,R0
   \       0x9C   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xA0   0xD001             BEQ.N    ??sl_se_aes_crypt_ecb_7
   \       0xA2   0x4640             MOV      R0,R8
   \       0xA4   0xE026             B.N      ??sl_se_aes_crypt_ecb_2
   \                     ??sl_se_aes_crypt_ecb_7: (+1)
   \       0xA6   0xA908             ADD      R1,SP,#+32
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x.... 0x....      BL       SE_addDataInput
     90          
     91            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(input, length);
   \       0xAE   0xF10D 0x0C14      ADD      R12,SP,#+20
   \       0xB2   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0xB6   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xBA   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xBE   0x9605             STR      R6,[SP, #+20]
   \       0xC0   0xF05A 0x5000      ORRS     R0,R10,#0x20000000
   \       0xC4   0x9007             STR      R0,[SP, #+28]
     92            SE_addDataInput(se_cmd, &in);
   \       0xC6   0xA905             ADD      R1,SP,#+20
   \       0xC8   0x9800             LDR      R0,[SP, #+0]
   \       0xCA   0x.... 0x....      BL       SE_addDataInput
     93          
     94            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(output, length);
   \       0xCE   0xF10D 0x0C08      ADD      R12,SP,#+8
   \       0xD2   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0xD6   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xDA   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xDE   0x9702             STR      R7,[SP, #+8]
   \       0xE0   0xF05A 0x5000      ORRS     R0,R10,#0x20000000
   \       0xE4   0x9004             STR      R0,[SP, #+16]
     95            SE_addDataOutput(se_cmd, &out);
   \       0xE6   0xA902             ADD      R1,SP,#+8
   \       0xE8   0x9800             LDR      R0,[SP, #+0]
   \       0xEA   0x.... 0x....      BL       SE_addDataOutput
     96          
     97            return sli_se_execute_and_wait(cmd_ctx);
   \       0xEE   0x0020             MOVS     R0,R4
   \       0xF0   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_aes_crypt_ecb_2: (+1)
   \       0xF4   0xB00F             ADD      SP,SP,#+60
   \       0xF6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
     98          }

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
     99          
    100          /***************************************************************************//**
    101           * AES-CBC buffer encryption/decryption.
    102           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    103          sl_status_t sl_se_aes_crypt_cbc(sl_se_command_context_t *cmd_ctx,
    104                                          const sl_se_key_descriptor_t *key,
    105                                          sl_se_cipher_operation_t mode,
    106                                          size_t length,
    107                                          unsigned char iv[16],
    108                                          const unsigned char *input,
    109                                          unsigned char *output)
    110          {
   \                     sl_se_aes_crypt_cbc: (+1)
   \        0x0   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x469B             MOV      R11,R3
   \        0xC   0x9E1E             LDR      R6,[SP, #+120]
   \        0xE   0x9F1F             LDR      R7,[SP, #+124]
   \       0x10   0xF8DD 0x8080      LDR      R8,[SP, #+128]
    111            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL
    112                || iv == NULL) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD008             BEQ.N    ??sl_se_aes_crypt_cbc_0
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD006             BEQ.N    ??sl_se_aes_crypt_cbc_0
   \       0x1C   0x2F00             CMP      R7,#+0
   \       0x1E   0xD004             BEQ.N    ??sl_se_aes_crypt_cbc_0
   \       0x20   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x24   0xD001             BEQ.N    ??sl_se_aes_crypt_cbc_0
   \       0x26   0x2E00             CMP      R6,#+0
   \       0x28   0xD101             BNE.N    ??sl_se_aes_crypt_cbc_1
    113              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_cbc_0: (+1)
   \       0x2A   0x2021             MOVS     R0,#+33
   \       0x2C   0xE083             B.N      ??sl_se_aes_crypt_cbc_2
    114            }
    115          
    116            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_aes_crypt_cbc_1: (+1)
   \       0x2E   0x9400             STR      R4,[SP, #+0]
    117            sl_status_t status;
    118          
    119            // Input length must be a multiple of 16 bytes which is the AES block length
    120            if (length & 0xf) {
   \       0x30   0xF01B 0x0F0F      TST      R11,#0xF
   \       0x34   0xD001             BEQ.N    ??sl_se_aes_crypt_cbc_3
    121              return SL_STATUS_INVALID_PARAMETER;
   \       0x36   0x2021             MOVS     R0,#+33
   \       0x38   0xE07D             B.N      ??sl_se_aes_crypt_cbc_2
    122            }
    123          
    124            sli_se_command_init(cmd_ctx,
    125                                (mode == SL_SE_ENCRYPT
    126                                 ? SLI_SE_COMMAND_AES_ENCRYPT : SLI_SE_COMMAND_AES_DECRYPT)
    127                                | SLI_SE_COMMAND_OPTION_MODE_CBC
    128                                | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \                     ??sl_se_aes_crypt_cbc_3: (+1)
   \       0x3A   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD102             BNE.N    ??sl_se_aes_crypt_cbc_4
   \       0x42   0xF05F 0x6180      MOVS     R1,#+67108864
   \       0x46   0xE001             B.N      ??sl_se_aes_crypt_cbc_5
   \                     ??sl_se_aes_crypt_cbc_4: (+1)
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable6
   \                     ??sl_se_aes_crypt_cbc_5: (+1)
   \       0x4C   0xF240 0x2003      MOVW     R0,#+515
   \       0x50   0x4301             ORRS     R1,R0,R1
   \       0x52   0x6021             STR      R1,[R4, #+0]
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x6060             STR      R0,[R4, #+4]
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x60A0             STR      R0,[R4, #+8]
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x61E0             STR      R0,[R4, #+28]
    129          
    130            // Add key parameters to command
    131            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x60   0xA901             ADD      R1,SP,#+4
   \       0x62   0x0028             MOVS     R0,R5
   \       0x64   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x68   0x4681             MOV      R9,R0
   \       0x6A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x6E   0xD001             BEQ.N    ??sl_se_aes_crypt_cbc_6
   \       0x70   0x4648             MOV      R0,R9
   \       0x72   0xE060             B.N      ??sl_se_aes_crypt_cbc_2
   \                     ??sl_se_aes_crypt_cbc_6: (+1)
   \       0x74   0x9901             LDR      R1,[SP, #+4]
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0x.... 0x....      BL       SE_addParameter
    132            // Message size (number of bytes)
    133            SE_addParameter(se_cmd, length);
   \       0x7C   0x4659             MOV      R1,R11
   \       0x7E   0x9800             LDR      R0,[SP, #+0]
   \       0x80   0x.... 0x....      BL       SE_addParameter
    134          
    135            // Add key metadata block to command
    136            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x84   0xA911             ADD      R1,SP,#+68
   \       0x86   0x0028             MOVS     R0,R5
   \       0x88   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x8C   0x4682             MOV      R10,R0
   \       0x8E   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x92   0xD001             BEQ.N    ??sl_se_aes_crypt_cbc_7
   \       0x94   0x4650             MOV      R0,R10
   \       0x96   0xE04E             B.N      ??sl_se_aes_crypt_cbc_2
   \                     ??sl_se_aes_crypt_cbc_7: (+1)
   \       0x98   0xA911             ADD      R1,SP,#+68
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0x.... 0x....      BL       SE_addDataInput
    137            // Add key input block to command
    138            sli_add_key_input(cmd_ctx, key, status);
   \       0xA0   0xA90E             ADD      R1,SP,#+56
   \       0xA2   0x0028             MOVS     R0,R5
   \       0xA4   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xA8   0x4681             MOV      R9,R0
   \       0xAA   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xAE   0xD001             BEQ.N    ??sl_se_aes_crypt_cbc_8
   \       0xB0   0x4648             MOV      R0,R9
   \       0xB2   0xE040             B.N      ??sl_se_aes_crypt_cbc_2
   \                     ??sl_se_aes_crypt_cbc_8: (+1)
   \       0xB4   0xA90E             ADD      R1,SP,#+56
   \       0xB6   0x0020             MOVS     R0,R4
   \       0xB8   0x.... 0x....      BL       SE_addDataInput
    139          
    140            SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, 16);
   \       0xBC   0xF10D 0x0C2C      ADD      R12,SP,#+44
   \       0xC0   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0xC4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xC8   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xCC   0x960B             STR      R6,[SP, #+44]
    141            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(input, length);
   \       0xCE   0xAB05             ADD      R3,SP,#+20
   \       0xD0   0x.... 0x....      LDR.W    R12,??DataTable6_4
   \       0xD4   0xE89C 0x0007      LDM      R12,{R0-R2}
   \       0xD8   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xDC   0x9705             STR      R7,[SP, #+20]
   \       0xDE   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \       0xE2   0x9007             STR      R0,[SP, #+28]
    142            SE_addDataInput(se_cmd, &iv_in);
   \       0xE4   0xA90B             ADD      R1,SP,#+44
   \       0xE6   0x9800             LDR      R0,[SP, #+0]
   \       0xE8   0x.... 0x....      BL       SE_addDataInput
    143            SE_addDataInput(se_cmd, &in);
   \       0xEC   0xA905             ADD      R1,SP,#+20
   \       0xEE   0x9800             LDR      R0,[SP, #+0]
   \       0xF0   0x.... 0x....      BL       SE_addDataInput
    144          
    145            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(output, length);
   \       0xF4   0xF10D 0x0C08      ADD      R12,SP,#+8
   \       0xF8   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0xFC   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x100   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x104   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \      0x108   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \      0x10C   0x9004             STR      R0,[SP, #+16]
    146            SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(iv, 16);
   \      0x10E   0xF10D 0x0C20      ADD      R12,SP,#+32
   \      0x112   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x116   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x11A   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x11E   0x9608             STR      R6,[SP, #+32]
    147            SE_addDataOutput(se_cmd, &out);
   \      0x120   0xA902             ADD      R1,SP,#+8
   \      0x122   0x9800             LDR      R0,[SP, #+0]
   \      0x124   0x.... 0x....      BL       SE_addDataOutput
    148            SE_addDataOutput(se_cmd, &iv_out);
   \      0x128   0xA908             ADD      R1,SP,#+32
   \      0x12A   0x9800             LDR      R0,[SP, #+0]
   \      0x12C   0x.... 0x....      BL       SE_addDataOutput
    149          
    150            return sli_se_execute_and_wait(cmd_ctx);
   \      0x130   0x0020             MOVS     R0,R4
   \      0x132   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_aes_crypt_cbc_2: (+1)
   \      0x136   0xB015             ADD      SP,SP,#+84
   \      0x138   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    151          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
    152          
    153          /***************************************************************************//**
    154           * AES-CFB128 buffer encryption/decryption.
    155           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    156          sl_status_t sl_se_aes_crypt_cfb128(sl_se_command_context_t *cmd_ctx,
    157                                             const sl_se_key_descriptor_t *key,
    158                                             sl_se_cipher_operation_t mode,
    159                                             size_t length,
    160                                             uint32_t *iv_off,
    161                                             unsigned char iv[16],
    162                                             const unsigned char *input,
    163                                             unsigned char *output)
    164          {
   \                     sl_se_aes_crypt_cfb128: (+1)
   \        0x0   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x9F23             LDR      R7,[SP, #+140]
   \        0xA   0xF8DD 0x8090      LDR      R8,[SP, #+144]
   \        0xE   0xF8DD 0x9094      LDR      R9,[SP, #+148]
    165            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL
    166                || iv == NULL) {
   \       0x12   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x16   0xD00A             BEQ.N    ??sl_se_aes_crypt_cfb128_0
   \       0x18   0x9816             LDR      R0,[SP, #+88]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD007             BEQ.N    ??sl_se_aes_crypt_cfb128_0
   \       0x1E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x22   0xD004             BEQ.N    ??sl_se_aes_crypt_cfb128_0
   \       0x24   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x28   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb128_0
   \       0x2A   0x2F00             CMP      R7,#+0
   \       0x2C   0xD101             BNE.N    ??sl_se_aes_crypt_cfb128_1
    167              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_cfb128_0: (+1)
   \       0x2E   0x2021             MOVS     R0,#+33
   \       0x30   0xE0F3             B.N      ??sl_se_aes_crypt_cfb128_2
    168            }
    169          
    170            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_aes_crypt_cfb128_1: (+1)
   \       0x32   0xF8CD 0xB008      STR      R11,[SP, #+8]
    171            uint32_t n = iv_off ? *iv_off : 0;
   \       0x36   0x9822             LDR      R0,[SP, #+136]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD002             BEQ.N    ??sl_se_aes_crypt_cfb128_3
   \       0x3C   0x9822             LDR      R0,[SP, #+136]
   \       0x3E   0x6804             LDR      R4,[R0, #+0]
   \       0x40   0xE000             B.N      ??sl_se_aes_crypt_cfb128_4
   \                     ??sl_se_aes_crypt_cfb128_3: (+1)
   \       0x42   0x2400             MOVS     R4,#+0
    172            uint32_t processed = 0;
   \                     ??sl_se_aes_crypt_cfb128_4: (+1)
   \       0x44   0xF05F 0x0A00      MOVS     R10,#+0
    173            sl_status_t command_status = SL_STATUS_OK;
   \       0x48   0x2500             MOVS     R5,#+0
    174          
    175            while (processed < length) {
   \                     ??sl_se_aes_crypt_cfb128_5: (+1)
   \       0x4A   0x9818             LDR      R0,[SP, #+96]
   \       0x4C   0x4582             CMP      R10,R0
   \       0x4E   0xF080 0x80DE      BCS.W    ??sl_se_aes_crypt_cfb128_6
    176              if (n > 0) {
   \       0x52   0x2C00             CMP      R4,#+0
   \       0x54   0xD01A             BEQ.N    ??sl_se_aes_crypt_cfb128_7
    177                // start by filling up the IV
    178                if (mode == SL_SE_ENCRYPT) {
   \       0x56   0xF89D 0x005C      LDRB     R0,[SP, #+92]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD109             BNE.N    ??sl_se_aes_crypt_cfb128_8
    179                  iv[n] = output[processed] = (unsigned char)(iv[n] ^ input[processed]);
   \       0x5E   0x5D39             LDRB     R1,[R7, R4]
   \       0x60   0xF818 0x000A      LDRB     R0,[R8, R10]
   \       0x64   0x4041             EORS     R1,R0,R1
   \       0x66   0xF809 0x100A      STRB     R1,[R9, R10]
   \       0x6A   0xF819 0x000A      LDRB     R0,[R9, R10]
   \       0x6E   0x5538             STRB     R0,[R7, R4]
   \       0x70   0xE006             B.N      ??sl_se_aes_crypt_cfb128_9
    180                } else {
    181                  int c = input[processed];
   \                     ??sl_se_aes_crypt_cfb128_8: (+1)
   \       0x72   0xF818 0x100A      LDRB     R1,[R8, R10]
    182                  output[processed] = (unsigned char)(c ^ iv[n]);
   \       0x76   0x5D38             LDRB     R0,[R7, R4]
   \       0x78   0x4048             EORS     R0,R0,R1
   \       0x7A   0xF809 0x000A      STRB     R0,[R9, R10]
    183                  iv[n] = (unsigned char) c;
   \       0x7E   0x5539             STRB     R1,[R7, R4]
    184                }
    185                n = (n + 1) & 0x0F;
   \                     ??sl_se_aes_crypt_cfb128_9: (+1)
   \       0x80   0x1C64             ADDS     R4,R4,#+1
   \       0x82   0xF014 0x040F      ANDS     R4,R4,#0xF
    186                processed++;
   \       0x86   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \       0x8A   0xE7DE             B.N      ??sl_se_aes_crypt_cfb128_5
    187              } else {
    188                // process one ore more blocks of data
    189                uint32_t iterations = (length - processed) / 16;
   \                     ??sl_se_aes_crypt_cfb128_7: (+1)
   \       0x8C   0x9E18             LDR      R6,[SP, #+96]
   \       0x8E   0xEBB6 0x060A      SUBS     R6,R6,R10
   \       0x92   0x0936             LSRS     R6,R6,#+4
    190          
    191                if (iterations > 0) {
   \       0x94   0x2E00             CMP      R6,#+0
   \       0x96   0xF000 0x808A      BEQ.W    ??sl_se_aes_crypt_cfb128_10
    192                  sli_se_command_init(cmd_ctx,
    193                                      (mode == SL_SE_ENCRYPT
    194                                       ? SLI_SE_COMMAND_AES_ENCRYPT : SLI_SE_COMMAND_AES_DECRYPT)
    195                                      | SLI_SE_COMMAND_OPTION_MODE_CFB
    196                                      | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \       0x9A   0xF89D 0x005C      LDRB     R0,[SP, #+92]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD102             BNE.N    ??sl_se_aes_crypt_cfb128_11
   \       0xA2   0xF05F 0x6180      MOVS     R1,#+67108864
   \       0xA6   0xE001             B.N      ??sl_se_aes_crypt_cfb128_12
   \                     ??sl_se_aes_crypt_cfb128_11: (+1)
   \       0xA8   0x.... 0x....      LDR.W    R1,??DataTable6
   \                     ??sl_se_aes_crypt_cfb128_12: (+1)
   \       0xAC   0xF240 0x4003      MOVW     R0,#+1027
   \       0xB0   0x4301             ORRS     R1,R0,R1
   \       0xB2   0xF8CB 0x1000      STR      R1,[R11, #+0]
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0xF8CB 0x001C      STR      R0,[R11, #+28]
    197          
    198                  // Add key parameters to command
    199                  sli_add_key_parameters(cmd_ctx, key, command_status);
   \       0xC8   0xA901             ADD      R1,SP,#+4
   \       0xCA   0x9816             LDR      R0,[SP, #+88]
   \       0xCC   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xD0   0x9000             STR      R0,[SP, #+0]
   \       0xD2   0x9800             LDR      R0,[SP, #+0]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb128_13
   \       0xD8   0x9800             LDR      R0,[SP, #+0]
   \       0xDA   0xE09E             B.N      ??sl_se_aes_crypt_cfb128_2
   \                     ??sl_se_aes_crypt_cfb128_13: (+1)
   \       0xDC   0x9901             LDR      R1,[SP, #+4]
   \       0xDE   0x4658             MOV      R0,R11
   \       0xE0   0x.... 0x....      BL       SE_addParameter
    200                  // Message size (number of bytes)
    201                  SE_addParameter(se_cmd, iterations * 16);
   \       0xE4   0x0131             LSLS     R1,R6,#+4
   \       0xE6   0x9802             LDR      R0,[SP, #+8]
   \       0xE8   0x.... 0x....      BL       SE_addParameter
    202          
    203                  // Add key metadata block to command
    204                  sli_add_key_metadata(cmd_ctx, key, command_status);
   \       0xEC   0xA912             ADD      R1,SP,#+72
   \       0xEE   0x9816             LDR      R0,[SP, #+88]
   \       0xF0   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xF4   0x0005             MOVS     R5,R0
   \       0xF6   0x2D00             CMP      R5,#+0
   \       0xF8   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb128_14
   \       0xFA   0x0028             MOVS     R0,R5
   \       0xFC   0xE08D             B.N      ??sl_se_aes_crypt_cfb128_2
   \                     ??sl_se_aes_crypt_cfb128_14: (+1)
   \       0xFE   0xA912             ADD      R1,SP,#+72
   \      0x100   0x4658             MOV      R0,R11
   \      0x102   0x.... 0x....      BL       SE_addDataInput
    205                  // Add key input block to command
    206                  sli_add_key_input(cmd_ctx, key, command_status);
   \      0x106   0xA90F             ADD      R1,SP,#+60
   \      0x108   0x9816             LDR      R0,[SP, #+88]
   \      0x10A   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x10E   0x9000             STR      R0,[SP, #+0]
   \      0x110   0x9800             LDR      R0,[SP, #+0]
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb128_15
   \      0x116   0x9800             LDR      R0,[SP, #+0]
   \      0x118   0xE07F             B.N      ??sl_se_aes_crypt_cfb128_2
   \                     ??sl_se_aes_crypt_cfb128_15: (+1)
   \      0x11A   0xA90F             ADD      R1,SP,#+60
   \      0x11C   0x4658             MOV      R0,R11
   \      0x11E   0x.... 0x....      BL       SE_addDataInput
    207          
    208                  SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, 16);
   \      0x122   0xAB0C             ADD      R3,SP,#+48
   \      0x124   0x.... 0x....      LDR.W    R5,??DataTable7_1
   \      0x128   0xE895 0x0007      LDM      R5,{R0-R2}
   \      0x12C   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x130   0x970C             STR      R7,[SP, #+48]
    209                  SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(&input[processed], iterations * 16);
   \      0x132   0xAB06             ADD      R3,SP,#+24
   \      0x134   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \      0x138   0xE890 0x0026      LDM      R0,{R1,R2,R5}
   \      0x13C   0xE883 0x0026      STM      R3,{R1,R2,R5}
   \      0x140   0xEB08 0x000A      ADD      R0,R8,R10
   \      0x144   0x9006             STR      R0,[SP, #+24]
   \      0x146   0x0130             LSLS     R0,R6,#+4
   \      0x148   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x14C   0x9008             STR      R0,[SP, #+32]
    210                  SE_addDataInput(se_cmd, &iv_in);
   \      0x14E   0xA90C             ADD      R1,SP,#+48
   \      0x150   0x9802             LDR      R0,[SP, #+8]
   \      0x152   0x.... 0x....      BL       SE_addDataInput
    211                  SE_addDataInput(se_cmd, &in);
   \      0x156   0xA906             ADD      R1,SP,#+24
   \      0x158   0x9802             LDR      R0,[SP, #+8]
   \      0x15A   0x.... 0x....      BL       SE_addDataInput
    212          
    213                  SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(&output[processed], iterations * 16);
   \      0x15E   0xAB03             ADD      R3,SP,#+12
   \      0x160   0x.... 0x....      LDR.W    R5,??DataTable7_3
   \      0x164   0xE895 0x0007      LDM      R5,{R0-R2}
   \      0x168   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x16C   0xEB09 0x000A      ADD      R0,R9,R10
   \      0x170   0x9003             STR      R0,[SP, #+12]
   \      0x172   0x0130             LSLS     R0,R6,#+4
   \      0x174   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x178   0x9005             STR      R0,[SP, #+20]
    214                  SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(iv, 16);
   \      0x17A   0xAD09             ADD      R5,SP,#+36
   \      0x17C   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \      0x180   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x184   0xE885 0x000E      STM      R5,{R1-R3}
   \      0x188   0x9709             STR      R7,[SP, #+36]
    215                  SE_addDataOutput(se_cmd, &out);
   \      0x18A   0xA903             ADD      R1,SP,#+12
   \      0x18C   0x9802             LDR      R0,[SP, #+8]
   \      0x18E   0x.... 0x....      BL       SE_addDataOutput
    216                  SE_addDataOutput(se_cmd, &iv_out);
   \      0x192   0xA909             ADD      R1,SP,#+36
   \      0x194   0x9802             LDR      R0,[SP, #+8]
   \      0x196   0x.... 0x....      BL       SE_addDataOutput
    217          
    218                  command_status = sli_se_execute_and_wait(cmd_ctx);
   \      0x19A   0x4658             MOV      R0,R11
   \      0x19C   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x1A0   0x0005             MOVS     R5,R0
    219                  processed += iterations * 16;
   \      0x1A2   0xEB1A 0x1A06      ADDS     R10,R10,R6, LSL #+4
    220                  if (command_status != SL_STATUS_OK) {
   \      0x1A6   0x2D00             CMP      R5,#+0
   \      0x1A8   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb128_10
    221                    return command_status;
   \      0x1AA   0x0028             MOVS     R0,R5
   \      0x1AC   0xE035             B.N      ??sl_se_aes_crypt_cfb128_2
    222                  }
    223                }
    224          
    225                while ((length - processed) > 0) {
   \                     ??sl_se_aes_crypt_cfb128_10: (+1)
   \      0x1AE   0x9818             LDR      R0,[SP, #+96]
   \      0x1B0   0xEBB0 0x000A      SUBS     R0,R0,R10
   \      0x1B4   0x2800             CMP      R0,#+0
   \      0x1B6   0xF43F 0xAF48      BEQ.W    ??sl_se_aes_crypt_cfb128_5
    226                  if (n == 0) {
   \      0x1BA   0x2C00             CMP      R4,#+0
   \      0x1BC   0xD10C             BNE.N    ??sl_se_aes_crypt_cfb128_16
    227                    // Need to update the IV but don't have a full block of input to pass
    228                    // to the SE.
    229                    command_status = sl_se_aes_crypt_ecb(cmd_ctx, key, SL_SE_ENCRYPT, 16U, iv, iv);
   \      0x1BE   0x9701             STR      R7,[SP, #+4]
   \      0x1C0   0x9700             STR      R7,[SP, #+0]
   \      0x1C2   0x2310             MOVS     R3,#+16
   \      0x1C4   0x2200             MOVS     R2,#+0
   \      0x1C6   0x9916             LDR      R1,[SP, #+88]
   \      0x1C8   0x4658             MOV      R0,R11
   \      0x1CA   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \      0x1CE   0x0005             MOVS     R5,R0
    230                    if (command_status != SL_STATUS_OK) {
   \      0x1D0   0x2D00             CMP      R5,#+0
   \      0x1D2   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb128_16
    231                      return command_status;
   \      0x1D4   0x0028             MOVS     R0,R5
   \      0x1D6   0xE020             B.N      ??sl_se_aes_crypt_cfb128_2
    232                    }
    233                  }
    234                  // Save remainder to IV
    235                  if (mode == SL_SE_ENCRYPT) {
   \                     ??sl_se_aes_crypt_cfb128_16: (+1)
   \      0x1D8   0xF89D 0x005C      LDRB     R0,[SP, #+92]
   \      0x1DC   0x2800             CMP      R0,#+0
   \      0x1DE   0xD109             BNE.N    ??sl_se_aes_crypt_cfb128_17
    236                    iv[n] = output[processed] = (unsigned char)(iv[n] ^ input[processed]);
   \      0x1E0   0x5D39             LDRB     R1,[R7, R4]
   \      0x1E2   0xF818 0x000A      LDRB     R0,[R8, R10]
   \      0x1E6   0x4041             EORS     R1,R0,R1
   \      0x1E8   0xF809 0x100A      STRB     R1,[R9, R10]
   \      0x1EC   0xF819 0x000A      LDRB     R0,[R9, R10]
   \      0x1F0   0x5538             STRB     R0,[R7, R4]
   \      0x1F2   0xE006             B.N      ??sl_se_aes_crypt_cfb128_18
    237                  } else {
    238                    int c = input[processed];
   \                     ??sl_se_aes_crypt_cfb128_17: (+1)
   \      0x1F4   0xF818 0x100A      LDRB     R1,[R8, R10]
    239                    output[processed] = (unsigned char)(c ^ iv[n]);
   \      0x1F8   0x5D38             LDRB     R0,[R7, R4]
   \      0x1FA   0x4048             EORS     R0,R0,R1
   \      0x1FC   0xF809 0x000A      STRB     R0,[R9, R10]
    240                    iv[n] = (unsigned char) c;
   \      0x200   0x5539             STRB     R1,[R7, R4]
    241                  }
    242                  n = (n + 1) & 0x0F;
   \                     ??sl_se_aes_crypt_cfb128_18: (+1)
   \      0x202   0x1C64             ADDS     R4,R4,#+1
   \      0x204   0xF014 0x040F      ANDS     R4,R4,#0xF
    243                  processed++;
   \      0x208   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x20C   0xE7CF             B.N      ??sl_se_aes_crypt_cfb128_10
    244                }
    245              }
    246            }
    247          
    248            if ( iv_off ) {
   \                     ??sl_se_aes_crypt_cfb128_6: (+1)
   \      0x20E   0x9822             LDR      R0,[SP, #+136]
   \      0x210   0x2800             CMP      R0,#+0
   \      0x212   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb128_19
    249              *iv_off = n;
   \      0x214   0x9822             LDR      R0,[SP, #+136]
   \      0x216   0x6004             STR      R4,[R0, #+0]
    250            }
    251          
    252            return command_status;
   \                     ??sl_se_aes_crypt_cfb128_19: (+1)
   \      0x218   0x0028             MOVS     R0,R5
   \                     ??sl_se_aes_crypt_cfb128_2: (+1)
   \      0x21A   0xB019             ADD      SP,SP,#+100
   \      0x21C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    253          }

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
    254          
    255          /***************************************************************************//**
    256           * AES-CFB8 buffer encryption/decryption.
    257           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    258          sl_status_t sl_se_aes_crypt_cfb8(sl_se_command_context_t *cmd_ctx,
    259                                           const sl_se_key_descriptor_t *key,
    260                                           sl_se_cipher_operation_t mode,
    261                                           size_t length,
    262                                           unsigned char iv[16],
    263                                           const unsigned char *input,
    264                                           unsigned char *output)
    265          {
   \                     sl_se_aes_crypt_cfb8: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4698             MOV      R8,R3
   \        0x8   0x9C14             LDR      R4,[SP, #+80]
   \        0xA   0x9D15             LDR      R5,[SP, #+84]
   \        0xC   0x9E16             LDR      R6,[SP, #+88]
    266            unsigned char c;
    267            unsigned char ov[17];
    268            sl_status_t ret = SL_STATUS_OK;
   \        0xE   0x2700             MOVS     R7,#+0
    269          
    270            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL
    271                || iv == NULL) {
   \       0x10   0x9808             LDR      R0,[SP, #+32]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD008             BEQ.N    ??sl_se_aes_crypt_cfb8_0
   \       0x16   0x9809             LDR      R0,[SP, #+36]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD005             BEQ.N    ??sl_se_aes_crypt_cfb8_0
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD003             BEQ.N    ??sl_se_aes_crypt_cfb8_0
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb8_0
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD101             BNE.N    ??sl_se_aes_crypt_cfb8_1
    272              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_cfb8_0: (+1)
   \       0x28   0x2021             MOVS     R0,#+33
   \       0x2A   0xE03E             B.N      ??sl_se_aes_crypt_cfb8_2
    273            }
    274          
    275            while (length--) {
   \                     ??sl_se_aes_crypt_cfb8_1: (+1)
   \       0x2C   0x4640             MOV      R0,R8
   \       0x2E   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD038             BEQ.N    ??sl_se_aes_crypt_cfb8_3
    276              memcpy(ov, iv, 16U);
   \       0x36   0xF05F 0x0A10      MOVS     R10,#+16
   \       0x3A   0x46A1             MOV      R9,R4
   \       0x3C   0xF10D 0x0B0C      ADD      R11,SP,#+12
   \       0x40   0x4652             MOV      R2,R10
   \       0x42   0x4649             MOV      R1,R9
   \       0x44   0x4658             MOV      R0,R11
   \       0x46   0x.... 0x....      BL       __aeabi_memcpy
    277              if ((ret = sl_se_aes_crypt_ecb(cmd_ctx, key, SL_SE_ENCRYPT, 16U, iv, iv))
    278                  != SL_STATUS_OK) {
   \       0x4A   0x9401             STR      R4,[SP, #+4]
   \       0x4C   0x9400             STR      R4,[SP, #+0]
   \       0x4E   0x2310             MOVS     R3,#+16
   \       0x50   0x2200             MOVS     R2,#+0
   \       0x52   0x9909             LDR      R1,[SP, #+36]
   \       0x54   0x9808             LDR      R0,[SP, #+32]
   \       0x56   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \       0x5A   0x0007             MOVS     R7,R0
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb8_4
    279                return ret;
   \       0x60   0x0038             MOVS     R0,R7
   \       0x62   0xE022             B.N      ??sl_se_aes_crypt_cfb8_2
    280              }
    281          
    282              if (mode == SL_SE_DECRYPT) {
   \                     ??sl_se_aes_crypt_cfb8_4: (+1)
   \       0x64   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??sl_se_aes_crypt_cfb8_5
    283                ov[16] = *input;
   \       0x6C   0x7828             LDRB     R0,[R5, #+0]
   \       0x6E   0xF88D 0x001C      STRB     R0,[SP, #+28]
    284              }
    285          
    286              c = *output++ = (unsigned char)(iv[0] ^ *input++);
   \                     ??sl_se_aes_crypt_cfb8_5: (+1)
   \       0x72   0x7821             LDRB     R1,[R4, #+0]
   \       0x74   0x7828             LDRB     R0,[R5, #+0]
   \       0x76   0x4048             EORS     R0,R0,R1
   \       0x78   0x1C6D             ADDS     R5,R5,#+1
   \       0x7A   0x7030             STRB     R0,[R6, #+0]
   \       0x7C   0x1C76             ADDS     R6,R6,#+1
   \       0x7E   0xF88D 0x0008      STRB     R0,[SP, #+8]
    287          
    288              if (mode == SL_SE_ENCRYPT) {
   \       0x82   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD103             BNE.N    ??sl_se_aes_crypt_cfb8_6
    289                ov[16] = c;
   \       0x8A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x8E   0xF88D 0x001C      STRB     R0,[SP, #+28]
    290              }
    291          
    292              memcpy(iv, ov + 1, 16U);
   \                     ??sl_se_aes_crypt_cfb8_6: (+1)
   \       0x92   0xF05F 0x0B10      MOVS     R11,#+16
   \       0x96   0xF10D 0x090D      ADD      R9,SP,#+13
   \       0x9A   0x46A2             MOV      R10,R4
   \       0x9C   0x465A             MOV      R2,R11
   \       0x9E   0x4649             MOV      R1,R9
   \       0xA0   0x4650             MOV      R0,R10
   \       0xA2   0x.... 0x....      BL       __aeabi_memcpy
    293            }
   \       0xA6   0xE7C1             B.N      ??sl_se_aes_crypt_cfb8_1
    294          
    295            return ret;
   \                     ??sl_se_aes_crypt_cfb8_3: (+1)
   \       0xA8   0x0038             MOVS     R0,R7
   \                     ??sl_se_aes_crypt_cfb8_2: (+1)
   \       0xAA   0xB00B             ADD      SP,SP,#+44
   \       0xAC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    296          }
    297          
    298          /***************************************************************************//**
    299           * Increment the input nonce counter by one
    300           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    301          static void increment_nonce_counter(uint8_t block_end, unsigned char nonce_counter[])
    302          {
   \                     increment_nonce_counter: (+1)
   \        0x0   0xB410             PUSH     {R4}
    303            for (size_t i = 0u; i < SL_SE_AES_BLOCK_SIZE; i++) {
   \        0x2   0x2300             MOVS     R3,#+0
   \                     ??increment_nonce_counter_0: (+1)
   \        0x4   0x2B10             CMP      R3,#+16
   \        0x6   0xD210             BCS.N    ??increment_nonce_counter_1
    304              nonce_counter[block_end - i] = nonce_counter[block_end - i] + 1u;
   \        0x8   0x0002             MOVS     R2,R0
   \        0xA   0xB2D2             UXTB     R2,R2
   \        0xC   0x1AD2             SUBS     R2,R2,R3
   \        0xE   0x5C8C             LDRB     R4,[R1, R2]
   \       0x10   0x1C64             ADDS     R4,R4,#+1
   \       0x12   0x0002             MOVS     R2,R0
   \       0x14   0xB2D2             UXTB     R2,R2
   \       0x16   0x1AD2             SUBS     R2,R2,R3
   \       0x18   0x548C             STRB     R4,[R1, R2]
    305              if (nonce_counter[block_end - i] != 0u) {
   \       0x1A   0x0002             MOVS     R2,R0
   \       0x1C   0xB2D2             UXTB     R2,R2
   \       0x1E   0x1AD2             SUBS     R2,R2,R3
   \       0x20   0x5C8A             LDRB     R2,[R1, R2]
   \       0x22   0x2A00             CMP      R2,#+0
   \       0x24   0xD101             BNE.N    ??increment_nonce_counter_1
    306                // did not overflow so no need to increment the value at next index
    307                break;
    308              }
    309            }
   \                     ??increment_nonce_counter_2: (+1)
   \       0x26   0x1C5B             ADDS     R3,R3,#+1
   \       0x28   0xE7EC             B.N      ??increment_nonce_counter_0
    310          }
   \                     ??increment_nonce_counter_1: (+1)
   \       0x2A   0xBC10             POP      {R4}
   \       0x2C   0x4770             BX       LR
    311          
    312          #if (SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED > 1)
    313          /***************************************************************************//**
    314           * Prepare the SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE byte
    315           * wide stream block buffer that will be used as nonce counter for
    316           * encryption/decryption.
    317           ******************************************************************************/
    318          static void prepare_nonce_counter(unsigned char nonce_counter[],
    319                                            unsigned char stream_block[])
    320          {
    321            uint8_t no_of_blocks = ((SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE) / SL_SE_AES_BLOCK_SIZE);
    322            // place the most recent counter in the first stream block
    323            memcpy(stream_block,
    324                   nonce_counter,
    325                   SL_SE_AES_BLOCK_SIZE);
    326          
    327            for (size_t i = 0; i < no_of_blocks - 1u; i++) {
    328              // Use the first block's reference counter to update the other
    329              // blocks since it holds the most recent counter information.
    330              memcpy(&stream_block[i * SL_SE_AES_BLOCK_SIZE + SL_SE_AES_BLOCK_SIZE],
    331                     &stream_block[i * SL_SE_AES_BLOCK_SIZE],
    332                     SL_SE_AES_BLOCK_SIZE);
    333              increment_nonce_counter(((i + 2u) * SL_SE_AES_BLOCK_SIZE) - 1u, stream_block);
    334            }
    335          
    336            // Store the largest counter back in the nonce counter buffer
    337            memcpy(nonce_counter,
    338                   &stream_block[(no_of_blocks - 1u) * SL_SE_AES_BLOCK_SIZE],
    339                   SL_SE_AES_BLOCK_SIZE);
    340          }
    341          #endif // SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED > 1
    342          
    343          /***************************************************************************//**
    344           * AES-CTR buffer encryption/decryption.
    345           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    346          sl_status_t sl_se_aes_crypt_ctr(sl_se_command_context_t *cmd_ctx,
    347                                          const sl_se_key_descriptor_t *key,
    348                                          size_t length,
    349                                          uint32_t *nc_off,
    350                                          unsigned char nonce_counter[16],
    351                                          unsigned char stream_block[SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE],
    352                                          const unsigned char *input,
    353                                          unsigned char *output)
    354          {
   \                     sl_se_aes_crypt_ctr: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB096             SUB      SP,SP,#+88
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0xF8DD 0x9088      LDR      R9,[SP, #+136]
   \        0xC   0xF8DD 0xB08C      LDR      R11,[SP, #+140]
    355            if (cmd_ctx == NULL || key == NULL
    356                || (length != 0 && (input == NULL || output == NULL))
    357                || nonce_counter == NULL || stream_block == NULL) {
   \       0x10   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x14   0xD011             BEQ.N    ??sl_se_aes_crypt_ctr_0
   \       0x16   0x9816             LDR      R0,[SP, #+88]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD00E             BEQ.N    ??sl_se_aes_crypt_ctr_0
   \       0x1C   0x9817             LDR      R0,[SP, #+92]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD005             BEQ.N    ??sl_se_aes_crypt_ctr_1
   \       0x22   0x9824             LDR      R0,[SP, #+144]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD008             BEQ.N    ??sl_se_aes_crypt_ctr_0
   \       0x28   0x9825             LDR      R0,[SP, #+148]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD005             BEQ.N    ??sl_se_aes_crypt_ctr_0
   \                     ??sl_se_aes_crypt_ctr_1: (+1)
   \       0x2E   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x32   0xD002             BEQ.N    ??sl_se_aes_crypt_ctr_0
   \       0x34   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x38   0xD101             BNE.N    ??sl_se_aes_crypt_ctr_2
    358              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_ctr_0: (+1)
   \       0x3A   0x2021             MOVS     R0,#+33
   \       0x3C   0xE0DA             B.N      ??sl_se_aes_crypt_ctr_3
    359            }
    360          
    361            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_aes_crypt_ctr_2: (+1)
   \       0x3E   0xF8CD 0x8008      STR      R8,[SP, #+8]
    362            uint32_t n = nc_off ? *nc_off : 0;
   \       0x42   0x9818             LDR      R0,[SP, #+96]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD002             BEQ.N    ??sl_se_aes_crypt_ctr_4
   \       0x48   0x9818             LDR      R0,[SP, #+96]
   \       0x4A   0x6805             LDR      R5,[R0, #+0]
   \       0x4C   0xE000             B.N      ??sl_se_aes_crypt_ctr_5
   \                     ??sl_se_aes_crypt_ctr_4: (+1)
   \       0x4E   0x2500             MOVS     R5,#+0
    363            uint32_t processed = 0;
   \                     ??sl_se_aes_crypt_ctr_5: (+1)
   \       0x50   0xF05F 0x0A00      MOVS     R10,#+0
    364            sl_status_t command_status = SL_STATUS_OK;
   \       0x54   0x2400             MOVS     R4,#+0
    365          
    366            while (processed < length) {
   \                     ??sl_se_aes_crypt_ctr_6: (+1)
   \       0x56   0x9817             LDR      R0,[SP, #+92]
   \       0x58   0x4582             CMP      R10,R0
   \       0x5A   0xF080 0x80C5      BCS.W    ??sl_se_aes_crypt_ctr_7
    367              if (n > 0) {
   \       0x5E   0x2D00             CMP      R5,#+0
   \       0x60   0xD00E             BEQ.N    ??sl_se_aes_crypt_ctr_8
    368                // start by filling up the IV
    369                output[processed] = (unsigned char)(input[processed] ^ stream_block[n]);
   \       0x62   0x9824             LDR      R0,[SP, #+144]
   \       0x64   0xF810 0x100A      LDRB     R1,[R0, R10]
   \       0x68   0xF81B 0x0005      LDRB     R0,[R11, R5]
   \       0x6C   0x4041             EORS     R1,R0,R1
   \       0x6E   0x9825             LDR      R0,[SP, #+148]
   \       0x70   0xF800 0x100A      STRB     R1,[R0, R10]
    370                n = (n + 1) & ((SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE) - 1u);
   \       0x74   0x1C6D             ADDS     R5,R5,#+1
   \       0x76   0xF015 0x050F      ANDS     R5,R5,#0xF
    371                processed++;
   \       0x7A   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \       0x7E   0xE7EA             B.N      ??sl_se_aes_crypt_ctr_6
    372              } else {
    373                // process one or more blocks of data
    374                uint32_t iterations = (length - processed) / SL_SE_AES_BLOCK_SIZE;
   \                     ??sl_se_aes_crypt_ctr_8: (+1)
   \       0x80   0x9E17             LDR      R6,[SP, #+92]
   \       0x82   0xEBB6 0x060A      SUBS     R6,R6,R10
   \       0x86   0x0936             LSRS     R6,R6,#+4
    375          
    376                if (iterations > 0) {
   \       0x88   0x2E00             CMP      R6,#+0
   \       0x8A   0xF000 0x8080      BEQ.W    ??sl_se_aes_crypt_ctr_9
    377                  sli_se_command_init(cmd_ctx,
    378                                      SLI_SE_COMMAND_AES_ENCRYPT
    379                                      | SLI_SE_COMMAND_OPTION_MODE_CTR
    380                                      | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \       0x92   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xF8C8 0x0004      STR      R0,[R8, #+4]
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0xF8C8 0x001C      STR      R0,[R8, #+28]
    381          
    382                  // Add key parameters to command
    383                  sli_add_key_parameters(cmd_ctx, key, command_status);
   \       0xA8   0x4669             MOV      R1,SP
   \       0xAA   0x9816             LDR      R0,[SP, #+88]
   \       0xAC   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xB0   0x0007             MOVS     R7,R0
   \       0xB2   0x2F00             CMP      R7,#+0
   \       0xB4   0xD001             BEQ.N    ??sl_se_aes_crypt_ctr_10
   \       0xB6   0x0038             MOVS     R0,R7
   \       0xB8   0xE09C             B.N      ??sl_se_aes_crypt_ctr_3
   \                     ??sl_se_aes_crypt_ctr_10: (+1)
   \       0xBA   0x9900             LDR      R1,[SP, #+0]
   \       0xBC   0x4640             MOV      R0,R8
   \       0xBE   0x.... 0x....      BL       SE_addParameter
    384                  // Message size (number of bytes)
    385                  SE_addParameter(se_cmd, iterations * SL_SE_AES_BLOCK_SIZE);
   \       0xC2   0x0131             LSLS     R1,R6,#+4
   \       0xC4   0x9802             LDR      R0,[SP, #+8]
   \       0xC6   0x.... 0x....      BL       SE_addParameter
    386          
    387                  // Add key metadata block to command
    388                  sli_add_key_metadata(cmd_ctx, key, command_status);
   \       0xCA   0xA913             ADD      R1,SP,#+76
   \       0xCC   0x9816             LDR      R0,[SP, #+88]
   \       0xCE   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xD2   0x0004             MOVS     R4,R0
   \       0xD4   0x2C00             CMP      R4,#+0
   \       0xD6   0xD001             BEQ.N    ??sl_se_aes_crypt_ctr_11
   \       0xD8   0x0020             MOVS     R0,R4
   \       0xDA   0xE08B             B.N      ??sl_se_aes_crypt_ctr_3
   \                     ??sl_se_aes_crypt_ctr_11: (+1)
   \       0xDC   0xA913             ADD      R1,SP,#+76
   \       0xDE   0x4640             MOV      R0,R8
   \       0xE0   0x.... 0x....      BL       SE_addDataInput
    389                  // Add key input block to command
    390                  sli_add_key_input(cmd_ctx, key, command_status);
   \       0xE4   0xA910             ADD      R1,SP,#+64
   \       0xE6   0x9816             LDR      R0,[SP, #+88]
   \       0xE8   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xEC   0x0007             MOVS     R7,R0
   \       0xEE   0x2F00             CMP      R7,#+0
   \       0xF0   0xD001             BEQ.N    ??sl_se_aes_crypt_ctr_12
   \       0xF2   0x0038             MOVS     R0,R7
   \       0xF4   0xE07E             B.N      ??sl_se_aes_crypt_ctr_3
   \                     ??sl_se_aes_crypt_ctr_12: (+1)
   \       0xF6   0xA910             ADD      R1,SP,#+64
   \       0xF8   0x4640             MOV      R0,R8
   \       0xFA   0x.... 0x....      BL       SE_addDataInput
    391          
    392                  SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(nonce_counter, SL_SE_AES_BLOCK_SIZE);
   \       0xFE   0xAC0D             ADD      R4,SP,#+52
   \      0x100   0x.... 0x....      LDR.W    R0,??DataTable7_6
   \      0x104   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x108   0xE884 0x000E      STM      R4,{R1-R3}
   \      0x10C   0xF8CD 0x9034      STR      R9,[SP, #+52]
    393                  SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(&input[processed], iterations * SL_SE_AES_BLOCK_SIZE);
   \      0x110   0xAB07             ADD      R3,SP,#+28
   \      0x112   0x.... 0x....      LDR.W    R4,??DataTable7_7
   \      0x116   0xE894 0x0007      LDM      R4,{R0-R2}
   \      0x11A   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x11E   0x9824             LDR      R0,[SP, #+144]
   \      0x120   0x4450             ADD      R0,R0,R10
   \      0x122   0x9007             STR      R0,[SP, #+28]
   \      0x124   0x0130             LSLS     R0,R6,#+4
   \      0x126   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x12A   0x9009             STR      R0,[SP, #+36]
    394                  SE_addDataInput(se_cmd, &iv_in);
   \      0x12C   0xA90D             ADD      R1,SP,#+52
   \      0x12E   0x9802             LDR      R0,[SP, #+8]
   \      0x130   0x.... 0x....      BL       SE_addDataInput
    395                  SE_addDataInput(se_cmd, &in);
   \      0x134   0xA907             ADD      R1,SP,#+28
   \      0x136   0x9802             LDR      R0,[SP, #+8]
   \      0x138   0x.... 0x....      BL       SE_addDataInput
    396          
    397                  SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(&output[processed], iterations * SL_SE_AES_BLOCK_SIZE);
   \      0x13C   0xAB04             ADD      R3,SP,#+16
   \      0x13E   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0x142   0xE890 0x0016      LDM      R0,{R1,R2,R4}
   \      0x146   0xE883 0x0016      STM      R3,{R1,R2,R4}
   \      0x14A   0x9825             LDR      R0,[SP, #+148]
   \      0x14C   0x4450             ADD      R0,R0,R10
   \      0x14E   0x9004             STR      R0,[SP, #+16]
   \      0x150   0x0130             LSLS     R0,R6,#+4
   \      0x152   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x156   0x9006             STR      R0,[SP, #+24]
    398                  SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(nonce_counter, SL_SE_AES_BLOCK_SIZE);
   \      0x158   0xAB0A             ADD      R3,SP,#+40
   \      0x15A   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \      0x15E   0xE890 0x0016      LDM      R0,{R1,R2,R4}
   \      0x162   0xE883 0x0016      STM      R3,{R1,R2,R4}
   \      0x166   0xF8CD 0x9028      STR      R9,[SP, #+40]
    399                  SE_addDataOutput(se_cmd, &out);
   \      0x16A   0xA904             ADD      R1,SP,#+16
   \      0x16C   0x9802             LDR      R0,[SP, #+8]
   \      0x16E   0x.... 0x....      BL       SE_addDataOutput
    400                  SE_addDataOutput(se_cmd, &iv_out);
   \      0x172   0xA90A             ADD      R1,SP,#+40
   \      0x174   0x9802             LDR      R0,[SP, #+8]
   \      0x176   0x.... 0x....      BL       SE_addDataOutput
    401          
    402                  command_status = sli_se_execute_and_wait(cmd_ctx);
   \      0x17A   0x4640             MOV      R0,R8
   \      0x17C   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x180   0x0004             MOVS     R4,R0
    403                  processed += iterations * SL_SE_AES_BLOCK_SIZE;
   \      0x182   0xEB1A 0x1A06      ADDS     R10,R10,R6, LSL #+4
    404                  if (command_status != SL_STATUS_OK) {
   \      0x186   0x2C00             CMP      R4,#+0
   \      0x188   0xD001             BEQ.N    ??sl_se_aes_crypt_ctr_9
    405                    return command_status;
   \      0x18A   0x0020             MOVS     R0,R4
   \      0x18C   0xE032             B.N      ??sl_se_aes_crypt_ctr_3
    406                  }
    407                }
    408          
    409                while ((length - processed) > 0) {
   \                     ??sl_se_aes_crypt_ctr_9: (+1)
   \      0x18E   0x9817             LDR      R0,[SP, #+92]
   \      0x190   0xEBB0 0x000A      SUBS     R0,R0,R10
   \      0x194   0x2800             CMP      R0,#+0
   \      0x196   0xF43F 0xAF5E      BEQ.W    ??sl_se_aes_crypt_ctr_6
    410                  if (n == 0) {
   \      0x19A   0x2D00             CMP      R5,#+0
   \      0x19C   0xD115             BNE.N    ??sl_se_aes_crypt_ctr_13
    411                    // Get a new stream block
    412                    unsigned char *counter_ptr = NULL;
   \      0x19E   0x2700             MOVS     R7,#+0
    413                    #if (SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED > 1)
    414                    // Use the nonce counter buffer as the reference to create nonce counter blocks
    415                    // needed to compute the key stream blocks. Also, update the nonce counter buffer
    416                    // to store the latest block.
    417                    prepare_nonce_counter(nonce_counter, stream_block);
    418                    // The key stream buffer now holds the nonce counter
    419                    counter_ptr = stream_block;
    420                    #else
    421                    counter_ptr = nonce_counter;
   \      0x1A0   0xF8CD 0x900C      STR      R9,[SP, #+12]
    422                    #endif // SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED > 1
    423          
    424                    command_status = sl_se_aes_crypt_ecb(cmd_ctx,
    425                                                         key,
    426                                                         SL_SE_ENCRYPT,
    427                                                         SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE,
    428                                                         counter_ptr,
    429                                                         stream_block);
   \      0x1A4   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \      0x1A8   0x9803             LDR      R0,[SP, #+12]
   \      0x1AA   0x9000             STR      R0,[SP, #+0]
   \      0x1AC   0x2310             MOVS     R3,#+16
   \      0x1AE   0x2200             MOVS     R2,#+0
   \      0x1B0   0x9916             LDR      R1,[SP, #+88]
   \      0x1B2   0x4640             MOV      R0,R8
   \      0x1B4   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \      0x1B8   0x0004             MOVS     R4,R0
    430                    if (command_status != SL_STATUS_OK) {
   \      0x1BA   0x2C00             CMP      R4,#+0
   \      0x1BC   0xD001             BEQ.N    ??sl_se_aes_crypt_ctr_14
    431                      return command_status;
   \      0x1BE   0x0020             MOVS     R0,R4
   \      0x1C0   0xE018             B.N      ??sl_se_aes_crypt_ctr_3
    432                    }
    433                    increment_nonce_counter(SL_SE_AES_BLOCK_SIZE - 1u, nonce_counter);
   \                     ??sl_se_aes_crypt_ctr_14: (+1)
   \      0x1C2   0x4649             MOV      R1,R9
   \      0x1C4   0x200F             MOVS     R0,#+15
   \      0x1C6   0x.... 0x....      BL       increment_nonce_counter
    434                  }
    435                  // Save remainder to IV
    436                  output[processed] = (unsigned char)(input[processed] ^ stream_block[n]);
   \                     ??sl_se_aes_crypt_ctr_13: (+1)
   \      0x1CA   0x9824             LDR      R0,[SP, #+144]
   \      0x1CC   0xF810 0x100A      LDRB     R1,[R0, R10]
   \      0x1D0   0xF81B 0x0005      LDRB     R0,[R11, R5]
   \      0x1D4   0x4041             EORS     R1,R0,R1
   \      0x1D6   0x9825             LDR      R0,[SP, #+148]
   \      0x1D8   0xF800 0x100A      STRB     R1,[R0, R10]
    437                  n = (n + 1) & ((SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE) - 1u);
   \      0x1DC   0x1C6D             ADDS     R5,R5,#+1
   \      0x1DE   0xF015 0x050F      ANDS     R5,R5,#0xF
    438                  processed++;
   \      0x1E2   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x1E6   0xE7D2             B.N      ??sl_se_aes_crypt_ctr_9
    439                }
    440              }
    441            }
    442          
    443            if ( nc_off ) {
   \                     ??sl_se_aes_crypt_ctr_7: (+1)
   \      0x1E8   0x9818             LDR      R0,[SP, #+96]
   \      0x1EA   0x2800             CMP      R0,#+0
   \      0x1EC   0xD001             BEQ.N    ??sl_se_aes_crypt_ctr_15
    444              *nc_off = n;
   \      0x1EE   0x9818             LDR      R0,[SP, #+96]
   \      0x1F0   0x6005             STR      R5,[R0, #+0]
    445            }
    446          
    447            return command_status;
   \                     ??sl_se_aes_crypt_ctr_15: (+1)
   \      0x1F2   0x0020             MOVS     R0,R4
   \                     ??sl_se_aes_crypt_ctr_3: (+1)
   \      0x1F4   0xB019             ADD      SP,SP,#+100
   \      0x1F6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    448          }

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
    449          
    450          /***************************************************************************//**
    451           * AES-CCM buffer encryption.
    452           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    453          sl_status_t sl_se_ccm_encrypt_and_tag(sl_se_command_context_t *cmd_ctx,
    454                                                const sl_se_key_descriptor_t *key,
    455                                                size_t length,
    456                                                const unsigned char *iv, size_t iv_len,
    457                                                const unsigned char *add, size_t add_len,
    458                                                const unsigned char *input,
    459                                                unsigned char *output,
    460                                                unsigned char *tag, size_t tag_len)
    461          {
   \                     sl_se_ccm_encrypt_and_tag: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB098             SUB      SP,SP,#+96
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0xF8DD 0xA088      LDR      R10,[SP, #+136]
   \       0x10   0x9F26             LDR      R7,[SP, #+152]
   \       0x12   0xF8DD 0x80A0      LDR      R8,[SP, #+160]
    462            if (cmd_ctx == NULL || key == NULL || (tag_len > 0 && tag == NULL) || iv == NULL) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD00A             BEQ.N    ??sl_se_ccm_encrypt_and_tag_0
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD008             BEQ.N    ??sl_se_ccm_encrypt_and_tag_0
   \       0x1E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x22   0xD002             BEQ.N    ??sl_se_ccm_encrypt_and_tag_1
   \       0x24   0x9827             LDR      R0,[SP, #+156]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ.N    ??sl_se_ccm_encrypt_and_tag_0
   \                     ??sl_se_ccm_encrypt_and_tag_1: (+1)
   \       0x2A   0x9818             LDR      R0,[SP, #+96]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD101             BNE.N    ??sl_se_ccm_encrypt_and_tag_2
    463              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_encrypt_and_tag_0: (+1)
   \       0x30   0x2021             MOVS     R0,#+33
   \       0x32   0xE0D6             B.N      ??sl_se_ccm_encrypt_and_tag_3
    464            }
    465            if (add_len > 0 && add == NULL) {
   \                     ??sl_se_ccm_encrypt_and_tag_2: (+1)
   \       0x34   0x9824             LDR      R0,[SP, #+144]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD004             BEQ.N    ??sl_se_ccm_encrypt_and_tag_4
   \       0x3A   0x9823             LDR      R0,[SP, #+140]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD101             BNE.N    ??sl_se_ccm_encrypt_and_tag_4
    466              return SL_STATUS_INVALID_PARAMETER;
   \       0x40   0x2021             MOVS     R0,#+33
   \       0x42   0xE0CE             B.N      ??sl_se_ccm_encrypt_and_tag_3
    467            }
    468            if (length > 0 && (input == NULL || output == NULL)) {
   \                     ??sl_se_ccm_encrypt_and_tag_4: (+1)
   \       0x44   0x2E00             CMP      R6,#+0
   \       0x46   0xD006             BEQ.N    ??sl_se_ccm_encrypt_and_tag_5
   \       0x48   0x9825             LDR      R0,[SP, #+148]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD001             BEQ.N    ??sl_se_ccm_encrypt_and_tag_6
   \       0x4E   0x2F00             CMP      R7,#+0
   \       0x50   0xD101             BNE.N    ??sl_se_ccm_encrypt_and_tag_5
    469              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_encrypt_and_tag_6: (+1)
   \       0x52   0x2021             MOVS     R0,#+33
   \       0x54   0xE0C5             B.N      ??sl_se_ccm_encrypt_and_tag_3
    470            }
    471          
    472            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_ccm_encrypt_and_tag_5: (+1)
   \       0x56   0x9401             STR      R4,[SP, #+4]
    473            unsigned char q;
    474            sl_status_t command_status = SL_STATUS_OK;
   \       0x58   0xF05F 0x0B00      MOVS     R11,#+0
    475          
    476            // Test for invalid (too long) message length. This test is included here because
    477            // the SE does not implement the test. When the SE ultimately implements the test
    478            // the following test can be removed.
    479            q = 16 - 1 - (unsigned char) iv_len;
   \       0x5C   0xF1DA 0x000F      RSBS     R0,R10,#+15
   \       0x60   0xF88D 0x0000      STRB     R0,[SP, #+0]
    480            if ((q < sizeof(length)) && (length >= (1UL << (q * 8)))) {
   \       0x64   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x68   0x2804             CMP      R0,#+4
   \       0x6A   0xD209             BCS.N    ??sl_se_ccm_encrypt_and_tag_7
   \       0x6C   0x2101             MOVS     R1,#+1
   \       0x6E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x72   0xB2C0             UXTB     R0,R0
   \       0x74   0x00C0             LSLS     R0,R0,#+3
   \       0x76   0x4081             LSLS     R1,R1,R0
   \       0x78   0x428E             CMP      R6,R1
   \       0x7A   0xD301             BCC.N    ??sl_se_ccm_encrypt_and_tag_7
    481              return SL_STATUS_INVALID_PARAMETER;
   \       0x7C   0x2021             MOVS     R0,#+33
   \       0x7E   0xE0B0             B.N      ??sl_se_ccm_encrypt_and_tag_3
    482            }
    483          
    484            if (tag_len == 2 || tag_len > 16 || tag_len % 2 != 0) {
   \                     ??sl_se_ccm_encrypt_and_tag_7: (+1)
   \       0x80   0xF1B8 0x0F02      CMP      R8,#+2
   \       0x84   0xD005             BEQ.N    ??sl_se_ccm_encrypt_and_tag_8
   \       0x86   0xF1B8 0x0F11      CMP      R8,#+17
   \       0x8A   0xD202             BCS.N    ??sl_se_ccm_encrypt_and_tag_8
   \       0x8C   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \       0x90   0xD501             BPL.N    ??sl_se_ccm_encrypt_and_tag_9
    485              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_encrypt_and_tag_8: (+1)
   \       0x92   0x2021             MOVS     R0,#+33
   \       0x94   0xE0A5             B.N      ??sl_se_ccm_encrypt_and_tag_3
    486            }
    487          
    488            // Also implies q is within bounds
    489            if (iv_len < 7 || iv_len > 13) {
   \                     ??sl_se_ccm_encrypt_and_tag_9: (+1)
   \       0x96   0xF1BA 0x0F07      CMP      R10,#+7
   \       0x9A   0xD302             BCC.N    ??sl_se_ccm_encrypt_and_tag_10
   \       0x9C   0xF1BA 0x0F0E      CMP      R10,#+14
   \       0xA0   0xD301             BCC.N    ??sl_se_ccm_encrypt_and_tag_11
    490              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_encrypt_and_tag_10: (+1)
   \       0xA2   0x2021             MOVS     R0,#+33
   \       0xA4   0xE09D             B.N      ??sl_se_ccm_encrypt_and_tag_3
    491            }
    492          
    493          #if !defined(SLI_SE_MANAGER_HOST_SYSTEM)
    494            if ((uint32_t)output + length > RAM_MEM_END) {
   \                     ??sl_se_ccm_encrypt_and_tag_11: (+1)
   \       0xA6   0x19F1             ADDS     R1,R6,R7
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \       0xAC   0x4281             CMP      R1,R0
   \       0xAE   0xD301             BCC.N    ??sl_se_ccm_encrypt_and_tag_12
    495              return SL_STATUS_INVALID_PARAMETER;
   \       0xB0   0x2021             MOVS     R0,#+33
   \       0xB2   0xE096             B.N      ??sl_se_ccm_encrypt_and_tag_3
    496            }
    497          #endif // SLI_SE_MANAGER_HOST_SYSTEM
    498          
    499            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_CCM_ENCRYPT);
   \                     ??sl_se_ccm_encrypt_and_tag_12: (+1)
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \       0xB8   0x6020             STR      R0,[R4, #+0]
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0x6060             STR      R0,[R4, #+4]
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0x60A0             STR      R0,[R4, #+8]
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x61E0             STR      R0,[R4, #+28]
    500          
    501            // Add key parameters to command
    502            sli_add_key_parameters(cmd_ctx, key, command_status);
   \       0xC6   0xA902             ADD      R1,SP,#+8
   \       0xC8   0x0028             MOVS     R0,R5
   \       0xCA   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xCE   0x4681             MOV      R9,R0
   \       0xD0   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xD4   0xD001             BEQ.N    ??sl_se_ccm_encrypt_and_tag_13
   \       0xD6   0x4648             MOV      R0,R9
   \       0xD8   0xE083             B.N      ??sl_se_ccm_encrypt_and_tag_3
   \                     ??sl_se_ccm_encrypt_and_tag_13: (+1)
   \       0xDA   0x9902             LDR      R1,[SP, #+8]
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0x.... 0x....      BL       SE_addParameter
    503            // Message size (number of bytes)
    504            SE_addParameter(se_cmd, ((iv_len & 0xFFFF) << 16) | (tag_len & 0xFFFF));
   \       0xE2   0x4641             MOV      R1,R8
   \       0xE4   0xF36A 0x411F      BFI      R1,R10,#+16,#+16
   \       0xE8   0x9801             LDR      R0,[SP, #+4]
   \       0xEA   0x.... 0x....      BL       SE_addParameter
    505            SE_addParameter(se_cmd, add_len);
   \       0xEE   0x9924             LDR      R1,[SP, #+144]
   \       0xF0   0x9801             LDR      R0,[SP, #+4]
   \       0xF2   0x.... 0x....      BL       SE_addParameter
    506            SE_addParameter(se_cmd, length);
   \       0xF6   0x0031             MOVS     R1,R6
   \       0xF8   0x9801             LDR      R0,[SP, #+4]
   \       0xFA   0x.... 0x....      BL       SE_addParameter
    507          
    508            // Add key metadata block to command
    509            sli_add_key_metadata(cmd_ctx, key, command_status);
   \       0xFE   0xA915             ADD      R1,SP,#+84
   \      0x100   0x0028             MOVS     R0,R5
   \      0x102   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x106   0x4683             MOV      R11,R0
   \      0x108   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x10C   0xD001             BEQ.N    ??sl_se_ccm_encrypt_and_tag_14
   \      0x10E   0x4658             MOV      R0,R11
   \      0x110   0xE067             B.N      ??sl_se_ccm_encrypt_and_tag_3
   \                     ??sl_se_ccm_encrypt_and_tag_14: (+1)
   \      0x112   0xA915             ADD      R1,SP,#+84
   \      0x114   0x0020             MOVS     R0,R4
   \      0x116   0x.... 0x....      BL       SE_addDataInput
    510            // Add key input block to command
    511            sli_add_key_input(cmd_ctx, key, command_status);
   \      0x11A   0xA912             ADD      R1,SP,#+72
   \      0x11C   0x0028             MOVS     R0,R5
   \      0x11E   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x122   0x4681             MOV      R9,R0
   \      0x124   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x128   0xD001             BEQ.N    ??sl_se_ccm_encrypt_and_tag_15
   \      0x12A   0x4648             MOV      R0,R9
   \      0x12C   0xE059             B.N      ??sl_se_ccm_encrypt_and_tag_3
   \                     ??sl_se_ccm_encrypt_and_tag_15: (+1)
   \      0x12E   0xA912             ADD      R1,SP,#+72
   \      0x130   0x0020             MOVS     R0,R4
   \      0x132   0x.... 0x....      BL       SE_addDataInput
    512          
    513            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(input, length);
   \      0x136   0xF10D 0x0C3C      ADD      R12,SP,#+60
   \      0x13A   0x.... 0x....      LDR.W    R0,??DataTable9
   \      0x13E   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x142   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x146   0x9825             LDR      R0,[SP, #+148]
   \      0x148   0x900F             STR      R0,[SP, #+60]
   \      0x14A   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \      0x14E   0x9011             STR      R0,[SP, #+68]
    514            SE_DataTransfer_t in_add = SE_DATATRANSFER_DEFAULT(add, add_len);
   \      0x150   0xF10D 0x0C30      ADD      R12,SP,#+48
   \      0x154   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \      0x158   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x15C   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x160   0x9823             LDR      R0,[SP, #+140]
   \      0x162   0x900C             STR      R0,[SP, #+48]
   \      0x164   0x9824             LDR      R0,[SP, #+144]
   \      0x166   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x16A   0x900E             STR      R0,[SP, #+56]
    515            SE_DataTransfer_t in_nonce = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \      0x16C   0xF10D 0x0C24      ADD      R12,SP,#+36
   \      0x170   0x.... 0x....      LDR.W    R0,??DataTable9_2
   \      0x174   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x178   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x17C   0x9818             LDR      R0,[SP, #+96]
   \      0x17E   0x9009             STR      R0,[SP, #+36]
   \      0x180   0xF05A 0x5000      ORRS     R0,R10,#0x20000000
   \      0x184   0x900B             STR      R0,[SP, #+44]
    516            SE_addDataInput(se_cmd, &in_nonce);
   \      0x186   0xA909             ADD      R1,SP,#+36
   \      0x188   0x9801             LDR      R0,[SP, #+4]
   \      0x18A   0x.... 0x....      BL       SE_addDataInput
    517            SE_addDataInput(se_cmd, &in_add);
   \      0x18E   0xA90C             ADD      R1,SP,#+48
   \      0x190   0x9801             LDR      R0,[SP, #+4]
   \      0x192   0x.... 0x....      BL       SE_addDataInput
    518            SE_addDataInput(se_cmd, &in_data);
   \      0x196   0xA90F             ADD      R1,SP,#+60
   \      0x198   0x9801             LDR      R0,[SP, #+4]
   \      0x19A   0x.... 0x....      BL       SE_addDataInput
    519          
    520            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x19E   0xAB06             ADD      R3,SP,#+24
   \      0x1A0   0x.... 0x....      LDR.W    R12,??DataTable9_3
   \      0x1A4   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x1A8   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x1AC   0x9706             STR      R7,[SP, #+24]
   \      0x1AE   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \      0x1B2   0x9008             STR      R0,[SP, #+32]
    521            SE_DataTransfer_t out_tag = SE_DATATRANSFER_DEFAULT(tag, tag_len);
   \      0x1B4   0xAB03             ADD      R3,SP,#+12
   \      0x1B6   0x.... 0x....      LDR.W    R12,??DataTable10
   \      0x1BA   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x1BE   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x1C2   0x9827             LDR      R0,[SP, #+156]
   \      0x1C4   0x9003             STR      R0,[SP, #+12]
   \      0x1C6   0xF058 0x5000      ORRS     R0,R8,#0x20000000
   \      0x1CA   0x9005             STR      R0,[SP, #+20]
    522            SE_addDataOutput(se_cmd, &out_data);
   \      0x1CC   0xA906             ADD      R1,SP,#+24
   \      0x1CE   0x9801             LDR      R0,[SP, #+4]
   \      0x1D0   0x.... 0x....      BL       SE_addDataOutput
    523            SE_addDataOutput(se_cmd, &out_tag);
   \      0x1D4   0xA903             ADD      R1,SP,#+12
   \      0x1D6   0x9801             LDR      R0,[SP, #+4]
   \      0x1D8   0x.... 0x....      BL       SE_addDataOutput
    524          
    525            command_status = sli_se_execute_and_wait(cmd_ctx);
   \      0x1DC   0x0020             MOVS     R0,R4
   \      0x1DE   0x.... 0x....      BL       sli_se_execute_and_wait
    526            return command_status;
   \                     ??sl_se_ccm_encrypt_and_tag_3: (+1)
   \      0x1E2   0xB019             ADD      SP,SP,#+100
   \      0x1E4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    527          }

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    528          
    529          /***************************************************************************//**
    530           * AES-CCM buffer decryption.
    531           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    532          sl_status_t sl_se_ccm_auth_decrypt(sl_se_command_context_t *cmd_ctx,
    533                                             const sl_se_key_descriptor_t *key,
    534                                             size_t length,
    535                                             const unsigned char *iv, size_t iv_len,
    536                                             const unsigned char *add, size_t add_len,
    537                                             const unsigned char *input,
    538                                             unsigned char *output,
    539                                             const unsigned char *tag, size_t tag_len)
    540          {
   \                     sl_se_ccm_auth_decrypt: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB09A             SUB      SP,SP,#+104
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0xF8DD 0xB090      LDR      R11,[SP, #+144]
   \       0x10   0x9F28             LDR      R7,[SP, #+160]
   \       0x12   0xF8DD 0x80A8      LDR      R8,[SP, #+168]
    541            if (cmd_ctx == NULL || key == NULL || tag == NULL || iv == NULL) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD007             BEQ.N    ??sl_se_ccm_auth_decrypt_0
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD005             BEQ.N    ??sl_se_ccm_auth_decrypt_0
   \       0x1E   0x9829             LDR      R0,[SP, #+164]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD002             BEQ.N    ??sl_se_ccm_auth_decrypt_0
   \       0x24   0x981A             LDR      R0,[SP, #+104]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD101             BNE.N    ??sl_se_ccm_auth_decrypt_1
    542              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_auth_decrypt_0: (+1)
   \       0x2A   0x2021             MOVS     R0,#+33
   \       0x2C   0xE0EA             B.N      ??sl_se_ccm_auth_decrypt_2
    543            }
    544            if (add_len > 0 && add == NULL) {
   \                     ??sl_se_ccm_auth_decrypt_1: (+1)
   \       0x2E   0x9826             LDR      R0,[SP, #+152]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD004             BEQ.N    ??sl_se_ccm_auth_decrypt_3
   \       0x34   0x9825             LDR      R0,[SP, #+148]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD101             BNE.N    ??sl_se_ccm_auth_decrypt_3
    545              return SL_STATUS_INVALID_PARAMETER;
   \       0x3A   0x2021             MOVS     R0,#+33
   \       0x3C   0xE0E2             B.N      ??sl_se_ccm_auth_decrypt_2
    546            }
    547            if (length > 0 && (input == NULL || output == NULL)) {
   \                     ??sl_se_ccm_auth_decrypt_3: (+1)
   \       0x3E   0x2E00             CMP      R6,#+0
   \       0x40   0xD006             BEQ.N    ??sl_se_ccm_auth_decrypt_4
   \       0x42   0x9827             LDR      R0,[SP, #+156]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD001             BEQ.N    ??sl_se_ccm_auth_decrypt_5
   \       0x48   0x2F00             CMP      R7,#+0
   \       0x4A   0xD101             BNE.N    ??sl_se_ccm_auth_decrypt_4
    548              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_auth_decrypt_5: (+1)
   \       0x4C   0x2021             MOVS     R0,#+33
   \       0x4E   0xE0D9             B.N      ??sl_se_ccm_auth_decrypt_2
    549            }
    550          
    551            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_ccm_auth_decrypt_4: (+1)
   \       0x50   0x9401             STR      R4,[SP, #+4]
    552            unsigned char q;
    553            sl_status_t command_status = SL_STATUS_OK;
   \       0x52   0xF05F 0x0A00      MOVS     R10,#+0
    554          
    555            // Test for invalid (too long) message length. This test is included here because
    556            // the SE does not implement the test. When the SE ultimately implements the test
    557            // the following test can be removed.
    558            q = 16 - 1 - (unsigned char) iv_len;
   \       0x56   0xF1DB 0x000F      RSBS     R0,R11,#+15
   \       0x5A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    559            if ((q < sizeof(length)) && (length >= (1UL << (q * 8)))) {
   \       0x5E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x62   0x2804             CMP      R0,#+4
   \       0x64   0xD209             BCS.N    ??sl_se_ccm_auth_decrypt_6
   \       0x66   0x2101             MOVS     R1,#+1
   \       0x68   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x6C   0xB2C0             UXTB     R0,R0
   \       0x6E   0x00C0             LSLS     R0,R0,#+3
   \       0x70   0x4081             LSLS     R1,R1,R0
   \       0x72   0x428E             CMP      R6,R1
   \       0x74   0xD301             BCC.N    ??sl_se_ccm_auth_decrypt_6
    560              return SL_STATUS_INVALID_PARAMETER;
   \       0x76   0x2021             MOVS     R0,#+33
   \       0x78   0xE0C4             B.N      ??sl_se_ccm_auth_decrypt_2
    561            }
    562          
    563            if (tag_len == 2 || tag_len == 0 || tag_len > 16 || tag_len % 2 != 0) {
   \                     ??sl_se_ccm_auth_decrypt_6: (+1)
   \       0x7A   0xF1B8 0x0F02      CMP      R8,#+2
   \       0x7E   0xD008             BEQ.N    ??sl_se_ccm_auth_decrypt_7
   \       0x80   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x84   0xD005             BEQ.N    ??sl_se_ccm_auth_decrypt_7
   \       0x86   0xF1B8 0x0F11      CMP      R8,#+17
   \       0x8A   0xD202             BCS.N    ??sl_se_ccm_auth_decrypt_7
   \       0x8C   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \       0x90   0xD501             BPL.N    ??sl_se_ccm_auth_decrypt_8
    564              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_auth_decrypt_7: (+1)
   \       0x92   0x2021             MOVS     R0,#+33
   \       0x94   0xE0B6             B.N      ??sl_se_ccm_auth_decrypt_2
    565            }
    566          
    567            // Also implies q is within bounds */
    568            if (iv_len < 7 || iv_len > 13) {
   \                     ??sl_se_ccm_auth_decrypt_8: (+1)
   \       0x96   0xF1BB 0x0F07      CMP      R11,#+7
   \       0x9A   0xD302             BCC.N    ??sl_se_ccm_auth_decrypt_9
   \       0x9C   0xF1BB 0x0F0E      CMP      R11,#+14
   \       0xA0   0xD301             BCC.N    ??sl_se_ccm_auth_decrypt_10
    569              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_auth_decrypt_9: (+1)
   \       0xA2   0x2021             MOVS     R0,#+33
   \       0xA4   0xE0AE             B.N      ??sl_se_ccm_auth_decrypt_2
    570            }
    571          
    572          #if !defined(SLI_SE_MANAGER_HOST_SYSTEM)
    573            if ((uint32_t)output + length > RAM_MEM_END) {
   \                     ??sl_se_ccm_auth_decrypt_10: (+1)
   \       0xA6   0x19F1             ADDS     R1,R6,R7
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \       0xAC   0x4281             CMP      R1,R0
   \       0xAE   0xD301             BCC.N    ??sl_se_ccm_auth_decrypt_11
    574              return SL_STATUS_INVALID_PARAMETER;
   \       0xB0   0x2021             MOVS     R0,#+33
   \       0xB2   0xE0A7             B.N      ??sl_se_ccm_auth_decrypt_2
    575            }
    576          #endif // SLI_SE_MANAGER_HOST_SYSTEM
    577          
    578            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_CCM_DECRYPT);
   \                     ??sl_se_ccm_auth_decrypt_11: (+1)
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \       0xB8   0x6020             STR      R0,[R4, #+0]
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0x6060             STR      R0,[R4, #+4]
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0x60A0             STR      R0,[R4, #+8]
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x61E0             STR      R0,[R4, #+28]
    579          
    580            // Add key parameters to command
    581            sli_add_key_parameters(cmd_ctx, key, command_status);
   \       0xC6   0xA902             ADD      R1,SP,#+8
   \       0xC8   0x0028             MOVS     R0,R5
   \       0xCA   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xCE   0x4681             MOV      R9,R0
   \       0xD0   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xD4   0xD001             BEQ.N    ??sl_se_ccm_auth_decrypt_12
   \       0xD6   0x4648             MOV      R0,R9
   \       0xD8   0xE094             B.N      ??sl_se_ccm_auth_decrypt_2
   \                     ??sl_se_ccm_auth_decrypt_12: (+1)
   \       0xDA   0x9902             LDR      R1,[SP, #+8]
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0x.... 0x....      BL       SE_addParameter
    582            // Message size (number of bytes)
    583            SE_addParameter(se_cmd, ((iv_len & 0xFFFF) << 16) | (tag_len & 0xFFFF));
   \       0xE2   0x4641             MOV      R1,R8
   \       0xE4   0xF36B 0x411F      BFI      R1,R11,#+16,#+16
   \       0xE8   0x9801             LDR      R0,[SP, #+4]
   \       0xEA   0x.... 0x....      BL       SE_addParameter
    584            SE_addParameter(se_cmd, add_len);
   \       0xEE   0x9926             LDR      R1,[SP, #+152]
   \       0xF0   0x9801             LDR      R0,[SP, #+4]
   \       0xF2   0x.... 0x....      BL       SE_addParameter
    585            SE_addParameter(se_cmd, length);
   \       0xF6   0x0031             MOVS     R1,R6
   \       0xF8   0x9801             LDR      R0,[SP, #+4]
   \       0xFA   0x.... 0x....      BL       SE_addParameter
    586          
    587            // Add key metadata block to command
    588            sli_add_key_metadata(cmd_ctx, key, command_status);
   \       0xFE   0xA917             ADD      R1,SP,#+92
   \      0x100   0x0028             MOVS     R0,R5
   \      0x102   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x106   0x4682             MOV      R10,R0
   \      0x108   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x10C   0xD001             BEQ.N    ??sl_se_ccm_auth_decrypt_13
   \      0x10E   0x4650             MOV      R0,R10
   \      0x110   0xE078             B.N      ??sl_se_ccm_auth_decrypt_2
   \                     ??sl_se_ccm_auth_decrypt_13: (+1)
   \      0x112   0xA917             ADD      R1,SP,#+92
   \      0x114   0x0020             MOVS     R0,R4
   \      0x116   0x.... 0x....      BL       SE_addDataInput
    589            // Add key input block to command
    590            sli_add_key_input(cmd_ctx, key, command_status);
   \      0x11A   0xA914             ADD      R1,SP,#+80
   \      0x11C   0x0028             MOVS     R0,R5
   \      0x11E   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x122   0x4681             MOV      R9,R0
   \      0x124   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x128   0xD001             BEQ.N    ??sl_se_ccm_auth_decrypt_14
   \      0x12A   0x4648             MOV      R0,R9
   \      0x12C   0xE06A             B.N      ??sl_se_ccm_auth_decrypt_2
   \                     ??sl_se_ccm_auth_decrypt_14: (+1)
   \      0x12E   0xA914             ADD      R1,SP,#+80
   \      0x130   0x0020             MOVS     R0,R4
   \      0x132   0x.... 0x....      BL       SE_addDataInput
    591          
    592            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(input, length);
   \      0x136   0xF10D 0x0C44      ADD      R12,SP,#+68
   \      0x13A   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \      0x13E   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x142   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x146   0x9827             LDR      R0,[SP, #+156]
   \      0x148   0x9011             STR      R0,[SP, #+68]
   \      0x14A   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \      0x14E   0x9013             STR      R0,[SP, #+76]
    593            SE_DataTransfer_t in_add = SE_DATATRANSFER_DEFAULT(add, add_len);
   \      0x150   0xF10D 0x0C38      ADD      R12,SP,#+56
   \      0x154   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \      0x158   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x15C   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x160   0x9825             LDR      R0,[SP, #+148]
   \      0x162   0x900E             STR      R0,[SP, #+56]
   \      0x164   0x9826             LDR      R0,[SP, #+152]
   \      0x166   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x16A   0x9010             STR      R0,[SP, #+64]
    594            SE_DataTransfer_t in_nonce = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \      0x16C   0xF10D 0x0C2C      ADD      R12,SP,#+44
   \      0x170   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \      0x174   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x178   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x17C   0x981A             LDR      R0,[SP, #+104]
   \      0x17E   0x900B             STR      R0,[SP, #+44]
   \      0x180   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \      0x184   0x900D             STR      R0,[SP, #+52]
    595            SE_addDataInput(se_cmd, &in_nonce);
   \      0x186   0xA90B             ADD      R1,SP,#+44
   \      0x188   0x9801             LDR      R0,[SP, #+4]
   \      0x18A   0x.... 0x....      BL       SE_addDataInput
    596            SE_addDataInput(se_cmd, &in_add);
   \      0x18E   0xA90E             ADD      R1,SP,#+56
   \      0x190   0x9801             LDR      R0,[SP, #+4]
   \      0x192   0x.... 0x....      BL       SE_addDataInput
    597            SE_addDataInput(se_cmd, &in_data);
   \      0x196   0xA911             ADD      R1,SP,#+68
   \      0x198   0x9801             LDR      R0,[SP, #+4]
   \      0x19A   0x.... 0x....      BL       SE_addDataInput
    598          
    599            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x19E   0xAB08             ADD      R3,SP,#+32
   \      0x1A0   0x.... 0x....      LDR.W    R0,??DataTable11
   \      0x1A4   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x1A8   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x1AC   0x9708             STR      R7,[SP, #+32]
   \      0x1AE   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \      0x1B2   0x900A             STR      R0,[SP, #+40]
    600            SE_addDataOutput(se_cmd, &out_data);
   \      0x1B4   0xA908             ADD      R1,SP,#+32
   \      0x1B6   0x9801             LDR      R0,[SP, #+4]
   \      0x1B8   0x.... 0x....      BL       SE_addDataOutput
    601            SE_DataTransfer_t in_tag = SE_DATATRANSFER_DEFAULT(tag, tag_len);
   \      0x1BC   0xF10D 0x0C14      ADD      R12,SP,#+20
   \      0x1C0   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \      0x1C4   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x1C8   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x1CC   0x9829             LDR      R0,[SP, #+164]
   \      0x1CE   0x9005             STR      R0,[SP, #+20]
   \      0x1D0   0xF058 0x5000      ORRS     R0,R8,#0x20000000
   \      0x1D4   0x9007             STR      R0,[SP, #+28]
    602            SE_addDataInput(se_cmd, &in_tag);
   \      0x1D6   0xA905             ADD      R1,SP,#+20
   \      0x1D8   0x9801             LDR      R0,[SP, #+4]
   \      0x1DA   0x.... 0x....      BL       SE_addDataInput
    603          
    604            command_status = sli_se_execute_and_wait(cmd_ctx);
   \      0x1DE   0x0020             MOVS     R0,R4
   \      0x1E0   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x1E4   0x4682             MOV      R10,R0
    605            if (command_status == SL_STATUS_OK) {
   \      0x1E6   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x1EA   0xD101             BNE.N    ??sl_se_ccm_auth_decrypt_15
    606              return SL_STATUS_OK;
   \      0x1EC   0x2000             MOVS     R0,#+0
   \      0x1EE   0xE009             B.N      ??sl_se_ccm_auth_decrypt_2
    607            } else {
    608              memset(output, 0, length);
   \                     ??sl_se_ccm_auth_decrypt_15: (+1)
   \      0x1F0   0x9604             STR      R6,[SP, #+16]
   \      0x1F2   0x2000             MOVS     R0,#+0
   \      0x1F4   0x9003             STR      R0,[SP, #+12]
   \      0x1F6   0x46B9             MOV      R9,R7
   \      0x1F8   0x9A03             LDR      R2,[SP, #+12]
   \      0x1FA   0x9904             LDR      R1,[SP, #+16]
   \      0x1FC   0x4648             MOV      R0,R9
   \      0x1FE   0x.... 0x....      BL       __aeabi_memset
    609              return command_status;
   \      0x202   0x4650             MOV      R0,R10
   \                     ??sl_se_ccm_auth_decrypt_2: (+1)
   \      0x204   0xB01B             ADD      SP,SP,#+108
   \      0x206   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    610            }
    611          }

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_23:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    612          
    613          #if defined(SLI_SE_MAJOR_VERSION_ONE)
    614          sl_status_t sl_se_ccm_multipart_starts(sl_se_ccm_multipart_context_t *ccm_ctx,
    615                                                 sl_se_command_context_t *cmd_ctx,
    616                                                 const sl_se_key_descriptor_t *key,
    617                                                 sl_se_cipher_operation_t mode,
    618                                                 uint32_t total_message_length,
    619                                                 const uint8_t *iv,
    620                                                 size_t iv_len,
    621                                                 const uint8_t *aad,
    622                                                 size_t aad_len,
    623                                                 size_t tag_len)
    624          {
    625            sl_status_t status = SL_STATUS_OK;
    626            uint8_t q;
    627            uint8_t b[SL_SE_AES_BLOCK_SIZE] = { 0 };
    628            uint8_t tag_out[SL_SE_AES_BLOCK_SIZE] = { 0 };
    629            uint8_t cbc_mac_state[SL_SE_AES_BLOCK_SIZE] = { 0 };
    630            uint8_t nonce_counter[SL_SE_AES_BLOCK_SIZE] = { 0 };
    631            uint32_t len_left;
    632          
    633            //Check input parameters
    634            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL || iv == NULL) {
    635              return SL_STATUS_INVALID_PARAMETER;
    636            }
    637            if (aad_len > 0 && aad == NULL) {
    638              return SL_STATUS_INVALID_PARAMETER;
    639            }
    640          
    641            if (tag_len == 2 || tag_len > 16 || tag_len % 2 != 0) {
    642              return SL_STATUS_INVALID_PARAMETER;
    643            }
    644          
    645            if (iv_len < 7 || iv_len > 13) {
    646              return SL_STATUS_INVALID_PARAMETER;
    647            }
    648          
    649            // q is the the octet length of Q which again is a bit string representation of
    650            // the octet length of the payload.
    651            q = 16 - 1 - (uint8_t) iv_len;
    652          
    653            // The parameter q determines the maximum length of the payload: by definition, p<2^(8*q),
    654            // where p is payload.
    655            if ((q < sizeof(total_message_length)) && (total_message_length >= (1UL << (q * 8)))) {
    656              return SL_STATUS_INVALID_PARAMETER;
    657            }
    658            memset(ccm_ctx, 0, sizeof(sl_se_ccm_multipart_context_t));
    659          
    660            // Format first input block B_O according to the formatting function:
    661          
    662            // 0        .. 0        flags
    663            // 1        .. iv_len   nonce (aka iv)
    664            // iv_len+1 .. 15       length
    665            //
    666            // With flags as (bits):
    667            // 7        0
    668            // 6        add present?
    669            // 5 .. 3   (t - 2) / 2
    670            // 2 .. 0   q - 1
    671          
    672            b[0] = 0;
    673            b[0] |= (aad_len > 0) << 6;
    674            b[0] |= ((tag_len - 2) / 2) << 3;
    675            b[0] |= q - 1;
    676          
    677            memcpy(b + 1, iv, iv_len);
    678          
    679            len_left = total_message_length;
    680            for (uint32_t i = 0; i < q; i++, len_left >>= 8) {
    681              b[15 - i] = (unsigned char)(len_left & 0xFF);
    682            }
    683          
    684            ccm_ctx->mode = mode;
    685            ccm_ctx->processed_message_length = 0;
    686            ccm_ctx->total_message_length = total_message_length;
    687            ccm_ctx->tag_len = tag_len;
    688            ccm_ctx->mode = mode;
    689            ccm_ctx->iv_len = iv_len;
    690            memcpy(ccm_ctx->iv, iv, iv_len);
    691          
    692            status = sl_se_aes_crypt_cbc(cmd_ctx,
    693                                         key,
    694                                         SL_SE_ENCRYPT,
    695                                         SL_SE_AES_BLOCK_SIZE,
    696                                         cbc_mac_state,
    697                                         b,
    698                                         tag_out);
    699          
    700            if (status != SL_STATUS_OK) {
    701              return status;
    702            }
    703          
    704            // If there is additional data, update using CBC. Must be done
    705            // blockwise to achieve the same behaviour as CBC-MAC.
    706            if (aad_len > 0) {
    707              uint8_t use_len;
    708              len_left = aad_len;
    709              memset(b, 0, sizeof(b));
    710              // First block.
    711              b[0] = (unsigned char)((aad_len >> 8) & 0xFF);
    712              b[1] = (unsigned char)((aad_len) & 0xFF);
    713              use_len = len_left < SL_SE_AES_BLOCK_SIZE - 2 ? len_left : 16 - 2;
    714              memcpy(b + 2, aad, use_len);
    715              len_left -= use_len;
    716              aad += use_len;
    717          
    718              status = sl_se_aes_crypt_cbc(cmd_ctx,
    719                                           key,
    720                                           SL_SE_ENCRYPT,
    721                                           SL_SE_AES_BLOCK_SIZE,
    722                                           cbc_mac_state,
    723                                           b,
    724                                           tag_out);
    725              if (status != SL_STATUS_OK) {
    726                return status;
    727              }
    728          
    729              while (len_left) {
    730                use_len = len_left > 16 ? 16 : len_left;
    731          
    732                memset(b, 0, sizeof(b));
    733                memcpy(b, aad, use_len);
    734                status = sl_se_aes_crypt_cbc(cmd_ctx,
    735                                             key,
    736                                             SL_SE_ENCRYPT,
    737                                             SL_SE_AES_BLOCK_SIZE,
    738                                             cbc_mac_state,
    739                                             b,
    740                                             tag_out);
    741          
    742                if (status != SL_STATUS_OK) {
    743                  return status;
    744                }
    745                len_left -= use_len;
    746                aad += use_len;
    747              }
    748            }
    749          
    750            memcpy(ccm_ctx->cbc_mac_state, cbc_mac_state, sizeof(cbc_mac_state));
    751          
    752            // Prepare nonce counter for encryption/decryption operation.
    753            nonce_counter[0] = q - 1;
    754            memcpy(nonce_counter + 1, iv, iv_len);
    755            memset(nonce_counter + 1 + iv_len, 0, q);
    756            nonce_counter[15] = 1;
    757          
    758            memcpy(ccm_ctx->nonce_counter, nonce_counter, sizeof(ccm_ctx->nonce_counter));
    759          
    760            return SL_STATUS_OK;
    761          }
    762          
    763          sl_status_t sl_se_ccm_multipart_update(sl_se_ccm_multipart_context_t *ccm_ctx,
    764                                                 sl_se_command_context_t *cmd_ctx,
    765                                                 const sl_se_key_descriptor_t *key,
    766                                                 size_t length,
    767                                                 const uint8_t *input,
    768                                                 uint8_t *output,
    769                                                 size_t *output_length)
    770          {
    771            sl_status_t status = SL_STATUS_OK;
    772            *output_length = 0;
    773          
    774            uint8_t out_buf[SL_SE_AES_BLOCK_SIZE] = { 0 };
    775            uint8_t empty[SL_SE_AES_BLOCK_SIZE * SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED] = { 0 };
    776            uint8_t b[SL_SE_AES_BLOCK_SIZE] = { 0 };
    777          
    778            size_t len_left;
    779          
    780            // Check input parameters.
    781            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL) {
    782              return SL_STATUS_INVALID_PARAMETER;
    783            }
    784          
    785            if (length == 0) {
    786              return SL_STATUS_OK;
    787            }
    788          
    789            // Check variable overflow
    790            if (ccm_ctx->processed_message_length > 0xFFFFFFFF - length) {
    791              return SL_STATUS_INVALID_PARAMETER;
    792            }
    793          
    794            if (ccm_ctx->processed_message_length + length > ccm_ctx->total_message_length) {
    795              return SL_STATUS_INVALID_PARAMETER;
    796            }
    797          
    798            if (length > 0 && (input == NULL || output == NULL)) {
    799              return SL_STATUS_INVALID_PARAMETER;
    800            }
    801          
    802            if ((uint32_t)output + length > RAM_MEM_END) {
    803              return SL_STATUS_INVALID_PARAMETER;
    804            }
    805          
    806            // Support partial overlap.
    807            if ((output > input) && (output < (input + length))) {
    808              memmove(output, input, length);
    809              input = output;
    810            }
    811          
    812            if (length + ccm_ctx->final_data_length < SL_SE_AES_BLOCK_SIZE && length < SL_SE_AES_BLOCK_SIZE && ccm_ctx->processed_message_length + length != ccm_ctx->total_message_length ) {
    813              if (ccm_ctx->final_data_length > SL_SE_AES_BLOCK_SIZE) {
    814                // Context is not valid.
    815                return SL_STATUS_INVALID_PARAMETER;
    816              }
    817              memcpy(ccm_ctx->final_data + ccm_ctx->final_data_length, input, length);
    818              ccm_ctx->final_data_length += length;
    819              *output_length = 0;
    820              return SL_STATUS_OK;
    821            }
    822          
    823            len_left = length + ccm_ctx->final_data_length;
    824          
    825            // Authenticate and {en,de}crypt the message.
    826          
    827            // The only difference between encryption and decryption is
    828            // the respective order of authentication and {en,de}cryption.
    829            while (len_left > 0 ) {
    830              uint8_t use_len = len_left > SL_SE_AES_BLOCK_SIZE ? SL_SE_AES_BLOCK_SIZE : len_left;
    831          
    832              memset(b, 0, sizeof(b));
    833          
    834              // Process data stored in context first.
    835              if (ccm_ctx->final_data_length > 0) {
    836                if (ccm_ctx->final_data_length > SL_SE_AES_BLOCK_SIZE) {
    837                  // Context is not valid.
    838                  return SL_STATUS_INVALID_PARAMETER;
    839                }
    840                memcpy(b, ccm_ctx->final_data, ccm_ctx->final_data_length);
    841                memcpy(b + ccm_ctx->final_data_length, input, SL_SE_AES_BLOCK_SIZE - ccm_ctx->final_data_length);
    842                input += SL_SE_AES_BLOCK_SIZE - ccm_ctx->final_data_length;
    843                ccm_ctx->final_data_length = 0;
    844              } else {
    845                memcpy(b, input, use_len);
    846                input += use_len;
    847              }
    848              if (ccm_ctx->mode == SL_SE_ENCRYPT) {
    849                // Authenticate input.
    850                status = sl_se_aes_crypt_cbc(cmd_ctx,
    851                                             key,
    852                                             SL_SE_ENCRYPT,
    853                                             SL_SE_AES_BLOCK_SIZE,
    854                                             ccm_ctx->cbc_mac_state,
    855                                             b,
    856                                             out_buf);
    857          
    858                if (status != SL_STATUS_OK) {
    859                  return status;
    860                }
    861              }
    862              // Encrypt/decrypt data with CTR.
    863              status = sl_se_aes_crypt_ctr(cmd_ctx,
    864                                           key,
    865                                           use_len,
    866                                           NULL,
    867                                           ccm_ctx->nonce_counter,
    868                                           empty,
    869                                           b,
    870                                           output);
    871          
    872              if (ccm_ctx->mode == SL_SE_DECRYPT) {
    873                // Authenticate output.
    874                memset(b, 0, sizeof(b));
    875                memcpy(b, output, use_len);
    876                status = sl_se_aes_crypt_cbc(cmd_ctx,
    877                                             key,
    878                                             SL_SE_ENCRYPT,
    879                                             SL_SE_AES_BLOCK_SIZE,
    880                                             ccm_ctx->cbc_mac_state,
    881                                             b,
    882                                             out_buf);
    883          
    884                if (status != SL_STATUS_OK) {
    885                  return status;
    886                }
    887              }
    888              ccm_ctx->processed_message_length += use_len;
    889              *output_length += use_len;
    890              len_left -= use_len;
    891              output += use_len;
    892          
    893              if (len_left < SL_SE_AES_BLOCK_SIZE && ((ccm_ctx->processed_message_length + len_left) != ccm_ctx->total_message_length)) {
    894                memcpy(ccm_ctx->final_data, input, len_left);
    895                ccm_ctx->final_data_length = len_left;
    896                break;
    897              }
    898            }
    899          
    900            if (status != SL_STATUS_OK) {
    901              return status;
    902            }
    903          
    904            return SL_STATUS_OK;
    905          }
    906          
    907          sl_status_t sl_se_ccm_multipart_finish(sl_se_ccm_multipart_context_t *ccm_ctx,
    908                                                 sl_se_command_context_t *cmd_ctx,
    909                                                 const sl_se_key_descriptor_t *key,
    910                                                 uint8_t *tag,
    911                                                 uint8_t tag_size,
    912                                                 uint8_t *output,
    913                                                 uint8_t output_size,
    914                                                 uint8_t *output_length)
    915          {
    916            (void)output;
    917            uint8_t q;
    918            uint8_t ctr[SL_SE_AES_BLOCK_SIZE] = { 0 };
    919            uint8_t out_tag[SL_SE_AES_BLOCK_SIZE] = { 0 };
    920            //Check input parameters
    921            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL || tag == NULL) {
    922              return SL_STATUS_INVALID_PARAMETER;
    923            }
    924          
    925            if (tag_size < ccm_ctx->tag_len || output_size < ccm_ctx->final_data_length) {
    926              return SL_STATUS_INVALID_PARAMETER;
    927            }
    928          
    929            sl_status_t status = SL_STATUS_OK;
    930          
    931            // Reset CTR counter.
    932            q = 16 - 1 - (unsigned char) ccm_ctx->iv_len;
    933          
    934            ctr[0] = q - 1;
    935            memcpy(ctr + 1, ccm_ctx->iv, ccm_ctx->iv_len);
    936          
    937            // Encrypt the tag with CTR.
    938            uint8_t empty[SL_SE_AES_BLOCK_SIZE * SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED] = { 0 };
    939            status =  sl_se_aes_crypt_ctr(cmd_ctx,
    940                                          key,
    941                                          ccm_ctx->tag_len,
    942                                          NULL,
    943                                          ctr,
    944                                          empty,
    945                                          ccm_ctx->cbc_mac_state,
    946                                          out_tag);
    947          
    948            if (status != SL_STATUS_OK) {
    949              memset(out_tag, 0, sizeof(out_tag));
    950              return status;
    951            }
    952          
    953            if (ccm_ctx->mode == SL_SE_DECRYPT) {
    954              if (memcmp_time_cst(tag, out_tag, ccm_ctx->tag_len) != 0) {
    955                memset(tag, 0, ccm_ctx->tag_len);
    956                return SL_STATUS_INVALID_SIGNATURE;
    957              }
    958            } else {
    959              memcpy(tag, out_tag, ccm_ctx->tag_len);
    960            }
    961          
    962            *output_length = 0;
    963            return SL_STATUS_OK;
    964          }
    965          #endif // SLI_SE_MAJOR_VERSION_ONE
    966          
    967          #if defined(SLI_SE_MAJOR_VERSION_TWO)
    968          /***************************************************************************//**
    969           *   Prepare a CCM streaming command context object to be used in subsequent
    970           *   CCM streaming function calls.
    971           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    972          sl_status_t sl_se_ccm_multipart_starts(sl_se_ccm_multipart_context_t *ccm_ctx,
    973                                                 sl_se_command_context_t *cmd_ctx,
    974                                                 const sl_se_key_descriptor_t *key,
    975                                                 sl_se_cipher_operation_t mode,
    976                                                 uint32_t total_message_length,
    977                                                 const uint8_t *iv,
    978                                                 size_t iv_len,
    979                                                 const uint8_t *add,
    980                                                 size_t add_len,
    981                                                 size_t tag_len)
    982          
    983          {
   \                     sl_se_ccm_multipart_starts: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB0A7             SUB      SP,SP,#+156
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0xF8DD 0xB0D0      LDR      R11,[SP, #+208]
   \       0x10   0xF8DD 0x90DC      LDR      R9,[SP, #+220]
    984            sl_status_t status = SL_STATUS_OK;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9026             STR      R0,[SP, #+152]
    985            uint8_t q;
    986          
    987            //Check input parameters
    988            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL || iv == NULL) {
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD006             BEQ.N    ??sl_se_ccm_multipart_starts_0
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD004             BEQ.N    ??sl_se_ccm_multipart_starts_0
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xD002             BEQ.N    ??sl_se_ccm_multipart_starts_0
   \       0x24   0x9833             LDR      R0,[SP, #+204]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD101             BNE.N    ??sl_se_ccm_multipart_starts_1
    989              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_starts_0: (+1)
   \       0x2A   0x2021             MOVS     R0,#+33
   \       0x2C   0xE16C             B.N      ??sl_se_ccm_multipart_starts_2
    990            }
    991            if (add_len > 0 && add == NULL) {
   \                     ??sl_se_ccm_multipart_starts_1: (+1)
   \       0x2E   0x9836             LDR      R0,[SP, #+216]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD004             BEQ.N    ??sl_se_ccm_multipart_starts_3
   \       0x34   0x9835             LDR      R0,[SP, #+212]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD101             BNE.N    ??sl_se_ccm_multipart_starts_3
    992              return SL_STATUS_INVALID_PARAMETER;
   \       0x3A   0x2021             MOVS     R0,#+33
   \       0x3C   0xE164             B.N      ??sl_se_ccm_multipart_starts_2
    993            }
    994          
    995            if (tag_len == 2 || tag_len > 16 || tag_len % 2 != 0) {
   \                     ??sl_se_ccm_multipart_starts_3: (+1)
   \       0x3E   0xF1B9 0x0F02      CMP      R9,#+2
   \       0x42   0xD005             BEQ.N    ??sl_se_ccm_multipart_starts_4
   \       0x44   0xF1B9 0x0F11      CMP      R9,#+17
   \       0x48   0xD202             BCS.N    ??sl_se_ccm_multipart_starts_4
   \       0x4A   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \       0x4E   0xD501             BPL.N    ??sl_se_ccm_multipart_starts_5
    996              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_starts_4: (+1)
   \       0x50   0x2021             MOVS     R0,#+33
   \       0x52   0xE159             B.N      ??sl_se_ccm_multipart_starts_2
    997            }
    998          
    999            if (iv_len < 7 || iv_len > 13) {
   \                     ??sl_se_ccm_multipart_starts_5: (+1)
   \       0x54   0xF1BB 0x0F07      CMP      R11,#+7
   \       0x58   0xD302             BCC.N    ??sl_se_ccm_multipart_starts_6
   \       0x5A   0xF1BB 0x0F0E      CMP      R11,#+14
   \       0x5E   0xD301             BCC.N    ??sl_se_ccm_multipart_starts_7
   1000              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_starts_6: (+1)
   \       0x60   0x2021             MOVS     R0,#+33
   \       0x62   0xE151             B.N      ??sl_se_ccm_multipart_starts_2
   1001            }
   1002          
   1003            q = 16 - 1 - (unsigned char) iv_len;
   \                     ??sl_se_ccm_multipart_starts_7: (+1)
   \       0x64   0xF1DB 0x000F      RSBS     R0,R11,#+15
   \       0x68   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1004            if ((q < sizeof(ccm_ctx->total_message_length)) && (ccm_ctx->total_message_length >= (1UL << (q * 8)))) {
   \       0x6C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x70   0x2804             CMP      R0,#+4
   \       0x72   0xD20A             BCS.N    ??sl_se_ccm_multipart_starts_8
   \       0x74   0x6861             LDR      R1,[R4, #+4]
   \       0x76   0x2201             MOVS     R2,#+1
   \       0x78   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x7C   0xB2C0             UXTB     R0,R0
   \       0x7E   0x00C0             LSLS     R0,R0,#+3
   \       0x80   0x4082             LSLS     R2,R2,R0
   \       0x82   0x4291             CMP      R1,R2
   \       0x84   0xD301             BCC.N    ??sl_se_ccm_multipart_starts_8
   1005              return SL_STATUS_INVALID_PARAMETER;
   \       0x86   0x2021             MOVS     R0,#+33
   \       0x88   0xE13E             B.N      ??sl_se_ccm_multipart_starts_2
   1006            }
   1007          
   1008            memset(ccm_ctx, 0, sizeof(sl_se_ccm_multipart_context_t));
   \                     ??sl_se_ccm_multipart_starts_8: (+1)
   \       0x8A   0xF05F 0x0850      MOVS     R8,#+80
   \       0x8E   0x2700             MOVS     R7,#+0
   \       0x90   0x46A2             MOV      R10,R4
   \       0x92   0x003A             MOVS     R2,R7
   \       0x94   0x4641             MOV      R1,R8
   \       0x96   0x4650             MOV      R0,R10
   \       0x98   0x.... 0x....      BL       __aeabi_memset
   1009          
   1010            ccm_ctx->mode = mode;
   \       0x9C   0xF89D 0x00A0      LDRB     R0,[SP, #+160]
   \       0xA0   0x7720             STRB     R0,[R4, #+28]
   1011            ccm_ctx->processed_message_length = 0;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x6020             STR      R0,[R4, #+0]
   1012            ccm_ctx->total_message_length = total_message_length;
   \       0xA6   0x9832             LDR      R0,[SP, #+200]
   \       0xA8   0x6060             STR      R0,[R4, #+4]
   1013            ccm_ctx->tag_len = tag_len;
   \       0xAA   0xF8C4 0x9018      STR      R9,[R4, #+24]
   1014            memcpy(ccm_ctx->iv, iv, iv_len);
   \       0xAE   0xF8CD 0xB010      STR      R11,[SP, #+16]
   \       0xB2   0x9833             LDR      R0,[SP, #+204]
   \       0xB4   0x9003             STR      R0,[SP, #+12]
   \       0xB6   0xF114 0x0A08      ADDS     R10,R4,#+8
   \       0xBA   0x9A04             LDR      R2,[SP, #+16]
   \       0xBC   0x9903             LDR      R1,[SP, #+12]
   \       0xBE   0x4650             MOV      R0,R10
   \       0xC0   0x.... 0x....      BL       __aeabi_memcpy
   1015          
   1016            SE_Command_t *se_cmd = &cmd_ctx->command;
   \       0xC4   0x46AA             MOV      R10,R5
   1017          
   1018            if (total_message_length == 0) {
   \       0xC6   0x9832             LDR      R0,[SP, #+200]
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xF040 0x8085      BNE.W    ??sl_se_ccm_multipart_starts_9
   1019              // The first encryption precomputes the tag in the event there is no more data.
   1020              // For decryption, the pre-computed is compared to the input tag in
   1021              // sl_se_ccm_multipart_finish.
   1022              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \       0xCE   0xAF11             ADD      R7,SP,#+68
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \       0xD4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xD8   0xE887 0x000E      STM      R7,{R1-R3}
   \       0xDC   0x9833             LDR      R0,[SP, #+204]
   \       0xDE   0x9011             STR      R0,[SP, #+68]
   \       0xE0   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \       0xE4   0x9013             STR      R0,[SP, #+76]
   1023              SE_DataTransfer_t add_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \       0xE6   0xAB0E             ADD      R3,SP,#+56
   \       0xE8   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0xEC   0xE890 0x0086      LDM      R0,{R1,R2,R7}
   \       0xF0   0xE883 0x0086      STM      R3,{R1,R2,R7}
   \       0xF4   0x9835             LDR      R0,[SP, #+212]
   \       0xF6   0x900E             STR      R0,[SP, #+56]
   \       0xF8   0x9836             LDR      R0,[SP, #+216]
   \       0xFA   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \       0xFE   0x9010             STR      R0,[SP, #+64]
   1024              SE_DataTransfer_t tag_out = SE_DATATRANSFER_DEFAULT(ccm_ctx->mode_specific_buffer.tagbuf,
   1025                                                                  tag_len);
   \      0x100   0xAF0B             ADD      R7,SP,#+44
   \      0x102   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \      0x106   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x10A   0xE887 0x000E      STM      R7,{R1-R3}
   \      0x10E   0xF114 0x003D      ADDS     R0,R4,#+61
   \      0x112   0x900B             STR      R0,[SP, #+44]
   \      0x114   0xF059 0x5000      ORRS     R0,R9,#0x20000000
   \      0x118   0x900D             STR      R0,[SP, #+52]
   1026          
   1027              sli_se_command_init(cmd_ctx,
   1028                                  SLI_SE_COMMAND_AES_CCM_ENCRYPT
   1029                                  | SLI_SE_COMMAND_OPTION_CONTEXT_WHOLE);
   \      0x11A   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \      0x11E   0x6028             STR      R0,[R5, #+0]
   \      0x120   0x2000             MOVS     R0,#+0
   \      0x122   0x6068             STR      R0,[R5, #+4]
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0x60A8             STR      R0,[R5, #+8]
   \      0x128   0x2000             MOVS     R0,#+0
   \      0x12A   0x61E8             STR      R0,[R5, #+28]
   1030          
   1031              sli_add_key_parameters(cmd_ctx, key, status);
   \      0x12C   0xA902             ADD      R1,SP,#+8
   \      0x12E   0x0030             MOVS     R0,R6
   \      0x130   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x134   0x0007             MOVS     R7,R0
   \      0x136   0x2F00             CMP      R7,#+0
   \      0x138   0xD001             BEQ.N    ??sl_se_ccm_multipart_starts_10
   \      0x13A   0x0038             MOVS     R0,R7
   \      0x13C   0xE0E4             B.N      ??sl_se_ccm_multipart_starts_2
   \                     ??sl_se_ccm_multipart_starts_10: (+1)
   \      0x13E   0x9902             LDR      R1,[SP, #+8]
   \      0x140   0x0028             MOVS     R0,R5
   \      0x142   0x.... 0x....      BL       SE_addParameter
   1032              SE_addParameter(se_cmd, ((iv_len & 0xFFFF) << 16) | (tag_len & 0xFFFF));
   \      0x146   0x4649             MOV      R1,R9
   \      0x148   0xF36B 0x411F      BFI      R1,R11,#+16,#+16
   \      0x14C   0x4650             MOV      R0,R10
   \      0x14E   0x.... 0x....      BL       SE_addParameter
   1033              SE_addParameter(se_cmd, add_len);
   \      0x152   0x9936             LDR      R1,[SP, #+216]
   \      0x154   0x4650             MOV      R0,R10
   \      0x156   0x.... 0x....      BL       SE_addParameter
   1034              SE_addParameter(se_cmd, 0);
   \      0x15A   0x2100             MOVS     R1,#+0
   \      0x15C   0x4650             MOV      R0,R10
   \      0x15E   0x.... 0x....      BL       SE_addParameter
   1035          
   1036              // Add key metadata block to command
   1037              sli_add_key_metadata(cmd_ctx, key, status);
   \      0x162   0xA91D             ADD      R1,SP,#+116
   \      0x164   0x0030             MOVS     R0,R6
   \      0x166   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x16A   0x4680             MOV      R8,R0
   \      0x16C   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x170   0xD001             BEQ.N    ??sl_se_ccm_multipart_starts_11
   \      0x172   0x4640             MOV      R0,R8
   \      0x174   0xE0C8             B.N      ??sl_se_ccm_multipart_starts_2
   \                     ??sl_se_ccm_multipart_starts_11: (+1)
   \      0x176   0xA91D             ADD      R1,SP,#+116
   \      0x178   0x0028             MOVS     R0,R5
   \      0x17A   0x.... 0x....      BL       SE_addDataInput
   1038              // Add key input block to command
   1039              sli_add_key_input(cmd_ctx, key, status);
   \      0x17E   0xA91A             ADD      R1,SP,#+104
   \      0x180   0x0030             MOVS     R0,R6
   \      0x182   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x186   0x0007             MOVS     R7,R0
   \      0x188   0x2F00             CMP      R7,#+0
   \      0x18A   0xD001             BEQ.N    ??sl_se_ccm_multipart_starts_12
   \      0x18C   0x0038             MOVS     R0,R7
   \      0x18E   0xE0BB             B.N      ??sl_se_ccm_multipart_starts_2
   \                     ??sl_se_ccm_multipart_starts_12: (+1)
   \      0x190   0xA91A             ADD      R1,SP,#+104
   \      0x192   0x0028             MOVS     R0,R5
   \      0x194   0x.... 0x....      BL       SE_addDataInput
   1040          
   1041              SE_addDataInput(se_cmd, &iv_in);
   \      0x198   0xA911             ADD      R1,SP,#+68
   \      0x19A   0x4650             MOV      R0,R10
   \      0x19C   0x.... 0x....      BL       SE_addDataInput
   1042              SE_addDataInput(se_cmd, &add_in);
   \      0x1A0   0xA90E             ADD      R1,SP,#+56
   \      0x1A2   0x4650             MOV      R0,R10
   \      0x1A4   0x.... 0x....      BL       SE_addDataInput
   1043          
   1044              SE_addDataOutput(se_cmd, &tag_out);
   \      0x1A8   0xA90B             ADD      R1,SP,#+44
   \      0x1AA   0x4650             MOV      R0,R10
   \      0x1AC   0x.... 0x....      BL       SE_addDataOutput
   1045          
   1046              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x1B0   0x0028             MOVS     R0,R5
   \      0x1B2   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x1B6   0x4680             MOV      R8,R0
   1047              if (status != SL_STATUS_OK) {
   \      0x1B8   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x1BC   0xD00A             BEQ.N    ??sl_se_ccm_multipart_starts_13
   1048                memset(ccm_ctx->mode_specific_buffer.tagbuf, 0, sizeof(ccm_ctx->mode_specific_buffer.tagbuf));
   \      0x1BE   0x2010             MOVS     R0,#+16
   \      0x1C0   0x9004             STR      R0,[SP, #+16]
   \      0x1C2   0x2000             MOVS     R0,#+0
   \      0x1C4   0x9003             STR      R0,[SP, #+12]
   \      0x1C6   0xF114 0x073D      ADDS     R7,R4,#+61
   \      0x1CA   0x9A03             LDR      R2,[SP, #+12]
   \      0x1CC   0x9904             LDR      R1,[SP, #+16]
   \      0x1CE   0x0038             MOVS     R0,R7
   \      0x1D0   0x.... 0x....      BL       __aeabi_memset
   1049              }
   1050              return status;
   \                     ??sl_se_ccm_multipart_starts_13: (+1)
   \      0x1D4   0x4640             MOV      R0,R8
   \      0x1D6   0xE097             B.N      ??sl_se_ccm_multipart_starts_2
   1051            }
   1052            SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \                     ??sl_se_ccm_multipart_starts_9: (+1)
   \      0x1D8   0xAF08             ADD      R7,SP,#+32
   \      0x1DA   0x.... 0x....      LDR.W    R0,??DataTable12
   \      0x1DE   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x1E2   0xE887 0x000E      STM      R7,{R1-R3}
   \      0x1E6   0x9833             LDR      R0,[SP, #+204]
   \      0x1E8   0x9008             STR      R0,[SP, #+32]
   \      0x1EA   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \      0x1EE   0x900A             STR      R0,[SP, #+40]
   1053            SE_DataTransfer_t add_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \      0x1F0   0xAF05             ADD      R7,SP,#+20
   \      0x1F2   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \      0x1F6   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x1FA   0xE887 0x000E      STM      R7,{R1-R3}
   \      0x1FE   0x9835             LDR      R0,[SP, #+212]
   \      0x200   0x9005             STR      R0,[SP, #+20]
   \      0x202   0x9836             LDR      R0,[SP, #+216]
   \      0x204   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x208   0x9007             STR      R0,[SP, #+28]
   1054            SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \      0x20A   0xAF17             ADD      R7,SP,#+92
   \      0x20C   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \      0x210   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x214   0xE887 0x000E      STM      R7,{R1-R3}
   \      0x218   0xF114 0x001D      ADDS     R0,R4,#+29
   \      0x21C   0x9017             STR      R0,[SP, #+92]
   1055          
   1056            SE_DataTransfer_t message_length_in = SE_DATATRANSFER_DEFAULT(&total_message_length, sizeof(uint32_t));
   \      0x21E   0xAB14             ADD      R3,SP,#+80
   \      0x220   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \      0x224   0xE890 0x0086      LDM      R0,{R1,R2,R7}
   \      0x228   0xE883 0x0086      STM      R3,{R1,R2,R7}
   \      0x22C   0xA832             ADD      R0,SP,#+200
   \      0x22E   0x9014             STR      R0,[SP, #+80]
   1057          
   1058            sli_se_command_init(cmd_ctx,
   1059                                ((ccm_ctx->mode == SL_SE_DECRYPT)
   1060                                 ? SLI_SE_COMMAND_AES_CCM_DECRYPT : SLI_SE_COMMAND_AES_CCM_ENCRYPT)
   1061                                | SLI_SE_COMMAND_OPTION_CONTEXT_START);
   \      0x230   0x7F20             LDRB     R0,[R4, #+28]
   \      0x232   0x2801             CMP      R0,#+1
   \      0x234   0xD102             BNE.N    ??sl_se_ccm_multipart_starts_14
   \      0x236   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \      0x23A   0xE001             B.N      ??sl_se_ccm_multipart_starts_15
   \                     ??sl_se_ccm_multipart_starts_14: (+1)
   \      0x23C   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \                     ??sl_se_ccm_multipart_starts_15: (+1)
   \      0x240   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x244   0x6028             STR      R0,[R5, #+0]
   \      0x246   0x2000             MOVS     R0,#+0
   \      0x248   0x6068             STR      R0,[R5, #+4]
   \      0x24A   0x2000             MOVS     R0,#+0
   \      0x24C   0x60A8             STR      R0,[R5, #+8]
   \      0x24E   0x2000             MOVS     R0,#+0
   \      0x250   0x61E8             STR      R0,[R5, #+28]
   1062          
   1063            sli_add_key_parameters(cmd_ctx, key, status);
   \      0x252   0xA901             ADD      R1,SP,#+4
   \      0x254   0x0030             MOVS     R0,R6
   \      0x256   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x25A   0x0007             MOVS     R7,R0
   \      0x25C   0x2F00             CMP      R7,#+0
   \      0x25E   0xD001             BEQ.N    ??sl_se_ccm_multipart_starts_16
   \      0x260   0x0038             MOVS     R0,R7
   \      0x262   0xE051             B.N      ??sl_se_ccm_multipart_starts_2
   \                     ??sl_se_ccm_multipart_starts_16: (+1)
   \      0x264   0x9901             LDR      R1,[SP, #+4]
   \      0x266   0x0028             MOVS     R0,R5
   \      0x268   0x.... 0x....      BL       SE_addParameter
   1064          
   1065            SE_addParameter(se_cmd, ((iv_len & 0xFFFF) << 16) | (tag_len & 0xFFFF));
   \      0x26C   0x4649             MOV      R1,R9
   \      0x26E   0xF36B 0x411F      BFI      R1,R11,#+16,#+16
   \      0x272   0x4650             MOV      R0,R10
   \      0x274   0x.... 0x....      BL       SE_addParameter
   1066            SE_addParameter(se_cmd, add_len);
   \      0x278   0x9936             LDR      R1,[SP, #+216]
   \      0x27A   0x4650             MOV      R0,R10
   \      0x27C   0x.... 0x....      BL       SE_addParameter
   1067            SE_addParameter(se_cmd, 0);
   \      0x280   0x2100             MOVS     R1,#+0
   \      0x282   0x4650             MOV      R0,R10
   \      0x284   0x.... 0x....      BL       SE_addParameter
   1068          
   1069            sli_add_key_metadata(cmd_ctx, key, status);
   \      0x288   0xA923             ADD      R1,SP,#+140
   \      0x28A   0x0030             MOVS     R0,R6
   \      0x28C   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x290   0x4680             MOV      R8,R0
   \      0x292   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x296   0xD001             BEQ.N    ??sl_se_ccm_multipart_starts_17
   \      0x298   0x4640             MOV      R0,R8
   \      0x29A   0xE035             B.N      ??sl_se_ccm_multipart_starts_2
   \                     ??sl_se_ccm_multipart_starts_17: (+1)
   \      0x29C   0xA923             ADD      R1,SP,#+140
   \      0x29E   0x0028             MOVS     R0,R5
   \      0x2A0   0x.... 0x....      BL       SE_addDataInput
   1070            sli_add_key_input(cmd_ctx, key, status);
   \      0x2A4   0xA920             ADD      R1,SP,#+128
   \      0x2A6   0x0030             MOVS     R0,R6
   \      0x2A8   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x2AC   0x0007             MOVS     R7,R0
   \      0x2AE   0x2F00             CMP      R7,#+0
   \      0x2B0   0xD001             BEQ.N    ??sl_se_ccm_multipart_starts_18
   \      0x2B2   0x0038             MOVS     R0,R7
   \      0x2B4   0xE028             B.N      ??sl_se_ccm_multipart_starts_2
   \                     ??sl_se_ccm_multipart_starts_18: (+1)
   \      0x2B6   0xA920             ADD      R1,SP,#+128
   \      0x2B8   0x0028             MOVS     R0,R5
   \      0x2BA   0x.... 0x....      BL       SE_addDataInput
   1071          
   1072            SE_addDataInput(se_cmd, &message_length_in);
   \      0x2BE   0xA914             ADD      R1,SP,#+80
   \      0x2C0   0x4650             MOV      R0,R10
   \      0x2C2   0x.... 0x....      BL       SE_addDataInput
   1073          
   1074            SE_addDataInput(se_cmd, &iv_in);
   \      0x2C6   0xA908             ADD      R1,SP,#+32
   \      0x2C8   0x4650             MOV      R0,R10
   \      0x2CA   0x.... 0x....      BL       SE_addDataInput
   1075            SE_addDataInput(se_cmd, &add_in);
   \      0x2CE   0xA905             ADD      R1,SP,#+20
   \      0x2D0   0x4650             MOV      R0,R10
   \      0x2D2   0x.... 0x....      BL       SE_addDataInput
   1076            SE_addDataOutput(se_cmd, &ctx_out);
   \      0x2D6   0xA917             ADD      R1,SP,#+92
   \      0x2D8   0x4650             MOV      R0,R10
   \      0x2DA   0x.... 0x....      BL       SE_addDataOutput
   1077          
   1078            status = sli_se_execute_and_wait(cmd_ctx);
   \      0x2DE   0x0028             MOVS     R0,R5
   \      0x2E0   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x2E4   0x4680             MOV      R8,R0
   1079            if (status != SL_STATUS_OK) {
   \      0x2E6   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x2EA   0xD00C             BEQ.N    ??sl_se_ccm_multipart_starts_19
   1080              memset(ccm_ctx->se_ctx, 0, sizeof(ccm_ctx->se_ctx));
   \      0x2EC   0x2020             MOVS     R0,#+32
   \      0x2EE   0x9004             STR      R0,[SP, #+16]
   \      0x2F0   0x2000             MOVS     R0,#+0
   \      0x2F2   0x9003             STR      R0,[SP, #+12]
   \      0x2F4   0xF114 0x071D      ADDS     R7,R4,#+29
   \      0x2F8   0x9A03             LDR      R2,[SP, #+12]
   \      0x2FA   0x9904             LDR      R1,[SP, #+16]
   \      0x2FC   0x0038             MOVS     R0,R7
   \      0x2FE   0x.... 0x....      BL       __aeabi_memset
   1081              return status;
   \      0x302   0x4640             MOV      R0,R8
   \      0x304   0xE000             B.N      ??sl_se_ccm_multipart_starts_2
   1082            }
   1083          
   1084            return status;
   \                     ??sl_se_ccm_multipart_starts_19: (+1)
   \      0x306   0x4640             MOV      R0,R8
   \                     ??sl_se_ccm_multipart_starts_2: (+1)
   \      0x308   0xB029             ADD      SP,SP,#+164
   \      0x30A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1085          }

   \                                 In section .rodata, align 4
   \                     ?_24:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_25:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_26:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_27:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_28:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_29:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_30:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
   1086          #endif
   1087          
   1088          /***************************************************************************//**
   1089           *   This function feeds an input buffer into an ongoing CCM computation.
   1090           *   It is called between sl_se_ccm_multipart_starts() and sl_se_ccm_multipart_finish().
   1091           *   Can be called repeatedly.
   1092           ******************************************************************************/
   1093          #if defined(SLI_SE_MAJOR_VERSION_TWO)

   \                                 In section .text, align 2, keep-with-next
   1094          sl_status_t sl_se_ccm_multipart_update(sl_se_ccm_multipart_context_t *ccm_ctx,
   1095                                                 sl_se_command_context_t *cmd_ctx,
   1096                                                 const sl_se_key_descriptor_t *key,
   1097                                                 size_t length,
   1098                                                 const uint8_t *input,
   1099                                                 uint8_t *output,
   1100                                                 size_t *output_length)
   1101          {
   \                     sl_se_ccm_multipart_update: (+1)
   \        0x0   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \        0x4   0xB0AA             SUB      SP,SP,#+168
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9F34             LDR      R7,[SP, #+208]
   \        0xE   0xF8DD 0x80D4      LDR      R8,[SP, #+212]
   1102            sl_status_t status = SL_STATUS_OK;
   \       0x12   0xF05F 0x0900      MOVS     R9,#+0
   1103          
   1104            // Check input parameters.
   1105            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL) {
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD004             BEQ.N    ??sl_se_ccm_multipart_update_0
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD002             BEQ.N    ??sl_se_ccm_multipart_update_0
   \       0x1E   0x982A             LDR      R0,[SP, #+168]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??sl_se_ccm_multipart_update_1
   1106              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_update_0: (+1)
   \       0x24   0x2021             MOVS     R0,#+33
   \       0x26   0xE204             B.N      ??sl_se_ccm_multipart_update_2
   1107            }
   1108          
   1109            if (length == 0) {
   \                     ??sl_se_ccm_multipart_update_1: (+1)
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD101             BNE.N    ??sl_se_ccm_multipart_update_3
   1110              return SL_STATUS_OK;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xE200             B.N      ??sl_se_ccm_multipart_update_2
   1111            }
   1112          
   1113            if (ccm_ctx->processed_message_length + length > ccm_ctx->total_message_length) {
   \                     ??sl_se_ccm_multipart_update_3: (+1)
   \       0x30   0x6869             LDR      R1,[R5, #+4]
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x1820             ADDS     R0,R4,R0
   \       0x36   0x4281             CMP      R1,R0
   \       0x38   0xD201             BCS.N    ??sl_se_ccm_multipart_update_4
   1114              return SL_STATUS_INVALID_PARAMETER;
   \       0x3A   0x2021             MOVS     R0,#+33
   \       0x3C   0xE1F9             B.N      ??sl_se_ccm_multipart_update_2
   1115            }
   1116          
   1117            // Check variable overflow
   1118            if (ccm_ctx->processed_message_length > 0xFFFFFFFF - length) {
   \                     ??sl_se_ccm_multipart_update_4: (+1)
   \       0x3E   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x42   0x1B09             SUBS     R1,R1,R4
   \       0x44   0x6828             LDR      R0,[R5, #+0]
   \       0x46   0x4281             CMP      R1,R0
   \       0x48   0xD201             BCS.N    ??sl_se_ccm_multipart_update_5
   1119              return SL_STATUS_INVALID_PARAMETER;
   \       0x4A   0x2021             MOVS     R0,#+33
   \       0x4C   0xE1F1             B.N      ??sl_se_ccm_multipart_update_2
   1120            }
   1121          
   1122            if (length > 0 && (input == NULL || output == NULL)) {
   \                     ??sl_se_ccm_multipart_update_5: (+1)
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xD006             BEQ.N    ??sl_se_ccm_multipart_update_6
   \       0x52   0x2F00             CMP      R7,#+0
   \       0x54   0xD002             BEQ.N    ??sl_se_ccm_multipart_update_7
   \       0x56   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x5A   0xD101             BNE.N    ??sl_se_ccm_multipart_update_6
   1123              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_update_7: (+1)
   \       0x5C   0x2021             MOVS     R0,#+33
   \       0x5E   0xE1E8             B.N      ??sl_se_ccm_multipart_update_2
   1124            }
   1125          
   1126          #if !defined(SLI_SE_MANAGER_HOST_SYSTEM)
   1127            if ((uint32_t)output + length > RAM_MEM_END) {
   \                     ??sl_se_ccm_multipart_update_6: (+1)
   \       0x60   0xEB14 0x0108      ADDS     R1,R4,R8
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \       0x68   0x4281             CMP      R1,R0
   \       0x6A   0xD301             BCC.N    ??sl_se_ccm_multipart_update_8
   1128              return SL_STATUS_INVALID_PARAMETER;
   \       0x6C   0x2021             MOVS     R0,#+33
   \       0x6E   0xE1E0             B.N      ??sl_se_ccm_multipart_update_2
   1129            }
   1130          #endif // SLI_SE_MANAGER_HOST_SYSTEM
   1131          
   1132            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_ccm_multipart_update_8: (+1)
   \       0x70   0x9600             STR      R6,[SP, #+0]
   1133            *output_length = 0;
   \       0x72   0x2100             MOVS     R1,#+0
   \       0x74   0x9836             LDR      R0,[SP, #+216]
   \       0x76   0x6001             STR      R1,[R0, #+0]
   1134          
   1135            // Approach:
   1136            // Encrypt or decrypt regularly with context store. The crypto DMA must have input data in the 'END' operation, thus,
   1137            // some data must be saved in the context.
   1138          
   1139            if ((ccm_ctx->final_data_length + length) < 16 && length < 16) {
   \       0x78   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \       0x7C   0x1820             ADDS     R0,R4,R0
   \       0x7E   0x2810             CMP      R0,#+16
   \       0x80   0xD21A             BCS.N    ??sl_se_ccm_multipart_update_9
   \       0x82   0x2C10             CMP      R4,#+16
   \       0x84   0xD218             BCS.N    ??sl_se_ccm_multipart_update_9
   1140              if (ccm_ctx->final_data_length > 16) {
   \       0x86   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \       0x8A   0x2811             CMP      R0,#+17
   \       0x8C   0xDB01             BLT.N    ??sl_se_ccm_multipart_update_10
   1141                // Context is not valid.
   1142                return SL_STATUS_INVALID_PARAMETER;
   \       0x8E   0x2021             MOVS     R0,#+33
   \       0x90   0xE1CF             B.N      ??sl_se_ccm_multipart_update_2
   1143              }
   1144          
   1145              memcpy(ccm_ctx->mode_specific_buffer.final_data + ccm_ctx->final_data_length, input, length);
   \                     ??sl_se_ccm_multipart_update_10: (+1)
   \       0x92   0x9403             STR      R4,[SP, #+12]
   \       0x94   0x46BB             MOV      R11,R7
   \       0x96   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \       0x9A   0x4428             ADD      R0,R5,R0
   \       0x9C   0xF110 0x0A3D      ADDS     R10,R0,#+61
   \       0xA0   0x9A03             LDR      R2,[SP, #+12]
   \       0xA2   0x4659             MOV      R1,R11
   \       0xA4   0x4650             MOV      R0,R10
   \       0xA6   0x.... 0x....      BL       __aeabi_memcpy
   1146              ccm_ctx->final_data_length += length;
   \       0xAA   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \       0xAE   0x1820             ADDS     R0,R4,R0
   \       0xB0   0xF885 0x004D      STRB     R0,[R5, #+77]
   1147              return SL_STATUS_OK;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0xE1BC             B.N      ??sl_se_ccm_multipart_update_2
   1148            }
   1149          
   1150            // If there is data in final_data, this must be processed first
   1151            if (ccm_ctx->final_data_length) {
   \                     ??sl_se_ccm_multipart_update_9: (+1)
   \       0xB8   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xF000 0x80CE      BEQ.W    ??sl_se_ccm_multipart_update_11
   1152              if (ccm_ctx->final_data_length > 16) {
   \       0xC2   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \       0xC6   0x2811             CMP      R0,#+17
   \       0xC8   0xDB01             BLT.N    ??sl_se_ccm_multipart_update_12
   1153                // Context is not valid.
   1154                return SL_STATUS_INVALID_PARAMETER;
   \       0xCA   0x2021             MOVS     R0,#+33
   \       0xCC   0xE1B1             B.N      ??sl_se_ccm_multipart_update_2
   1155              }
   1156          
   1157              // Fill up the remainder of the buffer.
   1158              memcpy(ccm_ctx->mode_specific_buffer.final_data + ccm_ctx->final_data_length, input, 16 - ccm_ctx->final_data_length);
   \                     ??sl_se_ccm_multipart_update_12: (+1)
   \       0xCE   0xF895 0xA04D      LDRB     R10,[R5, #+77]
   \       0xD2   0xF1DA 0x0A10      RSBS     R10,R10,#+16
   \       0xD6   0x9703             STR      R7,[SP, #+12]
   \       0xD8   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \       0xDC   0x4428             ADD      R0,R5,R0
   \       0xDE   0xF110 0x0B3D      ADDS     R11,R0,#+61
   \       0xE2   0x4652             MOV      R2,R10
   \       0xE4   0x9903             LDR      R1,[SP, #+12]
   \       0xE6   0x4658             MOV      R0,R11
   \       0xE8   0x.... 0x....      BL       __aeabi_memcpy
   1159          
   1160              if (ccm_ctx->processed_message_length + 16 == ccm_ctx->total_message_length ) {
   \       0xEC   0x6829             LDR      R1,[R5, #+0]
   \       0xEE   0x3110             ADDS     R1,R1,#+16
   \       0xF0   0x6868             LDR      R0,[R5, #+4]
   \       0xF2   0x4281             CMP      R1,R0
   \       0xF4   0xD104             BNE.N    ??sl_se_ccm_multipart_update_13
   1161                // The finish operation must have some data or the SE fails.
   1162                ccm_ctx->final_data_length = 16;
   \       0xF6   0x2010             MOVS     R0,#+16
   \       0xF8   0xF885 0x004D      STRB     R0,[R5, #+77]
   1163                return SL_STATUS_OK;
   \       0xFC   0x2000             MOVS     R0,#+0
   \       0xFE   0xE198             B.N      ??sl_se_ccm_multipart_update_2
   1164              }
   1165          
   1166              SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \                     ??sl_se_ccm_multipart_update_13: (+1)
   \      0x100   0xF10D 0x0C6C      ADD      R12,SP,#+108
   \      0x104   0x.... 0x....      LDR.W    R0,??DataTable13
   \      0x108   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x10C   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x110   0xF115 0x001D      ADDS     R0,R5,#+29
   \      0x114   0x901B             STR      R0,[SP, #+108]
   1167          
   1168              SE_DataTransfer_t data_in =
   1169                SE_DATATRANSFER_DEFAULT(ccm_ctx->mode_specific_buffer.final_data, 16);
   \      0x116   0xAB18             ADD      R3,SP,#+96
   \      0x118   0x.... 0x....      LDR.W    R12,??DataTable13_1
   \      0x11C   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x120   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x124   0xF115 0x003D      ADDS     R0,R5,#+61
   \      0x128   0x9018             STR      R0,[SP, #+96]
   1170              SE_DataTransfer_t data_out =
   1171                SE_DATATRANSFER_DEFAULT(output, 16);
   \      0x12A   0xF10D 0x0C54      ADD      R12,SP,#+84
   \      0x12E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \      0x132   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x136   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x13A   0xF8CD 0x8054      STR      R8,[SP, #+84]
   1172          
   1173              SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \      0x13E   0xAB12             ADD      R3,SP,#+72
   \      0x140   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \      0x144   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x148   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x14C   0xF115 0x001D      ADDS     R0,R5,#+29
   \      0x150   0x9012             STR      R0,[SP, #+72]
   1174          
   1175              sli_se_command_init(cmd_ctx,
   1176                                  ((ccm_ctx->mode == SL_SE_DECRYPT)
   1177                                   ? SLI_SE_COMMAND_AES_CCM_DECRYPT : SLI_SE_COMMAND_AES_CCM_ENCRYPT)
   1178                                  | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \      0x152   0x7F28             LDRB     R0,[R5, #+28]
   \      0x154   0x2801             CMP      R0,#+1
   \      0x156   0xD102             BNE.N    ??sl_se_ccm_multipart_update_14
   \      0x158   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \      0x15C   0xE000             B.N      ??sl_se_ccm_multipart_update_15
   \                     ??sl_se_ccm_multipart_update_14: (+1)
   \      0x15E   0x....             LDR.N    R0,??DataTable8_3
   \                     ??sl_se_ccm_multipart_update_15: (+1)
   \      0x160   0xF050 0x0003      ORRS     R0,R0,#0x3
   \      0x164   0x6030             STR      R0,[R6, #+0]
   \      0x166   0x2000             MOVS     R0,#+0
   \      0x168   0x6070             STR      R0,[R6, #+4]
   \      0x16A   0x2000             MOVS     R0,#+0
   \      0x16C   0x60B0             STR      R0,[R6, #+8]
   \      0x16E   0x2000             MOVS     R0,#+0
   \      0x170   0x61F0             STR      R0,[R6, #+28]
   1179          
   1180              sli_add_key_parameters(cmd_ctx, key, status);
   \      0x172   0xA902             ADD      R1,SP,#+8
   \      0x174   0x982A             LDR      R0,[SP, #+168]
   \      0x176   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x17A   0x4682             MOV      R10,R0
   \      0x17C   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x180   0xD001             BEQ.N    ??sl_se_ccm_multipart_update_16
   \      0x182   0x4650             MOV      R0,R10
   \      0x184   0xE155             B.N      ??sl_se_ccm_multipart_update_2
   \                     ??sl_se_ccm_multipart_update_16: (+1)
   \      0x186   0x9902             LDR      R1,[SP, #+8]
   \      0x188   0x0030             MOVS     R0,R6
   \      0x18A   0x.... 0x....      BL       SE_addParameter
   1181          
   1182              SE_addParameter(se_cmd, 16);
   \      0x18E   0x2110             MOVS     R1,#+16
   \      0x190   0x9800             LDR      R0,[SP, #+0]
   \      0x192   0x.... 0x....      BL       SE_addParameter
   1183          
   1184              sli_add_key_metadata(cmd_ctx, key, status);
   \      0x196   0xA921             ADD      R1,SP,#+132
   \      0x198   0x982A             LDR      R0,[SP, #+168]
   \      0x19A   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x19E   0x4681             MOV      R9,R0
   \      0x1A0   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x1A4   0xD001             BEQ.N    ??sl_se_ccm_multipart_update_17
   \      0x1A6   0x4648             MOV      R0,R9
   \      0x1A8   0xE143             B.N      ??sl_se_ccm_multipart_update_2
   \                     ??sl_se_ccm_multipart_update_17: (+1)
   \      0x1AA   0xA921             ADD      R1,SP,#+132
   \      0x1AC   0x0030             MOVS     R0,R6
   \      0x1AE   0x.... 0x....      BL       SE_addDataInput
   1185              sli_add_key_input(cmd_ctx, key, status);
   \      0x1B2   0xA91E             ADD      R1,SP,#+120
   \      0x1B4   0x982A             LDR      R0,[SP, #+168]
   \      0x1B6   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x1BA   0x4682             MOV      R10,R0
   \      0x1BC   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x1C0   0xD001             BEQ.N    ??sl_se_ccm_multipart_update_18
   \      0x1C2   0x4650             MOV      R0,R10
   \      0x1C4   0xE135             B.N      ??sl_se_ccm_multipart_update_2
   \                     ??sl_se_ccm_multipart_update_18: (+1)
   \      0x1C6   0xA91E             ADD      R1,SP,#+120
   \      0x1C8   0x0030             MOVS     R0,R6
   \      0x1CA   0x.... 0x....      BL       SE_addDataInput
   1186          
   1187              SE_addDataInput(se_cmd, &iv_ctx_in);
   \      0x1CE   0xA91B             ADD      R1,SP,#+108
   \      0x1D0   0x9800             LDR      R0,[SP, #+0]
   \      0x1D2   0x.... 0x....      BL       SE_addDataInput
   1188              SE_addDataInput(se_cmd, &data_in);
   \      0x1D6   0xA918             ADD      R1,SP,#+96
   \      0x1D8   0x9800             LDR      R0,[SP, #+0]
   \      0x1DA   0x.... 0x....      BL       SE_addDataInput
   1189          
   1190              SE_addDataOutput(se_cmd, &data_out);
   \      0x1DE   0xA915             ADD      R1,SP,#+84
   \      0x1E0   0x9800             LDR      R0,[SP, #+0]
   \      0x1E2   0x.... 0x....      BL       SE_addDataOutput
   1191              SE_addDataOutput(se_cmd, &ctx_out);
   \      0x1E6   0xA912             ADD      R1,SP,#+72
   \      0x1E8   0x9800             LDR      R0,[SP, #+0]
   \      0x1EA   0x.... 0x....      BL       SE_addDataOutput
   1192          
   1193              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x1EE   0x0030             MOVS     R0,R6
   \      0x1F0   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x1F4   0x4681             MOV      R9,R0
   1194              if (status != SL_STATUS_OK) {
   \      0x1F6   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x1FA   0xD018             BEQ.N    ??sl_se_ccm_multipart_update_19
   1195                memset(output, 0, length);
   \      0x1FC   0x9405             STR      R4,[SP, #+20]
   \      0x1FE   0x2000             MOVS     R0,#+0
   \      0x200   0x9004             STR      R0,[SP, #+16]
   \      0x202   0x46C2             MOV      R10,R8
   \      0x204   0x9A04             LDR      R2,[SP, #+16]
   \      0x206   0x9905             LDR      R1,[SP, #+20]
   \      0x208   0x4650             MOV      R0,R10
   \      0x20A   0x.... 0x....      BL       __aeabi_memset
   1196                memset(ccm_ctx->se_ctx, 0, sizeof(ccm_ctx->se_ctx));
   \      0x20E   0x2020             MOVS     R0,#+32
   \      0x210   0x9003             STR      R0,[SP, #+12]
   \      0x212   0xF05F 0x0B00      MOVS     R11,#+0
   \      0x216   0xF115 0x0A1D      ADDS     R10,R5,#+29
   \      0x21A   0x465A             MOV      R2,R11
   \      0x21C   0x9903             LDR      R1,[SP, #+12]
   \      0x21E   0x4650             MOV      R0,R10
   \      0x220   0x.... 0x....      BL       __aeabi_memset
   1197                *output_length = 0;
   \      0x224   0x2000             MOVS     R0,#+0
   \      0x226   0x9936             LDR      R1,[SP, #+216]
   \      0x228   0x6008             STR      R0,[R1, #+0]
   1198                return status;
   \      0x22A   0x4648             MOV      R0,R9
   \      0x22C   0xE101             B.N      ??sl_se_ccm_multipart_update_2
   1199              }
   1200              ccm_ctx->processed_message_length += 16;
   \                     ??sl_se_ccm_multipart_update_19: (+1)
   \      0x22E   0x6828             LDR      R0,[R5, #+0]
   \      0x230   0x3010             ADDS     R0,R0,#+16
   \      0x232   0x6028             STR      R0,[R5, #+0]
   1201              output += 16;
   \      0x234   0xF118 0x0810      ADDS     R8,R8,#+16
   1202              length -= (16 - ccm_ctx->final_data_length);
   \      0x238   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \      0x23C   0xF1D0 0x0010      RSBS     R0,R0,#+16
   \      0x240   0x1A24             SUBS     R4,R4,R0
   1203              input += (16 - ccm_ctx->final_data_length);
   \      0x242   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \      0x246   0x4240             RSBS     R0,R0,#+0
   \      0x248   0x4438             ADD      R0,R7,R0
   \      0x24A   0xF110 0x0710      ADDS     R7,R0,#+16
   1204              ccm_ctx->final_data_length = 0;
   \      0x24E   0x2000             MOVS     R0,#+0
   \      0x250   0xF885 0x004D      STRB     R0,[R5, #+77]
   1205              *output_length += 16;
   \      0x254   0x9836             LDR      R0,[SP, #+216]
   \      0x256   0x6800             LDR      R0,[R0, #+0]
   \      0x258   0x3010             ADDS     R0,R0,#+16
   \      0x25A   0x9936             LDR      R1,[SP, #+216]
   \      0x25C   0x6008             STR      R0,[R1, #+0]
   1206            }
   1207          
   1208            if (length < 16) {
   \                     ??sl_se_ccm_multipart_update_11: (+1)
   \      0x25E   0x2C10             CMP      R4,#+16
   \      0x260   0xD20F             BCS.N    ??sl_se_ccm_multipart_update_20
   1209              memcpy(ccm_ctx->mode_specific_buffer.final_data, input, length);
   \      0x262   0x9403             STR      R4,[SP, #+12]
   \      0x264   0x46BB             MOV      R11,R7
   \      0x266   0xF115 0x0A3D      ADDS     R10,R5,#+61
   \      0x26A   0x9A03             LDR      R2,[SP, #+12]
   \      0x26C   0x4659             MOV      R1,R11
   \      0x26E   0x4650             MOV      R0,R10
   \      0x270   0x.... 0x....      BL       __aeabi_memcpy
   1210              ccm_ctx->final_data_length += length;
   \      0x274   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \      0x278   0x1820             ADDS     R0,R4,R0
   \      0x27A   0xF885 0x004D      STRB     R0,[R5, #+77]
   1211              return SL_STATUS_OK;
   \      0x27E   0x2000             MOVS     R0,#+0
   \      0x280   0xE0D7             B.N      ??sl_se_ccm_multipart_update_2
   1212            }
   1213          
   1214            // Run only multiples of 16 and store residue data in context
   1215            if (length % 16 != 0) {
   \                     ??sl_se_ccm_multipart_update_20: (+1)
   \      0x282   0xF014 0x0F0F      TST      R4,#0xF
   \      0x286   0xD015             BEQ.N    ??sl_se_ccm_multipart_update_21
   1216              uint8_t residue_data_length = length % 16;
   \      0x288   0xF014 0x0A0F      ANDS     R10,R4,#0xF
   1217              memcpy(ccm_ctx->mode_specific_buffer.final_data, input + (length - residue_data_length), residue_data_length);
   \      0x28C   0x4650             MOV      R0,R10
   \      0x28E   0xB2C0             UXTB     R0,R0
   \      0x290   0x9004             STR      R0,[SP, #+16]
   \      0x292   0x4650             MOV      R0,R10
   \      0x294   0xB2C0             UXTB     R0,R0
   \      0x296   0x1A20             SUBS     R0,R4,R0
   \      0x298   0x4438             ADD      R0,R7,R0
   \      0x29A   0x9003             STR      R0,[SP, #+12]
   \      0x29C   0xF115 0x0B3D      ADDS     R11,R5,#+61
   \      0x2A0   0x9A04             LDR      R2,[SP, #+16]
   \      0x2A2   0x9903             LDR      R1,[SP, #+12]
   \      0x2A4   0x4658             MOV      R0,R11
   \      0x2A6   0x.... 0x....      BL       __aeabi_memcpy
   1218              length -= residue_data_length;
   \      0x2AA   0x4650             MOV      R0,R10
   \      0x2AC   0xB2C0             UXTB     R0,R0
   \      0x2AE   0x1A24             SUBS     R4,R4,R0
   1219              ccm_ctx->final_data_length = residue_data_length;
   \      0x2B0   0xF885 0xA04D      STRB     R10,[R5, #+77]
   1220            }
   1221          
   1222            if ((ccm_ctx->total_message_length == ccm_ctx->processed_message_length + length) && !ccm_ctx->final_data_length) {
   \                     ??sl_se_ccm_multipart_update_21: (+1)
   \      0x2B4   0x6869             LDR      R1,[R5, #+4]
   \      0x2B6   0x6828             LDR      R0,[R5, #+0]
   \      0x2B8   0x1820             ADDS     R0,R4,R0
   \      0x2BA   0x4281             CMP      R1,R0
   \      0x2BC   0xD118             BNE.N    ??sl_se_ccm_multipart_update_22
   \      0x2BE   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \      0x2C2   0x2800             CMP      R0,#+0
   \      0x2C4   0xD114             BNE.N    ??sl_se_ccm_multipart_update_22
   1223              // The finish operation must have some data or the SE fails.
   1224              memcpy(ccm_ctx->mode_specific_buffer.final_data, input + (length - 16), 16);
   \      0x2C6   0xF05F 0x0A10      MOVS     R10,#+16
   \      0x2CA   0xEB07 0x0004      ADD      R0,R7,R4
   \      0x2CE   0x3810             SUBS     R0,R0,#+16
   \      0x2D0   0x9003             STR      R0,[SP, #+12]
   \      0x2D2   0xF115 0x0B3D      ADDS     R11,R5,#+61
   \      0x2D6   0x4652             MOV      R2,R10
   \      0x2D8   0x9903             LDR      R1,[SP, #+12]
   \      0x2DA   0x4658             MOV      R0,R11
   \      0x2DC   0x.... 0x....      BL       __aeabi_memcpy
   1225              ccm_ctx->final_data_length = 16;
   \      0x2E0   0x2010             MOVS     R0,#+16
   \      0x2E2   0xF885 0x004D      STRB     R0,[R5, #+77]
   1226              length -= 16;
   \      0x2E6   0x3C10             SUBS     R4,R4,#+16
   1227              if (!length) {
   \      0x2E8   0x2C00             CMP      R4,#+0
   \      0x2EA   0xD101             BNE.N    ??sl_se_ccm_multipart_update_22
   1228                return SL_STATUS_OK;
   \      0x2EC   0x2000             MOVS     R0,#+0
   \      0x2EE   0xE0A0             B.N      ??sl_se_ccm_multipart_update_2
   1229              }
   1230            }
   1231          
   1232            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \                     ??sl_se_ccm_multipart_update_22: (+1)
   \      0x2F0   0xAB0F             ADD      R3,SP,#+60
   \      0x2F2   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \      0x2F6   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x2FA   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x2FE   0xF115 0x001D      ADDS     R0,R5,#+29
   \      0x302   0x900F             STR      R0,[SP, #+60]
   1233          
   1234            SE_DataTransfer_t data_in =
   1235              SE_DATATRANSFER_DEFAULT(input, length);
   \      0x304   0xF10D 0x0C24      ADD      R12,SP,#+36
   \      0x308   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \      0x30C   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x310   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x314   0x9709             STR      R7,[SP, #+36]
   \      0x316   0xF054 0x5000      ORRS     R0,R4,#0x20000000
   \      0x31A   0x900B             STR      R0,[SP, #+44]
   1236            SE_DataTransfer_t data_out =
   1237              SE_DATATRANSFER_DEFAULT(output, length);
   \      0x31C   0xF10D 0x0C18      ADD      R12,SP,#+24
   \      0x320   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \      0x324   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x328   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x32C   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \      0x330   0xF054 0x5000      ORRS     R0,R4,#0x20000000
   \      0x334   0x9008             STR      R0,[SP, #+32]
   1238          
   1239            SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \      0x336   0xAB0C             ADD      R3,SP,#+48
   \      0x338   0x.... 0x....      LDR.W    R12,??DataTable13_7
   \      0x33C   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x340   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x344   0xF115 0x001D      ADDS     R0,R5,#+29
   \      0x348   0x900C             STR      R0,[SP, #+48]
   1240          
   1241            sli_se_command_init(cmd_ctx,
   1242                                ((ccm_ctx->mode == SL_SE_DECRYPT)
   1243                                 ? SLI_SE_COMMAND_AES_CCM_DECRYPT : SLI_SE_COMMAND_AES_CCM_ENCRYPT)
   1244                                | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \      0x34A   0x7F28             LDRB     R0,[R5, #+28]
   \      0x34C   0x2801             CMP      R0,#+1
   \      0x34E   0xD102             BNE.N    ??sl_se_ccm_multipart_update_23
   \      0x350   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \      0x354   0xE000             B.N      ??sl_se_ccm_multipart_update_24
   \                     ??sl_se_ccm_multipart_update_23: (+1)
   \      0x356   0x....             LDR.N    R0,??DataTable8_3
   \                     ??sl_se_ccm_multipart_update_24: (+1)
   \      0x358   0xF050 0x0003      ORRS     R0,R0,#0x3
   \      0x35C   0x6030             STR      R0,[R6, #+0]
   \      0x35E   0x2000             MOVS     R0,#+0
   \      0x360   0x6070             STR      R0,[R6, #+4]
   \      0x362   0x2000             MOVS     R0,#+0
   \      0x364   0x60B0             STR      R0,[R6, #+8]
   \      0x366   0x2000             MOVS     R0,#+0
   \      0x368   0x61F0             STR      R0,[R6, #+28]
   1245          
   1246            sli_add_key_parameters(cmd_ctx, key, status);
   \      0x36A   0xA901             ADD      R1,SP,#+4
   \      0x36C   0x982A             LDR      R0,[SP, #+168]
   \      0x36E   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x372   0x4682             MOV      R10,R0
   \      0x374   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x378   0xD001             BEQ.N    ??sl_se_ccm_multipart_update_25
   \      0x37A   0x4650             MOV      R0,R10
   \      0x37C   0xE059             B.N      ??sl_se_ccm_multipart_update_2
   \                     ??sl_se_ccm_multipart_update_25: (+1)
   \      0x37E   0x9901             LDR      R1,[SP, #+4]
   \      0x380   0x0030             MOVS     R0,R6
   \      0x382   0x.... 0x....      BL       SE_addParameter
   1247          
   1248            SE_addParameter(se_cmd, length);
   \      0x386   0x0021             MOVS     R1,R4
   \      0x388   0x9800             LDR      R0,[SP, #+0]
   \      0x38A   0x.... 0x....      BL       SE_addParameter
   1249          
   1250            sli_add_key_metadata(cmd_ctx, key, status);
   \      0x38E   0xA927             ADD      R1,SP,#+156
   \      0x390   0x982A             LDR      R0,[SP, #+168]
   \      0x392   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x396   0x4681             MOV      R9,R0
   \      0x398   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x39C   0xD001             BEQ.N    ??sl_se_ccm_multipart_update_26
   \      0x39E   0x4648             MOV      R0,R9
   \      0x3A0   0xE047             B.N      ??sl_se_ccm_multipart_update_2
   \                     ??sl_se_ccm_multipart_update_26: (+1)
   \      0x3A2   0xA927             ADD      R1,SP,#+156
   \      0x3A4   0x0030             MOVS     R0,R6
   \      0x3A6   0x.... 0x....      BL       SE_addDataInput
   1251            sli_add_key_input(cmd_ctx, key, status);
   \      0x3AA   0xA924             ADD      R1,SP,#+144
   \      0x3AC   0x982A             LDR      R0,[SP, #+168]
   \      0x3AE   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x3B2   0x4682             MOV      R10,R0
   \      0x3B4   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x3B8   0xD001             BEQ.N    ??sl_se_ccm_multipart_update_27
   \      0x3BA   0x4650             MOV      R0,R10
   \      0x3BC   0xE039             B.N      ??sl_se_ccm_multipart_update_2
   \                     ??sl_se_ccm_multipart_update_27: (+1)
   \      0x3BE   0xA924             ADD      R1,SP,#+144
   \      0x3C0   0x0030             MOVS     R0,R6
   \      0x3C2   0x.... 0x....      BL       SE_addDataInput
   1252          
   1253            SE_addDataInput(se_cmd, &iv_ctx_in);
   \      0x3C6   0xA90F             ADD      R1,SP,#+60
   \      0x3C8   0x9800             LDR      R0,[SP, #+0]
   \      0x3CA   0x.... 0x....      BL       SE_addDataInput
   1254            SE_addDataInput(se_cmd, &data_in);
   \      0x3CE   0xA909             ADD      R1,SP,#+36
   \      0x3D0   0x9800             LDR      R0,[SP, #+0]
   \      0x3D2   0x.... 0x....      BL       SE_addDataInput
   1255          
   1256            SE_addDataOutput(se_cmd, &data_out);
   \      0x3D6   0xA906             ADD      R1,SP,#+24
   \      0x3D8   0x9800             LDR      R0,[SP, #+0]
   \      0x3DA   0x.... 0x....      BL       SE_addDataOutput
   1257            SE_addDataOutput(se_cmd, &ctx_out);
   \      0x3DE   0xA90C             ADD      R1,SP,#+48
   \      0x3E0   0x9800             LDR      R0,[SP, #+0]
   \      0x3E2   0x.... 0x....      BL       SE_addDataOutput
   1258          
   1259            status = sli_se_execute_and_wait(cmd_ctx);
   \      0x3E6   0x0030             MOVS     R0,R6
   \      0x3E8   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x3EC   0x4681             MOV      R9,R0
   1260            if (status != SL_STATUS_OK) {
   \      0x3EE   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x3F2   0xD015             BEQ.N    ??sl_se_ccm_multipart_update_28
   1261              memset(output, 0, length);
   \      0x3F4   0x9405             STR      R4,[SP, #+20]
   \      0x3F6   0x2000             MOVS     R0,#+0
   \      0x3F8   0x9004             STR      R0,[SP, #+16]
   \      0x3FA   0x46C2             MOV      R10,R8
   \      0x3FC   0x9A04             LDR      R2,[SP, #+16]
   \      0x3FE   0x9905             LDR      R1,[SP, #+20]
   \      0x400   0x4650             MOV      R0,R10
   \      0x402   0x.... 0x....      BL       __aeabi_memset
   1262              memset(ccm_ctx->se_ctx, 0, sizeof(ccm_ctx->se_ctx));
   \      0x406   0x2020             MOVS     R0,#+32
   \      0x408   0x9003             STR      R0,[SP, #+12]
   \      0x40A   0xF05F 0x0B00      MOVS     R11,#+0
   \      0x40E   0xF115 0x0A1D      ADDS     R10,R5,#+29
   \      0x412   0x465A             MOV      R2,R11
   \      0x414   0x9903             LDR      R1,[SP, #+12]
   \      0x416   0x4650             MOV      R0,R10
   \      0x418   0x.... 0x....      BL       __aeabi_memset
   1263              return status;
   \      0x41C   0x4648             MOV      R0,R9
   \      0x41E   0xE008             B.N      ??sl_se_ccm_multipart_update_2
   1264            }
   1265          
   1266            *output_length += length;
   \                     ??sl_se_ccm_multipart_update_28: (+1)
   \      0x420   0x9836             LDR      R0,[SP, #+216]
   \      0x422   0x6801             LDR      R1,[R0, #+0]
   \      0x424   0x1861             ADDS     R1,R4,R1
   \      0x426   0x9836             LDR      R0,[SP, #+216]
   \      0x428   0x6001             STR      R1,[R0, #+0]
   1267            ccm_ctx->processed_message_length += length;
   \      0x42A   0x6828             LDR      R0,[R5, #+0]
   \      0x42C   0x1820             ADDS     R0,R4,R0
   \      0x42E   0x6028             STR      R0,[R5, #+0]
   1268          
   1269            return status;
   \      0x430   0x4648             MOV      R0,R9
   \                     ??sl_se_ccm_multipart_update_2: (+1)
   \      0x432   0xB02B             ADD      SP,SP,#+172
   \      0x434   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1270          }

   \                                 In section .rodata, align 4
   \                     ?_31:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_32:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_33:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_34:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_35:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_36:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_37:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_38:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020
   1271          #endif
   1272          
   1273          /***************************************************************************//**
   1274           *   Finish a CCM streaming operation and return the resulting CCM tag.
   1275           *   It is called after sl_se_ccm_multipart_update().
   1276           ******************************************************************************/
   1277          #if defined(SLI_SE_MAJOR_VERSION_TWO)

   \                                 In section .text, align 2, keep-with-next
   1278          sl_status_t sl_se_ccm_multipart_finish(sl_se_ccm_multipart_context_t *ccm_ctx,
   1279                                                 sl_se_command_context_t *cmd_ctx,
   1280                                                 const sl_se_key_descriptor_t *key,
   1281                                                 uint8_t *tag,
   1282                                                 uint8_t tag_size,
   1283                                                 uint8_t *output,
   1284                                                 uint8_t output_size,
   1285                                                 uint8_t *output_length)
   1286          {
   \                     sl_se_ccm_multipart_finish: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0xF8DD 0xB084      LDR      R11,[SP, #+132]
   1287            //Check input parameters
   1288            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL || tag == NULL) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD005             BEQ.N    ??sl_se_ccm_multipart_finish_0
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD003             BEQ.N    ??sl_se_ccm_multipart_finish_0
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD001             BEQ.N    ??sl_se_ccm_multipart_finish_0
   \       0x1E   0x2F00             CMP      R7,#+0
   \       0x20   0xD101             BNE.N    ??sl_se_ccm_multipart_finish_1
   1289              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_finish_0: (+1)
   \       0x22   0x2021             MOVS     R0,#+33
   \       0x24   0xE0E0             B.N      ??sl_se_ccm_multipart_finish_2
   1290            }
   1291          
   1292            if (tag_size < ccm_ctx->tag_len || output_size < ccm_ctx->final_data_length) {
   \                     ??sl_se_ccm_multipart_finish_1: (+1)
   \       0x26   0xF89D 0x1078      LDRB     R1,[SP, #+120]
   \       0x2A   0x69A0             LDR      R0,[R4, #+24]
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD305             BCC.N    ??sl_se_ccm_multipart_finish_3
   \       0x30   0xF89D 0x1080      LDRB     R1,[SP, #+128]
   \       0x34   0xF894 0x004D      LDRB     R0,[R4, #+77]
   \       0x38   0x4281             CMP      R1,R0
   \       0x3A   0xD201             BCS.N    ??sl_se_ccm_multipart_finish_4
   1293              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_finish_3: (+1)
   \       0x3C   0x2021             MOVS     R0,#+33
   \       0x3E   0xE0D3             B.N      ??sl_se_ccm_multipart_finish_2
   1294            }
   1295          
   1296            sl_status_t status = SL_STATUS_OK;
   \                     ??sl_se_ccm_multipart_finish_4: (+1)
   \       0x40   0xF05F 0x0900      MOVS     R9,#+0
   1297          
   1298            if (ccm_ctx->total_message_length == 0) {
   \       0x44   0x6860             LDR      R0,[R4, #+4]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD122             BNE.N    ??sl_se_ccm_multipart_finish_5
   1299              if (ccm_ctx->mode == SL_SE_DECRYPT) {
   \       0x4A   0x7F20             LDRB     R0,[R4, #+28]
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD113             BNE.N    ??sl_se_ccm_multipart_finish_6
   1300                if (memcmp_time_cst(tag, ccm_ctx->mode_specific_buffer.tagbuf, ccm_ctx->tag_len) != 0) {
   \       0x50   0x69A2             LDR      R2,[R4, #+24]
   \       0x52   0xF114 0x013D      ADDS     R1,R4,#+61
   \       0x56   0x0038             MOVS     R0,R7
   \       0x58   0x.... 0x....      BL       memcmp_time_cst
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD015             BEQ.N    ??sl_se_ccm_multipart_finish_7
   1301                  memset(tag, 0, ccm_ctx->tag_len);
   \       0x60   0x69A0             LDR      R0,[R4, #+24]
   \       0x62   0x9001             STR      R0,[SP, #+4]
   \       0x64   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x68   0x46B8             MOV      R8,R7
   \       0x6A   0x4652             MOV      R2,R10
   \       0x6C   0x9901             LDR      R1,[SP, #+4]
   \       0x6E   0x4640             MOV      R0,R8
   \       0x70   0x.... 0x....      BL       __aeabi_memset
   1302                  return SL_STATUS_INVALID_SIGNATURE;
   \       0x74   0x202C             MOVS     R0,#+44
   \       0x76   0xE0B7             B.N      ??sl_se_ccm_multipart_finish_2
   1303                }
   1304              } else {
   1305                memcpy(tag, ccm_ctx->mode_specific_buffer.tagbuf, ccm_ctx->tag_len);
   \                     ??sl_se_ccm_multipart_finish_6: (+1)
   \       0x78   0x69A0             LDR      R0,[R4, #+24]
   \       0x7A   0x9001             STR      R0,[SP, #+4]
   \       0x7C   0xF114 0x0A3D      ADDS     R10,R4,#+61
   \       0x80   0x46B8             MOV      R8,R7
   \       0x82   0x9A01             LDR      R2,[SP, #+4]
   \       0x84   0x4651             MOV      R1,R10
   \       0x86   0x4640             MOV      R0,R8
   \       0x88   0x.... 0x....      BL       __aeabi_memcpy
   1306              }
   1307              return SL_STATUS_OK;
   \                     ??sl_se_ccm_multipart_finish_7: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xE0AB             B.N      ??sl_se_ccm_multipart_finish_2
   1308            }
   1309          
   1310            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_ccm_multipart_finish_5: (+1)
   \       0x90   0x46AA             MOV      R10,R5
   1311          
   1312            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \       0x92   0xF10D 0x0C30      ADD      R12,SP,#+48
   \       0x96   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x9A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x9E   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xA2   0xF114 0x001D      ADDS     R0,R4,#+29
   \       0xA6   0x900C             STR      R0,[SP, #+48]
   1313          
   1314            SE_DataTransfer_t data_in =
   1315              SE_DATATRANSFER_DEFAULT(ccm_ctx->mode_specific_buffer.final_data, ccm_ctx->final_data_length);
   \       0xA8   0xAB09             ADD      R3,SP,#+36
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0xAE   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xB2   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xB6   0xF114 0x003D      ADDS     R0,R4,#+61
   \       0xBA   0x9009             STR      R0,[SP, #+36]
   \       0xBC   0xF894 0x004D      LDRB     R0,[R4, #+77]
   \       0xC0   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \       0xC4   0x900B             STR      R0,[SP, #+44]
   1316          
   1317            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, ccm_ctx->final_data_length);
   \       0xC6   0xAB06             ADD      R3,SP,#+24
   \       0xC8   0x.... 0x....      LDR.W    R12,??DataTable14_2
   \       0xCC   0xE89C 0x0007      LDM      R12,{R0-R2}
   \       0xD0   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xD4   0x981F             LDR      R0,[SP, #+124]
   \       0xD6   0x9006             STR      R0,[SP, #+24]
   \       0xD8   0xF894 0x004D      LDRB     R0,[R4, #+77]
   \       0xDC   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \       0xE0   0x9008             STR      R0,[SP, #+32]
   1318            SE_DataTransfer_t tag_buf = SE_DATATRANSFER_DEFAULT(tag,
   1319                                                                ccm_ctx->tag_len);
   \       0xE2   0xAB03             ADD      R3,SP,#+12
   \       0xE4   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \       0xE8   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xEC   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xF0   0x9703             STR      R7,[SP, #+12]
   \       0xF2   0x69A0             LDR      R0,[R4, #+24]
   \       0xF4   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \       0xF8   0x9005             STR      R0,[SP, #+20]
   1320          
   1321            sli_se_command_init(cmd_ctx,
   1322                                ((ccm_ctx->mode == SL_SE_DECRYPT)
   1323                                 ? SLI_SE_COMMAND_AES_CCM_DECRYPT : SLI_SE_COMMAND_AES_CCM_ENCRYPT)
   1324                                | SLI_SE_COMMAND_OPTION_CONTEXT_END);
   \       0xFA   0x7F20             LDRB     R0,[R4, #+28]
   \       0xFC   0x2801             CMP      R0,#+1
   \       0xFE   0xD101             BNE.N    ??sl_se_ccm_multipart_finish_8
   \      0x100   0x....             LDR.N    R0,??DataTable10_1
   \      0x102   0xE001             B.N      ??sl_se_ccm_multipart_finish_9
   \                     ??sl_se_ccm_multipart_finish_8: (+1)
   \      0x104   0x.... 0x....      LDR.W    R0,??DataTable15
   \                     ??sl_se_ccm_multipart_finish_9: (+1)
   \      0x108   0xF050 0x0002      ORRS     R0,R0,#0x2
   \      0x10C   0x6028             STR      R0,[R5, #+0]
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0x6068             STR      R0,[R5, #+4]
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0x60A8             STR      R0,[R5, #+8]
   \      0x116   0x2000             MOVS     R0,#+0
   \      0x118   0x61E8             STR      R0,[R5, #+28]
   1325          
   1326            sli_add_key_parameters(cmd_ctx, key, status);
   \      0x11A   0x4669             MOV      R1,SP
   \      0x11C   0x0030             MOVS     R0,R6
   \      0x11E   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x122   0x4680             MOV      R8,R0
   \      0x124   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x128   0xD001             BEQ.N    ??sl_se_ccm_multipart_finish_10
   \      0x12A   0x4640             MOV      R0,R8
   \      0x12C   0xE05C             B.N      ??sl_se_ccm_multipart_finish_2
   \                     ??sl_se_ccm_multipart_finish_10: (+1)
   \      0x12E   0x9900             LDR      R1,[SP, #+0]
   \      0x130   0x0028             MOVS     R0,R5
   \      0x132   0x.... 0x....      BL       SE_addParameter
   1327          
   1328            SE_addParameter(se_cmd, (ccm_ctx->tag_len & 0xFFFF));
   \      0x136   0x69A1             LDR      R1,[R4, #+24]
   \      0x138   0xB289             UXTH     R1,R1
   \      0x13A   0x4650             MOV      R0,R10
   \      0x13C   0x.... 0x....      BL       SE_addParameter
   1329          
   1330            SE_addParameter(se_cmd, ccm_ctx->final_data_length);
   \      0x140   0xF894 0x104D      LDRB     R1,[R4, #+77]
   \      0x144   0x4650             MOV      R0,R10
   \      0x146   0x.... 0x....      BL       SE_addParameter
   1331          
   1332            sli_add_key_metadata(cmd_ctx, key, status);
   \      0x14A   0xA912             ADD      R1,SP,#+72
   \      0x14C   0x0030             MOVS     R0,R6
   \      0x14E   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x152   0x4681             MOV      R9,R0
   \      0x154   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x158   0xD001             BEQ.N    ??sl_se_ccm_multipart_finish_11
   \      0x15A   0x4648             MOV      R0,R9
   \      0x15C   0xE044             B.N      ??sl_se_ccm_multipart_finish_2
   \                     ??sl_se_ccm_multipart_finish_11: (+1)
   \      0x15E   0xA912             ADD      R1,SP,#+72
   \      0x160   0x0028             MOVS     R0,R5
   \      0x162   0x.... 0x....      BL       SE_addDataInput
   1333            sli_add_key_input(cmd_ctx, key, status);
   \      0x166   0xA90F             ADD      R1,SP,#+60
   \      0x168   0x0030             MOVS     R0,R6
   \      0x16A   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x16E   0x4680             MOV      R8,R0
   \      0x170   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x174   0xD001             BEQ.N    ??sl_se_ccm_multipart_finish_12
   \      0x176   0x4640             MOV      R0,R8
   \      0x178   0xE036             B.N      ??sl_se_ccm_multipart_finish_2
   \                     ??sl_se_ccm_multipart_finish_12: (+1)
   \      0x17A   0xA90F             ADD      R1,SP,#+60
   \      0x17C   0x0028             MOVS     R0,R5
   \      0x17E   0x.... 0x....      BL       SE_addDataInput
   1334          
   1335            SE_addDataInput(se_cmd, &iv_ctx_in);
   \      0x182   0xA90C             ADD      R1,SP,#+48
   \      0x184   0x4650             MOV      R0,R10
   \      0x186   0x.... 0x....      BL       SE_addDataInput
   1336            SE_addDataInput(se_cmd, &data_in);
   \      0x18A   0xA909             ADD      R1,SP,#+36
   \      0x18C   0x4650             MOV      R0,R10
   \      0x18E   0x.... 0x....      BL       SE_addDataInput
   1337          
   1338            SE_addDataOutput(se_cmd, &data_out);
   \      0x192   0xA906             ADD      R1,SP,#+24
   \      0x194   0x4650             MOV      R0,R10
   \      0x196   0x.... 0x....      BL       SE_addDataOutput
   1339            if (ccm_ctx->mode == SL_SE_DECRYPT) {
   \      0x19A   0x7F20             LDRB     R0,[R4, #+28]
   \      0x19C   0x2801             CMP      R0,#+1
   \      0x19E   0xD104             BNE.N    ??sl_se_ccm_multipart_finish_13
   1340              SE_addDataInput(se_cmd, &tag_buf);
   \      0x1A0   0xA903             ADD      R1,SP,#+12
   \      0x1A2   0x4650             MOV      R0,R10
   \      0x1A4   0x.... 0x....      BL       SE_addDataInput
   \      0x1A8   0xE003             B.N      ??sl_se_ccm_multipart_finish_14
   1341            } else {
   1342              SE_addDataOutput(se_cmd, &tag_buf);
   \                     ??sl_se_ccm_multipart_finish_13: (+1)
   \      0x1AA   0xA903             ADD      R1,SP,#+12
   \      0x1AC   0x4650             MOV      R0,R10
   \      0x1AE   0x.... 0x....      BL       SE_addDataOutput
   1343            }
   1344            status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??sl_se_ccm_multipart_finish_14: (+1)
   \      0x1B2   0x0028             MOVS     R0,R5
   \      0x1B4   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x1B8   0x4681             MOV      R9,R0
   1345          
   1346            if (status != SL_STATUS_OK) {
   \      0x1BA   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x1BE   0xD00E             BEQ.N    ??sl_se_ccm_multipart_finish_15
   1347              memset(tag, 0, ccm_ctx->tag_len);
   \      0x1C0   0x69A0             LDR      R0,[R4, #+24]
   \      0x1C2   0x9002             STR      R0,[SP, #+8]
   \      0x1C4   0x2000             MOVS     R0,#+0
   \      0x1C6   0x9001             STR      R0,[SP, #+4]
   \      0x1C8   0x46B8             MOV      R8,R7
   \      0x1CA   0x9A01             LDR      R2,[SP, #+4]
   \      0x1CC   0x9902             LDR      R1,[SP, #+8]
   \      0x1CE   0x4640             MOV      R0,R8
   \      0x1D0   0x.... 0x....      BL       __aeabi_memset
   1348              *output_length = 0;
   \      0x1D4   0x2000             MOVS     R0,#+0
   \      0x1D6   0xF88B 0x0000      STRB     R0,[R11, #+0]
   1349              return status;
   \      0x1DA   0x4648             MOV      R0,R9
   \      0x1DC   0xE004             B.N      ??sl_se_ccm_multipart_finish_2
   1350            }
   1351          
   1352            *output_length = ccm_ctx->final_data_length;
   \                     ??sl_se_ccm_multipart_finish_15: (+1)
   \      0x1DE   0xF894 0x004D      LDRB     R0,[R4, #+77]
   \      0x1E2   0xF88B 0x0000      STRB     R0,[R11, #+0]
   1353          
   1354            return SL_STATUS_OK;
   \      0x1E6   0x2000             MOVS     R0,#+0
   \                     ??sl_se_ccm_multipart_finish_2: (+1)
   \      0x1E8   0xB015             ADD      SP,SP,#+84
   \      0x1EA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1355          }

   \                                 In section .rodata, align 4
   \                     ?_39:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_40:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_41:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_42:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1356          #endif
   1357          
   1358          /***************************************************************************//**
   1359           * This function calculates the full generic CMAC on the input buffer with
   1360           * the provided key.
   1361           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1362          sl_status_t sl_se_cmac(sl_se_command_context_t *cmd_ctx,
   1363                                 const sl_se_key_descriptor_t *key,
   1364                                 const unsigned char *input,
   1365                                 size_t input_len,
   1366                                 unsigned char *output)
   1367          {
   \                     sl_se_cmac: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x469B             MOV      R11,R3
   \        0xE   0x9F16             LDR      R7,[SP, #+88]
   1368            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD005             BEQ.N    ??sl_se_cmac_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD003             BEQ.N    ??sl_se_cmac_0
   \       0x18   0x2E00             CMP      R6,#+0
   \       0x1A   0xD001             BEQ.N    ??sl_se_cmac_0
   \       0x1C   0x2F00             CMP      R7,#+0
   \       0x1E   0xD101             BNE.N    ??sl_se_cmac_1
   1369              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_cmac_0: (+1)
   \       0x20   0x2021             MOVS     R0,#+33
   \       0x22   0xE063             B.N      ??sl_se_cmac_2
   1370            }
   1371          
   1372            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_cmac_1: (+1)
   \       0x24   0x46A2             MOV      R10,R4
   1373            sl_status_t status = SL_STATUS_OK;
   \       0x26   0xF05F 0x0900      MOVS     R9,#+0
   1374          
   1375            switch (key->type) {
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x2810             CMP      R0,#+16
   \       0x2E   0xD003             BEQ.N    ??sl_se_cmac_3
   \       0x30   0x2818             CMP      R0,#+24
   \       0x32   0xD001             BEQ.N    ??sl_se_cmac_3
   \       0x34   0x2820             CMP      R0,#+32
   \       0x36   0xD111             BNE.N    ??sl_se_cmac_4
   1376              case SL_SE_KEY_TYPE_AES_128:
   1377              case SL_SE_KEY_TYPE_AES_192:
   1378              case SL_SE_KEY_TYPE_AES_256:
   1379                break;
   1380          
   1381              default:
   1382                return SL_STATUS_INVALID_PARAMETER;
   1383            }
   1384          
   1385            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_CMAC);
   \                     ??sl_se_cmac_3: (+1)
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \       0x3C   0x6020             STR      R0,[R4, #+0]
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6060             STR      R0,[R4, #+4]
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x60A0             STR      R0,[R4, #+8]
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x61E0             STR      R0,[R4, #+28]
   1386          
   1387            // Add key parameter to command.
   1388            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x52   0x4680             MOV      R8,R0
   \       0x54   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x58   0xD102             BNE.N    ??sl_se_cmac_5
   \       0x5A   0xE003             B.N      ??sl_se_cmac_6
   \                     ??sl_se_cmac_4: (+1)
   \       0x5C   0x2021             MOVS     R0,#+33
   \       0x5E   0xE045             B.N      ??sl_se_cmac_2
   \                     ??sl_se_cmac_5: (+1)
   \       0x60   0x4640             MOV      R0,R8
   \       0x62   0xE043             B.N      ??sl_se_cmac_2
   \                     ??sl_se_cmac_6: (+1)
   \       0x64   0x9900             LDR      R1,[SP, #+0]
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x.... 0x....      BL       SE_addParameter
   1389          
   1390            // Message size parameter.
   1391            SE_addParameter(se_cmd, input_len);
   \       0x6C   0x4659             MOV      R1,R11
   \       0x6E   0x4650             MOV      R0,R10
   \       0x70   0x.... 0x....      BL       SE_addParameter
   1392          
   1393            // Key metadata.
   1394            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x74   0xA90A             ADD      R1,SP,#+40
   \       0x76   0x0028             MOVS     R0,R5
   \       0x78   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x7C   0x4681             MOV      R9,R0
   \       0x7E   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x82   0xD001             BEQ.N    ??sl_se_cmac_7
   \       0x84   0x4648             MOV      R0,R9
   \       0x86   0xE031             B.N      ??sl_se_cmac_2
   \                     ??sl_se_cmac_7: (+1)
   \       0x88   0xA90A             ADD      R1,SP,#+40
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x.... 0x....      BL       SE_addDataInput
   1395            sli_add_key_input(cmd_ctx, key, status);
   \       0x90   0xA907             ADD      R1,SP,#+28
   \       0x92   0x0028             MOVS     R0,R5
   \       0x94   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x98   0x4680             MOV      R8,R0
   \       0x9A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x9E   0xD001             BEQ.N    ??sl_se_cmac_8
   \       0xA0   0x4640             MOV      R0,R8
   \       0xA2   0xE023             B.N      ??sl_se_cmac_2
   \                     ??sl_se_cmac_8: (+1)
   \       0xA4   0xA907             ADD      R1,SP,#+28
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0x.... 0x....      BL       SE_addDataInput
   1396          
   1397            // Data input.
   1398            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(input, input_len);
   \       0xAC   0xF10D 0x0C04      ADD      R12,SP,#+4
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable16
   \       0xB4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xB8   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xBC   0x9601             STR      R6,[SP, #+4]
   \       0xBE   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \       0xC2   0x9003             STR      R0,[SP, #+12]
   1399            SE_addDataInput(se_cmd, &in_data);
   \       0xC4   0xA901             ADD      R1,SP,#+4
   \       0xC6   0x4650             MOV      R0,R10
   \       0xC8   0x.... 0x....      BL       SE_addDataInput
   1400          
   1401            // Data output.
   1402            SE_DataTransfer_t out_tag = SE_DATATRANSFER_DEFAULT(output, 16);
   \       0xCC   0xF10D 0x0C10      ADD      R12,SP,#+16
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \       0xD4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xD8   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xDC   0x9704             STR      R7,[SP, #+16]
   1403            SE_addDataOutput(se_cmd, &out_tag);
   \       0xDE   0xA904             ADD      R1,SP,#+16
   \       0xE0   0x4650             MOV      R0,R10
   \       0xE2   0x.... 0x....      BL       SE_addDataOutput
   1404          
   1405            return sli_se_execute_and_wait(cmd_ctx);
   \       0xE6   0x0020             MOVS     R0,R4
   \       0xE8   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_cmac_2: (+1)
   \       0xEC   0xB00D             ADD      SP,SP,#+52
   \       0xEE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1406          }

   \                                 In section .rodata, align 4
   \                     ?_43:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_44:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1407          
   1408          /***************************************************************************//**
   1409           *   Finish a CMAC streaming operation and return the resulting CMAC tag.
   1410           *   It is called after sl_se_cmac_update().
   1411           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1412          sl_status_t sl_se_cmac_multipart_finish(sl_se_cmac_multipart_context_t *cmac_ctx,
   1413                                                  sl_se_command_context_t *cmd_ctx,
   1414                                                  const sl_se_key_descriptor_t *key,
   1415                                                  uint8_t *output)
   1416          {
   \                     sl_se_cmac_multipart_finish: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB093             SUB      SP,SP,#+76
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x0016             MOVS     R6,R2
   \        0xC   0x001F             MOVS     R7,R3
   1417            sl_status_t status = SL_STATUS_OK;
   \        0xE   0xF05F 0x0900      MOVS     R9,#+0
   1418          
   1419            if (cmac_ctx == NULL || cmd_ctx == NULL || key == NULL || output == NULL) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD005             BEQ.N    ??sl_se_cmac_multipart_finish_0
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD003             BEQ.N    ??sl_se_cmac_multipart_finish_0
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD001             BEQ.N    ??sl_se_cmac_multipart_finish_0
   \       0x1E   0x2F00             CMP      R7,#+0
   \       0x20   0xD101             BNE.N    ??sl_se_cmac_multipart_finish_1
   1420              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_cmac_multipart_finish_0: (+1)
   \       0x22   0x2021             MOVS     R0,#+33
   \       0x24   0xE0A3             B.N      ??sl_se_cmac_multipart_finish_2
   1421            }
   1422          
   1423            if (cmac_ctx->length >= 16U) {
   \                     ??sl_se_cmac_multipart_finish_1: (+1)
   \       0x26   0x6B20             LDR      R0,[R4, #+48]
   \       0x28   0x2810             CMP      R0,#+16
   \       0x2A   0xD30A             BCC.N    ??sl_se_cmac_multipart_finish_3
   1424              // Compute previous input block by decryption of current data.
   1425              status = sl_se_aes_crypt_ecb(cmd_ctx,
   1426                                           key,
   1427                                           SL_SE_DECRYPT,
   1428                                           16U,
   1429                                           cmac_ctx->data_out,
   1430                                           cmac_ctx->state);  // Keep decrypted data in 'state'
   \       0x2C   0x9401             STR      R4,[SP, #+4]
   \       0x2E   0xF114 0x0020      ADDS     R0,R4,#+32
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0x2310             MOVS     R3,#+16
   \       0x36   0x2201             MOVS     R2,#+1
   \       0x38   0x0031             MOVS     R1,R6
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \       0x40   0x4681             MOV      R9,R0
   1431            }
   1432          
   1433            if (status == SL_STATUS_OK) {
   \                     ??sl_se_cmac_multipart_finish_3: (+1)
   \       0x42   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x46   0xF040 0x8091      BNE.W    ??sl_se_cmac_multipart_finish_4
   1434              // Feed previous block and unprocessed data (if any) to CMAC,
   1435              // or on data < 16 just use accumulated data in context.
   1436              SE_Command_t *se_cmd = &cmd_ctx->command;
   \       0x4A   0x46AA             MOV      R10,R5
   1437              sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_CMAC);
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \       0x50   0x6028             STR      R0,[R5, #+0]
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x6068             STR      R0,[R5, #+4]
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x60A8             STR      R0,[R5, #+8]
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x61E8             STR      R0,[R5, #+28]
   1438          
   1439              // Add key parameter to command.
   1440              sli_add_key_parameters(cmd_ctx, key, status);
   \       0x5E   0x4669             MOV      R1,SP
   \       0x60   0x0030             MOVS     R0,R6
   \       0x62   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x66   0x4680             MOV      R8,R0
   \       0x68   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x6C   0xD001             BEQ.N    ??sl_se_cmac_multipart_finish_5
   \       0x6E   0x4640             MOV      R0,R8
   \       0x70   0xE07D             B.N      ??sl_se_cmac_multipart_finish_2
   \                     ??sl_se_cmac_multipart_finish_5: (+1)
   \       0x72   0x9900             LDR      R1,[SP, #+0]
   \       0x74   0x0028             MOVS     R0,R5
   \       0x76   0x.... 0x....      BL       SE_addParameter
   1441          
   1442              // Message size parameter.
   1443              if (cmac_ctx->length >= 16U) {
   \       0x7A   0x6B20             LDR      R0,[R4, #+48]
   \       0x7C   0x2810             CMP      R0,#+16
   \       0x7E   0xD308             BCC.N    ??sl_se_cmac_multipart_finish_6
   1444                SE_addParameter(se_cmd, 16U + (cmac_ctx->length & 0xFU));
   \       0x80   0xF894 0x1030      LDRB     R1,[R4, #+48]
   \       0x84   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x88   0x3110             ADDS     R1,R1,#+16
   \       0x8A   0x4650             MOV      R0,R10
   \       0x8C   0x.... 0x....      BL       SE_addParameter
   \       0x90   0xE003             B.N      ??sl_se_cmac_multipart_finish_7
   1445              } else {
   1446                SE_addParameter(se_cmd, cmac_ctx->length);
   \                     ??sl_se_cmac_multipart_finish_6: (+1)
   \       0x92   0x6B21             LDR      R1,[R4, #+48]
   \       0x94   0x4650             MOV      R0,R10
   \       0x96   0x.... 0x....      BL       SE_addParameter
   1447              }
   1448          
   1449              // Key metadata.
   1450              sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??sl_se_cmac_multipart_finish_7: (+1)
   \       0x9A   0xA910             ADD      R1,SP,#+64
   \       0x9C   0x0030             MOVS     R0,R6
   \       0x9E   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xA2   0x4681             MOV      R9,R0
   \       0xA4   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xA8   0xD001             BEQ.N    ??sl_se_cmac_multipart_finish_8
   \       0xAA   0x4648             MOV      R0,R9
   \       0xAC   0xE05F             B.N      ??sl_se_cmac_multipart_finish_2
   \                     ??sl_se_cmac_multipart_finish_8: (+1)
   \       0xAE   0xA910             ADD      R1,SP,#+64
   \       0xB0   0x0028             MOVS     R0,R5
   \       0xB2   0x.... 0x....      BL       SE_addDataInput
   1451              sli_add_key_input(cmd_ctx, key, status);
   \       0xB6   0xA90D             ADD      R1,SP,#+52
   \       0xB8   0x0030             MOVS     R0,R6
   \       0xBA   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xBE   0x4680             MOV      R8,R0
   \       0xC0   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xC4   0xD001             BEQ.N    ??sl_se_cmac_multipart_finish_9
   \       0xC6   0x4640             MOV      R0,R8
   \       0xC8   0xE051             B.N      ??sl_se_cmac_multipart_finish_2
   \                     ??sl_se_cmac_multipart_finish_9: (+1)
   \       0xCA   0xA90D             ADD      R1,SP,#+52
   \       0xCC   0x0028             MOVS     R0,R5
   \       0xCE   0x.... 0x....      BL       SE_addDataInput
   1452          
   1453              SE_DataTransfer_t in_data1 = SE_DATATRANSFER_DEFAULT(cmac_ctx->state, 16U);
   \       0xD2   0xF10D 0x0C04      ADD      R12,SP,#+4
   \       0xD6   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \       0xDA   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xDE   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xE2   0x9401             STR      R4,[SP, #+4]
   1454              SE_DataTransfer_t in_data2 = SE_DATATRANSFER_DEFAULT(cmac_ctx->data_in,
   1455                                                                   cmac_ctx->length & 0xFU);
   \       0xE4   0xAB07             ADD      R3,SP,#+28
   \       0xE6   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \       0xEA   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xEE   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xF2   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0xF6   0x9007             STR      R0,[SP, #+28]
   \       0xF8   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \       0xFC   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x100   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x104   0x9009             STR      R0,[SP, #+36]
   1456              SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(cmac_ctx->data_in,
   1457                                                                  cmac_ctx->length);
   \      0x106   0xAB04             ADD      R3,SP,#+16
   \      0x108   0x.... 0x....      LDR.W    R12,??DataTable16_4
   \      0x10C   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x110   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x114   0xF114 0x0010      ADDS     R0,R4,#+16
   \      0x118   0x9004             STR      R0,[SP, #+16]
   \      0x11A   0x6B20             LDR      R0,[R4, #+48]
   \      0x11C   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x120   0x9006             STR      R0,[SP, #+24]
   1458              // Data input.
   1459              if (cmac_ctx->length >= 16U) {
   \      0x122   0x6B20             LDR      R0,[R4, #+48]
   \      0x124   0x2810             CMP      R0,#+16
   \      0x126   0xD30C             BCC.N    ??sl_se_cmac_multipart_finish_10
   1460                // Collect data from two sources.
   1461                in_data1.length &= ~SE_DATATRANSFER_REALIGN;
   \      0x128   0x9803             LDR      R0,[SP, #+12]
   \      0x12A   0xF030 0x5000      BICS     R0,R0,#0x20000000
   \      0x12E   0x9003             STR      R0,[SP, #+12]
   1462                SE_addDataInput(se_cmd, &in_data1);
   \      0x130   0xA901             ADD      R1,SP,#+4
   \      0x132   0x4650             MOV      R0,R10
   \      0x134   0x.... 0x....      BL       SE_addDataInput
   1463                SE_addDataInput(se_cmd, &in_data2);
   \      0x138   0xA907             ADD      R1,SP,#+28
   \      0x13A   0x4650             MOV      R0,R10
   \      0x13C   0x.... 0x....      BL       SE_addDataInput
   \      0x140   0xE003             B.N      ??sl_se_cmac_multipart_finish_11
   1464              } else {
   1465                SE_addDataInput(se_cmd, &in_data);
   \                     ??sl_se_cmac_multipart_finish_10: (+1)
   \      0x142   0xA904             ADD      R1,SP,#+16
   \      0x144   0x4650             MOV      R0,R10
   \      0x146   0x.... 0x....      BL       SE_addDataInput
   1466              }
   1467          
   1468              // Data output.
   1469              SE_DataTransfer_t out_tag = SE_DATATRANSFER_DEFAULT(output, 16U);
   \                     ??sl_se_cmac_multipart_finish_11: (+1)
   \      0x14A   0xF10D 0x0C28      ADD      R12,SP,#+40
   \      0x14E   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \      0x152   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x156   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x15A   0x970A             STR      R7,[SP, #+40]
   1470              SE_addDataOutput(se_cmd, &out_tag);
   \      0x15C   0xA90A             ADD      R1,SP,#+40
   \      0x15E   0x4650             MOV      R0,R10
   \      0x160   0x.... 0x....      BL       SE_addDataOutput
   1471          
   1472              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x164   0x0028             MOVS     R0,R5
   \      0x166   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x16A   0x4681             MOV      R9,R0
   1473            }
   1474            return status;
   \                     ??sl_se_cmac_multipart_finish_4: (+1)
   \      0x16C   0x4648             MOV      R0,R9
   \                     ??sl_se_cmac_multipart_finish_2: (+1)
   \      0x16E   0xB014             ADD      SP,SP,#+80
   \      0x170   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1475          }

   \                                 In section .rodata, align 4
   \                     ?_45:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_46:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_47:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_48:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1476          
   1477          /***************************************************************************//**
   1478           *   Prepare a CMAC streaming command context object to be used in subsequent
   1479           *   CMAC streaming function calls.
   1480           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1481          sl_status_t sl_se_cmac_multipart_starts(sl_se_cmac_multipart_context_t *cmac_ctx,
   1482                                                  sl_se_command_context_t *cmd_ctx,
   1483                                                  const sl_se_key_descriptor_t *key)
   1484          {
   \                     sl_se_cmac_multipart_starts: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1485            if (cmac_ctx == NULL || cmd_ctx == NULL || key == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD003             BEQ.N    ??sl_se_cmac_multipart_starts_0
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD001             BEQ.N    ??sl_se_cmac_multipart_starts_0
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD101             BNE.N    ??sl_se_cmac_multipart_starts_1
   1486              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_cmac_multipart_starts_0: (+1)
   \       0x16   0x2021             MOVS     R0,#+33
   \       0x18   0xE012             B.N      ??sl_se_cmac_multipart_starts_2
   1487            }
   1488          
   1489            switch (key->type) {
   \                     ??sl_se_cmac_multipart_starts_1: (+1)
   \       0x1A   0x6830             LDR      R0,[R6, #+0]
   \       0x1C   0x2810             CMP      R0,#+16
   \       0x1E   0xD003             BEQ.N    ??sl_se_cmac_multipart_starts_3
   \       0x20   0x2818             CMP      R0,#+24
   \       0x22   0xD001             BEQ.N    ??sl_se_cmac_multipart_starts_3
   \       0x24   0x2820             CMP      R0,#+32
   \       0x26   0xD10A             BNE.N    ??sl_se_cmac_multipart_starts_4
   1490              case SL_SE_KEY_TYPE_AES_128:
   1491              case SL_SE_KEY_TYPE_AES_192:
   1492              case SL_SE_KEY_TYPE_AES_256:
   1493                break;
   1494          
   1495              default:
   1496                return SL_STATUS_INVALID_PARAMETER;
   1497            }
   1498          
   1499            memset(cmac_ctx, 0, sizeof(sl_se_cmac_multipart_context_t));
   \                     ??sl_se_cmac_multipart_starts_3: (+1)
   \       0x28   0xF05F 0x0934      MOVS     R9,#+52
   \       0x2C   0x2700             MOVS     R7,#+0
   \       0x2E   0x46A0             MOV      R8,R4
   \       0x30   0x003A             MOVS     R2,R7
   \       0x32   0x4649             MOV      R1,R9
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0x.... 0x....      BL       __aeabi_memset
   1500            return SL_STATUS_OK;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xE000             B.N      ??sl_se_cmac_multipart_starts_2
   \                     ??sl_se_cmac_multipart_starts_4: (+1)
   \       0x3E   0x2021             MOVS     R0,#+33
   \                     ??sl_se_cmac_multipart_starts_2: (+1)
   \       0x40   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1501          }
   1502          
   1503          /***************************************************************************//**
   1504           *   This function feeds an input buffer into an ongoing CMAC computation.
   1505           *   It is called between sl_se_cmac_starts() and sl_se_cmac_finish().
   1506           *   Can be called repeatedly.
   1507           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1508          sl_status_t sl_se_cmac_multipart_update(sl_se_cmac_multipart_context_t *cmac_ctx,
   1509                                                  sl_se_command_context_t *cmd_ctx,
   1510                                                  const sl_se_key_descriptor_t *key,
   1511                                                  const uint8_t *input,
   1512                                                  size_t input_len)
   1513          {
   \                     sl_se_cmac_multipart_update: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB09D             SUB      SP,SP,#+116
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0xF8DD 0xA0A0      LDR      R10,[SP, #+160]
   1514            sl_status_t status = SL_STATUS_OK;
   \        0xE   0x2600             MOVS     R6,#+0
   1515          
   1516            if (cmac_ctx == NULL || cmd_ctx == NULL || key == NULL || input == NULL) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD007             BEQ.N    ??sl_se_cmac_multipart_update_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD005             BEQ.N    ??sl_se_cmac_multipart_update_0
   \       0x18   0x981D             LDR      R0,[SP, #+116]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD002             BEQ.N    ??sl_se_cmac_multipart_update_0
   \       0x1E   0x981E             LDR      R0,[SP, #+120]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??sl_se_cmac_multipart_update_1
   1517              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_cmac_multipart_update_0: (+1)
   \       0x24   0x2021             MOVS     R0,#+33
   \       0x26   0xE0D6             B.N      ??sl_se_cmac_multipart_update_2
   1518            }
   1519          
   1520            size_t pending = cmac_ctx->length & 0xFU;
   \                     ??sl_se_cmac_multipart_update_1: (+1)
   \       0x28   0xF894 0x8030      LDRB     R8,[R4, #+48]
   \       0x2C   0xF018 0x080F      ANDS     R8,R8,#0xF
   1521          
   1522            if ((cmac_ctx->length / 16U) != ((cmac_ctx->length + input_len) / 16U)) {
   \       0x30   0x6B21             LDR      R1,[R4, #+48]
   \       0x32   0x0909             LSRS     R1,R1,#+4
   \       0x34   0x6B20             LDR      R0,[R4, #+48]
   \       0x36   0xEB1A 0x0000      ADDS     R0,R10,R0
   \       0x3A   0xEBB1 0x1F10      CMP      R1,R0, LSR #+4
   \       0x3E   0xF000 0x80B9      BEQ.W    ??sl_se_cmac_multipart_update_3
   1523              // Process one or more 16 byte blocks.
   1524              size_t bytes_to_process = (pending + input_len) & 0xFFFFFFF0U;
   \       0x42   0xEB1A 0x0908      ADDS     R9,R10,R8
   \       0x46   0xEA5F 0x1919      LSRS     R9,R9,#+4
   \       0x4A   0xEA5F 0x1909      LSLS     R9,R9,#+4
   1525          
   1526              SE_Command_t *se_cmd = &cmd_ctx->command;
   \       0x4E   0x9500             STR      R5,[SP, #+0]
   1527              sli_se_command_init(cmd_ctx,
   1528                                  SLI_SE_COMMAND_AES_ENCRYPT
   1529                                  | SLI_SE_COMMAND_OPTION_MODE_CBC
   1530                                  | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \       0x54   0x6028             STR      R0,[R5, #+0]
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x6068             STR      R0,[R5, #+4]
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x60A8             STR      R0,[R5, #+8]
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x61E8             STR      R0,[R5, #+28]
   1531          
   1532              // Add key parameters to command.
   1533              sli_add_key_parameters(cmd_ctx, key, status);
   \       0x62   0xA902             ADD      R1,SP,#+8
   \       0x64   0x981D             LDR      R0,[SP, #+116]
   \       0x66   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x6A   0x0007             MOVS     R7,R0
   \       0x6C   0x2F00             CMP      R7,#+0
   \       0x6E   0xD001             BEQ.N    ??sl_se_cmac_multipart_update_4
   \       0x70   0x0038             MOVS     R0,R7
   \       0x72   0xE0B0             B.N      ??sl_se_cmac_multipart_update_2
   \                     ??sl_se_cmac_multipart_update_4: (+1)
   \       0x74   0x9902             LDR      R1,[SP, #+8]
   \       0x76   0x0028             MOVS     R0,R5
   \       0x78   0x.... 0x....      BL       SE_addParameter
   1534              // Message size (number of bytes)
   1535              SE_addParameter(se_cmd, bytes_to_process);
   \       0x7C   0x4649             MOV      R1,R9
   \       0x7E   0x9800             LDR      R0,[SP, #+0]
   \       0x80   0x.... 0x....      BL       SE_addParameter
   1536          
   1537              // Add key metadata block to command.
   1538              sli_add_key_metadata(cmd_ctx, key, status);
   \       0x84   0xA91A             ADD      R1,SP,#+104
   \       0x86   0x981D             LDR      R0,[SP, #+116]
   \       0x88   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x8C   0x0006             MOVS     R6,R0
   \       0x8E   0x2E00             CMP      R6,#+0
   \       0x90   0xD001             BEQ.N    ??sl_se_cmac_multipart_update_5
   \       0x92   0x0030             MOVS     R0,R6
   \       0x94   0xE09F             B.N      ??sl_se_cmac_multipart_update_2
   \                     ??sl_se_cmac_multipart_update_5: (+1)
   \       0x96   0xA91A             ADD      R1,SP,#+104
   \       0x98   0x0028             MOVS     R0,R5
   \       0x9A   0x.... 0x....      BL       SE_addDataInput
   1539              // Add key input block to command.
   1540              sli_add_key_input(cmd_ctx, key, status);
   \       0x9E   0xA917             ADD      R1,SP,#+92
   \       0xA0   0x981D             LDR      R0,[SP, #+116]
   \       0xA2   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xA6   0x0007             MOVS     R7,R0
   \       0xA8   0x2F00             CMP      R7,#+0
   \       0xAA   0xD001             BEQ.N    ??sl_se_cmac_multipart_update_6
   \       0xAC   0x0038             MOVS     R0,R7
   \       0xAE   0xE092             B.N      ??sl_se_cmac_multipart_update_2
   \                     ??sl_se_cmac_multipart_update_6: (+1)
   \       0xB0   0xA917             ADD      R1,SP,#+92
   \       0xB2   0x0028             MOVS     R0,R5
   \       0xB4   0x.... 0x....      BL       SE_addDataInput
   1541          
   1542              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(cmac_ctx->state, 16U);
   \       0xB8   0xAE14             ADD      R6,SP,#+80
   \       0xBA   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \       0xBE   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xC2   0xE886 0x000E      STM      R6,{R1-R3}
   \       0xC6   0x9414             STR      R4,[SP, #+80]
   1543              SE_addDataInput(se_cmd, &iv_in);
   \       0xC8   0xA914             ADD      R1,SP,#+80
   \       0xCA   0x9800             LDR      R0,[SP, #+0]
   \       0xCC   0x.... 0x....      BL       SE_addDataInput
   1544          
   1545              // Data input, collect data from two sources.
   1546              SE_DataTransfer_t in1 = SE_DATATRANSFER_DEFAULT(cmac_ctx->data_in, pending);
   \       0xD0   0xAE08             ADD      R6,SP,#+32
   \       0xD2   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \       0xD6   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xDA   0xE886 0x000E      STM      R6,{R1-R3}
   \       0xDE   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0xE2   0x9008             STR      R0,[SP, #+32]
   \       0xE4   0xF058 0x5000      ORRS     R0,R8,#0x20000000
   \       0xE8   0x900A             STR      R0,[SP, #+40]
   1547              SE_DataTransfer_t in2 = SE_DATATRANSFER_DEFAULT(input, bytes_to_process - pending);
   \       0xEA   0xAE0B             ADD      R6,SP,#+44
   \       0xEC   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \       0xF0   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xF4   0xE886 0x000E      STM      R6,{R1-R3}
   \       0xF8   0x981E             LDR      R0,[SP, #+120]
   \       0xFA   0x900B             STR      R0,[SP, #+44]
   \       0xFC   0xEBB9 0x0008      SUBS     R0,R9,R8
   \      0x100   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x104   0x900D             STR      R0,[SP, #+52]
   1548              in1.length &= ~SE_DATATRANSFER_REALIGN;
   \      0x106   0x980A             LDR      R0,[SP, #+40]
   \      0x108   0xF030 0x5000      BICS     R0,R0,#0x20000000
   \      0x10C   0x900A             STR      R0,[SP, #+40]
   1549              SE_addDataInput(se_cmd, &in1);
   \      0x10E   0xA908             ADD      R1,SP,#+32
   \      0x110   0x9800             LDR      R0,[SP, #+0]
   \      0x112   0x.... 0x....      BL       SE_addDataInput
   1550              SE_addDataInput(se_cmd, &in2);
   \      0x116   0xA90B             ADD      R1,SP,#+44
   \      0x118   0x9800             LDR      R0,[SP, #+0]
   \      0x11A   0x.... 0x....      BL       SE_addDataInput
   1551          
   1552              // Data output, discard everything except the last 16 bytes.
   1553              SE_DataTransfer_t out1 = SE_DATATRANSFER_DEFAULT(NULL, bytes_to_process - 16U);
   \      0x11E   0xAE03             ADD      R6,SP,#+12
   \      0x120   0x.... 0x....      LDR.W    R0,??DataTable16_10
   \      0x124   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x128   0xE886 0x000E      STM      R6,{R1-R3}
   \      0x12C   0xF1B9 0x0010      SUBS     R0,R9,#+16
   \      0x130   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x134   0x9005             STR      R0,[SP, #+20]
   1554              SE_DataTransfer_t out2 = SE_DATATRANSFER_DEFAULT(cmac_ctx->data_out, 16U);
   \      0x136   0xAE11             ADD      R6,SP,#+68
   \      0x138   0x.... 0x....      LDR.W    R0,??DataTable16_11
   \      0x13C   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x140   0xE886 0x000E      STM      R6,{R1-R3}
   \      0x144   0xF114 0x0020      ADDS     R0,R4,#+32
   \      0x148   0x9011             STR      R0,[SP, #+68]
   1555              out1.length |= SE_DATATRANSFER_DISCARD;
   \      0x14A   0x9805             LDR      R0,[SP, #+20]
   \      0x14C   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x150   0x9005             STR      R0,[SP, #+20]
   1556              out1.length &= ~SE_DATATRANSFER_REALIGN;
   \      0x152   0x9805             LDR      R0,[SP, #+20]
   \      0x154   0xF030 0x5000      BICS     R0,R0,#0x20000000
   \      0x158   0x9005             STR      R0,[SP, #+20]
   1557              SE_addDataOutput(se_cmd, &out1);
   \      0x15A   0xA903             ADD      R1,SP,#+12
   \      0x15C   0x9800             LDR      R0,[SP, #+0]
   \      0x15E   0x.... 0x....      BL       SE_addDataOutput
   1558              SE_addDataOutput(se_cmd, &out2);
   \      0x162   0xA911             ADD      R1,SP,#+68
   \      0x164   0x9800             LDR      R0,[SP, #+0]
   \      0x166   0x.... 0x....      BL       SE_addDataOutput
   1559          
   1560              SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(cmac_ctx->state, 16U);
   \      0x16A   0xAB0E             ADD      R3,SP,#+56
   \      0x16C   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \      0x170   0xE890 0x0046      LDM      R0,{R1,R2,R6}
   \      0x174   0xE883 0x0046      STM      R3,{R1,R2,R6}
   \      0x178   0x940E             STR      R4,[SP, #+56]
   1561              SE_addDataOutput(se_cmd, &iv_out);
   \      0x17A   0xA90E             ADD      R1,SP,#+56
   \      0x17C   0x9800             LDR      R0,[SP, #+0]
   \      0x17E   0x.... 0x....      BL       SE_addDataOutput
   1562          
   1563              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x182   0x0028             MOVS     R0,R5
   \      0x184   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x188   0x0006             MOVS     R6,R0
   1564          
   1565              // Store leftover data.
   1566              size_t leftover = pending + input_len - bytes_to_process;
   \      0x18A   0xEB1A 0x0008      ADDS     R0,R10,R8
   \      0x18E   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x192   0x9001             STR      R0,[SP, #+4]
   1567              memcpy(cmac_ctx->data_in, input + input_len - leftover, leftover);
   \      0x194   0x9801             LDR      R0,[SP, #+4]
   \      0x196   0x9007             STR      R0,[SP, #+28]
   \      0x198   0x981E             LDR      R0,[SP, #+120]
   \      0x19A   0x4450             ADD      R0,R0,R10
   \      0x19C   0x9901             LDR      R1,[SP, #+4]
   \      0x19E   0x4249             RSBS     R1,R1,#+0
   \      0x1A0   0x4408             ADD      R0,R0,R1
   \      0x1A2   0x9006             STR      R0,[SP, #+24]
   \      0x1A4   0xF114 0x0B10      ADDS     R11,R4,#+16
   \      0x1A8   0x9A07             LDR      R2,[SP, #+28]
   \      0x1AA   0x9906             LDR      R1,[SP, #+24]
   \      0x1AC   0x4658             MOV      R0,R11
   \      0x1AE   0x.... 0x....      BL       __aeabi_memcpy
   1568            } else {
   \      0x1B2   0xE00B             B.N      ??sl_se_cmac_multipart_update_7
   1569              // Not a complete 16 byte block yet, save input data for later.
   1570              memcpy(cmac_ctx->data_in + pending, input, input_len);
   \                     ??sl_se_cmac_multipart_update_3: (+1)
   \      0x1B4   0x4657             MOV      R7,R10
   \      0x1B6   0x981E             LDR      R0,[SP, #+120]
   \      0x1B8   0x9000             STR      R0,[SP, #+0]
   \      0x1BA   0xEB04 0x0008      ADD      R0,R4,R8
   \      0x1BE   0xF110 0x0910      ADDS     R9,R0,#+16
   \      0x1C2   0x003A             MOVS     R2,R7
   \      0x1C4   0x9900             LDR      R1,[SP, #+0]
   \      0x1C6   0x4648             MOV      R0,R9
   \      0x1C8   0x.... 0x....      BL       __aeabi_memcpy
   1571            }
   1572            cmac_ctx->length += input_len;
   \                     ??sl_se_cmac_multipart_update_7: (+1)
   \      0x1CC   0x6B20             LDR      R0,[R4, #+48]
   \      0x1CE   0xEB1A 0x0000      ADDS     R0,R10,R0
   \      0x1D2   0x6320             STR      R0,[R4, #+48]
   1573            return status;
   \      0x1D4   0x0030             MOVS     R0,R6
   \                     ??sl_se_cmac_multipart_update_2: (+1)
   \      0x1D6   0xB01F             ADD      SP,SP,#+124
   \      0x1D8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1574          }

   \                                 In section .rodata, align 4
   \                     ?_49:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_50:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_51:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_52:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_53:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_54:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1575          
   1576          /***************************************************************************//**
   1577           *   Compute a HMAC on a full message.
   1578           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1579          sl_status_t sl_se_hmac(sl_se_command_context_t *cmd_ctx,
   1580                                 const sl_se_key_descriptor_t *key,
   1581                                 sl_se_hash_type_t hash_type,
   1582                                 const uint8_t *message,
   1583                                 size_t message_len,
   1584                                 uint8_t *output,
   1585                                 size_t output_len)
   1586          {
   \                     sl_se_hmac: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB08E             SUB      SP,SP,#+56
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0xF8DD 0xB068      LDR      R11,[SP, #+104]
   \        0xE   0x9E1B             LDR      R6,[SP, #+108]
   1587            if (cmd_ctx == NULL || key == NULL || message == NULL || output == NULL) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD006             BEQ.N    ??sl_se_hmac_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD004             BEQ.N    ??sl_se_hmac_0
   \       0x18   0x9810             LDR      R0,[SP, #+64]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??sl_se_hmac_0
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD101             BNE.N    ??sl_se_hmac_1
   1588              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_hmac_0: (+1)
   \       0x22   0x2021             MOVS     R0,#+33
   \       0x24   0xE086             B.N      ??sl_se_hmac_2
   1589            }
   1590          
   1591            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_hmac_1: (+1)
   \       0x26   0x9400             STR      R4,[SP, #+0]
   1592            sl_status_t status = SL_STATUS_OK;
   \       0x28   0xF05F 0x0800      MOVS     R8,#+0
   1593            uint32_t command_word;
   1594            size_t hmac_len;
   1595          
   1596            switch (hash_type) {
   \       0x2C   0xF89D 0x003C      LDRB     R0,[SP, #+60]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD007             BEQ.N    ??sl_se_hmac_3
   \       0x34   0xD31F             BCC.N    ??sl_se_hmac_4
   \       0x36   0x2803             CMP      R0,#+3
   \       0x38   0xD00E             BEQ.N    ??sl_se_hmac_5
   \       0x3A   0xD308             BCC.N    ??sl_se_hmac_6
   \       0x3C   0x2805             CMP      R0,#+5
   \       0x3E   0xD015             BEQ.N    ??sl_se_hmac_7
   \       0x40   0xD30F             BCC.N    ??sl_se_hmac_8
   \       0x42   0xE018             B.N      ??sl_se_hmac_4
   1597              case SL_SE_HASH_SHA1:
   1598                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA1;
   \                     ??sl_se_hmac_3: (+1)
   \       0x44   0x.... 0x....      LDR.W    R9,??DataTable16_13
   1599                // SHA1 digest size is 20 bytes
   1600                hmac_len = 20;
   \       0x48   0xF05F 0x0A14      MOVS     R10,#+20
   1601                break;
   \       0x4C   0xE015             B.N      ??sl_se_hmac_9
   1602          
   1603              case SL_SE_HASH_SHA224:
   1604                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA224;
   \                     ??sl_se_hmac_6: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R9,??DataTable16_14
   1605                // SHA224 digest size is 28 bytes
   1606                hmac_len = 28;
   \       0x52   0xF05F 0x0A1C      MOVS     R10,#+28
   1607                break;
   \       0x56   0xE010             B.N      ??sl_se_hmac_9
   1608          
   1609              case SL_SE_HASH_SHA256:
   1610                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA256;
   \                     ??sl_se_hmac_5: (+1)
   \       0x58   0x.... 0x....      LDR.W    R9,??DataTable16_15
   1611                // SHA256 digest size is 32 bytes
   1612                hmac_len = 32;
   \       0x5C   0xF05F 0x0A20      MOVS     R10,#+32
   1613                break;
   \       0x60   0xE00B             B.N      ??sl_se_hmac_9
   1614          
   1615          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
   1616              case SL_SE_HASH_SHA384:
   1617                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA384;
   \                     ??sl_se_hmac_8: (+1)
   \       0x62   0x.... 0x....      LDR.W    R9,??DataTable16_16
   1618                // SHA384 digest size is 48 bytes
   1619                hmac_len = 48;
   \       0x66   0xF05F 0x0A30      MOVS     R10,#+48
   1620                break;
   \       0x6A   0xE006             B.N      ??sl_se_hmac_9
   1621          
   1622              case SL_SE_HASH_SHA512:
   1623                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA512;
   \                     ??sl_se_hmac_7: (+1)
   \       0x6C   0x.... 0x....      LDR.W    R9,??DataTable16_17
   1624                // SHA512 digest size is 64 bytes
   1625                hmac_len = 64;
   \       0x70   0xF05F 0x0A40      MOVS     R10,#+64
   1626                break;
   \       0x74   0xE001             B.N      ??sl_se_hmac_9
   1627          
   1628          #endif
   1629              default:
   1630                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_hmac_4: (+1)
   \       0x76   0x2021             MOVS     R0,#+33
   \       0x78   0xE05C             B.N      ??sl_se_hmac_2
   1631            }
   1632          
   1633            if (output_len < hmac_len) {
   \                     ??sl_se_hmac_9: (+1)
   \       0x7A   0x981C             LDR      R0,[SP, #+112]
   \       0x7C   0x4550             CMP      R0,R10
   \       0x7E   0xD201             BCS.N    ??sl_se_hmac_10
   1634              return SL_STATUS_INVALID_PARAMETER;
   \       0x80   0x2021             MOVS     R0,#+33
   \       0x82   0xE057             B.N      ??sl_se_hmac_2
   1635            }
   1636          
   1637            sli_se_command_init(cmd_ctx, command_word);
   \                     ??sl_se_hmac_10: (+1)
   \       0x84   0xF8C4 0x9000      STR      R9,[R4, #+0]
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0x6060             STR      R0,[R4, #+4]
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x60A0             STR      R0,[R4, #+8]
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x61E0             STR      R0,[R4, #+28]
   1638          
   1639            // Add key parameter to command.
   1640            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x94   0xA901             ADD      R1,SP,#+4
   \       0x96   0x0028             MOVS     R0,R5
   \       0x98   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x9C   0x0007             MOVS     R7,R0
   \       0x9E   0x2F00             CMP      R7,#+0
   \       0xA0   0xD001             BEQ.N    ??sl_se_hmac_11
   \       0xA2   0x0038             MOVS     R0,R7
   \       0xA4   0xE046             B.N      ??sl_se_hmac_2
   \                     ??sl_se_hmac_11: (+1)
   \       0xA6   0x9901             LDR      R1,[SP, #+4]
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x.... 0x....      BL       SE_addParameter
   1641          
   1642            // Message size parameter.
   1643            SE_addParameter(se_cmd, message_len);
   \       0xAE   0x4659             MOV      R1,R11
   \       0xB0   0x9800             LDR      R0,[SP, #+0]
   \       0xB2   0x.... 0x....      BL       SE_addParameter
   1644          
   1645            // Key metadata.
   1646            sli_add_key_metadata(cmd_ctx, key, status);
   \       0xB6   0xA90B             ADD      R1,SP,#+44
   \       0xB8   0x0028             MOVS     R0,R5
   \       0xBA   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xBE   0x4680             MOV      R8,R0
   \       0xC0   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xC4   0xD001             BEQ.N    ??sl_se_hmac_12
   \       0xC6   0x4640             MOV      R0,R8
   \       0xC8   0xE034             B.N      ??sl_se_hmac_2
   \                     ??sl_se_hmac_12: (+1)
   \       0xCA   0xA90B             ADD      R1,SP,#+44
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0x.... 0x....      BL       SE_addDataInput
   1647          
   1648            sli_add_key_input(cmd_ctx, key, status);
   \       0xD2   0xA908             ADD      R1,SP,#+32
   \       0xD4   0x0028             MOVS     R0,R5
   \       0xD6   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xDA   0x0007             MOVS     R7,R0
   \       0xDC   0x2F00             CMP      R7,#+0
   \       0xDE   0xD001             BEQ.N    ??sl_se_hmac_13
   \       0xE0   0x0038             MOVS     R0,R7
   \       0xE2   0xE027             B.N      ??sl_se_hmac_2
   \                     ??sl_se_hmac_13: (+1)
   \       0xE4   0xA908             ADD      R1,SP,#+32
   \       0xE6   0x0020             MOVS     R0,R4
   \       0xE8   0x.... 0x....      BL       SE_addDataInput
   1649          
   1650            // Data input.
   1651            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(message, message_len);
   \       0xEC   0xF10D 0x0C14      ADD      R12,SP,#+20
   \       0xF0   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0xF4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xF8   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xFC   0x9810             LDR      R0,[SP, #+64]
   \       0xFE   0x9005             STR      R0,[SP, #+20]
   \      0x100   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \      0x104   0x9007             STR      R0,[SP, #+28]
   1652            SE_addDataInput(se_cmd, &in_data);
   \      0x106   0xA905             ADD      R1,SP,#+20
   \      0x108   0x9800             LDR      R0,[SP, #+0]
   \      0x10A   0x.... 0x....      BL       SE_addDataInput
   1653          
   1654            // Data output.
   1655            SE_DataTransfer_t out_hmac = SE_DATATRANSFER_DEFAULT(output, hmac_len);
   \      0x10E   0xF10D 0x0C08      ADD      R12,SP,#+8
   \      0x112   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \      0x116   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x11A   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x11E   0x9602             STR      R6,[SP, #+8]
   \      0x120   0xF05A 0x5000      ORRS     R0,R10,#0x20000000
   \      0x124   0x9004             STR      R0,[SP, #+16]
   1656            SE_addDataOutput(se_cmd, &out_hmac);
   \      0x126   0xA902             ADD      R1,SP,#+8
   \      0x128   0x9800             LDR      R0,[SP, #+0]
   \      0x12A   0x.... 0x....      BL       SE_addDataOutput
   1657          
   1658            return sli_se_execute_and_wait(cmd_ctx);
   \      0x12E   0x0020             MOVS     R0,R4
   \      0x130   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_hmac_2: (+1)
   \      0x134   0xB011             ADD      SP,SP,#+68
   \      0x136   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1659          }

   \                                 In section .rodata, align 4
   \                     ?_55:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_56:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1660          
   1661          /***************************************************************************//**
   1662           * GCM buffer encryption or decryption.
   1663           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1664          sl_status_t sl_se_gcm_crypt_and_tag(sl_se_command_context_t *cmd_ctx,
   1665                                              const sl_se_key_descriptor_t *key,
   1666                                              sl_se_cipher_operation_t mode,
   1667                                              size_t length,
   1668                                              const unsigned char *iv,
   1669                                              size_t iv_len,
   1670                                              const unsigned char *add,
   1671                                              size_t add_len,
   1672                                              const unsigned char *input,
   1673                                              unsigned char *output,
   1674                                              size_t tag_len,
   1675                                              unsigned char *tag)
   1676          {
   \                     sl_se_gcm_crypt_and_tag: (+1)
   \        0x0   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \        0x4   0xB0B1             SUB      SP,SP,#+196
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0x9C41             LDR      R4,[SP, #+260]
   1677            // Check input parameters.
   1678            if (cmd_ctx == NULL || key == NULL || iv == NULL || tag == NULL
   1679                || ((add_len > 0) && (add == NULL))
   1680                || ((length > 0) && (input == NULL || output == NULL))
   1681                || ((tag_len < 4) || (tag_len > 16))) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD01A             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD018             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \       0x16   0x983C             LDR      R0,[SP, #+240]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD015             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \       0x1C   0x9843             LDR      R0,[SP, #+268]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD012             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \       0x22   0x983F             LDR      R0,[SP, #+252]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD002             BEQ.N    ??sl_se_gcm_crypt_and_tag_1
   \       0x28   0x983E             LDR      R0,[SP, #+248]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD00C             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \                     ??sl_se_gcm_crypt_and_tag_1: (+1)
   \       0x2E   0x2F00             CMP      R7,#+0
   \       0x30   0xD004             BEQ.N    ??sl_se_gcm_crypt_and_tag_2
   \       0x32   0x9840             LDR      R0,[SP, #+256]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD007             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD005             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \                     ??sl_se_gcm_crypt_and_tag_2: (+1)
   \       0x3C   0x9842             LDR      R0,[SP, #+264]
   \       0x3E   0x2804             CMP      R0,#+4
   \       0x40   0xD302             BCC.N    ??sl_se_gcm_crypt_and_tag_0
   \       0x42   0x9842             LDR      R0,[SP, #+264]
   \       0x44   0x2811             CMP      R0,#+17
   \       0x46   0xD301             BCC.N    ??sl_se_gcm_crypt_and_tag_3
   1682              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_crypt_and_tag_0: (+1)
   \       0x48   0x2021             MOVS     R0,#+33
   \       0x4A   0xE17A             B.N      ??sl_se_gcm_crypt_and_tag_4
   1683            }
   1684          
   1685            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_gcm_crypt_and_tag_3: (+1)
   \       0x4C   0x46AA             MOV      R10,R5
   1686            uint8_t tagbuf[16];
   1687            sl_status_t status = SL_STATUS_OK;
   \       0x4E   0xF05F 0x0800      MOVS     R8,#+0
   1688          
   1689            if (// IV length is required to be 96 bits for SE.
   1690              (iv_len != 96 / 8)
   1691              // AD is limited to 2^64 bits, so 2^61 bytes.
   1692              // However, on 32 bit platforms, that amount of continous data cannot be
   1693              // available.
   1694              // || (((uint64_t)add_len) >> 61 != 0)
   1695              ) {
   \       0x52   0x983D             LDR      R0,[SP, #+244]
   \       0x54   0x280C             CMP      R0,#+12
   \       0x56   0xD001             BEQ.N    ??sl_se_gcm_crypt_and_tag_5
   1696              return SL_STATUS_INVALID_PARAMETER;
   \       0x58   0x2021             MOVS     R0,#+33
   \       0x5A   0xE172             B.N      ??sl_se_gcm_crypt_and_tag_4
   1697            }
   1698            switch (key->type) {
   \                     ??sl_se_gcm_crypt_and_tag_5: (+1)
   \       0x5C   0x6830             LDR      R0,[R6, #+0]
   \       0x5E   0x2810             CMP      R0,#+16
   \       0x60   0xD003             BEQ.N    ??sl_se_gcm_crypt_and_tag_6
   \       0x62   0x2818             CMP      R0,#+24
   \       0x64   0xD001             BEQ.N    ??sl_se_gcm_crypt_and_tag_6
   \       0x66   0x2820             CMP      R0,#+32
   \       0x68   0xD105             BNE.N    ??sl_se_gcm_crypt_and_tag_7
   1699              case SL_SE_KEY_TYPE_AES_128:
   1700              case SL_SE_KEY_TYPE_AES_192:
   1701              case SL_SE_KEY_TYPE_AES_256:
   1702                break;
   1703          
   1704              default:
   1705                return SL_STATUS_INVALID_PARAMETER;
   1706            }
   1707          
   1708            if (mode == SL_SE_DECRYPT) {
   \                     ??sl_se_gcm_crypt_and_tag_6: (+1)
   \       0x6A   0xF89D 0x00C8      LDRB     R0,[SP, #+200]
   \       0x6E   0x2801             CMP      R0,#+1
   \       0x70   0xF040 0x80B7      BNE.W    ??sl_se_gcm_crypt_and_tag_8
   \       0x74   0xE001             B.N      ??sl_se_gcm_crypt_and_tag_9
   \                     ??sl_se_gcm_crypt_and_tag_7: (+1)
   \       0x76   0x2021             MOVS     R0,#+33
   \       0x78   0xE163             B.N      ??sl_se_gcm_crypt_and_tag_4
   1709              // Extract plaintext first.
   1710              sli_se_command_init(cmd_ctx,
   1711                                  SLI_SE_COMMAND_AES_GCM_DECRYPT | ((tag_len & 0xFF) << 8));
   \                     ??sl_se_gcm_crypt_and_tag_9: (+1)
   \       0x7A   0x9942             LDR      R1,[SP, #+264]
   \       0x7C   0x0209             LSLS     R1,R1,#+8
   \       0x7E   0xF411 0x417F      ANDS     R1,R1,#0xFF00
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \       0x86   0x4301             ORRS     R1,R0,R1
   \       0x88   0x6029             STR      R1,[R5, #+0]
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0x6068             STR      R0,[R5, #+4]
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0x60A8             STR      R0,[R5, #+8]
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x61E8             STR      R0,[R5, #+28]
   1712          
   1713              sli_add_key_parameters(cmd_ctx, key, status);
   \       0x96   0xA901             ADD      R1,SP,#+4
   \       0x98   0x0030             MOVS     R0,R6
   \       0x9A   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x9E   0x4681             MOV      R9,R0
   \       0xA0   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xA4   0xD001             BEQ.N    ??sl_se_gcm_crypt_and_tag_10
   \       0xA6   0x4648             MOV      R0,R9
   \       0xA8   0xE14B             B.N      ??sl_se_gcm_crypt_and_tag_4
   \                     ??sl_se_gcm_crypt_and_tag_10: (+1)
   \       0xAA   0x9901             LDR      R1,[SP, #+4]
   \       0xAC   0x0028             MOVS     R0,R5
   \       0xAE   0x.... 0x....      BL       SE_addParameter
   1714              SE_addParameter(se_cmd, add_len);
   \       0xB2   0x993F             LDR      R1,[SP, #+252]
   \       0xB4   0x4650             MOV      R0,R10
   \       0xB6   0x.... 0x....      BL       SE_addParameter
   1715              SE_addParameter(se_cmd, length);
   \       0xBA   0x0039             MOVS     R1,R7
   \       0xBC   0x4650             MOV      R0,R10
   \       0xBE   0x.... 0x....      BL       SE_addParameter
   1716          
   1717              sli_add_key_metadata(cmd_ctx, key, status);
   \       0xC2   0xA924             ADD      R1,SP,#+144
   \       0xC4   0x0030             MOVS     R0,R6
   \       0xC6   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xCA   0x4680             MOV      R8,R0
   \       0xCC   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xD0   0xD001             BEQ.N    ??sl_se_gcm_crypt_and_tag_11
   \       0xD2   0x4640             MOV      R0,R8
   \       0xD4   0xE135             B.N      ??sl_se_gcm_crypt_and_tag_4
   \                     ??sl_se_gcm_crypt_and_tag_11: (+1)
   \       0xD6   0xA924             ADD      R1,SP,#+144
   \       0xD8   0x0028             MOVS     R0,R5
   \       0xDA   0x.... 0x....      BL       SE_addDataInput
   1718              sli_add_key_input(cmd_ctx, key, status);
   \       0xDE   0xA921             ADD      R1,SP,#+132
   \       0xE0   0x0030             MOVS     R0,R6
   \       0xE2   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xE6   0x4681             MOV      R9,R0
   \       0xE8   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xEC   0xD001             BEQ.N    ??sl_se_gcm_crypt_and_tag_12
   \       0xEE   0x4648             MOV      R0,R9
   \       0xF0   0xE127             B.N      ??sl_se_gcm_crypt_and_tag_4
   \                     ??sl_se_gcm_crypt_and_tag_12: (+1)
   \       0xF2   0xA921             ADD      R1,SP,#+132
   \       0xF4   0x0028             MOVS     R0,R5
   \       0xF6   0x.... 0x....      BL       SE_addDataInput
   1719          
   1720              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \       0xFA   0xAB1B             ADD      R3,SP,#+108
   \       0xFC   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \      0x100   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x104   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x108   0x983C             LDR      R0,[SP, #+240]
   \      0x10A   0x901B             STR      R0,[SP, #+108]
   \      0x10C   0x983D             LDR      R0,[SP, #+244]
   \      0x10E   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x112   0x901D             STR      R0,[SP, #+116]
   1721              SE_addDataInput(se_cmd, &iv_in);
   \      0x114   0xA91B             ADD      R1,SP,#+108
   \      0x116   0x4650             MOV      R0,R10
   \      0x118   0x.... 0x....      BL       SE_addDataInput
   1722          
   1723              SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \      0x11C   0xF10D 0x0C60      ADD      R12,SP,#+96
   \      0x120   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \      0x124   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x128   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x12C   0x983E             LDR      R0,[SP, #+248]
   \      0x12E   0x9018             STR      R0,[SP, #+96]
   \      0x130   0x983F             LDR      R0,[SP, #+252]
   \      0x132   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x136   0x901A             STR      R0,[SP, #+104]
   1724              SE_addDataInput(se_cmd, &aad_in);
   \      0x138   0xA918             ADD      R1,SP,#+96
   \      0x13A   0x4650             MOV      R0,R10
   \      0x13C   0x.... 0x....      BL       SE_addDataInput
   1725          
   1726              SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \      0x140   0xF10D 0x0C54      ADD      R12,SP,#+84
   \      0x144   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \      0x148   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x14C   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x150   0x9840             LDR      R0,[SP, #+256]
   \      0x152   0x9015             STR      R0,[SP, #+84]
   \      0x154   0xF057 0x5000      ORRS     R0,R7,#0x20000000
   \      0x158   0x9017             STR      R0,[SP, #+92]
   1727              SE_addDataInput(se_cmd, &data_in);
   \      0x15A   0xA915             ADD      R1,SP,#+84
   \      0x15C   0x4650             MOV      R0,R10
   \      0x15E   0x.... 0x....      BL       SE_addDataInput
   1728          
   1729              SE_DataTransfer_t tag_in = SE_DATATRANSFER_DEFAULT(tag, tag_len);
   \      0x162   0xF10D 0x0C48      ADD      R12,SP,#+72
   \      0x166   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \      0x16A   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x16E   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x172   0x9843             LDR      R0,[SP, #+268]
   \      0x174   0x9012             STR      R0,[SP, #+72]
   \      0x176   0x9842             LDR      R0,[SP, #+264]
   \      0x178   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x17C   0x9014             STR      R0,[SP, #+80]
   1730              SE_addDataInput(se_cmd, &tag_in);
   \      0x17E   0xA912             ADD      R1,SP,#+72
   \      0x180   0x4650             MOV      R0,R10
   \      0x182   0x.... 0x....      BL       SE_addDataInput
   1731          
   1732              SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x186   0xF10D 0x0C18      ADD      R12,SP,#+24
   \      0x18A   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \      0x18E   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x192   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x196   0x9406             STR      R4,[SP, #+24]
   \      0x198   0xF057 0x5000      ORRS     R0,R7,#0x20000000
   \      0x19C   0x9008             STR      R0,[SP, #+32]
   1733              if (output == NULL) {
   \      0x19E   0x2C00             CMP      R4,#+0
   \      0x1A0   0xD103             BNE.N    ??sl_se_gcm_crypt_and_tag_13
   1734                data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x1A2   0x9808             LDR      R0,[SP, #+32]
   \      0x1A4   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x1A8   0x9008             STR      R0,[SP, #+32]
   1735              }
   1736              SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_gcm_crypt_and_tag_13: (+1)
   \      0x1AA   0xA906             ADD      R1,SP,#+24
   \      0x1AC   0x4650             MOV      R0,R10
   \      0x1AE   0x.... 0x....      BL       SE_addDataOutput
   1737          
   1738              // Execute GCM operation.
   1739              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x1B2   0x0028             MOVS     R0,R5
   \      0x1B4   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x1B8   0x4680             MOV      R8,R0
   1740              if ((status != SL_STATUS_OK) && (status != SL_STATUS_INVALID_SIGNATURE)) {
   \      0x1BA   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x1BE   0xD00D             BEQ.N    ??sl_se_gcm_crypt_and_tag_14
   \      0x1C0   0xF1B8 0x0F2C      CMP      R8,#+44
   \      0x1C4   0xD00A             BEQ.N    ??sl_se_gcm_crypt_and_tag_14
   1741                memset(output, 0, length);
   \      0x1C6   0x9702             STR      R7,[SP, #+8]
   \      0x1C8   0xF05F 0x0B00      MOVS     R11,#+0
   \      0x1CC   0x46A1             MOV      R9,R4
   \      0x1CE   0x465A             MOV      R2,R11
   \      0x1D0   0x9902             LDR      R1,[SP, #+8]
   \      0x1D2   0x4648             MOV      R0,R9
   \      0x1D4   0x.... 0x....      BL       __aeabi_memset
   1742                return status;
   \      0x1D8   0x4640             MOV      R0,R8
   \      0x1DA   0xE0B2             B.N      ??sl_se_gcm_crypt_and_tag_4
   1743              }
   1744          
   1745              // Re-encrypt the extracted plaintext to generate the tag to match.
   1746              input = output;
   \                     ??sl_se_gcm_crypt_and_tag_14: (+1)
   \      0x1DC   0x9440             STR      R4,[SP, #+256]
   1747              output = NULL;
   \      0x1DE   0x2000             MOVS     R0,#+0
   \      0x1E0   0x0004             MOVS     R4,R0
   1748            }
   1749          
   1750            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_GCM_ENCRYPT);
   \                     ??sl_se_gcm_crypt_and_tag_8: (+1)
   \      0x1E2   0x.... 0x....      LDR.W    R0,??DataTable17_8
   \      0x1E6   0x6028             STR      R0,[R5, #+0]
   \      0x1E8   0x2000             MOVS     R0,#+0
   \      0x1EA   0x6068             STR      R0,[R5, #+4]
   \      0x1EC   0x2000             MOVS     R0,#+0
   \      0x1EE   0x60A8             STR      R0,[R5, #+8]
   \      0x1F0   0x2000             MOVS     R0,#+0
   \      0x1F2   0x61E8             STR      R0,[R5, #+28]
   1751          
   1752            sli_add_key_parameters(cmd_ctx, key, status);
   \      0x1F4   0x4669             MOV      R1,SP
   \      0x1F6   0x0030             MOVS     R0,R6
   \      0x1F8   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x1FC   0x4681             MOV      R9,R0
   \      0x1FE   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x202   0xD001             BEQ.N    ??sl_se_gcm_crypt_and_tag_15
   \      0x204   0x4648             MOV      R0,R9
   \      0x206   0xE09C             B.N      ??sl_se_gcm_crypt_and_tag_4
   \                     ??sl_se_gcm_crypt_and_tag_15: (+1)
   \      0x208   0x9900             LDR      R1,[SP, #+0]
   \      0x20A   0x0028             MOVS     R0,R5
   \      0x20C   0x.... 0x....      BL       SE_addParameter
   1753            SE_addParameter(se_cmd, add_len);
   \      0x210   0x993F             LDR      R1,[SP, #+252]
   \      0x212   0x4650             MOV      R0,R10
   \      0x214   0x.... 0x....      BL       SE_addParameter
   1754            SE_addParameter(se_cmd, length);
   \      0x218   0x0039             MOVS     R1,R7
   \      0x21A   0x4650             MOV      R0,R10
   \      0x21C   0x.... 0x....      BL       SE_addParameter
   1755          
   1756            sli_add_key_metadata(cmd_ctx, key, status);
   \      0x220   0xA92A             ADD      R1,SP,#+168
   \      0x222   0x0030             MOVS     R0,R6
   \      0x224   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x228   0x4680             MOV      R8,R0
   \      0x22A   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x22E   0xD001             BEQ.N    ??sl_se_gcm_crypt_and_tag_16
   \      0x230   0x4640             MOV      R0,R8
   \      0x232   0xE086             B.N      ??sl_se_gcm_crypt_and_tag_4
   \                     ??sl_se_gcm_crypt_and_tag_16: (+1)
   \      0x234   0xA92A             ADD      R1,SP,#+168
   \      0x236   0x0028             MOVS     R0,R5
   \      0x238   0x.... 0x....      BL       SE_addDataInput
   1757            sli_add_key_input(cmd_ctx, key, status);
   \      0x23C   0xA927             ADD      R1,SP,#+156
   \      0x23E   0x0030             MOVS     R0,R6
   \      0x240   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x244   0x4681             MOV      R9,R0
   \      0x246   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x24A   0xD001             BEQ.N    ??sl_se_gcm_crypt_and_tag_17
   \      0x24C   0x4648             MOV      R0,R9
   \      0x24E   0xE078             B.N      ??sl_se_gcm_crypt_and_tag_4
   \                     ??sl_se_gcm_crypt_and_tag_17: (+1)
   \      0x250   0xA927             ADD      R1,SP,#+156
   \      0x252   0x0028             MOVS     R0,R5
   \      0x254   0x.... 0x....      BL       SE_addDataInput
   1758          
   1759            SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \      0x258   0xF10D 0x0C3C      ADD      R12,SP,#+60
   \      0x25C   0x.... 0x....      LDR.W    R0,??DataTable18
   \      0x260   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x264   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x268   0x983C             LDR      R0,[SP, #+240]
   \      0x26A   0x900F             STR      R0,[SP, #+60]
   \      0x26C   0x983D             LDR      R0,[SP, #+244]
   \      0x26E   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x272   0x9011             STR      R0,[SP, #+68]
   1760            SE_addDataInput(se_cmd, &iv_in);
   \      0x274   0xA90F             ADD      R1,SP,#+60
   \      0x276   0x4650             MOV      R0,R10
   \      0x278   0x.... 0x....      BL       SE_addDataInput
   1761          
   1762            SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \      0x27C   0xF10D 0x0C30      ADD      R12,SP,#+48
   \      0x280   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \      0x284   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x288   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x28C   0x983E             LDR      R0,[SP, #+248]
   \      0x28E   0x900C             STR      R0,[SP, #+48]
   \      0x290   0x983F             LDR      R0,[SP, #+252]
   \      0x292   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x296   0x900E             STR      R0,[SP, #+56]
   1763            SE_addDataInput(se_cmd, &aad_in);
   \      0x298   0xA90C             ADD      R1,SP,#+48
   \      0x29A   0x4650             MOV      R0,R10
   \      0x29C   0x.... 0x....      BL       SE_addDataInput
   1764          
   1765            SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \      0x2A0   0xAB09             ADD      R3,SP,#+36
   \      0x2A2   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \      0x2A6   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x2AA   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x2AE   0x9840             LDR      R0,[SP, #+256]
   \      0x2B0   0x9009             STR      R0,[SP, #+36]
   \      0x2B2   0xF057 0x5000      ORRS     R0,R7,#0x20000000
   \      0x2B6   0x900B             STR      R0,[SP, #+44]
   1766            SE_addDataInput(se_cmd, &data_in);
   \      0x2B8   0xA909             ADD      R1,SP,#+36
   \      0x2BA   0x4650             MOV      R0,R10
   \      0x2BC   0x.... 0x....      BL       SE_addDataInput
   1767          
   1768            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x2C0   0xF10D 0x0C0C      ADD      R12,SP,#+12
   \      0x2C4   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \      0x2C8   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x2CC   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x2D0   0x9403             STR      R4,[SP, #+12]
   \      0x2D2   0xF057 0x5000      ORRS     R0,R7,#0x20000000
   \      0x2D6   0x9005             STR      R0,[SP, #+20]
   1769            if (output == NULL) {
   \      0x2D8   0x2C00             CMP      R4,#+0
   \      0x2DA   0xD103             BNE.N    ??sl_se_gcm_crypt_and_tag_18
   1770              data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x2DC   0x9805             LDR      R0,[SP, #+20]
   \      0x2DE   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x2E2   0x9005             STR      R0,[SP, #+20]
   1771            }
   1772            SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_gcm_crypt_and_tag_18: (+1)
   \      0x2E4   0xA903             ADD      R1,SP,#+12
   \      0x2E6   0x4650             MOV      R0,R10
   \      0x2E8   0x.... 0x....      BL       SE_addDataOutput
   1773          
   1774            SE_DataTransfer_t mac_out = SE_DATATRANSFER_DEFAULT(tagbuf, sizeof(tagbuf));
   \      0x2EC   0xF10D 0x0C78      ADD      R12,SP,#+120
   \      0x2F0   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \      0x2F4   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x2F8   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x2FC   0xA82D             ADD      R0,SP,#+180
   \      0x2FE   0x901E             STR      R0,[SP, #+120]
   1775            SE_addDataOutput(se_cmd, &mac_out);
   \      0x300   0xA91E             ADD      R1,SP,#+120
   \      0x302   0x4650             MOV      R0,R10
   \      0x304   0x.... 0x....      BL       SE_addDataOutput
   1776          
   1777            // Execute GCM operation.
   1778            status = sli_se_execute_and_wait(cmd_ctx);
   \      0x308   0x0028             MOVS     R0,R5
   \      0x30A   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x30E   0x4680             MOV      R8,R0
   1779            if (status == SL_STATUS_OK) {
   \      0x310   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x314   0xD10B             BNE.N    ??sl_se_gcm_crypt_and_tag_19
   1780              // For encryption, copy requested tag size to output tag buffer.
   1781              memcpy(tag, tagbuf, tag_len);
   \      0x316   0x9842             LDR      R0,[SP, #+264]
   \      0x318   0x9002             STR      R0,[SP, #+8]
   \      0x31A   0xF10D 0x0BB4      ADD      R11,SP,#+180
   \      0x31E   0xF8DD 0x910C      LDR      R9,[SP, #+268]
   \      0x322   0x9A02             LDR      R2,[SP, #+8]
   \      0x324   0x4659             MOV      R1,R11
   \      0x326   0x4648             MOV      R0,R9
   \      0x328   0x.... 0x....      BL       __aeabi_memcpy
   1782            } else {
   \      0x32C   0xE008             B.N      ??sl_se_gcm_crypt_and_tag_20
   1783              memset(output, 0, length);
   \                     ??sl_se_gcm_crypt_and_tag_19: (+1)
   \      0x32E   0x9702             STR      R7,[SP, #+8]
   \      0x330   0xF05F 0x0B00      MOVS     R11,#+0
   \      0x334   0x46A1             MOV      R9,R4
   \      0x336   0x465A             MOV      R2,R11
   \      0x338   0x9902             LDR      R1,[SP, #+8]
   \      0x33A   0x4648             MOV      R0,R9
   \      0x33C   0x.... 0x....      BL       __aeabi_memset
   1784            }
   1785          
   1786            return status;
   \                     ??sl_se_gcm_crypt_and_tag_20: (+1)
   \      0x340   0x4640             MOV      R0,R8
   \                     ??sl_se_gcm_crypt_and_tag_4: (+1)
   \      0x342   0xB033             ADD      SP,SP,#+204
   \      0x344   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1787          }

   \                                 In section .rodata, align 4
   \                     ?_57:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_58:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_59:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_60:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_61:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_62:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_63:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_64:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_65:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_66:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1788          
   1789          /***************************************************************************//**
   1790           * GCM buffer decryption and authentication.
   1791           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1792          sl_status_t sl_se_gcm_auth_decrypt(sl_se_command_context_t *cmd_ctx,
   1793                                             const sl_se_key_descriptor_t *key,
   1794                                             size_t length,
   1795                                             const unsigned char *iv,
   1796                                             size_t iv_len,
   1797                                             const unsigned char *add,
   1798                                             size_t add_len,
   1799                                             const unsigned char *input,
   1800                                             unsigned char *output,
   1801                                             size_t tag_len,
   1802                                             const unsigned char *tag)
   1803          {
   \                     sl_se_gcm_auth_decrypt: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB099             SUB      SP,SP,#+100
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0xF8DD 0x8098      LDR      R8,[SP, #+152]
   \       0x10   0x9C28             LDR      R4,[SP, #+160]
   \       0x12   0xF8DD 0xB0A4      LDR      R11,[SP, #+164]
   1804            // Check input parameters.
   1805            if (cmd_ctx == NULL || key == NULL || iv == NULL || tag == NULL
   1806                || ((add_len > 0) && (add == NULL))
   1807                || ((length > 0) && (input == NULL || output == NULL))
   1808                || ((tag_len < 4) || (tag_len > 16))) {
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD01A             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD018             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \       0x1E   0x981A             LDR      R0,[SP, #+104]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD015             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \       0x24   0x982A             LDR      R0,[SP, #+168]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD012             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \       0x2A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x2E   0xD002             BEQ.N    ??sl_se_gcm_auth_decrypt_1
   \       0x30   0x9825             LDR      R0,[SP, #+148]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD00C             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \                     ??sl_se_gcm_auth_decrypt_1: (+1)
   \       0x36   0x2F00             CMP      R7,#+0
   \       0x38   0xD004             BEQ.N    ??sl_se_gcm_auth_decrypt_2
   \       0x3A   0x9827             LDR      R0,[SP, #+156]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD007             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD005             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \                     ??sl_se_gcm_auth_decrypt_2: (+1)
   \       0x44   0xF1BB 0x0F04      CMP      R11,#+4
   \       0x48   0xD302             BCC.N    ??sl_se_gcm_auth_decrypt_0
   \       0x4A   0xF1BB 0x0F11      CMP      R11,#+17
   \       0x4E   0xD301             BCC.N    ??sl_se_gcm_auth_decrypt_3
   1809              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_auth_decrypt_0: (+1)
   \       0x50   0x2021             MOVS     R0,#+33
   \       0x52   0xE0BC             B.N      ??sl_se_gcm_auth_decrypt_4
   1810            }
   1811          
   1812            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_gcm_auth_decrypt_3: (+1)
   \       0x54   0x9500             STR      R5,[SP, #+0]
   1813            sl_status_t status = SL_STATUS_OK;
   \       0x56   0xF05F 0x0A00      MOVS     R10,#+0
   1814          
   1815            if (// IV length is required to be 96 bits for SE.
   1816              (iv_len != 96 / 8)
   1817              // AD is limited to 2^64 bits, so 2^61 bytes.
   1818              // However, on 32 bit platforms, that amount of continous data cannot be
   1819              // available.
   1820              // || (((uint64_t)add_len) >> 61 != 0)
   1821              ) {
   \       0x5A   0x9824             LDR      R0,[SP, #+144]
   \       0x5C   0x280C             CMP      R0,#+12
   \       0x5E   0xD001             BEQ.N    ??sl_se_gcm_auth_decrypt_5
   1822              return SL_STATUS_INVALID_PARAMETER;
   \       0x60   0x2021             MOVS     R0,#+33
   \       0x62   0xE0B4             B.N      ??sl_se_gcm_auth_decrypt_4
   1823            }
   1824            switch (key->type) {
   \                     ??sl_se_gcm_auth_decrypt_5: (+1)
   \       0x64   0x6830             LDR      R0,[R6, #+0]
   \       0x66   0x2810             CMP      R0,#+16
   \       0x68   0xD003             BEQ.N    ??sl_se_gcm_auth_decrypt_6
   \       0x6A   0x2818             CMP      R0,#+24
   \       0x6C   0xD001             BEQ.N    ??sl_se_gcm_auth_decrypt_6
   \       0x6E   0x2820             CMP      R0,#+32
   \       0x70   0xD116             BNE.N    ??sl_se_gcm_auth_decrypt_7
   1825              case SL_SE_KEY_TYPE_AES_128: // Fallthrough
   1826              case SL_SE_KEY_TYPE_AES_192: // Fallthrough
   1827              case SL_SE_KEY_TYPE_AES_256:
   1828                break;
   1829          
   1830              default:
   1831                return SL_STATUS_INVALID_PARAMETER;
   1832            }
   1833          
   1834            sli_se_command_init(cmd_ctx,
   1835                                SLI_SE_COMMAND_AES_GCM_DECRYPT | ((tag_len & 0xFF) << 8));
   \                     ??sl_se_gcm_auth_decrypt_6: (+1)
   \       0x72   0xEA5F 0x210B      LSLS     R1,R11,#+8
   \       0x76   0xF411 0x417F      ANDS     R1,R1,#0xFF00
   \       0x7A   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \       0x7E   0x4301             ORRS     R1,R0,R1
   \       0x80   0x6029             STR      R1,[R5, #+0]
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x6068             STR      R0,[R5, #+4]
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x60A8             STR      R0,[R5, #+8]
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0x61E8             STR      R0,[R5, #+28]
   1836          
   1837            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x8E   0xA901             ADD      R1,SP,#+4
   \       0x90   0x0030             MOVS     R0,R6
   \       0x92   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x96   0x4681             MOV      R9,R0
   \       0x98   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x9C   0xD102             BNE.N    ??sl_se_gcm_auth_decrypt_8
   \       0x9E   0xE003             B.N      ??sl_se_gcm_auth_decrypt_9
   \                     ??sl_se_gcm_auth_decrypt_7: (+1)
   \       0xA0   0x2021             MOVS     R0,#+33
   \       0xA2   0xE094             B.N      ??sl_se_gcm_auth_decrypt_4
   \                     ??sl_se_gcm_auth_decrypt_8: (+1)
   \       0xA4   0x4648             MOV      R0,R9
   \       0xA6   0xE092             B.N      ??sl_se_gcm_auth_decrypt_4
   \                     ??sl_se_gcm_auth_decrypt_9: (+1)
   \       0xA8   0x9901             LDR      R1,[SP, #+4]
   \       0xAA   0x0028             MOVS     R0,R5
   \       0xAC   0x.... 0x....      BL       SE_addParameter
   1838            SE_addParameter(se_cmd, add_len);
   \       0xB0   0x4641             MOV      R1,R8
   \       0xB2   0x9800             LDR      R0,[SP, #+0]
   \       0xB4   0x.... 0x....      BL       SE_addParameter
   1839            SE_addParameter(se_cmd, length);
   \       0xB8   0x0039             MOVS     R1,R7
   \       0xBA   0x9800             LDR      R0,[SP, #+0]
   \       0xBC   0x.... 0x....      BL       SE_addParameter
   1840          
   1841            sli_add_key_metadata(cmd_ctx, key, status);
   \       0xC0   0xA916             ADD      R1,SP,#+88
   \       0xC2   0x0030             MOVS     R0,R6
   \       0xC4   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xC8   0x4682             MOV      R10,R0
   \       0xCA   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xCE   0xD001             BEQ.N    ??sl_se_gcm_auth_decrypt_10
   \       0xD0   0x4650             MOV      R0,R10
   \       0xD2   0xE07C             B.N      ??sl_se_gcm_auth_decrypt_4
   \                     ??sl_se_gcm_auth_decrypt_10: (+1)
   \       0xD4   0xA916             ADD      R1,SP,#+88
   \       0xD6   0x0028             MOVS     R0,R5
   \       0xD8   0x.... 0x....      BL       SE_addDataInput
   1842            sli_add_key_input(cmd_ctx, key, status);
   \       0xDC   0xA913             ADD      R1,SP,#+76
   \       0xDE   0x0030             MOVS     R0,R6
   \       0xE0   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xE4   0x4681             MOV      R9,R0
   \       0xE6   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xEA   0xD001             BEQ.N    ??sl_se_gcm_auth_decrypt_11
   \       0xEC   0x4648             MOV      R0,R9
   \       0xEE   0xE06E             B.N      ??sl_se_gcm_auth_decrypt_4
   \                     ??sl_se_gcm_auth_decrypt_11: (+1)
   \       0xF0   0xA913             ADD      R1,SP,#+76
   \       0xF2   0x0028             MOVS     R0,R5
   \       0xF4   0x.... 0x....      BL       SE_addDataInput
   1843          
   1844            SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \       0xF8   0xF10D 0x0C40      ADD      R12,SP,#+64
   \       0xFC   0x.... 0x....      LDR.W    R0,??DataTable19
   \      0x100   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x104   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x108   0x981A             LDR      R0,[SP, #+104]
   \      0x10A   0x9010             STR      R0,[SP, #+64]
   \      0x10C   0x9824             LDR      R0,[SP, #+144]
   \      0x10E   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x112   0x9012             STR      R0,[SP, #+72]
   1845            SE_addDataInput(se_cmd, &iv_in);
   \      0x114   0xA910             ADD      R1,SP,#+64
   \      0x116   0x9800             LDR      R0,[SP, #+0]
   \      0x118   0x.... 0x....      BL       SE_addDataInput
   1846          
   1847            SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \      0x11C   0xF10D 0x0C34      ADD      R12,SP,#+52
   \      0x120   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \      0x124   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x128   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x12C   0x9825             LDR      R0,[SP, #+148]
   \      0x12E   0x900D             STR      R0,[SP, #+52]
   \      0x130   0xF058 0x5000      ORRS     R0,R8,#0x20000000
   \      0x134   0x900F             STR      R0,[SP, #+60]
   1848            SE_addDataInput(se_cmd, &aad_in);
   \      0x136   0xA90D             ADD      R1,SP,#+52
   \      0x138   0x9800             LDR      R0,[SP, #+0]
   \      0x13A   0x.... 0x....      BL       SE_addDataInput
   1849          
   1850            SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \      0x13E   0xF10D 0x0C28      ADD      R12,SP,#+40
   \      0x142   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \      0x146   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x14A   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x14E   0x9827             LDR      R0,[SP, #+156]
   \      0x150   0x900A             STR      R0,[SP, #+40]
   \      0x152   0xF057 0x5000      ORRS     R0,R7,#0x20000000
   \      0x156   0x900C             STR      R0,[SP, #+48]
   1851            SE_addDataInput(se_cmd, &data_in);
   \      0x158   0xA90A             ADD      R1,SP,#+40
   \      0x15A   0x9800             LDR      R0,[SP, #+0]
   \      0x15C   0x.... 0x....      BL       SE_addDataInput
   1852          
   1853            SE_DataTransfer_t tag_in = SE_DATATRANSFER_DEFAULT(tag, tag_len);
   \      0x160   0xAB07             ADD      R3,SP,#+28
   \      0x162   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \      0x166   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x16A   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x16E   0x982A             LDR      R0,[SP, #+168]
   \      0x170   0x9007             STR      R0,[SP, #+28]
   \      0x172   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \      0x176   0x9009             STR      R0,[SP, #+36]
   1854            SE_addDataInput(se_cmd, &tag_in);
   \      0x178   0xA907             ADD      R1,SP,#+28
   \      0x17A   0x9800             LDR      R0,[SP, #+0]
   \      0x17C   0x.... 0x....      BL       SE_addDataInput
   1855          
   1856            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x180   0xF10D 0x0C10      ADD      R12,SP,#+16
   \      0x184   0x.... 0x....      LDR.W    R0,??DataTable20
   \      0x188   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x18C   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x190   0x9404             STR      R4,[SP, #+16]
   \      0x192   0xF057 0x5000      ORRS     R0,R7,#0x20000000
   \      0x196   0x9006             STR      R0,[SP, #+24]
   1857            if (output == NULL) {
   \      0x198   0x2C00             CMP      R4,#+0
   \      0x19A   0xD103             BNE.N    ??sl_se_gcm_auth_decrypt_12
   1858              data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x19C   0x9806             LDR      R0,[SP, #+24]
   \      0x19E   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x1A2   0x9006             STR      R0,[SP, #+24]
   1859            }
   1860            SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_gcm_auth_decrypt_12: (+1)
   \      0x1A4   0xA904             ADD      R1,SP,#+16
   \      0x1A6   0x9800             LDR      R0,[SP, #+0]
   \      0x1A8   0x.... 0x....      BL       SE_addDataOutput
   1861          
   1862            // Execute GCM operation.
   1863            status = sli_se_execute_and_wait(cmd_ctx);
   \      0x1AC   0x0028             MOVS     R0,R5
   \      0x1AE   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x1B2   0x4682             MOV      R10,R0
   1864          
   1865            if (status != SL_STATUS_OK) {
   \      0x1B4   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x1B8   0xD008             BEQ.N    ??sl_se_gcm_auth_decrypt_13
   1866              memset(output, 0, length);
   \      0x1BA   0x9703             STR      R7,[SP, #+12]
   \      0x1BC   0x2000             MOVS     R0,#+0
   \      0x1BE   0x9002             STR      R0,[SP, #+8]
   \      0x1C0   0x46A1             MOV      R9,R4
   \      0x1C2   0x9A02             LDR      R2,[SP, #+8]
   \      0x1C4   0x9903             LDR      R1,[SP, #+12]
   \      0x1C6   0x4648             MOV      R0,R9
   \      0x1C8   0x.... 0x....      BL       __aeabi_memset
   1867            }
   1868          
   1869            return status;
   \                     ??sl_se_gcm_auth_decrypt_13: (+1)
   \      0x1CC   0x4650             MOV      R0,R10
   \                     ??sl_se_gcm_auth_decrypt_4: (+1)
   \      0x1CE   0xB01B             ADD      SP,SP,#+108
   \      0x1D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1870          }

   \                                 In section .rodata, align 4
   \                     ?_67:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_68:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_69:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_70:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_71:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1871          
   1872          #if defined(SLI_SE_MAJOR_VERSION_TWO)
   1873          /***************************************************************************//**
   1874           * GCM  multipart encryption/decryption, initial stage.
   1875           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1876          sl_status_t sl_se_gcm_multipart_starts(sl_se_gcm_multipart_context_t *gcm_ctx,
   1877                                                 sl_se_command_context_t *cmd_ctx,
   1878                                                 const sl_se_key_descriptor_t *key,
   1879                                                 sl_se_cipher_operation_t mode,
   1880                                                 const uint8_t *iv,
   1881                                                 size_t iv_len,
   1882                                                 const uint8_t *add,
   1883                                                 size_t add_len)
   1884          {
   \                     sl_se_gcm_multipart_starts: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB093             SUB      SP,SP,#+76
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0xF8DD 0x907C      LDR      R9,[SP, #+124]
   \       0x10   0x9C21             LDR      R4,[SP, #+132]
   1885            sl_status_t status = SL_STATUS_OK;
   \       0x12   0xF05F 0x0800      MOVS     R8,#+0
   1886          
   1887            // Check input parameters.
   1888            if (gcm_ctx == NULL || cmd_ctx == NULL || key == NULL || iv == NULL
   1889                || (add_len > 0 && add == NULL)) {
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD00B             BEQ.N    ??sl_se_gcm_multipart_starts_0
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD009             BEQ.N    ??sl_se_gcm_multipart_starts_0
   \       0x1E   0x2F00             CMP      R7,#+0
   \       0x20   0xD007             BEQ.N    ??sl_se_gcm_multipart_starts_0
   \       0x22   0x981E             LDR      R0,[SP, #+120]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD004             BEQ.N    ??sl_se_gcm_multipart_starts_0
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD004             BEQ.N    ??sl_se_gcm_multipart_starts_1
   \       0x2C   0x9820             LDR      R0,[SP, #+128]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD101             BNE.N    ??sl_se_gcm_multipart_starts_1
   1890              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_multipart_starts_0: (+1)
   \       0x32   0x2021             MOVS     R0,#+33
   \       0x34   0xE0B8             B.N      ??sl_se_gcm_multipart_starts_2
   1891            }
   1892            if ((iv_len != 12)
   1893                // AD are limited to 2^64 bits, so 2^61 bytes.
   1894                // However, on 32 bit platforms, that amount of continous data cannot be
   1895                // available.
   1896                // || (((uint64_t)add_len) >> 61 != 0)
   1897                ) {
   \                     ??sl_se_gcm_multipart_starts_1: (+1)
   \       0x36   0xF1B9 0x0F0C      CMP      R9,#+12
   \       0x3A   0xD001             BEQ.N    ??sl_se_gcm_multipart_starts_3
   1898              return SL_STATUS_INVALID_PARAMETER;
   \       0x3C   0x2021             MOVS     R0,#+33
   \       0x3E   0xE0B3             B.N      ??sl_se_gcm_multipart_starts_2
   1899            }
   1900          
   1901            memset(gcm_ctx, 0, sizeof(sl_se_gcm_multipart_context_t));
   \                     ??sl_se_gcm_multipart_starts_3: (+1)
   \       0x40   0x2048             MOVS     R0,#+72
   \       0x42   0x9002             STR      R0,[SP, #+8]
   \       0x44   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x48   0x46AB             MOV      R11,R5
   \       0x4A   0x4652             MOV      R2,R10
   \       0x4C   0x9902             LDR      R1,[SP, #+8]
   \       0x4E   0x4658             MOV      R0,R11
   \       0x50   0x.... 0x....      BL       __aeabi_memset
   1902          
   1903            gcm_ctx->mode = mode;
   \       0x54   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \       0x58   0xF885 0x0041      STRB     R0,[R5, #+65]
   1904            gcm_ctx->len = 0;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0xE9C5 0x0100      STRD     R0,R1,[R5, #+0]
   1905            gcm_ctx->add_len = add_len;
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0xE9C5 0x0102      STRD     R0,R1,[R5, #+8]
   1906          
   1907            SE_Command_t *se_cmd = &cmd_ctx->command;
   \       0x6C   0x9600             STR      R6,[SP, #+0]
   1908          
   1909            // The start context requires some data, either additional data or input data.
   1910            // Case add_len > 0: Run start command with additonal data to create ctx_out.
   1911            // Case add_len = 0: Store iv in gcm_ctx and run start function with input data
   1912            // in sl_se_gcm_multipart_update. In the case of zero input data or
   1913            // input data < 16 run sl_se_gcm_auth_decrypt()/sl_se_gcm_crypt_and_tag() in
   1914            // sl_se_gcm_multipart_finish.
   1915            if ( add_len > 0 ) {
   \       0x6E   0x2C00             CMP      R4,#+0
   \       0x70   0xF000 0x808B      BEQ.W    ??sl_se_gcm_multipart_starts_4
   1916              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \       0x74   0xF10D 0x0C1C      ADD      R12,SP,#+28
   \       0x78   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x7C   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x80   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x84   0x981E             LDR      R0,[SP, #+120]
   \       0x86   0x9007             STR      R0,[SP, #+28]
   \       0x88   0xF059 0x5000      ORRS     R0,R9,#0x20000000
   \       0x8C   0x9009             STR      R0,[SP, #+36]
   1917              SE_DataTransfer_t add_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \       0x8E   0xAB04             ADD      R3,SP,#+16
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \       0x94   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0x98   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0x9C   0x9820             LDR      R0,[SP, #+128]
   \       0x9E   0x9004             STR      R0,[SP, #+16]
   \       0xA0   0xF054 0x5000      ORRS     R0,R4,#0x20000000
   \       0xA4   0x9006             STR      R0,[SP, #+24]
   1918              SE_DataTransfer_t ctx_out =
   1919                SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   \       0xA6   0xAB0A             ADD      R3,SP,#+40
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \       0xAC   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xB0   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xB4   0xF115 0x0010      ADDS     R0,R5,#+16
   \       0xB8   0x900A             STR      R0,[SP, #+40]
   1920          
   1921              sli_se_command_init(cmd_ctx,
   1922                                  (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   1923                                   : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   1924                                  | SLI_SE_COMMAND_OPTION_CONTEXT_START);
   \       0xBA   0xF895 0x0041      LDRB     R0,[R5, #+65]
   \       0xBE   0x2801             CMP      R0,#+1
   \       0xC0   0xD102             BNE.N    ??sl_se_gcm_multipart_starts_5
   \       0xC2   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \       0xC6   0xE001             B.N      ??sl_se_gcm_multipart_starts_6
   \                     ??sl_se_gcm_multipart_starts_5: (+1)
   \       0xC8   0x.... 0x....      LDR.W    R0,??DataTable17_8
   \                     ??sl_se_gcm_multipart_starts_6: (+1)
   \       0xCC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xD0   0x6030             STR      R0,[R6, #+0]
   \       0xD2   0x2000             MOVS     R0,#+0
   \       0xD4   0x6070             STR      R0,[R6, #+4]
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x60B0             STR      R0,[R6, #+8]
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0x61F0             STR      R0,[R6, #+28]
   1925          
   1926              sli_add_key_parameters(cmd_ctx, key, status);
   \       0xDE   0xA901             ADD      R1,SP,#+4
   \       0xE0   0x0038             MOVS     R0,R7
   \       0xE2   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xE6   0x4682             MOV      R10,R0
   \       0xE8   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xEC   0xD001             BEQ.N    ??sl_se_gcm_multipart_starts_7
   \       0xEE   0x4650             MOV      R0,R10
   \       0xF0   0xE05A             B.N      ??sl_se_gcm_multipart_starts_2
   \                     ??sl_se_gcm_multipart_starts_7: (+1)
   \       0xF2   0x9901             LDR      R1,[SP, #+4]
   \       0xF4   0x0030             MOVS     R0,R6
   \       0xF6   0x.... 0x....      BL       SE_addParameter
   1927              SE_addParameter(se_cmd, add_len);
   \       0xFA   0x0021             MOVS     R1,R4
   \       0xFC   0x9800             LDR      R0,[SP, #+0]
   \       0xFE   0x.... 0x....      BL       SE_addParameter
   1928              SE_addParameter(se_cmd, 0);
   \      0x102   0x2100             MOVS     R1,#+0
   \      0x104   0x9800             LDR      R0,[SP, #+0]
   \      0x106   0x.... 0x....      BL       SE_addParameter
   1929          
   1930              sli_add_key_metadata(cmd_ctx, key, status);
   \      0x10A   0xA910             ADD      R1,SP,#+64
   \      0x10C   0x0038             MOVS     R0,R7
   \      0x10E   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x112   0x4680             MOV      R8,R0
   \      0x114   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x118   0xD001             BEQ.N    ??sl_se_gcm_multipart_starts_8
   \      0x11A   0x4640             MOV      R0,R8
   \      0x11C   0xE044             B.N      ??sl_se_gcm_multipart_starts_2
   \                     ??sl_se_gcm_multipart_starts_8: (+1)
   \      0x11E   0xA910             ADD      R1,SP,#+64
   \      0x120   0x0030             MOVS     R0,R6
   \      0x122   0x.... 0x....      BL       SE_addDataInput
   1931              sli_add_key_input(cmd_ctx, key, status);
   \      0x126   0xA90D             ADD      R1,SP,#+52
   \      0x128   0x0038             MOVS     R0,R7
   \      0x12A   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x12E   0x4682             MOV      R10,R0
   \      0x130   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x134   0xD001             BEQ.N    ??sl_se_gcm_multipart_starts_9
   \      0x136   0x4650             MOV      R0,R10
   \      0x138   0xE036             B.N      ??sl_se_gcm_multipart_starts_2
   \                     ??sl_se_gcm_multipart_starts_9: (+1)
   \      0x13A   0xA90D             ADD      R1,SP,#+52
   \      0x13C   0x0030             MOVS     R0,R6
   \      0x13E   0x.... 0x....      BL       SE_addDataInput
   1932          
   1933              SE_addDataInput(se_cmd, &iv_in);
   \      0x142   0xA907             ADD      R1,SP,#+28
   \      0x144   0x9800             LDR      R0,[SP, #+0]
   \      0x146   0x.... 0x....      BL       SE_addDataInput
   1934              SE_addDataInput(se_cmd, &add_in);
   \      0x14A   0xA904             ADD      R1,SP,#+16
   \      0x14C   0x9800             LDR      R0,[SP, #+0]
   \      0x14E   0x.... 0x....      BL       SE_addDataInput
   1935              SE_addDataOutput(se_cmd, &ctx_out);
   \      0x152   0xA90A             ADD      R1,SP,#+40
   \      0x154   0x9800             LDR      R0,[SP, #+0]
   \      0x156   0x.... 0x....      BL       SE_addDataOutput
   1936          
   1937              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x15A   0x0030             MOVS     R0,R6
   \      0x15C   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x160   0x4680             MOV      R8,R0
   1938              if (status != SL_STATUS_OK) {
   \      0x162   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x166   0xD00C             BEQ.N    ??sl_se_gcm_multipart_starts_10
   1939                memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   \      0x168   0x2020             MOVS     R0,#+32
   \      0x16A   0x9002             STR      R0,[SP, #+8]
   \      0x16C   0xF05F 0x0A00      MOVS     R10,#+0
   \      0x170   0xF115 0x0B10      ADDS     R11,R5,#+16
   \      0x174   0x4652             MOV      R2,R10
   \      0x176   0x9902             LDR      R1,[SP, #+8]
   \      0x178   0x4658             MOV      R0,R11
   \      0x17A   0x.... 0x....      BL       __aeabi_memset
   1940                return status;
   \      0x17E   0x4640             MOV      R0,R8
   \      0x180   0xE012             B.N      ??sl_se_gcm_multipart_starts_2
   1941              }
   1942              gcm_ctx->first_operation = false;
   \                     ??sl_se_gcm_multipart_starts_10: (+1)
   \      0x182   0x2000             MOVS     R0,#+0
   \      0x184   0xF885 0x0042      STRB     R0,[R5, #+66]
   \      0x188   0xE00D             B.N      ??sl_se_gcm_multipart_starts_11
   1943            } else {
   1944              memcpy(gcm_ctx->se_ctx, iv, iv_len);
   \                     ??sl_se_gcm_multipart_starts_4: (+1)
   \      0x18A   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \      0x18E   0x981E             LDR      R0,[SP, #+120]
   \      0x190   0x9002             STR      R0,[SP, #+8]
   \      0x192   0xF115 0x0A10      ADDS     R10,R5,#+16
   \      0x196   0x9A03             LDR      R2,[SP, #+12]
   \      0x198   0x9902             LDR      R1,[SP, #+8]
   \      0x19A   0x4650             MOV      R0,R10
   \      0x19C   0x.... 0x....      BL       __aeabi_memcpy
   1945              gcm_ctx->first_operation = true;
   \      0x1A0   0x2001             MOVS     R0,#+1
   \      0x1A2   0xF885 0x0042      STRB     R0,[R5, #+66]
   1946            }
   1947            return SL_STATUS_OK;
   \                     ??sl_se_gcm_multipart_starts_11: (+1)
   \      0x1A6   0x2000             MOVS     R0,#+0
   \                     ??sl_se_gcm_multipart_starts_2: (+1)
   \      0x1A8   0xB015             ADD      SP,SP,#+84
   \      0x1AA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1948          }

   \                                 In section .rodata, align 4
   \                     ?_72:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_73:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_74:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020
   1949          
   1950          #else
   1951          /***************************************************************************//**
   1952           * GCM  multipart encryption/decryption, initial stage.
   1953           ******************************************************************************/
   1954          sl_status_t sl_se_gcm_multipart_starts(sl_se_gcm_multipart_context_t *gcm_ctx,
   1955                                                 sl_se_command_context_t *cmd_ctx,
   1956                                                 const sl_se_key_descriptor_t *key,
   1957                                                 sl_se_cipher_operation_t mode,
   1958                                                 const uint8_t *iv,
   1959                                                 size_t iv_len,
   1960                                                 const uint8_t *add,
   1961                                                 size_t add_len)
   1962          {
   1963            sl_status_t status = SL_STATUS_OK;
   1964          
   1965            // Check input parameters.
   1966            if (gcm_ctx == NULL || cmd_ctx == NULL || key == NULL || iv == NULL
   1967                || (add_len > 0 && add == NULL)) {
   1968              return SL_STATUS_INVALID_PARAMETER;
   1969            }
   1970            if ((iv_len != 12)
   1971                // AD are limited to 2^64 bits, so 2^61 bytes.
   1972                // However, on 32 bit platforms, that amount of continous data cannot be
   1973                // available.
   1974                // || (((uint64_t)add_len) >> 61 != 0)
   1975                ) {
   1976              return SL_STATUS_INVALID_PARAMETER;
   1977            }
   1978          
   1979            memset(gcm_ctx, 0, sizeof(sl_se_gcm_multipart_context_t));
   1980          
   1981            gcm_ctx->mode = mode;
   1982            gcm_ctx->len = 0;
   1983            gcm_ctx->add_len = add_len;
   1984          
   1985            // The start context requires some data, either additional data or input data.
   1986            // Case add_len > 0: Run start command with additonal data to create ctx_out.
   1987            // Case add_len = 0: Store iv in gcm_ctx and run start function with input data
   1988            // in sl_se_gcm_multipart_update. In the case of zero input data or
   1989            // input data < 16 run sl_se_gcm_auth_decrypt()/sl_se_gcm_crypt_and_tag() in
   1990            // sl_se_gcm_multipart_finish.
   1991            if ( add_len > 0 ) {
   1992              // Encrypt: Compute tag and store it in context and output tag in finish.
   1993              // Decrypt: Compute tag and store it in context and compare it to the
   1994              // input tag in finish to verify it.
   1995          
   1996              // Explanation:The end-context in finish is currently not supporting 0 input data
   1997              // for this config. For add_len = 0 and input_length = 0 we can run
   1998              // sl_se_gcm_auth_decrypt()/sl_se_gcm_crypt_and_tag() in finish, so this is only
   1999              // an issue for 0 input data and add_len != 0.
   2000              SE_Command_t *se_cmd = &cmd_ctx->command;
   2001              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   2002              SE_DataTransfer_t add_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   2003              SE_DataTransfer_t tag_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->tagbuf,
   2004                                                                  sizeof(gcm_ctx->tagbuf));
   2005              sli_se_command_init(cmd_ctx,
   2006                                  SLI_SE_COMMAND_AES_GCM_ENCRYPT
   2007                                  | SLI_SE_COMMAND_OPTION_CONTEXT_WHOLE);
   2008          
   2009              sli_add_key_parameters(cmd_ctx, key, status);
   2010              SE_addParameter(se_cmd, add_len);
   2011              SE_addParameter(se_cmd, 0);
   2012          
   2013              sli_add_key_metadata(cmd_ctx, key, status);
   2014              sli_add_key_input(cmd_ctx, key, status);
   2015          
   2016              SE_addDataInput(se_cmd, &iv_in);
   2017              SE_addDataInput(se_cmd, &add_in);
   2018              SE_addDataOutput(se_cmd, &tag_out);
   2019          
   2020              status = sli_se_execute_and_wait(cmd_ctx);
   2021              if (status != SL_STATUS_OK) {
   2022                memset(gcm_ctx->tagbuf, 0, sizeof(gcm_ctx->tagbuf));
   2023                return status;
   2024              }
   2025          
   2026              SE_DataTransfer_t ctx_out =
   2027                SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   2028          
   2029              // Reuse the values of the command context object from the previous
   2030              // operation, and only update the command word and the output data pointer.
   2031              cmd_ctx->command.command =
   2032                (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2033                 : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2034                | SLI_SE_COMMAND_OPTION_CONTEXT_START;
   2035          
   2036              cmd_ctx->command.data_out = &ctx_out;
   2037          
   2038              status = sli_se_execute_and_wait(cmd_ctx);
   2039              if (status != SL_STATUS_OK) {
   2040                memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   2041                return status;
   2042              }
   2043              gcm_ctx->first_operation = false;
   2044            } else {
   2045              memcpy(gcm_ctx->se_ctx, iv, iv_len);
   2046              gcm_ctx->first_operation = true;
   2047            }
   2048            return SL_STATUS_OK;
   2049          }
   2050          #endif
   2051          
   2052          #if defined(SLI_SE_MAJOR_VERSION_TWO)
   2053          /***************************************************************************//**
   2054           * GCM multipart encryption/decryption, update stage.
   2055           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2056          sl_status_t sl_se_gcm_multipart_update(sl_se_gcm_multipart_context_t *gcm_ctx,
   2057                                                 sl_se_command_context_t *cmd_ctx,
   2058                                                 const sl_se_key_descriptor_t *key,
   2059                                                 size_t length,
   2060                                                 const uint8_t *input,
   2061                                                 uint8_t *output,
   2062                                                 size_t *output_length)
   2063          {
   \                     sl_se_gcm_multipart_update: (+1)
   \        0x0   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \        0x4   0xB0A9             SUB      SP,SP,#+164
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9F35             LDR      R7,[SP, #+212]
   2064            sl_status_t status = SL_STATUS_OK;
   \        0xE   0xF05F 0x0800      MOVS     R8,#+0
   2065            uint8_t stored_res_length = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2066          
   2067            // Check input parameters.
   2068            if (cmd_ctx == NULL || key == NULL || gcm_ctx == NULL) {
   \       0x18   0x2E00             CMP      R6,#+0
   \       0x1A   0xD004             BEQ.N    ??sl_se_gcm_multipart_update_0
   \       0x1C   0x982A             LDR      R0,[SP, #+168]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_0
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD101             BNE.N    ??sl_se_gcm_multipart_update_1
   2069              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_multipart_update_0: (+1)
   \       0x26   0x2021             MOVS     R0,#+33
   \       0x28   0xE222             B.N      ??sl_se_gcm_multipart_update_2
   2070            }
   2071            if (length == 0) {
   \                     ??sl_se_gcm_multipart_update_1: (+1)
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD101             BNE.N    ??sl_se_gcm_multipart_update_3
   2072              return SL_STATUS_OK;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xE21E             B.N      ??sl_se_gcm_multipart_update_2
   2073            }
   2074            if (length > 0 && (input == NULL || output == NULL || output_length == NULL)) {
   \                     ??sl_se_gcm_multipart_update_3: (+1)
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD009             BEQ.N    ??sl_se_gcm_multipart_update_4
   \       0x36   0x9834             LDR      R0,[SP, #+208]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD004             BEQ.N    ??sl_se_gcm_multipart_update_5
   \       0x3C   0x2F00             CMP      R7,#+0
   \       0x3E   0xD002             BEQ.N    ??sl_se_gcm_multipart_update_5
   \       0x40   0x9836             LDR      R0,[SP, #+216]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD101             BNE.N    ??sl_se_gcm_multipart_update_4
   2075              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_multipart_update_5: (+1)
   \       0x46   0x2021             MOVS     R0,#+33
   \       0x48   0xE212             B.N      ??sl_se_gcm_multipart_update_2
   2076            }
   2077          
   2078            *output_length = 0;
   \                     ??sl_se_gcm_multipart_update_4: (+1)
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x9836             LDR      R0,[SP, #+216]
   \       0x4E   0x6001             STR      R1,[R0, #+0]
   2079          
   2080            // Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes.
   2081            // Also check for possible overflow.
   2082            if (gcm_ctx->len + length < gcm_ctx->len
   2083                || (uint64_t)gcm_ctx->len + length > 0xFFFFFFFE0ULL) {
   \       0x50   0xE9D5 0x2300      LDRD     R2,R3,[R5, #+0]
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x1810             ADDS     R0,R2,R0
   \       0x5A   0x4159             ADCS     R1,R3,R1
   \       0x5C   0xE9D5 0x2300      LDRD     R2,R3,[R5, #+0]
   \       0x60   0x4299             CMP      R1,R3
   \       0x62   0xD310             BCC.N    ??sl_se_gcm_multipart_update_6
   \       0x64   0xD801             BHI.N    ??sl_se_gcm_multipart_update_7
   \       0x66   0x4290             CMP      R0,R2
   \       0x68   0xD30D             BCC.N    ??sl_se_gcm_multipart_update_6
   \                     ??sl_se_gcm_multipart_update_7: (+1)
   \       0x6A   0xE9D5 0x2300      LDRD     R2,R3,[R5, #+0]
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0x2100             MOVS     R1,#+0
   \       0x72   0x1810             ADDS     R0,R2,R0
   \       0x74   0x4159             ADCS     R1,R3,R1
   \       0x76   0xF07F 0x021E      MVNS     R2,#+30
   \       0x7A   0x230F             MOVS     R3,#+15
   \       0x7C   0x4299             CMP      R1,R3
   \       0x7E   0xD304             BCC.N    ??sl_se_gcm_multipart_update_8
   \       0x80   0xD801             BHI.N    ??sl_se_gcm_multipart_update_9
   \       0x82   0x4290             CMP      R0,R2
   \       0x84   0xD301             BCC.N    ??sl_se_gcm_multipart_update_8
   2084              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_multipart_update_9: (+1)
   \                     ??sl_se_gcm_multipart_update_6: (+1)
   \       0x86   0x2021             MOVS     R0,#+33
   \       0x88   0xE1F2             B.N      ??sl_se_gcm_multipart_update_2
   2085            }
   2086            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_gcm_multipart_update_8: (+1)
   \       0x8A   0x9601             STR      R6,[SP, #+4]
   2087          
   2088            // The update context only support an input length as a multiple of 16. Hence, there
   2089            // there is a few cases that can happen.
   2090          
   2091            // Always:
   2092            //  Case length = 0: Return SL_STATUS_OK
   2093          
   2094            // If there is no data in gcm_ctx->final_data:
   2095            //  Case length < 16: Store data in gcm_ctx->final_data and return SL_STATUS_OK
   2096            //  Case length == 16: Run update as normal
   2097            //  Case length > 16 and length is a multiple of 16: Run update as normal
   2098            //  Case length > 16 and length is not a multiple of 16: Run update as normal on the largest multiple
   2099            //  and save the residue bytes in gcm_ctx->final_data.
   2100          
   2101            // If there is data in gcm_ctx->final_data:
   2102            //  Case final_data_length + length < 16: Store input data in gcm_ctx and return SL_STATUS_OKAY
   2103            //  Case final_data_length + length > 16: Add data to fill up the gcm_ctx->final_data-buffer, run update
   2104            //  on the gcm_ctx->final_data-buffer and finally run update as explained above on the rest of the data.
   2105          
   2106            if (gcm_ctx->final_data_length) {
   \       0x8C   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xF000 0x8102      BEQ.W    ??sl_se_gcm_multipart_update_10
   2107              if ((gcm_ctx->final_data_length + length) < 16) {
   \       0x96   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0x9A   0x1820             ADDS     R0,R4,R0
   \       0x9C   0x2810             CMP      R0,#+16
   \       0x9E   0xD216             BCS.N    ??sl_se_gcm_multipart_update_11
   2108                memcpy(gcm_ctx->final_data + gcm_ctx->final_data_length, input, length);
   \       0xA0   0x46A1             MOV      R9,R4
   \       0xA2   0x9834             LDR      R0,[SP, #+208]
   \       0xA4   0x9004             STR      R0,[SP, #+16]
   \       0xA6   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0xAA   0x4428             ADD      R0,R5,R0
   \       0xAC   0xF110 0x0A30      ADDS     R10,R0,#+48
   \       0xB0   0x464A             MOV      R2,R9
   \       0xB2   0x9904             LDR      R1,[SP, #+16]
   \       0xB4   0x4650             MOV      R0,R10
   \       0xB6   0x.... 0x....      BL       __aeabi_memcpy
   2109                gcm_ctx->final_data_length += length;
   \       0xBA   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0xBE   0x1820             ADDS     R0,R4,R0
   \       0xC0   0xF885 0x0040      STRB     R0,[R5, #+64]
   2110                *output_length = 0;
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0x9936             LDR      R1,[SP, #+216]
   \       0xC8   0x6008             STR      R0,[R1, #+0]
   2111                return SL_STATUS_OK;
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0xE1D0             B.N      ??sl_se_gcm_multipart_update_2
   2112              }
   2113              stored_res_length = 16 - gcm_ctx->final_data_length;
   \                     ??sl_se_gcm_multipart_update_11: (+1)
   \       0xCE   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0xD2   0xF1D0 0x0010      RSBS     R0,R0,#+16
   \       0xD6   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2114              memcpy(gcm_ctx->final_data + gcm_ctx->final_data_length, input, stored_res_length);
   \       0xDA   0xF89D 0x9000      LDRB     R9,[SP, #+0]
   \       0xDE   0x9834             LDR      R0,[SP, #+208]
   \       0xE0   0x9004             STR      R0,[SP, #+16]
   \       0xE2   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0xE6   0x4428             ADD      R0,R5,R0
   \       0xE8   0xF110 0x0A30      ADDS     R10,R0,#+48
   \       0xEC   0x464A             MOV      R2,R9
   \       0xEE   0x9904             LDR      R1,[SP, #+16]
   \       0xF0   0x4650             MOV      R0,R10
   \       0xF2   0x.... 0x....      BL       __aeabi_memcpy
   2115          
   2116              //The gcm_ctx->se_ctx buffer contain iv data with length 12 if gcm_ctx->first_operation = true
   2117              SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2118                                                                    gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   \       0xF6   0xAB0E             ADD      R3,SP,#+56
   \       0xF8   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0xFC   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x100   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x104   0xF115 0x0010      ADDS     R0,R5,#+16
   \      0x108   0x900E             STR      R0,[SP, #+56]
   \      0x10A   0xF895 0x0042      LDRB     R0,[R5, #+66]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_12
   \      0x112   0x200C             MOVS     R0,#+12
   \      0x114   0xE000             B.N      ??sl_se_gcm_multipart_update_13
   \                     ??sl_se_gcm_multipart_update_12: (+1)
   \      0x116   0x2020             MOVS     R0,#+32
   \                     ??sl_se_gcm_multipart_update_13: (+1)
   \      0x118   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x11C   0x9010             STR      R0,[SP, #+64]
   2119          
   2120              SE_DataTransfer_t data_in =
   2121                SE_DATATRANSFER_DEFAULT(gcm_ctx->final_data, 16);
   \      0x11E   0xF10D 0x0C68      ADD      R12,SP,#+104
   \      0x122   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \      0x126   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x12A   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x12E   0xF115 0x0030      ADDS     R0,R5,#+48
   \      0x132   0x901A             STR      R0,[SP, #+104]
   2122          
   2123              SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, 16);
   \      0x134   0xAB17             ADD      R3,SP,#+92
   \      0x136   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \      0x13A   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x13E   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x142   0x9717             STR      R7,[SP, #+92]
   2124              SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2125                                                                  sizeof(gcm_ctx->se_ctx));
   \      0x144   0xAB14             ADD      R3,SP,#+80
   \      0x146   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \      0x14A   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x14E   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x152   0xF115 0x0010      ADDS     R0,R5,#+16
   \      0x156   0x9014             STR      R0,[SP, #+80]
   2126          
   2127              sli_se_command_init(cmd_ctx,
   2128                                  (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2129                                   : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2130                                  | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   \      0x158   0xF895 0x0041      LDRB     R0,[R5, #+65]
   \      0x15C   0x2801             CMP      R0,#+1
   \      0x15E   0xD101             BNE.N    ??sl_se_gcm_multipart_update_14
   \      0x160   0x....             LDR.N    R1,??DataTable17_2
   \      0x162   0xE000             B.N      ??sl_se_gcm_multipart_update_15
   \                     ??sl_se_gcm_multipart_update_14: (+1)
   \      0x164   0x....             LDR.N    R1,??DataTable17_8
   \                     ??sl_se_gcm_multipart_update_15: (+1)
   \      0x166   0xF895 0x0042      LDRB     R0,[R5, #+66]
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_16
   \      0x16E   0x2001             MOVS     R0,#+1
   \      0x170   0xE000             B.N      ??sl_se_gcm_multipart_update_17
   \                     ??sl_se_gcm_multipart_update_16: (+1)
   \      0x172   0x2003             MOVS     R0,#+3
   \                     ??sl_se_gcm_multipart_update_17: (+1)
   \      0x174   0x4301             ORRS     R1,R0,R1
   \      0x176   0x6031             STR      R1,[R6, #+0]
   \      0x178   0x2000             MOVS     R0,#+0
   \      0x17A   0x6070             STR      R0,[R6, #+4]
   \      0x17C   0x2000             MOVS     R0,#+0
   \      0x17E   0x60B0             STR      R0,[R6, #+8]
   \      0x180   0x2000             MOVS     R0,#+0
   \      0x182   0x61F0             STR      R0,[R6, #+28]
   2131          
   2132              sli_add_key_parameters(cmd_ctx, key, status);
   \      0x184   0xA903             ADD      R1,SP,#+12
   \      0x186   0x982A             LDR      R0,[SP, #+168]
   \      0x188   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x18C   0x4681             MOV      R9,R0
   \      0x18E   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x192   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_18
   \      0x194   0x4648             MOV      R0,R9
   \      0x196   0xE16B             B.N      ??sl_se_gcm_multipart_update_2
   \                     ??sl_se_gcm_multipart_update_18: (+1)
   \      0x198   0x9903             LDR      R1,[SP, #+12]
   \      0x19A   0x0030             MOVS     R0,R6
   \      0x19C   0x.... 0x....      BL       SE_addParameter
   2133              SE_addParameter(se_cmd, 0);
   \      0x1A0   0x2100             MOVS     R1,#+0
   \      0x1A2   0x9801             LDR      R0,[SP, #+4]
   \      0x1A4   0x.... 0x....      BL       SE_addParameter
   2134              SE_addParameter(se_cmd, 16);
   \      0x1A8   0x2110             MOVS     R1,#+16
   \      0x1AA   0x9801             LDR      R0,[SP, #+4]
   \      0x1AC   0x.... 0x....      BL       SE_addParameter
   2135          
   2136              sli_add_key_metadata(cmd_ctx, key, status);
   \      0x1B0   0xA920             ADD      R1,SP,#+128
   \      0x1B2   0x982A             LDR      R0,[SP, #+168]
   \      0x1B4   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x1B8   0x4680             MOV      R8,R0
   \      0x1BA   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x1BE   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_19
   \      0x1C0   0x4640             MOV      R0,R8
   \      0x1C2   0xE155             B.N      ??sl_se_gcm_multipart_update_2
   \                     ??sl_se_gcm_multipart_update_19: (+1)
   \      0x1C4   0xA920             ADD      R1,SP,#+128
   \      0x1C6   0x0030             MOVS     R0,R6
   \      0x1C8   0x.... 0x....      BL       SE_addDataInput
   2137              sli_add_key_input(cmd_ctx, key, status);
   \      0x1CC   0xA91D             ADD      R1,SP,#+116
   \      0x1CE   0x982A             LDR      R0,[SP, #+168]
   \      0x1D0   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x1D4   0x4681             MOV      R9,R0
   \      0x1D6   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x1DA   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_20
   \      0x1DC   0x4648             MOV      R0,R9
   \      0x1DE   0xE147             B.N      ??sl_se_gcm_multipart_update_2
   \                     ??sl_se_gcm_multipart_update_20: (+1)
   \      0x1E0   0xA91D             ADD      R1,SP,#+116
   \      0x1E2   0x0030             MOVS     R0,R6
   \      0x1E4   0x.... 0x....      BL       SE_addDataInput
   2138          
   2139              SE_addDataInput(se_cmd, &iv_ctx_in);
   \      0x1E8   0xA90E             ADD      R1,SP,#+56
   \      0x1EA   0x9801             LDR      R0,[SP, #+4]
   \      0x1EC   0x.... 0x....      BL       SE_addDataInput
   2140              SE_addDataInput(se_cmd, &data_in);
   \      0x1F0   0xA91A             ADD      R1,SP,#+104
   \      0x1F2   0x9801             LDR      R0,[SP, #+4]
   \      0x1F4   0x.... 0x....      BL       SE_addDataInput
   2141          
   2142              SE_addDataOutput(se_cmd, &data_out);
   \      0x1F8   0xA917             ADD      R1,SP,#+92
   \      0x1FA   0x9801             LDR      R0,[SP, #+4]
   \      0x1FC   0x.... 0x....      BL       SE_addDataOutput
   2143          
   2144              SE_addDataOutput(se_cmd, &ctx_out);
   \      0x200   0xA914             ADD      R1,SP,#+80
   \      0x202   0x9801             LDR      R0,[SP, #+4]
   \      0x204   0x.... 0x....      BL       SE_addDataOutput
   2145          
   2146              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x208   0x0030             MOVS     R0,R6
   \      0x20A   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x20E   0x4680             MOV      R8,R0
   2147          
   2148              if (status != SL_STATUS_OK) {
   \      0x210   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x214   0xD00C             BEQ.N    ??sl_se_gcm_multipart_update_21
   2149                memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   \      0x216   0xF05F 0x0B20      MOVS     R11,#+32
   \      0x21A   0xF05F 0x0900      MOVS     R9,#+0
   \      0x21E   0xF115 0x0A10      ADDS     R10,R5,#+16
   \      0x222   0x464A             MOV      R2,R9
   \      0x224   0x4659             MOV      R1,R11
   \      0x226   0x4650             MOV      R0,R10
   \      0x228   0x.... 0x....      BL       __aeabi_memset
   2150                return status;
   \      0x22C   0x4640             MOV      R0,R8
   \      0x22E   0xE11F             B.N      ??sl_se_gcm_multipart_update_2
   2151              }
   2152              gcm_ctx->first_operation = false;
   \                     ??sl_se_gcm_multipart_update_21: (+1)
   \      0x230   0x2000             MOVS     R0,#+0
   \      0x232   0xF885 0x0042      STRB     R0,[R5, #+66]
   2153              gcm_ctx->len += 16;
   \      0x236   0xE9D5 0x0100      LDRD     R0,R1,[R5, #+0]
   \      0x23A   0x3010             ADDS     R0,R0,#+16
   \      0x23C   0xF151 0x0100      ADCS     R1,R1,#+0
   \      0x240   0xE9C5 0x0100      STRD     R0,R1,[R5, #+0]
   2154              output += 16;
   \      0x244   0x3710             ADDS     R7,R7,#+16
   2155          
   2156              if ((length - stored_res_length) < 16) {
   \      0x246   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x24A   0x1A20             SUBS     R0,R4,R0
   \      0x24C   0x2810             CMP      R0,#+16
   \      0x24E   0xD219             BCS.N    ??sl_se_gcm_multipart_update_22
   2157                memcpy(gcm_ctx->final_data, input + stored_res_length, length - stored_res_length);
   \      0x250   0xF89D 0xB000      LDRB     R11,[SP, #+0]
   \      0x254   0xEBB4 0x0B0B      SUBS     R11,R4,R11
   \      0x258   0x9834             LDR      R0,[SP, #+208]
   \      0x25A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \      0x25E   0xEB00 0x0901      ADD      R9,R0,R1
   \      0x262   0xF115 0x0A30      ADDS     R10,R5,#+48
   \      0x266   0x465A             MOV      R2,R11
   \      0x268   0x4649             MOV      R1,R9
   \      0x26A   0x4650             MOV      R0,R10
   \      0x26C   0x.... 0x....      BL       __aeabi_memcpy
   2158                gcm_ctx->final_data_length = length - stored_res_length;
   \      0x270   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x274   0x1A20             SUBS     R0,R4,R0
   \      0x276   0xF885 0x0040      STRB     R0,[R5, #+64]
   2159                *output_length = 16;
   \      0x27A   0x2110             MOVS     R1,#+16
   \      0x27C   0x9836             LDR      R0,[SP, #+216]
   \      0x27E   0x6001             STR      R1,[R0, #+0]
   2160                return SL_STATUS_OK;
   \      0x280   0x2000             MOVS     R0,#+0
   \      0x282   0xE0F5             B.N      ??sl_se_gcm_multipart_update_2
   2161              }
   2162          
   2163              length -= stored_res_length;
   \                     ??sl_se_gcm_multipart_update_22: (+1)
   \      0x284   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x288   0x1A24             SUBS     R4,R4,R0
   2164              gcm_ctx->final_data_length = 0;
   \      0x28A   0x2000             MOVS     R0,#+0
   \      0x28C   0xF885 0x0040      STRB     R0,[R5, #+64]
   2165              *output_length += 16;
   \      0x290   0x9836             LDR      R0,[SP, #+216]
   \      0x292   0x6801             LDR      R1,[R0, #+0]
   \      0x294   0x3110             ADDS     R1,R1,#+16
   \      0x296   0x9836             LDR      R0,[SP, #+216]
   \      0x298   0x6001             STR      R1,[R0, #+0]
   2166            }
   2167            if (length % 16 != 0) {
   \                     ??sl_se_gcm_multipart_update_10: (+1)
   \      0x29A   0xF014 0x0F0F      TST      R4,#0xF
   \      0x29E   0xD02F             BEQ.N    ??sl_se_gcm_multipart_update_23
   2168              if (length > 16) {
   \      0x2A0   0x2C11             CMP      R4,#+17
   \      0x2A2   0xD319             BCC.N    ??sl_se_gcm_multipart_update_24
   2169                // Input length is larger than, and a non multiple of, 16
   2170                memcpy(gcm_ctx->final_data, input + stored_res_length + (length - (length % 16)), length % 16);
   \      0x2A4   0xF014 0x0A0F      ANDS     R10,R4,#0xF
   \      0x2A8   0x9834             LDR      R0,[SP, #+208]
   \      0x2AA   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \      0x2AE   0x4408             ADD      R0,R0,R1
   \      0x2B0   0xF014 0x010F      ANDS     R1,R4,#0xF
   \      0x2B4   0x1A61             SUBS     R1,R4,R1
   \      0x2B6   0xEB00 0x0901      ADD      R9,R0,R1
   \      0x2BA   0xF115 0x0B30      ADDS     R11,R5,#+48
   \      0x2BE   0x4652             MOV      R2,R10
   \      0x2C0   0x4649             MOV      R1,R9
   \      0x2C2   0x4658             MOV      R0,R11
   \      0x2C4   0x.... 0x....      BL       __aeabi_memcpy
   2171                gcm_ctx->final_data_length = length % 16;
   \      0x2C8   0xF014 0x000F      ANDS     R0,R4,#0xF
   \      0x2CC   0xF885 0x0040      STRB     R0,[R5, #+64]
   2172                length -= length % 16;
   \      0x2D0   0xF014 0x000F      ANDS     R0,R4,#0xF
   \      0x2D4   0x1A24             SUBS     R4,R4,R0
   \      0x2D6   0xE013             B.N      ??sl_se_gcm_multipart_update_23
   2173              } else {
   2174                // Input length is not a multiple of 16
   2175                memcpy(gcm_ctx->final_data, input + stored_res_length, length);
   \                     ??sl_se_gcm_multipart_update_24: (+1)
   \      0x2D8   0x46A3             MOV      R11,R4
   \      0x2DA   0x9834             LDR      R0,[SP, #+208]
   \      0x2DC   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \      0x2E0   0xEB00 0x0901      ADD      R9,R0,R1
   \      0x2E4   0xF115 0x0A30      ADDS     R10,R5,#+48
   \      0x2E8   0x465A             MOV      R2,R11
   \      0x2EA   0x4649             MOV      R1,R9
   \      0x2EC   0x4650             MOV      R0,R10
   \      0x2EE   0x.... 0x....      BL       __aeabi_memcpy
   2176                gcm_ctx->final_data_length = length;
   \      0x2F2   0xF885 0x4040      STRB     R4,[R5, #+64]
   2177                *output_length = 0;
   \      0x2F6   0x2000             MOVS     R0,#+0
   \      0x2F8   0x9936             LDR      R1,[SP, #+216]
   \      0x2FA   0x6008             STR      R0,[R1, #+0]
   2178                return SL_STATUS_OK;
   \      0x2FC   0x2000             MOVS     R0,#+0
   \      0x2FE   0xE0B7             B.N      ??sl_se_gcm_multipart_update_2
   2179              }
   2180            }
   2181            gcm_ctx->len += length;
   \                     ??sl_se_gcm_multipart_update_23: (+1)
   \      0x300   0xE9D5 0x2300      LDRD     R2,R3,[R5, #+0]
   \      0x304   0x0020             MOVS     R0,R4
   \      0x306   0x2100             MOVS     R1,#+0
   \      0x308   0x1810             ADDS     R0,R2,R0
   \      0x30A   0x4159             ADCS     R1,R3,R1
   \      0x30C   0xE9C5 0x0100      STRD     R0,R1,[R5, #+0]
   2182          
   2183            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2184                                                                  gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   \      0x310   0xF10D 0x0C2C      ADD      R12,SP,#+44
   \      0x314   0x.... 0x....      LDR.W    R0,??DataTable22_4
   \      0x318   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x31C   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x320   0xF115 0x0010      ADDS     R0,R5,#+16
   \      0x324   0x900B             STR      R0,[SP, #+44]
   \      0x326   0xF895 0x0042      LDRB     R0,[R5, #+66]
   \      0x32A   0x2800             CMP      R0,#+0
   \      0x32C   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_25
   \      0x32E   0x200C             MOVS     R0,#+12
   \      0x330   0xE000             B.N      ??sl_se_gcm_multipart_update_26
   \                     ??sl_se_gcm_multipart_update_25: (+1)
   \      0x332   0x2020             MOVS     R0,#+32
   \                     ??sl_se_gcm_multipart_update_26: (+1)
   \      0x334   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x338   0x900D             STR      R0,[SP, #+52]
   2185          
   2186            SE_DataTransfer_t data_in =
   2187              SE_DATATRANSFER_DEFAULT(input + stored_res_length, length);
   \      0x33A   0xF10D 0x0C20      ADD      R12,SP,#+32
   \      0x33E   0x.... 0x....      LDR.W    R0,??DataTable22_5
   \      0x342   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x346   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x34A   0x9934             LDR      R1,[SP, #+208]
   \      0x34C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x350   0x4408             ADD      R0,R1,R0
   \      0x352   0x9008             STR      R0,[SP, #+32]
   \      0x354   0xF054 0x5000      ORRS     R0,R4,#0x20000000
   \      0x358   0x900A             STR      R0,[SP, #+40]
   2188          
   2189            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x35A   0xF10D 0x0C14      ADD      R12,SP,#+20
   \      0x35E   0x.... 0x....      LDR.W    R0,??DataTable22_6
   \      0x362   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x366   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x36A   0x9705             STR      R7,[SP, #+20]
   \      0x36C   0xF054 0x5000      ORRS     R0,R4,#0x20000000
   \      0x370   0x9007             STR      R0,[SP, #+28]
   2190            SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2191                                                                sizeof(gcm_ctx->se_ctx));
   \      0x372   0xAB11             ADD      R3,SP,#+68
   \      0x374   0x.... 0x....      LDR.W    R12,??DataTable22_7
   \      0x378   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x37C   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x380   0xF115 0x0010      ADDS     R0,R5,#+16
   \      0x384   0x9011             STR      R0,[SP, #+68]
   2192          
   2193            sli_se_command_init(cmd_ctx,
   2194                                (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2195                                 : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2196                                | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   \      0x386   0xF895 0x0041      LDRB     R0,[R5, #+65]
   \      0x38A   0x2801             CMP      R0,#+1
   \      0x38C   0xD101             BNE.N    ??sl_se_gcm_multipart_update_27
   \      0x38E   0x....             LDR.N    R1,??DataTable17_2
   \      0x390   0xE000             B.N      ??sl_se_gcm_multipart_update_28
   \                     ??sl_se_gcm_multipart_update_27: (+1)
   \      0x392   0x....             LDR.N    R1,??DataTable17_8
   \                     ??sl_se_gcm_multipart_update_28: (+1)
   \      0x394   0xF895 0x0042      LDRB     R0,[R5, #+66]
   \      0x398   0x2800             CMP      R0,#+0
   \      0x39A   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_29
   \      0x39C   0x2001             MOVS     R0,#+1
   \      0x39E   0xE000             B.N      ??sl_se_gcm_multipart_update_30
   \                     ??sl_se_gcm_multipart_update_29: (+1)
   \      0x3A0   0x2003             MOVS     R0,#+3
   \                     ??sl_se_gcm_multipart_update_30: (+1)
   \      0x3A2   0x4301             ORRS     R1,R0,R1
   \      0x3A4   0x6031             STR      R1,[R6, #+0]
   \      0x3A6   0x2000             MOVS     R0,#+0
   \      0x3A8   0x6070             STR      R0,[R6, #+4]
   \      0x3AA   0x2000             MOVS     R0,#+0
   \      0x3AC   0x60B0             STR      R0,[R6, #+8]
   \      0x3AE   0x2000             MOVS     R0,#+0
   \      0x3B0   0x61F0             STR      R0,[R6, #+28]
   2197          
   2198            sli_add_key_parameters(cmd_ctx, key, status);
   \      0x3B2   0xA902             ADD      R1,SP,#+8
   \      0x3B4   0x982A             LDR      R0,[SP, #+168]
   \      0x3B6   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x3BA   0x4681             MOV      R9,R0
   \      0x3BC   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x3C0   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_31
   \      0x3C2   0x4648             MOV      R0,R9
   \      0x3C4   0xE054             B.N      ??sl_se_gcm_multipart_update_2
   \                     ??sl_se_gcm_multipart_update_31: (+1)
   \      0x3C6   0x9902             LDR      R1,[SP, #+8]
   \      0x3C8   0x0030             MOVS     R0,R6
   \      0x3CA   0x.... 0x....      BL       SE_addParameter
   2199            SE_addParameter(se_cmd, 0);
   \      0x3CE   0x2100             MOVS     R1,#+0
   \      0x3D0   0x9801             LDR      R0,[SP, #+4]
   \      0x3D2   0x.... 0x....      BL       SE_addParameter
   2200            SE_addParameter(se_cmd, length);
   \      0x3D6   0x0021             MOVS     R1,R4
   \      0x3D8   0x9801             LDR      R0,[SP, #+4]
   \      0x3DA   0x.... 0x....      BL       SE_addParameter
   2201          
   2202            sli_add_key_metadata(cmd_ctx, key, status);
   \      0x3DE   0xA926             ADD      R1,SP,#+152
   \      0x3E0   0x982A             LDR      R0,[SP, #+168]
   \      0x3E2   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x3E6   0x4680             MOV      R8,R0
   \      0x3E8   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x3EC   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_32
   \      0x3EE   0x4640             MOV      R0,R8
   \      0x3F0   0xE03E             B.N      ??sl_se_gcm_multipart_update_2
   \                     ??sl_se_gcm_multipart_update_32: (+1)
   \      0x3F2   0xA926             ADD      R1,SP,#+152
   \      0x3F4   0x0030             MOVS     R0,R6
   \      0x3F6   0x.... 0x....      BL       SE_addDataInput
   2203            sli_add_key_input(cmd_ctx, key, status);
   \      0x3FA   0xA923             ADD      R1,SP,#+140
   \      0x3FC   0x982A             LDR      R0,[SP, #+168]
   \      0x3FE   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x402   0x4681             MOV      R9,R0
   \      0x404   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x408   0xD001             BEQ.N    ??sl_se_gcm_multipart_update_33
   \      0x40A   0x4648             MOV      R0,R9
   \      0x40C   0xE030             B.N      ??sl_se_gcm_multipart_update_2
   \                     ??sl_se_gcm_multipart_update_33: (+1)
   \      0x40E   0xA923             ADD      R1,SP,#+140
   \      0x410   0x0030             MOVS     R0,R6
   \      0x412   0x.... 0x....      BL       SE_addDataInput
   2204          
   2205            SE_addDataInput(se_cmd, &iv_ctx_in);
   \      0x416   0xA90B             ADD      R1,SP,#+44
   \      0x418   0x9801             LDR      R0,[SP, #+4]
   \      0x41A   0x.... 0x....      BL       SE_addDataInput
   2206            SE_addDataInput(se_cmd, &data_in);
   \      0x41E   0xA908             ADD      R1,SP,#+32
   \      0x420   0x9801             LDR      R0,[SP, #+4]
   \      0x422   0x.... 0x....      BL       SE_addDataInput
   2207          
   2208            SE_addDataOutput(se_cmd, &data_out);
   \      0x426   0xA905             ADD      R1,SP,#+20
   \      0x428   0x9801             LDR      R0,[SP, #+4]
   \      0x42A   0x.... 0x....      BL       SE_addDataOutput
   2209          
   2210            SE_addDataOutput(se_cmd, &ctx_out);
   \      0x42E   0xA911             ADD      R1,SP,#+68
   \      0x430   0x9801             LDR      R0,[SP, #+4]
   \      0x432   0x.... 0x....      BL       SE_addDataOutput
   2211          
   2212            status = sli_se_execute_and_wait(cmd_ctx);
   \      0x436   0x0030             MOVS     R0,R6
   \      0x438   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x43C   0x4680             MOV      R8,R0
   2213          
   2214            if (status != SL_STATUS_OK) {
   \      0x43E   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x442   0xD00C             BEQ.N    ??sl_se_gcm_multipart_update_34
   2215              memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   \      0x444   0xF05F 0x0B20      MOVS     R11,#+32
   \      0x448   0xF05F 0x0900      MOVS     R9,#+0
   \      0x44C   0xF115 0x0A10      ADDS     R10,R5,#+16
   \      0x450   0x464A             MOV      R2,R9
   \      0x452   0x4659             MOV      R1,R11
   \      0x454   0x4650             MOV      R0,R10
   \      0x456   0x.... 0x....      BL       __aeabi_memset
   2216              return status;
   \      0x45A   0x4640             MOV      R0,R8
   \      0x45C   0xE008             B.N      ??sl_se_gcm_multipart_update_2
   2217            }
   2218            *output_length += length;
   \                     ??sl_se_gcm_multipart_update_34: (+1)
   \      0x45E   0x9836             LDR      R0,[SP, #+216]
   \      0x460   0x6801             LDR      R1,[R0, #+0]
   \      0x462   0x1861             ADDS     R1,R4,R1
   \      0x464   0x9836             LDR      R0,[SP, #+216]
   \      0x466   0x6001             STR      R1,[R0, #+0]
   2219            gcm_ctx->first_operation = false;
   \      0x468   0x2000             MOVS     R0,#+0
   \      0x46A   0xF885 0x0042      STRB     R0,[R5, #+66]
   2220            return SL_STATUS_OK;
   \      0x46E   0x2000             MOVS     R0,#+0
   \                     ??sl_se_gcm_multipart_update_2: (+1)
   \      0x470   0xB02B             ADD      SP,SP,#+172
   \      0x472   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2221          }

   \                                 In section .rodata, align 4
   \                     ?_75:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_76:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_77:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_78:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_79:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_80:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_81:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_82:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020
   2222          
   2223          #else // SLI_SE_MAJOR_VERSION_ONE
   2224          /***************************************************************************//**
   2225           * GCM multipart encryption/decryption, update stage.
   2226           ******************************************************************************/
   2227          sl_status_t sl_se_gcm_multipart_update(sl_se_gcm_multipart_context_t *gcm_ctx,
   2228                                                 sl_se_command_context_t *cmd_ctx,
   2229                                                 const sl_se_key_descriptor_t *key,
   2230                                                 size_t length,
   2231                                                 const uint8_t *input,
   2232                                                 uint8_t *output,
   2233                                                 size_t *output_length)
   2234          {
   2235            sl_status_t status = SL_STATUS_OK;
   2236            uint8_t stored_res_length = 0;
   2237          
   2238            // Check input parameters.
   2239            if (cmd_ctx == NULL || key == NULL || gcm_ctx == NULL) {
   2240              return SL_STATUS_INVALID_PARAMETER;
   2241            }
   2242            if (length == 0) {
   2243              return SL_STATUS_OK;
   2244            }
   2245            if (length > 0 && (input == NULL || output == NULL || output_length == NULL)) {
   2246              return SL_STATUS_INVALID_PARAMETER;
   2247            }
   2248          
   2249            *output_length = 0;
   2250          
   2251            // Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes.
   2252            // Also check for possible overflow.
   2253            if (gcm_ctx->len + length < gcm_ctx->len
   2254                || (uint64_t)gcm_ctx->len + length > 0xFFFFFFFE0ULL) {
   2255              return SL_STATUS_INVALID_PARAMETER;
   2256            }
   2257            SE_Command_t *se_cmd = &cmd_ctx->command;
   2258          
   2259            // The finish command will return the wrong tag or INVALID SIGNATURE if there is no
   2260            // input data. There is no way to know when sl_se_gcm_multipart_update is called for the last time, so there must
   2261            // always be data stored.
   2262            // The update context only support an input length as a multiple of 16. Hence, there
   2263            // there is a few cases that can happen.
   2264          
   2265            // Always:
   2266            //  Case length = 0: Return SL_STATUS_OK
   2267          
   2268            // If there is no data in gcm_ctx->final_data
   2269            //  Case length < 16: Store data in gcm_ctx->final_data and return SL_STATUS_OK
   2270            //  Case length > 16 and length is not a multiple of 16: Run update as normal on the largest multiple
   2271            //  and save the residue bytes in gcm_ctx->final_data.
   2272            //  Case length == 16: store the current se_ctx in gcm_ctx->previous_se_ctx and store input data in final_data,
   2273            //  then run update as normal on the input data.
   2274            //  Case length > 16 and length is a multible of 16: run update twice, one with all input data and one with
   2275            //  all input data except the last 16 bytes. The out_ctx from each run are stored in gcm_ctx->se_ctx and
   2276            //  gcm_ctx->previous_se_ctx respectively. The last 16 bytes are then stored in final_data.
   2277            //  NOTE:output_length will include all encrypted/decrypted data.
   2278          
   2279            // If there is data in gcm_ctx->final_data
   2280            //  Case final_data_length + length < 16: Store input data in gcm_ctx and return SL_STATUS_OKAY
   2281            //  Case final_data_length + length > 16: Add data to fill up the gcm_ctx->final_data-buffer, run update
   2282            //  on the gcm_ctx->final_data-buffer and finally run update as explained above on the rest of the data.
   2283          
   2284            // Our drivers only support full or no overlap between input and output
   2285            // buffers. So in the case of partial overlap, copy the input buffer into
   2286            // the output buffer and process it in place as if the buffers fully
   2287            // overlapped.
   2288            if ((output > input) && (output < (input + length))) {
   2289              memmove(output, input, length);
   2290              input = output;
   2291            }
   2292          
   2293            // Check for data in final_data_length.
   2294            if (gcm_ctx->final_data_length && gcm_ctx->final_data_length != 16) {
   2295              if ((gcm_ctx->final_data_length + length) < 16) {
   2296                memcpy(gcm_ctx->final_data + gcm_ctx->final_data_length, input, length);
   2297                gcm_ctx->final_data_length += length;
   2298                *output_length = 0;
   2299                return SL_STATUS_OK;
   2300              }
   2301          
   2302              if ((gcm_ctx->final_data_length + length) == 16) {
   2303                memcpy(gcm_ctx->previous_se_ctx, gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   2304              }
   2305              stored_res_length = 16 - gcm_ctx->final_data_length;
   2306              memcpy(gcm_ctx->final_data + gcm_ctx->final_data_length, input, stored_res_length);
   2307          
   2308              SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2309                                                                    gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   2310          
   2311              SE_DataTransfer_t data_in =
   2312                SE_DATATRANSFER_DEFAULT(gcm_ctx->final_data, 16);
   2313          
   2314              SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, 16);
   2315              SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2316                                                                  sizeof(gcm_ctx->se_ctx));
   2317          
   2318              sli_se_command_init(cmd_ctx,
   2319                                  (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2320                                   : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2321                                  | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   2322          
   2323              sli_add_key_parameters(cmd_ctx, key, status);
   2324              SE_addParameter(se_cmd, 0);
   2325              SE_addParameter(se_cmd, 16);
   2326          
   2327              sli_add_key_metadata(cmd_ctx, key, status);
   2328              sli_add_key_input(cmd_ctx, key, status);
   2329          
   2330              SE_addDataInput(se_cmd, &iv_ctx_in);
   2331              SE_addDataInput(se_cmd, &data_in);
   2332          
   2333              SE_addDataOutput(se_cmd, &data_out);
   2334          
   2335              SE_addDataOutput(se_cmd, &ctx_out);
   2336          
   2337              status = sli_se_execute_and_wait(cmd_ctx);
   2338          
   2339              if (status != SL_STATUS_OK) {
   2340                memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   2341                return status;
   2342              }
   2343              gcm_ctx->first_operation = false;
   2344              gcm_ctx->len += 16;
   2345              output += 16;
   2346          
   2347              if ((gcm_ctx->final_data_length + length) == 16) {
   2348                gcm_ctx->final_data_length = 16;
   2349                *output_length = 16;
   2350                return SL_STATUS_OK;
   2351              }
   2352          
   2353              if ((length - stored_res_length) < 16) {
   2354                memcpy(gcm_ctx->final_data, input + stored_res_length, length - stored_res_length);
   2355                gcm_ctx->final_data_length = length - stored_res_length;
   2356                *output_length = 16;
   2357                return SL_STATUS_OK;
   2358              }
   2359          
   2360              length -= stored_res_length;
   2361              gcm_ctx->final_data_length = 0;
   2362              *output_length += 16;
   2363            }
   2364            if (length % 16 != 0) {
   2365              if (length > 16) {
   2366                //Input length is larger than, and a non multiple of, 16
   2367                memcpy(gcm_ctx->final_data, input + stored_res_length + (length - (length % 16)), length % 16);
   2368                gcm_ctx->final_data_length = length % 16;
   2369                length -= length % 16;
   2370              } else {
   2371                //Input length is not a multiple of 16
   2372                memcpy(gcm_ctx->final_data, input + stored_res_length, length);
   2373                gcm_ctx->final_data_length = length;
   2374                *output_length = 0;
   2375                return SL_STATUS_OK;
   2376              }
   2377            } else {
   2378              if (length > 16) {
   2379                //If length is larger than, and a multiple of, 16, we must compute a context without the last 16 bytes
   2380                //and store it as the previous context in case there is no more data.
   2381                memcpy(gcm_ctx->final_data, input + stored_res_length + (length - 16), 16);
   2382                gcm_ctx->final_data_length = 16;
   2383          
   2384                //The gcm_ctx->se_ctx buffer contain iv data with length 12 if gcm_ctx->first_operation = true
   2385                SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2386                                                                      gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   2387          
   2388                SE_DataTransfer_t data_in =
   2389                  SE_DATATRANSFER_DEFAULT(input + stored_res_length, length - 16);
   2390          
   2391                SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length - 16);
   2392                SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2393                                                                    sizeof(gcm_ctx->se_ctx));
   2394          
   2395                sli_se_command_init(cmd_ctx,
   2396                                    (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2397                                     : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2398                                    | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   2399          
   2400                sli_add_key_parameters(cmd_ctx, key, status);
   2401                SE_addParameter(se_cmd, 0);
   2402                SE_addParameter(se_cmd, length - 16);
   2403          
   2404                sli_add_key_metadata(cmd_ctx, key, status);
   2405                sli_add_key_input(cmd_ctx, key, status);
   2406          
   2407                SE_addDataInput(se_cmd, &iv_ctx_in);
   2408                SE_addDataInput(se_cmd, &data_in);
   2409          
   2410                SE_addDataOutput(se_cmd, &data_out);
   2411          
   2412                SE_addDataOutput(se_cmd, &ctx_out);
   2413          
   2414                status = sli_se_execute_and_wait(cmd_ctx);
   2415          
   2416                if (status != SL_STATUS_OK) {
   2417                  memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   2418                  return status;
   2419                }
   2420          
   2421                // Only process the last 16 bytes in the last operation.
   2422                output += (length - 16);
   2423                input += (length - 16);
   2424                gcm_ctx->first_operation = false;
   2425                gcm_ctx->len += (length - 16);
   2426                *output_length += (length - 16);
   2427          
   2428                length = 16;
   2429          
   2430                memcpy(gcm_ctx->previous_se_ctx, gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   2431              } else {
   2432                memcpy(gcm_ctx->previous_se_ctx, gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   2433                memcpy(gcm_ctx->final_data, input + stored_res_length, length);
   2434                gcm_ctx->final_data_length = length;
   2435              }
   2436            }
   2437            gcm_ctx->len += length;
   2438          
   2439            // The gcm_ctx->se_ctx buffer contain iv data with length 12 if gcm_ctx->first_operation = true
   2440            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2441                                                                  gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   2442          
   2443            SE_DataTransfer_t data_in =
   2444              SE_DATATRANSFER_DEFAULT(input + stored_res_length, length);
   2445          
   2446            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   2447            SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2448                                                                sizeof(gcm_ctx->se_ctx));
   2449          
   2450            sli_se_command_init(cmd_ctx,
   2451                                (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2452                                 : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2453                                | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   2454          
   2455            sli_add_key_parameters(cmd_ctx, key, status);
   2456            SE_addParameter(se_cmd, 0);
   2457            SE_addParameter(se_cmd, length);
   2458          
   2459            sli_add_key_metadata(cmd_ctx, key, status);
   2460            sli_add_key_input(cmd_ctx, key, status);
   2461          
   2462            SE_addDataInput(se_cmd, &iv_ctx_in);
   2463            SE_addDataInput(se_cmd, &data_in);
   2464          
   2465            SE_addDataOutput(se_cmd, &data_out);
   2466          
   2467            SE_addDataOutput(se_cmd, &ctx_out);
   2468          
   2469            status = sli_se_execute_and_wait(cmd_ctx);
   2470          
   2471            if (status != SL_STATUS_OK) {
   2472              memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   2473              return status;
   2474            }
   2475            *output_length += length;
   2476            gcm_ctx->first_operation = false;
   2477            return SL_STATUS_OK;
   2478          }
   2479          #endif
   2480          
   2481          /***************************************************************************//**
   2482           * GCM multipart encryption/decryption, finish stage.
   2483           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2484          sl_status_t sl_se_gcm_multipart_finish(sl_se_gcm_multipart_context_t *gcm_ctx,
   2485                                                 sl_se_command_context_t *cmd_ctx,
   2486                                                 const sl_se_key_descriptor_t *key,
   2487                                                 uint8_t *tag,
   2488                                                 uint8_t tag_length,
   2489                                                 uint8_t *output,
   2490                                                 uint8_t output_size,
   2491                                                 uint8_t *output_length)
   2492          {
   \                     sl_se_gcm_multipart_finish: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB09C             SUB      SP,SP,#+112
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x9E28             LDR      R6,[SP, #+160]
   \        0xC   0xF8DD 0x80AC      LDR      R8,[SP, #+172]
   2493            sl_status_t status = SL_STATUS_OK;
   \       0x10   0xF05F 0x0900      MOVS     R9,#+0
   2494            uint32_t tmpbuf[4];
   2495            uint8_t length;
   2496            if (cmd_ctx == NULL || key == NULL || gcm_ctx == NULL || tag == NULL || tag_length < 4 || tag_length > 16) {
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD00F             BEQ.N    ??sl_se_gcm_multipart_finish_0
   \       0x18   0x981D             LDR      R0,[SP, #+116]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD00C             BEQ.N    ??sl_se_gcm_multipart_finish_0
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD00A             BEQ.N    ??sl_se_gcm_multipart_finish_0
   \       0x22   0x981E             LDR      R0,[SP, #+120]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD007             BEQ.N    ??sl_se_gcm_multipart_finish_0
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2804             CMP      R0,#+4
   \       0x2E   0xDB03             BLT.N    ??sl_se_gcm_multipart_finish_0
   \       0x30   0x0030             MOVS     R0,R6
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0x2811             CMP      R0,#+17
   \       0x36   0xDB01             BLT.N    ??sl_se_gcm_multipart_finish_1
   2497              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_multipart_finish_0: (+1)
   \       0x38   0x2021             MOVS     R0,#+33
   \       0x3A   0xE17C             B.N      ??sl_se_gcm_multipart_finish_2
   2498            }
   2499          
   2500            if ((gcm_ctx->final_data_length != 16)
   2501                && (output_size < gcm_ctx->final_data_length)) {
   \                     ??sl_se_gcm_multipart_finish_1: (+1)
   \       0x3C   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \       0x40   0x2810             CMP      R0,#+16
   \       0x42   0xD007             BEQ.N    ??sl_se_gcm_multipart_finish_3
   \       0x44   0xF89D 0x10A8      LDRB     R1,[SP, #+168]
   \       0x48   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \       0x4C   0x4281             CMP      R1,R0
   \       0x4E   0xD201             BCS.N    ??sl_se_gcm_multipart_finish_3
   2502              return SL_STATUS_INVALID_PARAMETER;
   \       0x50   0x2021             MOVS     R0,#+33
   \       0x52   0xE170             B.N      ??sl_se_gcm_multipart_finish_2
   2503            }
   2504          
   2505            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_gcm_multipart_finish_3: (+1)
   \       0x54   0x9508             STR      R5,[SP, #+32]
   2506            length = gcm_ctx->final_data_length;
   \       0x56   0xF894 0x7040      LDRB     R7,[R4, #+64]
   2507            gcm_ctx->len += ((length % 16 != 0) ? length : 0);
   \       0x5A   0xF017 0x0F0F      TST      R7,#0xF
   \       0x5E   0xD002             BEQ.N    ??sl_se_gcm_multipart_finish_4
   \       0x60   0x0038             MOVS     R0,R7
   \       0x62   0xB2C0             UXTB     R0,R0
   \       0x64   0xE000             B.N      ??sl_se_gcm_multipart_finish_5
   \                     ??sl_se_gcm_multipart_finish_4: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \                     ??sl_se_gcm_multipart_finish_5: (+1)
   \       0x68   0xE9D4 0x2300      LDRD     R2,R3,[R4, #+0]
   \       0x6C   0x17C1             ASRS     R1,R0,#+31
   \       0x6E   0x1810             ADDS     R0,R2,R0
   \       0x70   0x4159             ADCS     R1,R3,R1
   \       0x72   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
   2508          
   2509            #if defined(SLI_SE_MAJOR_VERSION_ONE)
   2510            if ((gcm_ctx->add_len > 0) && (gcm_ctx->len == 0)) {
   2511              if (gcm_ctx->mode == SL_SE_DECRYPT) {
   2512                if (memcmp_time_cst(tag, gcm_ctx->tagbuf, tag_length)) {
   2513                  memset(tag, 0, tag_length);
   2514                  return SL_STATUS_INVALID_SIGNATURE;
   2515                }
   2516              } else {
   2517                memcpy(tag, gcm_ctx->tagbuf, tag_length);
   2518              }
   2519              return SL_STATUS_OK;
   2520            }
   2521            #endif
   2522          
   2523          #if defined(SLI_SE_MAJOR_VERSION_ONE)
   2524            // For xG21 devices, since the multipart finish command cannot handle cases without
   2525            // more data being passed as part of the finish call, there are two cases for which
   2526            // a finish call can condense into a one-shot operation:
   2527            // 1. The 'first operation' flag is set, meaning no multipart context has been started
   2528            // 2. There was no AAD input and the total input length equals 16 bytes. In such a case,
   2529            //    all information needed for a one-shot operation is still present in the context,
   2530            //    being the 16 bytes of input in the lookback buffer. In such a case, be careful to
   2531            //    not return ciphertext/plaintext to the user a second time, since it has already
   2532            //    been returned as part of the initial call to `_update`.
   2533            if (gcm_ctx->first_operation || (gcm_ctx->add_len == 0 && gcm_ctx->len == 16)) {
   2534          #else
   2535            // Devices xG23 or newer support a finish call without data, so the only case for
   2536            // condensing a multipart finish operation into a one-shot operation is when the
   2537            // 'first operation' flag is set, meaning no multipart context has been started
   2538            if (gcm_ctx->first_operation) {
   \       0x76   0xF894 0x0042      LDRB     R0,[R4, #+66]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD065             BEQ.N    ??sl_se_gcm_multipart_finish_6
   2539          #endif
   2540              if (gcm_ctx->mode == SL_SE_ENCRYPT) {
   \       0x7E   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD122             BNE.N    ??sl_se_gcm_multipart_finish_7
   2541                status = sl_se_gcm_crypt_and_tag(cmd_ctx,
   2542                                                 key,
   2543                                                 gcm_ctx->mode,
   2544                                                 length,
   2545                                                 gcm_ctx->se_ctx, //iv
   2546                                                 12,  //iv_len
   2547                                                 NULL,
   2548                                                 0,
   2549                                                 gcm_ctx->final_data,
   2550                                                 (length < 16 ? output : (unsigned char*)tmpbuf),
   2551                                                 tag_length,
   2552                                                 tag);
   \       0x86   0x0038             MOVS     R0,R7
   \       0x88   0xB2C0             UXTB     R0,R0
   \       0x8A   0x2810             CMP      R0,#+16
   \       0x8C   0xDA01             BGE.N    ??sl_se_gcm_multipart_finish_8
   \       0x8E   0x9829             LDR      R0,[SP, #+164]
   \       0x90   0xE000             B.N      ??sl_se_gcm_multipart_finish_9
   \                     ??sl_se_gcm_multipart_finish_8: (+1)
   \       0x92   0xA80C             ADD      R0,SP,#+48
   \                     ??sl_se_gcm_multipart_finish_9: (+1)
   \       0x94   0x991E             LDR      R1,[SP, #+120]
   \       0x96   0x9107             STR      R1,[SP, #+28]
   \       0x98   0x0031             MOVS     R1,R6
   \       0x9A   0xB2C9             UXTB     R1,R1
   \       0x9C   0x9106             STR      R1,[SP, #+24]
   \       0x9E   0x9005             STR      R0,[SP, #+20]
   \       0xA0   0xF114 0x0030      ADDS     R0,R4,#+48
   \       0xA4   0x9004             STR      R0,[SP, #+16]
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x9003             STR      R0,[SP, #+12]
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0x9002             STR      R0,[SP, #+8]
   \       0xAE   0x200C             MOVS     R0,#+12
   \       0xB0   0x9001             STR      R0,[SP, #+4]
   \       0xB2   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0xB6   0x9000             STR      R0,[SP, #+0]
   \       0xB8   0x003B             MOVS     R3,R7
   \       0xBA   0xB2DB             UXTB     R3,R3
   \       0xBC   0xF894 0x2041      LDRB     R2,[R4, #+65]
   \       0xC0   0x991D             LDR      R1,[SP, #+116]
   \       0xC2   0x0028             MOVS     R0,R5
   \       0xC4   0x.... 0x....      BL       sl_se_gcm_crypt_and_tag
   \       0xC8   0x4682             MOV      R10,R0
   \       0xCA   0xE01E             B.N      ??sl_se_gcm_multipart_finish_10
   2553              } else {
   2554                status = sl_se_gcm_auth_decrypt(cmd_ctx,
   2555                                                key,
   2556                                                length,
   2557                                                gcm_ctx->se_ctx, //iv
   2558                                                12,   //iv_len
   2559                                                NULL,
   2560                                                0,
   2561                                                gcm_ctx->final_data,
   2562                                                (length < 16 ? output : (unsigned char*)tmpbuf),
   2563                                                tag_length,
   2564                                                tag);
   \                     ??sl_se_gcm_multipart_finish_7: (+1)
   \       0xCC   0x0038             MOVS     R0,R7
   \       0xCE   0xB2C0             UXTB     R0,R0
   \       0xD0   0x2810             CMP      R0,#+16
   \       0xD2   0xDA01             BGE.N    ??sl_se_gcm_multipart_finish_11
   \       0xD4   0x9829             LDR      R0,[SP, #+164]
   \       0xD6   0xE000             B.N      ??sl_se_gcm_multipart_finish_12
   \                     ??sl_se_gcm_multipart_finish_11: (+1)
   \       0xD8   0xA80C             ADD      R0,SP,#+48
   \                     ??sl_se_gcm_multipart_finish_12: (+1)
   \       0xDA   0x991E             LDR      R1,[SP, #+120]
   \       0xDC   0x9106             STR      R1,[SP, #+24]
   \       0xDE   0x0031             MOVS     R1,R6
   \       0xE0   0xB2C9             UXTB     R1,R1
   \       0xE2   0x9105             STR      R1,[SP, #+20]
   \       0xE4   0x9004             STR      R0,[SP, #+16]
   \       0xE6   0xF114 0x0030      ADDS     R0,R4,#+48
   \       0xEA   0x9003             STR      R0,[SP, #+12]
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0x9002             STR      R0,[SP, #+8]
   \       0xF0   0x2000             MOVS     R0,#+0
   \       0xF2   0x9001             STR      R0,[SP, #+4]
   \       0xF4   0x200C             MOVS     R0,#+12
   \       0xF6   0x9000             STR      R0,[SP, #+0]
   \       0xF8   0xF114 0x0310      ADDS     R3,R4,#+16
   \       0xFC   0x003A             MOVS     R2,R7
   \       0xFE   0xB2D2             UXTB     R2,R2
   \      0x100   0x991D             LDR      R1,[SP, #+116]
   \      0x102   0x0028             MOVS     R0,R5
   \      0x104   0x.... 0x....      BL       sl_se_gcm_auth_decrypt
   \      0x108   0x4682             MOV      R10,R0
   2565              }
   2566              if (status != SL_STATUS_OK) {
   \                     ??sl_se_gcm_multipart_finish_10: (+1)
   \      0x10A   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x10E   0xD010             BEQ.N    ??sl_se_gcm_multipart_finish_13
   2567                *output_length = 0;
   \      0x110   0x2000             MOVS     R0,#+0
   \      0x112   0xF888 0x0000      STRB     R0,[R8, #+0]
   2568                memset(tag, 0, tag_length);
   \      0x116   0x0030             MOVS     R0,R6
   \      0x118   0xB2C0             UXTB     R0,R0
   \      0x11A   0x9004             STR      R0,[SP, #+16]
   \      0x11C   0xF05F 0x0900      MOVS     R9,#+0
   \      0x120   0xF8DD 0xB078      LDR      R11,[SP, #+120]
   \      0x124   0x464A             MOV      R2,R9
   \      0x126   0x9904             LDR      R1,[SP, #+16]
   \      0x128   0x4658             MOV      R0,R11
   \      0x12A   0x.... 0x....      BL       __aeabi_memset
   2569                return status;
   \      0x12E   0x4650             MOV      R0,R10
   \      0x130   0xE101             B.N      ??sl_se_gcm_multipart_finish_2
   2570              }
   2571              if (length < 16) {
   \                     ??sl_se_gcm_multipart_finish_13: (+1)
   \      0x132   0x0038             MOVS     R0,R7
   \      0x134   0xB2C0             UXTB     R0,R0
   \      0x136   0x2810             CMP      R0,#+16
   \      0x138   0xDA02             BGE.N    ??sl_se_gcm_multipart_finish_14
   2572                *output_length = length;
   \      0x13A   0xF888 0x7000      STRB     R7,[R8, #+0]
   \      0x13E   0xE002             B.N      ??sl_se_gcm_multipart_finish_15
   2573              } else {
   2574                *output_length = 0;
   \                     ??sl_se_gcm_multipart_finish_14: (+1)
   \      0x140   0x2000             MOVS     R0,#+0
   \      0x142   0xF888 0x0000      STRB     R0,[R8, #+0]
   2575              }
   2576              return SL_STATUS_OK;
   \                     ??sl_se_gcm_multipart_finish_15: (+1)
   \      0x146   0x2000             MOVS     R0,#+0
   \      0x148   0xE0F5             B.N      ??sl_se_gcm_multipart_finish_2
   2577            }
   2578          
   2579            // Construct GCM LenA || LenC block into temporary buffer
   2580            tmpbuf[0] = __REV(gcm_ctx->add_len >> 29);
   \                     ??sl_se_gcm_multipart_finish_6: (+1)
   \      0x14A   0xE9D4 0x0102      LDRD     R0,R1,[R4, #+8]
   \      0x14E   0x0F40             LSRS     R0,R0,#+29
   \      0x150   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \      0x154   0x0F49             LSRS     R1,R1,#+29
   \      0x156   0xBA00             REV      R0,R0
   \      0x158   0x900C             STR      R0,[SP, #+48]
   2581            tmpbuf[1] = __REV((gcm_ctx->add_len << 3) & 0xFFFFFFFFUL);
   \      0x15A   0xAA0C             ADD      R2,SP,#+48
   \      0x15C   0xE9D4 0x0102      LDRD     R0,R1,[R4, #+8]
   \      0x160   0x00C0             LSLS     R0,R0,#+3
   \      0x162   0xBA00             REV      R0,R0
   \      0x164   0x6050             STR      R0,[R2, #+4]
   2582            tmpbuf[2] = __REV(gcm_ctx->len >> 29);
   \      0x166   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x16A   0x0F40             LSRS     R0,R0,#+29
   \      0x16C   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \      0x170   0x0F49             LSRS     R1,R1,#+29
   \      0x172   0xBA00             REV      R0,R0
   \      0x174   0x6090             STR      R0,[R2, #+8]
   2583            tmpbuf[3] = __REV((gcm_ctx->len << 3) & 0xFFFFFFFFUL);
   \      0x176   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \      0x17A   0x00C0             LSLS     R0,R0,#+3
   \      0x17C   0xBA00             REV      R0,R0
   \      0x17E   0x60D0             STR      R0,[R2, #+12]
   2584          
   2585            SE_DataTransfer_t data_in =
   2586              SE_DATATRANSFER_DEFAULT(gcm_ctx->final_data, length);
   \      0x180   0xAB09             ADD      R3,SP,#+36
   \      0x182   0x.... 0x....      LDR.W    R0,??DataTable22_8
   \      0x186   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x18A   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x18E   0xF114 0x0030      ADDS     R0,R4,#+48
   \      0x192   0x9009             STR      R0,[SP, #+36]
   \      0x194   0x0038             MOVS     R0,R7
   \      0x196   0xB2C0             UXTB     R0,R0
   \      0x198   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x19C   0x900B             STR      R0,[SP, #+44]
   2587          
   2588            #if defined(SLI_SE_MAJOR_VERSION_ONE)
   2589            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT((length % 16 != 0 || length == 0) ? gcm_ctx->se_ctx : gcm_ctx->previous_se_ctx, sizeof(gcm_ctx->previous_se_ctx));
   2590            #else
   2591            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   \      0x19E   0xF10D 0x0C4C      ADD      R12,SP,#+76
   \      0x1A2   0x.... 0x....      LDR.W    R0,??DataTable22_9
   \      0x1A6   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x1AA   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x1AE   0xF114 0x0010      ADDS     R0,R4,#+16
   \      0x1B2   0x9013             STR      R0,[SP, #+76]
   2592            #endif
   2593          
   2594            SE_DataTransfer_t lenalenc_in = SE_DATATRANSFER_DEFAULT(&tmpbuf[0],
   2595                                                                    sizeof(tmpbuf));
   \      0x1B4   0xF10D 0x0C40      ADD      R12,SP,#+64
   \      0x1B8   0x.... 0x....      LDR.W    R0,??DataTable22_10
   \      0x1BC   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x1C0   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x1C4   0xA80C             ADD      R0,SP,#+48
   \      0x1C6   0x9010             STR      R0,[SP, #+64]
   2596          
   2597            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x1C8   0xF10D 0x0C04      ADD      R12,SP,#+4
   \      0x1CC   0x.... 0x....      LDR.W    R0,??DataTable22_11
   \      0x1D0   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x1D4   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x1D8   0x9829             LDR      R0,[SP, #+164]
   \      0x1DA   0x9001             STR      R0,[SP, #+4]
   \      0x1DC   0x0038             MOVS     R0,R7
   \      0x1DE   0xB2C0             UXTB     R0,R0
   \      0x1E0   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x1E4   0x9003             STR      R0,[SP, #+12]
   2598            if (length == 16) {
   \      0x1E6   0x0038             MOVS     R0,R7
   \      0x1E8   0xB2C0             UXTB     R0,R0
   \      0x1EA   0x2810             CMP      R0,#+16
   \      0x1EC   0xD105             BNE.N    ??sl_se_gcm_multipart_finish_16
   2599              data_out.data = NULL;
   \      0x1EE   0x2000             MOVS     R0,#+0
   \      0x1F0   0x9001             STR      R0,[SP, #+4]
   2600              data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x1F2   0x9803             LDR      R0,[SP, #+12]
   \      0x1F4   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x1F8   0x9003             STR      R0,[SP, #+12]
   2601            }
   2602          
   2603            SE_DataTransfer_t gcm_tag = SE_DATATRANSFER_DEFAULT(tag, tag_length);
   \                     ??sl_se_gcm_multipart_finish_16: (+1)
   \      0x1FA   0xAB05             ADD      R3,SP,#+20
   \      0x1FC   0x.... 0x....      LDR.W    R0,??DataTable22_12
   \      0x200   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x204   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x208   0x981E             LDR      R0,[SP, #+120]
   \      0x20A   0x9005             STR      R0,[SP, #+20]
   \      0x20C   0x0030             MOVS     R0,R6
   \      0x20E   0xB2C0             UXTB     R0,R0
   \      0x210   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x214   0x9007             STR      R0,[SP, #+28]
   2604          
   2605            sli_se_command_init(cmd_ctx,
   2606                                (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2607                                 : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2608                                | tag_length << 8 | SLI_SE_COMMAND_OPTION_CONTEXT_END);
   \      0x216   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \      0x21A   0x2801             CMP      R0,#+1
   \      0x21C   0xD102             BNE.N    ??sl_se_gcm_multipart_finish_17
   \      0x21E   0x.... 0x....      LDR.W    R1,??DataTable22_13
   \      0x222   0xE001             B.N      ??sl_se_gcm_multipart_finish_18
   \                     ??sl_se_gcm_multipart_finish_17: (+1)
   \      0x224   0x.... 0x....      LDR.W    R1,??DataTable22_14
   \                     ??sl_se_gcm_multipart_finish_18: (+1)
   \      0x228   0x0030             MOVS     R0,R6
   \      0x22A   0xB2C0             UXTB     R0,R0
   \      0x22C   0xEA51 0x2100      ORRS     R1,R1,R0, LSL #+8
   \      0x230   0xF051 0x0102      ORRS     R1,R1,#0x2
   \      0x234   0x6029             STR      R1,[R5, #+0]
   \      0x236   0x2000             MOVS     R0,#+0
   \      0x238   0x6068             STR      R0,[R5, #+4]
   \      0x23A   0x2000             MOVS     R0,#+0
   \      0x23C   0x60A8             STR      R0,[R5, #+8]
   \      0x23E   0x2000             MOVS     R0,#+0
   \      0x240   0x61E8             STR      R0,[R5, #+28]
   2609          
   2610            sli_add_key_parameters(cmd_ctx, key, status);
   \      0x242   0x4669             MOV      R1,SP
   \      0x244   0x981D             LDR      R0,[SP, #+116]
   \      0x246   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x24A   0x4682             MOV      R10,R0
   \      0x24C   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x250   0xD001             BEQ.N    ??sl_se_gcm_multipart_finish_19
   \      0x252   0x4650             MOV      R0,R10
   \      0x254   0xE06F             B.N      ??sl_se_gcm_multipart_finish_2
   \                     ??sl_se_gcm_multipart_finish_19: (+1)
   \      0x256   0x9900             LDR      R1,[SP, #+0]
   \      0x258   0x0028             MOVS     R0,R5
   \      0x25A   0x.... 0x....      BL       SE_addParameter
   2611            SE_addParameter(se_cmd, 0);
   \      0x25E   0x2100             MOVS     R1,#+0
   \      0x260   0x9808             LDR      R0,[SP, #+32]
   \      0x262   0x.... 0x....      BL       SE_addParameter
   2612            SE_addParameter(se_cmd, length);
   \      0x266   0x0039             MOVS     R1,R7
   \      0x268   0xB2C9             UXTB     R1,R1
   \      0x26A   0x9808             LDR      R0,[SP, #+32]
   \      0x26C   0x.... 0x....      BL       SE_addParameter
   2613          
   2614            sli_add_key_metadata(cmd_ctx, key, status);
   \      0x270   0xA919             ADD      R1,SP,#+100
   \      0x272   0x981D             LDR      R0,[SP, #+116]
   \      0x274   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x278   0x4681             MOV      R9,R0
   \      0x27A   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x27E   0xD001             BEQ.N    ??sl_se_gcm_multipart_finish_20
   \      0x280   0x4648             MOV      R0,R9
   \      0x282   0xE058             B.N      ??sl_se_gcm_multipart_finish_2
   \                     ??sl_se_gcm_multipart_finish_20: (+1)
   \      0x284   0xA919             ADD      R1,SP,#+100
   \      0x286   0x0028             MOVS     R0,R5
   \      0x288   0x.... 0x....      BL       SE_addDataInput
   2615            sli_add_key_input(cmd_ctx, key, status);
   \      0x28C   0xA916             ADD      R1,SP,#+88
   \      0x28E   0x981D             LDR      R0,[SP, #+116]
   \      0x290   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x294   0x4682             MOV      R10,R0
   \      0x296   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x29A   0xD001             BEQ.N    ??sl_se_gcm_multipart_finish_21
   \      0x29C   0x4650             MOV      R0,R10
   \      0x29E   0xE04A             B.N      ??sl_se_gcm_multipart_finish_2
   \                     ??sl_se_gcm_multipart_finish_21: (+1)
   \      0x2A0   0xA916             ADD      R1,SP,#+88
   \      0x2A2   0x0028             MOVS     R0,R5
   \      0x2A4   0x.... 0x....      BL       SE_addDataInput
   2616          
   2617            SE_addDataInput(se_cmd, &iv_ctx_in);
   \      0x2A8   0xA913             ADD      R1,SP,#+76
   \      0x2AA   0x9808             LDR      R0,[SP, #+32]
   \      0x2AC   0x.... 0x....      BL       SE_addDataInput
   2618            SE_addDataInput(se_cmd, &data_in);
   \      0x2B0   0xA909             ADD      R1,SP,#+36
   \      0x2B2   0x9808             LDR      R0,[SP, #+32]
   \      0x2B4   0x.... 0x....      BL       SE_addDataInput
   2619            SE_addDataInput(se_cmd, &lenalenc_in);
   \      0x2B8   0xA910             ADD      R1,SP,#+64
   \      0x2BA   0x9808             LDR      R0,[SP, #+32]
   \      0x2BC   0x.... 0x....      BL       SE_addDataInput
   2620          
   2621            if (gcm_ctx->mode == SL_SE_DECRYPT) {
   \      0x2C0   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \      0x2C4   0x2801             CMP      R0,#+1
   \      0x2C6   0xD103             BNE.N    ??sl_se_gcm_multipart_finish_22
   2622              SE_addDataInput(se_cmd, &gcm_tag);
   \      0x2C8   0xA905             ADD      R1,SP,#+20
   \      0x2CA   0x9808             LDR      R0,[SP, #+32]
   \      0x2CC   0x.... 0x....      BL       SE_addDataInput
   2623            }
   2624          
   2625            SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_gcm_multipart_finish_22: (+1)
   \      0x2D0   0xA901             ADD      R1,SP,#+4
   \      0x2D2   0x9808             LDR      R0,[SP, #+32]
   \      0x2D4   0x.... 0x....      BL       SE_addDataOutput
   2626          
   2627            if (gcm_ctx->mode == SL_SE_ENCRYPT) {
   \      0x2D8   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \      0x2DC   0x2800             CMP      R0,#+0
   \      0x2DE   0xD103             BNE.N    ??sl_se_gcm_multipart_finish_23
   2628              SE_addDataOutput(se_cmd, &gcm_tag);
   \      0x2E0   0xA905             ADD      R1,SP,#+20
   \      0x2E2   0x9808             LDR      R0,[SP, #+32]
   \      0x2E4   0x.... 0x....      BL       SE_addDataOutput
   2629            }
   2630          
   2631            status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??sl_se_gcm_multipart_finish_23: (+1)
   \      0x2E8   0x0028             MOVS     R0,R5
   \      0x2EA   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x2EE   0x4681             MOV      R9,R0
   2632          
   2633            if (status != SL_STATUS_OK) {
   \      0x2F0   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x2F4   0xD014             BEQ.N    ??sl_se_gcm_multipart_finish_24
   2634              if (gcm_ctx->mode == SL_SE_ENCRYPT) {
   \      0x2F6   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \      0x2FA   0x2800             CMP      R0,#+0
   \      0x2FC   0xD10B             BNE.N    ??sl_se_gcm_multipart_finish_25
   2635                memset(tag, 0, tag_length);
   \      0x2FE   0x0030             MOVS     R0,R6
   \      0x300   0xB2C0             UXTB     R0,R0
   \      0x302   0x9004             STR      R0,[SP, #+16]
   \      0x304   0xF05F 0x0A00      MOVS     R10,#+0
   \      0x308   0xF8DD 0xB078      LDR      R11,[SP, #+120]
   \      0x30C   0x4652             MOV      R2,R10
   \      0x30E   0x9904             LDR      R1,[SP, #+16]
   \      0x310   0x4658             MOV      R0,R11
   \      0x312   0x.... 0x....      BL       __aeabi_memset
   2636              }
   2637              *output_length = 0;
   \                     ??sl_se_gcm_multipart_finish_25: (+1)
   \      0x316   0x2000             MOVS     R0,#+0
   \      0x318   0xF888 0x0000      STRB     R0,[R8, #+0]
   2638              return status;
   \      0x31C   0x4648             MOV      R0,R9
   \      0x31E   0xE00A             B.N      ??sl_se_gcm_multipart_finish_2
   2639            }
   2640          
   2641            if (length < 16) {
   \                     ??sl_se_gcm_multipart_finish_24: (+1)
   \      0x320   0x0038             MOVS     R0,R7
   \      0x322   0xB2C0             UXTB     R0,R0
   \      0x324   0x2810             CMP      R0,#+16
   \      0x326   0xDA02             BGE.N    ??sl_se_gcm_multipart_finish_26
   2642              *output_length = length;
   \      0x328   0xF888 0x7000      STRB     R7,[R8, #+0]
   \      0x32C   0xE002             B.N      ??sl_se_gcm_multipart_finish_27
   2643            } else {
   2644              *output_length = 0;
   \                     ??sl_se_gcm_multipart_finish_26: (+1)
   \      0x32E   0x2000             MOVS     R0,#+0
   \      0x330   0xF888 0x0000      STRB     R0,[R8, #+0]
   2645            }
   2646          
   2647            return SL_STATUS_OK;
   \                     ??sl_se_gcm_multipart_finish_27: (+1)
   \      0x334   0x2000             MOVS     R0,#+0
   \                     ??sl_se_gcm_multipart_finish_2: (+1)
   \      0x336   0xB01F             ADD      SP,SP,#+124
   \      0x338   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2648          }

   \                                 In section .rodata, align 4
   \                     ?_83:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_84:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_85:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_86:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_87:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   2649          
   2650          #if (defined(_SILICON_LABS_SECURITY_FEATURE) \
   2651            && (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT))
   2652          /***************************************************************************//**
   2653           * ChaCha20 buffer encryption/decryption, as defined by RFC8439 section 2.4.
   2654           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2655          sl_status_t sl_se_chacha20_crypt(sl_se_command_context_t *cmd_ctx,
   2656                                           sl_se_cipher_operation_t mode,
   2657                                           const sl_se_key_descriptor_t *key,
   2658                                           size_t length,
   2659                                           const unsigned char initial_counter[4],
   2660                                           const unsigned char nonce[12],
   2661                                           const unsigned char *input,
   2662                                           unsigned char *output)
   2663          {
   \                     sl_se_chacha20_crypt: (+1)
   \        0x0   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x469B             MOV      R11,R3
   \        0xC   0x9E1F             LDR      R6,[SP, #+124]
   \        0xE   0x9F20             LDR      R7,[SP, #+128]
   \       0x10   0xF8DD 0x8084      LDR      R8,[SP, #+132]
   2664            if (cmd_ctx == NULL || key == NULL || initial_counter == NULL || nonce == NULL
   2665                || input == NULL || output == NULL) {
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD00B             BEQ.N    ??sl_se_chacha20_crypt_0
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD009             BEQ.N    ??sl_se_chacha20_crypt_0
   \       0x1C   0x981E             LDR      R0,[SP, #+120]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD006             BEQ.N    ??sl_se_chacha20_crypt_0
   \       0x22   0x2E00             CMP      R6,#+0
   \       0x24   0xD004             BEQ.N    ??sl_se_chacha20_crypt_0
   \       0x26   0x2F00             CMP      R7,#+0
   \       0x28   0xD002             BEQ.N    ??sl_se_chacha20_crypt_0
   \       0x2A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x2E   0xD101             BNE.N    ??sl_se_chacha20_crypt_1
   2666              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_chacha20_crypt_0: (+1)
   \       0x30   0x2021             MOVS     R0,#+33
   \       0x32   0xE080             B.N      ??sl_se_chacha20_crypt_2
   2667            }
   2668          
   2669            if (key->type != SL_SE_KEY_TYPE_CHACHA20) {
   \                     ??sl_se_chacha20_crypt_1: (+1)
   \       0x34   0x6828             LDR      R0,[R5, #+0]
   \       0x36   0x2820             CMP      R0,#+32
   \       0x38   0xD001             BEQ.N    ??sl_se_chacha20_crypt_3
   2670              return SL_STATUS_INVALID_PARAMETER;
   \       0x3A   0x2021             MOVS     R0,#+33
   \       0x3C   0xE07B             B.N      ??sl_se_chacha20_crypt_2
   2671            }
   2672          
   2673            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_chacha20_crypt_3: (+1)
   \       0x3E   0x9400             STR      R4,[SP, #+0]
   2674            sl_status_t status;
   2675          
   2676            sli_se_command_init(cmd_ctx,
   2677                                (mode == SL_SE_ENCRYPT
   2678                                 ? SLI_SE_COMMAND_CHACHA20_ENCRYPT
   2679                                 : SLI_SE_COMMAND_CHACHA20_DECRYPT)
   2680                                | SLI_SE_COMMAND_OPTION_CONTEXT_WHOLE);
   \       0x40   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD102             BNE.N    ??sl_se_chacha20_crypt_4
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable22_15
   \       0x4C   0xE001             B.N      ??sl_se_chacha20_crypt_5
   \                     ??sl_se_chacha20_crypt_4: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable22_16
   \                     ??sl_se_chacha20_crypt_5: (+1)
   \       0x52   0x6020             STR      R0,[R4, #+0]
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x6060             STR      R0,[R4, #+4]
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x60A0             STR      R0,[R4, #+8]
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x61E0             STR      R0,[R4, #+28]
   2681          
   2682            // Add key parameters to command
   2683            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x60   0xA901             ADD      R1,SP,#+4
   \       0x62   0x0028             MOVS     R0,R5
   \       0x64   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x68   0x4681             MOV      R9,R0
   \       0x6A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x6E   0xD001             BEQ.N    ??sl_se_chacha20_crypt_6
   \       0x70   0x4648             MOV      R0,R9
   \       0x72   0xE060             B.N      ??sl_se_chacha20_crypt_2
   \                     ??sl_se_chacha20_crypt_6: (+1)
   \       0x74   0x9901             LDR      R1,[SP, #+4]
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0x.... 0x....      BL       SE_addParameter
   2684            // Message size (number of bytes)
   2685            SE_addParameter(se_cmd, length);
   \       0x7C   0x4659             MOV      R1,R11
   \       0x7E   0x9800             LDR      R0,[SP, #+0]
   \       0x80   0x.... 0x....      BL       SE_addParameter
   2686          
   2687            // Add key metadata block to command
   2688            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x84   0xA911             ADD      R1,SP,#+68
   \       0x86   0x0028             MOVS     R0,R5
   \       0x88   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x8C   0x4682             MOV      R10,R0
   \       0x8E   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x92   0xD001             BEQ.N    ??sl_se_chacha20_crypt_7
   \       0x94   0x4650             MOV      R0,R10
   \       0x96   0xE04E             B.N      ??sl_se_chacha20_crypt_2
   \                     ??sl_se_chacha20_crypt_7: (+1)
   \       0x98   0xA911             ADD      R1,SP,#+68
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0x.... 0x....      BL       SE_addDataInput
   2689            // Add key input block to command
   2690            sli_add_key_input(cmd_ctx, key, status);
   \       0xA0   0xA90E             ADD      R1,SP,#+56
   \       0xA2   0x0028             MOVS     R0,R5
   \       0xA4   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xA8   0x4681             MOV      R9,R0
   \       0xAA   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xAE   0xD001             BEQ.N    ??sl_se_chacha20_crypt_8
   \       0xB0   0x4648             MOV      R0,R9
   \       0xB2   0xE040             B.N      ??sl_se_chacha20_crypt_2
   \                     ??sl_se_chacha20_crypt_8: (+1)
   \       0xB4   0xA90E             ADD      R1,SP,#+56
   \       0xB6   0x0020             MOVS     R0,R4
   \       0xB8   0x.... 0x....      BL       SE_addDataInput
   2691          
   2692            // Add initial counter to command
   2693            SE_DataTransfer_t counter = SE_DATATRANSFER_DEFAULT(initial_counter, 4);
   \       0xBC   0xF10D 0x0C2C      ADD      R12,SP,#+44
   \       0xC0   0x.... 0x....      LDR.W    R0,??DataTable22_17
   \       0xC4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xC8   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xCC   0x981E             LDR      R0,[SP, #+120]
   \       0xCE   0x900B             STR      R0,[SP, #+44]
   2694            SE_addDataInput(se_cmd, &counter);
   \       0xD0   0xA90B             ADD      R1,SP,#+44
   \       0xD2   0x9800             LDR      R0,[SP, #+0]
   \       0xD4   0x.... 0x....      BL       SE_addDataInput
   2695          
   2696            // Add nonce/IV to command
   2697            SE_DataTransfer_t iv = SE_DATATRANSFER_DEFAULT(nonce, 12);
   \       0xD8   0xAB08             ADD      R3,SP,#+32
   \       0xDA   0x.... 0x....      LDR.W    R0,??DataTable22_18
   \       0xDE   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xE2   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xE6   0x9608             STR      R6,[SP, #+32]
   2698            SE_addDataInput(se_cmd, &iv);
   \       0xE8   0xA908             ADD      R1,SP,#+32
   \       0xEA   0x9800             LDR      R0,[SP, #+0]
   \       0xEC   0x.... 0x....      BL       SE_addDataInput
   2699          
   2700            // Add input data to command
   2701            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(input, length);
   \       0xF0   0xF10D 0x0C14      ADD      R12,SP,#+20
   \       0xF4   0x.... 0x....      LDR.W    R0,??DataTable22_19
   \       0xF8   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xFC   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x100   0x9705             STR      R7,[SP, #+20]
   \      0x102   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \      0x106   0x9007             STR      R0,[SP, #+28]
   2702            SE_addDataInput(se_cmd, &in);
   \      0x108   0xA905             ADD      R1,SP,#+20
   \      0x10A   0x9800             LDR      R0,[SP, #+0]
   \      0x10C   0x.... 0x....      BL       SE_addDataInput
   2703          
   2704            // Request output data from command
   2705            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x110   0xAB02             ADD      R3,SP,#+8
   \      0x112   0x.... 0x....      LDR.W    R12,??DataTable22_20
   \      0x116   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x11A   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x11E   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \      0x122   0xF05B 0x5000      ORRS     R0,R11,#0x20000000
   \      0x126   0x9004             STR      R0,[SP, #+16]
   2706            SE_addDataOutput(se_cmd, &out);
   \      0x128   0xA902             ADD      R1,SP,#+8
   \      0x12A   0x9800             LDR      R0,[SP, #+0]
   \      0x12C   0x.... 0x....      BL       SE_addDataOutput
   2707          
   2708            return sli_se_execute_and_wait(cmd_ctx);
   \      0x130   0x0020             MOVS     R0,R4
   \      0x132   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_chacha20_crypt_2: (+1)
   \      0x136   0xB015             ADD      SP,SP,#+84
   \      0x138   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2709          }

   \                                 In section .rodata, align 4
   \                     ?_88:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004

   \                                 In section .rodata, align 4
   \                     ?_89:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C

   \                                 In section .rodata, align 4
   \                     ?_90:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_91:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   2710          
   2711          /***************************************************************************//**
   2712           * ChaCha20-Poly1305 authenticated encryption with additional data, as defined
   2713           * by RFC8439 section 2.8.
   2714           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2715          sl_status_t sl_se_chacha20_poly1305_encrypt_and_tag(sl_se_command_context_t *cmd_ctx,
   2716                                                              const sl_se_key_descriptor_t *key,
   2717                                                              size_t length,
   2718                                                              const unsigned char nonce[12],
   2719                                                              const unsigned char *add, size_t add_len,
   2720                                                              const unsigned char *input,
   2721                                                              unsigned char *output,
   2722                                                              unsigned char *tag)
   2723          {
   \                     sl_se_chacha20_poly1305_encrypt_and_tag: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB097             SUB      SP,SP,#+92
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x9E23             LDR      R6,[SP, #+140]
   \        0xE   0x9F25             LDR      R7,[SP, #+148]
   \       0x10   0xF8DD 0x8098      LDR      R8,[SP, #+152]
   2724            // Check input parameters.
   2725            if (cmd_ctx == NULL || key == NULL || nonce == NULL
   2726                || ((add_len > 0) && (add == NULL))
   2727                || ((length > 0) && (input == NULL))) {
   \       0x14   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x18   0xD00E             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_0
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD00C             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_0
   \       0x1E   0x9818             LDR      R0,[SP, #+96]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD009             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_0
   \       0x24   0x2E00             CMP      R6,#+0
   \       0x26   0xD002             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_1
   \       0x28   0x9822             LDR      R0,[SP, #+136]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD004             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_0
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_1: (+1)
   \       0x2E   0x2D00             CMP      R5,#+0
   \       0x30   0xD004             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_2
   \       0x32   0x9824             LDR      R0,[SP, #+144]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD101             BNE.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_2
   2728              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_0: (+1)
   \       0x38   0x2021             MOVS     R0,#+33
   \       0x3A   0xE09F             B.N      ??sl_se_chacha20_poly1305_encrypt_and_tag_3
   2729            }
   2730          
   2731            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_2: (+1)
   \       0x3C   0xF8CD 0xB000      STR      R11,[SP, #+0]
   2732            sl_status_t status;
   2733          
   2734            if (key->type != SL_SE_KEY_TYPE_CHACHA20) {
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x2820             CMP      R0,#+32
   \       0x44   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_4
   2735              return SL_STATUS_INVALID_PARAMETER;
   \       0x46   0x2021             MOVS     R0,#+33
   \       0x48   0xE098             B.N      ??sl_se_chacha20_poly1305_encrypt_and_tag_3
   2736            }
   2737          
   2738            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CHACHAPOLY_ENCRYPT);
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_4: (+1)
   \       0x4A   0xF05F 0x6040      MOVS     R0,#+201326592
   \       0x4E   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF8CB 0x001C      STR      R0,[R11, #+28]
   2739          
   2740            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x64   0xA901             ADD      R1,SP,#+4
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x6C   0x4681             MOV      R9,R0
   \       0x6E   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x72   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_5
   \       0x74   0x4648             MOV      R0,R9
   \       0x76   0xE081             B.N      ??sl_se_chacha20_poly1305_encrypt_and_tag_3
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_5: (+1)
   \       0x78   0x9901             LDR      R1,[SP, #+4]
   \       0x7A   0x4658             MOV      R0,R11
   \       0x7C   0x.... 0x....      BL       SE_addParameter
   2741            SE_addParameter(se_cmd, add_len);
   \       0x80   0x0031             MOVS     R1,R6
   \       0x82   0x9800             LDR      R0,[SP, #+0]
   \       0x84   0x.... 0x....      BL       SE_addParameter
   2742            SE_addParameter(se_cmd, length);
   \       0x88   0x0029             MOVS     R1,R5
   \       0x8A   0x9800             LDR      R0,[SP, #+0]
   \       0x8C   0x.... 0x....      BL       SE_addParameter
   2743          
   2744            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x90   0xA914             ADD      R1,SP,#+80
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x98   0x4682             MOV      R10,R0
   \       0x9A   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x9E   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_6
   \       0xA0   0x4650             MOV      R0,R10
   \       0xA2   0xE06B             B.N      ??sl_se_chacha20_poly1305_encrypt_and_tag_3
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_6: (+1)
   \       0xA4   0xA914             ADD      R1,SP,#+80
   \       0xA6   0x4658             MOV      R0,R11
   \       0xA8   0x.... 0x....      BL       SE_addDataInput
   2745            sli_add_key_input(cmd_ctx, key, status);
   \       0xAC   0xA911             ADD      R1,SP,#+68
   \       0xAE   0x0020             MOVS     R0,R4
   \       0xB0   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xB4   0x4681             MOV      R9,R0
   \       0xB6   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xBA   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_7
   \       0xBC   0x4648             MOV      R0,R9
   \       0xBE   0xE05D             B.N      ??sl_se_chacha20_poly1305_encrypt_and_tag_3
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_7: (+1)
   \       0xC0   0xA911             ADD      R1,SP,#+68
   \       0xC2   0x4658             MOV      R0,R11
   \       0xC4   0x.... 0x....      BL       SE_addDataInput
   2746          
   2747            SE_DataTransfer_t nonce_in = SE_DATATRANSFER_DEFAULT(nonce, 12);
   \       0xC8   0xF10D 0x0C38      ADD      R12,SP,#+56
   \       0xCC   0x.... 0x....      LDR.W    R0,??DataTable22_21
   \       0xD0   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xD4   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xD8   0x9818             LDR      R0,[SP, #+96]
   \       0xDA   0x900E             STR      R0,[SP, #+56]
   2748            SE_addDataInput(se_cmd, &nonce_in);
   \       0xDC   0xA90E             ADD      R1,SP,#+56
   \       0xDE   0x9800             LDR      R0,[SP, #+0]
   \       0xE0   0x.... 0x....      BL       SE_addDataInput
   2749          
   2750            SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \       0xE4   0xAB0B             ADD      R3,SP,#+44
   \       0xE6   0x.... 0x....      LDR.W    R12,??DataTable22_22
   \       0xEA   0xE89C 0x0007      LDM      R12,{R0-R2}
   \       0xEE   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xF2   0x9822             LDR      R0,[SP, #+136]
   \       0xF4   0x900B             STR      R0,[SP, #+44]
   \       0xF6   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \       0xFA   0x900D             STR      R0,[SP, #+52]
   2751            SE_addDataInput(se_cmd, &aad_in);
   \       0xFC   0xA90B             ADD      R1,SP,#+44
   \       0xFE   0x9800             LDR      R0,[SP, #+0]
   \      0x100   0x.... 0x....      BL       SE_addDataInput
   2752          
   2753            SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \      0x104   0xF10D 0x0C20      ADD      R12,SP,#+32
   \      0x108   0x.... 0x....      LDR.W    R0,??DataTable22_23
   \      0x10C   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x110   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x114   0x9824             LDR      R0,[SP, #+144]
   \      0x116   0x9008             STR      R0,[SP, #+32]
   \      0x118   0xF055 0x5000      ORRS     R0,R5,#0x20000000
   \      0x11C   0x900A             STR      R0,[SP, #+40]
   2754            SE_addDataInput(se_cmd, &data_in);
   \      0x11E   0xA908             ADD      R1,SP,#+32
   \      0x120   0x9800             LDR      R0,[SP, #+0]
   \      0x122   0x.... 0x....      BL       SE_addDataInput
   2755          
   2756            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x126   0xAB05             ADD      R3,SP,#+20
   \      0x128   0x....             LDR.N    R0,??DataTable22_24
   \      0x12A   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x12E   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x132   0x9705             STR      R7,[SP, #+20]
   \      0x134   0xF055 0x5000      ORRS     R0,R5,#0x20000000
   \      0x138   0x9007             STR      R0,[SP, #+28]
   2757            if (output == NULL) {
   \      0x13A   0x2F00             CMP      R7,#+0
   \      0x13C   0xD103             BNE.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_8
   2758              data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x13E   0x9807             LDR      R0,[SP, #+28]
   \      0x140   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x144   0x9007             STR      R0,[SP, #+28]
   2759            }
   2760            SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_8: (+1)
   \      0x146   0xA905             ADD      R1,SP,#+20
   \      0x148   0x9800             LDR      R0,[SP, #+0]
   \      0x14A   0x.... 0x....      BL       SE_addDataOutput
   2761          
   2762            SE_DataTransfer_t mac_out = SE_DATATRANSFER_DEFAULT(tag, 16);
   \      0x14E   0xAB02             ADD      R3,SP,#+8
   \      0x150   0x.... 0x....      LDR.W    R12,??DataTable22_25
   \      0x154   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x158   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x15C   0xF8CD 0x8008      STR      R8,[SP, #+8]
   2763            if (tag == NULL) {
   \      0x160   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x164   0xD103             BNE.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_9
   2764              mac_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x166   0x9804             LDR      R0,[SP, #+16]
   \      0x168   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x16C   0x9004             STR      R0,[SP, #+16]
   2765            }
   2766            SE_addDataOutput(se_cmd, &mac_out);
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_9: (+1)
   \      0x16E   0xA902             ADD      R1,SP,#+8
   \      0x170   0x9800             LDR      R0,[SP, #+0]
   \      0x172   0x.... 0x....      BL       SE_addDataOutput
   2767          
   2768            // Execute AEAD operation.
   2769            return sli_se_execute_and_wait(cmd_ctx);
   \      0x176   0x4658             MOV      R0,R11
   \      0x178   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_3: (+1)
   \      0x17C   0xB019             ADD      SP,SP,#+100
   \      0x17E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2770          }

   \                                 In section .rodata, align 4
   \                     ?_92:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C

   \                                 In section .rodata, align 4
   \                     ?_93:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_94:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_95:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_96:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   2771          
   2772          /***************************************************************************//**
   2773           * ChaCha20-Poly1305 authenticated decryption with additional data, as defined
   2774           * by RFC8439 section 2.8.
   2775           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2776          sl_status_t sl_se_chacha20_poly1305_auth_decrypt(sl_se_command_context_t *cmd_ctx,
   2777                                                           const sl_se_key_descriptor_t *key,
   2778                                                           size_t length,
   2779                                                           const unsigned char nonce[12],
   2780                                                           const unsigned char *add, size_t add_len,
   2781                                                           const unsigned char *input,
   2782                                                           unsigned char *output,
   2783                                                           const unsigned char tag[16])
   2784          {
   \                     sl_se_chacha20_poly1305_auth_decrypt: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB097             SUB      SP,SP,#+92
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x9E23             LDR      R6,[SP, #+140]
   \        0xE   0x9F25             LDR      R7,[SP, #+148]
   \       0x10   0xF8DD 0x8098      LDR      R8,[SP, #+152]
   2785            // Check input parameters.
   2786            if (cmd_ctx == NULL || key == NULL || nonce == NULL || tag == NULL
   2787                || ((add_len > 0) && (add == NULL))
   2788                || ((length > 0) && (input == NULL))) {
   \       0x14   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x18   0xD011             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_0
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD00F             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_0
   \       0x1E   0x9818             LDR      R0,[SP, #+96]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD00C             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_0
   \       0x24   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x28   0xD009             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_0
   \       0x2A   0x2E00             CMP      R6,#+0
   \       0x2C   0xD002             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_1
   \       0x2E   0x9822             LDR      R0,[SP, #+136]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD004             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_0
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_1: (+1)
   \       0x34   0x2D00             CMP      R5,#+0
   \       0x36   0xD004             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_2
   \       0x38   0x9824             LDR      R0,[SP, #+144]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD101             BNE.N    ??sl_se_chacha20_poly1305_auth_decrypt_2
   2789              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_0: (+1)
   \       0x3E   0x2021             MOVS     R0,#+33
   \       0x40   0xE093             B.N      ??sl_se_chacha20_poly1305_auth_decrypt_3
   2790            }
   2791          
   2792            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_2: (+1)
   \       0x42   0xF8CD 0xB000      STR      R11,[SP, #+0]
   2793            sl_status_t status;
   2794          
   2795            if (key->type != SL_SE_KEY_TYPE_CHACHA20) {
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x2820             CMP      R0,#+32
   \       0x4A   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_4
   2796              return SL_STATUS_INVALID_PARAMETER;
   \       0x4C   0x2021             MOVS     R0,#+33
   \       0x4E   0xE08C             B.N      ??sl_se_chacha20_poly1305_auth_decrypt_3
   2797            }
   2798          
   2799            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CHACHAPOLY_DECRYPT);
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_4: (+1)
   \       0x50   0x....             LDR.N    R0,??DataTable22_26
   \       0x52   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xF8CB 0x001C      STR      R0,[R11, #+28]
   2800          
   2801            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x68   0xA901             ADD      R1,SP,#+4
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x70   0x4681             MOV      R9,R0
   \       0x72   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x76   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_5
   \       0x78   0x4648             MOV      R0,R9
   \       0x7A   0xE076             B.N      ??sl_se_chacha20_poly1305_auth_decrypt_3
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_5: (+1)
   \       0x7C   0x9901             LDR      R1,[SP, #+4]
   \       0x7E   0x4658             MOV      R0,R11
   \       0x80   0x.... 0x....      BL       SE_addParameter
   2802            SE_addParameter(se_cmd, add_len);
   \       0x84   0x0031             MOVS     R1,R6
   \       0x86   0x9800             LDR      R0,[SP, #+0]
   \       0x88   0x.... 0x....      BL       SE_addParameter
   2803            SE_addParameter(se_cmd, length);
   \       0x8C   0x0029             MOVS     R1,R5
   \       0x8E   0x9800             LDR      R0,[SP, #+0]
   \       0x90   0x.... 0x....      BL       SE_addParameter
   2804          
   2805            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x94   0xA914             ADD      R1,SP,#+80
   \       0x96   0x0020             MOVS     R0,R4
   \       0x98   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x9C   0x4682             MOV      R10,R0
   \       0x9E   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xA2   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_6
   \       0xA4   0x4650             MOV      R0,R10
   \       0xA6   0xE060             B.N      ??sl_se_chacha20_poly1305_auth_decrypt_3
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_6: (+1)
   \       0xA8   0xA914             ADD      R1,SP,#+80
   \       0xAA   0x4658             MOV      R0,R11
   \       0xAC   0x.... 0x....      BL       SE_addDataInput
   2806            sli_add_key_input(cmd_ctx, key, status);
   \       0xB0   0xA911             ADD      R1,SP,#+68
   \       0xB2   0x0020             MOVS     R0,R4
   \       0xB4   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xB8   0x4681             MOV      R9,R0
   \       0xBA   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xBE   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_7
   \       0xC0   0x4648             MOV      R0,R9
   \       0xC2   0xE052             B.N      ??sl_se_chacha20_poly1305_auth_decrypt_3
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_7: (+1)
   \       0xC4   0xA911             ADD      R1,SP,#+68
   \       0xC6   0x4658             MOV      R0,R11
   \       0xC8   0x.... 0x....      BL       SE_addDataInput
   2807          
   2808            SE_DataTransfer_t nonce_in = SE_DATATRANSFER_DEFAULT(nonce, 12);
   \       0xCC   0xF10D 0x0C38      ADD      R12,SP,#+56
   \       0xD0   0x....             LDR.N    R0,??DataTable22_27
   \       0xD2   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xD6   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xDA   0x9818             LDR      R0,[SP, #+96]
   \       0xDC   0x900E             STR      R0,[SP, #+56]
   2809            SE_addDataInput(se_cmd, &nonce_in);
   \       0xDE   0xA90E             ADD      R1,SP,#+56
   \       0xE0   0x9800             LDR      R0,[SP, #+0]
   \       0xE2   0x.... 0x....      BL       SE_addDataInput
   2810          
   2811            SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \       0xE6   0xAB08             ADD      R3,SP,#+32
   \       0xE8   0x....             LDR.N    R0,??DataTable22_28
   \       0xEA   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xEE   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xF2   0x9822             LDR      R0,[SP, #+136]
   \       0xF4   0x9008             STR      R0,[SP, #+32]
   \       0xF6   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \       0xFA   0x900A             STR      R0,[SP, #+40]
   2812            SE_addDataInput(se_cmd, &aad_in);
   \       0xFC   0xA908             ADD      R1,SP,#+32
   \       0xFE   0x9800             LDR      R0,[SP, #+0]
   \      0x100   0x.... 0x....      BL       SE_addDataInput
   2813          
   2814            SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \      0x104   0xAB05             ADD      R3,SP,#+20
   \      0x106   0x....             LDR.N    R0,??DataTable22_29
   \      0x108   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x10C   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x110   0x9824             LDR      R0,[SP, #+144]
   \      0x112   0x9005             STR      R0,[SP, #+20]
   \      0x114   0xF055 0x5000      ORRS     R0,R5,#0x20000000
   \      0x118   0x9007             STR      R0,[SP, #+28]
   2815            SE_addDataInput(se_cmd, &data_in);
   \      0x11A   0xA905             ADD      R1,SP,#+20
   \      0x11C   0x9800             LDR      R0,[SP, #+0]
   \      0x11E   0x.... 0x....      BL       SE_addDataInput
   2816          
   2817            SE_DataTransfer_t mac_in = SE_DATATRANSFER_DEFAULT(tag, 16);
   \      0x122   0xF10D 0x0C2C      ADD      R12,SP,#+44
   \      0x126   0x....             LDR.N    R0,??DataTable22_30
   \      0x128   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x12C   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x130   0xF8CD 0x802C      STR      R8,[SP, #+44]
   2818            SE_addDataInput(se_cmd, &mac_in);
   \      0x134   0xA90B             ADD      R1,SP,#+44
   \      0x136   0x9800             LDR      R0,[SP, #+0]
   \      0x138   0x.... 0x....      BL       SE_addDataInput
   2819          
   2820            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x13C   0xAB02             ADD      R3,SP,#+8
   \      0x13E   0x....             LDR.N    R0,??DataTable22_31
   \      0x140   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x144   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x148   0x9702             STR      R7,[SP, #+8]
   \      0x14A   0xF055 0x5000      ORRS     R0,R5,#0x20000000
   \      0x14E   0x9004             STR      R0,[SP, #+16]
   2821            if (output == NULL) {
   \      0x150   0x2F00             CMP      R7,#+0
   \      0x152   0xD103             BNE.N    ??sl_se_chacha20_poly1305_auth_decrypt_8
   2822              data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x154   0x9804             LDR      R0,[SP, #+16]
   \      0x156   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x15A   0x9004             STR      R0,[SP, #+16]
   2823            }
   2824            SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_8: (+1)
   \      0x15C   0xA902             ADD      R1,SP,#+8
   \      0x15E   0x9800             LDR      R0,[SP, #+0]
   \      0x160   0x.... 0x....      BL       SE_addDataOutput
   2825          
   2826            // Execute AEAD operation.
   2827            return sli_se_execute_and_wait(cmd_ctx);
   \      0x164   0x4658             MOV      R0,R11
   \      0x166   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_3: (+1)
   \      0x16A   0xB019             ADD      SP,SP,#+100
   \      0x16C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2828          }

   \                                 In section .rodata, align 4
   \                     ?_97:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C

   \                                 In section .rodata, align 4
   \                     ?_98:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_99:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_100:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .rodata, align 4
   \                     ?_101:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   2829          
   2830          /***************************************************************************//**
   2831           * Generate a MAC (message authentication code) for a given message, according
   2832           * to RFC8439 section 2.8 but bypassing the encryption step.
   2833           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2834          sl_status_t sl_se_poly1305_genkey_tag(sl_se_command_context_t *cmd_ctx,
   2835                                                const sl_se_key_descriptor_t *key,
   2836                                                size_t length,
   2837                                                const unsigned char nonce[12],
   2838                                                const unsigned char *input,
   2839                                                unsigned char *tag)
   2840          {
   \                     sl_se_poly1305_genkey_tag: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB091             SUB      SP,SP,#+68
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
   \        0xE   0x9F1A             LDR      R7,[SP, #+104]
   \       0x10   0xF8DD 0x806C      LDR      R8,[SP, #+108]
   2841            if (cmd_ctx == NULL || key == NULL || nonce == NULL || tag == NULL
   2842                || ((length > 0) && (input == NULL))) {
   \       0x14   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x18   0xD00A             BEQ.N    ??sl_se_poly1305_genkey_tag_0
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD008             BEQ.N    ??sl_se_poly1305_genkey_tag_0
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD006             BEQ.N    ??sl_se_poly1305_genkey_tag_0
   \       0x22   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x26   0xD003             BEQ.N    ??sl_se_poly1305_genkey_tag_0
   \       0x28   0x2D00             CMP      R5,#+0
   \       0x2A   0xD003             BEQ.N    ??sl_se_poly1305_genkey_tag_1
   \       0x2C   0x2F00             CMP      R7,#+0
   \       0x2E   0xD101             BNE.N    ??sl_se_poly1305_genkey_tag_1
   2843              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_poly1305_genkey_tag_0: (+1)
   \       0x30   0x2021             MOVS     R0,#+33
   \       0x32   0xE06B             B.N      ??sl_se_poly1305_genkey_tag_2
   2844            }
   2845          
   2846            if (key->type != SL_SE_KEY_TYPE_CHACHA20) {
   \                     ??sl_se_poly1305_genkey_tag_1: (+1)
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x2820             CMP      R0,#+32
   \       0x38   0xD001             BEQ.N    ??sl_se_poly1305_genkey_tag_3
   2847              return SL_STATUS_INVALID_PARAMETER;
   \       0x3A   0x2021             MOVS     R0,#+33
   \       0x3C   0xE066             B.N      ??sl_se_poly1305_genkey_tag_2
   2848            }
   2849          
   2850            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_poly1305_genkey_tag_3: (+1)
   \       0x3E   0xF8CD 0xB000      STR      R11,[SP, #+0]
   2851            sl_status_t status;
   2852          
   2853            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_POLY1305_KEY_MAC);
   \       0x42   0x....             LDR.N    R0,??DataTable22_32
   \       0x44   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xF8CB 0x001C      STR      R0,[R11, #+28]
   2854          
   2855            // Add key parameters to command
   2856            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x5A   0xA901             ADD      R1,SP,#+4
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x62   0x4681             MOV      R9,R0
   \       0x64   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x68   0xD001             BEQ.N    ??sl_se_poly1305_genkey_tag_4
   \       0x6A   0x4648             MOV      R0,R9
   \       0x6C   0xE04E             B.N      ??sl_se_poly1305_genkey_tag_2
   \                     ??sl_se_poly1305_genkey_tag_4: (+1)
   \       0x6E   0x9901             LDR      R1,[SP, #+4]
   \       0x70   0x4658             MOV      R0,R11
   \       0x72   0x.... 0x....      BL       SE_addParameter
   2857            // Message size (number of bytes)
   2858            SE_addParameter(se_cmd, length);
   \       0x76   0x0029             MOVS     R1,R5
   \       0x78   0x9800             LDR      R0,[SP, #+0]
   \       0x7A   0x.... 0x....      BL       SE_addParameter
   2859          
   2860            // Add key metadata block to command
   2861            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x7E   0xA90E             ADD      R1,SP,#+56
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x86   0x4682             MOV      R10,R0
   \       0x88   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x8C   0xD001             BEQ.N    ??sl_se_poly1305_genkey_tag_5
   \       0x8E   0x4650             MOV      R0,R10
   \       0x90   0xE03C             B.N      ??sl_se_poly1305_genkey_tag_2
   \                     ??sl_se_poly1305_genkey_tag_5: (+1)
   \       0x92   0xA90E             ADD      R1,SP,#+56
   \       0x94   0x4658             MOV      R0,R11
   \       0x96   0x.... 0x....      BL       SE_addDataInput
   2862            // Add key input block to command
   2863            sli_add_key_input(cmd_ctx, key, status);
   \       0x9A   0xA90B             ADD      R1,SP,#+44
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xA2   0x4681             MOV      R9,R0
   \       0xA4   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xA8   0xD001             BEQ.N    ??sl_se_poly1305_genkey_tag_6
   \       0xAA   0x4648             MOV      R0,R9
   \       0xAC   0xE02E             B.N      ??sl_se_poly1305_genkey_tag_2
   \                     ??sl_se_poly1305_genkey_tag_6: (+1)
   \       0xAE   0xA90B             ADD      R1,SP,#+44
   \       0xB0   0x4658             MOV      R0,R11
   \       0xB2   0x.... 0x....      BL       SE_addDataInput
   2864          
   2865            // Add nonce/IV to command
   2866            SE_DataTransfer_t iv = SE_DATATRANSFER_DEFAULT(nonce, 12);
   \       0xB6   0xF10D 0x0C20      ADD      R12,SP,#+32
   \       0xBA   0x....             LDR.N    R0,??DataTable22_33
   \       0xBC   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xC0   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xC4   0x9608             STR      R6,[SP, #+32]
   2867            SE_addDataInput(se_cmd, &iv);
   \       0xC6   0xA908             ADD      R1,SP,#+32
   \       0xC8   0x9800             LDR      R0,[SP, #+0]
   \       0xCA   0x.... 0x....      BL       SE_addDataInput
   2868          
   2869            // Add input data to command
   2870            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(input, length);
   \       0xCE   0xF10D 0x0C08      ADD      R12,SP,#+8
   \       0xD2   0x....             LDR.N    R0,??DataTable22_34
   \       0xD4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xD8   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xDC   0x9702             STR      R7,[SP, #+8]
   \       0xDE   0xF055 0x5000      ORRS     R0,R5,#0x20000000
   \       0xE2   0x9004             STR      R0,[SP, #+16]
   2871            SE_addDataInput(se_cmd, &in);
   \       0xE4   0xA902             ADD      R1,SP,#+8
   \       0xE6   0x9800             LDR      R0,[SP, #+0]
   \       0xE8   0x.... 0x....      BL       SE_addDataInput
   2872          
   2873            // Request tag from command
   2874            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(tag, 16);
   \       0xEC   0xF10D 0x0C14      ADD      R12,SP,#+20
   \       0xF0   0x....             LDR.N    R0,??DataTable22_35
   \       0xF2   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xF6   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xFA   0xF8CD 0x8014      STR      R8,[SP, #+20]
   2875            SE_addDataOutput(se_cmd, &out);
   \       0xFE   0xA905             ADD      R1,SP,#+20
   \      0x100   0x9800             LDR      R0,[SP, #+0]
   \      0x102   0x.... 0x....      BL       SE_addDataOutput
   2876          
   2877            return sli_se_execute_and_wait(cmd_ctx);
   \      0x106   0x4658             MOV      R0,R11
   \      0x108   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_poly1305_genkey_tag_2: (+1)
   \      0x10C   0xB011             ADD      SP,SP,#+68
   \      0x10E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2878          }

   \                                 In section .rodata, align 4
   \                     ?_102:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C

   \                                 In section .rodata, align 4
   \                     ?_103:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_104:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x0401'0000        DC32     0x4010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x0400'0303        DC32     0x4000303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x2004'0000        DC32     0x20040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x0405'0000        DC32     0x4050000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x0406'0000        DC32     0x4060000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x....'....        DC32     ?_24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x....'....        DC32     ?_25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x....'....        DC32     ?_26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     ?_27

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x....'....        DC32     ?_28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     ?_29

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     ?_30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     ?_31

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x....'....        DC32     ?_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     ?_33

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x....'....        DC32     ?_34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x....'....        DC32     ?_35

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \        0x0   0x....'....        DC32     ?_36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \        0x0   0x....'....        DC32     ?_37

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \        0x0   0x....'....        DC32     ?_38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     ?_39

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     ?_40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     ?_41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x....'....        DC32     ?_42

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x0405'0000        DC32     0x4050000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x0404'0000        DC32     0x4040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     ?_43

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     ?_44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x....'....        DC32     ?_45

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x....'....        DC32     ?_46

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x....'....        DC32     ?_47

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x....'....        DC32     ?_48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x0400'0203        DC32     0x4000203

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x....'....        DC32     ?_49

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0x....'....        DC32     ?_50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0x....'....        DC32     ?_51

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x....'....        DC32     ?_52

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \        0x0   0x....'....        DC32     ?_53

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \        0x0   0x....'....        DC32     ?_54

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \        0x0   0x0302'0200        DC32     0x3020200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \        0x0   0x0302'0300        DC32     0x3020300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \        0x0   0x0302'0400        DC32     0x3020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \        0x0   0x0302'0500        DC32     0x3020500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \        0x0   0x0302'0600        DC32     0x3020600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     ?_55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     ?_56

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x0403'0000        DC32     0x4030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \        0x0   0x....'....        DC32     ?_57

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \        0x0   0x....'....        DC32     ?_58

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \        0x0   0x....'....        DC32     ?_59

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \        0x0   0x....'....        DC32     ?_60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \        0x0   0x....'....        DC32     ?_61

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \        0x0   0x0402'0000        DC32     0x4020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x....'....        DC32     ?_62

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x....'....        DC32     ?_63

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x....'....        DC32     ?_64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \        0x0   0x....'....        DC32     ?_65

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \        0x0   0x....'....        DC32     ?_66

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x....'....        DC32     ?_67

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x....'....        DC32     ?_68

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x....'....        DC32     ?_69

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0x....'....        DC32     ?_70

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x....'....        DC32     ?_71

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x....'....        DC32     ?_72

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x....'....        DC32     ?_73

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \        0x0   0x....'....        DC32     ?_74

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     ?_75

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x....'....        DC32     ?_76

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x....'....        DC32     ?_77

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0x....'....        DC32     ?_78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \        0x0   0x....'....        DC32     ?_79

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \        0x0   0x....'....        DC32     ?_80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \        0x0   0x....'....        DC32     ?_81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \        0x0   0x....'....        DC32     ?_82

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \        0x0   0x....'....        DC32     ?_83

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \        0x0   0x....'....        DC32     ?_84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \        0x0   0x....'....        DC32     ?_85

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \        0x0   0x....'....        DC32     ?_86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_12:
   \        0x0   0x....'....        DC32     ?_87

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_13:
   \        0x0   0x0403'0000        DC32     0x4030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_14:
   \        0x0   0x0402'0000        DC32     0x4020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_15:
   \        0x0   0x0C02'0000        DC32     0xc020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_16:
   \        0x0   0x0C03'0000        DC32     0xc030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_17:
   \        0x0   0x....'....        DC32     ?_88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_18:
   \        0x0   0x....'....        DC32     ?_89

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_19:
   \        0x0   0x....'....        DC32     ?_90

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_20:
   \        0x0   0x....'....        DC32     ?_91

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_21:
   \        0x0   0x....'....        DC32     ?_92

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_22:
   \        0x0   0x....'....        DC32     ?_93

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_23:
   \        0x0   0x....'....        DC32     ?_94

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_24:
   \        0x0   0x....'....        DC32     ?_95

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_25:
   \        0x0   0x....'....        DC32     ?_96

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_26:
   \        0x0   0x0C01'0000        DC32     0xc010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_27:
   \        0x0   0x....'....        DC32     ?_97

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_28:
   \        0x0   0x....'....        DC32     ?_98

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_29:
   \        0x0   0x....'....        DC32     ?_99

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_30:
   \        0x0   0x....'....        DC32     ?_100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_31:
   \        0x0   0x....'....        DC32     ?_101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_32:
   \        0x0   0x0C04'0000        DC32     0xc040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_33:
   \        0x0   0x....'....        DC32     ?_102

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_34:
   \        0x0   0x....'....        DC32     ?_103

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_35:
   \        0x0   0x....'....        DC32     ?_104
   2879          #endif
   2880          
   2881          /** @} (end addtogroup sl_se) */
   2882          
   2883          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   increment_nonce_counter
      12   memcmp_time_cst
     120   sl_se_aes_crypt_cbc
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
     136   sl_se_aes_crypt_cfb128
       136   -> SE_addDataInput
       136   -> SE_addDataOutput
       136   -> SE_addParameter
       136   -> sl_se_aes_crypt_ecb
       136   -> sli_se_execute_and_wait
       136   -> sli_se_get_auth_buffer
       136   -> sli_se_get_key_input_output
       136   -> sli_se_key_to_keyspec
      80   sl_se_aes_crypt_cfb8
        80   -> __aeabi_memcpy
        80   -> sl_se_aes_crypt_ecb
     136   sl_se_aes_crypt_ctr
       136   -> SE_addDataInput
       136   -> SE_addDataOutput
       136   -> SE_addParameter
       136   -> increment_nonce_counter
       136   -> sl_se_aes_crypt_ecb
       136   -> sli_se_execute_and_wait
       136   -> sli_se_get_auth_buffer
       136   -> sli_se_get_key_input_output
       136   -> sli_se_key_to_keyspec
      96   sl_se_aes_crypt_ecb
        96   -> SE_addDataInput
        96   -> SE_addDataOutput
        96   -> SE_addParameter
        96   -> sli_se_execute_and_wait
        96   -> sli_se_get_auth_buffer
        96   -> sli_se_get_key_input_output
        96   -> sli_se_key_to_keyspec
     144   sl_se_ccm_auth_decrypt
       144   -> SE_addDataInput
       144   -> SE_addDataOutput
       144   -> SE_addParameter
       144   -> __aeabi_memset
       144   -> sli_se_execute_and_wait
       144   -> sli_se_get_auth_buffer
       144   -> sli_se_get_key_input_output
       144   -> sli_se_key_to_keyspec
     136   sl_se_ccm_encrypt_and_tag
       136   -> SE_addDataInput
       136   -> SE_addDataOutput
       136   -> SE_addParameter
       136   -> sli_se_execute_and_wait
       136   -> sli_se_get_auth_buffer
       136   -> sli_se_get_key_input_output
       136   -> sli_se_key_to_keyspec
     120   sl_se_ccm_multipart_finish
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> __aeabi_memcpy
       120   -> __aeabi_memset
       120   -> memcmp_time_cst
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
     200   sl_se_ccm_multipart_starts
       200   -> SE_addDataInput
       200   -> SE_addDataOutput
       200   -> SE_addParameter
       200   -> __aeabi_memcpy
       200   -> __aeabi_memset
       200   -> sli_se_execute_and_wait
       200   -> sli_se_get_auth_buffer
       200   -> sli_se_get_key_input_output
       200   -> sli_se_key_to_keyspec
     208   sl_se_ccm_multipart_update
       208   -> SE_addDataInput
       208   -> SE_addDataOutput
       208   -> SE_addParameter
       208   -> __aeabi_memcpy
       208   -> __aeabi_memset
       208   -> sli_se_execute_and_wait
       208   -> sli_se_get_auth_buffer
       208   -> sli_se_get_key_input_output
       208   -> sli_se_key_to_keyspec
     120   sl_se_chacha20_crypt
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
     136   sl_se_chacha20_poly1305_auth_decrypt
       136   -> SE_addDataInput
       136   -> SE_addDataOutput
       136   -> SE_addParameter
       136   -> sli_se_execute_and_wait
       136   -> sli_se_get_auth_buffer
       136   -> sli_se_get_key_input_output
       136   -> sli_se_key_to_keyspec
     136   sl_se_chacha20_poly1305_encrypt_and_tag
       136   -> SE_addDataInput
       136   -> SE_addDataOutput
       136   -> SE_addParameter
       136   -> sli_se_execute_and_wait
       136   -> sli_se_get_auth_buffer
       136   -> sli_se_get_key_input_output
       136   -> sli_se_key_to_keyspec
      88   sl_se_cmac
        88   -> SE_addDataInput
        88   -> SE_addDataOutput
        88   -> SE_addParameter
        88   -> sli_se_execute_and_wait
        88   -> sli_se_get_auth_buffer
        88   -> sli_se_get_key_input_output
        88   -> sli_se_key_to_keyspec
     112   sl_se_cmac_multipart_finish
       112   -> SE_addDataInput
       112   -> SE_addDataOutput
       112   -> SE_addParameter
       112   -> sl_se_aes_crypt_ecb
       112   -> sli_se_execute_and_wait
       112   -> sli_se_get_auth_buffer
       112   -> sli_se_get_key_input_output
       112   -> sli_se_key_to_keyspec
      32   sl_se_cmac_multipart_starts
        32   -> __aeabi_memset
     160   sl_se_cmac_multipart_update
       160   -> SE_addDataInput
       160   -> SE_addDataOutput
       160   -> SE_addParameter
       160   -> __aeabi_memcpy
       160   -> sli_se_execute_and_wait
       160   -> sli_se_get_auth_buffer
       160   -> sli_se_get_key_input_output
       160   -> sli_se_key_to_keyspec
     144   sl_se_gcm_auth_decrypt
       144   -> SE_addDataInput
       144   -> SE_addDataOutput
       144   -> SE_addParameter
       144   -> __aeabi_memset
       144   -> sli_se_execute_and_wait
       144   -> sli_se_get_auth_buffer
       144   -> sli_se_get_key_input_output
       144   -> sli_se_key_to_keyspec
     240   sl_se_gcm_crypt_and_tag
       240   -> SE_addDataInput
       240   -> SE_addDataOutput
       240   -> SE_addParameter
       240   -> __aeabi_memcpy
       240   -> __aeabi_memset
       240   -> sli_se_execute_and_wait
       240   -> sli_se_get_auth_buffer
       240   -> sli_se_get_key_input_output
       240   -> sli_se_key_to_keyspec
     160   sl_se_gcm_multipart_finish
       160   -> SE_addDataInput
       160   -> SE_addDataOutput
       160   -> SE_addParameter
       160   -> __aeabi_memset
       160   -> sl_se_gcm_auth_decrypt
       160   -> sl_se_gcm_crypt_and_tag
       160   -> sli_se_execute_and_wait
       160   -> sli_se_get_auth_buffer
       160   -> sli_se_get_key_input_output
       160   -> sli_se_key_to_keyspec
     120   sl_se_gcm_multipart_starts
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> __aeabi_memcpy
       120   -> __aeabi_memset
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
     208   sl_se_gcm_multipart_update
       208   -> SE_addDataInput
       208   -> SE_addDataOutput
       208   -> SE_addParameter
       208   -> __aeabi_memcpy
       208   -> __aeabi_memset
       208   -> sli_se_execute_and_wait
       208   -> sli_se_get_auth_buffer
       208   -> sli_se_get_key_input_output
       208   -> sli_se_key_to_keyspec
     104   sl_se_hmac
       104   -> SE_addDataInput
       104   -> SE_addDataOutput
       104   -> SE_addParameter
       104   -> sli_se_execute_and_wait
       104   -> sli_se_get_auth_buffer
       104   -> sli_se_get_key_input_output
       104   -> sli_se_key_to_keyspec
     104   sl_se_poly1305_genkey_tag
       104   -> SE_addDataInput
       104   -> SE_addDataOutput
       104   -> SE_addParameter
       104   -> sli_se_execute_and_wait
       104   -> sli_se_get_auth_buffer
       104   -> sli_se_get_key_input_output
       104   -> sli_se_key_to_keyspec


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_21
       4  ??DataTable22_22
       4  ??DataTable22_23
       4  ??DataTable22_24
       4  ??DataTable22_25
       4  ??DataTable22_26
       4  ??DataTable22_27
       4  ??DataTable22_28
       4  ??DataTable22_29
       4  ??DataTable22_3
       4  ??DataTable22_30
       4  ??DataTable22_31
       4  ??DataTable22_32
       4  ??DataTable22_33
       4  ??DataTable22_34
       4  ??DataTable22_35
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
      12  ?_0
      12  ?_1
      12  ?_10
      12  ?_100
      12  ?_101
      12  ?_102
      12  ?_103
      12  ?_104
      12  ?_11
      12  ?_12
      12  ?_13
      12  ?_14
      12  ?_15
      12  ?_16
      12  ?_17
      12  ?_18
      12  ?_19
      12  ?_2
      12  ?_20
      12  ?_21
      12  ?_22
      12  ?_23
      12  ?_24
      12  ?_25
      12  ?_26
      12  ?_27
      12  ?_28
      12  ?_29
      12  ?_3
      12  ?_30
      12  ?_31
      12  ?_32
      12  ?_33
      12  ?_34
      12  ?_35
      12  ?_36
      12  ?_37
      12  ?_38
      12  ?_39
      12  ?_4
      12  ?_40
      12  ?_41
      12  ?_42
      12  ?_43
      12  ?_44
      12  ?_45
      12  ?_46
      12  ?_47
      12  ?_48
      12  ?_49
      12  ?_5
      12  ?_50
      12  ?_51
      12  ?_52
      12  ?_53
      12  ?_54
      12  ?_55
      12  ?_56
      12  ?_57
      12  ?_58
      12  ?_59
      12  ?_6
      12  ?_60
      12  ?_61
      12  ?_62
      12  ?_63
      12  ?_64
      12  ?_65
      12  ?_66
      12  ?_67
      12  ?_68
      12  ?_69
      12  ?_7
      12  ?_70
      12  ?_71
      12  ?_72
      12  ?_73
      12  ?_74
      12  ?_75
      12  ?_76
      12  ?_77
      12  ?_78
      12  ?_79
      12  ?_8
      12  ?_80
      12  ?_81
      12  ?_82
      12  ?_83
      12  ?_84
      12  ?_85
      12  ?_86
      12  ?_87
      12  ?_88
      12  ?_89
      12  ?_9
      12  ?_90
      12  ?_91
      12  ?_92
      12  ?_93
      12  ?_94
      12  ?_95
      12  ?_96
      12  ?_97
      12  ?_98
      12  ?_99
      46  increment_nonce_counter
      40  memcmp_time_cst
     316  sl_se_aes_crypt_cbc
     544  sl_se_aes_crypt_cfb128
     176  sl_se_aes_crypt_cfb8
     506  sl_se_aes_crypt_ctr
     250  sl_se_aes_crypt_ecb
     522  sl_se_ccm_auth_decrypt
     488  sl_se_ccm_encrypt_and_tag
     494  sl_se_ccm_multipart_finish
     782  sl_se_ccm_multipart_starts
   1'080  sl_se_ccm_multipart_update
     316  sl_se_chacha20_crypt
     368  sl_se_chacha20_poly1305_auth_decrypt
     386  sl_se_chacha20_poly1305_encrypt_and_tag
     242  sl_se_cmac
     372  sl_se_cmac_multipart_finish
      68  sl_se_cmac_multipart_starts
     476  sl_se_cmac_multipart_update
     468  sl_se_gcm_auth_decrypt
     840  sl_se_gcm_crypt_and_tag
     828  sl_se_gcm_multipart_finish
     430  sl_se_gcm_multipart_starts
   1'142  sl_se_gcm_multipart_update
     314  sl_se_hmac
     274  sl_se_poly1305_genkey_tag

 
  1'260 bytes in section .rodata
 12'272 bytes in section .text
 
 12'272 bytes of CODE  memory
  1'260 bytes of CONST memory

Errors: none
Warnings: none
