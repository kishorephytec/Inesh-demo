###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:08
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_key_derivation.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_key_derivation.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_key_derivation.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_10044205007528117694.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_key_derivation.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_10044205007528117694.dir\sl_se_manager_key_derivation.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_key_derivation.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_key_derivation.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs Secure Engine Manager API.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sl_se_manager.h"
     32          
     33          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
     34          
     35          #include "sli_se_manager_internal.h"
     36          #include "em_se.h"
     37          #include <string.h>
     38          
     39          /***************************************************************************//**
     40           * \addtogroup sl_se Secure Engine Manager API
     41           * @{
     42           ******************************************************************************/
     43          
     44          // -----------------------------------------------------------------------------
     45          // Defines
     46          
     47          #define KEYSPEC_DH_RESERVED                 0x00000780U
     48          // Constant from RFC 4492.
     49          #define SL_SE_ECP_TLS_NAMED_CURVE   3   ///< ECCurveType's named_curve
     50          #define SL_SE_TLSID_ECC_P256        23  ///< Named curve value for SECP256R1
     51          
     52          // -----------------------------------------------------------------------------
     53          // Locals
     54          
     55          // ECJPAKE role

   \                                 In section .rodata, align 4
     56          static const char * const ecjpake_id[] = {
   \                     ecjpake_id:
   \        0x0   0x....'....        DC32 ?_0, ?_1
   \              0x....'....
     57            "client",
     58            "server"
     59          };
     60          
     61          // -----------------------------------------------------------------------------
     62          // Global Functions
     63          
     64          // -------------------------------
     65          // Elliptic-curve Diffie–Hellman
     66          
     67          /***************************************************************************//**
     68           * ECDH shared secret computation.
     69           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     70          sl_status_t sl_se_ecdh_compute_shared_secret(sl_se_command_context_t *cmd_ctx,
     71                                                       const sl_se_key_descriptor_t *key_in_priv,
     72                                                       const sl_se_key_descriptor_t *key_in_pub,
     73                                                       const sl_se_key_descriptor_t *key_out)
     74          {
   \                     sl_se_ecdh_compute_shared_secret: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
   \        0xC   0x4698             MOV      R8,R3
     75            sl_status_t status;
     76            uint32_t keyspec_out;
     77            uint32_t keyspec_in;
     78            uint32_t key_pubkey_size;
     79            SE_DataTransfer_t pubkey_input_buffer;
     80            SE_DataTransfer_t auth_buffer_out;
     81          
     82            if (cmd_ctx == NULL
     83                || key_in_priv == NULL || key_in_pub == NULL || key_out == NULL) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD006             BEQ.N    ??sl_se_ecdh_compute_shared_secret_0
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD004             BEQ.N    ??sl_se_ecdh_compute_shared_secret_0
   \       0x16   0x2F00             CMP      R7,#+0
   \       0x18   0xD002             BEQ.N    ??sl_se_ecdh_compute_shared_secret_0
   \       0x1A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x1E   0xD101             BNE.N    ??sl_se_ecdh_compute_shared_secret_1
     84              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecdh_compute_shared_secret_0: (+1)
   \       0x20   0x2021             MOVS     R0,#+33
   \       0x22   0xE0CA             B.N      ??sl_se_ecdh_compute_shared_secret_2
     85            }
     86          
     87            status = sli_key_check_equivalent(key_in_priv, key_in_pub, false, false);
   \                     ??sl_se_ecdh_compute_shared_secret_1: (+1)
   \       0x24   0x2300             MOVS     R3,#+0
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x0039             MOVS     R1,R7
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0x.... 0x....      BL       sli_key_check_equivalent
   \       0x30   0x4681             MOV      R9,R0
     88            if (status != SL_STATUS_OK) {
   \       0x32   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x36   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_3
     89              return status;
   \       0x38   0x4648             MOV      R0,R9
   \       0x3A   0xE0BE             B.N      ??sl_se_ecdh_compute_shared_secret_2
     90            }
     91            status = sli_key_get_size(key_in_pub, &key_pubkey_size);
   \                     ??sl_se_ecdh_compute_shared_secret_3: (+1)
   \       0x3C   0xA901             ADD      R1,SP,#+4
   \       0x3E   0x0038             MOVS     R0,R7
   \       0x40   0x.... 0x....      BL       sli_key_get_size
   \       0x44   0x0004             MOVS     R4,R0
     92            if (status != SL_STATUS_OK) {
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_4
     93              return status;
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0xE0B5             B.N      ??sl_se_ecdh_compute_shared_secret_2
     94            }
     95          
     96            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
     97            // The key out buffer size needs be large enough for non-volatile keys
     98            if (key_out->storage.method != SL_SE_KEY_STORAGE_INTERNAL_VOLATILE) {
   \                     ??sl_se_ecdh_compute_shared_secret_4: (+1)
   \       0x4E   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x52   0x2802             CMP      R0,#+2
   \       0x54   0xD018             BEQ.N    ??sl_se_ecdh_compute_shared_secret_5
     99              if (key_in_priv->type == SL_SE_KEY_TYPE_ECC_X25519
    100                  || key_in_priv->type == SL_SE_KEY_TYPE_ECC_X448) {
   \       0x56   0x6831             LDR      R1,[R6, #+0]
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x5C   0x4281             CMP      R1,R0
   \       0x5E   0xD004             BEQ.N    ??sl_se_ecdh_compute_shared_secret_6
   \       0x60   0x6831             LDR      R1,[R6, #+0]
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable5
   \       0x66   0x4281             CMP      R1,R0
   \       0x68   0xD106             BNE.N    ??sl_se_ecdh_compute_shared_secret_7
    101                if (key_pubkey_size > key_out->storage.location.buffer.size) {
   \                     ??sl_se_ecdh_compute_shared_secret_6: (+1)
   \       0x6A   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \       0x6E   0x9801             LDR      R0,[SP, #+4]
   \       0x70   0x4281             CMP      R1,R0
   \       0x72   0xD209             BCS.N    ??sl_se_ecdh_compute_shared_secret_5
    102                  return SL_STATUS_INVALID_PARAMETER;
   \       0x74   0x2021             MOVS     R0,#+33
   \       0x76   0xE0A0             B.N      ??sl_se_ecdh_compute_shared_secret_2
    103                }
    104              } else {
    105                if ((key_pubkey_size * 2) > key_out->storage.location.buffer.size) {
   \                     ??sl_se_ecdh_compute_shared_secret_7: (+1)
   \       0x78   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x7C   0x9901             LDR      R1,[SP, #+4]
   \       0x7E   0xEBB0 0x0F41      CMP      R0,R1, LSL #+1
   \       0x82   0xD201             BCS.N    ??sl_se_ecdh_compute_shared_secret_5
    106                  return SL_STATUS_INVALID_PARAMETER;
   \       0x84   0x2021             MOVS     R0,#+33
   \       0x86   0xE098             B.N      ??sl_se_ecdh_compute_shared_secret_2
    107                }
    108              }
    109            }
    110            #else
    111            if (key_in_priv->type == SL_SE_KEY_TYPE_ECC_X25519) {
    112              if (key_pubkey_size > key_out->storage.location.buffer.size) {
    113                return SL_STATUS_INVALID_PARAMETER;
    114              }
    115            } else {
    116              if ((key_pubkey_size * 2) > key_out->storage.location.buffer.size) {
    117                return SL_STATUS_INVALID_PARAMETER;
    118              }
    119            }
    120            #endif
    121          
    122            // Output of DH must be in RAW format
    123            if (key_out->type != SL_SE_KEY_TYPE_SYMMETRIC) {
   \                     ??sl_se_ecdh_compute_shared_secret_5: (+1)
   \       0x88   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_8
    124              return SL_STATUS_INVALID_PARAMETER;
   \       0x90   0x2021             MOVS     R0,#+33
   \       0x92   0xE092             B.N      ??sl_se_ecdh_compute_shared_secret_2
    125            }
    126          
    127            // Initialize command
    128            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DH);
   \                     ??sl_se_ecdh_compute_shared_secret_8: (+1)
   \       0x94   0xF05F 0x6060      MOVS     R0,#+234881024
   \       0x98   0x6028             STR      R0,[R5, #+0]
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x6068             STR      R0,[R5, #+4]
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x60A8             STR      R0,[R5, #+8]
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x61E8             STR      R0,[R5, #+28]
    129          
    130            // Add key parameters to command
    131            status = sli_se_key_to_keyspec(key_in_priv, &keyspec_in);
   \       0xA6   0x4669             MOV      R1,SP
   \       0xA8   0x0030             MOVS     R0,R6
   \       0xAA   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xAE   0x4681             MOV      R9,R0
    132            if (status != SL_STATUS_OK) {
   \       0xB0   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xB4   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_9
    133              return status;
   \       0xB6   0x4648             MOV      R0,R9
   \       0xB8   0xE07F             B.N      ??sl_se_ecdh_compute_shared_secret_2
    134            }
    135            keyspec_in = keyspec_in & ~KEYSPEC_DH_RESERVED;
   \                     ??sl_se_ecdh_compute_shared_secret_9: (+1)
   \       0xBA   0x9800             LDR      R0,[SP, #+0]
   \       0xBC   0xF430 0x60F0      BICS     R0,R0,#0x780
   \       0xC0   0x9000             STR      R0,[SP, #+0]
    136            SE_addParameter(&cmd_ctx->command, keyspec_in);
   \       0xC2   0x9900             LDR      R1,[SP, #+0]
   \       0xC4   0x0028             MOVS     R0,R5
   \       0xC6   0x.... 0x....      BL       SE_addParameter
    137          
    138            status = sli_se_key_to_keyspec(key_out, &keyspec_out);
   \       0xCA   0xA902             ADD      R1,SP,#+8
   \       0xCC   0x4640             MOV      R0,R8
   \       0xCE   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xD2   0x0004             MOVS     R4,R0
    139            if (status != SL_STATUS_OK) {
   \       0xD4   0x2C00             CMP      R4,#+0
   \       0xD6   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_10
    140              return status;
   \       0xD8   0x0020             MOVS     R0,R4
   \       0xDA   0xE06E             B.N      ??sl_se_ecdh_compute_shared_secret_2
    141            }
    142            SE_addParameter(&cmd_ctx->command, keyspec_out);
   \                     ??sl_se_ecdh_compute_shared_secret_10: (+1)
   \       0xDC   0x9902             LDR      R1,[SP, #+8]
   \       0xDE   0x0028             MOVS     R0,R5
   \       0xE0   0x.... 0x....      BL       SE_addParameter
    143          
    144            // Add key input metadata block to command
    145            sli_add_key_metadata(cmd_ctx, key_in_priv, status);
   \       0xE4   0xA90C             ADD      R1,SP,#+48
   \       0xE6   0x0030             MOVS     R0,R6
   \       0xE8   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xEC   0x4681             MOV      R9,R0
   \       0xEE   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xF2   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_11
   \       0xF4   0x4648             MOV      R0,R9
   \       0xF6   0xE060             B.N      ??sl_se_ecdh_compute_shared_secret_2
   \                     ??sl_se_ecdh_compute_shared_secret_11: (+1)
   \       0xF8   0xA90C             ADD      R1,SP,#+48
   \       0xFA   0x0028             MOVS     R0,R5
   \       0xFC   0x.... 0x....      BL       SE_addDataInput
    146            // Add key input block to command
    147            sli_add_key_input(cmd_ctx, key_in_priv, status);
   \      0x100   0xA909             ADD      R1,SP,#+36
   \      0x102   0x0030             MOVS     R0,R6
   \      0x104   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x108   0x0004             MOVS     R4,R0
   \      0x10A   0x2C00             CMP      R4,#+0
   \      0x10C   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_12
   \      0x10E   0x0020             MOVS     R0,R4
   \      0x110   0xE053             B.N      ??sl_se_ecdh_compute_shared_secret_2
   \                     ??sl_se_ecdh_compute_shared_secret_12: (+1)
   \      0x112   0xA909             ADD      R1,SP,#+36
   \      0x114   0x0028             MOVS     R0,R5
   \      0x116   0x.... 0x....      BL       SE_addDataInput
    148          
    149            if (key_out->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   \      0x11A   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD00C             BEQ.N    ??sl_se_ecdh_compute_shared_secret_13
    150              // Add key output metadata block to command
    151              status = sli_se_get_auth_buffer(key_out, &auth_buffer_out);
   \      0x122   0xA90F             ADD      R1,SP,#+60
   \      0x124   0x4640             MOV      R0,R8
   \      0x126   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x12A   0x0004             MOVS     R4,R0
    152              if (status != SL_STATUS_OK) {
   \      0x12C   0x2C00             CMP      R4,#+0
   \      0x12E   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_14
    153                return status;
   \      0x130   0x0020             MOVS     R0,R4
   \      0x132   0xE042             B.N      ??sl_se_ecdh_compute_shared_secret_2
    154              }
    155              SE_addDataInput(&cmd_ctx->command, &auth_buffer_out);
   \                     ??sl_se_ecdh_compute_shared_secret_14: (+1)
   \      0x134   0xA90F             ADD      R1,SP,#+60
   \      0x136   0x0028             MOVS     R0,R5
   \      0x138   0x.... 0x....      BL       SE_addDataInput
    156            }
    157            // Add key of other party
    158            status = sli_se_get_key_input_output(key_in_pub, &pubkey_input_buffer);
   \                     ??sl_se_ecdh_compute_shared_secret_13: (+1)
   \      0x13C   0xA903             ADD      R1,SP,#+12
   \      0x13E   0x0038             MOVS     R0,R7
   \      0x140   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x144   0x4681             MOV      R9,R0
    159            if (status != SL_STATUS_OK) {
   \      0x146   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x14A   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_15
    160              return status;
   \      0x14C   0x4648             MOV      R0,R9
   \      0x14E   0xE034             B.N      ??sl_se_ecdh_compute_shared_secret_2
    161            }
    162          
    163            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    164            if (key_in_pub->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) {
   \                     ??sl_se_ecdh_compute_shared_secret_15: (+1)
   \      0x150   0x68B8             LDR      R0,[R7, #+8]
   \      0x152   0x04C0             LSLS     R0,R0,#+19
   \      0x154   0xD511             BPL.N    ??sl_se_ecdh_compute_shared_secret_16
    165              if (key_in_pub->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY) {
   \      0x156   0x68B8             LDR      R0,[R7, #+8]
   \      0x158   0x0480             LSLS     R0,R0,#+18
   \      0x15A   0xD50C             BPL.N    ??sl_se_ecdh_compute_shared_secret_17
    166                // If using custom domain, the key buffer stores domain parameters,
    167                // however when computing the shared secret only the key is of interest.
    168                uint32_t domain_size = ((sl_se_custom_weierstrass_prime_domain_t*)key_in_pub->domain)->size;
   \      0x15C   0x69F8             LDR      R0,[R7, #+28]
   \      0x15E   0x6800             LDR      R0,[R0, #+0]
    169                pubkey_input_buffer.data = &key_in_pub->storage.location.buffer.pointer[domain_size * 6];
   \      0x160   0x693A             LDR      R2,[R7, #+16]
   \      0x162   0x2106             MOVS     R1,#+6
   \      0x164   0xFB01 0xF100      MUL      R1,R1,R0
   \      0x168   0x4411             ADD      R1,R2,R1
   \      0x16A   0x9103             STR      R1,[SP, #+12]
    170                pubkey_input_buffer.length = (domain_size * 2) | SE_DATATRANSFER_REALIGN;
   \      0x16C   0x0040             LSLS     R0,R0,#+1
   \      0x16E   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x172   0x9005             STR      R0,[SP, #+20]
   \      0x174   0xE001             B.N      ??sl_se_ecdh_compute_shared_secret_16
    171              } else {
    172                // Does not contain a public key.
    173                return SL_STATUS_INVALID_KEY;
   \                     ??sl_se_ecdh_compute_shared_secret_17: (+1)
   \      0x176   0x2029             MOVS     R0,#+41
   \      0x178   0xE01F             B.N      ??sl_se_ecdh_compute_shared_secret_2
    174              }
    175            }
    176            #endif
    177          
    178            SE_addDataInput(&cmd_ctx->command, &pubkey_input_buffer);
   \                     ??sl_se_ecdh_compute_shared_secret_16: (+1)
   \      0x17A   0xA903             ADD      R1,SP,#+12
   \      0x17C   0x0028             MOVS     R0,R5
   \      0x17E   0x.... 0x....      BL       SE_addDataInput
    179          
    180            // Add key output block to command
    181            sli_add_key_output(cmd_ctx, key_out, status);
   \      0x182   0xA906             ADD      R1,SP,#+24
   \      0x184   0x4640             MOV      R0,R8
   \      0x186   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x18A   0x0004             MOVS     R4,R0
   \      0x18C   0x2C00             CMP      R4,#+0
   \      0x18E   0xD001             BEQ.N    ??sl_se_ecdh_compute_shared_secret_18
   \      0x190   0x0020             MOVS     R0,R4
   \      0x192   0xE012             B.N      ??sl_se_ecdh_compute_shared_secret_2
   \                     ??sl_se_ecdh_compute_shared_secret_18: (+1)
   \      0x194   0xA906             ADD      R1,SP,#+24
   \      0x196   0x0028             MOVS     R0,R5
   \      0x198   0x.... 0x....      BL       SE_addDataOutput
    182          
    183            // Execute command.
    184            // The retries are necessary in order to reduce the risk of random failures
    185            // in the accelerated point multiplication. This mainly affects very small or
    186            // large scalars, which in this case would be the private key.
    187            for (size_t i = 0; i < SLI_SE_MAX_POINT_MULT_RETRIES; ++i) {
   \      0x19C   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??sl_se_ecdh_compute_shared_secret_19: (+1)
   \      0x1A0   0xF1B9 0x0F03      CMP      R9,#+3
   \      0x1A4   0xD208             BCS.N    ??sl_se_ecdh_compute_shared_secret_20
    188              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x1A6   0x0028             MOVS     R0,R5
   \      0x1A8   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x1AC   0x0004             MOVS     R4,R0
    189              if (status != SL_STATUS_FAIL) {
   \      0x1AE   0x2C01             CMP      R4,#+1
   \      0x1B0   0xD102             BNE.N    ??sl_se_ecdh_compute_shared_secret_20
    190                break;
    191              }
    192            }
   \                     ??sl_se_ecdh_compute_shared_secret_21: (+1)
   \      0x1B2   0xF119 0x0901      ADDS     R9,R9,#+1
   \      0x1B6   0xE7F3             B.N      ??sl_se_ecdh_compute_shared_secret_19
    193            return status;
   \                     ??sl_se_ecdh_compute_shared_secret_20: (+1)
   \      0x1B8   0x0020             MOVS     R0,R4
   \                     ??sl_se_ecdh_compute_shared_secret_2: (+1)
   \      0x1BA   0xB013             ADD      SP,SP,#+76
   \      0x1BC   0xE8BD 0x83F0      POP      {R4-R9,PC}
    194          }
    195          
    196          // -------------------------------
    197          // ECJPAKE
    198          
    199          /***************************************************************************//**
    200           * Parse a ECJPAKE TLS point.
    201           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    202          static sl_status_t ecjpake_parse_tls_point(const uint8_t **ibuf,
    203                                                     size_t *ilen,
    204                                                     size_t *rlen,
    205                                                     uint8_t **obuf, size_t *olen)
    206          {
   \                     ecjpake_parse_tls_point: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8030      LDR      R8,[SP, #+48]
    207            if (ilen == NULL || ibuf == NULL || obuf == NULL || olen == NULL) {
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD006             BEQ.N    ??ecjpake_parse_tls_point_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD004             BEQ.N    ??ecjpake_parse_tls_point_0
   \       0x18   0x2F00             CMP      R7,#+0
   \       0x1A   0xD002             BEQ.N    ??ecjpake_parse_tls_point_0
   \       0x1C   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x20   0xD101             BNE.N    ??ecjpake_parse_tls_point_1
    208              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_parse_tls_point_0: (+1)
   \       0x22   0x2021             MOVS     R0,#+33
   \       0x24   0xE064             B.N      ??ecjpake_parse_tls_point_2
    209            }
    210          
    211            if (*ilen == 0 || *ibuf == NULL || *obuf == NULL) {
   \                     ??ecjpake_parse_tls_point_1: (+1)
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD005             BEQ.N    ??ecjpake_parse_tls_point_3
   \       0x2C   0x6828             LDR      R0,[R5, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD002             BEQ.N    ??ecjpake_parse_tls_point_3
   \       0x32   0x6838             LDR      R0,[R7, #+0]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD101             BNE.N    ??ecjpake_parse_tls_point_4
    212              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_parse_tls_point_3: (+1)
   \       0x38   0x2021             MOVS     R0,#+33
   \       0x3A   0xE059             B.N      ??ecjpake_parse_tls_point_2
    213            }
    214          
    215            // Consume first byte, length of what follows.
    216            size_t field_length = **ibuf;
   \                     ??ecjpake_parse_tls_point_4: (+1)
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x7800             LDRB     R0,[R0, #+0]
   \       0x40   0x9001             STR      R0,[SP, #+4]
    217            *ibuf += 1;
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0x1C40             ADDS     R0,R0,#+1
   \       0x46   0x6028             STR      R0,[R5, #+0]
    218            *ilen -= 1;
   \       0x48   0x6830             LDR      R0,[R6, #+0]
   \       0x4A   0x1E40             SUBS     R0,R0,#+1
   \       0x4C   0x6030             STR      R0,[R6, #+0]
    219            if (rlen != NULL) {
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xD002             BEQ.N    ??ecjpake_parse_tls_point_5
    220              *rlen += 1;
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x1C40             ADDS     R0,R0,#+1
   \       0x56   0x6020             STR      R0,[R4, #+0]
    221            }
    222          
    223            if (field_length > *ilen) {
   \                     ??ecjpake_parse_tls_point_5: (+1)
   \       0x58   0x6831             LDR      R1,[R6, #+0]
   \       0x5A   0x9801             LDR      R0,[SP, #+4]
   \       0x5C   0x4281             CMP      R1,R0
   \       0x5E   0xD201             BCS.N    ??ecjpake_parse_tls_point_6
    224              return SL_STATUS_INVALID_PARAMETER;
   \       0x60   0x2021             MOVS     R0,#+33
   \       0x62   0xE045             B.N      ??ecjpake_parse_tls_point_2
    225            }
    226          
    227            // Consume second byte, point type.
    228            uint8_t point_type = **ibuf;
   \                     ??ecjpake_parse_tls_point_6: (+1)
   \       0x64   0x6828             LDR      R0,[R5, #+0]
   \       0x66   0x7800             LDRB     R0,[R0, #+0]
   \       0x68   0xF88D 0x0000      STRB     R0,[SP, #+0]
    229            size_t point_length = field_length - 1;
   \       0x6C   0xF8DD 0x9004      LDR      R9,[SP, #+4]
   \       0x70   0xF1B9 0x0901      SUBS     R9,R9,#+1
    230            *ibuf += 1;
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x1C40             ADDS     R0,R0,#+1
   \       0x78   0x6028             STR      R0,[R5, #+0]
    231            *ilen -= 1;
   \       0x7A   0x6830             LDR      R0,[R6, #+0]
   \       0x7C   0x1E40             SUBS     R0,R0,#+1
   \       0x7E   0x6030             STR      R0,[R6, #+0]
    232          
    233            switch (point_type) {
   \       0x80   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD004             BEQ.N    ??ecjpake_parse_tls_point_7
   \       0x88   0x2804             CMP      R0,#+4
   \       0x8A   0xD004             BEQ.N    ??ecjpake_parse_tls_point_8
   \       0x8C   0x2805             CMP      R0,#+5
   \       0x8E   0xD007             BEQ.N    ??ecjpake_parse_tls_point_9
   \       0x90   0xE008             B.N      ??ecjpake_parse_tls_point_10
    234              case 0x0:
    235                // Why would we ever get a zero-point?
    236                return SL_STATUS_INVALID_KEY;
   \                     ??ecjpake_parse_tls_point_7: (+1)
   \       0x92   0x2029             MOVS     R0,#+41
   \       0x94   0xE02C             B.N      ??ecjpake_parse_tls_point_2
    237              case 0x04:
    238                break;
    239              case 0x05:
    240                // We don't support compressed points...
    241                return SL_STATUS_NOT_SUPPORTED;
    242              default:
    243                return SL_STATUS_INVALID_PARAMETER;
    244            }
    245          
    246            // Copy out binary point.
    247            if (point_length > *olen) {
   \                     ??ecjpake_parse_tls_point_8: (+1)
   \       0x96   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x9A   0x4548             CMP      R0,R9
   \       0x9C   0xD206             BCS.N    ??ecjpake_parse_tls_point_11
   \       0x9E   0xE003             B.N      ??ecjpake_parse_tls_point_12
   \                     ??ecjpake_parse_tls_point_9: (+1)
   \       0xA0   0x200F             MOVS     R0,#+15
   \       0xA2   0xE025             B.N      ??ecjpake_parse_tls_point_2
   \                     ??ecjpake_parse_tls_point_10: (+1)
   \       0xA4   0x2021             MOVS     R0,#+33
   \       0xA6   0xE023             B.N      ??ecjpake_parse_tls_point_2
    248              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_parse_tls_point_12: (+1)
   \       0xA8   0x2021             MOVS     R0,#+33
   \       0xAA   0xE021             B.N      ??ecjpake_parse_tls_point_2
    249            }
    250          
    251            memcpy(*obuf, *ibuf, point_length);
   \                     ??ecjpake_parse_tls_point_11: (+1)
   \       0xAC   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0xB0   0xF8D5 0xB000      LDR      R11,[R5, #+0]
   \       0xB4   0xF8D7 0xA000      LDR      R10,[R7, #+0]
   \       0xB8   0x9A02             LDR      R2,[SP, #+8]
   \       0xBA   0x4659             MOV      R1,R11
   \       0xBC   0x4650             MOV      R0,R10
   \       0xBE   0x.... 0x....      BL       __aeabi_memcpy
    252            *ibuf += point_length;
   \       0xC2   0x6828             LDR      R0,[R5, #+0]
   \       0xC4   0x4448             ADD      R0,R0,R9
   \       0xC6   0x6028             STR      R0,[R5, #+0]
    253            *ilen -= point_length;
   \       0xC8   0x6830             LDR      R0,[R6, #+0]
   \       0xCA   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0xCE   0x6030             STR      R0,[R6, #+0]
    254            *obuf += point_length;
   \       0xD0   0x6838             LDR      R0,[R7, #+0]
   \       0xD2   0x4448             ADD      R0,R0,R9
   \       0xD4   0x6038             STR      R0,[R7, #+0]
    255            *olen -= point_length;
   \       0xD6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xDA   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0xDE   0xF8C8 0x0000      STR      R0,[R8, #+0]
    256            if (rlen != NULL) {
   \       0xE2   0x2C00             CMP      R4,#+0
   \       0xE4   0xD003             BEQ.N    ??ecjpake_parse_tls_point_13
    257              *rlen += field_length;
   \       0xE6   0x6821             LDR      R1,[R4, #+0]
   \       0xE8   0x9801             LDR      R0,[SP, #+4]
   \       0xEA   0x1841             ADDS     R1,R0,R1
   \       0xEC   0x6021             STR      R1,[R4, #+0]
    258            }
    259          
    260            return SL_STATUS_OK;
   \                     ??ecjpake_parse_tls_point_13: (+1)
   \       0xEE   0x2000             MOVS     R0,#+0
   \                     ??ecjpake_parse_tls_point_2: (+1)
   \       0xF0   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    261          }
    262          
    263          /***************************************************************************//**
    264           * Parse a ECJPAKE TLS zkp.
    265           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    266          static sl_status_t ecjpake_parse_tls_zkp(const uint8_t **ibuf,
    267                                                   size_t *ilen,
    268                                                   size_t *rlen,
    269                                                   uint8_t **obuf,
    270                                                   size_t *olen)
    271          {
   \                     ecjpake_parse_tls_zkp: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0x001F             MOVS     R7,R3
   \        0xE   0xF8DD 0x8038      LDR      R8,[SP, #+56]
    272            if (ilen == NULL || ibuf == NULL || obuf == NULL || olen == NULL) {
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD006             BEQ.N    ??ecjpake_parse_tls_zkp_0
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD004             BEQ.N    ??ecjpake_parse_tls_zkp_0
   \       0x1A   0x2F00             CMP      R7,#+0
   \       0x1C   0xD002             BEQ.N    ??ecjpake_parse_tls_zkp_0
   \       0x1E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x22   0xD101             BNE.N    ??ecjpake_parse_tls_zkp_1
    273              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_parse_tls_zkp_0: (+1)
   \       0x24   0x2021             MOVS     R0,#+33
   \       0x26   0xE077             B.N      ??ecjpake_parse_tls_zkp_2
    274            }
    275          
    276            if (*ilen == 0 || *ibuf == NULL || *obuf == NULL || *olen < 96) {
   \                     ??ecjpake_parse_tls_zkp_1: (+1)
   \       0x28   0x6830             LDR      R0,[R6, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD009             BEQ.N    ??ecjpake_parse_tls_zkp_3
   \       0x2E   0x6828             LDR      R0,[R5, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD006             BEQ.N    ??ecjpake_parse_tls_zkp_3
   \       0x34   0x6838             LDR      R0,[R7, #+0]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD003             BEQ.N    ??ecjpake_parse_tls_zkp_3
   \       0x3A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x3E   0x2860             CMP      R0,#+96
   \       0x40   0xD201             BCS.N    ??ecjpake_parse_tls_zkp_4
    277              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_parse_tls_zkp_3: (+1)
   \       0x42   0x2021             MOVS     R0,#+33
   \       0x44   0xE068             B.N      ??ecjpake_parse_tls_zkp_2
    278            }
    279          
    280            int ret = ecjpake_parse_tls_point(ibuf, ilen, rlen, obuf, olen);
   \                     ??ecjpake_parse_tls_zkp_4: (+1)
   \       0x46   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x4A   0x003B             MOVS     R3,R7
   \       0x4C   0x0022             MOVS     R2,R4
   \       0x4E   0x0031             MOVS     R1,R6
   \       0x50   0x0028             MOVS     R0,R5
   \       0x52   0x.... 0x....      BL       ecjpake_parse_tls_point
   \       0x56   0x4681             MOV      R9,R0
    281            if (ret != SL_STATUS_OK) {
   \       0x58   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x5C   0xD001             BEQ.N    ??ecjpake_parse_tls_zkp_5
    282              return ret;
   \       0x5E   0x4648             MOV      R0,R9
   \       0x60   0xE05A             B.N      ??ecjpake_parse_tls_zkp_2
    283            }
    284          
    285            if (*ilen < 1) {
   \                     ??ecjpake_parse_tls_zkp_5: (+1)
   \       0x62   0x6830             LDR      R0,[R6, #+0]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD101             BNE.N    ??ecjpake_parse_tls_zkp_6
    286              return SL_STATUS_INVALID_PARAMETER;
   \       0x68   0x2021             MOVS     R0,#+33
   \       0x6A   0xE055             B.N      ??ecjpake_parse_tls_zkp_2
    287            }
    288          
    289            // Consume first byte, length of what follows.
    290            size_t field_length = **ibuf;
   \                     ??ecjpake_parse_tls_zkp_6: (+1)
   \       0x6C   0x6828             LDR      R0,[R5, #+0]
   \       0x6E   0xF890 0xA000      LDRB     R10,[R0, #+0]
    291            *ibuf += 1;
   \       0x72   0x6828             LDR      R0,[R5, #+0]
   \       0x74   0x1C40             ADDS     R0,R0,#+1
   \       0x76   0x6028             STR      R0,[R5, #+0]
    292            *ilen -= 1;
   \       0x78   0x6830             LDR      R0,[R6, #+0]
   \       0x7A   0x1E40             SUBS     R0,R0,#+1
   \       0x7C   0x6030             STR      R0,[R6, #+0]
    293            if (rlen != NULL) {
   \       0x7E   0x2C00             CMP      R4,#+0
   \       0x80   0xD002             BEQ.N    ??ecjpake_parse_tls_zkp_7
    294              *rlen += 1;
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x1C40             ADDS     R0,R0,#+1
   \       0x86   0x6020             STR      R0,[R4, #+0]
    295            }
    296          
    297            if (field_length > *ilen || field_length > *olen) {
   \                     ??ecjpake_parse_tls_zkp_7: (+1)
   \       0x88   0x6830             LDR      R0,[R6, #+0]
   \       0x8A   0x4550             CMP      R0,R10
   \       0x8C   0xD303             BCC.N    ??ecjpake_parse_tls_zkp_8
   \       0x8E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x92   0x4550             CMP      R0,R10
   \       0x94   0xD201             BCS.N    ??ecjpake_parse_tls_zkp_9
    298              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_parse_tls_zkp_8: (+1)
   \       0x96   0x2021             MOVS     R0,#+33
   \       0x98   0xE03E             B.N      ??ecjpake_parse_tls_zkp_2
    299            }
    300          
    301            if (field_length == 0) {
   \                     ??ecjpake_parse_tls_zkp_9: (+1)
   \       0x9A   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x9E   0xD101             BNE.N    ??ecjpake_parse_tls_zkp_10
    302              // Scalar cannot be zero.
    303              return SL_STATUS_INVALID_KEY;
   \       0xA0   0x2029             MOVS     R0,#+41
   \       0xA2   0xE039             B.N      ??ecjpake_parse_tls_zkp_2
    304            }
    305          
    306            // Right-adjust.
    307            size_t adjust_length = 32 - field_length;
   \                     ??ecjpake_parse_tls_zkp_10: (+1)
   \       0xA4   0xF1DA 0x0020      RSBS     R0,R10,#+32
   \       0xA8   0x9000             STR      R0,[SP, #+0]
    308            memset(*obuf, 0, adjust_length);
   \       0xAA   0x9800             LDR      R0,[SP, #+0]
   \       0xAC   0x9004             STR      R0,[SP, #+16]
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0x9003             STR      R0,[SP, #+12]
   \       0xB2   0xF8D7 0xB000      LDR      R11,[R7, #+0]
   \       0xB6   0x9A03             LDR      R2,[SP, #+12]
   \       0xB8   0x9904             LDR      R1,[SP, #+16]
   \       0xBA   0x4658             MOV      R0,R11
   \       0xBC   0x.... 0x....      BL       __aeabi_memset
    309            *obuf += adjust_length;
   \       0xC0   0x6838             LDR      R0,[R7, #+0]
   \       0xC2   0x9900             LDR      R1,[SP, #+0]
   \       0xC4   0x4408             ADD      R0,R0,R1
   \       0xC6   0x6038             STR      R0,[R7, #+0]
    310            *olen -= adjust_length;
   \       0xC8   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xCC   0x9800             LDR      R0,[SP, #+0]
   \       0xCE   0x1A09             SUBS     R1,R1,R0
   \       0xD0   0xF8C8 0x1000      STR      R1,[R8, #+0]
    311          
    312            // Consume field.
    313            memcpy(*obuf, *ibuf, field_length);
   \       0xD4   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \       0xD8   0x6828             LDR      R0,[R5, #+0]
   \       0xDA   0x9001             STR      R0,[SP, #+4]
   \       0xDC   0xF8D7 0xB000      LDR      R11,[R7, #+0]
   \       0xE0   0x9A02             LDR      R2,[SP, #+8]
   \       0xE2   0x9901             LDR      R1,[SP, #+4]
   \       0xE4   0x4658             MOV      R0,R11
   \       0xE6   0x.... 0x....      BL       __aeabi_memcpy
    314            *obuf += field_length;
   \       0xEA   0x6838             LDR      R0,[R7, #+0]
   \       0xEC   0x4450             ADD      R0,R0,R10
   \       0xEE   0x6038             STR      R0,[R7, #+0]
    315            *olen -= field_length;
   \       0xF0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xF4   0xEBB0 0x000A      SUBS     R0,R0,R10
   \       0xF8   0xF8C8 0x0000      STR      R0,[R8, #+0]
    316            *ibuf += field_length;
   \       0xFC   0x6828             LDR      R0,[R5, #+0]
   \       0xFE   0x4450             ADD      R0,R0,R10
   \      0x100   0x6028             STR      R0,[R5, #+0]
    317            *ilen -= field_length;
   \      0x102   0x6830             LDR      R0,[R6, #+0]
   \      0x104   0xEBB0 0x000A      SUBS     R0,R0,R10
   \      0x108   0x6030             STR      R0,[R6, #+0]
    318          
    319            if (rlen != NULL) {
   \      0x10A   0x2C00             CMP      R4,#+0
   \      0x10C   0xD003             BEQ.N    ??ecjpake_parse_tls_zkp_11
    320              *rlen += field_length;
   \      0x10E   0x6820             LDR      R0,[R4, #+0]
   \      0x110   0xEB1A 0x0000      ADDS     R0,R10,R0
   \      0x114   0x6020             STR      R0,[R4, #+0]
    321            }
    322          
    323            return SL_STATUS_OK;
   \                     ??ecjpake_parse_tls_zkp_11: (+1)
   \      0x116   0x2000             MOVS     R0,#+0
   \                     ??ecjpake_parse_tls_zkp_2: (+1)
   \      0x118   0xB005             ADD      SP,SP,#+20
   \      0x11A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    324          }
    325          
    326          /***************************************************************************//**
    327           * Write a ECJPAKE TLS point.
    328           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    329          static sl_status_t ecjpake_write_tls_point(uint8_t **obuf,
    330                                                     size_t *olen,
    331                                                     size_t *wlen,
    332                                                     const uint8_t **ibuf,
    333                                                     size_t *ilen,
    334                                                     size_t point_length)
    335          {
   \                     ecjpake_write_tls_point: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \       0x10   0xF8DD 0x902C      LDR      R9,[SP, #+44]
    336            if (ibuf == NULL || obuf == NULL || olen == NULL || ilen == NULL) {
   \       0x14   0x2F00             CMP      R7,#+0
   \       0x16   0xD006             BEQ.N    ??ecjpake_write_tls_point_0
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD004             BEQ.N    ??ecjpake_write_tls_point_0
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD002             BEQ.N    ??ecjpake_write_tls_point_0
   \       0x20   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x24   0xD101             BNE.N    ??ecjpake_write_tls_point_1
    337              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_write_tls_point_0: (+1)
   \       0x26   0x2021             MOVS     R0,#+33
   \       0x28   0xE04A             B.N      ??ecjpake_write_tls_point_2
    338            }
    339          
    340            if (*obuf == NULL || *ibuf == NULL) {
   \                     ??ecjpake_write_tls_point_1: (+1)
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD002             BEQ.N    ??ecjpake_write_tls_point_3
   \       0x30   0x6838             LDR      R0,[R7, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD101             BNE.N    ??ecjpake_write_tls_point_4
    341              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_write_tls_point_3: (+1)
   \       0x36   0x2021             MOVS     R0,#+33
   \       0x38   0xE042             B.N      ??ecjpake_write_tls_point_2
    342            }
    343          
    344            // We can only output uncompressed points here.
    345            if (*olen < point_length + 2) {
   \                     ??ecjpake_write_tls_point_4: (+1)
   \       0x3A   0x6829             LDR      R1,[R5, #+0]
   \       0x3C   0xF119 0x0002      ADDS     R0,R9,#+2
   \       0x40   0x4281             CMP      R1,R0
   \       0x42   0xD201             BCS.N    ??ecjpake_write_tls_point_5
    346              return SL_STATUS_WOULD_OVERFLOW;
   \       0x44   0x201D             MOVS     R0,#+29
   \       0x46   0xE03B             B.N      ??ecjpake_write_tls_point_2
    347            }
    348          
    349            if (*ilen < point_length) {
   \                     ??ecjpake_write_tls_point_5: (+1)
   \       0x48   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x4C   0x4548             CMP      R0,R9
   \       0x4E   0xD201             BCS.N    ??ecjpake_write_tls_point_6
    350              return SL_STATUS_INVALID_PARAMETER;
   \       0x50   0x2021             MOVS     R0,#+33
   \       0x52   0xE035             B.N      ??ecjpake_write_tls_point_2
    351            }
    352          
    353            **obuf = point_length + 1;
   \                     ??ecjpake_write_tls_point_6: (+1)
   \       0x54   0xF119 0x0101      ADDS     R1,R9,#+1
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x7001             STRB     R1,[R0, #+0]
    354            *obuf += 1;
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x1C40             ADDS     R0,R0,#+1
   \       0x60   0x6020             STR      R0,[R4, #+0]
    355            *olen -= 1;
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x1E40             SUBS     R0,R0,#+1
   \       0x66   0x6028             STR      R0,[R5, #+0]
    356          
    357            **obuf = 0x04;
   \       0x68   0x2104             MOVS     R1,#+4
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x7001             STRB     R1,[R0, #+0]
    358            *obuf += 1;
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x1C40             ADDS     R0,R0,#+1
   \       0x72   0x6020             STR      R0,[R4, #+0]
    359            *olen -= 1;
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x1E40             SUBS     R0,R0,#+1
   \       0x78   0x6028             STR      R0,[R5, #+0]
    360          
    361            memcpy(*obuf, *ibuf, point_length);
   \       0x7A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x7E   0xF8D7 0xB000      LDR      R11,[R7, #+0]
   \       0x82   0xF8D4 0xA000      LDR      R10,[R4, #+0]
   \       0x86   0x9A00             LDR      R2,[SP, #+0]
   \       0x88   0x4659             MOV      R1,R11
   \       0x8A   0x4650             MOV      R0,R10
   \       0x8C   0x.... 0x....      BL       __aeabi_memcpy
    362          
    363            *obuf += point_length;
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x4448             ADD      R0,R0,R9
   \       0x94   0x6020             STR      R0,[R4, #+0]
    364            *olen -= point_length;
   \       0x96   0x6828             LDR      R0,[R5, #+0]
   \       0x98   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0x9C   0x6028             STR      R0,[R5, #+0]
    365            *ibuf += point_length;
   \       0x9E   0x6838             LDR      R0,[R7, #+0]
   \       0xA0   0x4448             ADD      R0,R0,R9
   \       0xA2   0x6038             STR      R0,[R7, #+0]
    366            *ilen -= point_length;
   \       0xA4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xA8   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0xAC   0xF8C8 0x0000      STR      R0,[R8, #+0]
    367          
    368            if (wlen != NULL) {
   \       0xB0   0x2E00             CMP      R6,#+0
   \       0xB2   0xD004             BEQ.N    ??ecjpake_write_tls_point_7
    369              *wlen += point_length + 2;
   \       0xB4   0x6830             LDR      R0,[R6, #+0]
   \       0xB6   0xEB19 0x0000      ADDS     R0,R9,R0
   \       0xBA   0x1C80             ADDS     R0,R0,#+2
   \       0xBC   0x6030             STR      R0,[R6, #+0]
    370            }
    371          
    372            return SL_STATUS_OK;
   \                     ??ecjpake_write_tls_point_7: (+1)
   \       0xBE   0x2000             MOVS     R0,#+0
   \                     ??ecjpake_write_tls_point_2: (+1)
   \       0xC0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    373          }
    374          
    375          /***************************************************************************//**
    376           * Write a ECJPAKE TLS zkp.
    377           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    378          static sl_status_t ecjpake_write_tls_zkp(uint8_t **obuf,
    379                                                   size_t *olen,
    380                                                   size_t *wlen,
    381                                                   const uint8_t **ibuf,
    382                                                   size_t *ilen,
    383                                                   size_t point_length)
    384          {
   \                     ecjpake_write_tls_zkp: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8030      LDR      R8,[SP, #+48]
    385            sl_status_t ret = SL_STATUS_OK;
   \       0x10   0xF05F 0x0A00      MOVS     R10,#+0
    386          
    387            if (ibuf == NULL || obuf == NULL || olen == NULL || ilen == NULL) {
   \       0x14   0x2F00             CMP      R7,#+0
   \       0x16   0xD006             BEQ.N    ??ecjpake_write_tls_zkp_0
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD004             BEQ.N    ??ecjpake_write_tls_zkp_0
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD002             BEQ.N    ??ecjpake_write_tls_zkp_0
   \       0x20   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x24   0xD101             BNE.N    ??ecjpake_write_tls_zkp_1
    388              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_write_tls_zkp_0: (+1)
   \       0x26   0x2021             MOVS     R0,#+33
   \       0x28   0xE050             B.N      ??ecjpake_write_tls_zkp_2
    389            }
    390          
    391            if (*obuf == NULL || *ibuf == NULL) {
   \                     ??ecjpake_write_tls_zkp_1: (+1)
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD002             BEQ.N    ??ecjpake_write_tls_zkp_3
   \       0x30   0x6838             LDR      R0,[R7, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD101             BNE.N    ??ecjpake_write_tls_zkp_4
    392              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_write_tls_zkp_3: (+1)
   \       0x36   0x2021             MOVS     R0,#+33
   \       0x38   0xE048             B.N      ??ecjpake_write_tls_zkp_2
    393            }
    394          
    395            ret = ecjpake_write_tls_point(obuf, olen, wlen, ibuf, ilen, point_length);
   \                     ??ecjpake_write_tls_zkp_4: (+1)
   \       0x3A   0x980D             LDR      R0,[SP, #+52]
   \       0x3C   0x9001             STR      R0,[SP, #+4]
   \       0x3E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x42   0x003B             MOVS     R3,R7
   \       0x44   0x0032             MOVS     R2,R6
   \       0x46   0x0029             MOVS     R1,R5
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       ecjpake_write_tls_point
   \       0x4E   0x4681             MOV      R9,R0
    396          
    397            if (ret != SL_STATUS_OK) {
   \       0x50   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x54   0xD001             BEQ.N    ??ecjpake_write_tls_zkp_5
    398              return ret;
   \       0x56   0x4648             MOV      R0,R9
   \       0x58   0xE038             B.N      ??ecjpake_write_tls_zkp_2
    399            }
    400          
    401            size_t zkp_length = 32;
   \                     ??ecjpake_write_tls_zkp_5: (+1)
   \       0x5A   0xF05F 0x0A20      MOVS     R10,#+32
    402          
    403            if (*olen < zkp_length + 1 || *ilen < zkp_length) {
   \       0x5E   0x6829             LDR      R1,[R5, #+0]
   \       0x60   0xF11A 0x0001      ADDS     R0,R10,#+1
   \       0x64   0x4281             CMP      R1,R0
   \       0x66   0xD303             BCC.N    ??ecjpake_write_tls_zkp_6
   \       0x68   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x6C   0x4550             CMP      R0,R10
   \       0x6E   0xD201             BCS.N    ??ecjpake_write_tls_zkp_7
    404              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_write_tls_zkp_6: (+1)
   \       0x70   0x2021             MOVS     R0,#+33
   \       0x72   0xE02B             B.N      ??ecjpake_write_tls_zkp_2
    405            }
    406          
    407            **obuf = zkp_length;
   \                     ??ecjpake_write_tls_zkp_7: (+1)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0xF880 0xA000      STRB     R10,[R0, #+0]
    408            *obuf += 1;
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x1C40             ADDS     R0,R0,#+1
   \       0x7E   0x6020             STR      R0,[R4, #+0]
    409            *olen -= 1;
   \       0x80   0x6828             LDR      R0,[R5, #+0]
   \       0x82   0x1E40             SUBS     R0,R0,#+1
   \       0x84   0x6028             STR      R0,[R5, #+0]
    410          
    411            memcpy(*obuf, *ibuf, zkp_length);
   \       0x86   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0x8A   0x6838             LDR      R0,[R7, #+0]
   \       0x8C   0x9000             STR      R0,[SP, #+0]
   \       0x8E   0xF8D4 0xB000      LDR      R11,[R4, #+0]
   \       0x92   0x9A01             LDR      R2,[SP, #+4]
   \       0x94   0x9900             LDR      R1,[SP, #+0]
   \       0x96   0x4658             MOV      R0,R11
   \       0x98   0x.... 0x....      BL       __aeabi_memcpy
    412          
    413            *obuf += zkp_length;
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x4450             ADD      R0,R0,R10
   \       0xA0   0x6020             STR      R0,[R4, #+0]
    414            *olen -= zkp_length;
   \       0xA2   0x6828             LDR      R0,[R5, #+0]
   \       0xA4   0xEBB0 0x000A      SUBS     R0,R0,R10
   \       0xA8   0x6028             STR      R0,[R5, #+0]
    415            *ibuf += zkp_length;
   \       0xAA   0x6838             LDR      R0,[R7, #+0]
   \       0xAC   0x4450             ADD      R0,R0,R10
   \       0xAE   0x6038             STR      R0,[R7, #+0]
    416            *ilen -= zkp_length;
   \       0xB0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xB4   0xEBB0 0x000A      SUBS     R0,R0,R10
   \       0xB8   0xF8C8 0x0000      STR      R0,[R8, #+0]
    417          
    418            if (wlen != NULL) {
   \       0xBC   0x2E00             CMP      R6,#+0
   \       0xBE   0xD004             BEQ.N    ??ecjpake_write_tls_zkp_8
    419              *wlen += zkp_length + 1;
   \       0xC0   0x6830             LDR      R0,[R6, #+0]
   \       0xC2   0xEB1A 0x0000      ADDS     R0,R10,R0
   \       0xC6   0x1C40             ADDS     R0,R0,#+1
   \       0xC8   0x6030             STR      R0,[R6, #+0]
    420            }
    421          
    422            return SL_STATUS_OK;
   \                     ??ecjpake_write_tls_zkp_8: (+1)
   \       0xCA   0x2000             MOVS     R0,#+0
   \                     ??ecjpake_write_tls_zkp_2: (+1)
   \       0xCC   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    423          }
    424          
    425          /***************************************************************************//**
    426           * Check if an ECJPAKE context is ready for use.
    427           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    428          sl_status_t sl_se_ecjpake_check(const sl_se_ecjpake_context_t *ctx)
    429          {
   \                     sl_se_ecjpake_check: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    430            if (ctx == NULL) {
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD101             BNE.N    ??sl_se_ecjpake_check_0
    431              return SL_STATUS_INVALID_PARAMETER;
   \        0x6   0x2021             MOVS     R0,#+33
   \        0x8   0xE005             B.N      ??sl_se_ecjpake_check_1
    432            }
    433          
    434            if (ctx->curve_flags == 0) {
   \                     ??sl_se_ecjpake_check_0: (+1)
   \        0xA   0x6848             LDR      R0,[R1, #+4]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??sl_se_ecjpake_check_2
    435              return SL_STATUS_INVALID_PARAMETER;
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE000             B.N      ??sl_se_ecjpake_check_1
    436            }
    437          
    438            return SL_STATUS_OK;
   \                     ??sl_se_ecjpake_check_2: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \                     ??sl_se_ecjpake_check_1: (+1)
   \       0x16   0x4770             BX       LR
    439          }
    440          
    441          /***************************************************************************//**
    442           * Derive the shared secret.
    443           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    444          sl_status_t sl_se_ecjpake_derive_secret(sl_se_ecjpake_context_t *ctx,
    445                                                  unsigned char *buf,
    446                                                  size_t len,
    447                                                  size_t *olen)
    448          {
   \                     sl_se_ecjpake_derive_secret: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x4692             MOV      R10,R2
   \        0xC   0x001E             MOVS     R6,R3
    449            sl_se_command_context_t *cmd_ctx;
    450            SE_Command_t *se_cmd;
    451          
    452            if (ctx == NULL || buf == NULL || olen == NULL) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD003             BEQ.N    ??sl_se_ecjpake_derive_secret_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD001             BEQ.N    ??sl_se_ecjpake_derive_secret_0
   \       0x16   0x2E00             CMP      R6,#+0
   \       0x18   0xD101             BNE.N    ??sl_se_ecjpake_derive_secret_1
    453              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_derive_secret_0: (+1)
   \       0x1A   0x2021             MOVS     R0,#+33
   \       0x1C   0xE07E             B.N      ??sl_se_ecjpake_derive_secret_2
    454            }
    455          
    456            if (len < 32) {
   \                     ??sl_se_ecjpake_derive_secret_1: (+1)
   \       0x1E   0xF1BA 0x0F20      CMP      R10,#+32
   \       0x22   0xD201             BCS.N    ??sl_se_ecjpake_derive_secret_3
    457              return SL_STATUS_WOULD_OVERFLOW;
   \       0x24   0x201D             MOVS     R0,#+29
   \       0x26   0xE079             B.N      ??sl_se_ecjpake_derive_secret_2
    458            }
    459          
    460            cmd_ctx = ctx->cmd_ctx;
   \                     ??sl_se_ecjpake_derive_secret_3: (+1)
   \       0x28   0x6827             LDR      R7,[R4, #+0]
    461            se_cmd = &ctx->cmd_ctx->command;
   \       0x2A   0xF8D4 0x8000      LDR      R8,[R4, #+0]
    462          
    463            // Generated session key needs to come out unprotected.
    464            uint32_t gen_key_flags = 32;
   \       0x2E   0xF05F 0x0920      MOVS     R9,#+32
    465          
    466            // SE command structures.
    467            sli_se_command_init(cmd_ctx,
    468                                SLI_SE_COMMAND_JPAKE_GEN_SESSIONKEY
    469                                | SLI_SE_COMMAND_OPTION_HASH_SHA256);
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x36   0x6038             STR      R0,[R7, #+0]
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x6078             STR      R0,[R7, #+4]
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x60B8             STR      R0,[R7, #+8]
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x61F8             STR      R0,[R7, #+28]
    470            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \       0x44   0xAB0F             ADD      R3,SP,#+60
   \       0x46   0x.... 0x....      LDR.W    R12,??DataTable7_1
   \       0x4A   0xE89C 0x0007      LDM      R12,{R0-R2}
   \       0x4E   0xE883 0x0007      STM      R3,{R0-R2}
    471            SE_DataTransfer_t pwd_in = SE_DATATRANSFER_DEFAULT(ctx->pwd, ctx->pwd_len);
   \       0x52   0x466B             MOV      R3,SP
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \       0x58   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0x5C   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0x60   0xF114 0x0009      ADDS     R0,R4,#+9
   \       0x64   0x9000             STR      R0,[SP, #+0]
   \       0x66   0x6AE0             LDR      R0,[R4, #+44]
   \       0x68   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \       0x6C   0x9002             STR      R0,[SP, #+8]
    472            SE_DataTransfer_t r_in = SE_DATATRANSFER_DEFAULT(ctx->r, 32);
   \       0x6E   0xF10D 0x0C30      ADD      R12,SP,#+48
   \       0x72   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0x76   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x7A   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x7E   0xF114 0x0030      ADDS     R0,R4,#+48
   \       0x82   0x900C             STR      R0,[SP, #+48]
    473            SE_DataTransfer_t Xp2_in = SE_DATATRANSFER_DEFAULT(ctx->Xp2, 64);
   \       0x84   0xF10D 0x0C24      ADD      R12,SP,#+36
   \       0x88   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \       0x8C   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x90   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x94   0xF514 0x7088      ADDS     R0,R4,#+272
   \       0x98   0x9009             STR      R0,[SP, #+36]
    474            SE_DataTransfer_t Xp_in = SE_DATATRANSFER_DEFAULT(ctx->Xp, 64);
   \       0x9A   0xF10D 0x0C18      ADD      R12,SP,#+24
   \       0x9E   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \       0xA2   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xA6   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xAA   0xF514 0x70A8      ADDS     R0,R4,#+336
   \       0xAE   0x9006             STR      R0,[SP, #+24]
    475            SE_DataTransfer_t key_out = SE_DATATRANSFER_DEFAULT(buf, 32);
   \       0xB0   0xAB03             ADD      R3,SP,#+12
   \       0xB2   0x.... 0x....      LDR.W    R12,??DataTable8
   \       0xB6   0xE89C 0x0007      LDM      R12,{R0-R2}
   \       0xBA   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xBE   0x9503             STR      R5,[SP, #+12]
    476          
    477            SE_addDataInput(se_cmd, &domain_in);
   \       0xC0   0xA90F             ADD      R1,SP,#+60
   \       0xC2   0x4640             MOV      R0,R8
   \       0xC4   0x.... 0x....      BL       SE_addDataInput
    478            SE_addDataInput(se_cmd, &pwd_in);
   \       0xC8   0x4669             MOV      R1,SP
   \       0xCA   0x4640             MOV      R0,R8
   \       0xCC   0x.... 0x....      BL       SE_addDataInput
    479            SE_addDataInput(se_cmd, &r_in);
   \       0xD0   0xA90C             ADD      R1,SP,#+48
   \       0xD2   0x4640             MOV      R0,R8
   \       0xD4   0x.... 0x....      BL       SE_addDataInput
    480            SE_addDataInput(se_cmd, &Xp2_in);
   \       0xD8   0xA909             ADD      R1,SP,#+36
   \       0xDA   0x4640             MOV      R0,R8
   \       0xDC   0x.... 0x....      BL       SE_addDataInput
    481            SE_addDataInput(se_cmd, &Xp_in);
   \       0xE0   0xA906             ADD      R1,SP,#+24
   \       0xE2   0x4640             MOV      R0,R8
   \       0xE4   0x.... 0x....      BL       SE_addDataInput
    482          
    483            SE_addDataOutput(se_cmd, &key_out);
   \       0xE8   0xA903             ADD      R1,SP,#+12
   \       0xEA   0x4640             MOV      R0,R8
   \       0xEC   0x.... 0x....      BL       SE_addDataOutput
    484          
    485            SE_addParameter(se_cmd, ctx->curve_flags);
   \       0xF0   0x6861             LDR      R1,[R4, #+4]
   \       0xF2   0x4640             MOV      R0,R8
   \       0xF4   0x.... 0x....      BL       SE_addParameter
    486            SE_addParameter(se_cmd, ctx->pwd_len);
   \       0xF8   0x6AE1             LDR      R1,[R4, #+44]
   \       0xFA   0x4640             MOV      R0,R8
   \       0xFC   0x.... 0x....      BL       SE_addParameter
    487            SE_addParameter(se_cmd, gen_key_flags);
   \      0x100   0x4649             MOV      R1,R9
   \      0x102   0x4640             MOV      R0,R8
   \      0x104   0x.... 0x....      BL       SE_addParameter
    488          
    489            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \      0x108   0x0038             MOVS     R0,R7
   \      0x10A   0x.... 0x....      BL       sli_se_execute_and_wait
    490          
    491            if (ret == SL_STATUS_OK) {
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD102             BNE.N    ??sl_se_ecjpake_derive_secret_4
    492              *olen = 32;
   \      0x112   0x2120             MOVS     R1,#+32
   \      0x114   0x6031             STR      R1,[R6, #+0]
   \      0x116   0xE001             B.N      ??sl_se_ecjpake_derive_secret_5
    493            } else {
    494              *olen = 0;
   \                     ??sl_se_ecjpake_derive_secret_4: (+1)
   \      0x118   0x2100             MOVS     R1,#+0
   \      0x11A   0x6031             STR      R1,[R6, #+0]
    495            }
    496            return ret;
   \                     ??sl_se_ecjpake_derive_secret_5: (+1)
   \                     ??sl_se_ecjpake_derive_secret_2: (+1)
   \      0x11C   0xB012             ADD      SP,SP,#+72
   \      0x11E   0xE8BD 0x87F0      POP      {R4-R10,PC}
    497          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020
    498          
    499          /***************************************************************************//**
    500           * This clears an ECJPAKE context.
    501           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    502          sl_status_t sl_se_ecjpake_free(sl_se_ecjpake_context_t *ctx)
    503          {
   \                     sl_se_ecjpake_free: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    504            if (ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??sl_se_ecjpake_free_0
    505              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE009             B.N      ??sl_se_ecjpake_free_1
    506            }
    507          
    508            memset(ctx, 0, sizeof(*ctx));
   \                     ??sl_se_ecjpake_free_0: (+1)
   \        0xC   0xF44F 0x77C8      MOV      R7,#+400
   \       0x10   0x2500             MOVS     R5,#+0
   \       0x12   0x0026             MOVS     R6,R4
   \       0x14   0x002A             MOVS     R2,R5
   \       0x16   0x0039             MOVS     R1,R7
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x.... 0x....      BL       __aeabi_memset
    509          
    510            return SL_STATUS_OK;
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??sl_se_ecjpake_free_1: (+1)
   \       0x20   0xBDF2             POP      {R1,R4-R7,PC}
    511          }
    512          
    513          /***************************************************************************//**
    514           * Initialize an ECJPAKE context.
    515           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    516          sl_status_t sl_se_ecjpake_init(sl_se_ecjpake_context_t *ctx,
    517                                         sl_se_command_context_t *cmd_ctx)
    518          {
   \                     sl_se_ecjpake_init: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    519            if (ctx == NULL || cmd_ctx == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??sl_se_ecjpake_init_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??sl_se_ecjpake_init_1
    520              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_init_0: (+1)
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE00A             B.N      ??sl_se_ecjpake_init_2
    521            }
    522          
    523            memset(ctx, 0, sizeof(*ctx));
   \                     ??sl_se_ecjpake_init_1: (+1)
   \       0x14   0xF44F 0x78C8      MOV      R8,#+400
   \       0x18   0x2600             MOVS     R6,#+0
   \       0x1A   0x0027             MOVS     R7,R4
   \       0x1C   0x0032             MOVS     R2,R6
   \       0x1E   0x4641             MOV      R1,R8
   \       0x20   0x0038             MOVS     R0,R7
   \       0x22   0x.... 0x....      BL       __aeabi_memset
    524          
    525            // store pointer to command context object
    526            ctx->cmd_ctx = cmd_ctx;
   \       0x26   0x6025             STR      R5,[R4, #+0]
    527          
    528            return SL_STATUS_OK;
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??sl_se_ecjpake_init_2: (+1)
   \       0x2A   0xE8BD 0x81F0      POP      {R4-R8,PC}
    529          }
    530          
    531          /***************************************************************************//**
    532           * Read and process the first round message.
    533           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    534          sl_status_t sl_se_ecjpake_read_round_one(sl_se_ecjpake_context_t *ctx,
    535                                                   const unsigned char *buf,
    536                                                   size_t len)
    537          {
   \                     sl_se_ecjpake_read_round_one: (+1)
   \        0x0   0xE92D 0x41F6      PUSH     {R1,R2,R4-R8,LR}
   \        0x4   0xB0C8             SUB      SP,SP,#+288
   \        0x6   0x0004             MOVS     R4,R0
    538            sl_status_t ret = SL_STATUS_OK;
   \        0x8   0x2600             MOVS     R6,#+0
    539          
    540            if (ctx == NULL || buf == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD002             BEQ.N    ??sl_se_ecjpake_read_round_one_0
   \        0xE   0x9848             LDR      R0,[SP, #+288]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD101             BNE.N    ??sl_se_ecjpake_read_round_one_1
    541              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_read_round_one_0: (+1)
   \       0x14   0x2021             MOVS     R0,#+33
   \       0x16   0xE0F9             B.N      ??sl_se_ecjpake_read_round_one_2
    542            }
    543            sl_se_command_context_t *cmd_ctx = ctx->cmd_ctx;
   \                     ??sl_se_ecjpake_read_round_one_1: (+1)
   \       0x18   0xF8D4 0x8000      LDR      R8,[R4, #+0]
    544            SE_Command_t *se_cmd = &ctx->cmd_ctx->command;
   \       0x1C   0x6827             LDR      R7,[R4, #+0]
   \       0x1E   0x2160             MOVS     R1,#+96
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0xAD30             ADD      R5,SP,#+192
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       __aeabi_memset
   \       0x2A   0x2160             MOVS     R1,#+96
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0xAD18             ADD      R5,SP,#+96
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x.... 0x....      BL       __aeabi_memset
    545          
    546            // We should receive 2 binary points and 2 ZKP's.
    547          
    548            // Local storage for ZKP's.
    549            uint8_t zkp1[32 + 64] = { 0 };
    550            uint8_t zkp2[32 + 64] = { 0 };
    551          
    552            uint8_t *obuf = ctx->Xp1;
   \       0x36   0xF114 0x00D0      ADDS     R0,R4,#+208
   \       0x3A   0x9002             STR      R0,[SP, #+8]
    553            size_t olen = 64;
   \       0x3C   0x2040             MOVS     R0,#+64
   \       0x3E   0x9001             STR      R0,[SP, #+4]
    554          
    555            // Parse structures.
    556            ret = ecjpake_parse_tls_point(&buf, &len, NULL, &obuf, &olen);
   \       0x40   0xA801             ADD      R0,SP,#+4
   \       0x42   0x9000             STR      R0,[SP, #+0]
   \       0x44   0xAB02             ADD      R3,SP,#+8
   \       0x46   0x2200             MOVS     R2,#+0
   \       0x48   0xA949             ADD      R1,SP,#+292
   \       0x4A   0xA848             ADD      R0,SP,#+288
   \       0x4C   0x.... 0x....      BL       ecjpake_parse_tls_point
   \       0x50   0x0005             MOVS     R5,R0
    557            if (ret != SL_STATUS_OK) {
   \       0x52   0x2D00             CMP      R5,#+0
   \       0x54   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_one_3
    558              return ret;
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0xE0D8             B.N      ??sl_se_ecjpake_read_round_one_2
    559            }
    560          
    561            obuf = zkp1;
   \                     ??sl_se_ecjpake_read_round_one_3: (+1)
   \       0x5A   0xA830             ADD      R0,SP,#+192
   \       0x5C   0x9002             STR      R0,[SP, #+8]
    562            olen = 96;
   \       0x5E   0x2060             MOVS     R0,#+96
   \       0x60   0x9001             STR      R0,[SP, #+4]
    563            ret = ecjpake_parse_tls_zkp(&buf, &len, NULL, &obuf, &olen);
   \       0x62   0xA801             ADD      R0,SP,#+4
   \       0x64   0x9000             STR      R0,[SP, #+0]
   \       0x66   0xAB02             ADD      R3,SP,#+8
   \       0x68   0x2200             MOVS     R2,#+0
   \       0x6A   0xA949             ADD      R1,SP,#+292
   \       0x6C   0xA848             ADD      R0,SP,#+288
   \       0x6E   0x.... 0x....      BL       ecjpake_parse_tls_zkp
   \       0x72   0x0006             MOVS     R6,R0
    564            if (ret != SL_STATUS_OK) {
   \       0x74   0x2E00             CMP      R6,#+0
   \       0x76   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_one_4
    565              return ret;
   \       0x78   0x0030             MOVS     R0,R6
   \       0x7A   0xE0C7             B.N      ??sl_se_ecjpake_read_round_one_2
    566            }
    567          
    568            obuf = ctx->Xp2;
   \                     ??sl_se_ecjpake_read_round_one_4: (+1)
   \       0x7C   0xF514 0x7088      ADDS     R0,R4,#+272
   \       0x80   0x9002             STR      R0,[SP, #+8]
    569            olen = 64;
   \       0x82   0x2040             MOVS     R0,#+64
   \       0x84   0x9001             STR      R0,[SP, #+4]
    570            ret = ecjpake_parse_tls_point(&buf, &len, NULL, &obuf, &olen);
   \       0x86   0xA801             ADD      R0,SP,#+4
   \       0x88   0x9000             STR      R0,[SP, #+0]
   \       0x8A   0xAB02             ADD      R3,SP,#+8
   \       0x8C   0x2200             MOVS     R2,#+0
   \       0x8E   0xA949             ADD      R1,SP,#+292
   \       0x90   0xA848             ADD      R0,SP,#+288
   \       0x92   0x.... 0x....      BL       ecjpake_parse_tls_point
   \       0x96   0x0005             MOVS     R5,R0
    571            if (ret != SL_STATUS_OK) {
   \       0x98   0x2D00             CMP      R5,#+0
   \       0x9A   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_one_5
    572              return ret;
   \       0x9C   0x0028             MOVS     R0,R5
   \       0x9E   0xE0B5             B.N      ??sl_se_ecjpake_read_round_one_2
    573            }
    574          
    575            obuf = zkp2;
   \                     ??sl_se_ecjpake_read_round_one_5: (+1)
   \       0xA0   0xA818             ADD      R0,SP,#+96
   \       0xA2   0x9002             STR      R0,[SP, #+8]
    576            olen = 96;
   \       0xA4   0x2060             MOVS     R0,#+96
   \       0xA6   0x9001             STR      R0,[SP, #+4]
    577            ret = ecjpake_parse_tls_zkp(&buf, &len, NULL, &obuf, &olen);
   \       0xA8   0xA801             ADD      R0,SP,#+4
   \       0xAA   0x9000             STR      R0,[SP, #+0]
   \       0xAC   0xAB02             ADD      R3,SP,#+8
   \       0xAE   0x2200             MOVS     R2,#+0
   \       0xB0   0xA949             ADD      R1,SP,#+292
   \       0xB2   0xA848             ADD      R0,SP,#+288
   \       0xB4   0x.... 0x....      BL       ecjpake_parse_tls_zkp
   \       0xB8   0x0006             MOVS     R6,R0
    578            if (ret != SL_STATUS_OK) {
   \       0xBA   0x2E00             CMP      R6,#+0
   \       0xBC   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_one_6
    579              return ret;
   \       0xBE   0x0030             MOVS     R0,R6
   \       0xC0   0xE0A4             B.N      ??sl_se_ecjpake_read_round_one_2
    580            }
    581          
    582            if (len > 0) {
   \                     ??sl_se_ecjpake_read_round_one_6: (+1)
   \       0xC2   0x9849             LDR      R0,[SP, #+292]
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_one_7
    583              // Too much input.
    584              return SL_STATUS_WOULD_OVERFLOW;
   \       0xC8   0x201D             MOVS     R0,#+29
   \       0xCA   0xE09F             B.N      ??sl_se_ecjpake_read_round_one_2
    585            }
    586          
    587            // SE command structures.
    588            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_JPAKE_R1_VERIFY);
   \                     ??sl_se_ecjpake_read_round_one_7: (+1)
   \       0xCC   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \       0xD0   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0xF8C8 0x0004      STR      R0,[R8, #+4]
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xF8C8 0x001C      STR      R0,[R8, #+28]
    589            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \       0xE6   0xAD15             ADD      R5,SP,#+84
   \       0xE8   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \       0xEC   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xF0   0xE885 0x000E      STM      R5,{R1-R3}
    590            SE_DataTransfer_t userid_mine = SE_DATATRANSFER_DEFAULT(
    591              (void*)ecjpake_id[ctx->role], strlen(ecjpake_id[ctx->role]));
   \       0xF4   0xAB06             ADD      R3,SP,#+24
   \       0xF6   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \       0xFA   0xE890 0x0026      LDM      R0,{R1,R2,R5}
   \       0xFE   0xE883 0x0026      STM      R3,{R1,R2,R5}
   \      0x102   0x.... 0x....      LDR.W    R5,??DataTable8_4
   \      0x106   0x7A20             LDRB     R0,[R4, #+8]
   \      0x108   0xF855 0x0020      LDR      R0,[R5, R0, LSL #+2]
   \      0x10C   0x9006             STR      R0,[SP, #+24]
   \      0x10E   0x7A20             LDRB     R0,[R4, #+8]
   \      0x110   0xF855 0x0020      LDR      R0,[R5, R0, LSL #+2]
   \      0x114   0x.... 0x....      BL       strlen
   \      0x118   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x11C   0x9008             STR      R0,[SP, #+32]
    592            SE_DataTransfer_t userid_peer = SE_DATATRANSFER_DEFAULT(
    593              (void*)ecjpake_id[1 - ctx->role], strlen(ecjpake_id[1 - ctx->role]));
   \      0x11E   0xF10D 0x0C0C      ADD      R12,SP,#+12
   \      0x122   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \      0x126   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x12A   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x12E   0x7A20             LDRB     R0,[R4, #+8]
   \      0x130   0x4240             RSBS     R0,R0,#+0
   \      0x132   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \      0x136   0x6840             LDR      R0,[R0, #+4]
   \      0x138   0x9003             STR      R0,[SP, #+12]
   \      0x13A   0x7A20             LDRB     R0,[R4, #+8]
   \      0x13C   0x4240             RSBS     R0,R0,#+0
   \      0x13E   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \      0x142   0x6840             LDR      R0,[R0, #+4]
   \      0x144   0x.... 0x....      BL       strlen
   \      0x148   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x14C   0x9005             STR      R0,[SP, #+20]
    594            SE_DataTransfer_t Xp1_in = SE_DATATRANSFER_DEFAULT(ctx->Xp1, 64);
   \      0x14E   0xAB12             ADD      R3,SP,#+72
   \      0x150   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \      0x154   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x158   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x15C   0xF114 0x00D0      ADDS     R0,R4,#+208
   \      0x160   0x9012             STR      R0,[SP, #+72]
    595            SE_DataTransfer_t zkp1_in = SE_DATATRANSFER_DEFAULT(zkp1, sizeof(zkp1));
   \      0x162   0xF10D 0x0C3C      ADD      R12,SP,#+60
   \      0x166   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \      0x16A   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x16E   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x172   0xA830             ADD      R0,SP,#+192
   \      0x174   0x900F             STR      R0,[SP, #+60]
    596            SE_DataTransfer_t Xp2_in = SE_DATATRANSFER_DEFAULT(ctx->Xp2, 64);
   \      0x176   0xF10D 0x0C30      ADD      R12,SP,#+48
   \      0x17A   0x.... 0x....      LDR.W    R0,??DataTable8_8
   \      0x17E   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x182   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x186   0xF514 0x7088      ADDS     R0,R4,#+272
   \      0x18A   0x900C             STR      R0,[SP, #+48]
    597            SE_DataTransfer_t zkp2_in = SE_DATATRANSFER_DEFAULT(zkp2, sizeof(zkp2));
   \      0x18C   0xAB09             ADD      R3,SP,#+36
   \      0x18E   0x.... 0x....      LDR.W    R12,??DataTable8_9
   \      0x192   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x196   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x19A   0xA818             ADD      R0,SP,#+96
   \      0x19C   0x9009             STR      R0,[SP, #+36]
    598          
    599            SE_addDataInput(se_cmd, &domain_in);
   \      0x19E   0xA915             ADD      R1,SP,#+84
   \      0x1A0   0x0038             MOVS     R0,R7
   \      0x1A2   0x.... 0x....      BL       SE_addDataInput
    600            SE_addDataInput(se_cmd, &userid_mine);
   \      0x1A6   0xA906             ADD      R1,SP,#+24
   \      0x1A8   0x0038             MOVS     R0,R7
   \      0x1AA   0x.... 0x....      BL       SE_addDataInput
    601            SE_addDataInput(se_cmd, &userid_peer);
   \      0x1AE   0xA903             ADD      R1,SP,#+12
   \      0x1B0   0x0038             MOVS     R0,R7
   \      0x1B2   0x.... 0x....      BL       SE_addDataInput
    602            SE_addDataInput(se_cmd, &Xp1_in);
   \      0x1B6   0xA912             ADD      R1,SP,#+72
   \      0x1B8   0x0038             MOVS     R0,R7
   \      0x1BA   0x.... 0x....      BL       SE_addDataInput
    603            SE_addDataInput(se_cmd, &zkp1_in);
   \      0x1BE   0xA90F             ADD      R1,SP,#+60
   \      0x1C0   0x0038             MOVS     R0,R7
   \      0x1C2   0x.... 0x....      BL       SE_addDataInput
    604            SE_addDataInput(se_cmd, &Xp2_in);
   \      0x1C6   0xA90C             ADD      R1,SP,#+48
   \      0x1C8   0x0038             MOVS     R0,R7
   \      0x1CA   0x.... 0x....      BL       SE_addDataInput
    605            SE_addDataInput(se_cmd, &zkp2_in);
   \      0x1CE   0xA909             ADD      R1,SP,#+36
   \      0x1D0   0x0038             MOVS     R0,R7
   \      0x1D2   0x.... 0x....      BL       SE_addDataInput
    606          
    607            SE_addParameter(se_cmd, ctx->curve_flags);
   \      0x1D6   0x6861             LDR      R1,[R4, #+4]
   \      0x1D8   0x0038             MOVS     R0,R7
   \      0x1DA   0x.... 0x....      BL       SE_addParameter
    608            SE_addParameter(se_cmd, strlen(ecjpake_id[ctx->role]));
   \      0x1DE   0x7A20             LDRB     R0,[R4, #+8]
   \      0x1E0   0xF855 0x0020      LDR      R0,[R5, R0, LSL #+2]
   \      0x1E4   0x.... 0x....      BL       strlen
   \      0x1E8   0x0001             MOVS     R1,R0
   \      0x1EA   0x0038             MOVS     R0,R7
   \      0x1EC   0x.... 0x....      BL       SE_addParameter
    609            SE_addParameter(se_cmd, strlen(ecjpake_id[1 - ctx->role]));
   \      0x1F0   0x7A20             LDRB     R0,[R4, #+8]
   \      0x1F2   0x4240             RSBS     R0,R0,#+0
   \      0x1F4   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \      0x1F8   0x6840             LDR      R0,[R0, #+4]
   \      0x1FA   0x.... 0x....      BL       strlen
   \      0x1FE   0x0001             MOVS     R1,R0
   \      0x200   0x0038             MOVS     R0,R7
   \      0x202   0x.... 0x....      BL       SE_addParameter
    610          
    611            return sli_se_execute_and_wait(cmd_ctx);
   \      0x206   0x4640             MOV      R0,R8
   \      0x208   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_ecjpake_read_round_one_2: (+1)
   \      0x20C   0xB04A             ADD      SP,SP,#+296
   \      0x20E   0xE8BD 0x81F0      POP      {R4-R8,PC}
    612          }

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060
    613          
    614          /***************************************************************************//**
    615           * Read and process the second round message.
    616           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    617          sl_status_t sl_se_ecjpake_read_round_two(sl_se_ecjpake_context_t *ctx,
    618                                                   const unsigned char *buf,
    619                                                   size_t len)
    620          {
   \                     sl_se_ecjpake_read_round_two: (+1)
   \        0x0   0xE92D 0x41F6      PUSH     {R1,R2,R4-R8,LR}
   \        0x4   0xB0B0             SUB      SP,SP,#+192
   \        0x6   0x0004             MOVS     R4,R0
    621            if (ctx == NULL || buf == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD002             BEQ.N    ??sl_se_ecjpake_read_round_two_0
   \        0xC   0x9830             LDR      R0,[SP, #+192]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??sl_se_ecjpake_read_round_two_1
    622              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_read_round_two_0: (+1)
   \       0x12   0x2021             MOVS     R0,#+33
   \       0x14   0xE0DE             B.N      ??sl_se_ecjpake_read_round_two_2
    623            }
    624          
    625            sl_se_command_context_t *cmd_ctx = ctx->cmd_ctx;
   \                     ??sl_se_ecjpake_read_round_two_1: (+1)
   \       0x16   0xF8D4 0x8000      LDR      R8,[R4, #+0]
    626            SE_Command_t *se_cmd = &ctx->cmd_ctx->command;
   \       0x1A   0x6827             LDR      R7,[R4, #+0]
    627            sl_status_t ret = SL_STATUS_OK;
   \       0x1C   0x2500             MOVS     R5,#+0
    628          
    629            // Local storage for ZKP.
    630            uint8_t zkpB[32 + 64];
    631          
    632            if (ctx->role == SL_SE_ECJPAKE_CLIENT) {
   \       0x1E   0x7A20             LDRB     R0,[R4, #+8]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD121             BNE.N    ??sl_se_ecjpake_read_round_two_3
    633              uint16_t tls_id;
    634          
    635              if (len < 3) {
   \       0x24   0x9831             LDR      R0,[SP, #+196]
   \       0x26   0x2803             CMP      R0,#+3
   \       0x28   0xD201             BCS.N    ??sl_se_ecjpake_read_round_two_4
    636                return SL_STATUS_INVALID_PARAMETER;
   \       0x2A   0x2021             MOVS     R0,#+33
   \       0x2C   0xE0D2             B.N      ??sl_se_ecjpake_read_round_two_2
    637              }
    638          
    639              // First byte is curve_type; only named_curve is handled.
    640              if (*(buf++) != SL_SE_ECP_TLS_NAMED_CURVE) {
   \                     ??sl_se_ecjpake_read_round_two_4: (+1)
   \       0x2E   0x9830             LDR      R0,[SP, #+192]
   \       0x30   0x1C41             ADDS     R1,R0,#+1
   \       0x32   0x9130             STR      R1,[SP, #+192]
   \       0x34   0x7800             LDRB     R0,[R0, #+0]
   \       0x36   0x2803             CMP      R0,#+3
   \       0x38   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_two_5
    641                return SL_STATUS_INVALID_PARAMETER;
   \       0x3A   0x2021             MOVS     R0,#+33
   \       0x3C   0xE0CA             B.N      ??sl_se_ecjpake_read_round_two_2
    642              }
    643          
    644              // Next two bytes are the namedcurve value.
    645              tls_id = *(buf++);
   \                     ??sl_se_ecjpake_read_round_two_5: (+1)
   \       0x3E   0x9830             LDR      R0,[SP, #+192]
   \       0x40   0x7801             LDRB     R1,[R0, #+0]
   \       0x42   0x9830             LDR      R0,[SP, #+192]
   \       0x44   0x1C40             ADDS     R0,R0,#+1
   \       0x46   0x9030             STR      R0,[SP, #+192]
    646              tls_id <<= 8;
   \       0x48   0x0209             LSLS     R1,R1,#+8
    647              tls_id |= *(buf++);
   \       0x4A   0x9830             LDR      R0,[SP, #+192]
   \       0x4C   0x7800             LDRB     R0,[R0, #+0]
   \       0x4E   0x4301             ORRS     R1,R0,R1
   \       0x50   0x9830             LDR      R0,[SP, #+192]
   \       0x52   0x1C40             ADDS     R0,R0,#+1
   \       0x54   0x9030             STR      R0,[SP, #+192]
    648          
    649              // We support only one curve.
    650              if (tls_id != SL_SE_TLSID_ECC_P256) {
   \       0x56   0x0008             MOVS     R0,R1
   \       0x58   0xB280             UXTH     R0,R0
   \       0x5A   0x2817             CMP      R0,#+23
   \       0x5C   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_two_6
    651                return SL_STATUS_NOT_SUPPORTED;
   \       0x5E   0x200F             MOVS     R0,#+15
   \       0x60   0xE0B8             B.N      ??sl_se_ecjpake_read_round_two_2
    652              }
    653          
    654              len -= 3;
   \                     ??sl_se_ecjpake_read_round_two_6: (+1)
   \       0x62   0x9831             LDR      R0,[SP, #+196]
   \       0x64   0x1EC0             SUBS     R0,R0,#+3
   \       0x66   0x9031             STR      R0,[SP, #+196]
    655            }
    656          
    657            // We should receive 1 binary point and 1 ZKP.
    658            uint8_t *obuf = ctx->Xp;
   \                     ??sl_se_ecjpake_read_round_two_3: (+1)
   \       0x68   0xF514 0x70A8      ADDS     R0,R4,#+336
   \       0x6C   0x9002             STR      R0,[SP, #+8]
    659            size_t olen = 64;
   \       0x6E   0x2040             MOVS     R0,#+64
   \       0x70   0x9001             STR      R0,[SP, #+4]
    660          
    661            // Parse structures.
    662            ret = ecjpake_parse_tls_point(&buf, &len, NULL, &obuf, &olen);
   \       0x72   0xA801             ADD      R0,SP,#+4
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0xAB02             ADD      R3,SP,#+8
   \       0x78   0x2200             MOVS     R2,#+0
   \       0x7A   0xA931             ADD      R1,SP,#+196
   \       0x7C   0xA830             ADD      R0,SP,#+192
   \       0x7E   0x.... 0x....      BL       ecjpake_parse_tls_point
   \       0x82   0x0006             MOVS     R6,R0
    663            if (ret != SL_STATUS_OK) {
   \       0x84   0x2E00             CMP      R6,#+0
   \       0x86   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_two_7
    664              return ret;
   \       0x88   0x0030             MOVS     R0,R6
   \       0x8A   0xE0A3             B.N      ??sl_se_ecjpake_read_round_two_2
    665            }
    666          
    667            obuf = zkpB;
   \                     ??sl_se_ecjpake_read_round_two_7: (+1)
   \       0x8C   0xA818             ADD      R0,SP,#+96
   \       0x8E   0x9002             STR      R0,[SP, #+8]
    668            olen = sizeof(zkpB);
   \       0x90   0x2060             MOVS     R0,#+96
   \       0x92   0x9001             STR      R0,[SP, #+4]
    669            ret = ecjpake_parse_tls_zkp(&buf, &len, NULL, &obuf, &olen);
   \       0x94   0xA801             ADD      R0,SP,#+4
   \       0x96   0x9000             STR      R0,[SP, #+0]
   \       0x98   0xAB02             ADD      R3,SP,#+8
   \       0x9A   0x2200             MOVS     R2,#+0
   \       0x9C   0xA931             ADD      R1,SP,#+196
   \       0x9E   0xA830             ADD      R0,SP,#+192
   \       0xA0   0x.... 0x....      BL       ecjpake_parse_tls_zkp
   \       0xA4   0x0005             MOVS     R5,R0
    670            if (ret != SL_STATUS_OK) {
   \       0xA6   0x2D00             CMP      R5,#+0
   \       0xA8   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_two_8
    671              return ret;
   \       0xAA   0x0028             MOVS     R0,R5
   \       0xAC   0xE092             B.N      ??sl_se_ecjpake_read_round_two_2
    672            }
    673          
    674            if (len > 0) {
   \                     ??sl_se_ecjpake_read_round_two_8: (+1)
   \       0xAE   0x9831             LDR      R0,[SP, #+196]
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_two_9
    675              // Too much input.
    676              return SL_STATUS_WOULD_OVERFLOW;
   \       0xB4   0x201D             MOVS     R0,#+29
   \       0xB6   0xE08D             B.N      ??sl_se_ecjpake_read_round_two_2
    677            }
    678          
    679            // SE command structures.
    680            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_JPAKE_R2_VERIFY);
   \                     ??sl_se_ecjpake_read_round_two_9: (+1)
   \       0xB8   0x.... 0x....      LDR.W    R0,??DataTable8_10
   \       0xBC   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xF8C8 0x0004      STR      R0,[R8, #+4]
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0xF8C8 0x001C      STR      R0,[R8, #+28]
    681            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \       0xD2   0xAB15             ADD      R3,SP,#+84
   \       0xD4   0x.... 0x....      LDR.W    R0,??DataTable8_11
   \       0xD8   0xE890 0x0046      LDM      R0,{R1,R2,R6}
   \       0xDC   0xE883 0x0046      STM      R3,{R1,R2,R6}
    682            SE_DataTransfer_t userid_peer = SE_DATATRANSFER_DEFAULT(
    683              (void*)ecjpake_id[1 - ctx->role], strlen(ecjpake_id[1 - ctx->role]));
   \       0xE0   0xAE03             ADD      R6,SP,#+12
   \       0xE2   0x.... 0x....      LDR.W    R0,??DataTable8_12
   \       0xE6   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xEA   0xE886 0x000E      STM      R6,{R1-R3}
   \       0xEE   0x.... 0x....      LDR.W    R6,??DataTable8_4
   \       0xF2   0x7A20             LDRB     R0,[R4, #+8]
   \       0xF4   0x4240             RSBS     R0,R0,#+0
   \       0xF6   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \       0xFA   0x6840             LDR      R0,[R0, #+4]
   \       0xFC   0x9003             STR      R0,[SP, #+12]
   \       0xFE   0x7A20             LDRB     R0,[R4, #+8]
   \      0x100   0x4240             RSBS     R0,R0,#+0
   \      0x102   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \      0x106   0x6840             LDR      R0,[R0, #+4]
   \      0x108   0x.... 0x....      BL       strlen
   \      0x10C   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x110   0x9005             STR      R0,[SP, #+20]
    684            SE_DataTransfer_t Xm1_in = SE_DATATRANSFER_DEFAULT(ctx->Xm1, 64);
   \      0x112   0xF10D 0x0C48      ADD      R12,SP,#+72
   \      0x116   0x.... 0x....      LDR.W    R0,??DataTable8_13
   \      0x11A   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x11E   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x122   0xF114 0x0050      ADDS     R0,R4,#+80
   \      0x126   0x9012             STR      R0,[SP, #+72]
    685            SE_DataTransfer_t Xm2_in = SE_DATATRANSFER_DEFAULT(ctx->Xm2, 64);
   \      0x128   0xAB0F             ADD      R3,SP,#+60
   \      0x12A   0x.... 0x....      LDR.W    R0,??DataTable8_14
   \      0x12E   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x132   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x136   0xF114 0x0090      ADDS     R0,R4,#+144
   \      0x13A   0x900F             STR      R0,[SP, #+60]
    686            SE_DataTransfer_t Xp1_in = SE_DATATRANSFER_DEFAULT(ctx->Xp1, 64);
   \      0x13C   0xF10D 0x0C30      ADD      R12,SP,#+48
   \      0x140   0x.... 0x....      LDR.W    R0,??DataTable8_15
   \      0x144   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x148   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x14C   0xF114 0x00D0      ADDS     R0,R4,#+208
   \      0x150   0x900C             STR      R0,[SP, #+48]
    687            SE_DataTransfer_t Xp_in = SE_DATATRANSFER_DEFAULT(ctx->Xp, 64);
   \      0x152   0xAB09             ADD      R3,SP,#+36
   \      0x154   0x.... 0x....      LDR.W    R0,??DataTable8_16
   \      0x158   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \      0x15C   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \      0x160   0xF514 0x70A8      ADDS     R0,R4,#+336
   \      0x164   0x9009             STR      R0,[SP, #+36]
    688            SE_DataTransfer_t zkpB_in = SE_DATATRANSFER_DEFAULT(zkpB, sizeof(zkpB));
   \      0x166   0xAB06             ADD      R3,SP,#+24
   \      0x168   0x.... 0x....      LDR.W    R12,??DataTable8_17
   \      0x16C   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x170   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x174   0xA818             ADD      R0,SP,#+96
   \      0x176   0x9006             STR      R0,[SP, #+24]
    689          
    690            SE_addDataInput(se_cmd, &domain_in);
   \      0x178   0xA915             ADD      R1,SP,#+84
   \      0x17A   0x0038             MOVS     R0,R7
   \      0x17C   0x.... 0x....      BL       SE_addDataInput
    691            SE_addDataInput(se_cmd, &userid_peer);
   \      0x180   0xA903             ADD      R1,SP,#+12
   \      0x182   0x0038             MOVS     R0,R7
   \      0x184   0x.... 0x....      BL       SE_addDataInput
    692            SE_addDataInput(se_cmd, &Xm1_in);
   \      0x188   0xA912             ADD      R1,SP,#+72
   \      0x18A   0x0038             MOVS     R0,R7
   \      0x18C   0x.... 0x....      BL       SE_addDataInput
    693            SE_addDataInput(se_cmd, &Xm2_in);
   \      0x190   0xA90F             ADD      R1,SP,#+60
   \      0x192   0x0038             MOVS     R0,R7
   \      0x194   0x.... 0x....      BL       SE_addDataInput
    694            SE_addDataInput(se_cmd, &Xp1_in);
   \      0x198   0xA90C             ADD      R1,SP,#+48
   \      0x19A   0x0038             MOVS     R0,R7
   \      0x19C   0x.... 0x....      BL       SE_addDataInput
    695            SE_addDataInput(se_cmd, &Xp_in);
   \      0x1A0   0xA909             ADD      R1,SP,#+36
   \      0x1A2   0x0038             MOVS     R0,R7
   \      0x1A4   0x.... 0x....      BL       SE_addDataInput
    696            SE_addDataInput(se_cmd, &zkpB_in);
   \      0x1A8   0xA906             ADD      R1,SP,#+24
   \      0x1AA   0x0038             MOVS     R0,R7
   \      0x1AC   0x.... 0x....      BL       SE_addDataInput
    697          
    698            SE_addParameter(se_cmd, ctx->curve_flags);
   \      0x1B0   0x6861             LDR      R1,[R4, #+4]
   \      0x1B2   0x0038             MOVS     R0,R7
   \      0x1B4   0x.... 0x....      BL       SE_addParameter
    699            SE_addParameter(se_cmd, strlen(ecjpake_id[1 - ctx->role]));
   \      0x1B8   0x7A20             LDRB     R0,[R4, #+8]
   \      0x1BA   0x4240             RSBS     R0,R0,#+0
   \      0x1BC   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \      0x1C0   0x6840             LDR      R0,[R0, #+4]
   \      0x1C2   0x.... 0x....      BL       strlen
   \      0x1C6   0x0001             MOVS     R1,R0
   \      0x1C8   0x0038             MOVS     R0,R7
   \      0x1CA   0x.... 0x....      BL       SE_addParameter
    700          
    701            return sli_se_execute_and_wait(cmd_ctx);
   \      0x1CE   0x4640             MOV      R0,R8
   \      0x1D0   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_ecjpake_read_round_two_2: (+1)
   \      0x1D4   0xB032             ADD      SP,SP,#+200
   \      0x1D6   0xE8BD 0x81F0      POP      {R4-R8,PC}
    702          }

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060
    703          
    704          /***************************************************************************//**
    705           * Set up an ECJPAKE context for use.
    706           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    707          sl_status_t sl_se_ecjpake_setup(sl_se_ecjpake_context_t *ctx,
    708                                          sl_se_ecjpake_role_t role,
    709                                          sl_se_hash_type_t hash,
    710                                          uint32_t curve,
    711                                          const unsigned char *secret,
    712                                          size_t len)
    713          {
   \                     sl_se_ecjpake_setup: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
   \        0xC   0x9D0A             LDR      R5,[SP, #+40]
   \        0xE   0x9E0B             LDR      R6,[SP, #+44]
    714            if (ctx == NULL || (len > 0 && secret == NULL)) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD003             BEQ.N    ??sl_se_ecjpake_setup_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD003             BEQ.N    ??sl_se_ecjpake_setup_1
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD101             BNE.N    ??sl_se_ecjpake_setup_1
    715              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_setup_0: (+1)
   \       0x1C   0x2021             MOVS     R0,#+33
   \       0x1E   0xE01E             B.N      ??sl_se_ecjpake_setup_2
    716            }
    717          
    718            // SE only supports passphrases of maximum 32 bytes.
    719            if (len > sizeof(ctx->pwd)) {
   \                     ??sl_se_ecjpake_setup_1: (+1)
   \       0x20   0x2E21             CMP      R6,#+33
   \       0x22   0xD301             BCC.N    ??sl_se_ecjpake_setup_3
    720              return SL_STATUS_INVALID_PARAMETER;
   \       0x24   0x2021             MOVS     R0,#+33
   \       0x26   0xE01A             B.N      ??sl_se_ecjpake_setup_2
    721            }
    722          
    723            // SE currently only supports SHA256 as JPAKE hashing mechanism.
    724            if (hash != SL_SE_HASH_SHA256) {
   \                     ??sl_se_ecjpake_setup_3: (+1)
   \       0x28   0x4640             MOV      R0,R8
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2803             CMP      R0,#+3
   \       0x2E   0xD001             BEQ.N    ??sl_se_ecjpake_setup_4
    725              return SL_STATUS_NOT_SUPPORTED;
   \       0x30   0x200F             MOVS     R0,#+15
   \       0x32   0xE014             B.N      ??sl_se_ecjpake_setup_2
    726            }
    727          
    728            // SE currently only supports ECDSA secp256r1 as curve.
    729            if (curve != SL_SE_KEY_TYPE_ECC_P256) {
   \                     ??sl_se_ecjpake_setup_4: (+1)
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable8_18
   \       0x38   0x4581             CMP      R9,R0
   \       0x3A   0xD001             BEQ.N    ??sl_se_ecjpake_setup_5
    730              return SL_STATUS_NOT_SUPPORTED;
   \       0x3C   0x200F             MOVS     R0,#+15
   \       0x3E   0xE00E             B.N      ??sl_se_ecjpake_setup_2
    731            }
    732          
    733            ctx->curve_flags = 0x8000001FUL;
   \                     ??sl_se_ecjpake_setup_5: (+1)
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable8_19
   \       0x44   0x6060             STR      R0,[R4, #+4]
    734            ctx->role = role;
   \       0x46   0x7227             STRB     R7,[R4, #+8]
    735            ctx->pwd_len = len;
   \       0x48   0x62E6             STR      R6,[R4, #+44]
    736            memcpy(ctx->pwd, secret, len);
   \       0x4A   0x9600             STR      R6,[SP, #+0]
   \       0x4C   0x46AB             MOV      R11,R5
   \       0x4E   0xF114 0x0A09      ADDS     R10,R4,#+9
   \       0x52   0x9A00             LDR      R2,[SP, #+0]
   \       0x54   0x4659             MOV      R1,R11
   \       0x56   0x4650             MOV      R0,R10
   \       0x58   0x.... 0x....      BL       __aeabi_memcpy
    737          
    738            return SL_STATUS_OK;
   \       0x5C   0x2000             MOVS     R0,#+0
   \                     ??sl_se_ecjpake_setup_2: (+1)
   \       0x5E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    739          }
    740          
    741          /***************************************************************************//**
    742           * Generate and write the first round message.
    743           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    744          sl_status_t sl_se_ecjpake_write_round_one(sl_se_ecjpake_context_t *ctx,
    745                                                    unsigned char *buf,
    746                                                    size_t len,
    747                                                    size_t *olen)
    748          {
   \                     sl_se_ecjpake_write_round_one: (+1)
   \        0x0   0xE92D 0x47F6      PUSH     {R1,R2,R4-R10,LR}
   \        0x4   0xB0CA             SUB      SP,SP,#+296
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x001E             MOVS     R6,R3
    749            sl_status_t ret = SL_STATUS_OK;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
    750          
    751            if (ctx == NULL || buf == NULL || olen == NULL) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD003             BEQ.N    ??sl_se_ecjpake_write_round_one_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD001             BEQ.N    ??sl_se_ecjpake_write_round_one_0
   \       0x18   0x2E00             CMP      R6,#+0
   \       0x1A   0xD101             BNE.N    ??sl_se_ecjpake_write_round_one_1
    752              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_write_round_one_0: (+1)
   \       0x1C   0x2021             MOVS     R0,#+33
   \       0x1E   0xE0DD             B.N      ??sl_se_ecjpake_write_round_one_2
    753            }
    754          
    755            sl_se_command_context_t *cmd_ctx = ctx->cmd_ctx;
   \                     ??sl_se_ecjpake_write_round_one_1: (+1)
   \       0x20   0xF8D4 0xA000      LDR      R10,[R4, #+0]
    756            SE_Command_t *se_cmd = &ctx->cmd_ctx->command;
   \       0x24   0xF8D4 0x9000      LDR      R9,[R4, #+0]
    757            *olen = 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6030             STR      R0,[R6, #+0]
    758          
    759            // Local storage for ZKP's.
    760            uint8_t zkp1[32 + 64];
    761            uint8_t zkp2[32 + 64];
    762          
    763            // SE command structures.
    764            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_JPAKE_R1_GENERATE);
   \       0x2C   0xF05F 0x6030      MOVS     R0,#+184549376
   \       0x30   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF8CA 0x0004      STR      R0,[R10, #+4]
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF8CA 0x0008      STR      R0,[R10, #+8]
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xF8CA 0x001C      STR      R0,[R10, #+28]
    765            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \       0x46   0xAB17             ADD      R3,SP,#+92
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable8_20
   \       0x4C   0xE890 0x0086      LDM      R0,{R1,R2,R7}
   \       0x50   0xE883 0x0086      STM      R3,{R1,R2,R7}
    766            SE_DataTransfer_t userid = SE_DATATRANSFER_DEFAULT(
    767              (void*)ecjpake_id[ctx->role], strlen(ecjpake_id[ctx->role]));
   \       0x54   0xAB05             ADD      R3,SP,#+20
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable8_21
   \       0x5A   0xE890 0x0086      LDM      R0,{R1,R2,R7}
   \       0x5E   0xE883 0x0086      STM      R3,{R1,R2,R7}
   \       0x62   0x.... 0x....      LDR.W    R7,??DataTable8_4
   \       0x66   0x7A20             LDRB     R0,[R4, #+8]
   \       0x68   0xF857 0x0020      LDR      R0,[R7, R0, LSL #+2]
   \       0x6C   0x9005             STR      R0,[SP, #+20]
   \       0x6E   0x7A20             LDRB     R0,[R4, #+8]
   \       0x70   0xF857 0x0020      LDR      R0,[R7, R0, LSL #+2]
   \       0x74   0x.... 0x....      BL       strlen
   \       0x78   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \       0x7C   0x9007             STR      R0,[SP, #+28]
    768            SE_DataTransfer_t r_out = SE_DATATRANSFER_DEFAULT(ctx->r, 32);
   \       0x7E   0xAB14             ADD      R3,SP,#+80
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable8_22
   \       0x84   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0x88   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0x8C   0xF114 0x0030      ADDS     R0,R4,#+48
   \       0x90   0x9014             STR      R0,[SP, #+80]
    769            SE_DataTransfer_t Xm1_out = SE_DATATRANSFER_DEFAULT(ctx->Xm1, 64);
   \       0x92   0xF10D 0x0C44      ADD      R12,SP,#+68
   \       0x96   0x.... 0x....      LDR.W    R0,??DataTable8_23
   \       0x9A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x9E   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xA2   0xF114 0x0050      ADDS     R0,R4,#+80
   \       0xA6   0x9011             STR      R0,[SP, #+68]
    770            SE_DataTransfer_t zkp1_out = SE_DATATRANSFER_DEFAULT(zkp1, sizeof(zkp1));
   \       0xA8   0xAB0E             ADD      R3,SP,#+56
   \       0xAA   0x.... 0x....      LDR.W    R12,??DataTable8_24
   \       0xAE   0xE89C 0x0007      LDM      R12,{R0-R2}
   \       0xB2   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xB6   0xA832             ADD      R0,SP,#+200
   \       0xB8   0x900E             STR      R0,[SP, #+56]
    771            SE_DataTransfer_t Xm2_out = SE_DATATRANSFER_DEFAULT(ctx->Xm2, 64);
   \       0xBA   0xAB0B             ADD      R3,SP,#+44
   \       0xBC   0x.... 0x....      LDR.W    R0,??DataTable8_25
   \       0xC0   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xC4   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xC8   0xF114 0x0090      ADDS     R0,R4,#+144
   \       0xCC   0x900B             STR      R0,[SP, #+44]
    772            SE_DataTransfer_t zkp2_out = SE_DATATRANSFER_DEFAULT(zkp2, sizeof(zkp2));
   \       0xCE   0xF10D 0x0C20      ADD      R12,SP,#+32
   \       0xD2   0x.... 0x....      LDR.W    R0,??DataTable8_26
   \       0xD6   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xDA   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xDE   0xA81A             ADD      R0,SP,#+104
   \       0xE0   0x9008             STR      R0,[SP, #+32]
    773          
    774            SE_addDataInput(se_cmd, &domain_in);
   \       0xE2   0xA917             ADD      R1,SP,#+92
   \       0xE4   0x4648             MOV      R0,R9
   \       0xE6   0x.... 0x....      BL       SE_addDataInput
    775            SE_addDataInput(se_cmd, &userid);
   \       0xEA   0xA905             ADD      R1,SP,#+20
   \       0xEC   0x4648             MOV      R0,R9
   \       0xEE   0x.... 0x....      BL       SE_addDataInput
    776          
    777            SE_addDataOutput(se_cmd, &r_out);
   \       0xF2   0xA914             ADD      R1,SP,#+80
   \       0xF4   0x4648             MOV      R0,R9
   \       0xF6   0x.... 0x....      BL       SE_addDataOutput
    778            SE_addDataOutput(se_cmd, &Xm1_out);
   \       0xFA   0xA911             ADD      R1,SP,#+68
   \       0xFC   0x4648             MOV      R0,R9
   \       0xFE   0x.... 0x....      BL       SE_addDataOutput
    779            SE_addDataOutput(se_cmd, &zkp1_out);
   \      0x102   0xA90E             ADD      R1,SP,#+56
   \      0x104   0x4648             MOV      R0,R9
   \      0x106   0x.... 0x....      BL       SE_addDataOutput
    780            SE_addDataOutput(se_cmd, &Xm2_out);
   \      0x10A   0xA90B             ADD      R1,SP,#+44
   \      0x10C   0x4648             MOV      R0,R9
   \      0x10E   0x.... 0x....      BL       SE_addDataOutput
    781            SE_addDataOutput(se_cmd, &zkp2_out);
   \      0x112   0xA908             ADD      R1,SP,#+32
   \      0x114   0x4648             MOV      R0,R9
   \      0x116   0x.... 0x....      BL       SE_addDataOutput
    782          
    783            SE_addParameter(se_cmd, ctx->curve_flags);
   \      0x11A   0x6861             LDR      R1,[R4, #+4]
   \      0x11C   0x4648             MOV      R0,R9
   \      0x11E   0x.... 0x....      BL       SE_addParameter
    784            SE_addParameter(se_cmd, strlen(ecjpake_id[ctx->role]));
   \      0x122   0x7A20             LDRB     R0,[R4, #+8]
   \      0x124   0xF857 0x0020      LDR      R0,[R7, R0, LSL #+2]
   \      0x128   0x.... 0x....      BL       strlen
   \      0x12C   0x0001             MOVS     R1,R0
   \      0x12E   0x4648             MOV      R0,R9
   \      0x130   0x.... 0x....      BL       SE_addParameter
    785          
    786            ret = sli_se_execute_and_wait(cmd_ctx);
   \      0x134   0x4650             MOV      R0,R10
   \      0x136   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x13A   0x0007             MOVS     R7,R0
    787          
    788            if (ret == SL_STATUS_OK) {
   \      0x13C   0x2F00             CMP      R7,#+0
   \      0x13E   0xD14C             BNE.N    ??sl_se_ecjpake_write_round_one_3
    789              // To write TLS structures of ECJ-PAKE, we need to write:
    790              // Xm1, zkp1, Xm2 and zkp2.
    791              uint8_t *obuf = buf;
   \      0x140   0x9504             STR      R5,[SP, #+16]
    792              const uint8_t *ibuf = ctx->Xm1;
   \      0x142   0xF114 0x0050      ADDS     R0,R4,#+80
   \      0x146   0x9003             STR      R0,[SP, #+12]
    793              size_t ilen = 64;
   \      0x148   0x2040             MOVS     R0,#+64
   \      0x14A   0x9002             STR      R0,[SP, #+8]
    794          
    795              ret = ecjpake_write_tls_point(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x14C   0x2040             MOVS     R0,#+64
   \      0x14E   0x9001             STR      R0,[SP, #+4]
   \      0x150   0xA802             ADD      R0,SP,#+8
   \      0x152   0x9000             STR      R0,[SP, #+0]
   \      0x154   0xAB03             ADD      R3,SP,#+12
   \      0x156   0x0032             MOVS     R2,R6
   \      0x158   0xA94B             ADD      R1,SP,#+300
   \      0x15A   0xA804             ADD      R0,SP,#+16
   \      0x15C   0x.... 0x....      BL       ecjpake_write_tls_point
   \      0x160   0x4680             MOV      R8,R0
    796              if (ret != SL_STATUS_OK) {
   \      0x162   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x166   0xD001             BEQ.N    ??sl_se_ecjpake_write_round_one_4
    797                return ret;
   \      0x168   0x4640             MOV      R0,R8
   \      0x16A   0xE037             B.N      ??sl_se_ecjpake_write_round_one_2
    798              }
    799          
    800              ibuf = zkp1;
   \                     ??sl_se_ecjpake_write_round_one_4: (+1)
   \      0x16C   0xA832             ADD      R0,SP,#+200
   \      0x16E   0x9003             STR      R0,[SP, #+12]
    801              ilen = 96;
   \      0x170   0x2060             MOVS     R0,#+96
   \      0x172   0x9002             STR      R0,[SP, #+8]
    802              ret = ecjpake_write_tls_zkp(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x174   0x2040             MOVS     R0,#+64
   \      0x176   0x9001             STR      R0,[SP, #+4]
   \      0x178   0xA802             ADD      R0,SP,#+8
   \      0x17A   0x9000             STR      R0,[SP, #+0]
   \      0x17C   0xAB03             ADD      R3,SP,#+12
   \      0x17E   0x0032             MOVS     R2,R6
   \      0x180   0xA94B             ADD      R1,SP,#+300
   \      0x182   0xA804             ADD      R0,SP,#+16
   \      0x184   0x.... 0x....      BL       ecjpake_write_tls_zkp
   \      0x188   0x0007             MOVS     R7,R0
    803              if (ret != SL_STATUS_OK) {
   \      0x18A   0x2F00             CMP      R7,#+0
   \      0x18C   0xD001             BEQ.N    ??sl_se_ecjpake_write_round_one_5
    804                return ret;
   \      0x18E   0x0038             MOVS     R0,R7
   \      0x190   0xE024             B.N      ??sl_se_ecjpake_write_round_one_2
    805              }
    806          
    807              ibuf = ctx->Xm2;
   \                     ??sl_se_ecjpake_write_round_one_5: (+1)
   \      0x192   0xF114 0x0090      ADDS     R0,R4,#+144
   \      0x196   0x9003             STR      R0,[SP, #+12]
    808              ilen = 64;
   \      0x198   0x2040             MOVS     R0,#+64
   \      0x19A   0x9002             STR      R0,[SP, #+8]
    809              ret = ecjpake_write_tls_point(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x19C   0x2040             MOVS     R0,#+64
   \      0x19E   0x9001             STR      R0,[SP, #+4]
   \      0x1A0   0xA802             ADD      R0,SP,#+8
   \      0x1A2   0x9000             STR      R0,[SP, #+0]
   \      0x1A4   0xAB03             ADD      R3,SP,#+12
   \      0x1A6   0x0032             MOVS     R2,R6
   \      0x1A8   0xA94B             ADD      R1,SP,#+300
   \      0x1AA   0xA804             ADD      R0,SP,#+16
   \      0x1AC   0x.... 0x....      BL       ecjpake_write_tls_point
   \      0x1B0   0x4680             MOV      R8,R0
    810              if (ret != SL_STATUS_OK) {
   \      0x1B2   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x1B6   0xD001             BEQ.N    ??sl_se_ecjpake_write_round_one_6
    811                return ret;
   \      0x1B8   0x4640             MOV      R0,R8
   \      0x1BA   0xE00F             B.N      ??sl_se_ecjpake_write_round_one_2
    812              }
    813          
    814              ibuf = zkp2;
   \                     ??sl_se_ecjpake_write_round_one_6: (+1)
   \      0x1BC   0xA81A             ADD      R0,SP,#+104
   \      0x1BE   0x9003             STR      R0,[SP, #+12]
    815              ilen = 96;
   \      0x1C0   0x2060             MOVS     R0,#+96
   \      0x1C2   0x9002             STR      R0,[SP, #+8]
    816              ret = ecjpake_write_tls_zkp(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x1C4   0x2040             MOVS     R0,#+64
   \      0x1C6   0x9001             STR      R0,[SP, #+4]
   \      0x1C8   0xA802             ADD      R0,SP,#+8
   \      0x1CA   0x9000             STR      R0,[SP, #+0]
   \      0x1CC   0xAB03             ADD      R3,SP,#+12
   \      0x1CE   0x0032             MOVS     R2,R6
   \      0x1D0   0xA94B             ADD      R1,SP,#+300
   \      0x1D2   0xA804             ADD      R0,SP,#+16
   \      0x1D4   0x.... 0x....      BL       ecjpake_write_tls_zkp
   \      0x1D8   0x0007             MOVS     R7,R0
    817            }
    818            return ret;
   \                     ??sl_se_ecjpake_write_round_one_3: (+1)
   \      0x1DA   0x0038             MOVS     R0,R7
   \                     ??sl_se_ecjpake_write_round_one_2: (+1)
   \      0x1DC   0xB04C             ADD      SP,SP,#+304
   \      0x1DE   0xE8BD 0x87F0      POP      {R4-R10,PC}
    819          }

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .rodata, align 4
   \                     ?_23:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_24:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_25:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_26:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060

   \                                 In section .rodata, align 4
   \                     ?_27:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_28:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060
    820          
    821          /***************************************************************************//**
    822           * Generate and write the second round message.
    823           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    824          sl_status_t sl_se_ecjpake_write_round_two(sl_se_ecjpake_context_t *ctx,
    825                                                    unsigned char *buf,
    826                                                    size_t len,
    827                                                    size_t *olen)
    828          {
   \                     sl_se_ecjpake_write_round_two: (+1)
   \        0x0   0xE92D 0x47F6      PUSH     {R1,R2,R4-R10,LR}
   \        0x4   0xB0C8             SUB      SP,SP,#+288
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000F             MOVS     R7,R1
   \        0xA   0x001D             MOVS     R5,R3
    829            sl_status_t ret = SL_STATUS_OK;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
    830          
    831            if (ctx == NULL || buf == NULL || olen == NULL) {
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD003             BEQ.N    ??sl_se_ecjpake_write_round_two_0
   \       0x14   0x2F00             CMP      R7,#+0
   \       0x16   0xD001             BEQ.N    ??sl_se_ecjpake_write_round_two_0
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD101             BNE.N    ??sl_se_ecjpake_write_round_two_1
    832              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_write_round_two_0: (+1)
   \       0x1C   0x2021             MOVS     R0,#+33
   \       0x1E   0xE0F1             B.N      ??sl_se_ecjpake_write_round_two_2
    833            }
    834            sl_se_command_context_t *cmd_ctx = ctx->cmd_ctx;
   \                     ??sl_se_ecjpake_write_round_two_1: (+1)
   \       0x20   0xF8D4 0xA000      LDR      R10,[R4, #+0]
    835            SE_Command_t *se_cmd = &ctx->cmd_ctx->command;
   \       0x24   0xF8D4 0x9000      LDR      R9,[R4, #+0]
    836          
    837            *olen = 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6028             STR      R0,[R5, #+0]
    838          
    839            uint8_t zkpA[32 + 64];
    840            uint8_t xA[64];
    841          
    842            // SE command structures.
    843            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_JPAKE_R2_GENERATE);
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable8_27
   \       0x30   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF8CA 0x0004      STR      R0,[R10, #+4]
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF8CA 0x0008      STR      R0,[R10, #+8]
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xF8CA 0x001C      STR      R0,[R10, #+28]
    844            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \       0x46   0xAE1D             ADD      R6,SP,#+116
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable8_28
   \       0x4C   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x50   0xE886 0x000E      STM      R6,{R1-R3}
    845            SE_DataTransfer_t pwd_in = SE_DATATRANSFER_DEFAULT(ctx->pwd, ctx->pwd_len);
   \       0x54   0xAB08             ADD      R3,SP,#+32
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable8_29
   \       0x5A   0xE890 0x0046      LDM      R0,{R1,R2,R6}
   \       0x5E   0xE883 0x0046      STM      R3,{R1,R2,R6}
   \       0x62   0xF114 0x0009      ADDS     R0,R4,#+9
   \       0x66   0x9008             STR      R0,[SP, #+32]
   \       0x68   0x6AE0             LDR      R0,[R4, #+44]
   \       0x6A   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \       0x6E   0x900A             STR      R0,[SP, #+40]
    846            SE_DataTransfer_t userid = SE_DATATRANSFER_DEFAULT(
    847              (void*)ecjpake_id[ctx->role], strlen(ecjpake_id[ctx->role]));
   \       0x70   0xAB05             ADD      R3,SP,#+20
   \       0x72   0x.... 0x....      LDR.W    R0,??DataTable8_30
   \       0x76   0xE890 0x0046      LDM      R0,{R1,R2,R6}
   \       0x7A   0xE883 0x0046      STM      R3,{R1,R2,R6}
   \       0x7E   0x.... 0x....      LDR.W    R6,??DataTable8_4
   \       0x82   0x7A20             LDRB     R0,[R4, #+8]
   \       0x84   0xF856 0x0020      LDR      R0,[R6, R0, LSL #+2]
   \       0x88   0x9005             STR      R0,[SP, #+20]
   \       0x8A   0x7A20             LDRB     R0,[R4, #+8]
   \       0x8C   0xF856 0x0020      LDR      R0,[R6, R0, LSL #+2]
   \       0x90   0x.... 0x....      BL       strlen
   \       0x94   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \       0x98   0x9007             STR      R0,[SP, #+28]
    848            SE_DataTransfer_t r_in = SE_DATATRANSFER_DEFAULT(ctx->r, 32);
   \       0x9A   0xF10D 0x0C68      ADD      R12,SP,#+104
   \       0x9E   0x.... 0x....      LDR.W    R0,??DataTable8_31
   \       0xA2   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xA6   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xAA   0xF114 0x0030      ADDS     R0,R4,#+48
   \       0xAE   0x901A             STR      R0,[SP, #+104]
    849            SE_DataTransfer_t Xm1_in = SE_DATATRANSFER_DEFAULT(ctx->Xm1, 64);
   \       0xB0   0xAB17             ADD      R3,SP,#+92
   \       0xB2   0x.... 0x....      LDR.W    R0,??DataTable8_32
   \       0xB6   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xBA   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xBE   0xF114 0x0050      ADDS     R0,R4,#+80
   \       0xC2   0x9017             STR      R0,[SP, #+92]
    850            SE_DataTransfer_t Xp1_in = SE_DATATRANSFER_DEFAULT(ctx->Xp1, 64);
   \       0xC4   0xF10D 0x0C50      ADD      R12,SP,#+80
   \       0xC8   0x.... 0x....      LDR.W    R0,??DataTable8_33
   \       0xCC   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xD0   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xD4   0xF114 0x00D0      ADDS     R0,R4,#+208
   \       0xD8   0x9014             STR      R0,[SP, #+80]
    851            SE_DataTransfer_t Xp2_in = SE_DATATRANSFER_DEFAULT(ctx->Xp2, 64);
   \       0xDA   0xAB11             ADD      R3,SP,#+68
   \       0xDC   0x.... 0x....      LDR.W    R0,??DataTable8_34
   \       0xE0   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xE4   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xE8   0xF514 0x7088      ADDS     R0,R4,#+272
   \       0xEC   0x9011             STR      R0,[SP, #+68]
    852            SE_DataTransfer_t xA_out = SE_DATATRANSFER_DEFAULT(xA, sizeof(xA));
   \       0xEE   0xF10D 0x0C38      ADD      R12,SP,#+56
   \       0xF2   0x.... 0x....      LDR.W    R0,??DataTable8_35
   \       0xF6   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xFA   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xFE   0xA820             ADD      R0,SP,#+128
   \      0x100   0x900E             STR      R0,[SP, #+56]
    853            SE_DataTransfer_t zkpA_out = SE_DATATRANSFER_DEFAULT(zkpA, sizeof(zkpA));
   \      0x102   0xF10D 0x0C2C      ADD      R12,SP,#+44
   \      0x106   0x.... 0x....      LDR.W    R0,??DataTable8_36
   \      0x10A   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x10E   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x112   0xA830             ADD      R0,SP,#+192
   \      0x114   0x900B             STR      R0,[SP, #+44]
    854          
    855            SE_addDataInput(se_cmd, &domain_in);
   \      0x116   0xA91D             ADD      R1,SP,#+116
   \      0x118   0x4648             MOV      R0,R9
   \      0x11A   0x.... 0x....      BL       SE_addDataInput
    856            SE_addDataInput(se_cmd, &pwd_in);
   \      0x11E   0xA908             ADD      R1,SP,#+32
   \      0x120   0x4648             MOV      R0,R9
   \      0x122   0x.... 0x....      BL       SE_addDataInput
    857            SE_addDataInput(se_cmd, &userid);
   \      0x126   0xA905             ADD      R1,SP,#+20
   \      0x128   0x4648             MOV      R0,R9
   \      0x12A   0x.... 0x....      BL       SE_addDataInput
    858            SE_addDataInput(se_cmd, &r_in);
   \      0x12E   0xA91A             ADD      R1,SP,#+104
   \      0x130   0x4648             MOV      R0,R9
   \      0x132   0x.... 0x....      BL       SE_addDataInput
    859            SE_addDataInput(se_cmd, &Xm1_in);
   \      0x136   0xA917             ADD      R1,SP,#+92
   \      0x138   0x4648             MOV      R0,R9
   \      0x13A   0x.... 0x....      BL       SE_addDataInput
    860            SE_addDataInput(se_cmd, &Xp1_in);
   \      0x13E   0xA914             ADD      R1,SP,#+80
   \      0x140   0x4648             MOV      R0,R9
   \      0x142   0x.... 0x....      BL       SE_addDataInput
    861            SE_addDataInput(se_cmd, &Xp2_in);
   \      0x146   0xA911             ADD      R1,SP,#+68
   \      0x148   0x4648             MOV      R0,R9
   \      0x14A   0x.... 0x....      BL       SE_addDataInput
    862          
    863            SE_addDataOutput(se_cmd, &xA_out);
   \      0x14E   0xA90E             ADD      R1,SP,#+56
   \      0x150   0x4648             MOV      R0,R9
   \      0x152   0x.... 0x....      BL       SE_addDataOutput
    864            SE_addDataOutput(se_cmd, &zkpA_out);
   \      0x156   0xA90B             ADD      R1,SP,#+44
   \      0x158   0x4648             MOV      R0,R9
   \      0x15A   0x.... 0x....      BL       SE_addDataOutput
    865          
    866            SE_addParameter(se_cmd, ctx->curve_flags);
   \      0x15E   0x6861             LDR      R1,[R4, #+4]
   \      0x160   0x4648             MOV      R0,R9
   \      0x162   0x.... 0x....      BL       SE_addParameter
    867            SE_addParameter(se_cmd, ctx->pwd_len);
   \      0x166   0x6AE1             LDR      R1,[R4, #+44]
   \      0x168   0x4648             MOV      R0,R9
   \      0x16A   0x.... 0x....      BL       SE_addParameter
    868            SE_addParameter(se_cmd, strlen(ecjpake_id[ctx->role]));
   \      0x16E   0x7A20             LDRB     R0,[R4, #+8]
   \      0x170   0xF856 0x0020      LDR      R0,[R6, R0, LSL #+2]
   \      0x174   0x.... 0x....      BL       strlen
   \      0x178   0x0001             MOVS     R1,R0
   \      0x17A   0x4648             MOV      R0,R9
   \      0x17C   0x.... 0x....      BL       SE_addParameter
    869          
    870            ret = sli_se_execute_and_wait(cmd_ctx);
   \      0x180   0x4650             MOV      R0,R10
   \      0x182   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x186   0x0006             MOVS     R6,R0
    871          
    872            if (ret == SLI_SE_RESPONSE_OK) {
   \      0x188   0x2E00             CMP      R6,#+0
   \      0x18A   0xD13A             BNE.N    ??sl_se_ecjpake_write_round_two_3
    873              // If we are the server, we need to write out the ECParams.
    874              if (ctx->role == SL_SE_ECJPAKE_SERVER) {
   \      0x18C   0x7A20             LDRB     R0,[R4, #+8]
   \      0x18E   0x2801             CMP      R0,#+1
   \      0x190   0xD113             BNE.N    ??sl_se_ecjpake_write_round_two_4
    875                if (len < 3 + 66 + 66 + 33) {
   \      0x192   0x9849             LDR      R0,[SP, #+292]
   \      0x194   0x28A8             CMP      R0,#+168
   \      0x196   0xD201             BCS.N    ??sl_se_ecjpake_write_round_two_5
    876                  return SL_STATUS_WOULD_OVERFLOW;
   \      0x198   0x201D             MOVS     R0,#+29
   \      0x19A   0xE033             B.N      ??sl_se_ecjpake_write_round_two_2
    877                }
    878                // First byte is curve_type, always named_curve.
    879                *(buf++) = SL_SE_ECP_TLS_NAMED_CURVE;
   \                     ??sl_se_ecjpake_write_round_two_5: (+1)
   \      0x19C   0x2003             MOVS     R0,#+3
   \      0x19E   0x7038             STRB     R0,[R7, #+0]
   \      0x1A0   0x1C79             ADDS     R1,R7,#+1
    880          
    881                // Next two bytes are the namedcurve value, we only support one.
    882                *(buf++) = SL_SE_TLSID_ECC_P256 >> 8;
   \      0x1A2   0x2000             MOVS     R0,#+0
   \      0x1A4   0x7008             STRB     R0,[R1, #+0]
   \      0x1A6   0x1C49             ADDS     R1,R1,#+1
    883                *(buf++) = SL_SE_TLSID_ECC_P256 & 0xFF;
   \      0x1A8   0x2017             MOVS     R0,#+23
   \      0x1AA   0x7008             STRB     R0,[R1, #+0]
   \      0x1AC   0x1C4F             ADDS     R7,R1,#+1
    884          
    885                *olen += 3;
   \      0x1AE   0x6828             LDR      R0,[R5, #+0]
   \      0x1B0   0x1CC0             ADDS     R0,R0,#+3
   \      0x1B2   0x6028             STR      R0,[R5, #+0]
    886                len -= 3;
   \      0x1B4   0x9849             LDR      R0,[SP, #+292]
   \      0x1B6   0x1EC0             SUBS     R0,R0,#+3
   \      0x1B8   0x9049             STR      R0,[SP, #+292]
    887              }
    888          
    889              // To write TLS structures of ECJ-PAKE, we need to write:
    890              // xA in uncompressed form and zkpA in uncompressed form
    891              uint8_t *obuf = buf;
   \                     ??sl_se_ecjpake_write_round_two_4: (+1)
   \      0x1BA   0x9704             STR      R7,[SP, #+16]
    892              const uint8_t *ibuf = xA;
   \      0x1BC   0xA820             ADD      R0,SP,#+128
   \      0x1BE   0x9003             STR      R0,[SP, #+12]
    893              size_t ilen = 64;
   \      0x1C0   0x2040             MOVS     R0,#+64
   \      0x1C2   0x9002             STR      R0,[SP, #+8]
    894          
    895              ret = ecjpake_write_tls_point(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x1C4   0x2040             MOVS     R0,#+64
   \      0x1C6   0x9001             STR      R0,[SP, #+4]
   \      0x1C8   0xA802             ADD      R0,SP,#+8
   \      0x1CA   0x9000             STR      R0,[SP, #+0]
   \      0x1CC   0xAB03             ADD      R3,SP,#+12
   \      0x1CE   0x002A             MOVS     R2,R5
   \      0x1D0   0xA949             ADD      R1,SP,#+292
   \      0x1D2   0xA804             ADD      R0,SP,#+16
   \      0x1D4   0x.... 0x....      BL       ecjpake_write_tls_point
   \      0x1D8   0x4680             MOV      R8,R0
    896              if (ret != SL_STATUS_OK) {
   \      0x1DA   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x1DE   0xD001             BEQ.N    ??sl_se_ecjpake_write_round_two_6
    897                return ret;
   \      0x1E0   0x4640             MOV      R0,R8
   \      0x1E2   0xE00F             B.N      ??sl_se_ecjpake_write_round_two_2
    898              }
    899          
    900              ibuf = zkpA;
   \                     ??sl_se_ecjpake_write_round_two_6: (+1)
   \      0x1E4   0xA830             ADD      R0,SP,#+192
   \      0x1E6   0x9003             STR      R0,[SP, #+12]
    901              ilen = 96;
   \      0x1E8   0x2060             MOVS     R0,#+96
   \      0x1EA   0x9002             STR      R0,[SP, #+8]
    902              ret = ecjpake_write_tls_zkp(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x1EC   0x2040             MOVS     R0,#+64
   \      0x1EE   0x9001             STR      R0,[SP, #+4]
   \      0x1F0   0xA802             ADD      R0,SP,#+8
   \      0x1F2   0x9000             STR      R0,[SP, #+0]
   \      0x1F4   0xAB03             ADD      R3,SP,#+12
   \      0x1F6   0x002A             MOVS     R2,R5
   \      0x1F8   0xA949             ADD      R1,SP,#+292
   \      0x1FA   0xA804             ADD      R0,SP,#+16
   \      0x1FC   0x.... 0x....      BL       ecjpake_write_tls_zkp
   \      0x200   0x0006             MOVS     R6,R0
    903            }
    904          
    905            return ret;
   \                     ??sl_se_ecjpake_write_round_two_3: (+1)
   \      0x202   0x0030             MOVS     R0,R6
   \                     ??sl_se_ecjpake_write_round_two_2: (+1)
   \      0x204   0xB04A             ADD      SP,SP,#+296
   \      0x206   0xE8BD 0x87F0      POP      {R4-R10,PC}
    906          }

   \                                 In section .rodata, align 4
   \                     ?_29:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .rodata, align 4
   \                     ?_30:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_31:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_32:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .rodata, align 4
   \                     ?_33:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_34:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_35:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_36:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .rodata, align 4
   \                     ?_37:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060
    907          
    908          // -------------------------------
    909          // Key derivation functions
    910          
    911          #if (defined(_SILICON_LABS_SECURITY_FEATURE) \
    912            && (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT))
    913          /***************************************************************************//**
    914           * HKDF key derivation.
    915           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    916          sl_status_t sl_se_derive_key_hkdf(sl_se_command_context_t *cmd_ctx,
    917                                            const sl_se_key_descriptor_t *in_key,
    918                                            sl_se_hash_type_t hash,
    919                                            const unsigned char *salt,
    920                                            size_t salt_len,
    921                                            const unsigned char *info,
    922                                            size_t info_len,
    923                                            sl_se_key_descriptor_t *out_key)
    924          {
   \                     sl_se_derive_key_hkdf: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x9E20             LDR      R6,[SP, #+128]
   \        0xC   0x9F22             LDR      R7,[SP, #+136]
   \        0xE   0xF8DD 0x808C      LDR      R8,[SP, #+140]
    925            uint32_t hash_mask;
    926            sl_status_t status = SL_STATUS_OK;
   \       0x12   0xF05F 0x0900      MOVS     R9,#+0
    927          
    928            if ((cmd_ctx == NULL) || (in_key == NULL) || (out_key == NULL)) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD004             BEQ.N    ??sl_se_derive_key_hkdf_0
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD002             BEQ.N    ??sl_se_derive_key_hkdf_0
   \       0x1E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x22   0xD101             BNE.N    ??sl_se_derive_key_hkdf_1
    929              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_derive_key_hkdf_0: (+1)
   \       0x24   0x2021             MOVS     R0,#+33
   \       0x26   0xE0B4             B.N      ??sl_se_derive_key_hkdf_2
    930            }
    931            if ((salt == NULL) && (salt_len != 0U)) {
   \                     ??sl_se_derive_key_hkdf_1: (+1)
   \       0x28   0x9816             LDR      R0,[SP, #+88]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD103             BNE.N    ??sl_se_derive_key_hkdf_3
   \       0x2E   0x2E00             CMP      R6,#+0
   \       0x30   0xD001             BEQ.N    ??sl_se_derive_key_hkdf_3
    932              return SL_STATUS_INVALID_PARAMETER;
   \       0x32   0x2021             MOVS     R0,#+33
   \       0x34   0xE0AD             B.N      ??sl_se_derive_key_hkdf_2
    933            }
    934            if ((info == NULL) && (info_len != 0U)) {
   \                     ??sl_se_derive_key_hkdf_3: (+1)
   \       0x36   0x9821             LDR      R0,[SP, #+132]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD103             BNE.N    ??sl_se_derive_key_hkdf_4
   \       0x3C   0x2F00             CMP      R7,#+0
   \       0x3E   0xD001             BEQ.N    ??sl_se_derive_key_hkdf_4
    935              return SL_STATUS_INVALID_PARAMETER;
   \       0x40   0x2021             MOVS     R0,#+33
   \       0x42   0xE0A6             B.N      ??sl_se_derive_key_hkdf_2
    936            }
    937          
    938            switch (hash) {
   \                     ??sl_se_derive_key_hkdf_4: (+1)
   \       0x44   0xF89D 0x0054      LDRB     R0,[SP, #+84]
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD007             BEQ.N    ??sl_se_derive_key_hkdf_5
   \       0x4C   0xD315             BCC.N    ??sl_se_derive_key_hkdf_6
   \       0x4E   0x2803             CMP      R0,#+3
   \       0x50   0xD00A             BEQ.N    ??sl_se_derive_key_hkdf_7
   \       0x52   0xD306             BCC.N    ??sl_se_derive_key_hkdf_8
   \       0x54   0x2805             CMP      R0,#+5
   \       0x56   0xD00D             BEQ.N    ??sl_se_derive_key_hkdf_9
   \       0x58   0xD309             BCC.N    ??sl_se_derive_key_hkdf_10
   \       0x5A   0xE00E             B.N      ??sl_se_derive_key_hkdf_6
    939              case SL_SE_HASH_SHA1:
    940                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA1;
   \                     ??sl_se_derive_key_hkdf_5: (+1)
   \       0x5C   0xF44F 0x7A00      MOV      R10,#+512
    941                break;
   \       0x60   0xE00D             B.N      ??sl_se_derive_key_hkdf_11
    942          
    943              case SL_SE_HASH_SHA224:
    944                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA224;
   \                     ??sl_se_derive_key_hkdf_8: (+1)
   \       0x62   0xF44F 0x7A40      MOV      R10,#+768
    945                break;
   \       0x66   0xE00A             B.N      ??sl_se_derive_key_hkdf_11
    946          
    947              case SL_SE_HASH_SHA256:
    948                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA256;
   \                     ??sl_se_derive_key_hkdf_7: (+1)
   \       0x68   0xF44F 0x6A80      MOV      R10,#+1024
    949                break;
   \       0x6C   0xE007             B.N      ??sl_se_derive_key_hkdf_11
    950          
    951              case SL_SE_HASH_SHA384:
    952                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA384;
   \                     ??sl_se_derive_key_hkdf_10: (+1)
   \       0x6E   0xF44F 0x6AA0      MOV      R10,#+1280
    953                break;
   \       0x72   0xE004             B.N      ??sl_se_derive_key_hkdf_11
    954          
    955              case SL_SE_HASH_SHA512:
    956                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA512;
   \                     ??sl_se_derive_key_hkdf_9: (+1)
   \       0x74   0xF44F 0x6AC0      MOV      R10,#+1536
    957                break;
   \       0x78   0xE001             B.N      ??sl_se_derive_key_hkdf_11
    958          
    959              default:
    960                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_derive_key_hkdf_6: (+1)
   \       0x7A   0x2021             MOVS     R0,#+33
   \       0x7C   0xE089             B.N      ??sl_se_derive_key_hkdf_2
    961                break;
    962            }
    963          
    964            // SE command structures.
    965            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_derive_key_hkdf_11: (+1)
   \       0x7E   0x9400             STR      R4,[SP, #+0]
    966            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DERIVE_KEY_HKDF | hash_mask);
   \       0x80   0x....             LDR.N    R0,??DataTable8_37
   \       0x82   0xEA50 0x000A      ORRS     R0,R0,R10
   \       0x86   0x6020             STR      R0,[R4, #+0]
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0x6060             STR      R0,[R4, #+4]
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x60A0             STR      R0,[R4, #+8]
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x61E0             STR      R0,[R4, #+28]
    967          
    968            sli_add_key_parameters(cmd_ctx, in_key, status);
   \       0x94   0xA902             ADD      R1,SP,#+8
   \       0x96   0x0028             MOVS     R0,R5
   \       0x98   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x9C   0x4683             MOV      R11,R0
   \       0x9E   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xA2   0xD001             BEQ.N    ??sl_se_derive_key_hkdf_12
   \       0xA4   0x4658             MOV      R0,R11
   \       0xA6   0xE074             B.N      ??sl_se_derive_key_hkdf_2
   \                     ??sl_se_derive_key_hkdf_12: (+1)
   \       0xA8   0x9902             LDR      R1,[SP, #+8]
   \       0xAA   0x0020             MOVS     R0,R4
   \       0xAC   0x.... 0x....      BL       SE_addParameter
    969            SE_addParameter(se_cmd, salt_len);
   \       0xB0   0x0031             MOVS     R1,R6
   \       0xB2   0x9800             LDR      R0,[SP, #+0]
   \       0xB4   0x.... 0x....      BL       SE_addParameter
    970            SE_addParameter(se_cmd, info_len);
   \       0xB8   0x0039             MOVS     R1,R7
   \       0xBA   0x9800             LDR      R0,[SP, #+0]
   \       0xBC   0x.... 0x....      BL       SE_addParameter
    971            sli_add_key_parameters(cmd_ctx, out_key, status);
   \       0xC0   0xA901             ADD      R1,SP,#+4
   \       0xC2   0x4640             MOV      R0,R8
   \       0xC4   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xC8   0x4681             MOV      R9,R0
   \       0xCA   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xCE   0xD001             BEQ.N    ??sl_se_derive_key_hkdf_13
   \       0xD0   0x4648             MOV      R0,R9
   \       0xD2   0xE05E             B.N      ??sl_se_derive_key_hkdf_2
   \                     ??sl_se_derive_key_hkdf_13: (+1)
   \       0xD4   0x9901             LDR      R1,[SP, #+4]
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x.... 0x....      BL       SE_addParameter
    972          
    973            sli_add_key_metadata(cmd_ctx, in_key, status);
   \       0xDC   0xA912             ADD      R1,SP,#+72
   \       0xDE   0x0028             MOVS     R0,R5
   \       0xE0   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xE4   0x4683             MOV      R11,R0
   \       0xE6   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xEA   0xD001             BEQ.N    ??sl_se_derive_key_hkdf_14
   \       0xEC   0x4658             MOV      R0,R11
   \       0xEE   0xE050             B.N      ??sl_se_derive_key_hkdf_2
   \                     ??sl_se_derive_key_hkdf_14: (+1)
   \       0xF0   0xA912             ADD      R1,SP,#+72
   \       0xF2   0x0020             MOVS     R0,R4
   \       0xF4   0x.... 0x....      BL       SE_addDataInput
    974            sli_add_key_input(cmd_ctx, in_key, status);
   \       0xF8   0xA90F             ADD      R1,SP,#+60
   \       0xFA   0x0028             MOVS     R0,R5
   \       0xFC   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x100   0x4681             MOV      R9,R0
   \      0x102   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x106   0xD001             BEQ.N    ??sl_se_derive_key_hkdf_15
   \      0x108   0x4648             MOV      R0,R9
   \      0x10A   0xE042             B.N      ??sl_se_derive_key_hkdf_2
   \                     ??sl_se_derive_key_hkdf_15: (+1)
   \      0x10C   0xA90F             ADD      R1,SP,#+60
   \      0x10E   0x0020             MOVS     R0,R4
   \      0x110   0x.... 0x....      BL       SE_addDataInput
    975          
    976            sli_add_key_metadata_custom(cmd_ctx, auth_data, out_key, status);
   \      0x114   0xA90C             ADD      R1,SP,#+48
   \      0x116   0x4640             MOV      R0,R8
   \      0x118   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x11C   0x4683             MOV      R11,R0
   \      0x11E   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x122   0xD001             BEQ.N    ??sl_se_derive_key_hkdf_16
   \      0x124   0x4658             MOV      R0,R11
   \      0x126   0xE034             B.N      ??sl_se_derive_key_hkdf_2
   \                     ??sl_se_derive_key_hkdf_16: (+1)
   \      0x128   0xA90C             ADD      R1,SP,#+48
   \      0x12A   0x0020             MOVS     R0,R4
   \      0x12C   0x.... 0x....      BL       SE_addDataInput
    977          
    978            SE_DataTransfer_t salt_in = SE_DATATRANSFER_DEFAULT(salt, salt_len);
   \      0x130   0xF10D 0x0C18      ADD      R12,SP,#+24
   \      0x134   0x....             LDR.N    R0,??DataTable8_38
   \      0x136   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x13A   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x13E   0x9816             LDR      R0,[SP, #+88]
   \      0x140   0x9006             STR      R0,[SP, #+24]
   \      0x142   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \      0x146   0x9008             STR      R0,[SP, #+32]
    979            SE_addDataInput(se_cmd, &salt_in);
   \      0x148   0xA906             ADD      R1,SP,#+24
   \      0x14A   0x9800             LDR      R0,[SP, #+0]
   \      0x14C   0x.... 0x....      BL       SE_addDataInput
    980          
    981            SE_DataTransfer_t info_in = SE_DATATRANSFER_DEFAULT(info, info_len);
   \      0x150   0xF10D 0x0C0C      ADD      R12,SP,#+12
   \      0x154   0x....             LDR.N    R0,??DataTable8_39
   \      0x156   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x15A   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x15E   0x9821             LDR      R0,[SP, #+132]
   \      0x160   0x9003             STR      R0,[SP, #+12]
   \      0x162   0xF057 0x5000      ORRS     R0,R7,#0x20000000
   \      0x166   0x9005             STR      R0,[SP, #+20]
    982            SE_addDataInput(se_cmd, &info_in);
   \      0x168   0xA903             ADD      R1,SP,#+12
   \      0x16A   0x9800             LDR      R0,[SP, #+0]
   \      0x16C   0x.... 0x....      BL       SE_addDataInput
    983          
    984            sli_add_key_output(cmd_ctx, out_key, status);
   \      0x170   0xA909             ADD      R1,SP,#+36
   \      0x172   0x4640             MOV      R0,R8
   \      0x174   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x178   0x4681             MOV      R9,R0
   \      0x17A   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x17E   0xD001             BEQ.N    ??sl_se_derive_key_hkdf_17
   \      0x180   0x4648             MOV      R0,R9
   \      0x182   0xE006             B.N      ??sl_se_derive_key_hkdf_2
   \                     ??sl_se_derive_key_hkdf_17: (+1)
   \      0x184   0xA909             ADD      R1,SP,#+36
   \      0x186   0x0020             MOVS     R0,R4
   \      0x188   0x.... 0x....      BL       SE_addDataOutput
    985          
    986            status = sli_se_execute_and_wait(cmd_ctx);
   \      0x18C   0x0020             MOVS     R0,R4
   \      0x18E   0x.... 0x....      BL       sli_se_execute_and_wait
    987          
    988            return status;
   \                     ??sl_se_derive_key_hkdf_2: (+1)
   \      0x192   0xB017             ADD      SP,SP,#+92
   \      0x194   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    989          }

   \                                 In section .rodata, align 4
   \                     ?_38:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_39:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    990          #endif // _SILICON_LABS_SECURITY_FEATURE_VAULT
    991          
    992          #if (defined(_SILICON_LABS_SECURITY_FEATURE) \
    993            && (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT))
    994          /***************************************************************************//**
    995           * PBKDF2 key derivation.
    996           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    997          sl_status_t sl_se_derive_key_pbkdf2(sl_se_command_context_t *cmd_ctx,
    998                                              const sl_se_key_descriptor_t *in_key,
    999                                              sl_se_pbkdf2_prf_type_t prf,
   1000                                              const unsigned char *salt,
   1001                                              size_t salt_len,
   1002                                              uint32_t iterations,
   1003                                              sl_se_key_descriptor_t *out_key)
   1004          {
   \                     sl_se_derive_key_pbkdf2: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x9E1E             LDR      R6,[SP, #+120]
   \        0xC   0x9F1F             LDR      R7,[SP, #+124]
   \        0xE   0xF8DD 0x8080      LDR      R8,[SP, #+128]
   1005            sl_status_t status = SL_STATUS_OK;
   \       0x12   0xF05F 0x0900      MOVS     R9,#+0
   1006            uint32_t command_word = 0U;
   \       0x16   0x2100             MOVS     R1,#+0
   1007          
   1008            if ((cmd_ctx == NULL) || (in_key == NULL) || (out_key == NULL)) {
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD004             BEQ.N    ??sl_se_derive_key_pbkdf2_0
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD002             BEQ.N    ??sl_se_derive_key_pbkdf2_0
   \       0x20   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x24   0xD101             BNE.N    ??sl_se_derive_key_pbkdf2_1
   1009              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_derive_key_pbkdf2_0: (+1)
   \       0x26   0x2021             MOVS     R0,#+33
   \       0x28   0xE0A7             B.N      ??sl_se_derive_key_pbkdf2_2
   1010            }
   1011            if ((salt == NULL) && (salt_len != 0U)) {
   \                     ??sl_se_derive_key_pbkdf2_1: (+1)
   \       0x2A   0x9814             LDR      R0,[SP, #+80]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD103             BNE.N    ??sl_se_derive_key_pbkdf2_3
   \       0x30   0x2E00             CMP      R6,#+0
   \       0x32   0xD001             BEQ.N    ??sl_se_derive_key_pbkdf2_3
   1012              return SL_STATUS_INVALID_PARAMETER;
   \       0x34   0x2021             MOVS     R0,#+33
   \       0x36   0xE0A0             B.N      ??sl_se_derive_key_pbkdf2_2
   1013            }
   1014            // Too many iterations will trigger SE watchdog.
   1015            if ((iterations == 0U) || (iterations > 16384U)) {
   \                     ??sl_se_derive_key_pbkdf2_3: (+1)
   \       0x38   0x2F00             CMP      R7,#+0
   \       0x3A   0xD003             BEQ.N    ??sl_se_derive_key_pbkdf2_4
   \       0x3C   0xF244 0x0001      MOVW     R0,#+16385
   \       0x40   0x4287             CMP      R7,R0
   \       0x42   0xD301             BCC.N    ??sl_se_derive_key_pbkdf2_5
   1016              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_derive_key_pbkdf2_4: (+1)
   \       0x44   0x2021             MOVS     R0,#+33
   \       0x46   0xE098             B.N      ??sl_se_derive_key_pbkdf2_2
   1017            }
   1018          
   1019            switch (prf) {
   \                     ??sl_se_derive_key_pbkdf2_5: (+1)
   \       0x48   0xF89D 0x004C      LDRB     R0,[SP, #+76]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD017             BEQ.N    ??sl_se_derive_key_pbkdf2_6
   \       0x50   0x2802             CMP      R0,#+2
   \       0x52   0xD009             BEQ.N    ??sl_se_derive_key_pbkdf2_7
   \       0x54   0xD305             BCC.N    ??sl_se_derive_key_pbkdf2_8
   \       0x56   0x2804             CMP      R0,#+4
   \       0x58   0xD00C             BEQ.N    ??sl_se_derive_key_pbkdf2_9
   \       0x5A   0xD308             BCC.N    ??sl_se_derive_key_pbkdf2_10
   \       0x5C   0x2805             CMP      R0,#+5
   \       0x5E   0xD00C             BEQ.N    ??sl_se_derive_key_pbkdf2_11
   \       0x60   0xE011             B.N      ??sl_se_derive_key_pbkdf2_12
   1020              case SL_SE_PRF_HMAC_SHA1:
   1021                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1022                               | SLI_SE_COMMAND_OPTION_HASH_SHA1;
   \                     ??sl_se_derive_key_pbkdf2_8: (+1)
   \       0x62   0xF05F 0x3A02      MOVS     R10,#+33686018
   1023                break;
   \       0x66   0xE010             B.N      ??sl_se_derive_key_pbkdf2_13
   1024          
   1025              case SL_SE_PRF_HMAC_SHA224:
   1026                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1027                               | SLI_SE_COMMAND_OPTION_HASH_SHA224;
   \                     ??sl_se_derive_key_pbkdf2_7: (+1)
   \       0x68   0x.... 0x....      LDR.W    R10,??DataTable8_40
   1028                break;
   \       0x6C   0xE00D             B.N      ??sl_se_derive_key_pbkdf2_13
   1029          
   1030              case SL_SE_PRF_HMAC_SHA256:
   1031                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1032                               | SLI_SE_COMMAND_OPTION_HASH_SHA256;
   \                     ??sl_se_derive_key_pbkdf2_10: (+1)
   \       0x6E   0x.... 0x....      LDR.W    R10,??DataTable8_41
   1033                break;
   \       0x72   0xE00A             B.N      ??sl_se_derive_key_pbkdf2_13
   1034          
   1035              case SL_SE_PRF_HMAC_SHA384:
   1036                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1037                               | SLI_SE_COMMAND_OPTION_HASH_SHA384;
   \                     ??sl_se_derive_key_pbkdf2_9: (+1)
   \       0x74   0x.... 0x....      LDR.W    R10,??DataTable8_42
   1038                break;
   \       0x78   0xE007             B.N      ??sl_se_derive_key_pbkdf2_13
   1039          
   1040              case SL_SE_PRF_HMAC_SHA512:
   1041                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1042                               | SLI_SE_COMMAND_OPTION_HASH_SHA512;
   \                     ??sl_se_derive_key_pbkdf2_11: (+1)
   \       0x7A   0x.... 0x....      LDR.W    R10,??DataTable8_43
   1043                break;
   \       0x7E   0xE004             B.N      ??sl_se_derive_key_pbkdf2_13
   1044          
   1045          #if defined(SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_CMAC_AVAILABLE)
   1046              // PBKDF2 with CMAC as the PRF was first supported on EFR32xG23.
   1047              case SL_SE_PRF_AES_CMAC_128:
   1048                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_CMAC;
   \                     ??sl_se_derive_key_pbkdf2_6: (+1)
   \       0x80   0x.... 0x....      LDR.W    R10,??DataTable8_44
   1049                break;
   \       0x84   0xE001             B.N      ??sl_se_derive_key_pbkdf2_13
   1050          #endif
   1051          
   1052              default:
   1053                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_derive_key_pbkdf2_12: (+1)
   \       0x86   0x2021             MOVS     R0,#+33
   \       0x88   0xE077             B.N      ??sl_se_derive_key_pbkdf2_2
   1054                break;
   1055            }
   1056          
   1057            // SE command structures.
   1058            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_derive_key_pbkdf2_13: (+1)
   \       0x8A   0x9400             STR      R4,[SP, #+0]
   1059            sli_se_command_init(cmd_ctx, command_word);
   \       0x8C   0xF8C4 0xA000      STR      R10,[R4, #+0]
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x6060             STR      R0,[R4, #+4]
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x60A0             STR      R0,[R4, #+8]
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x61E0             STR      R0,[R4, #+28]
   1060          
   1061            sli_add_key_parameters(cmd_ctx, in_key, status);
   \       0x9C   0xA902             ADD      R1,SP,#+8
   \       0x9E   0x0028             MOVS     R0,R5
   \       0xA0   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xA4   0x4683             MOV      R11,R0
   \       0xA6   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xAA   0xD001             BEQ.N    ??sl_se_derive_key_pbkdf2_14
   \       0xAC   0x4658             MOV      R0,R11
   \       0xAE   0xE064             B.N      ??sl_se_derive_key_pbkdf2_2
   \                     ??sl_se_derive_key_pbkdf2_14: (+1)
   \       0xB0   0x9902             LDR      R1,[SP, #+8]
   \       0xB2   0x0020             MOVS     R0,R4
   \       0xB4   0x.... 0x....      BL       SE_addParameter
   1062            SE_addParameter(se_cmd, salt_len);
   \       0xB8   0x0031             MOVS     R1,R6
   \       0xBA   0x9800             LDR      R0,[SP, #+0]
   \       0xBC   0x.... 0x....      BL       SE_addParameter
   1063            SE_addParameter(se_cmd, iterations);
   \       0xC0   0x0039             MOVS     R1,R7
   \       0xC2   0x9800             LDR      R0,[SP, #+0]
   \       0xC4   0x.... 0x....      BL       SE_addParameter
   1064            sli_add_key_parameters(cmd_ctx, out_key, status);
   \       0xC8   0xA901             ADD      R1,SP,#+4
   \       0xCA   0x4640             MOV      R0,R8
   \       0xCC   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xD0   0x4681             MOV      R9,R0
   \       0xD2   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xD6   0xD001             BEQ.N    ??sl_se_derive_key_pbkdf2_15
   \       0xD8   0x4648             MOV      R0,R9
   \       0xDA   0xE04E             B.N      ??sl_se_derive_key_pbkdf2_2
   \                     ??sl_se_derive_key_pbkdf2_15: (+1)
   \       0xDC   0x9901             LDR      R1,[SP, #+4]
   \       0xDE   0x0020             MOVS     R0,R4
   \       0xE0   0x.... 0x....      BL       SE_addParameter
   1065          
   1066            sli_add_key_metadata(cmd_ctx, in_key, status);
   \       0xE4   0xA90F             ADD      R1,SP,#+60
   \       0xE6   0x0028             MOVS     R0,R5
   \       0xE8   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xEC   0x4683             MOV      R11,R0
   \       0xEE   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xF2   0xD001             BEQ.N    ??sl_se_derive_key_pbkdf2_16
   \       0xF4   0x4658             MOV      R0,R11
   \       0xF6   0xE040             B.N      ??sl_se_derive_key_pbkdf2_2
   \                     ??sl_se_derive_key_pbkdf2_16: (+1)
   \       0xF8   0xA90F             ADD      R1,SP,#+60
   \       0xFA   0x0020             MOVS     R0,R4
   \       0xFC   0x.... 0x....      BL       SE_addDataInput
   1067            sli_add_key_input(cmd_ctx, in_key, status);
   \      0x100   0xA90C             ADD      R1,SP,#+48
   \      0x102   0x0028             MOVS     R0,R5
   \      0x104   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x108   0x4681             MOV      R9,R0
   \      0x10A   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x10E   0xD001             BEQ.N    ??sl_se_derive_key_pbkdf2_17
   \      0x110   0x4648             MOV      R0,R9
   \      0x112   0xE032             B.N      ??sl_se_derive_key_pbkdf2_2
   \                     ??sl_se_derive_key_pbkdf2_17: (+1)
   \      0x114   0xA90C             ADD      R1,SP,#+48
   \      0x116   0x0020             MOVS     R0,R4
   \      0x118   0x.... 0x....      BL       SE_addDataInput
   1068          
   1069            sli_add_key_metadata_custom(cmd_ctx, auth_data, out_key, status);
   \      0x11C   0xA909             ADD      R1,SP,#+36
   \      0x11E   0x4640             MOV      R0,R8
   \      0x120   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x124   0x4683             MOV      R11,R0
   \      0x126   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x12A   0xD001             BEQ.N    ??sl_se_derive_key_pbkdf2_18
   \      0x12C   0x4658             MOV      R0,R11
   \      0x12E   0xE024             B.N      ??sl_se_derive_key_pbkdf2_2
   \                     ??sl_se_derive_key_pbkdf2_18: (+1)
   \      0x130   0xA909             ADD      R1,SP,#+36
   \      0x132   0x0020             MOVS     R0,R4
   \      0x134   0x.... 0x....      BL       SE_addDataInput
   1070          
   1071            SE_DataTransfer_t salt_in = SE_DATATRANSFER_DEFAULT(salt, salt_len);
   \      0x138   0xF10D 0x0C0C      ADD      R12,SP,#+12
   \      0x13C   0x....             LDR.N    R0,??DataTable8_45
   \      0x13E   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x142   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x146   0x9814             LDR      R0,[SP, #+80]
   \      0x148   0x9003             STR      R0,[SP, #+12]
   \      0x14A   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \      0x14E   0x9005             STR      R0,[SP, #+20]
   1072            SE_addDataInput(se_cmd, &salt_in);
   \      0x150   0xA903             ADD      R1,SP,#+12
   \      0x152   0x9800             LDR      R0,[SP, #+0]
   \      0x154   0x.... 0x....      BL       SE_addDataInput
   1073          
   1074            sli_add_key_output(cmd_ctx, out_key, status);
   \      0x158   0xA906             ADD      R1,SP,#+24
   \      0x15A   0x4640             MOV      R0,R8
   \      0x15C   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x160   0x4681             MOV      R9,R0
   \      0x162   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x166   0xD001             BEQ.N    ??sl_se_derive_key_pbkdf2_19
   \      0x168   0x4648             MOV      R0,R9
   \      0x16A   0xE006             B.N      ??sl_se_derive_key_pbkdf2_2
   \                     ??sl_se_derive_key_pbkdf2_19: (+1)
   \      0x16C   0xA906             ADD      R1,SP,#+24
   \      0x16E   0x0020             MOVS     R0,R4
   \      0x170   0x.... 0x....      BL       SE_addDataOutput
   1075          
   1076            status = sli_se_execute_and_wait(cmd_ctx);
   \      0x174   0x0020             MOVS     R0,R4
   \      0x176   0x.... 0x....      BL       sli_se_execute_and_wait
   1077          
   1078            return status;
   \                     ??sl_se_derive_key_pbkdf2_2: (+1)
   \      0x17A   0xB015             ADD      SP,SP,#+84
   \      0x17C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1079          }

   \                                 In section .rodata, align 4
   \                     ?_40:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0xB000'0020        DC32     0xb0000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0xB000'0038        DC32     0xb0000038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x0B02'0400        DC32     0xb020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0B00'0100        DC32     0xb000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     ecjpake_id

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x0B01'0100        DC32     0xb010100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \        0x0   0x....'....        DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \        0x0   0x....'....        DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \        0x0   0x8000'0020        DC32     0x80000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \        0x0   0x8000'001F        DC32     0x8000001f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \        0x0   0x....'....        DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \        0x0   0x....'....        DC32     ?_24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_23:
   \        0x0   0x....'....        DC32     ?_25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_24:
   \        0x0   0x....'....        DC32     ?_26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_25:
   \        0x0   0x....'....        DC32     ?_27

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_26:
   \        0x0   0x....'....        DC32     ?_28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_27:
   \        0x0   0x0B01'0000        DC32     0xb010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_28:
   \        0x0   0x....'....        DC32     ?_29

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_29:
   \        0x0   0x....'....        DC32     ?_30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_30:
   \        0x0   0x....'....        DC32     ?_31

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_31:
   \        0x0   0x....'....        DC32     ?_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_32:
   \        0x0   0x....'....        DC32     ?_33

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_33:
   \        0x0   0x....'....        DC32     ?_34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_34:
   \        0x0   0x....'....        DC32     ?_35

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_35:
   \        0x0   0x....'....        DC32     ?_36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_36:
   \        0x0   0x....'....        DC32     ?_37

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_37:
   \        0x0   0x0202'0003        DC32     0x2020003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_38:
   \        0x0   0x....'....        DC32     ?_38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_39:
   \        0x0   0x....'....        DC32     ?_39

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_40:
   \        0x0   0x0202'0302        DC32     0x2020302

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_41:
   \        0x0   0x0202'0402        DC32     0x2020402

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_42:
   \        0x0   0x0202'0502        DC32     0x2020502

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_43:
   \        0x0   0x0202'0602        DC32     0x2020602

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_44:
   \        0x0   0x0202'0010        DC32     0x2020010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_45:
   \        0x0   0x....'....        DC32     ?_40

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x63 0x6C          DC8 "client"
   \              0x69 0x65    
   \              0x6E 0x74    
   \              0x00
   \        0x7                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x73 0x65          DC8 "server"
   \              0x72 0x76    
   \              0x65 0x72    
   \              0x00
   \        0x7                      DS8 1
   1080          #endif // _SILICON_LABS_SECURITY_FEATURE_VAULT
   1081          
   1082          /** @} (end addtogroup sl_se) */
   1083          
   1084          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   ecjpake_parse_tls_point
        48   -> __aeabi_memcpy
      56   ecjpake_parse_tls_zkp
        56   -> __aeabi_memcpy
        56   -> __aeabi_memset
        56   -> ecjpake_parse_tls_point
      40   ecjpake_write_tls_point
        40   -> __aeabi_memcpy
      48   ecjpake_write_tls_zkp
        48   -> __aeabi_memcpy
        48   -> ecjpake_write_tls_point
     128   sl_se_derive_key_hkdf
       128   -> SE_addDataInput
       128   -> SE_addDataOutput
       128   -> SE_addParameter
       128   -> sli_se_execute_and_wait
       128   -> sli_se_get_auth_buffer
       128   -> sli_se_get_key_input_output
       128   -> sli_se_key_to_keyspec
     120   sl_se_derive_key_pbkdf2
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
     104   sl_se_ecdh_compute_shared_secret
       104   -> SE_addDataInput
       104   -> SE_addDataOutput
       104   -> SE_addParameter
       104   -> sli_key_check_equivalent
       104   -> sli_key_get_size
       104   -> sli_se_execute_and_wait
       104   -> sli_se_get_auth_buffer
       104   -> sli_se_get_key_input_output
       104   -> sli_se_key_to_keyspec
       0   sl_se_ecjpake_check
     104   sl_se_ecjpake_derive_secret
       104   -> SE_addDataInput
       104   -> SE_addDataOutput
       104   -> SE_addParameter
       104   -> sli_se_execute_and_wait
      24   sl_se_ecjpake_free
        24   -> __aeabi_memset
      24   sl_se_ecjpake_init
        24   -> __aeabi_memset
     320   sl_se_ecjpake_read_round_one
       320   -> SE_addDataInput
       320   -> SE_addParameter
       320   -> __aeabi_memset
       320   -> ecjpake_parse_tls_point
       320   -> ecjpake_parse_tls_zkp
       320   -> sli_se_execute_and_wait
       320   -> strlen
     224   sl_se_ecjpake_read_round_two
       224   -> SE_addDataInput
       224   -> SE_addParameter
       224   -> ecjpake_parse_tls_point
       224   -> ecjpake_parse_tls_zkp
       224   -> sli_se_execute_and_wait
       224   -> strlen
      40   sl_se_ecjpake_setup
        40   -> __aeabi_memcpy
     336   sl_se_ecjpake_write_round_one
       336   -> SE_addDataInput
       336   -> SE_addDataOutput
       336   -> SE_addParameter
       336   -> ecjpake_write_tls_point
       336   -> ecjpake_write_tls_zkp
       336   -> sli_se_execute_and_wait
       336   -> strlen
     328   sl_se_ecjpake_write_round_two
       328   -> SE_addDataInput
       328   -> SE_addDataOutput
       328   -> SE_addParameter
       328   -> ecjpake_write_tls_point
       328   -> ecjpake_write_tls_zkp
       328   -> sli_se_execute_and_wait
       328   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_23
       4  ??DataTable8_24
       4  ??DataTable8_25
       4  ??DataTable8_26
       4  ??DataTable8_27
       4  ??DataTable8_28
       4  ??DataTable8_29
       4  ??DataTable8_3
       4  ??DataTable8_30
       4  ??DataTable8_31
       4  ??DataTable8_32
       4  ??DataTable8_33
       4  ??DataTable8_34
       4  ??DataTable8_35
       4  ??DataTable8_36
       4  ??DataTable8_37
       4  ??DataTable8_38
       4  ??DataTable8_39
       4  ??DataTable8_4
       4  ??DataTable8_40
       4  ??DataTable8_41
       4  ??DataTable8_42
       4  ??DataTable8_43
       4  ??DataTable8_44
       4  ??DataTable8_45
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       8  ?_0
       8  ?_1
      12  ?_10
      12  ?_11
      12  ?_12
      12  ?_13
      12  ?_14
      12  ?_15
      12  ?_16
      12  ?_17
      12  ?_18
      12  ?_19
      12  ?_2
      12  ?_20
      12  ?_21
      12  ?_22
      12  ?_23
      12  ?_24
      12  ?_25
      12  ?_26
      12  ?_27
      12  ?_28
      12  ?_29
      12  ?_3
      12  ?_30
      12  ?_31
      12  ?_32
      12  ?_33
      12  ?_34
      12  ?_35
      12  ?_36
      12  ?_37
      12  ?_38
      12  ?_39
      12  ?_4
      12  ?_40
      12  ?_5
      12  ?_6
      12  ?_7
      12  ?_8
      12  ?_9
       8  ecjpake_id
     244  ecjpake_parse_tls_point
     286  ecjpake_parse_tls_zkp
     196  ecjpake_write_tls_point
     208  ecjpake_write_tls_zkp
     408  sl_se_derive_key_hkdf
     384  sl_se_derive_key_pbkdf2
     448  sl_se_ecdh_compute_shared_secret
      24  sl_se_ecjpake_check
     290  sl_se_ecjpake_derive_secret
      34  sl_se_ecjpake_free
      46  sl_se_ecjpake_init
     530  sl_se_ecjpake_read_round_one
     474  sl_se_ecjpake_read_round_two
      98  sl_se_ecjpake_setup
     482  sl_se_ecjpake_write_round_one
     522  sl_se_ecjpake_write_round_two

 
   492 bytes in section .rodata
 4'890 bytes in section .text
 
 4'890 bytes of CODE  memory
   492 bytes of CONST memory

Errors: none
Warnings: none
