###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         29/Mar/2025  15:53:09
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_util.c
#    Command line      =
#        -f "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_util.o.rsp"
#        ("D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_util.c"
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_10044205007528117694.dir"
#        --diag_suppress Pa050 -o "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M33 --cmse --cmse
#        -e --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\rail\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\config\wisun\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\.\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\\"
#        -I "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\\" -I
#        "D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\autogen\\" -On
#        --use_c++_inline) --dependencies=n "D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_util.o.iar_deps"
#    Locale            =  C
#    List file         =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\lst\src_10044205007528117694.dir\sl_se_manager_util.lst
#    Object file       =
#        D:\Inesh_wisun\Wisun_Node_App
#        1\Wisun_Node_App\ewarm-iar\obj\src_10044205007528117694.dir\sl_se_manager_util.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\Inesh_wisun\Wisun_Node_App 1\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\sl_se_manager_util.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs Secure Engine Manager API.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sl_se_manager_util.h"
     32          
     33          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED) || defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
     34          
     35          #include "sli_se_manager_internal.h"
     36          #include "em_se.h"
     37          #include "sl_assert.h"
     38          
     39          #if defined(SLI_SE_MAJOR_VERSION_ONE)
     40            #include "em_system.h"
     41          #endif
     42          
     43          /// @addtogroup sl_se_manager
     44          /// @{
     45          
     46          // -----------------------------------------------------------------------------
     47          // Defines
     48          
     49          // OTP initialization structure defines.
     50          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE (1 << 16)
     51          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE (1 << 17)
     52          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK (1 << 18)
     53          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW (1 << 19)
     54          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL (1 << 20)
     55          
     56          // -----------------------------------------------------------------------------
     57          // Local Functions
     58          
     59          /***************************************************************************//**
     60           * @brief
     61           *   Decode debug status word (as received from the SE).
     62           *
     63           * @return N/A
     64           ******************************************************************************/
     65          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)

   \                                 In section .text, align 2, keep-with-next
     66          static void decode_debug_status(sl_se_debug_status_t *debug_status,
     67                                          uint32_t status_word)
     68          {
     69            debug_status->debug_port_lock_applied = status_word & (1 << 0);
   \                     decode_debug_status: (+1)
   \        0x0   0xF011 0x0201      ANDS     R2,R1,#0x1
   \        0x4   0x7082             STRB     R2,[R0, #+2]
     70            debug_status->device_erase_enabled = status_word & (1 << 1);
   \        0x6   0x000A             MOVS     R2,R1
   \        0x8   0x0852             LSRS     R2,R2,#+1
   \        0xA   0xF012 0x0201      ANDS     R2,R2,#0x1
   \        0xE   0x7002             STRB     R2,[R0, #+0]
     71            debug_status->secure_debug_enabled = status_word & (1 << 2);
   \       0x10   0x000A             MOVS     R2,R1
   \       0x12   0x0892             LSRS     R2,R2,#+2
   \       0x14   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x18   0x7042             STRB     R2,[R0, #+1]
     72            debug_status->debug_port_lock_state = status_word & (1 << 5);
   \       0x1A   0x000A             MOVS     R2,R1
   \       0x1C   0x0952             LSRS     R2,R2,#+5
   \       0x1E   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x22   0x70C2             STRB     R2,[R0, #+3]
     73            debug_status->options_state.non_secure_invasive_debug =
     74              (status_word & (1 << 6)) == 0;
   \       0x24   0x000A             MOVS     R2,R1
   \       0x26   0x0992             LSRS     R2,R2,#+6
   \       0x28   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x2C   0xF092 0x0201      EORS     R2,R2,#0x1
   \       0x30   0x7202             STRB     R2,[R0, #+8]
     75            debug_status->options_state.non_secure_non_invasive_debug =
     76              (status_word & (1 << 7)) == 0;
   \       0x32   0x000A             MOVS     R2,R1
   \       0x34   0x09D2             LSRS     R2,R2,#+7
   \       0x36   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x3A   0xF092 0x0201      EORS     R2,R2,#0x1
   \       0x3E   0x7242             STRB     R2,[R0, #+9]
     77            debug_status->options_state.secure_invasive_debug =
     78              (status_word & (1 << 8)) == 0;
   \       0x40   0x000A             MOVS     R2,R1
   \       0x42   0x0A12             LSRS     R2,R2,#+8
   \       0x44   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x48   0xF092 0x0201      EORS     R2,R2,#0x1
   \       0x4C   0x7282             STRB     R2,[R0, #+10]
     79            debug_status->options_state.secure_non_invasive_debug =
     80              (status_word & (1 << 9)) == 0;
   \       0x4E   0x000A             MOVS     R2,R1
   \       0x50   0x0A52             LSRS     R2,R2,#+9
   \       0x52   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x56   0xF092 0x0201      EORS     R2,R2,#0x1
   \       0x5A   0x72C2             STRB     R2,[R0, #+11]
     81            debug_status->options_config.non_secure_invasive_debug =
     82              (status_word & (1 << 10)) == 0;
   \       0x5C   0x000A             MOVS     R2,R1
   \       0x5E   0x0A92             LSRS     R2,R2,#+10
   \       0x60   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x64   0xF092 0x0201      EORS     R2,R2,#0x1
   \       0x68   0x7102             STRB     R2,[R0, #+4]
     83            debug_status->options_config.non_secure_non_invasive_debug =
     84              (status_word & (1 << 11)) == 0;
   \       0x6A   0x000A             MOVS     R2,R1
   \       0x6C   0x0AD2             LSRS     R2,R2,#+11
   \       0x6E   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x72   0xF092 0x0201      EORS     R2,R2,#0x1
   \       0x76   0x7142             STRB     R2,[R0, #+5]
     85            debug_status->options_config.secure_invasive_debug =
     86              (status_word & (1 << 12)) == 0;
   \       0x78   0x000A             MOVS     R2,R1
   \       0x7A   0x0B12             LSRS     R2,R2,#+12
   \       0x7C   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x80   0xF092 0x0201      EORS     R2,R2,#0x1
   \       0x84   0x7182             STRB     R2,[R0, #+6]
     87            debug_status->options_config.secure_non_invasive_debug =
     88              (status_word & (1 << 13)) == 0;
   \       0x86   0x000A             MOVS     R2,R1
   \       0x88   0x0B52             LSRS     R2,R2,#+13
   \       0x8A   0xF012 0x0201      ANDS     R2,R2,#0x1
   \       0x8E   0xF092 0x0201      EORS     R2,R2,#0x1
   \       0x92   0x71C2             STRB     R2,[R0, #+7]
     89          }
   \       0x94   0x4770             BX       LR
     90          #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
     91          static void decode_debug_status(sl_se_debug_status_t *debug_status,
     92                                          uint32_t status_word)
     93          {
     94            debug_status->debug_port_lock_applied = status_word & (1 << 10);
     95            debug_status->device_erase_enabled = status_word & (1 << 11);
     96            debug_status->secure_debug_enabled = status_word & (1 << 12);
     97            debug_status->debug_port_lock_state = status_word & (1 << 15);
     98          }
     99          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    100          
    101          // -----------------------------------------------------------------------------
    102          // Global Functions
    103          
    104          /***************************************************************************//**
    105           * Validate SE firmware image.
    106           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    107          sl_status_t sl_se_check_se_image(sl_se_command_context_t *cmd_ctx,
    108                                           void *image_addr)
    109          {
   \                     sl_se_check_se_image: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    110            if (cmd_ctx == NULL || image_addr == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sl_se_check_se_image_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sl_se_check_se_image_1
    111              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_check_se_image_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE010             B.N      ??sl_se_check_se_image_2
    112            }
    113          
    114            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_check_se_image_1: (+1)
   \       0x12   0x0026             MOVS     R6,R4
    115            // SE command structures
    116            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CHECK_SE_IMAGE);
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable30
   \       0x18   0x6020             STR      R0,[R4, #+0]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6060             STR      R0,[R4, #+4]
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60A0             STR      R0,[R4, #+8]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61E0             STR      R0,[R4, #+28]
    117          
    118            SE_addParameter(se_cmd, (uint32_t)image_addr);
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0x.... 0x....      BL       SE_addParameter
    119          
    120            return sli_se_execute_and_wait(cmd_ctx);
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_check_se_image_2: (+1)
   \       0x34   0xBD70             POP      {R4-R6,PC}
    121          }
    122          
    123          /***************************************************************************//**
    124           * Apply SE firmware image.
    125           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    126          sl_status_t sl_se_apply_se_image(sl_se_command_context_t *cmd_ctx,
    127                                           void *image_addr)
    128          {
   \                     sl_se_apply_se_image: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    129            if (cmd_ctx == NULL || image_addr == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sl_se_apply_se_image_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sl_se_apply_se_image_1
    130              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_apply_se_image_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE010             B.N      ??sl_se_apply_se_image_2
    131            }
    132          
    133            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_apply_se_image_1: (+1)
   \       0x12   0x0026             MOVS     R6,R4
    134            // SE command structures
    135            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_APPLY_SE_IMAGE);
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable30_1
   \       0x18   0x6020             STR      R0,[R4, #+0]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6060             STR      R0,[R4, #+4]
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60A0             STR      R0,[R4, #+8]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61E0             STR      R0,[R4, #+28]
    136          
    137            SE_addParameter(se_cmd, (uint32_t)image_addr);
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0x.... 0x....      BL       SE_addParameter
    138          
    139            return sli_se_execute_and_wait(cmd_ctx);
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_apply_se_image_2: (+1)
   \       0x34   0xBD70             POP      {R4-R6,PC}
    140          }
    141          
    142          /***************************************************************************//**
    143           * Get upgrade status of SE firmware image.
    144           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    145          sl_status_t sl_se_get_upgrade_status_se_image(sl_se_command_context_t *cmd_ctx,
    146                                                        uint32_t *status,
    147                                                        uint32_t *prev_version)
    148          {
   \                     sl_se_get_upgrade_status_se_image: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    149            if (cmd_ctx == NULL || status == NULL || prev_version == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD003             BEQ.N    ??sl_se_get_upgrade_status_se_image_0
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD001             BEQ.N    ??sl_se_get_upgrade_status_se_image_0
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD101             BNE.N    ??sl_se_get_upgrade_status_se_image_1
    150              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_upgrade_status_se_image_0: (+1)
   \       0x16   0x2021             MOVS     R0,#+33
   \       0x18   0xE020             B.N      ??sl_se_get_upgrade_status_se_image_2
    151            }
    152          
    153            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_get_upgrade_status_se_image_1: (+1)
   \       0x1A   0x0027             MOVS     R7,R4
    154            // SE command structures
    155            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_SE_IMAGE);
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable29
   \       0x20   0x6020             STR      R0,[R4, #+0]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x6060             STR      R0,[R4, #+4]
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x60A0             STR      R0,[R4, #+8]
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x61E0             STR      R0,[R4, #+28]
    156          
    157            volatile uint32_t out_buf[2];
    158            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(out_buf,
    159                                                                 sizeof(out_buf));
   \       0x2E   0xF10D 0x0C08      ADD      R12,SP,#+8
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable31
   \       0x36   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x3A   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0x9002             STR      R0,[SP, #+8]
    160            SE_addDataOutput(se_cmd, &out_data);
   \       0x42   0xA902             ADD      R1,SP,#+8
   \       0x44   0x0038             MOVS     R0,R7
   \       0x46   0x.... 0x....      BL       SE_addDataOutput
    161          
    162            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       sli_se_execute_and_wait
    163          
    164            if (ret == SL_STATUS_OK) {
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD103             BNE.N    ??sl_se_get_upgrade_status_se_image_3
    165              *status = out_buf[0];
   \       0x54   0x9900             LDR      R1,[SP, #+0]
   \       0x56   0x6029             STR      R1,[R5, #+0]
    166              *prev_version = out_buf[1];
   \       0x58   0x9901             LDR      R1,[SP, #+4]
   \       0x5A   0x6031             STR      R1,[R6, #+0]
    167            }
    168          
    169            return ret;
   \                     ??sl_se_get_upgrade_status_se_image_3: (+1)
   \                     ??sl_se_get_upgrade_status_se_image_2: (+1)
   \       0x5C   0xB005             ADD      SP,SP,#+20
   \       0x5E   0xBDF0             POP      {R4-R7,PC}
    170          }

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'920
   \              0x0000'0001  
   \              0x2000'0008
    171          
    172          /***************************************************************************//**
    173           * Validate Host firmware image.
    174           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    175          sl_status_t sl_se_check_host_image(sl_se_command_context_t *cmd_ctx,
    176                                             void *image_addr,
    177                                             uint32_t size)
    178          {
   \                     sl_se_check_host_image: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    179            if (cmd_ctx == NULL || image_addr == NULL || size == 0UL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD003             BEQ.N    ??sl_se_check_host_image_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD001             BEQ.N    ??sl_se_check_host_image_0
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD101             BNE.N    ??sl_se_check_host_image_1
    180              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_check_host_image_0: (+1)
   \       0x14   0x2021             MOVS     R0,#+33
   \       0x16   0xE014             B.N      ??sl_se_check_host_image_2
    181            }
    182          
    183            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_check_host_image_1: (+1)
   \       0x18   0x0027             MOVS     R7,R4
    184            // SE command structures
    185            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CHECK_HOST_IMAGE);
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \       0x1E   0x6020             STR      R0,[R4, #+0]
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6060             STR      R0,[R4, #+4]
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x60A0             STR      R0,[R4, #+8]
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x61E0             STR      R0,[R4, #+28]
    186          
    187            SE_addParameter(se_cmd, (uint32_t)image_addr);
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0x.... 0x....      BL       SE_addParameter
    188            SE_addParameter(se_cmd, size);
   \       0x34   0x0031             MOVS     R1,R6
   \       0x36   0x0038             MOVS     R0,R7
   \       0x38   0x.... 0x....      BL       SE_addParameter
    189          
    190            return sli_se_execute_and_wait(cmd_ctx);
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_check_host_image_2: (+1)
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}
    191          }
    192          
    193          /***************************************************************************//**
    194           * Apply Host firmware image.
    195           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    196          sl_status_t sl_se_apply_host_image(sl_se_command_context_t *cmd_ctx,
    197                                             void *image_addr,
    198                                             uint32_t size)
    199          {
   \                     sl_se_apply_host_image: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    200            if (cmd_ctx == NULL || image_addr == NULL || size == 0UL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD003             BEQ.N    ??sl_se_apply_host_image_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD001             BEQ.N    ??sl_se_apply_host_image_0
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD101             BNE.N    ??sl_se_apply_host_image_1
    201              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_apply_host_image_0: (+1)
   \       0x14   0x2021             MOVS     R0,#+33
   \       0x16   0xE014             B.N      ??sl_se_apply_host_image_2
    202            }
    203          
    204            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_apply_host_image_1: (+1)
   \       0x18   0x0027             MOVS     R7,R4
    205            // SE command structures
    206            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_APPLY_HOST_IMAGE);
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable31_2
   \       0x1E   0x6020             STR      R0,[R4, #+0]
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6060             STR      R0,[R4, #+4]
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x60A0             STR      R0,[R4, #+8]
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x61E0             STR      R0,[R4, #+28]
    207          
    208            SE_addParameter(se_cmd, (uint32_t)image_addr);
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0x.... 0x....      BL       SE_addParameter
    209            SE_addParameter(se_cmd, size);
   \       0x34   0x0031             MOVS     R1,R6
   \       0x36   0x0038             MOVS     R0,R7
   \       0x38   0x.... 0x....      BL       SE_addParameter
    210          
    211            return sli_se_execute_and_wait(cmd_ctx);
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_apply_host_image_2: (+1)
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}
    212          }
    213          
    214          /***************************************************************************//**
    215           * Get upgrade status of Host firmware image.
    216           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    217          sl_status_t
    218          sl_se_get_upgrade_status_host_image(sl_se_command_context_t *cmd_ctx,
    219                                              uint32_t *status,
    220                                              uint32_t *prev_version)
    221          {
   \                     sl_se_get_upgrade_status_host_image: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    222            if (cmd_ctx == NULL || status == NULL || prev_version == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD003             BEQ.N    ??sl_se_get_upgrade_status_host_image_0
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD001             BEQ.N    ??sl_se_get_upgrade_status_host_image_0
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD101             BNE.N    ??sl_se_get_upgrade_status_host_image_1
    223              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_upgrade_status_host_image_0: (+1)
   \       0x16   0x2021             MOVS     R0,#+33
   \       0x18   0xE020             B.N      ??sl_se_get_upgrade_status_host_image_2
    224            }
    225          
    226            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_get_upgrade_status_host_image_1: (+1)
   \       0x1A   0x0027             MOVS     R7,R4
    227            // SE command structures
    228            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_HOST_IMAGE);
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable31_3
   \       0x20   0x6020             STR      R0,[R4, #+0]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x6060             STR      R0,[R4, #+4]
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x60A0             STR      R0,[R4, #+8]
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x61E0             STR      R0,[R4, #+28]
    229          
    230            volatile uint32_t out_buf[2];
    231            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(out_buf,
    232                                                                 sizeof(out_buf));
   \       0x2E   0xF10D 0x0C08      ADD      R12,SP,#+8
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable31_4
   \       0x36   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x3A   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0x9002             STR      R0,[SP, #+8]
    233            SE_addDataOutput(se_cmd, &out_data);
   \       0x42   0xA902             ADD      R1,SP,#+8
   \       0x44   0x0038             MOVS     R0,R7
   \       0x46   0x.... 0x....      BL       SE_addDataOutput
    234          
    235            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       sli_se_execute_and_wait
    236          
    237            if (ret == SL_STATUS_OK) {
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD103             BNE.N    ??sl_se_get_upgrade_status_host_image_3
    238              *status = out_buf[0];
   \       0x54   0x9900             LDR      R1,[SP, #+0]
   \       0x56   0x6029             STR      R1,[R5, #+0]
    239              *prev_version = out_buf[1];
   \       0x58   0x9901             LDR      R1,[SP, #+4]
   \       0x5A   0x6031             STR      R1,[R6, #+0]
    240            }
    241          
    242            return ret;
   \                     ??sl_se_get_upgrade_status_host_image_3: (+1)
   \                     ??sl_se_get_upgrade_status_host_image_2: (+1)
   \       0x5C   0xB005             ADD      SP,SP,#+20
   \       0x5E   0xBDF0             POP      {R4-R7,PC}
    243          }

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'920
   \              0x0000'0001  
   \              0x2000'0008
    244          
    245          /***************************************************************************//**
    246           * Initialize key to be stored in the SE OTP flash.
    247           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    248          sl_status_t sl_se_init_otp_key(sl_se_command_context_t *cmd_ctx,
    249                                         sl_se_device_key_type_t key_type,
    250                                         void *key,
    251                                         uint32_t num_bytes)
    252          {
   \                     sl_se_init_otp_key: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000F             MOVS     R7,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0x001E             MOVS     R6,R3
    253            if (cmd_ctx == NULL || key == NULL || num_bytes == 0UL || (size_t)key & 3U) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD007             BEQ.N    ??sl_se_init_otp_key_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD005             BEQ.N    ??sl_se_init_otp_key_0
   \       0x16   0x2E00             CMP      R6,#+0
   \       0x18   0xD003             BEQ.N    ??sl_se_init_otp_key_0
   \       0x1A   0xF015 0x0003      ANDS     R0,R5,#0x3
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??sl_se_init_otp_key_1
    254              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_init_otp_key_0: (+1)
   \       0x22   0x2021             MOVS     R0,#+33
   \       0x24   0xE05E             B.N      ??sl_se_init_otp_key_2
    255            }
    256          
    257            #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    258            if (key_type == SL_SE_KEY_TYPE_IMMUTABLE_AES_128) {
   \                     ??sl_se_init_otp_key_1: (+1)
   \       0x26   0x0038             MOVS     R0,R7
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x2802             CMP      R0,#+2
   \       0x2C   0xD103             BNE.N    ??sl_se_init_otp_key_3
    259              if (num_bytes != 16UL) {
   \       0x2E   0x2E10             CMP      R6,#+16
   \       0x30   0xD005             BEQ.N    ??sl_se_init_otp_key_4
    260                return SL_STATUS_INVALID_PARAMETER;
   \       0x32   0x2021             MOVS     R0,#+33
   \       0x34   0xE056             B.N      ??sl_se_init_otp_key_2
    261              }
    262            } else {
    263              if (num_bytes != 64UL) {
   \                     ??sl_se_init_otp_key_3: (+1)
   \       0x36   0x2E40             CMP      R6,#+64
   \       0x38   0xD001             BEQ.N    ??sl_se_init_otp_key_4
    264                return SL_STATUS_INVALID_PARAMETER;
   \       0x3A   0x2021             MOVS     R0,#+33
   \       0x3C   0xE052             B.N      ??sl_se_init_otp_key_2
    265              }
    266            }
    267            #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    268            if (num_bytes != 64UL) {
    269              return SL_STATUS_INVALID_PARAMETER;
    270            }
    271            #endif
    272          
    273            uint32_t command_word;
    274            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_init_otp_key_4: (+1)
   \       0x3E   0x46A1             MOV      R9,R4
    275          
    276            uint32_t se_key_type;
    277            switch (key_type) {
   \       0x40   0x0038             MOVS     R0,R7
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD003             BEQ.N    ??sl_se_init_otp_key_5
   \       0x48   0x2802             CMP      R0,#+2
   \       0x4A   0xD007             BEQ.N    ??sl_se_init_otp_key_6
   \       0x4C   0xD303             BCC.N    ??sl_se_init_otp_key_7
   \       0x4E   0xE008             B.N      ??sl_se_init_otp_key_8
    278              case SL_SE_KEY_TYPE_IMMUTABLE_BOOT:
    279                se_key_type = SLI_SE_KEY_TYPE_BOOT;
   \                     ??sl_se_init_otp_key_5: (+1)
   \       0x50   0xF44F 0x7880      MOV      R8,#+256
    280                break;
   \       0x54   0xE007             B.N      ??sl_se_init_otp_key_9
    281          
    282              case SL_SE_KEY_TYPE_IMMUTABLE_AUTH:
    283                se_key_type = SLI_SE_KEY_TYPE_AUTH;
   \                     ??sl_se_init_otp_key_7: (+1)
   \       0x56   0xF44F 0x7800      MOV      R8,#+512
    284                break;
   \       0x5A   0xE004             B.N      ??sl_se_init_otp_key_9
    285          
    286              #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    287              case SL_SE_KEY_TYPE_IMMUTABLE_AES_128:
    288                se_key_type = SLI_SE_IMMUTABLE_KEY_TYPE_AES_128;
   \                     ??sl_se_init_otp_key_6: (+1)
   \       0x5C   0xF44F 0x68A0      MOV      R8,#+1280
    289                break;
   \       0x60   0xE001             B.N      ??sl_se_init_otp_key_9
    290              #endif // SLI_MAILBOX_COMMAND_SUPPORTED
    291          
    292              default:
    293                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_init_otp_key_8: (+1)
   \       0x62   0x2021             MOVS     R0,#+33
   \       0x64   0xE03E             B.N      ??sl_se_init_otp_key_2
    294                break;
    295            }
    296          
    297            // Find parity word
    298            volatile uint32_t parity = 0;
   \                     ??sl_se_init_otp_key_9: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x9000             STR      R0,[SP, #+0]
    299            for (size_t i = 0; i < num_bytes / 4; i++) {
   \       0x6A   0x2200             MOVS     R2,#+0
   \                     ??sl_se_init_otp_key_10: (+1)
   \       0x6C   0xEBB2 0x0F96      CMP      R2,R6, LSR #+2
   \       0x70   0xD206             BCS.N    ??sl_se_init_otp_key_11
    300              parity = parity ^ ((uint32_t *)key)[i];
   \       0x72   0x9900             LDR      R1,[SP, #+0]
   \       0x74   0xF855 0x0022      LDR      R0,[R5, R2, LSL #+2]
   \       0x78   0x4041             EORS     R1,R0,R1
   \       0x7A   0x9100             STR      R1,[SP, #+0]
    301            }
   \       0x7C   0x1C52             ADDS     R2,R2,#+1
   \       0x7E   0xE7F5             B.N      ??sl_se_init_otp_key_10
    302          
    303            // SE command structures
    304            #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    305            command_word = key_type == SL_SE_KEY_TYPE_IMMUTABLE_AES_128
    306                           ? SLI_SE_COMMAND_INIT_AES_128_KEY : SLI_SE_COMMAND_INIT_PUBKEY;
   \                     ??sl_se_init_otp_key_11: (+1)
   \       0x80   0x0038             MOVS     R0,R7
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0x2802             CMP      R0,#+2
   \       0x86   0xD102             BNE.N    ??sl_se_init_otp_key_12
   \       0x88   0x.... 0x....      LDR.W    R10,??DataTable31_5
   \       0x8C   0xE001             B.N      ??sl_se_init_otp_key_13
   \                     ??sl_se_init_otp_key_12: (+1)
   \       0x8E   0x.... 0x....      LDR.W    R10,??DataTable31_6
    307            #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    308            command_word = SLI_SE_COMMAND_INIT_PUBKEY;
    309            #endif
    310          
    311            sli_se_command_init(cmd_ctx, (command_word | se_key_type));
   \                     ??sl_se_init_otp_key_13: (+1)
   \       0x92   0xEA58 0x000A      ORRS     R0,R8,R10
   \       0x96   0x6020             STR      R0,[R4, #+0]
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x6060             STR      R0,[R4, #+4]
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0x60A0             STR      R0,[R4, #+8]
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x61E0             STR      R0,[R4, #+28]
    312          
    313            SE_DataTransfer_t parity_data = SE_DATATRANSFER_DEFAULT(&parity, 4);
   \       0xA4   0xF10D 0x0C10      ADD      R12,SP,#+16
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable31_7
   \       0xAC   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xB0   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xB4   0x4668             MOV      R0,SP
   \       0xB6   0x9004             STR      R0,[SP, #+16]
    314            SE_addDataInput(se_cmd, &parity_data);
   \       0xB8   0xA904             ADD      R1,SP,#+16
   \       0xBA   0x4648             MOV      R0,R9
   \       0xBC   0x.... 0x....      BL       SE_addDataInput
    315          
    316            SE_DataTransfer_t key_data = SE_DATATRANSFER_DEFAULT(key, num_bytes);
   \       0xC0   0xAB01             ADD      R3,SP,#+4
   \       0xC2   0x.... 0x....      LDR.W    R0,??DataTable31_8
   \       0xC6   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xCA   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xCE   0x9501             STR      R5,[SP, #+4]
   \       0xD0   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \       0xD4   0x9003             STR      R0,[SP, #+12]
    317            SE_addDataInput(se_cmd, &key_data);
   \       0xD6   0xA901             ADD      R1,SP,#+4
   \       0xD8   0x4648             MOV      R0,R9
   \       0xDA   0x.... 0x....      BL       SE_addDataInput
    318          
    319            return sli_se_execute_and_wait(cmd_ctx);
   \       0xDE   0x0020             MOVS     R0,R4
   \       0xE0   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_init_otp_key_2: (+1)
   \       0xE4   0xB008             ADD      SP,SP,#+32
   \       0xE6   0xE8BD 0x87F0      POP      {R4-R10,PC}
    320          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    321          
    322          /***************************************************************************//**
    323           * Read a public key stored in the SE.
    324           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    325          sl_status_t sl_se_read_pubkey(sl_se_command_context_t *cmd_ctx,
    326                                        sl_se_device_key_type_t key_type,
    327                                        void *key,
    328                                        uint32_t num_bytes)
    329          {
   \                     sl_se_read_pubkey: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001F             MOVS     R7,R3
    330            if (cmd_ctx == NULL || key == NULL || num_bytes != 64UL || (size_t)key & 3U) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD007             BEQ.N    ??sl_se_read_pubkey_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD005             BEQ.N    ??sl_se_read_pubkey_0
   \       0x14   0x2F40             CMP      R7,#+64
   \       0x16   0xD103             BNE.N    ??sl_se_read_pubkey_0
   \       0x18   0xF015 0x0003      ANDS     R0,R5,#0x3
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD001             BEQ.N    ??sl_se_read_pubkey_1
    331              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_read_pubkey_0: (+1)
   \       0x20   0x2021             MOVS     R0,#+33
   \       0x22   0xE037             B.N      ??sl_se_read_pubkey_2
    332            }
    333          
    334            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_read_pubkey_1: (+1)
   \       0x24   0x46A2             MOV      R10,R4
    335            uint32_t se_key_type;
    336            uint32_t command_word = SLI_SE_COMMAND_READ_PUBKEY;
   \       0x26   0x.... 0x....      LDR.W    R8,??DataTable31_9
    337            switch (key_type) {
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD006             BEQ.N    ??sl_se_read_pubkey_3
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD007             BEQ.N    ??sl_se_read_pubkey_4
   \       0x36   0x2803             CMP      R0,#+3
   \       0x38   0xD00C             BEQ.N    ??sl_se_read_pubkey_5
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD006             BEQ.N    ??sl_se_read_pubkey_6
   \       0x3E   0xE00C             B.N      ??sl_se_read_pubkey_7
    338              case SL_SE_KEY_TYPE_IMMUTABLE_BOOT:
    339                se_key_type = SLI_SE_KEY_TYPE_BOOT;
   \                     ??sl_se_read_pubkey_3: (+1)
   \       0x40   0xF44F 0x7980      MOV      R9,#+256
    340                break;
   \       0x44   0xE00B             B.N      ??sl_se_read_pubkey_8
    341          
    342              case SL_SE_KEY_TYPE_IMMUTABLE_AUTH:
    343                se_key_type = SLI_SE_KEY_TYPE_AUTH;
   \                     ??sl_se_read_pubkey_4: (+1)
   \       0x46   0xF44F 0x7900      MOV      R9,#+512
    344                break;
   \       0x4A   0xE008             B.N      ??sl_se_read_pubkey_8
    345              #if defined(SLI_MAILBOX_COMMAND_SUPPORTED) && (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    346              case SL_SE_KEY_TYPE_IMMUTABLE_SE_ATTESTATION:
    347                command_word = command_word & ~0x1;
   \                     ??sl_se_read_pubkey_6: (+1)
   \       0x4C   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \       0x50   0xEA5F 0x0848      LSLS     R8,R8,#+1
    348              // Intentional fallthrough
    349              case SL_SE_KEY_TYPE_IMMUTABLE_ATTESTATION:
    350                se_key_type = SLI_SE_KEY_TYPE_ATTEST;
   \                     ??sl_se_read_pubkey_5: (+1)
   \       0x54   0xF44F 0x6980      MOV      R9,#+1024
    351                break;
   \       0x58   0xE001             B.N      ??sl_se_read_pubkey_8
    352              #endif // _SILICON_LABS_SECURITY_FEATURE_VAULT
    353          
    354              default:
    355                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_read_pubkey_7: (+1)
   \       0x5A   0x2021             MOVS     R0,#+33
   \       0x5C   0xE01A             B.N      ??sl_se_read_pubkey_2
    356                break;
    357            }
    358          
    359            // SE command structures
    360            sli_se_command_init(cmd_ctx, command_word | se_key_type);
   \                     ??sl_se_read_pubkey_8: (+1)
   \       0x5E   0xEA59 0x0008      ORRS     R0,R9,R8
   \       0x62   0x6020             STR      R0,[R4, #+0]
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x6060             STR      R0,[R4, #+4]
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x60A0             STR      R0,[R4, #+8]
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x61E0             STR      R0,[R4, #+28]
    361          
    362            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(key, num_bytes);
   \       0x70   0x46EC             MOV      R12,SP
   \       0x72   0x.... 0x....      LDR.W    R0,??DataTable31_10
   \       0x76   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x7A   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x7E   0x9500             STR      R5,[SP, #+0]
   \       0x80   0xF057 0x5000      ORRS     R0,R7,#0x20000000
   \       0x84   0x9002             STR      R0,[SP, #+8]
    363            SE_addDataOutput(se_cmd, &out_data);
   \       0x86   0x4669             MOV      R1,SP
   \       0x88   0x4650             MOV      R0,R10
   \       0x8A   0x.... 0x....      BL       SE_addDataOutput
    364          
    365            return sli_se_execute_and_wait(cmd_ctx);
   \       0x8E   0x0020             MOVS     R0,R4
   \       0x90   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_read_pubkey_2: (+1)
   \       0x94   0xB004             ADD      SP,SP,#+16
   \       0x96   0xE8BD 0x87F0      POP      {R4-R10,PC}
    366          }

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    367          
    368          /***************************************************************************//**
    369           * Read the SE firmware version.
    370           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          sl_status_t sl_se_get_se_version(sl_se_command_context_t *cmd_ctx,
    372                                           uint32_t *version)
    373          {
   \                     sl_se_get_se_version: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    374            if (cmd_ctx == NULL || version == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sl_se_get_se_version_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sl_se_get_se_version_1
    375              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_se_version_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE018             B.N      ??sl_se_get_se_version_2
    376            }
    377          
    378            #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    379          
    380            // SE command structures
    381            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_get_se_version_1: (+1)
   \       0x12   0x0026             MOVS     R6,R4
    382            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_SE_VERSION);
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable31_11
   \       0x18   0x6020             STR      R0,[R4, #+0]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6060             STR      R0,[R4, #+4]
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60A0             STR      R0,[R4, #+8]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61E0             STR      R0,[R4, #+28]
    383            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(version, sizeof(uint32_t));
   \       0x26   0x466F             MOV      R7,SP
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable31_12
   \       0x2C   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x30   0xE887 0x000E      STM      R7,{R1-R3}
   \       0x34   0x9500             STR      R5,[SP, #+0]
    384          
    385            SE_addDataOutput(se_cmd, &out_data);
   \       0x36   0x4669             MOV      R1,SP
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0x.... 0x....      BL       SE_addDataOutput
    386          
    387            return sli_se_execute_and_wait(cmd_ctx);
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_get_se_version_2: (+1)
   \       0x44   0xBDFE             POP      {R1-R7,PC}
    388          
    389            #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    390          
    391            sl_status_t status = SL_STATUS_OK;
    392            SE_Response_t command_response;
    393          
    394            // Try to acquire SE lock.
    395            // Need to protect VSE mailbox from being written by e.g. SE_ackCommand()
    396            status = sli_se_lock_acquire();
    397            if (status != SL_STATUS_OK) {
    398              return status;
    399            }
    400          
    401            // Read SE version from VSE mailbox.
    402            command_response = SE_getVersion(version);
    403          
    404            // Release SE lock
    405            status = sli_se_lock_release();
    406          
    407            // Return sl_status_t code.
    408            if (command_response == SLI_SE_RESPONSE_OK) {
    409              return status;
    410            } else {
    411              // Convert from SE_Response_t to sl_status_t code and return.
    412              return sli_se_to_sl_status(command_response);
    413            }
    414          
    415            #endif
    416          }

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
    417          
    418          /***************************************************************************//**
    419           * Enables the debug lock for the part.
    420           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    421          sl_status_t sl_se_apply_debug_lock(sl_se_command_context_t *cmd_ctx)
    422          {
   \                     sl_se_apply_debug_lock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    423            if (cmd_ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??sl_se_apply_debug_lock_0
    424              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE00B             B.N      ??sl_se_apply_debug_lock_1
    425            }
    426          
    427            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_LOCK_APPLY);
   \                     ??sl_se_apply_debug_lock_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable31_13
   \       0x10   0x6020             STR      R0,[R4, #+0]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6060             STR      R0,[R4, #+4]
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x60A0             STR      R0,[R4, #+8]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x61E0             STR      R0,[R4, #+28]
    428          
    429            return sli_se_execute_and_wait(cmd_ctx);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_apply_debug_lock_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
    430          }
    431          
    432          /***************************************************************************//**
    433           * Returns the current debug lock configuration.
    434           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    435          sl_status_t sl_se_get_debug_lock_status(sl_se_command_context_t *cmd_ctx,
    436                                                  sl_se_debug_status_t *debug_status)
    437          {
   \                     sl_se_get_debug_lock_status: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    438            if (cmd_ctx == NULL || debug_status == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??sl_se_get_debug_lock_status_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??sl_se_get_debug_lock_status_1
    439              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_debug_lock_status_0: (+1)
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE023             B.N      ??sl_se_get_debug_lock_status_2
    440            }
    441            #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    442            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_get_debug_lock_status_1: (+1)
   \       0x14   0x0027             MOVS     R7,R4
    443            volatile uint32_t status_word = 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x9000             STR      R0,[SP, #+0]
    444            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(&status_word, 4);
   \       0x1A   0xAE01             ADD      R6,SP,#+4
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable31_14
   \       0x20   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x24   0xE886 0x000E      STM      R6,{R1-R3}
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x9001             STR      R0,[SP, #+4]
    445          
    446            // Initialize SE command structures
    447            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_LOCK_STATUS);
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable31_15
   \       0x30   0x6020             STR      R0,[R4, #+0]
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6060             STR      R0,[R4, #+4]
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x60A0             STR      R0,[R4, #+8]
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x61E0             STR      R0,[R4, #+28]
    448            SE_addDataOutput(se_cmd, &out_data);
   \       0x3E   0xA901             ADD      R1,SP,#+4
   \       0x40   0x0038             MOVS     R0,R7
   \       0x42   0x.... 0x....      BL       SE_addDataOutput
    449          
    450            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       sli_se_execute_and_wait
   \       0x4C   0x0006             MOVS     R6,R0
    451          
    452            if (ret == SL_STATUS_OK) {
   \       0x4E   0x2E00             CMP      R6,#+0
   \       0x50   0xD103             BNE.N    ??sl_se_get_debug_lock_status_3
    453              decode_debug_status(debug_status, status_word);
   \       0x52   0x9900             LDR      R1,[SP, #+0]
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0x.... 0x....      BL       decode_debug_status
    454            }
    455          
    456            return ret;
   \                     ??sl_se_get_debug_lock_status_3: (+1)
   \       0x5A   0x0030             MOVS     R0,R6
   \                     ??sl_se_get_debug_lock_status_2: (+1)
   \       0x5C   0xB005             ADD      SP,SP,#+20
   \       0x5E   0xBDF0             POP      {R4-R7,PC}
    457            #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    458            uint32_t vse_version = 0;
    459            uint32_t debug_lock_flags = 0;
    460          
    461            // Try to acquire SE lock
    462            sl_status_t status = sli_se_lock_acquire();
    463            if (status != SL_STATUS_OK) {
    464              return status;
    465            }
    466          
    467            // Read SE version from VSE mailbox.
    468            SE_Response_t vse_mbx_status = SE_getVersion(&vse_version);
    469          
    470            // Reading debug lock status is not supported on VSE with versions <= 1.2.2.
    471            if ((vse_version <= 0x1010202UL) || (vse_mbx_status != SE_RESPONSE_OK)) {
    472              sli_se_lock_release();
    473              return SL_STATUS_COMMAND_IS_INVALID;
    474            }
    475          
    476            vse_mbx_status = SE_getConfigStatusBits(&debug_lock_flags);
    477            // Release SE lock
    478            status = sli_se_lock_release();
    479          
    480            if (vse_mbx_status != SE_RESPONSE_OK) {
    481              return sli_se_to_sl_status(vse_mbx_status);
    482            } else if (status != SL_STATUS_OK) {
    483              return status;
    484            }
    485          
    486            decode_debug_status(debug_status, debug_lock_flags);
    487          
    488            return SL_STATUS_OK;
    489            #endif
    490          }

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
    491          
    492          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    493          
    494          /***************************************************************************//**
    495           * Initialize SE OTP configuration.
    496           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    497          sl_status_t sl_se_init_otp(sl_se_command_context_t *cmd_ctx,
    498                                     sl_se_otp_init_t *otp_init)
    499          {
   \                     sl_se_init_otp: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB09F             SUB      SP,SP,#+124
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    500            if (cmd_ctx == NULL || otp_init == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??sl_se_init_otp_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??sl_se_init_otp_1
    501              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_init_otp_0: (+1)
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE0C8             B.N      ??sl_se_init_otp_2
    502            }
    503          
    504            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_init_otp_1: (+1)
   \       0x14   0x0027             MOVS     R7,R4
    505            uint32_t mcu_settings_flags = 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x9000             STR      R0,[SP, #+0]
    506          
    507            sl_status_t status;
    508          
    509            if (otp_init->enable_secure_boot) {
   \       0x1A   0x7828             LDRB     R0,[R5, #+0]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD00E             BEQ.N    ??sl_se_init_otp_3
    510              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE;
   \       0x20   0x9800             LDR      R0,[SP, #+0]
   \       0x22   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x26   0x9000             STR      R0,[SP, #+0]
    511          
    512              // Check for installed boot pubkey before OTP initialization
    513              uint8_t pubkey[64];
    514              status =
    515                sl_se_read_pubkey(cmd_ctx, SL_SE_KEY_TYPE_IMMUTABLE_BOOT, &pubkey, 64);
   \       0x28   0x2340             MOVS     R3,#+64
   \       0x2A   0xAA0F             ADD      R2,SP,#+60
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       sl_se_read_pubkey
   \       0x34   0x0006             MOVS     R6,R0
    516              if (status != SL_STATUS_OK) {
   \       0x36   0x2E00             CMP      R6,#+0
   \       0x38   0xD001             BEQ.N    ??sl_se_init_otp_3
    517                return SL_STATUS_ABORT;
   \       0x3A   0x2006             MOVS     R0,#+6
   \       0x3C   0xE0B3             B.N      ??sl_se_init_otp_2
    518              }
    519            }
    520            if (otp_init->verify_secure_boot_certificate) {
   \                     ??sl_se_init_otp_3: (+1)
   \       0x3E   0x7868             LDRB     R0,[R5, #+1]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD003             BEQ.N    ??sl_se_init_otp_4
    521              mcu_settings_flags |=
    522                SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE;
   \       0x44   0x9800             LDR      R0,[SP, #+0]
   \       0x46   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \       0x4A   0x9000             STR      R0,[SP, #+0]
    523            }
    524            if (otp_init->enable_anti_rollback) {
   \                     ??sl_se_init_otp_4: (+1)
   \       0x4C   0x78A8             LDRB     R0,[R5, #+2]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD003             BEQ.N    ??sl_se_init_otp_5
    525              // Verify firmware compatibility before enabling anti-rollback
    526              #if defined(SLI_SE_MAJOR_VERSION_ONE)
    527              uint16_t part_number = SYSTEM_GetPartNumber();
    528              if (part_number == 1010 || part_number == 1020) {
    529                if (SYSTEM_GetProdRev() < 16) {
    530                  sl_se_status_t se_status;
    531                  status = sl_se_get_status(cmd_ctx, &se_status);
    532                  if ((status != SL_STATUS_OK)
    533                      || (se_status.se_fw_version < 0x00010201)) {
    534                    // If the following error is returned, the SE firmware version
    535                    // needs to be upgraded to v1.2.1 or higher before enabling
    536                    // anti-rollback.
    537                    EFM_ASSERT(false);
    538                    return SL_STATUS_ABORT;
    539                  }
    540                }
    541              }
    542              #endif
    543          
    544              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK;
   \       0x52   0x9800             LDR      R0,[SP, #+0]
   \       0x54   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \       0x58   0x9000             STR      R0,[SP, #+0]
    545            }
    546            if (otp_init->secure_boot_page_lock_narrow) {
   \                     ??sl_se_init_otp_5: (+1)
   \       0x5A   0x78E8             LDRB     R0,[R5, #+3]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD003             BEQ.N    ??sl_se_init_otp_6
    547              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW;
   \       0x60   0x9800             LDR      R0,[SP, #+0]
   \       0x62   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \       0x66   0x9000             STR      R0,[SP, #+0]
    548            }
    549            if (otp_init->secure_boot_page_lock_full) {
   \                     ??sl_se_init_otp_6: (+1)
   \       0x68   0x7928             LDRB     R0,[R5, #+4]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD003             BEQ.N    ??sl_se_init_otp_7
    550              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL;
   \       0x6E   0x9800             LDR      R0,[SP, #+0]
   \       0x70   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \       0x74   0x9000             STR      R0,[SP, #+0]
    551            }
    552          
    553            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    554            static struct {
    555              uint8_t levels[SL_SE_TAMPER_SIGNAL_NUM_SIGNALS / 2];
    556              uint8_t period;
    557              uint8_t threshold;
    558              uint8_t flags;
    559              uint8_t reset_threshold;
    560            } otp_tamper_settings;
    561          
    562            // Check for reserved sources
    563            if ((otp_init->tamper_levels[SL_SE_TAMPER_SIGNAL_RESERVED_1] != SL_SE_TAMPER_LEVEL_IGNORE)
    564                || (otp_init->tamper_levels[SL_SE_TAMPER_SIGNAL_RESERVED_2] != SL_SE_TAMPER_LEVEL_IGNORE)
    565                || (otp_init->tamper_levels[SL_SE_TAMPER_SIGNAL_RESERVED_3] != SL_SE_TAMPER_LEVEL_IGNORE)
    566                || (otp_init->tamper_levels[SL_SE_TAMPER_SIGNAL_RESERVED_4] != SL_SE_TAMPER_LEVEL_IGNORE)) {
   \                     ??sl_se_init_otp_7: (+1)
   \       0x76   0x7968             LDRB     R0,[R5, #+5]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD108             BNE.N    ??sl_se_init_otp_8
   \       0x7C   0x7A28             LDRB     R0,[R5, #+8]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD105             BNE.N    ??sl_se_init_otp_8
   \       0x82   0x7AE8             LDRB     R0,[R5, #+11]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD102             BNE.N    ??sl_se_init_otp_8
   \       0x88   0x7CA8             LDRB     R0,[R5, #+18]
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD001             BEQ.N    ??sl_se_init_otp_9
    567              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_init_otp_8: (+1)
   \       0x8E   0x2021             MOVS     R0,#+33
   \       0x90   0xE089             B.N      ??sl_se_init_otp_2
    568            }
    569          
    570            // Combine tamper levels, two per byte
    571            for (size_t i = 0; i < SL_SE_TAMPER_SIGNAL_NUM_SIGNALS; i += 2) {
   \                     ??sl_se_init_otp_9: (+1)
   \       0x92   0x2100             MOVS     R1,#+0
   \                     ??sl_se_init_otp_10: (+1)
   \       0x94   0x2920             CMP      R1,#+32
   \       0x96   0xD223             BCS.N    ??sl_se_init_otp_11
    572              // Check for reserved levels
    573              for (size_t offset = 0; offset < 2; ++offset) {
   \       0x98   0x2200             MOVS     R2,#+0
   \                     ??sl_se_init_otp_12: (+1)
   \       0x9A   0x2A02             CMP      R2,#+2
   \       0x9C   0xD20D             BCS.N    ??sl_se_init_otp_13
    574                switch (otp_init->tamper_levels[i + offset]) {
   \       0x9E   0x1850             ADDS     R0,R2,R1
   \       0xA0   0x4428             ADD      R0,R5,R0
   \       0xA2   0x7940             LDRB     R0,[R0, #+5]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0x2802             CMP      R0,#+2
   \       0xA8   0xD903             BLS.N    ??sl_se_init_otp_14
   \       0xAA   0x1F00             SUBS     R0,R0,#+4
   \       0xAC   0xD001             BEQ.N    ??sl_se_init_otp_14
   \       0xAE   0x1EC0             SUBS     R0,R0,#+3
   \       0xB0   0xD101             BNE.N    ??sl_se_init_otp_15
    575                  case SL_SE_TAMPER_LEVEL_IGNORE:
    576                  case SL_SE_TAMPER_LEVEL_INTERRUPT:
    577                  case SL_SE_TAMPER_LEVEL_FILTER:
    578                  case SL_SE_TAMPER_LEVEL_RESET:
    579                  case SL_SE_TAMPER_LEVEL_PERMANENTLY_ERASE_OTP:
    580                    break;
   \                     ??sl_se_init_otp_14: (+1)
   \       0xB2   0x1C52             ADDS     R2,R2,#+1
   \       0xB4   0xE7F1             B.N      ??sl_se_init_otp_12
    581                  default:
    582                    return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_init_otp_15: (+1)
   \       0xB6   0x2021             MOVS     R0,#+33
   \       0xB8   0xE075             B.N      ??sl_se_init_otp_2
    583                }
    584              }
    585          
    586              otp_tamper_settings.levels[i / 2] = (otp_init->tamper_levels[i] & 0x7)
    587                                                  | ((otp_init->tamper_levels[i + 1] & 0x7) << 4);
   \                     ??sl_se_init_otp_13: (+1)
   \       0xBA   0xEB05 0x0001      ADD      R0,R5,R1
   \       0xBE   0x7940             LDRB     R0,[R0, #+5]
   \       0xC0   0xF010 0x0007      ANDS     R0,R0,#0x7
   \       0xC4   0xEB05 0x0201      ADD      R2,R5,R1
   \       0xC8   0x7992             LDRB     R2,[R2, #+6]
   \       0xCA   0x0112             LSLS     R2,R2,#+4
   \       0xCC   0xF012 0x0270      ANDS     R2,R2,#0x70
   \       0xD0   0x4310             ORRS     R0,R2,R0
   \       0xD2   0x.... 0x....      LDR.W    R3,??DataTable31_16
   \       0xD6   0x000A             MOVS     R2,R1
   \       0xD8   0x0852             LSRS     R2,R2,#+1
   \       0xDA   0x5498             STRB     R0,[R3, R2]
    588            }
   \       0xDC   0x1C89             ADDS     R1,R1,#+2
   \       0xDE   0xE7D9             B.N      ??sl_se_init_otp_10
    589            // Limit period and threshold input
    590            otp_tamper_settings.period = otp_init->tamper_filter_period & 0x1f;
   \                     ??sl_se_init_otp_11: (+1)
   \       0xE0   0x.... 0x....      LDR.W    R1,??DataTable31_16
   \       0xE4   0xF895 0x0025      LDRB     R0,[R5, #+37]
   \       0xE8   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \       0xEC   0x7408             STRB     R0,[R1, #+16]
    591            otp_tamper_settings.threshold = otp_init->tamper_filter_threshold & 0x7;
   \       0xEE   0xF895 0x0026      LDRB     R0,[R5, #+38]
   \       0xF2   0xF010 0x0007      ANDS     R0,R0,#0x7
   \       0xF6   0x7448             STRB     R0,[R1, #+17]
    592          
    593            #if !defined(SLI_SE_TAMPER_FLAG_KEEP_TAMPER_ALIVE_AVAILABLE)
    594            if ((otp_init->tamper_flags & SL_SE_TAMPER_FLAG_KEEP_TAMPER_ALIVE_DURING_SLEEP)
    595                == SL_SE_TAMPER_FLAG_KEEP_TAMPER_ALIVE_DURING_SLEEP) {
    596              return SL_STATUS_INVALID_PARAMETER;
    597            }
    598            #endif
    599            otp_tamper_settings.flags = otp_init->tamper_flags;
   \       0xF8   0xF895 0x0027      LDRB     R0,[R5, #+39]
   \       0xFC   0x7488             STRB     R0,[R1, #+18]
    600            otp_tamper_settings.reset_threshold = otp_init->tamper_reset_threshold;
   \       0xFE   0xF895 0x0028      LDRB     R0,[R5, #+40]
   \      0x102   0x74C8             STRB     R0,[R1, #+19]
    601            #else
    602            static struct otp_tamper_settings {
    603              uint8_t reserved1[16];
    604              uint8_t reserved2[2];
    605              uint8_t reserved3[2];
    606            } otp_tamper_settings = {
    607              { 0x00 },
    608              { 0xFF, 0xFF },
    609              { 0x00 }
    610            };
    611            #endif
    612          
    613            // Find parity word
    614            volatile uint32_t parity = 0;
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0x9001             STR      R0,[SP, #+4]
    615            parity = parity ^ mcu_settings_flags;
   \      0x108   0x9A01             LDR      R2,[SP, #+4]
   \      0x10A   0x9800             LDR      R0,[SP, #+0]
   \      0x10C   0x4042             EORS     R2,R0,R2
   \      0x10E   0x9201             STR      R2,[SP, #+4]
    616            for (size_t i = 0; i < 5; i++) {
   \      0x110   0x2300             MOVS     R3,#+0
   \                     ??sl_se_init_otp_16: (+1)
   \      0x112   0x2B05             CMP      R3,#+5
   \      0x114   0xD206             BCS.N    ??sl_se_init_otp_17
    617              parity = parity ^ ((uint32_t*)(&otp_tamper_settings))[i];
   \      0x116   0x9A01             LDR      R2,[SP, #+4]
   \      0x118   0xF851 0x0023      LDR      R0,[R1, R3, LSL #+2]
   \      0x11C   0x4042             EORS     R2,R0,R2
   \      0x11E   0x9201             STR      R2,[SP, #+4]
    618            }
   \      0x120   0x1C5B             ADDS     R3,R3,#+1
   \      0x122   0xE7F6             B.N      ??sl_se_init_otp_16
    619          
    620            // SE command structures
    621            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_INIT_OTP);
   \                     ??sl_se_init_otp_17: (+1)
   \      0x124   0x.... 0x....      LDR.W    R0,??DataTable31_17
   \      0x128   0x6020             STR      R0,[R4, #+0]
   \      0x12A   0x2000             MOVS     R0,#+0
   \      0x12C   0x6060             STR      R0,[R4, #+4]
   \      0x12E   0x2000             MOVS     R0,#+0
   \      0x130   0x60A0             STR      R0,[R4, #+8]
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x61E0             STR      R0,[R4, #+28]
    622          
    623            volatile uint32_t parameters[2] = {
    624              parity,
    625              sizeof(mcu_settings_flags)
    626              + sizeof(otp_tamper_settings)
    627            };
   \      0x136   0xAA0D             ADD      R2,SP,#+52
   \      0x138   0x.... 0x....      LDR.W    R0,??DataTable31_18
   \      0x13C   0xE9D0 0x1300      LDRD     R1,R3,[R0, #+0]
   \      0x140   0xE9C2 0x1300      STRD     R1,R3,[R2, #+0]
   \      0x144   0xAA02             ADD      R2,SP,#+8
   \      0x146   0xA80D             ADD      R0,SP,#+52
   \      0x148   0xE9D0 0x3100      LDRD     R3,R1,[R0, #+0]
   \      0x14C   0xE9C2 0x3100      STRD     R3,R1,[R2, #+0]
   \      0x150   0x9801             LDR      R0,[SP, #+4]
   \      0x152   0x9002             STR      R0,[SP, #+8]
    628            SE_DataTransfer_t parameters_data = SE_DATATRANSFER_DEFAULT(&parameters, 8);
   \      0x154   0xF10D 0x0C28      ADD      R12,SP,#+40
   \      0x158   0x.... 0x....      LDR.W    R0,??DataTable31_19
   \      0x15C   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x160   0xE88C 0x000E      STM      R12,{R1-R3}
   \      0x164   0xA802             ADD      R0,SP,#+8
   \      0x166   0x900A             STR      R0,[SP, #+40]
    629            SE_addDataInput(se_cmd, &parameters_data);
   \      0x168   0xA90A             ADD      R1,SP,#+40
   \      0x16A   0x0038             MOVS     R0,R7
   \      0x16C   0x.... 0x....      BL       SE_addDataInput
    630          
    631            SE_DataTransfer_t mcu_settings_flags_data =
    632              SE_DATATRANSFER_DEFAULT((volatile void *)&mcu_settings_flags, sizeof(mcu_settings_flags));
   \      0x170   0xAB07             ADD      R3,SP,#+28
   \      0x172   0x.... 0x....      LDR.W    R12,??DataTable31_20
   \      0x176   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x17A   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x17E   0x4668             MOV      R0,SP
   \      0x180   0x9007             STR      R0,[SP, #+28]
    633            SE_addDataInput(se_cmd, &mcu_settings_flags_data);
   \      0x182   0xA907             ADD      R1,SP,#+28
   \      0x184   0x0038             MOVS     R0,R7
   \      0x186   0x.... 0x....      BL       SE_addDataInput
    634          
    635            SE_DataTransfer_t tamper_settings_data =
    636              SE_DATATRANSFER_DEFAULT((volatile void *)&otp_tamper_settings, sizeof(otp_tamper_settings));
   \      0x18A   0xAB04             ADD      R3,SP,#+16
   \      0x18C   0x.... 0x....      LDR.W    R12,??DataTable31_21
   \      0x190   0xE89C 0x0007      LDM      R12,{R0-R2}
   \      0x194   0xE883 0x0007      STM      R3,{R0-R2}
    637            SE_addDataInput(se_cmd, &tamper_settings_data);
   \      0x198   0xA904             ADD      R1,SP,#+16
   \      0x19A   0x0038             MOVS     R0,R7
   \      0x19C   0x.... 0x....      BL       SE_addDataInput
    638          
    639            return sli_se_execute_and_wait(cmd_ctx);
   \      0x1A0   0x0020             MOVS     R0,R4
   \      0x1A2   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_init_otp_2: (+1)
   \      0x1A6   0xB01F             ADD      SP,SP,#+124
   \      0x1A8   0xBDF0             POP      {R4-R7,PC}
    640          }

   \                                 In section .bss, align 4
   \                     `sl_se_init_otp::otp_tamper_settings`:
   \        0x0                      DS8 20

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0, 24
   \              0x0000'0018

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'920
   \              0x0000'0001  
   \              0x2000'0008

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x....'....        DC32 `sl_se_init_otp::otp_tamper_settings`, 0x1, 536'870'932
   \              0x0000'0001  
   \              0x2000'0014
    641          
    642          /***************************************************************************//**
    643           * Read SE OTP configuration.
    644           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    645          sl_status_t sl_se_read_otp(sl_se_command_context_t *cmd_ctx,
    646                                     sl_se_otp_init_t *otp_settings)
    647          {
   \                     sl_se_read_otp: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    648            if (cmd_ctx == NULL || otp_settings == NULL) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD001             BEQ.N    ??sl_se_read_otp_0
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD101             BNE.N    ??sl_se_read_otp_1
    649              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_read_otp_0: (+1)
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE05D             B.N      ??sl_se_read_otp_2
    650            }
    651          
    652            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_read_otp_1: (+1)
   \       0x14   0x0026             MOVS     R6,R4
    653            sl_status_t status;
    654          
    655            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    656            volatile struct {
    657              uint32_t mcu_settings_flags;
    658              uint8_t levels[SL_SE_TAMPER_SIGNAL_NUM_SIGNALS / 2];
    659              uint8_t period;
    660              uint8_t threshold;
    661              uint8_t flags;
    662              uint8_t reset_threshold;
    663            } otp_raw;
    664            #else
    665            volatile struct {
    666              uint32_t mcu_settings_flags;
    667              uint8_t reserved1[16];
    668              uint8_t reserved2[2];
    669              uint8_t reserved3[2];
    670            } otp_raw;
    671            #endif
    672          
    673            // SE command structures
    674            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_OTP);
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable31_22
   \       0x1A   0x6020             STR      R0,[R4, #+0]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x6060             STR      R0,[R4, #+4]
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x60A0             STR      R0,[R4, #+8]
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x61E0             STR      R0,[R4, #+28]
    675          
    676            SE_DataTransfer_t otp_raw_data =
    677              SE_DATATRANSFER_DEFAULT(&otp_raw, sizeof(otp_raw));
   \       0x28   0xAF06             ADD      R7,SP,#+24
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable31_23
   \       0x2E   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x32   0xE887 0x000E      STM      R7,{R1-R3}
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x9006             STR      R0,[SP, #+24]
    678            SE_addDataOutput(se_cmd, &otp_raw_data);
   \       0x3A   0xA906             ADD      R1,SP,#+24
   \       0x3C   0x0030             MOVS     R0,R6
   \       0x3E   0x.... 0x....      BL       SE_addDataOutput
    679          
    680            status = sli_se_execute_and_wait(cmd_ctx);
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x.... 0x....      BL       sli_se_execute_and_wait
   \       0x48   0x0001             MOVS     R1,R0
    681          
    682            if (status != SL_STATUS_OK) {
   \       0x4A   0x2900             CMP      R1,#+0
   \       0x4C   0xD001             BEQ.N    ??sl_se_read_otp_3
    683              return status;
   \       0x4E   0x0008             MOVS     R0,R1
   \       0x50   0xE03E             B.N      ??sl_se_read_otp_2
    684            }
    685          
    686            otp_settings->enable_secure_boot =
    687              (otp_raw.mcu_settings_flags
    688               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE);
   \                     ??sl_se_read_otp_3: (+1)
   \       0x52   0x9800             LDR      R0,[SP, #+0]
   \       0x54   0x0C00             LSRS     R0,R0,#+16
   \       0x56   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x5A   0x7028             STRB     R0,[R5, #+0]
    689            otp_settings->verify_secure_boot_certificate =
    690              (otp_raw.mcu_settings_flags
    691               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE);
   \       0x5C   0x9800             LDR      R0,[SP, #+0]
   \       0x5E   0x0C40             LSRS     R0,R0,#+17
   \       0x60   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x64   0x7068             STRB     R0,[R5, #+1]
    692            otp_settings->enable_anti_rollback =
    693              (otp_raw.mcu_settings_flags
    694               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK);
   \       0x66   0x9800             LDR      R0,[SP, #+0]
   \       0x68   0x0C80             LSRS     R0,R0,#+18
   \       0x6A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x6E   0x70A8             STRB     R0,[R5, #+2]
    695            otp_settings->secure_boot_page_lock_narrow =
    696              (otp_raw.mcu_settings_flags
    697               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW);
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   \       0x72   0x0CC0             LSRS     R0,R0,#+19
   \       0x74   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x78   0x70E8             STRB     R0,[R5, #+3]
    698            otp_settings->secure_boot_page_lock_full =
    699              (otp_raw.mcu_settings_flags
    700               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL);
   \       0x7A   0x9800             LDR      R0,[SP, #+0]
   \       0x7C   0x0D00             LSRS     R0,R0,#+20
   \       0x7E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x82   0x7128             STRB     R0,[R5, #+4]
    701          
    702            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    703            // Split levels
    704            for (size_t i = 0; i < sizeof(otp_raw.levels); i++) {
   \       0x84   0x2000             MOVS     R0,#+0
   \                     ??sl_se_read_otp_4: (+1)
   \       0x86   0x2810             CMP      R0,#+16
   \       0x88   0xD211             BCS.N    ??sl_se_read_otp_5
    705              otp_settings->tamper_levels[2 * i] = (otp_raw.levels[i]) & 0x7;
   \       0x8A   0x466A             MOV      R2,SP
   \       0x8C   0x4402             ADD      R2,R2,R0
   \       0x8E   0x7912             LDRB     R2,[R2, #+4]
   \       0x90   0xF012 0x0207      ANDS     R2,R2,#0x7
   \       0x94   0xEB05 0x0340      ADD      R3,R5,R0, LSL #+1
   \       0x98   0x715A             STRB     R2,[R3, #+5]
    706              otp_settings->tamper_levels[2 * i + 1] = (otp_raw.levels[i] >> 4) & 0x7;
   \       0x9A   0x466A             MOV      R2,SP
   \       0x9C   0x4402             ADD      R2,R2,R0
   \       0x9E   0x7912             LDRB     R2,[R2, #+4]
   \       0xA0   0xF3C2 0x1302      UBFX     R3,R2,#+4,#+3
   \       0xA4   0xEB05 0x0240      ADD      R2,R5,R0, LSL #+1
   \       0xA8   0x7193             STRB     R3,[R2, #+6]
    707            }
   \       0xAA   0x1C40             ADDS     R0,R0,#+1
   \       0xAC   0xE7EB             B.N      ??sl_se_read_otp_4
    708          
    709            otp_settings->tamper_filter_period = otp_raw.period;
   \                     ??sl_se_read_otp_5: (+1)
   \       0xAE   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \       0xB2   0xF885 0x0025      STRB     R0,[R5, #+37]
    710            otp_settings->tamper_filter_threshold = otp_raw.threshold;
   \       0xB6   0xF89D 0x0015      LDRB     R0,[SP, #+21]
   \       0xBA   0xF885 0x0026      STRB     R0,[R5, #+38]
    711          
    712            otp_settings->tamper_flags = otp_raw.flags;
   \       0xBE   0xF89D 0x0016      LDRB     R0,[SP, #+22]
   \       0xC2   0xF885 0x0027      STRB     R0,[R5, #+39]
    713            otp_settings->tamper_reset_threshold = otp_raw.reset_threshold;
   \       0xC6   0xF89D 0x0017      LDRB     R0,[SP, #+23]
   \       0xCA   0xF885 0x0028      STRB     R0,[R5, #+40]
    714            #endif
    715          
    716            return SL_STATUS_OK;
   \       0xCE   0x2000             MOVS     R0,#+0
   \                     ??sl_se_read_otp_2: (+1)
   \       0xD0   0xB009             ADD      SP,SP,#+36
   \       0xD2   0xBDF0             POP      {R4-R7,PC}
    717          }

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'936
   \              0x0000'0001  
   \              0x2000'0018
    718          
    719          #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    720          
    721          sl_status_t sl_se_init_otp(sl_se_command_context_t *cmd_ctx,
    722                                     sl_se_otp_init_t *otp_init)
    723          {
    724            if (cmd_ctx == NULL || otp_init == NULL) {
    725              return SL_STATUS_INVALID_PARAMETER;
    726            }
    727          
    728            SE_Command_t *se_cmd = &cmd_ctx->command;
    729            volatile uint32_t mcu_settings_flags = 0;
    730          
    731            if (otp_init->enable_secure_boot) {
    732              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE;
    733            }
    734            if (otp_init->verify_secure_boot_certificate) {
    735              mcu_settings_flags |=
    736                SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE;
    737            }
    738            if (otp_init->enable_anti_rollback) {
    739              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK;
    740            }
    741            if (otp_init->secure_boot_page_lock_narrow) {
    742              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW;
    743            }
    744            if (otp_init->secure_boot_page_lock_full) {
    745              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL;
    746            }
    747          
    748            // Find parity word
    749            uint32_t parity = 0;
    750            parity = parity ^ mcu_settings_flags;
    751          
    752            // SE command structures
    753            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_INIT_OTP);
    754          
    755            volatile uint32_t parameters[2] = {
    756              parity,
    757              sizeof(mcu_settings_flags)
    758            };
    759            SE_DataTransfer_t parameters_data = SE_DATATRANSFER_DEFAULT(&parameters, 8);
    760            SE_addDataInput(se_cmd, &parameters_data);
    761          
    762            SE_DataTransfer_t mcu_settings_flags_data =
    763              SE_DATATRANSFER_DEFAULT(&mcu_settings_flags, sizeof(mcu_settings_flags));
    764            SE_addDataInput(se_cmd, &mcu_settings_flags_data);
    765          
    766            SE_executeCommand(se_cmd);
    767            return SL_STATUS_FAIL; // Should never get to this point
    768          }
    769          
    770          /***************************************************************************//**
    771           * Read the OTP firmware version of the SE module.
    772           ******************************************************************************/
    773          sl_status_t sl_se_get_otp_version(sl_se_command_context_t *cmd_ctx,
    774                                            uint32_t *version)
    775          {
    776            if (cmd_ctx == NULL || version == NULL) {
    777              return SL_STATUS_INVALID_PARAMETER;
    778            }
    779          
    780            // Try to acquire SE lock
    781            sl_status_t lock_status = sli_se_lock_acquire();
    782            if (lock_status != SL_STATUS_OK) {
    783              return lock_status;
    784            }
    785          
    786            SE_Response_t otp_status = SE_getOTPVersion(version);
    787          
    788            // Release SE lock
    789            sli_se_lock_release();
    790          
    791            if (otp_status == SE_RESPONSE_OK) {
    792              return SL_STATUS_OK;
    793            }
    794          
    795            return SL_STATUS_NOT_SUPPORTED;
    796          }
    797          
    798          sl_status_t sl_se_read_otp(sl_se_command_context_t *cmd_ctx,
    799                                     sl_se_otp_init_t *otp_settings)
    800          {
    801            if (cmd_ctx == NULL || otp_settings == NULL) {
    802              return SL_STATUS_INVALID_PARAMETER;
    803            }
    804          
    805            // Try to acquire SE lock
    806            sl_status_t status = sli_se_lock_acquire();
    807            if (status != SL_STATUS_OK) {
    808              return status;
    809            }
    810          
    811            uint32_t mcu_settings_flags = 0;
    812            SE_Response_t vse_mbx_status = SE_getConfigStatusBits(&mcu_settings_flags);
    813          
    814            // Release SE lock
    815            status = sli_se_lock_release();
    816          
    817            if (vse_mbx_status != SE_RESPONSE_OK) {
    818              return sli_se_to_sl_status(vse_mbx_status);
    819            } else if (status != SL_STATUS_OK) {
    820              return status;
    821            }
    822          
    823            otp_settings->enable_secure_boot =
    824              (mcu_settings_flags
    825               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    826            otp_settings->verify_secure_boot_certificate =
    827              (mcu_settings_flags
    828               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    829            otp_settings->enable_anti_rollback =
    830              (mcu_settings_flags
    831               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    832            otp_settings->secure_boot_page_lock_narrow =
    833              (mcu_settings_flags
    834               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    835            otp_settings->secure_boot_page_lock_full =
    836              (mcu_settings_flags
    837               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    838          
    839            return SL_STATUS_OK;
    840          }
    841          #endif
    842          
    843          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    844          
    845          /***************************************************************************//**
    846           * Writes data to User Data section in MTP. Write data must be aligned to
    847           * word size and contain a number of bytes that is divisable by four.
    848           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    849          sl_status_t sl_se_write_user_data(sl_se_command_context_t *cmd_ctx,
    850                                            uint32_t offset,
    851                                            void *data,
    852                                            uint32_t num_bytes)
    853          {
   \                     sl_se_write_user_data: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
    854            if (cmd_ctx == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD101             BNE.N    ??sl_se_write_user_data_0
    855              return SL_STATUS_INVALID_PARAMETER;
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xE029             B.N      ??sl_se_write_user_data_1
    856            }
    857          
    858            if (data == NULL && num_bytes > 0UL) {
   \                     ??sl_se_write_user_data_0: (+1)
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD103             BNE.N    ??sl_se_write_user_data_2
   \       0x18   0x2E00             CMP      R6,#+0
   \       0x1A   0xD001             BEQ.N    ??sl_se_write_user_data_2
    859              return SL_STATUS_INVALID_PARAMETER;
   \       0x1C   0x2021             MOVS     R0,#+33
   \       0x1E   0xE023             B.N      ??sl_se_write_user_data_1
    860            }
    861          
    862            // Setup SE command structures
    863            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_write_user_data_2: (+1)
   \       0x20   0x46A0             MOV      R8,R4
    864            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(data, num_bytes);
   \       0x22   0x46EC             MOV      R12,SP
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable31_24
   \       0x28   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x2C   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x30   0x9500             STR      R5,[SP, #+0]
   \       0x32   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \       0x36   0x9002             STR      R0,[SP, #+8]
    865          
    866            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_WRITE_USER_DATA);
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable31_25
   \       0x3C   0x6020             STR      R0,[R4, #+0]
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6060             STR      R0,[R4, #+4]
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x60A0             STR      R0,[R4, #+8]
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x61E0             STR      R0,[R4, #+28]
    867            SE_addDataInput(se_cmd, &in_data);
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0x.... 0x....      BL       SE_addDataInput
    868          
    869            SE_addParameter(se_cmd, offset);
   \       0x52   0x0039             MOVS     R1,R7
   \       0x54   0x4640             MOV      R0,R8
   \       0x56   0x.... 0x....      BL       SE_addParameter
    870            SE_addParameter(se_cmd, num_bytes);
   \       0x5A   0x0031             MOVS     R1,R6
   \       0x5C   0x4640             MOV      R0,R8
   \       0x5E   0x.... 0x....      BL       SE_addParameter
    871          
    872            // Execute and wait
    873            return sli_se_execute_and_wait(cmd_ctx);
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_write_user_data_1: (+1)
   \       0x68   0xB004             ADD      SP,SP,#+16
   \       0x6A   0xE8BD 0x81F0      POP      {R4-R8,PC}
    874          }

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    875          
    876          /***************************************************************************//**
    877           * Erases User Data section in MTP.
    878           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    879          sl_status_t sl_se_erase_user_data(sl_se_command_context_t *cmd_ctx)
    880          {
   \                     sl_se_erase_user_data: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    881            if (cmd_ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??sl_se_erase_user_data_0
    882              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE011             B.N      ??sl_se_erase_user_data_1
    883            }
    884          
    885            // SE command structures
    886            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_erase_user_data_0: (+1)
   \        0xC   0x0025             MOVS     R5,R4
    887            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_ERASE_USER_DATA);
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable31_26
   \       0x12   0x6020             STR      R0,[R4, #+0]
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6060             STR      R0,[R4, #+4]
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x60A0             STR      R0,[R4, #+8]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x61E0             STR      R0,[R4, #+28]
    888          
    889            SE_addParameter(se_cmd, SLI_SE_COMMAND_OPTION_ERASE_UD);
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable31_27
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       SE_addParameter
    890          
    891            // Execute and wait.
    892            return sli_se_execute_and_wait(cmd_ctx);
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_erase_user_data_1: (+1)
   \       0x30   0xBD32             POP      {R1,R4,R5,PC}
    893          }
    894          
    895          /***************************************************************************//**
    896           * Returns the current boot status, versions and system configuration.
    897           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    898          sl_status_t sl_se_get_status(sl_se_command_context_t *cmd_ctx,
    899                                       sl_se_status_t *status)
    900          {
   \                     sl_se_get_status: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
    901            if (cmd_ctx == NULL || status == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD001             BEQ.N    ??sl_se_get_status_0
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD101             BNE.N    ??sl_se_get_status_1
    902              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_status_0: (+1)
   \       0x12   0x2021             MOVS     R0,#+33
   \       0x14   0xE04A             B.N      ??sl_se_get_status_2
    903            }
   \                     ??sl_se_get_status_1: (+1)
   \       0x16   0x2124             MOVS     R1,#+36
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0xA803             ADD      R0,SP,#+12
   \       0x1C   0x.... 0x....      BL       __aeabi_memset
    904          
    905            volatile uint32_t output[9] = { 0 };
    906            SE_Command_t *se_cmd = &cmd_ctx->command;
   \       0x20   0x0027             MOVS     R7,R4
    907          
    908            // SE command structures
    909            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_GET_STATUS);
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable31_28
   \       0x26   0x6020             STR      R0,[R4, #+0]
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6060             STR      R0,[R4, #+4]
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x60A0             STR      R0,[R4, #+8]
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x61E0             STR      R0,[R4, #+28]
    910            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(output, 4 * 9);
   \       0x34   0x466E             MOV      R6,SP
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable31_29
   \       0x3A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x3E   0xE886 0x000E      STM      R6,{R1-R3}
   \       0x42   0xA803             ADD      R0,SP,#+12
   \       0x44   0x9000             STR      R0,[SP, #+0]
    911          
    912            SE_addDataOutput(se_cmd, &out_data);
   \       0x46   0x4669             MOV      R1,SP
   \       0x48   0x0038             MOVS     R0,R7
   \       0x4A   0x.... 0x....      BL       SE_addDataOutput
    913          
    914            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       sli_se_execute_and_wait
   \       0x54   0x0006             MOVS     R6,R0
    915          
    916            if (ret == SL_STATUS_OK) {
   \       0x56   0x2E00             CMP      R6,#+0
   \       0x58   0xD127             BNE.N    ??sl_se_get_status_3
    917              // Tamper status
    918              status->tamper_status = output[0];
   \       0x5A   0x9803             LDR      R0,[SP, #+12]
   \       0x5C   0x61E8             STR      R0,[R5, #+28]
    919              status->tamper_status_raw = output[2];
   \       0x5E   0xF10D 0x080C      ADD      R8,SP,#+12
   \       0x62   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x66   0x6228             STR      R0,[R5, #+32]
    920          
    921              // Update status object
    922              status->boot_status = output[4];
   \       0x68   0x9807             LDR      R0,[SP, #+28]
   \       0x6A   0x6028             STR      R0,[R5, #+0]
    923              status->se_fw_version = output[5];
   \       0x6C   0x9808             LDR      R0,[SP, #+32]
   \       0x6E   0x6068             STR      R0,[R5, #+4]
    924              status->host_fw_version = output[6];
   \       0x70   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \       0x74   0x60A8             STR      R0,[R5, #+8]
    925          
    926              // Decode debug status
    927              decode_debug_status(&status->debug_status, output[7]);
   \       0x76   0xF8D8 0x101C      LDR      R1,[R8, #+28]
   \       0x7A   0xF115 0x000C      ADDS     R0,R5,#+12
   \       0x7E   0x.... 0x....      BL       decode_debug_status
    928          
    929              // Decode secure boot mode
    930              status->secure_boot_enabled =
    931                ((output[8] & 0x1U) && ((output[8] & ~0x1U) == 0));
   \       0x82   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \       0x86   0x07C0             LSLS     R0,R0,#+31
   \       0x88   0xD507             BPL.N    ??sl_se_get_status_4
   \       0x8A   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \       0x8E   0x0840             LSRS     R0,R0,#+1
   \       0x90   0x0040             LSLS     R0,R0,#+1
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD101             BNE.N    ??sl_se_get_status_4
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE000             B.N      ??sl_se_get_status_5
   \                     ??sl_se_get_status_4: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \                     ??sl_se_get_status_5: (+1)
   \       0x9C   0x7628             STRB     R0,[R5, #+24]
    932          
    933          #if (_SILICON_LABS_32B_SERIES_2_CONFIG < 3)
    934              uint32_t active_mode_shift = 16;
    935          #else
    936              uint32_t active_mode_shift = 8;
   \       0x9E   0x2108             MOVS     R1,#+8
    937          #endif
    938              status->active_mode_enabled =
    939                (status->boot_status >> active_mode_shift) & 0x1;
   \       0xA0   0x6828             LDR      R0,[R5, #+0]
   \       0xA2   0x40C8             LSRS     R0,R0,R1
   \       0xA4   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xA8   0x7668             STRB     R0,[R5, #+25]
    940            }
    941          
    942            return ret;
   \                     ??sl_se_get_status_3: (+1)
   \       0xAA   0x0030             MOVS     R0,R6
   \                     ??sl_se_get_status_2: (+1)
   \       0xAC   0xB00C             ADD      SP,SP,#+48
   \       0xAE   0xE8BD 0x81F0      POP      {R4-R8,PC}
    943          }

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'948
   \              0x0000'0001  
   \              0x2000'0024
    944          
    945          /***************************************************************************//**
    946           * Read the serial number of the SE module.
    947           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    948          sl_status_t sl_se_get_serialnumber(sl_se_command_context_t *cmd_ctx,
    949                                             void *serial)
    950          {
   \                     sl_se_get_serialnumber: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    951            if (cmd_ctx == NULL || serial == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sl_se_get_serialnumber_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sl_se_get_serialnumber_1
    952              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_serialnumber_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE018             B.N      ??sl_se_get_serialnumber_2
    953            }
    954          
    955            // SE command structures
    956            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_get_serialnumber_1: (+1)
   \       0x12   0x0026             MOVS     R6,R4
    957            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_SERIAL);
   \       0x14   0xF05F 0x407E      MOVS     R0,#+4261412864
   \       0x18   0x6020             STR      R0,[R4, #+0]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6060             STR      R0,[R4, #+4]
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60A0             STR      R0,[R4, #+8]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61E0             STR      R0,[R4, #+28]
    958            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(serial, 16);
   \       0x26   0x466F             MOV      R7,SP
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable31_30
   \       0x2C   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x30   0xE887 0x000E      STM      R7,{R1-R3}
   \       0x34   0x9500             STR      R5,[SP, #+0]
    959          
    960            SE_addDataOutput(se_cmd, &out_data);
   \       0x36   0x4669             MOV      R1,SP
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0x.... 0x....      BL       SE_addDataOutput
    961          
    962            return sli_se_execute_and_wait(cmd_ctx);
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_get_serialnumber_2: (+1)
   \       0x44   0xBDFE             POP      {R1-R7,PC}
    963          }

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
    964          
    965          /***************************************************************************//**
    966           * Read the OTP firmware version of the SE module.
    967           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    968          sl_status_t sl_se_get_otp_version(sl_se_command_context_t *cmd_ctx,
    969                                            uint32_t *version)
    970          {
   \                     sl_se_get_otp_version: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    971            if (cmd_ctx == NULL || version == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sl_se_get_otp_version_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sl_se_get_otp_version_1
    972              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_otp_version_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE018             B.N      ??sl_se_get_otp_version_2
    973            }
    974          
    975            // SE command structures
    976            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_get_otp_version_1: (+1)
   \       0x12   0x0026             MOVS     R6,R4
    977            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_OTP_VERSION);
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable31_31
   \       0x18   0x6020             STR      R0,[R4, #+0]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6060             STR      R0,[R4, #+4]
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60A0             STR      R0,[R4, #+8]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61E0             STR      R0,[R4, #+28]
    978            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(version, sizeof(uint32_t));
   \       0x26   0x466F             MOV      R7,SP
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable31_32
   \       0x2C   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x30   0xE887 0x000E      STM      R7,{R1-R3}
   \       0x34   0x9500             STR      R5,[SP, #+0]
    979          
    980            SE_addDataOutput(se_cmd, &out_data);
   \       0x36   0x4669             MOV      R1,SP
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0x.... 0x....      BL       SE_addDataOutput
    981          
    982            return sli_se_execute_and_wait(cmd_ctx);
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_get_otp_version_2: (+1)
   \       0x44   0xBDFE             POP      {R1-R7,PC}
    983          }

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
    984          
    985          #if defined(SLI_SE_COMMAND_STATUS_READ_RSTCAUSE_AVAILABLE)
    986          /***************************************************************************//**
    987           * Read the EMU->RSTCAUSE after a tamper reset. This function should be called
    988           * if EMU->RSTCAUSE has been cleared upon boot.
    989           ******************************************************************************/
    990          sl_status_t sl_se_get_reset_cause(sl_se_command_context_t *cmd_ctx,
    991                                            uint32_t *reset_cause)
    992          {
    993            if (cmd_ctx == NULL || reset_cause == NULL) {
    994              return SL_STATUS_INVALID_PARAMETER;
    995            }
    996          
    997            // SE command structures
    998            SE_Command_t *se_cmd = &cmd_ctx->command;
    999            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_READ_RSTCAUSE);
   1000            SE_DataTransfer_t out_data =
   1001              SE_DATATRANSFER_DEFAULT(reset_cause, sizeof(uint32_t));
   1002            SE_addDataOutput(se_cmd, &out_data);
   1003            return sli_se_execute_and_wait(cmd_ctx);
   1004          }
   1005          #endif // SLI_SE_COMMAND_STATUS_READ_RSTCAUSE_AVAILABLE
   1006          
   1007          #if defined(SLI_SE_COMMAND_READ_TAMPER_RESET_CAUSE_AVAILABLE)
   1008          /***************************************************************************//**
   1009           * Read the cached value of the EMU->TAMPERRSTCAUSE register after a tamper
   1010           * reset. This function should be called if EMU->TAMPERRSTCAUSE has been cleared
   1011           * upon boot.
   1012           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1013          sl_status_t sl_se_get_tamper_reset_cause(sl_se_command_context_t *cmd_ctx,
   1014                                                   bool *was_tamper_reset,
   1015                                                   uint32_t *reset_cause)
   1016          {
   \                     sl_se_get_tamper_reset_cause: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1017            if (cmd_ctx == NULL || reset_cause == NULL || was_tamper_reset == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD003             BEQ.N    ??sl_se_get_tamper_reset_cause_0
   \        0xE   0x2E00             CMP      R6,#+0
   \       0x10   0xD001             BEQ.N    ??sl_se_get_tamper_reset_cause_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??sl_se_get_tamper_reset_cause_1
   1018              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_tamper_reset_cause_0: (+1)
   \       0x16   0x2021             MOVS     R0,#+33
   \       0x18   0xE02F             B.N      ??sl_se_get_tamper_reset_cause_2
   1019            }
   1020          
   1021            // Use a local cache to convert from bitfield to integer
   1022            uint32_t tamper_cause_ret = 0;
   \                     ??sl_se_get_tamper_reset_cause_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   1023          
   1024            // SE command structures
   1025            SE_Command_t *se_cmd = &cmd_ctx->command;
   \       0x1E   0x0027             MOVS     R7,R4
   1026            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_TAMPER_RESET_CAUSE);
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable31_33
   \       0x24   0x6020             STR      R0,[R4, #+0]
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6060             STR      R0,[R4, #+4]
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x60A0             STR      R0,[R4, #+8]
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x61E0             STR      R0,[R4, #+28]
   1027            SE_DataTransfer_t out_data =
   1028              SE_DATATRANSFER_DEFAULT(&tamper_cause_ret, sizeof(uint32_t));
   \       0x32   0xF10D 0x0C04      ADD      R12,SP,#+4
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable31_34
   \       0x3A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x3E   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x42   0x4668             MOV      R0,SP
   \       0x44   0x9001             STR      R0,[SP, #+4]
   1029            SE_addDataOutput(se_cmd, &out_data);
   \       0x46   0xA901             ADD      R1,SP,#+4
   \       0x48   0x0038             MOVS     R0,R7
   \       0x4A   0x.... 0x....      BL       SE_addDataOutput
   1030            sl_status_t status = sli_se_execute_and_wait(cmd_ctx);
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       sli_se_execute_and_wait
   1031            if (status != SL_STATUS_OK) {
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD110             BNE.N    ??sl_se_get_tamper_reset_cause_2
   1032              return status;
   1033            }
   1034          
   1035            // Update indication if the reset was because of a tamper event or not.
   1036            *was_tamper_reset = tamper_cause_ret > 0 ? true : false;
   \                     ??sl_se_get_tamper_reset_cause_3: (+1)
   \       0x58   0x9900             LDR      R1,[SP, #+0]
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD001             BEQ.N    ??sl_se_get_tamper_reset_cause_4
   \       0x5E   0x2101             MOVS     R1,#+1
   \       0x60   0xE000             B.N      ??sl_se_get_tamper_reset_cause_5
   \                     ??sl_se_get_tamper_reset_cause_4: (+1)
   \       0x62   0x2100             MOVS     R1,#+0
   \                     ??sl_se_get_tamper_reset_cause_5: (+1)
   \       0x64   0x7029             STRB     R1,[R5, #+0]
   1037          
   1038            // If there is a tamper cause the returned value(tamper_cause_ret) has a
   1039            // single bit set at the position of the tamper cause.
   1040            // Find the position of the set bit and return it.
   1041            uint32_t set_bit_position = 0;
   \       0x66   0x2100             MOVS     R1,#+0
   1042            while (tamper_cause_ret > 1) {
   \                     ??sl_se_get_tamper_reset_cause_6: (+1)
   \       0x68   0x9A00             LDR      R2,[SP, #+0]
   \       0x6A   0x2A02             CMP      R2,#+2
   \       0x6C   0xD304             BCC.N    ??sl_se_get_tamper_reset_cause_7
   1043              tamper_cause_ret >>= 1;
   \       0x6E   0x9A00             LDR      R2,[SP, #+0]
   \       0x70   0x0852             LSRS     R2,R2,#+1
   \       0x72   0x9200             STR      R2,[SP, #+0]
   1044              set_bit_position++;
   \       0x74   0x1C49             ADDS     R1,R1,#+1
   \       0x76   0xE7F7             B.N      ??sl_se_get_tamper_reset_cause_6
   1045            }
   1046          
   1047            *reset_cause = set_bit_position;
   \                     ??sl_se_get_tamper_reset_cause_7: (+1)
   \       0x78   0x6031             STR      R1,[R6, #+0]
   1048            return status;
   \                     ??sl_se_get_tamper_reset_cause_2: (+1)
   \       0x7A   0xB005             ADD      SP,SP,#+20
   \       0x7C   0xBDF0             POP      {R4-R7,PC}
   1049          }

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
   1050          #endif // SLI_SE_COMMAND_READ_TAMPER_RESET_CAUSE_AVAILABLE
   1051          
   1052          /***************************************************************************//**
   1053           * Enables the secure debug functionality.
   1054           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1055          sl_status_t sl_se_enable_secure_debug(sl_se_command_context_t *cmd_ctx)
   1056          {
   \                     sl_se_enable_secure_debug: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1057            if (cmd_ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??sl_se_enable_secure_debug_0
   1058              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE00B             B.N      ??sl_se_enable_secure_debug_1
   1059            }
   1060          
   1061            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_LOCK_ENABLE_SECURE);
   \                     ??sl_se_enable_secure_debug_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable31_35
   \       0x10   0x6020             STR      R0,[R4, #+0]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6060             STR      R0,[R4, #+4]
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x60A0             STR      R0,[R4, #+8]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x61E0             STR      R0,[R4, #+28]
   1062          
   1063            return sli_se_execute_and_wait(cmd_ctx);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_enable_secure_debug_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   1064          }
   1065          
   1066          /***************************************************************************//**
   1067           * Disables the secure debug functionality.
   1068           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1069          sl_status_t sl_se_disable_secure_debug(sl_se_command_context_t *cmd_ctx)
   1070          {
   \                     sl_se_disable_secure_debug: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1071            if (cmd_ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??sl_se_disable_secure_debug_0
   1072              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE00B             B.N      ??sl_se_disable_secure_debug_1
   1073            }
   1074          
   1075            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_LOCK_DISABLE_SECURE);
   \                     ??sl_se_disable_secure_debug_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable31_36
   \       0x10   0x6020             STR      R0,[R4, #+0]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6060             STR      R0,[R4, #+4]
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x60A0             STR      R0,[R4, #+8]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x61E0             STR      R0,[R4, #+28]
   1076          
   1077            return sli_se_execute_and_wait(cmd_ctx);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_disable_secure_debug_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   1078          }
   1079          
   1080          /***************************************************************************//**
   1081           * Set options on the debug interface.
   1082           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1083          sl_status_t sl_se_set_debug_options(sl_se_command_context_t *cmd_ctx,
   1084                                              const sl_se_debug_options_t *debug_options)
   1085          {
   \                     sl_se_set_debug_options: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1086            if (cmd_ctx == NULL || debug_options == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sl_se_set_debug_options_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sl_se_set_debug_options_1
   1087              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_set_debug_options_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE02D             B.N      ??sl_se_set_debug_options_2
   1088            }
   1089          
   1090            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_set_debug_options_1: (+1)
   \       0x12   0x0027             MOVS     R7,R4
   1091            uint32_t restriction_bits = 0x0;
   \       0x14   0x2600             MOVS     R6,#+0
   1092          
   1093            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_SET_RESTRICTIONS);
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable31_37
   \       0x1A   0x6020             STR      R0,[R4, #+0]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x6060             STR      R0,[R4, #+4]
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x60A0             STR      R0,[R4, #+8]
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x61E0             STR      R0,[R4, #+28]
   1094          
   1095            /// Encode restricted debug options parameter.
   1096            restriction_bits |= debug_options->non_secure_invasive_debug ? 0 : 1UL << 0;
   \       0x28   0x7828             LDRB     R0,[R5, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD001             BEQ.N    ??sl_se_set_debug_options_3
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xE000             B.N      ??sl_se_set_debug_options_4
   \                     ??sl_se_set_debug_options_3: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \                     ??sl_se_set_debug_options_4: (+1)
   \       0x34   0x4306             ORRS     R6,R0,R6
   1097            restriction_bits |= debug_options->non_secure_non_invasive_debug ? 0 : 1UL << 1;
   \       0x36   0x7868             LDRB     R0,[R5, #+1]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??sl_se_set_debug_options_5
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xE000             B.N      ??sl_se_set_debug_options_6
   \                     ??sl_se_set_debug_options_5: (+1)
   \       0x40   0x2002             MOVS     R0,#+2
   \                     ??sl_se_set_debug_options_6: (+1)
   \       0x42   0x4306             ORRS     R6,R0,R6
   1098            restriction_bits |= debug_options->secure_invasive_debug ? 0 : 1UL << 2;
   \       0x44   0x78A8             LDRB     R0,[R5, #+2]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD001             BEQ.N    ??sl_se_set_debug_options_7
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xE000             B.N      ??sl_se_set_debug_options_8
   \                     ??sl_se_set_debug_options_7: (+1)
   \       0x4E   0x2004             MOVS     R0,#+4
   \                     ??sl_se_set_debug_options_8: (+1)
   \       0x50   0x4306             ORRS     R6,R0,R6
   1099            restriction_bits |= debug_options->secure_non_invasive_debug ? 0 : 1UL << 3;
   \       0x52   0x78E8             LDRB     R0,[R5, #+3]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD001             BEQ.N    ??sl_se_set_debug_options_9
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xE000             B.N      ??sl_se_set_debug_options_10
   \                     ??sl_se_set_debug_options_9: (+1)
   \       0x5C   0x2008             MOVS     R0,#+8
   \                     ??sl_se_set_debug_options_10: (+1)
   \       0x5E   0x4306             ORRS     R6,R0,R6
   1100          
   1101            SE_addParameter(se_cmd, restriction_bits);
   \       0x60   0x0031             MOVS     R1,R6
   \       0x62   0x0038             MOVS     R0,R7
   \       0x64   0x.... 0x....      BL       SE_addParameter
   1102          
   1103            return sli_se_execute_and_wait(cmd_ctx);
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_set_debug_options_2: (+1)
   \       0x6E   0xBDF2             POP      {R1,R4-R7,PC}
   1104          }
   1105          
   1106          /***************************************************************************//**
   1107           * Performs a device mass erase and debug unlock.
   1108           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1109          sl_status_t sl_se_erase_device(sl_se_command_context_t *cmd_ctx)
   1110          {
   \                     sl_se_erase_device: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1111            if (cmd_ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??sl_se_erase_device_0
   1112              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE00B             B.N      ??sl_se_erase_device_1
   1113            }
   1114          
   1115            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DEVICE_ERASE);
   \                     ??sl_se_erase_device_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable31_38
   \       0x10   0x6020             STR      R0,[R4, #+0]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6060             STR      R0,[R4, #+4]
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x60A0             STR      R0,[R4, #+8]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x61E0             STR      R0,[R4, #+28]
   1116          
   1117            return sli_se_execute_and_wait(cmd_ctx);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_erase_device_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   1118          }
   1119          
   1120          /***************************************************************************//**
   1121           * Disabled device erase functionality.
   1122           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1123          sl_status_t sl_se_disable_device_erase(sl_se_command_context_t *cmd_ctx)
   1124          {
   \                     sl_se_disable_device_erase: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1125            if (cmd_ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??sl_se_disable_device_erase_0
   1126              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE00B             B.N      ??sl_se_disable_device_erase_1
   1127            }
   1128          
   1129            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DEVICE_ERASE_DISABLE);
   \                     ??sl_se_disable_device_erase_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable31_39
   \       0x10   0x6020             STR      R0,[R4, #+0]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6060             STR      R0,[R4, #+4]
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x60A0             STR      R0,[R4, #+8]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x61E0             STR      R0,[R4, #+28]
   1130          
   1131            return sli_se_execute_and_wait(cmd_ctx);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_disable_device_erase_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   1132          }
   1133          
   1134          /***************************************************************************//**
   1135           * Request challenge from SE which can be used to open debug access.
   1136           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1137          sl_status_t sl_se_get_challenge(sl_se_command_context_t *cmd_ctx,
   1138                                          sl_se_challenge_t challenge)
   1139          {
   \                     sl_se_get_challenge: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1140            if (cmd_ctx == NULL || challenge == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sl_se_get_challenge_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sl_se_get_challenge_1
   1141              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_challenge_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE016             B.N      ??sl_se_get_challenge_2
   1142            }
   1143          
   1144            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_get_challenge_1: (+1)
   \       0x12   0x0026             MOVS     R6,R4
   1145            SE_DataTransfer_t out_data =
   1146              SE_DATATRANSFER_DEFAULT(challenge, sizeof(sl_se_challenge_t));
   \       0x14   0x466F             MOV      R7,SP
   \       0x16   0x....             LDR.N    R0,??DataTable31_40
   \       0x18   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x1C   0xE887 0x000E      STM      R7,{R1-R3}
   \       0x20   0x9500             STR      R5,[SP, #+0]
   1147          
   1148            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_GET_CHALLENGE);
   \       0x22   0x....             LDR.N    R0,??DataTable31_41
   \       0x24   0x6020             STR      R0,[R4, #+0]
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6060             STR      R0,[R4, #+4]
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x60A0             STR      R0,[R4, #+8]
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x61E0             STR      R0,[R4, #+28]
   1149          
   1150            SE_addDataOutput(se_cmd, &out_data);
   \       0x32   0x4669             MOV      R1,SP
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0x.... 0x....      BL       SE_addDataOutput
   1151          
   1152            return sli_se_execute_and_wait(cmd_ctx);
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_get_challenge_2: (+1)
   \       0x40   0xBDFE             POP      {R1-R7,PC}
   1153          }

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1154          
   1155          /***************************************************************************//**
   1156           * Invalidate current challenge and make a new challenge.
   1157           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1158          sl_status_t sl_se_roll_challenge(sl_se_command_context_t *cmd_ctx)
   1159          {
   \                     sl_se_roll_challenge: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   1160            sl_se_challenge_t new_challenge;
   1161            if (cmd_ctx == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??sl_se_roll_challenge_0
   1162              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0x2021             MOVS     R0,#+33
   \        0xC   0xE016             B.N      ??sl_se_roll_challenge_1
   1163            }
   1164          
   1165            SE_DataTransfer_t out_data =
   1166              SE_DATATRANSFER_DEFAULT(new_challenge, sizeof(sl_se_challenge_t));
   \                     ??sl_se_roll_challenge_0: (+1)
   \        0xE   0x466D             MOV      R5,SP
   \       0x10   0x....             LDR.N    R0,??DataTable31_42
   \       0x12   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x16   0xE885 0x000E      STM      R5,{R1-R3}
   \       0x1A   0xA803             ADD      R0,SP,#+12
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   1167          
   1168            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_ROLL_CHALLENGE);
   \       0x1E   0x....             LDR.N    R0,??DataTable31_43
   \       0x20   0x6020             STR      R0,[R4, #+0]
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x6060             STR      R0,[R4, #+4]
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x60A0             STR      R0,[R4, #+8]
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x61E0             STR      R0,[R4, #+28]
   1169            SE_addDataOutput(&cmd_ctx->command, &out_data);
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       SE_addDataOutput
   1170          
   1171            return sli_se_execute_and_wait(cmd_ctx);
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_roll_challenge_1: (+1)
   \       0x3C   0xB007             ADD      SP,SP,#+28
   \       0x3E   0xBD30             POP      {R4,R5,PC}
   1172          }

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1173          
   1174          /***************************************************************************//**
   1175           * Unlock debug access using certificate signed with challenge.
   1176           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1177          sl_status_t sl_se_open_debug(sl_se_command_context_t *cmd_ctx,
   1178                                       void *cert, uint32_t len,
   1179                                       const sl_se_debug_options_t *debug_options)
   1180          {
   \                     sl_se_open_debug: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0x001E             MOVS     R6,R3
   1181            if (cmd_ctx == NULL || cert == NULL || debug_options == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD003             BEQ.N    ??sl_se_open_debug_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD001             BEQ.N    ??sl_se_open_debug_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD101             BNE.N    ??sl_se_open_debug_1
   1182              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_open_debug_0: (+1)
   \       0x18   0x2021             MOVS     R0,#+33
   \       0x1A   0xE03F             B.N      ??sl_se_open_debug_2
   1183            }
   1184          
   1185            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_open_debug_1: (+1)
   \       0x1C   0x0027             MOVS     R7,R4
   1186            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(cert, len);
   \       0x1E   0x46EC             MOV      R12,SP
   \       0x20   0x....             LDR.N    R0,??DataTable31_44
   \       0x22   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x26   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x2A   0x9500             STR      R5,[SP, #+0]
   \       0x2C   0xF059 0x5000      ORRS     R0,R9,#0x20000000
   \       0x30   0x9002             STR      R0,[SP, #+8]
   1187            uint32_t unlock_bits = 1UL << 1;  // Always request to unlock debug access port
   \       0x32   0xF05F 0x0802      MOVS     R8,#+2
   1188          
   1189            // SE command structures
   1190            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_OPEN_DEBUG);
   \       0x36   0x....             LDR.N    R0,??DataTable31_45
   \       0x38   0x6020             STR      R0,[R4, #+0]
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x6060             STR      R0,[R4, #+4]
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x60A0             STR      R0,[R4, #+8]
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x61E0             STR      R0,[R4, #+28]
   1191          
   1192            SE_addDataInput(se_cmd, &in_data);
   \       0x46   0x4669             MOV      R1,SP
   \       0x48   0x0038             MOVS     R0,R7
   \       0x4A   0x.... 0x....      BL       SE_addDataInput
   1193          
   1194            /** Encode parameter that holds debug options to unlock. */
   1195            unlock_bits |= debug_options->non_secure_invasive_debug     ? 1UL << 2 : 0;
   \       0x4E   0x7830             LDRB     R0,[R6, #+0]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD001             BEQ.N    ??sl_se_open_debug_3
   \       0x54   0x2004             MOVS     R0,#+4
   \       0x56   0xE000             B.N      ??sl_se_open_debug_4
   \                     ??sl_se_open_debug_3: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \                     ??sl_se_open_debug_4: (+1)
   \       0x5A   0xEA50 0x0808      ORRS     R8,R0,R8
   1196            unlock_bits |= debug_options->non_secure_non_invasive_debug ? 1UL << 3 : 0;
   \       0x5E   0x7870             LDRB     R0,[R6, #+1]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD001             BEQ.N    ??sl_se_open_debug_5
   \       0x64   0x2008             MOVS     R0,#+8
   \       0x66   0xE000             B.N      ??sl_se_open_debug_6
   \                     ??sl_se_open_debug_5: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??sl_se_open_debug_6: (+1)
   \       0x6A   0xEA50 0x0808      ORRS     R8,R0,R8
   1197            unlock_bits |= debug_options->secure_invasive_debug         ? 1UL << 4 : 0;
   \       0x6E   0x78B0             LDRB     R0,[R6, #+2]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD001             BEQ.N    ??sl_se_open_debug_7
   \       0x74   0x2010             MOVS     R0,#+16
   \       0x76   0xE000             B.N      ??sl_se_open_debug_8
   \                     ??sl_se_open_debug_7: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??sl_se_open_debug_8: (+1)
   \       0x7A   0xEA50 0x0808      ORRS     R8,R0,R8
   1198            unlock_bits |= debug_options->secure_non_invasive_debug     ? 1UL << 5 : 0;
   \       0x7E   0x78F0             LDRB     R0,[R6, #+3]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD001             BEQ.N    ??sl_se_open_debug_9
   \       0x84   0x2020             MOVS     R0,#+32
   \       0x86   0xE000             B.N      ??sl_se_open_debug_10
   \                     ??sl_se_open_debug_9: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \                     ??sl_se_open_debug_10: (+1)
   \       0x8A   0xEA50 0x0808      ORRS     R8,R0,R8
   1199          
   1200            SE_addParameter(se_cmd, unlock_bits);
   \       0x8E   0x4641             MOV      R1,R8
   \       0x90   0x0038             MOVS     R0,R7
   \       0x92   0x.... 0x....      BL       SE_addParameter
   1201          
   1202            return sli_se_execute_and_wait(cmd_ctx);
   \       0x96   0x0020             MOVS     R0,R4
   \       0x98   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_open_debug_2: (+1)
   \       0x9C   0xE8BD 0x83FE      POP      {R1-R9,PC}
   1203          }

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1204          
   1205          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
   1206          /***************************************************************************//**
   1207           * Temporarily disable tamper configuration using certificate signed with
   1208           * challenge.
   1209           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1210          sl_status_t sl_se_disable_tamper(sl_se_command_context_t *cmd_ctx,
   1211                                           void *cert,
   1212                                           uint32_t len,
   1213                                           sl_se_tamper_signals_t tamper_signals)
   1214          {
   \                     sl_se_disable_tamper: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1215            if (cmd_ctx == NULL || cert == NULL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD001             BEQ.N    ??sl_se_disable_tamper_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD101             BNE.N    ??sl_se_disable_tamper_1
   1216              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_disable_tamper_0: (+1)
   \       0x14   0x2021             MOVS     R0,#+33
   \       0x16   0xE01D             B.N      ??sl_se_disable_tamper_2
   1217            }
   1218          
   1219            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_disable_tamper_1: (+1)
   \       0x18   0x46A0             MOV      R8,R4
   1220            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(cert, len);
   \       0x1A   0x46EC             MOV      R12,SP
   \       0x1C   0x....             LDR.N    R0,??DataTable31_46
   \       0x1E   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x22   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x26   0x9500             STR      R5,[SP, #+0]
   \       0x28   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \       0x2C   0x9002             STR      R0,[SP, #+8]
   1221          
   1222            // SE command structures
   1223            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DISABLE_TAMPER);
   \       0x2E   0x....             LDR.N    R0,??DataTable31_47
   \       0x30   0x6020             STR      R0,[R4, #+0]
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6060             STR      R0,[R4, #+4]
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x60A0             STR      R0,[R4, #+8]
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x61E0             STR      R0,[R4, #+28]
   1224          
   1225            SE_addDataInput(se_cmd, &in_data);
   \       0x3E   0x4669             MOV      R1,SP
   \       0x40   0x4640             MOV      R0,R8
   \       0x42   0x.... 0x....      BL       SE_addDataInput
   1226          
   1227            SE_addParameter(se_cmd, tamper_signals);
   \       0x46   0x0039             MOVS     R1,R7
   \       0x48   0x4640             MOV      R0,R8
   \       0x4A   0x.... 0x....      BL       SE_addParameter
   1228          
   1229            return sli_se_execute_and_wait(cmd_ctx);
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_disable_tamper_2: (+1)
   \       0x54   0xB004             ADD      SP,SP,#+16
   \       0x56   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1230          }

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1231          
   1232          #endif
   1233          
   1234          /***************************************************************************//**
   1235           * Read size of stored certificates in SE.
   1236           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1237          sl_status_t sl_se_read_cert_size(sl_se_command_context_t *cmd_ctx,
   1238                                           sl_se_cert_size_type_t *cert_size)
   1239          {
   \                     sl_se_read_cert_size: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1240            if (cmd_ctx == NULL || cert_size == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??sl_se_read_cert_size_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD101             BNE.N    ??sl_se_read_cert_size_1
   1241              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_read_cert_size_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xE016             B.N      ??sl_se_read_cert_size_2
   1242            }
   1243            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_read_cert_size_1: (+1)
   \       0x12   0x0026             MOVS     R6,R4
   1244          
   1245            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_USER_CERT_SIZE);
   \       0x14   0x....             LDR.N    R0,??DataTable31_48
   \       0x16   0x6020             STR      R0,[R4, #+0]
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6060             STR      R0,[R4, #+4]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x60A0             STR      R0,[R4, #+8]
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x61E0             STR      R0,[R4, #+28]
   1246          
   1247            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(cert_size, 12UL);
   \       0x24   0x466F             MOV      R7,SP
   \       0x26   0x....             LDR.N    R0,??DataTable31_49
   \       0x28   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x2C   0xE887 0x000E      STM      R7,{R1-R3}
   \       0x30   0x9500             STR      R5,[SP, #+0]
   1248            SE_addDataOutput(se_cmd, &out_data);
   \       0x32   0x4669             MOV      R1,SP
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0x.... 0x....      BL       SE_addDataOutput
   1249          
   1250            return sli_se_execute_and_wait(cmd_ctx);
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_read_cert_size_2: (+1)
   \       0x40   0xBDFE             POP      {R1-R7,PC}
   1251          }

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C
   1252          
   1253          /***************************************************************************//**
   1254           * Read stored certificates in SE.
   1255           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1256          sl_status_t sl_se_read_cert(sl_se_command_context_t *cmd_ctx,
   1257                                      sl_se_cert_type_t cert_type,
   1258                                      void *cert,
   1259                                      uint32_t num_bytes)
   1260          {
   \                     sl_se_read_cert: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1261            if (cmd_ctx == NULL || cert == NULL || num_bytes == 0UL) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD003             BEQ.N    ??sl_se_read_cert_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD001             BEQ.N    ??sl_se_read_cert_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD101             BNE.N    ??sl_se_read_cert_1
   1262              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_read_cert_0: (+1)
   \       0x18   0x2021             MOVS     R0,#+33
   \       0x1A   0xE033             B.N      ??sl_se_read_cert_2
   1263            }
   1264            SE_Command_t *se_cmd = &cmd_ctx->command;
   \                     ??sl_se_read_cert_1: (+1)
   \       0x1C   0x0027             MOVS     R7,R4
   1265            uint32_t se_cert_type;
   1266          
   1267            switch (cert_type) {
   \       0x1E   0x4648             MOV      R0,R9
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD004             BEQ.N    ??sl_se_read_cert_3
   \       0x26   0xD30C             BCC.N    ??sl_se_read_cert_4
   \       0x28   0x2803             CMP      R0,#+3
   \       0x2A   0xD007             BEQ.N    ??sl_se_read_cert_5
   \       0x2C   0xD303             BCC.N    ??sl_se_read_cert_6
   \       0x2E   0xE008             B.N      ??sl_se_read_cert_4
   1268              case SL_SE_CERT_BATCH:
   1269                se_cert_type = SLI_SE_COMMAND_CERT_BATCH;
   \                     ??sl_se_read_cert_3: (+1)
   \       0x30   0xF44F 0x7880      MOV      R8,#+256
   1270                break;
   \       0x34   0xE007             B.N      ??sl_se_read_cert_7
   1271          
   1272              case SL_SE_CERT_DEVICE_SE:
   1273                se_cert_type = SLI_SE_COMMAND_CERT_SE;
   \                     ??sl_se_read_cert_6: (+1)
   \       0x36   0xF44F 0x7800      MOV      R8,#+512
   1274                break;
   \       0x3A   0xE004             B.N      ??sl_se_read_cert_7
   1275          
   1276              case SL_SE_CERT_DEVICE_HOST:
   1277                se_cert_type = SLI_SE_COMMAND_CERT_HOST;
   \                     ??sl_se_read_cert_5: (+1)
   \       0x3C   0xF44F 0x7840      MOV      R8,#+768
   1278                break;
   \       0x40   0xE001             B.N      ??sl_se_read_cert_7
   1279          
   1280              default:
   1281                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_read_cert_4: (+1)
   \       0x42   0x2021             MOVS     R0,#+33
   \       0x44   0xE01E             B.N      ??sl_se_read_cert_2
   1282                break;
   1283            }
   1284          
   1285            // SE command structures
   1286            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_USER_CERT | se_cert_type);
   \                     ??sl_se_read_cert_7: (+1)
   \       0x46   0x....             LDR.N    R0,??DataTable31_50
   \       0x48   0xEA50 0x0008      ORRS     R0,R0,R8
   \       0x4C   0x6020             STR      R0,[R4, #+0]
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x6060             STR      R0,[R4, #+4]
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x60A0             STR      R0,[R4, #+8]
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x61E0             STR      R0,[R4, #+28]
   1287          
   1288          #if SLI_MINIMUM_REQUIRED_NUMBER_PARAMS == 1
   1289            // One parameter is required, but has no effect
   1290            SE_addParameter(se_cmd, 0);
   \       0x5A   0x2100             MOVS     R1,#+0
   \       0x5C   0x0038             MOVS     R0,R7
   \       0x5E   0x.... 0x....      BL       SE_addParameter
   1291          #endif
   1292          
   1293            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(cert, num_bytes);
   \       0x62   0x46EC             MOV      R12,SP
   \       0x64   0x....             LDR.N    R0,??DataTable31_51
   \       0x66   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x6A   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x6E   0x9500             STR      R5,[SP, #+0]
   \       0x70   0xF056 0x5000      ORRS     R0,R6,#0x20000000
   \       0x74   0x9002             STR      R0,[SP, #+8]
   1294            SE_addDataOutput(se_cmd, &out_data);
   \       0x76   0x4669             MOV      R1,SP
   \       0x78   0x0038             MOVS     R0,R7
   \       0x7A   0x.... 0x....      BL       SE_addDataOutput
   1295          
   1296            return sli_se_execute_and_wait(cmd_ctx);
   \       0x7E   0x0020             MOVS     R0,R4
   \       0x80   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_read_cert_2: (+1)
   \       0x84   0xE8BD 0x83FE      POP      {R1-R9,PC}
   1297          }

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1298          
   1299          /***************************************************************************//**
   1300           * Enter active mode.
   1301           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1302          sl_status_t sl_se_enter_active_mode(sl_se_command_context_t *cmd_ctx)
   1303          {
   \                     sl_se_enter_active_mode: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1304            if (cmd_ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??sl_se_enter_active_mode_0
   1305              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE00B             B.N      ??sl_se_enter_active_mode_1
   1306            }
   1307          
   1308            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_ENTER_ACTIVE_MODE);
   \                     ??sl_se_enter_active_mode_0: (+1)
   \        0xC   0xF05F 0x408A      MOVS     R0,#+1157627904
   \       0x10   0x6020             STR      R0,[R4, #+0]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6060             STR      R0,[R4, #+4]
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x60A0             STR      R0,[R4, #+8]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x61E0             STR      R0,[R4, #+28]
   1309          
   1310            return sli_se_execute_and_wait(cmd_ctx);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_enter_active_mode_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   1311          }
   1312          
   1313          /***************************************************************************//**
   1314           * Exit active mode.
   1315           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1316          sl_status_t sl_se_exit_active_mode(sl_se_command_context_t *cmd_ctx)
   1317          {
   \                     sl_se_exit_active_mode: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1318            if (cmd_ctx == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??sl_se_exit_active_mode_0
   1319              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0xE00A             B.N      ??sl_se_exit_active_mode_1
   1320            }
   1321          
   1322            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_EXIT_ACTIVE_MODE);
   \                     ??sl_se_exit_active_mode_0: (+1)
   \        0xC   0x....             LDR.N    R0,??DataTable31_52
   \        0xE   0x6020             STR      R0,[R4, #+0]
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x6060             STR      R0,[R4, #+4]
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x60A0             STR      R0,[R4, #+8]
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x61E0             STR      R0,[R4, #+28]
   1323          
   1324            return sli_se_execute_and_wait(cmd_ctx);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_exit_active_mode_1: (+1)
   \       0x22   0xBD10             POP      {R4,PC}
   1325          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0x4304'0000        DC32     0x43040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \        0x0   0x4302'0000        DC32     0x43020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \        0x0   0x4303'0000        DC32     0x43030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \        0x0   0x4305'0001        DC32     0x43050001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \        0x0   0x4306'0001        DC32     0x43060001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \        0x0   0x4307'0000        DC32     0x43070000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_5:
   \        0x0   0xFF0B'0001        DC32     0xff0b0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_6:
   \        0x0   0xFF07'0001        DC32     0xff070001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_7:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_8:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_9:
   \        0x0   0xFF08'0001        DC32     0xff080001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_10:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_11:
   \        0x0   0x4308'0000        DC32     0x43080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_12:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_13:
   \        0x0   0x430C'0000        DC32     0x430c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_14:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_15:
   \        0x0   0x4311'0000        DC32     0x43110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_16:
   \        0x0   0x....'....        DC32     `sl_se_init_otp::otp_tamper_settings`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_17:
   \        0x0   0xFF00'0001        DC32     0xff000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_18:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_19:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_20:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_21:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_22:
   \        0x0   0xFE04'0000        DC32     0xfe040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_23:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_24:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_25:
   \        0x0   0x4309'0000        DC32     0x43090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_26:
   \        0x0   0x430A'0000        DC32     0x430a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_27:
   \        0x0   0xDE1E'7EAD        DC32     0xde1e7ead

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_28:
   \        0x0   0xFE01'0000        DC32     0xfe010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_29:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_30:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_31:
   \        0x0   0x4308'0100        DC32     0x43080100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_32:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_33:
   \        0x0   0xFE05'0000        DC32     0xfe050000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_34:
   \        0x0   0x....'....        DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_35:
   \        0x0   0x430D'0000        DC32     0x430d0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_36:
   \        0x0   0x430E'0000        DC32     0x430e0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_37:
   \        0x0   0x4312'0000        DC32     0x43120000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_38:
   \        0x0   0x430F'0000        DC32     0x430f0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_39:
   \        0x0   0x4310'0000        DC32     0x43100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_40:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_41:
   \        0x0   0xFD00'0001        DC32     0xfd000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_42:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_43:
   \        0x0   0xFD00'0101        DC32     0xfd000101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_44:
   \        0x0   0x....'....        DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_45:
   \        0x0   0xFD01'0001        DC32     0xfd010001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_46:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_47:
   \        0x0   0xFD02'0001        DC32     0xfd020001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_48:
   \        0x0   0x43FA'0000        DC32     0x43fa0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_49:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_50:
   \        0x0   0x43FB'0000        DC32     0x43fb0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_51:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_52:
   \        0x0   0x4501'0000        DC32     0x45010000
   1326          
   1327          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)
   1328          
   1329          /// @} (end addtogroup sl_se)
   1330          
   1331          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED) || defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   decode_debug_status
       8   sl_se_apply_debug_lock
         8   -> sli_se_execute_and_wait
      24   sl_se_apply_host_image
        24   -> SE_addParameter
        24   -> sli_se_execute_and_wait
      16   sl_se_apply_se_image
        16   -> SE_addParameter
        16   -> sli_se_execute_and_wait
      24   sl_se_check_host_image
        24   -> SE_addParameter
        24   -> sli_se_execute_and_wait
      16   sl_se_check_se_image
        16   -> SE_addParameter
        16   -> sli_se_execute_and_wait
       8   sl_se_disable_device_erase
         8   -> sli_se_execute_and_wait
       8   sl_se_disable_secure_debug
         8   -> sli_se_execute_and_wait
      40   sl_se_disable_tamper
        40   -> SE_addDataInput
        40   -> SE_addParameter
        40   -> sli_se_execute_and_wait
       8   sl_se_enable_secure_debug
         8   -> sli_se_execute_and_wait
       8   sl_se_enter_active_mode
         8   -> sli_se_execute_and_wait
       8   sl_se_erase_device
         8   -> sli_se_execute_and_wait
      16   sl_se_erase_user_data
        16   -> SE_addParameter
        16   -> sli_se_execute_and_wait
       8   sl_se_exit_active_mode
         8   -> sli_se_execute_and_wait
      32   sl_se_get_challenge
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      40   sl_se_get_debug_lock_status
        40   -> SE_addDataOutput
        40   -> decode_debug_status
        40   -> sli_se_execute_and_wait
      32   sl_se_get_otp_version
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      32   sl_se_get_se_version
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      32   sl_se_get_serialnumber
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      72   sl_se_get_status
        72   -> SE_addDataOutput
        72   -> __aeabi_memset
        72   -> decode_debug_status
        72   -> sli_se_execute_and_wait
      40   sl_se_get_tamper_reset_cause
        40   -> SE_addDataOutput
        40   -> sli_se_execute_and_wait
      40   sl_se_get_upgrade_status_host_image
        40   -> SE_addDataOutput
        40   -> sli_se_execute_and_wait
      40   sl_se_get_upgrade_status_se_image
        40   -> SE_addDataOutput
        40   -> sli_se_execute_and_wait
     144   sl_se_init_otp
       144   -> SE_addDataInput
       144   -> sl_se_read_pubkey
       144   -> sli_se_execute_and_wait
      64   sl_se_init_otp_key
        64   -> SE_addDataInput
        64   -> sli_se_execute_and_wait
      40   sl_se_open_debug
        40   -> SE_addDataInput
        40   -> SE_addParameter
        40   -> sli_se_execute_and_wait
      40   sl_se_read_cert
        40   -> SE_addDataOutput
        40   -> SE_addParameter
        40   -> sli_se_execute_and_wait
      32   sl_se_read_cert_size
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      56   sl_se_read_otp
        56   -> SE_addDataOutput
        56   -> sli_se_execute_and_wait
      48   sl_se_read_pubkey
        48   -> SE_addDataOutput
        48   -> sli_se_execute_and_wait
      40   sl_se_roll_challenge
        40   -> SE_addDataOutput
        40   -> sli_se_execute_and_wait
      24   sl_se_set_debug_options
        24   -> SE_addParameter
        24   -> sli_se_execute_and_wait
      40   sl_se_write_user_data
        40   -> SE_addDataInput
        40   -> SE_addParameter
        40   -> sli_se_execute_and_wait


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_12
       4  ??DataTable31_13
       4  ??DataTable31_14
       4  ??DataTable31_15
       4  ??DataTable31_16
       4  ??DataTable31_17
       4  ??DataTable31_18
       4  ??DataTable31_19
       4  ??DataTable31_2
       4  ??DataTable31_20
       4  ??DataTable31_21
       4  ??DataTable31_22
       4  ??DataTable31_23
       4  ??DataTable31_24
       4  ??DataTable31_25
       4  ??DataTable31_26
       4  ??DataTable31_27
       4  ??DataTable31_28
       4  ??DataTable31_29
       4  ??DataTable31_3
       4  ??DataTable31_30
       4  ??DataTable31_31
       4  ??DataTable31_32
       4  ??DataTable31_33
       4  ??DataTable31_34
       4  ??DataTable31_35
       4  ??DataTable31_36
       4  ??DataTable31_37
       4  ??DataTable31_38
       4  ??DataTable31_39
       4  ??DataTable31_4
       4  ??DataTable31_40
       4  ??DataTable31_41
       4  ??DataTable31_42
       4  ??DataTable31_43
       4  ??DataTable31_44
       4  ??DataTable31_45
       4  ??DataTable31_46
       4  ??DataTable31_47
       4  ??DataTable31_48
       4  ??DataTable31_49
       4  ??DataTable31_5
       4  ??DataTable31_50
       4  ??DataTable31_51
       4  ??DataTable31_52
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
      12  ?_0
      12  ?_1
      12  ?_10
      12  ?_11
      12  ?_12
      12  ?_13
      12  ?_14
      12  ?_15
      12  ?_16
      12  ?_17
      12  ?_18
      12  ?_19
      12  ?_2
      12  ?_20
      12  ?_21
      12  ?_22
      12  ?_3
      12  ?_4
      12  ?_5
      12  ?_6
       8  ?_7
      12  ?_8
      12  ?_9
     150  decode_debug_status
      20  otp_tamper_settings
      38  sl_se_apply_debug_lock
      68  sl_se_apply_host_image
      54  sl_se_apply_se_image
      68  sl_se_check_host_image
      54  sl_se_check_se_image
      38  sl_se_disable_device_erase
      38  sl_se_disable_secure_debug
      90  sl_se_disable_tamper
      38  sl_se_enable_secure_debug
      38  sl_se_enter_active_mode
      38  sl_se_erase_device
      50  sl_se_erase_user_data
      36  sl_se_exit_active_mode
      66  sl_se_get_challenge
      96  sl_se_get_debug_lock_status
      70  sl_se_get_otp_version
      70  sl_se_get_se_version
      70  sl_se_get_serialnumber
     178  sl_se_get_status
     126  sl_se_get_tamper_reset_cause
      96  sl_se_get_upgrade_status_host_image
      96  sl_se_get_upgrade_status_se_image
     426  sl_se_init_otp
     234  sl_se_init_otp_key
     160  sl_se_open_debug
     136  sl_se_read_cert
      66  sl_se_read_cert_size
     212  sl_se_read_otp
     154  sl_se_read_pubkey
      64  sl_se_roll_challenge
     112  sl_se_set_debug_options
     110  sl_se_write_user_data

 
    20 bytes in section .bss
   272 bytes in section .rodata
 3'564 bytes in section .text
 
 3'564 bytes of CODE  memory
   272 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: none
