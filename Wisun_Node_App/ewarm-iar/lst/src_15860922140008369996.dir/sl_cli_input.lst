###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         21/Jan/2025  17:21:05
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\sl_cli_input.c
#    Command line                 =
#        -f
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\obj\src_15860922140008369996.dir\sl_cli_input.o.rsp
#        (C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\sl_cli_input.c
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\lst\src_15860922140008369996.dir
#        --diag_suppress Pa050 -o
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\obj\src_15860922140008369996.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\autogen\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\config\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\config\rail\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\config\wisun\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\.\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\
#        -On --use_c++_inline) --dependencies=n
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\obj\src_15860922140008369996.dir\sl_cli_input.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\lst\src_15860922140008369996.dir\sl_cli_input.lst
#    Object file                  =
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\obj\src_15860922140008369996.dir\sl_cli_input.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\sl_cli_input.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Functions that implement the cli front end. Characters are appended
      4                    to make a command line string.
      5           * @version x.y.z
      6           *******************************************************************************
      7           * # License
      8           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      9           *******************************************************************************
     10           *
     11           * SPDX-License-Identifier: Zlib
     12           *
     13           * The licensor of this software is Silicon Laboratories Inc.
     14           *
     15           * This software is provided 'as-is', without any express or implied
     16           * warranty. In no event will the authors be held liable for any damages
     17           * arising from the use of this software.
     18           *
     19           * Permission is granted to anyone to use this software for any purpose,
     20           * including commercial applications, and to alter it and redistribute it
     21           * freely, subject to the following restrictions:
     22           *
     23           * 1. The origin of this software must not be misrepresented; you must not
     24           *    claim that you wrote the original software. If you use this software
     25           *    in a product, an acknowledgment in the product documentation would be
     26           *    appreciated but is not required.
     27           * 2. Altered source versions must be plainly marked as such, and must not be
     28           *    misrepresented as being the original software.
     29           * 3. This notice may not be removed or altered from any source distribution.
     30           *
     31           ******************************************************************************/
     32          
     33          #include "sl_cli_input.h"
     34          #include "sli_cli_input.h"
     35          #include "sl_cli_command.h"
     36          #include "sli_cli_io.h"
     37          #include "sl_string.h"
     38          #include <stdint.h>
     39          #include <stdbool.h>
     40          #include <stdio.h>
     41          #include <string.h>
     42          
     43          /*******************************************************************************
     44           ***************************   LOCAL MACROS   **********************************
     45           ******************************************************************************/
     46          
     47          #define SL_CLI_ESCAPE_CHAR       (0x1b)
     48          #define SL_CLI_ARROW_CHAR        (0x5b)
     49          #define SL_CLI_UP_ARROW_CHAR     (0x41)
     50          #define SL_CLI_DOWN_ARROW_CHAR   (0x42)
     51          #define SL_CLI_RIGHT_ARROW_CHAR  (0x43)
     52          #define SL_CLI_LEFT_ARROW_CHAR   (0x44)
     53          #define SL_CLI_DELETE_CHAR       (0x7f)
     54          
     55          #if SL_CLI_LOCAL_ECHO
     56          #define input_putchar(c)        sli_cli_io_putchar((c))
     57          #define input_printf(...)       sli_cli_io_printf(__VA_ARGS__)
     58          #else
     59          #define input_putchar(c)        (void)0
     60          #define input_printf(...)       (void)0
     61          #endif
     62          
     63          /*******************************************************************************
     64           ***************************   LOCAL FUNCTIONS   *******************************
     65           ******************************************************************************/
     66          
     67          #if SL_CLI_ADVANCED_INPUT_HANDLING
     68          /***************************************************************************//**
     69           * @brief
     70           *   Move the arrow one position left in the terminal
     71           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     72          static void write_left_arrow(void)
     73          {
   \                     write_left_arrow: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     74            input_putchar('\b');
   \        0x2   0x2008             MOVS     R0,#+8
   \        0x4   0x.... 0x....      BL       sli_cli_io_putchar
     75          }
   \        0x8   0xBD01             POP      {R0,PC}
     76          
     77          /***************************************************************************//**
     78           * @brief
     79           *   Move the arrow one position right in the terminal
     80           *
     81           * @param handle
     82           *   A handle to a CLI instance.
     83           *
     84           * @param position
     85           *   The current position of the cursor. Needed to figure out which letters to
     86           *   overwrite.
     87           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     88          static void write_right_arrow(sl_cli_handle_t handle,
     89                                        int position)
     90          {
   \                     write_right_arrow: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
     91          #if (SL_CLI_LOCAL_ECHO == 0)
     92            (void)handle;
     93            (void)position;
     94          #endif
     95            // Overwrite the next character to move arrow right
     96            input_putchar(handle->input_buffer[position]);
   \        0x6   0x5D28             LDRB     R0,[R5, R4]
   \        0x8   0x.... 0x....      BL       sli_cli_io_putchar
     97          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
     98          #endif // SL_CLI_ADVANCED_INUT_HANDLING
     99          
    100          #if SL_CLI_NUM_HISTORY_BYTES
    101          /***************************************************************************//**
    102           * @brief
    103           *   Get the number of command lines in the history buffer.
    104           *
    105           * @param handle
    106           *   sl_cli_handle_t handle to the CLI.
    107           *
    108           * @return
    109           *   Returns the number of command lines in the history buffer.
    110           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    111          static size_t history_get_count(sl_cli_handle_t handle)
    112          {
   \                     history_get_count: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    113            size_t cnt = 0;
   \        0x4   0x2500             MOVS     R5,#+0
    114          
    115            for (size_t i = 0; i < strlen(handle->history_buf); i++) {
   \        0x6   0x2600             MOVS     R6,#+0
   \                     ??history_get_count_0: (+1)
   \        0x8   0xF114 0x00AC      ADDS     R0,R4,#+172
   \        0xC   0x.... 0x....      BL       strlen
   \       0x10   0x4286             CMP      R6,R0
   \       0x12   0xD20E             BCS.N    ??history_get_count_1
    116              if (handle->history_buf[i] == '\0') {
   \       0x14   0xEB04 0x0006      ADD      R0,R4,R6
   \       0x18   0xF890 0x00AC      LDRB     R0,[R0, #+172]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD008             BEQ.N    ??history_get_count_1
    117                break;
    118              }
    119              if (handle->history_buf[i] == '\n') {
   \                     ??history_get_count_2: (+1)
   \       0x20   0xEB04 0x0006      ADD      R0,R4,R6
   \       0x24   0xF890 0x00AC      LDRB     R0,[R0, #+172]
   \       0x28   0x280A             CMP      R0,#+10
   \       0x2A   0xD100             BNE.N    ??history_get_count_3
    120                cnt++;
   \       0x2C   0x1C6D             ADDS     R5,R5,#+1
    121              }
    122            }
   \                     ??history_get_count_3: (+1)
   \       0x2E   0x1C76             ADDS     R6,R6,#+1
   \       0x30   0xE7EA             B.N      ??history_get_count_0
    123          
    124            return cnt;
   \                     ??history_get_count_1: (+1)
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0xBD70             POP      {R4-R6,PC}
    125          }
    126          
    127          /***************************************************************************//**
    128           * @brief
    129           *   Get the begin and end pointers to a given history position given by the
    130           *   handle variable history_pos.
    131           *
    132           * @param[in, out] handle
    133           *   A handle to a CLI instance.
    134           *
    135           * @param[out] ofs_begin
    136           *   A pointer to a variable that shall receive the history begin offset.
    137           *
    138           * @param[out] ofs_end
    139           *   A pointer to a variable that shall receive the history end offset.
    140           *
    141           * @return
    142           *   Returns true if the history buffer contain data false otherwise.
    143           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    144          static bool history_get_ofs(sl_cli_handle_t handle,
    145                                      size_t *ofs_begin,
    146                                      size_t *ofs_end)
    147          {
   \                     history_get_ofs: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    148            *ofs_begin = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x6028             STR      R0,[R5, #+0]
    149            *ofs_end = 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6030             STR      R0,[R6, #+0]
    150          
    151            if (handle->history_pos == 0) {
   \       0x10   0xF8D4 0x02AC      LDR      R0,[R4, #+684]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??history_get_ofs_0
    152              return false;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE038             B.N      ??history_get_ofs_1
    153            }
    154          
    155            if (strlen(handle->history_buf) == 0) {
   \                     ??history_get_ofs_0: (+1)
   \       0x1C   0xF114 0x00AC      ADDS     R0,R4,#+172
   \       0x20   0x.... 0x....      BL       strlen
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD101             BNE.N    ??history_get_ofs_2
    156              return false;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE030             B.N      ??history_get_ofs_1
    157            }
    158          
    159            // Find the beginning of the string
    160            size_t o = 0;
   \                     ??history_get_ofs_2: (+1)
   \       0x2C   0x2100             MOVS     R1,#+0
    161            for (size_t p = 1; p < handle->history_pos; p++) {
   \       0x2E   0x2001             MOVS     R0,#+1
   \                     ??history_get_ofs_3: (+1)
   \       0x30   0xF8D4 0x22AC      LDR      R2,[R4, #+684]
   \       0x34   0x4290             CMP      R0,R2
   \       0x36   0xD214             BCS.N    ??history_get_ofs_4
    162              for (; o < sizeof(handle->history_buf); o++) {
   \                     ??history_get_ofs_5: (+1)
   \       0x38   0xF5B1 0x7F00      CMP      R1,#+512
   \       0x3C   0xD20F             BCS.N    ??history_get_ofs_6
    163                (*ofs_begin)++;
   \       0x3E   0x682A             LDR      R2,[R5, #+0]
   \       0x40   0x1C52             ADDS     R2,R2,#+1
   \       0x42   0x602A             STR      R2,[R5, #+0]
    164                (*ofs_end)++;
   \       0x44   0x6832             LDR      R2,[R6, #+0]
   \       0x46   0x1C52             ADDS     R2,R2,#+1
   \       0x48   0x6032             STR      R2,[R6, #+0]
    165                if (handle->history_buf[o] == '\n') {
   \       0x4A   0xEB04 0x0201      ADD      R2,R4,R1
   \       0x4E   0xF892 0x20AC      LDRB     R2,[R2, #+172]
   \       0x52   0x2A0A             CMP      R2,#+10
   \       0x54   0xD101             BNE.N    ??history_get_ofs_7
    166                  o++;
   \       0x56   0x1C49             ADDS     R1,R1,#+1
    167                  break;
   \       0x58   0xE001             B.N      ??history_get_ofs_6
    168                }
    169              }
   \                     ??history_get_ofs_7: (+1)
   \       0x5A   0x1C49             ADDS     R1,R1,#+1
   \       0x5C   0xE7EC             B.N      ??history_get_ofs_5
    170            }
   \                     ??history_get_ofs_6: (+1)
   \       0x5E   0x1C40             ADDS     R0,R0,#+1
   \       0x60   0xE7E6             B.N      ??history_get_ofs_3
    171          
    172            // Find the end of the string
    173            for (; o < sizeof(handle->history_buf); o++) {
   \                     ??history_get_ofs_4: (+1)
   \       0x62   0xF5B1 0x7F00      CMP      R1,#+512
   \       0x66   0xD211             BCS.N    ??history_get_ofs_8
    174              if ((handle->history_buf[o] == '\n') || (handle->history_buf[o] == '\0')) {
   \       0x68   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x6C   0xF890 0x00AC      LDRB     R0,[R0, #+172]
   \       0x70   0x280A             CMP      R0,#+10
   \       0x72   0xD005             BEQ.N    ??history_get_ofs_9
   \       0x74   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x78   0xF890 0x00AC      LDRB     R0,[R0, #+172]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD100             BNE.N    ??history_get_ofs_10
    175                break;
   \                     ??history_get_ofs_9: (+1)
   \       0x80   0xE004             B.N      ??history_get_ofs_8
    176              }
    177              (*ofs_end)++;
   \                     ??history_get_ofs_10: (+1)
   \       0x82   0x6830             LDR      R0,[R6, #+0]
   \       0x84   0x1C40             ADDS     R0,R0,#+1
   \       0x86   0x6030             STR      R0,[R6, #+0]
    178            }
   \       0x88   0x1C49             ADDS     R1,R1,#+1
   \       0x8A   0xE7EA             B.N      ??history_get_ofs_4
    179          
    180            return true;
   \                     ??history_get_ofs_8: (+1)
   \       0x8C   0x2001             MOVS     R0,#+1
   \                     ??history_get_ofs_1: (+1)
   \       0x8E   0xBD70             POP      {R4-R6,PC}
    181          }
    182          #endif // SL_CLI_NUM_HISTORY_BYTES
    183          
    184          /*******************************************************************************
    185           **************************   GLOBAL FUNCTIONS   *******************************
    186           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    187          void sl_cli_input_clear(sl_cli_handle_t handle)
    188          {
   \                     sl_cli_input_clear: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    189            memset(handle->input_buffer, '\0', handle->input_size);
   \        0x4   0xF8D4 0x508C      LDR      R5,[R4, #+140]
   \        0x8   0x2600             MOVS     R6,#+0
   \        0xA   0x0027             MOVS     R7,R4
   \        0xC   0x0032             MOVS     R2,R6
   \        0xE   0x0029             MOVS     R1,R5
   \       0x10   0x0038             MOVS     R0,R7
   \       0x12   0x.... 0x....      BL       __aeabi_memset
    190            handle->input_pos = 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF8C4 0x0090      STR      R0,[R4, #+144]
    191            handle->input_len = 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xF8C4 0x0094      STR      R0,[R4, #+148]
    192          }
   \       0x22   0xBDF1             POP      {R0,R4-R7,PC}
    193          
    194          #if SL_CLI_ADVANCED_INPUT_HANDLING

   \                                 In section .text, align 2, keep-with-next
    195          void sl_cli_input_autocomplete(sl_cli_handle_t handle)
    196          {
   \                     sl_cli_input_autocomplete: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xF5AD 0x7D44      SUB      SP,SP,#+784
   \        0x8   0x0004             MOVS     R4,R0
   \        0xA   0x2180             MOVS     R1,#+128
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0xADA4             ADD      R5,SP,#+656
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       __aeabi_memset
    197            char possible_matches[SL_CLI_INPUT_BUFFER_SIZE] = { '\0' };
    198            int input_position;
    199            int input_length;
    200          
    201            int number_of_matches = sl_cli_command_find_matches(handle,
    202                                                                possible_matches, sizeof(possible_matches),
    203                                                                &input_length, &input_position);
   \       0x16   0xA802             ADD      R0,SP,#+8
   \       0x18   0x9000             STR      R0,[SP, #+0]
   \       0x1A   0xAB01             ADD      R3,SP,#+4
   \       0x1C   0x2280             MOVS     R2,#+128
   \       0x1E   0xA9A4             ADD      R1,SP,#+656
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       sl_cli_command_find_matches
   \       0x26   0x0005             MOVS     R5,R0
    204          
    205            // Number of matches is one, write match to buffer and terminal
    206            if (number_of_matches == 1) {
   \       0x28   0x2D01             CMP      R5,#+1
   \       0x2A   0xD154             BNE.N    ??sl_cli_input_autocomplete_0
    207              int length = strlen(possible_matches);
   \       0x2C   0xA8A4             ADD      R0,SP,#+656
   \       0x2E   0x.... 0x....      BL       strlen
   \       0x32   0x4681             MOV      R9,R0
    208              int remaining_length = length - input_length;
   \       0x34   0x9E01             LDR      R6,[SP, #+4]
   \       0x36   0xEBB9 0x0606      SUBS     R6,R9,R6
    209              char *buf_dest = &handle->input_buffer[input_length + input_position];
   \       0x3A   0x9901             LDR      R1,[SP, #+4]
   \       0x3C   0x9802             LDR      R0,[SP, #+8]
   \       0x3E   0x1841             ADDS     R1,R0,R1
   \       0x40   0xEB04 0x0701      ADD      R7,R4,R1
    210              char *buf_src = &possible_matches[input_length];
   \       0x44   0xA9A4             ADD      R1,SP,#+656
   \       0x46   0x9801             LDR      R0,[SP, #+4]
   \       0x48   0xEB01 0x0800      ADD      R8,R1,R0
    211          
    212              while (remaining_length > 0) {
   \                     ??sl_cli_input_autocomplete_1: (+1)
   \       0x4C   0x2E01             CMP      R6,#+1
   \       0x4E   0xDB07             BLT.N    ??sl_cli_input_autocomplete_2
    213                *buf_dest = *buf_src;
   \       0x50   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x54   0x7038             STRB     R0,[R7, #+0]
    214                buf_dest++;
   \       0x56   0x1C7F             ADDS     R7,R7,#+1
    215                buf_src++;
   \       0x58   0xF118 0x0801      ADDS     R8,R8,#+1
    216                remaining_length--;
   \       0x5C   0x1E76             SUBS     R6,R6,#+1
   \       0x5E   0xE7F5             B.N      ??sl_cli_input_autocomplete_1
    217              }
    218          
    219              *buf_dest = '\0';
   \                     ??sl_cli_input_autocomplete_2: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x7038             STRB     R0,[R7, #+0]
    220          
    221              for (int j = handle->input_pos; j < input_position + input_length; j++) {
   \       0x64   0xF8D4 0xA090      LDR      R10,[R4, #+144]
   \                     ??sl_cli_input_autocomplete_3: (+1)
   \       0x68   0x9902             LDR      R1,[SP, #+8]
   \       0x6A   0x9801             LDR      R0,[SP, #+4]
   \       0x6C   0x1841             ADDS     R1,R0,R1
   \       0x6E   0x458A             CMP      R10,R1
   \       0x70   0xDA0C             BGE.N    ??sl_cli_input_autocomplete_4
    222                write_right_arrow(handle, handle->input_pos);
   \       0x72   0xF8D4 0x1090      LDR      R1,[R4, #+144]
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0x.... 0x....      BL       write_right_arrow
    223                handle->input_pos++;
   \       0x7C   0xF8D4 0x0090      LDR      R0,[R4, #+144]
   \       0x80   0x1C40             ADDS     R0,R0,#+1
   \       0x82   0xF8C4 0x0090      STR      R0,[R4, #+144]
    224              }
   \       0x86   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \       0x8A   0xE7ED             B.N      ??sl_cli_input_autocomplete_3
    225              handle->input_len += length - input_length;
   \                     ??sl_cli_input_autocomplete_4: (+1)
   \       0x8C   0xF8D4 0x1094      LDR      R1,[R4, #+148]
   \       0x90   0xEB19 0x0101      ADDS     R1,R9,R1
   \       0x94   0x9801             LDR      R0,[SP, #+4]
   \       0x96   0x1A09             SUBS     R1,R1,R0
   \       0x98   0xF8C4 0x1094      STR      R1,[R4, #+148]
    226              handle->input_pos += length - input_length;
   \       0x9C   0xF8D4 0x1090      LDR      R1,[R4, #+144]
   \       0xA0   0xEB19 0x0101      ADDS     R1,R9,R1
   \       0xA4   0x9801             LDR      R0,[SP, #+4]
   \       0xA6   0x1A09             SUBS     R1,R1,R0
   \       0xA8   0xF8C4 0x1090      STR      R1,[R4, #+144]
    227              buf_src = &possible_matches[input_length];
   \       0xAC   0xA9A4             ADD      R1,SP,#+656
   \       0xAE   0x9801             LDR      R0,[SP, #+4]
   \       0xB0   0xEB01 0x0A00      ADD      R10,R1,R0
    228              remaining_length = length - input_length;
   \       0xB4   0xF8DD 0xB004      LDR      R11,[SP, #+4]
   \       0xB8   0xEBB9 0x0B0B      SUBS     R11,R9,R11
    229              while (remaining_length > 0) {
   \                     ??sl_cli_input_autocomplete_5: (+1)
   \       0xBC   0xF1BB 0x0F01      CMP      R11,#+1
   \       0xC0   0xF2C0 0x80B8      BLT.W    ??sl_cli_input_autocomplete_6
    230                input_putchar(*buf_src);
   \       0xC4   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \       0xC8   0x.... 0x....      BL       sli_cli_io_putchar
    231                buf_src++;
   \       0xCC   0xF11A 0x0A01      ADDS     R10,R10,#+1
    232                remaining_length--;
   \       0xD0   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \       0xD4   0xE7F2             B.N      ??sl_cli_input_autocomplete_5
    233              }
    234          
    235              // Number of matches is larger than one, print list of matches and write
    236              // longest common prefix of these matches to buffer and terminal
    237            } else if (number_of_matches > 1) {
   \                     ??sl_cli_input_autocomplete_0: (+1)
   \       0xD6   0x2D02             CMP      R5,#+2
   \       0xD8   0xF2C0 0x80AC      BLT.W    ??sl_cli_input_autocomplete_6
    238              // Find all the start indexes in possible matches
    239              int i = 0;
   \       0xDC   0xF05F 0x0A00      MOVS     R10,#+0
    240              bool match;
    241              char longest_common_prefix[SL_CLI_INPUT_BUFFER_SIZE];
    242              memset(longest_common_prefix, 0, sizeof(longest_common_prefix));
   \       0xE0   0xF05F 0x0980      MOVS     R9,#+128
   \       0xE4   0x2600             MOVS     R6,#+0
   \       0xE6   0xAF84             ADD      R7,SP,#+528
   \       0xE8   0x0032             MOVS     R2,R6
   \       0xEA   0x4649             MOV      R1,R9
   \       0xEC   0x0038             MOVS     R0,R7
   \       0xEE   0x.... 0x....      BL       __aeabi_memset
    243              int possible_matches_index = 1;
   \       0xF2   0x2701             MOVS     R7,#+1
   \       0xF4   0xF44F 0x7100      MOV      R1,#+512
   \       0xF8   0x2200             MOVS     R2,#+0
   \       0xFA   0xF10D 0x0810      ADD      R8,SP,#+16
   \       0xFE   0x4640             MOV      R0,R8
   \      0x100   0x.... 0x....      BL       __aeabi_memset
    244              int possible_matches_indexes[SL_CLI_INPUT_BUFFER_SIZE] = { 0 };
    245              while (possible_matches[i] != '\0') {
   \                     ??sl_cli_input_autocomplete_7: (+1)
   \      0x104   0xAEA4             ADD      R6,SP,#+656
   \      0x106   0xF816 0x000A      LDRB     R0,[R6, R10]
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD00C             BEQ.N    ??sl_cli_input_autocomplete_8
    246                if (possible_matches[i] == ' ') {
   \      0x10E   0xF816 0x000A      LDRB     R0,[R6, R10]
   \      0x112   0x2820             CMP      R0,#+32
   \      0x114   0xD105             BNE.N    ??sl_cli_input_autocomplete_9
    247                  possible_matches_indexes[possible_matches_index] = i + 1;
   \      0x116   0xF11A 0x0101      ADDS     R1,R10,#+1
   \      0x11A   0xA804             ADD      R0,SP,#+16
   \      0x11C   0xF840 0x1027      STR      R1,[R0, R7, LSL #+2]
    248                  possible_matches_index++;
   \      0x120   0x1C7F             ADDS     R7,R7,#+1
    249                }
    250                i++;
   \                     ??sl_cli_input_autocomplete_9: (+1)
   \      0x122   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x126   0xE7ED             B.N      ??sl_cli_input_autocomplete_7
    251              }
    252              possible_matches_indexes[possible_matches_index] = i;
   \                     ??sl_cli_input_autocomplete_8: (+1)
   \      0x128   0xF10D 0x0910      ADD      R9,SP,#+16
   \      0x12C   0xF849 0xA027      STR      R10,[R9, R7, LSL #+2]
    253              possible_matches_index++;
   \      0x130   0x1C7F             ADDS     R7,R7,#+1
   \      0x132   0x9703             STR      R7,[SP, #+12]
    254          
    255              // Find the longest common prefix of all the matches
    256              i = 0;
   \      0x134   0x2700             MOVS     R7,#+0
    257              char current_match;
    258              int possible_matches_length = strlen(possible_matches);
   \      0x136   0xA8A4             ADD      R0,SP,#+656
   \      0x138   0x.... 0x....      BL       strlen
   \      0x13C   0x4680             MOV      R8,R0
    259              for (int j = 0; j < possible_matches_index; j++) {
   \      0x13E   0x2100             MOVS     R1,#+0
   \                     ??sl_cli_input_autocomplete_10: (+1)
   \      0x140   0x9803             LDR      R0,[SP, #+12]
   \      0x142   0x4281             CMP      R1,R0
   \      0x144   0xDA25             BGE.N    ??sl_cli_input_autocomplete_11
    260                match = true;
   \      0x146   0x2001             MOVS     R0,#+1
   \      0x148   0xF88D 0x0000      STRB     R0,[SP, #+0]
    261                current_match = possible_matches[j];
   \      0x14C   0x5C70             LDRB     R0,[R6, R1]
   \      0x14E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    262                while (possible_matches_indexes[i] != possible_matches_length) {
   \                     ??sl_cli_input_autocomplete_12: (+1)
   \      0x152   0xF859 0x0027      LDR      R0,[R9, R7, LSL #+2]
   \      0x156   0x4540             CMP      R0,R8
   \      0x158   0xD00D             BEQ.N    ??sl_cli_input_autocomplete_13
    263                  if (possible_matches[possible_matches_indexes[i] + j] != current_match) {
   \      0x15A   0xF859 0x0027      LDR      R0,[R9, R7, LSL #+2]
   \      0x15E   0x1808             ADDS     R0,R1,R0
   \      0x160   0x5C32             LDRB     R2,[R6, R0]
   \      0x162   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \      0x166   0x4282             CMP      R2,R0
   \      0x168   0xD003             BEQ.N    ??sl_cli_input_autocomplete_14
    264                    match = false;
   \      0x16A   0x2000             MOVS     R0,#+0
   \      0x16C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    265                    break;
   \      0x170   0xE001             B.N      ??sl_cli_input_autocomplete_13
    266                  }
    267                  i++;
   \                     ??sl_cli_input_autocomplete_14: (+1)
   \      0x172   0x1C7F             ADDS     R7,R7,#+1
   \      0x174   0xE7ED             B.N      ??sl_cli_input_autocomplete_12
    268                }
    269                if (match) {
   \                     ??sl_cli_input_autocomplete_13: (+1)
   \      0x176   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xD006             BEQ.N    ??sl_cli_input_autocomplete_15
    270                  longest_common_prefix[j] = possible_matches[j];
   \      0x17E   0x5C72             LDRB     R2,[R6, R1]
   \      0x180   0xA884             ADD      R0,SP,#+528
   \      0x182   0x5442             STRB     R2,[R0, R1]
    271                } else {
    272                  longest_common_prefix[j] = '\0';
    273                  break;
    274                }
    275                i = 0;
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0x0007             MOVS     R7,R0
   \      0x188   0x1C49             ADDS     R1,R1,#+1
   \      0x18A   0xE7D9             B.N      ??sl_cli_input_autocomplete_10
   \                     ??sl_cli_input_autocomplete_15: (+1)
   \      0x18C   0x2200             MOVS     R2,#+0
   \      0x18E   0xA884             ADD      R0,SP,#+528
   \      0x190   0x5442             STRB     R2,[R0, R1]
    276              }
    277          
    278              // If position does not match input length, move cursor to end of input
    279              for (int j = handle->input_pos; j < input_length; j++) {
   \                     ??sl_cli_input_autocomplete_11: (+1)
   \      0x192   0xF8D4 0x6090      LDR      R6,[R4, #+144]
   \                     ??sl_cli_input_autocomplete_16: (+1)
   \      0x196   0x9801             LDR      R0,[SP, #+4]
   \      0x198   0x4286             CMP      R6,R0
   \      0x19A   0xDA0B             BGE.N    ??sl_cli_input_autocomplete_17
    280                write_right_arrow(handle, handle->input_pos);
   \      0x19C   0xF8D4 0x1090      LDR      R1,[R4, #+144]
   \      0x1A0   0x0020             MOVS     R0,R4
   \      0x1A2   0x.... 0x....      BL       write_right_arrow
    281                handle->input_pos++;
   \      0x1A6   0xF8D4 0x0090      LDR      R0,[R4, #+144]
   \      0x1AA   0x1C40             ADDS     R0,R0,#+1
   \      0x1AC   0xF8C4 0x0090      STR      R0,[R4, #+144]
    282              }
   \      0x1B0   0x1C76             ADDS     R6,R6,#+1
   \      0x1B2   0xE7F0             B.N      ??sl_cli_input_autocomplete_16
    283          
    284              // Print out the list of possible matches
    285              input_printf("\n%s\n%s%s", possible_matches, SL_CLI_PROMPT_STRING,
    286                           handle->input_buffer);
   \                     ??sl_cli_input_autocomplete_17: (+1)
   \      0x1B4   0x0023             MOVS     R3,R4
   \      0x1B6   0x....             ADR.N    R2,??DataTable1
   \      0x1B8   0xA9A4             ADD      R1,SP,#+656
   \      0x1BA   0x.... 0x....      LDR.W    R0,??DataTable2_1
   \      0x1BE   0x.... 0x....      BL       sli_cli_io_printf
    287          
    288              // Update input buffer to longest common prefix
    289              int prefix_length = strlen(longest_common_prefix);
   \      0x1C2   0xA884             ADD      R0,SP,#+528
   \      0x1C4   0x.... 0x....      BL       strlen
   \      0x1C8   0x0006             MOVS     R6,R0
    290              char *buf_dest = &handle->input_buffer[input_length + input_position];
   \      0x1CA   0x9901             LDR      R1,[SP, #+4]
   \      0x1CC   0x9802             LDR      R0,[SP, #+8]
   \      0x1CE   0x1841             ADDS     R1,R0,R1
   \      0x1D0   0xEB04 0x0B01      ADD      R11,R4,R1
    291              char *buf_src = &longest_common_prefix[input_length];
   \      0x1D4   0xA884             ADD      R0,SP,#+528
   \      0x1D6   0x9901             LDR      R1,[SP, #+4]
   \      0x1D8   0x4408             ADD      R0,R0,R1
    292              int  remain_length = prefix_length - input_length;
   \      0x1DA   0x9901             LDR      R1,[SP, #+4]
   \      0x1DC   0x1A71             SUBS     R1,R6,R1
    293              while (remain_length > 0) {
   \                     ??sl_cli_input_autocomplete_18: (+1)
   \      0x1DE   0x2901             CMP      R1,#+1
   \      0x1E0   0xDB11             BLT.N    ??sl_cli_input_autocomplete_19
    294                *buf_dest = *buf_src;
   \      0x1E2   0x7802             LDRB     R2,[R0, #+0]
   \      0x1E4   0xF88B 0x2000      STRB     R2,[R11, #+0]
    295                buf_dest++;
   \      0x1E8   0xF11B 0x0B01      ADDS     R11,R11,#+1
    296                buf_src++;
   \      0x1EC   0x1C40             ADDS     R0,R0,#+1
    297                handle->input_pos++;
   \      0x1EE   0xF8D4 0x2090      LDR      R2,[R4, #+144]
   \      0x1F2   0x1C52             ADDS     R2,R2,#+1
   \      0x1F4   0xF8C4 0x2090      STR      R2,[R4, #+144]
    298                handle->input_len++;
   \      0x1F8   0xF8D4 0x2094      LDR      R2,[R4, #+148]
   \      0x1FC   0x1C52             ADDS     R2,R2,#+1
   \      0x1FE   0xF8C4 0x2094      STR      R2,[R4, #+148]
    299                remain_length--;
   \      0x202   0x1E49             SUBS     R1,R1,#+1
   \      0x204   0xE7EB             B.N      ??sl_cli_input_autocomplete_18
    300              }
    301          
    302              *buf_dest = '\0';
   \                     ??sl_cli_input_autocomplete_19: (+1)
   \      0x206   0x2200             MOVS     R2,#+0
   \      0x208   0xF88B 0x2000      STRB     R2,[R11, #+0]
    303              buf_src = &longest_common_prefix[input_length];
   \      0x20C   0xAA84             ADD      R2,SP,#+528
   \      0x20E   0x9B01             LDR      R3,[SP, #+4]
   \      0x210   0xEB02 0x0903      ADD      R9,R2,R3
    304              remain_length = prefix_length - input_length;
   \      0x214   0xF8DD 0xA004      LDR      R10,[SP, #+4]
   \      0x218   0xEBB6 0x0A0A      SUBS     R10,R6,R10
    305              // Write longest common prefix to terminal
    306              while (remain_length > 0) {
   \                     ??sl_cli_input_autocomplete_20: (+1)
   \      0x21C   0xF1BA 0x0F01      CMP      R10,#+1
   \      0x220   0xDB08             BLT.N    ??sl_cli_input_autocomplete_6
    307                input_putchar(*buf_src);
   \      0x222   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \      0x226   0x.... 0x....      BL       sli_cli_io_putchar
    308                buf_src++;
   \      0x22A   0xF119 0x0901      ADDS     R9,R9,#+1
    309                remain_length--;
   \      0x22E   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \      0x232   0xE7F3             B.N      ??sl_cli_input_autocomplete_20
    310              }
    311            }
    312          }
   \                     ??sl_cli_input_autocomplete_6: (+1)
   \      0x234   0xF50D 0x7D45      ADD      SP,SP,#+788
   \      0x238   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    313          #endif // SL_CLI_ADVANCED_INPUT_HANDLING
    314          
    315          #if SL_CLI_NUM_HISTORY_BYTES

   \                                 In section .text, align 2, keep-with-next
    316          void sli_cli_input_update_history(sl_cli_handle_t handle)
    317          {
   \                     sli_cli_input_update_history: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
    318            while ((sl_strnlen(handle->input_buffer, sizeof(handle->input_buffer)) + 1) > (sizeof(handle->history_buf) - sl_strnlen(handle->history_buf, sizeof(handle->history_buf)))) {
   \                     ??sli_cli_input_update_history_0: (+1)
   \        0x6   0xF44F 0x7100      MOV      R1,#+512
   \        0xA   0xF114 0x00AC      ADDS     R0,R4,#+172
   \        0xE   0x.... 0x....      BL       sl_strnlen
   \       0x12   0x0005             MOVS     R5,R0
   \       0x14   0x2180             MOVS     R1,#+128
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       sl_strnlen
   \       0x1C   0x1C40             ADDS     R0,R0,#+1
   \       0x1E   0xF5D5 0x7500      RSBS     R5,R5,#+512
   \       0x22   0x4285             CMP      R5,R0
   \       0x24   0xD210             BCS.N    ??sli_cli_input_update_history_1
    319              // Remove the oldest history string(s) to make space for the last
    320              size_t history_cnt = history_get_count(handle);
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       history_get_count
   \       0x2C   0x0005             MOVS     R5,R0
    321              size_t ofs_begin, ofs_end;
    322              handle->history_pos = history_cnt;
   \       0x2E   0xF8C4 0x52AC      STR      R5,[R4, #+684]
    323              history_get_ofs(handle, &ofs_begin, &ofs_end);
   \       0x32   0xAA01             ADD      R2,SP,#+4
   \       0x34   0x4669             MOV      R1,SP
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       history_get_ofs
    324              handle->history_buf[ofs_begin] = '\0';
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x9900             LDR      R1,[SP, #+0]
   \       0x40   0x4421             ADD      R1,R4,R1
   \       0x42   0xF881 0x00AC      STRB     R0,[R1, #+172]
   \       0x46   0xE7DE             B.N      ??sli_cli_input_update_history_0
    325            }
    326            // Move the history data to make space for the last
    327            memmove(handle->history_buf + strlen(handle->input_buffer) + 1, handle->history_buf, strlen(handle->history_buf) + 1);
   \                     ??sli_cli_input_update_history_1: (+1)
   \       0x48   0xF114 0x00AC      ADDS     R0,R4,#+172
   \       0x4C   0x.... 0x....      BL       strlen
   \       0x50   0x0006             MOVS     R6,R0
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       strlen
   \       0x58   0x1C76             ADDS     R6,R6,#+1
   \       0x5A   0xF114 0x05AC      ADDS     R5,R4,#+172
   \       0x5E   0x4420             ADD      R0,R4,R0
   \       0x60   0xF110 0x07AD      ADDS     R7,R0,#+173
   \       0x64   0x0032             MOVS     R2,R6
   \       0x66   0x0029             MOVS     R1,R5
   \       0x68   0x0038             MOVS     R0,R7
   \       0x6A   0x.... 0x....      BL       __aeabi_memmove
    328          
    329            // Copy input to history buffer
    330            memcpy(handle->history_buf, handle->input_buffer, strlen(handle->input_buffer));
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0x.... 0x....      BL       strlen
   \       0x74   0x0007             MOVS     R7,R0
   \       0x76   0x46A0             MOV      R8,R4
   \       0x78   0xF114 0x09AC      ADDS     R9,R4,#+172
   \       0x7C   0x003A             MOVS     R2,R7
   \       0x7E   0x4641             MOV      R1,R8
   \       0x80   0x4648             MOV      R0,R9
   \       0x82   0x.... 0x....      BL       __aeabi_memcpy
    331            handle->history_buf[strlen(handle->input_buffer)] = '\n';
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       strlen
   \       0x8C   0xEB04 0x0100      ADD      R1,R4,R0
   \       0x90   0x200A             MOVS     R0,#+10
   \       0x92   0xF881 0x00AC      STRB     R0,[R1, #+172]
    332          
    333            handle->history_pos = 0;
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xF8C4 0x02AC      STR      R0,[R4, #+684]
    334          }
   \       0x9C   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}
    335          

   \                                 In section .text, align 2, keep-with-next
    336          void sl_cli_input_get_history(sl_cli_handle_t handle,
    337                                        int direction)
    338          {
   \                     sl_cli_input_get_history: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000C             MOVS     R4,R1
    339            size_t history_cnt = history_get_count(handle);
   \        0x8   0x0038             MOVS     R0,R7
   \        0xA   0x.... 0x....      BL       history_get_count
   \        0xE   0x0005             MOVS     R5,R0
    340            bool clr_previous = false;
   \       0x10   0x2600             MOVS     R6,#+0
    341          
    342            if (direction == SL_CLI_INPUT_DIRECTION_DOWN) {
   \       0x12   0xF114 0x0F01      CMN      R4,#+1
   \       0x16   0xD10B             BNE.N    ??sl_cli_input_get_history_0
    343              if (handle->history_pos > 0) {
   \       0x18   0xF8D7 0x02AC      LDR      R0,[R7, #+684]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD017             BEQ.N    ??sl_cli_input_get_history_1
    344                (handle->history_pos)--;
   \       0x20   0xF8D7 0x02AC      LDR      R0,[R7, #+684]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0xF8C7 0x02AC      STR      R0,[R7, #+684]
    345                clr_previous = true;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0x0006             MOVS     R6,R0
   \       0x2E   0xE00F             B.N      ??sl_cli_input_get_history_1
    346              }
    347            } else if (direction == SL_CLI_INPUT_DIRECTION_UP) {
   \                     ??sl_cli_input_get_history_0: (+1)
   \       0x30   0x2C01             CMP      R4,#+1
   \       0x32   0xD10C             BNE.N    ??sl_cli_input_get_history_2
    348              if (handle->history_pos < history_cnt) {
   \       0x34   0xF8D7 0x02AC      LDR      R0,[R7, #+684]
   \       0x38   0x42A8             CMP      R0,R5
   \       0x3A   0xD207             BCS.N    ??sl_cli_input_get_history_3
    349                (handle->history_pos)++;
   \       0x3C   0xF8D7 0x02AC      LDR      R0,[R7, #+684]
   \       0x40   0x1C40             ADDS     R0,R0,#+1
   \       0x42   0xF8C7 0x02AC      STR      R0,[R7, #+684]
    350                clr_previous = true;
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0x0006             MOVS     R6,R0
   \       0x4A   0xE001             B.N      ??sl_cli_input_get_history_1
    351              } else {
    352                return;
   \                     ??sl_cli_input_get_history_3: (+1)
   \       0x4C   0xE03D             B.N      ??sl_cli_input_get_history_4
    353              }
    354            } else {
    355              // Invalid input
    356              return;
   \                     ??sl_cli_input_get_history_2: (+1)
   \       0x4E   0xE03C             B.N      ??sl_cli_input_get_history_4
    357            }
    358          
    359            if (handle->history_pos == 0) {
   \                     ??sl_cli_input_get_history_1: (+1)
   \       0x50   0xF8D7 0x02AC      LDR      R0,[R7, #+684]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD101             BNE.N    ??sl_cli_input_get_history_5
    360              clr_previous = true;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0x0006             MOVS     R6,R0
    361            }
    362          
    363            if (clr_previous) {
   \                     ??sl_cli_input_get_history_5: (+1)
   \       0x5C   0x0030             MOVS     R0,R6
   \       0x5E   0xB2C0             UXTB     R0,R0
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD015             BEQ.N    ??sl_cli_input_get_history_6
    364              for (size_t i = 0; i < strlen(handle->input_buffer); i++) {
   \       0x64   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??sl_cli_input_get_history_7: (+1)
   \       0x68   0x0038             MOVS     R0,R7
   \       0x6A   0x.... 0x....      BL       strlen
   \       0x6E   0x4580             CMP      R8,R0
   \       0x70   0xD20B             BCS.N    ??sl_cli_input_get_history_8
    365                input_putchar('\b');
   \       0x72   0x2008             MOVS     R0,#+8
   \       0x74   0x.... 0x....      BL       sli_cli_io_putchar
    366                input_putchar(' ');
   \       0x78   0x2020             MOVS     R0,#+32
   \       0x7A   0x.... 0x....      BL       sli_cli_io_putchar
    367                input_putchar('\b');
   \       0x7E   0x2008             MOVS     R0,#+8
   \       0x80   0x.... 0x....      BL       sli_cli_io_putchar
    368              }
   \       0x84   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x88   0xE7EE             B.N      ??sl_cli_input_get_history_7
    369              sl_cli_input_clear(handle);
   \                     ??sl_cli_input_get_history_8: (+1)
   \       0x8A   0x0038             MOVS     R0,R7
   \       0x8C   0x.... 0x....      BL       sl_cli_input_clear
    370            }
    371          
    372            if (handle->history_pos > 0) {
   \                     ??sl_cli_input_get_history_6: (+1)
   \       0x90   0xF8D7 0x02AC      LDR      R0,[R7, #+684]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD018             BEQ.N    ??sl_cli_input_get_history_9
    373              size_t ofs_begin, ofs_end;
    374              bool found = history_get_ofs(handle, &ofs_begin, &ofs_end);
   \       0x98   0x466A             MOV      R2,SP
   \       0x9A   0xA901             ADD      R1,SP,#+4
   \       0x9C   0x0038             MOVS     R0,R7
   \       0x9E   0x.... 0x....      BL       history_get_ofs
   \       0xA2   0x4680             MOV      R8,R0
    375              if (found) {
   \       0xA4   0x4640             MOV      R0,R8
   \       0xA6   0xB2C0             UXTB     R0,R0
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD00E             BEQ.N    ??sl_cli_input_get_history_9
    376                for (size_t o = ofs_begin; o < ofs_end; o++) {
   \       0xAC   0xF8DD 0x9004      LDR      R9,[SP, #+4]
   \                     ??sl_cli_input_get_history_10: (+1)
   \       0xB0   0x9800             LDR      R0,[SP, #+0]
   \       0xB2   0x4581             CMP      R9,R0
   \       0xB4   0xD209             BCS.N    ??sl_cli_input_get_history_9
    377                  sl_cli_input_char(handle, handle->history_buf[o]);
   \       0xB6   0xEB07 0x0009      ADD      R0,R7,R9
   \       0xBA   0xF890 0x10AC      LDRB     R1,[R0, #+172]
   \       0xBE   0x0038             MOVS     R0,R7
   \       0xC0   0x.... 0x....      BL       sl_cli_input_char
    378                }
   \       0xC4   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0xC8   0xE7F2             B.N      ??sl_cli_input_get_history_10
    379              }
    380            }
    381          }
   \                     ??sl_cli_input_get_history_9: (+1)
   \                     ??sl_cli_input_get_history_4: (+1)
   \       0xCA   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}
    382          #endif // SL_CLI_NUM_HISTORY_BYTES
    383          

   \                                 In section .text, align 2, keep-with-next
    384          bool sl_cli_input_char(sl_cli_handle_t handle,
    385                                 char c)
    386          {
   \                     sl_cli_input_char: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000D             MOVS     R5,R1
    387            int position = handle->input_pos;
   \        0x8   0xF8D9 0x4090      LDR      R4,[R9, #+144]
    388            int length = handle->input_len;
   \        0xC   0xF8D9 0x6094      LDR      R6,[R9, #+148]
    389            bool write_to_buffer = true;
   \       0x10   0x2701             MOVS     R7,#+1
    390            char *input_buffer = handle->input_buffer;
   \       0x12   0x46C8             MOV      R8,R9
    391          
    392            // Interpret the new character based on what the last one was
    393            // First, check if last input was return, and look for a possible trailing
    394            // \n in case of \r\n line endings
    395            if (handle->last_input_type == SL_CLI_INPUT_RETURN && c == '\n') {
   \       0x14   0xF899 0x0098      LDRB     R0,[R9, #+152]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD108             BNE.N    ??sl_cli_input_char_0
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x280A             CMP      R0,#+10
   \       0x22   0xD104             BNE.N    ??sl_cli_input_char_0
    396              // Set handle last input to ordinary, and return false, even though the
    397              // input actually was newline, because the command has already been executed
    398              handle->last_input_type = SL_CLI_INPUT_ORDINARY;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xF889 0x0098      STRB     R0,[R9, #+152]
    399              return false;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xE138             B.N      ??sl_cli_input_char_1
    400            }
    401          
    402            if (handle->last_input_type == SL_CLI_INPUT_ORDINARY
    403                || handle->last_input_type == SL_CLI_INPUT_RETURN) {
   \                     ??sl_cli_input_char_0: (+1)
   \       0x2E   0xF899 0x0098      LDRB     R0,[R9, #+152]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD004             BEQ.N    ??sl_cli_input_char_2
   \       0x36   0xF899 0x0098      LDRB     R0,[R9, #+152]
   \       0x3A   0x2801             CMP      R0,#+1
   \       0x3C   0xF040 0x80E4      BNE.W    ??sl_cli_input_char_3
    404              // Handle cases where the last input was ordinary, or return and above block
    405              // did not exectue
    406              // Start to set new last_input_type
    407              if (c == SL_CLI_ESCAPE_CHAR) {
   \                     ??sl_cli_input_char_2: (+1)
   \       0x40   0x0028             MOVS     R0,R5
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0x281B             CMP      R0,#+27
   \       0x46   0xD104             BNE.N    ??sl_cli_input_char_4
    408                // Escape character. Change handle variable and exit function
    409                handle->last_input_type = SL_CLI_INPUT_ESCAPE;
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0xF889 0x0098      STRB     R0,[R9, #+152]
    410                return false;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xE126             B.N      ??sl_cli_input_char_1
    411              } else if (c == '\r') {
   \                     ??sl_cli_input_char_4: (+1)
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0x280D             CMP      R0,#+13
   \       0x58   0xD103             BNE.N    ??sl_cli_input_char_5
    412                // Return character
    413                handle->last_input_type = SL_CLI_INPUT_RETURN;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0xF889 0x0098      STRB     R0,[R9, #+152]
   \       0x60   0xE002             B.N      ??sl_cli_input_char_6
    414              } else {
    415                // All other cases:
    416                handle->last_input_type = SL_CLI_INPUT_ORDINARY;
   \                     ??sl_cli_input_char_5: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xF889 0x0098      STRB     R0,[R9, #+152]
    417              }
    418          
    419              if (c == '\b') {
   \                     ??sl_cli_input_char_6: (+1)
   \       0x68   0x0028             MOVS     R0,R5
   \       0x6A   0xB2C0             UXTB     R0,R0
   \       0x6C   0x2808             CMP      R0,#+8
   \       0x6E   0xD144             BNE.N    ??sl_cli_input_char_7
    420                // Handle backspace
    421                // Position is at end of non-zero input, write backspace and space and
    422                // another backspace to terminal to remove last character.
    423                // Remove last character from input buffer and decrease handle's length
    424                if (position > 0 && length == position) {
   \       0x70   0x2C01             CMP      R4,#+1
   \       0x72   0xDB10             BLT.N    ??sl_cli_input_char_8
   \       0x74   0x42A6             CMP      R6,R4
   \       0x76   0xD10E             BNE.N    ??sl_cli_input_char_8
    425                  input_putchar('\b');
   \       0x78   0x2008             MOVS     R0,#+8
   \       0x7A   0x.... 0x....      BL       sli_cli_io_putchar
    426                  input_putchar(' ');
   \       0x7E   0x2020             MOVS     R0,#+32
   \       0x80   0x.... 0x....      BL       sli_cli_io_putchar
    427                  input_putchar('\b');
   \       0x84   0x2008             MOVS     R0,#+8
   \       0x86   0x.... 0x....      BL       sli_cli_io_putchar
    428                  position--;
   \       0x8A   0x1E64             SUBS     R4,R4,#+1
    429                  input_buffer[position] = '\0';
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xF808 0x0004      STRB     R0,[R8, R4]
    430                  length = length - 1;
   \       0x92   0x1E76             SUBS     R6,R6,#+1
   \       0x94   0xE02B             B.N      ??sl_cli_input_char_9
    431          
    432                #if SL_CLI_ADVANCED_INPUT_HANDLING
    433                } else if (position > 0 && length > position) {
   \                     ??sl_cli_input_char_8: (+1)
   \       0x96   0x2C01             CMP      R4,#+1
   \       0x98   0xDB25             BLT.N    ??sl_cli_input_char_10
   \       0x9A   0x42B4             CMP      R4,R6
   \       0x9C   0xDA23             BGE.N    ??sl_cli_input_char_10
    434                  // Position is in the middle of the input, so terminal line needs to be
    435                  // cleared, and line needs to be correctly rewritten and arrow correctly
    436                  // positioned
    437                  position--;
   \       0x9E   0x1E64             SUBS     R4,R4,#+1
    438                  input_putchar('\b');
   \       0xA0   0x2008             MOVS     R0,#+8
   \       0xA2   0x.... 0x....      BL       sli_cli_io_putchar
    439                  // Shift input down
    440                  memmove(input_buffer + position, input_buffer + position + 1,
    441                          length - position);
   \       0xA6   0x1B30             SUBS     R0,R6,R4
   \       0xA8   0x9000             STR      R0,[SP, #+0]
   \       0xAA   0xEB08 0x0004      ADD      R0,R8,R4
   \       0xAE   0xF110 0x0B01      ADDS     R11,R0,#+1
   \       0xB2   0xEB08 0x0A04      ADD      R10,R8,R4
   \       0xB6   0x9A00             LDR      R2,[SP, #+0]
   \       0xB8   0x4659             MOV      R1,R11
   \       0xBA   0x4650             MOV      R0,R10
   \       0xBC   0x.... 0x....      BL       __aeabi_memmove
    442                  input_buffer[length] = '\0';
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xF808 0x0006      STRB     R0,[R8, R6]
    443                  // Write out rest of buffer, extra space and backspace
    444                  input_printf("%s \b", input_buffer + position);
   \       0xC6   0xEB08 0x0104      ADD      R1,R8,R4
   \       0xCA   0x....             LDR.N    R0,??DataTable2_2
   \       0xCC   0x.... 0x....      BL       sli_cli_io_printf
    445                  for (int i = length - 1; i > position; i--) {
   \       0xD0   0xF1B6 0x0A01      SUBS     R10,R6,#+1
   \                     ??sl_cli_input_char_11: (+1)
   \       0xD4   0x4554             CMP      R4,R10
   \       0xD6   0xDA04             BGE.N    ??sl_cli_input_char_12
    446                    write_left_arrow();
   \       0xD8   0x.... 0x....      BL       write_left_arrow
    447                  }
   \       0xDC   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \       0xE0   0xE7F8             B.N      ??sl_cli_input_char_11
    448                  length -= 1;
   \                     ??sl_cli_input_char_12: (+1)
   \       0xE2   0x1E76             SUBS     R6,R6,#+1
   \       0xE4   0xE003             B.N      ??sl_cli_input_char_9
    449                #endif // SL_CLI_ADVANCED_INPUT_HANDLING
    450                } else if (position == 0) {
   \                     ??sl_cli_input_char_10: (+1)
   \       0xE6   0x2C00             CMP      R4,#+0
   \       0xE8   0xD101             BNE.N    ??sl_cli_input_char_9
    451                  // Position is at beginning of input, so do nothing
    452                  return false;
   \       0xEA   0x2000             MOVS     R0,#+0
   \       0xEC   0xE0D8             B.N      ??sl_cli_input_char_1
    453                }
    454          
    455                // Update handle's position variable and return
    456                handle->input_pos = position;
   \                     ??sl_cli_input_char_9: (+1)
   \       0xEE   0xF8C9 0x4090      STR      R4,[R9, #+144]
    457                handle->input_len = length;
   \       0xF2   0xF8C9 0x6094      STR      R6,[R9, #+148]
    458                return false;
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0xE0D2             B.N      ??sl_cli_input_char_1
    459          
    460              #if SL_CLI_ADVANCED_INPUT_HANDLING
    461              } else if (c == SL_CLI_DELETE_CHAR) {
   \                     ??sl_cli_input_char_7: (+1)
   \       0xFA   0x0028             MOVS     R0,R5
   \       0xFC   0xB2C0             UXTB     R0,R0
   \       0xFE   0x287F             CMP      R0,#+127
   \      0x100   0xD128             BNE.N    ??sl_cli_input_char_13
    462                // Handle delete
    463                if (length > 0 && position < length) {
   \      0x102   0x2E01             CMP      R6,#+1
   \      0x104   0xDB24             BLT.N    ??sl_cli_input_char_14
   \      0x106   0x42B4             CMP      R4,R6
   \      0x108   0xDA22             BGE.N    ??sl_cli_input_char_14
    464                  // Remove a char from buffer, and print out new buffer
    465                  memmove(input_buffer + position, input_buffer + position + 1,
    466                          length - position);
   \      0x10A   0x1B30             SUBS     R0,R6,R4
   \      0x10C   0x9000             STR      R0,[SP, #+0]
   \      0x10E   0xEB08 0x0004      ADD      R0,R8,R4
   \      0x112   0xF110 0x0B01      ADDS     R11,R0,#+1
   \      0x116   0xEB08 0x0A04      ADD      R10,R8,R4
   \      0x11A   0x9A00             LDR      R2,[SP, #+0]
   \      0x11C   0x4659             MOV      R1,R11
   \      0x11E   0x4650             MOV      R0,R10
   \      0x120   0x.... 0x....      BL       __aeabi_memmove
    467                  input_buffer[length] = '\0';
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0xF808 0x0006      STRB     R0,[R8, R6]
    468                  input_printf("%s ", input_buffer + position);
   \      0x12A   0xEB08 0x0104      ADD      R1,R8,R4
   \      0x12E   0x....             ADR.N    R0,??DataTable2
   \      0x130   0x.... 0x....      BL       sli_cli_io_printf
    469                  // Backspace to current pos
    470                  for (int i = length; i > position; i--) {
   \      0x134   0x46B2             MOV      R10,R6
   \                     ??sl_cli_input_char_15: (+1)
   \      0x136   0x4554             CMP      R4,R10
   \      0x138   0xDA05             BGE.N    ??sl_cli_input_char_16
    471                    input_putchar('\b');
   \      0x13A   0x2008             MOVS     R0,#+8
   \      0x13C   0x.... 0x....      BL       sli_cli_io_putchar
    472                  }
   \      0x140   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \      0x144   0xE7F7             B.N      ??sl_cli_input_char_15
    473                  handle->input_len--;
   \                     ??sl_cli_input_char_16: (+1)
   \      0x146   0xF8D9 0x0094      LDR      R0,[R9, #+148]
   \      0x14A   0x1E40             SUBS     R0,R0,#+1
   \      0x14C   0xF8C9 0x0094      STR      R0,[R9, #+148]
    474                }
    475                return false;
   \                     ??sl_cli_input_char_14: (+1)
   \      0x150   0x2000             MOVS     R0,#+0
   \      0x152   0xE0A5             B.N      ??sl_cli_input_char_1
    476              #endif // SL_CLI_ADVANCED_INPUT_HANDLING
    477              } else if (c == '\r' || c == '\n') {
   \                     ??sl_cli_input_char_13: (+1)
   \      0x154   0x0028             MOVS     R0,R5
   \      0x156   0xB2C0             UXTB     R0,R0
   \      0x158   0x280D             CMP      R0,#+13
   \      0x15A   0xD003             BEQ.N    ??sl_cli_input_char_17
   \      0x15C   0x0028             MOVS     R0,R5
   \      0x15E   0xB2C0             UXTB     R0,R0
   \      0x160   0x280A             CMP      R0,#+10
   \      0x162   0xD10E             BNE.N    ??sl_cli_input_char_18
    478                // Line ending detected
    479                // Print newline and reset handle's postion and length
    480                input_putchar('\r');
   \                     ??sl_cli_input_char_17: (+1)
   \      0x164   0x200D             MOVS     R0,#+13
   \      0x166   0x.... 0x....      BL       sli_cli_io_putchar
    481                input_putchar('\n');
   \      0x16A   0x200A             MOVS     R0,#+10
   \      0x16C   0x.... 0x....      BL       sli_cli_io_putchar
    482                handle->input_pos = 0;
   \      0x170   0x2000             MOVS     R0,#+0
   \      0x172   0xF8C9 0x0090      STR      R0,[R9, #+144]
    483                handle->input_len = 0;
   \      0x176   0x2000             MOVS     R0,#+0
   \      0x178   0xF8C9 0x0094      STR      R0,[R9, #+148]
    484                write_to_buffer = false;
   \      0x17C   0x2100             MOVS     R1,#+0
    485                return true;
   \      0x17E   0x2001             MOVS     R0,#+1
   \      0x180   0xE08E             B.N      ??sl_cli_input_char_1
    486          
    487              #if SL_CLI_ADVANCED_INPUT_HANDLING
    488              } else if (c == '\t') {
   \                     ??sl_cli_input_char_18: (+1)
   \      0x182   0x0028             MOVS     R0,R5
   \      0x184   0xB2C0             UXTB     R0,R0
   \      0x186   0x2809             CMP      R0,#+9
   \      0x188   0xD104             BNE.N    ??sl_cli_input_char_19
    489                // Autocompletion
    490                sl_cli_input_autocomplete(handle);
   \      0x18A   0x4648             MOV      R0,R9
   \      0x18C   0x.... 0x....      BL       sl_cli_input_autocomplete
    491                return false;
   \      0x190   0x2000             MOVS     R0,#+0
   \      0x192   0xE085             B.N      ??sl_cli_input_char_1
    492              #endif // SL_CLI_ADVANCED_INPUT_HANDLING
    493              }
    494          
    495              // If the input buffer is full, do nothing, unless input is backspace
    496              // which is already handled
    497              if (length >= handle->input_size - 1) {
   \                     ??sl_cli_input_char_19: (+1)
   \      0x194   0xF8D9 0x008C      LDR      R0,[R9, #+140]
   \      0x198   0x1E40             SUBS     R0,R0,#+1
   \      0x19A   0x4286             CMP      R6,R0
   \      0x19C   0xDB01             BLT.N    ??sl_cli_input_char_20
    498                return false;
   \      0x19E   0x2000             MOVS     R0,#+0
   \      0x1A0   0xE07E             B.N      ??sl_cli_input_char_1
    499              }
    500          
    501              #if SL_CLI_ADVANCED_INPUT_HANDLING
    502              // If position is not at end of buffer, all characters positioned after
    503              // current position must be moved one step towards right in buffer and
    504              // terminal
    505              if (length > position && write_to_buffer) {
   \                     ??sl_cli_input_char_20: (+1)
   \      0x1A2   0x42B4             CMP      R4,R6
   \      0x1A4   0xDA1C             BGE.N    ??sl_cli_input_char_21
   \      0x1A6   0x0038             MOVS     R0,R7
   \      0x1A8   0xB2C0             UXTB     R0,R0
   \      0x1AA   0x2800             CMP      R0,#+0
   \      0x1AC   0xD018             BEQ.N    ??sl_cli_input_char_21
    506                // Shift buffer up by one index
    507                memmove(input_buffer + position + 1, input_buffer + position,
    508                        length - position);
   \      0x1AE   0x1B30             SUBS     R0,R6,R4
   \      0x1B0   0x9000             STR      R0,[SP, #+0]
   \      0x1B2   0xEB08 0x0B04      ADD      R11,R8,R4
   \      0x1B6   0xEB08 0x0004      ADD      R0,R8,R4
   \      0x1BA   0xF110 0x0A01      ADDS     R10,R0,#+1
   \      0x1BE   0x9A00             LDR      R2,[SP, #+0]
   \      0x1C0   0x4659             MOV      R1,R11
   \      0x1C2   0x4650             MOV      R0,R10
   \      0x1C4   0x.... 0x....      BL       __aeabi_memmove
    509                // Print out buffer end
    510                input_printf(input_buffer + position);
   \      0x1C8   0xEB08 0x0004      ADD      R0,R8,R4
   \      0x1CC   0x.... 0x....      BL       sli_cli_io_printf
    511                for (int i = length; i >= position; i--) {
   \      0x1D0   0x46B2             MOV      R10,R6
   \                     ??sl_cli_input_char_22: (+1)
   \      0x1D2   0x45A2             CMP      R10,R4
   \      0x1D4   0xDB04             BLT.N    ??sl_cli_input_char_21
    512                  write_left_arrow();
   \      0x1D6   0x.... 0x....      BL       write_left_arrow
    513                }
   \      0x1DA   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \      0x1DE   0xE7F8             B.N      ??sl_cli_input_char_22
    514              }
    515              #endif
    516          
    517              // Write character to the end of buffer if specified to do so
    518              if (write_to_buffer) {
   \                     ??sl_cli_input_char_21: (+1)
   \      0x1E0   0x0038             MOVS     R0,R7
   \      0x1E2   0xB2C0             UXTB     R0,R0
   \      0x1E4   0x2800             CMP      R0,#+0
   \      0x1E6   0xD009             BEQ.N    ??sl_cli_input_char_23
    519                input_buffer[position] = c;
   \      0x1E8   0xF808 0x5004      STRB     R5,[R8, R4]
    520                handle->input_pos = position + 1;
   \      0x1EC   0x1C60             ADDS     R0,R4,#+1
   \      0x1EE   0xF8C9 0x0090      STR      R0,[R9, #+144]
    521                handle->input_len = handle->input_len + 1;
   \      0x1F2   0xF8D9 0x0094      LDR      R0,[R9, #+148]
   \      0x1F6   0x1C40             ADDS     R0,R0,#+1
   \      0x1F8   0xF8C9 0x0094      STR      R0,[R9, #+148]
    522              }
    523          
    524              // Echo character to terminal
    525              input_putchar(c);
   \                     ??sl_cli_input_char_23: (+1)
   \      0x1FC   0x0028             MOVS     R0,R5
   \      0x1FE   0xB2C0             UXTB     R0,R0
   \      0x200   0x.... 0x....      BL       sli_cli_io_putchar
    526              return false;
   \      0x204   0x2000             MOVS     R0,#+0
   \      0x206   0xE04B             B.N      ??sl_cli_input_char_1
    527          
    528          #if SL_CLI_ADVANCED_INPUT_HANDLING
    529            } else if (handle->last_input_type == SL_CLI_INPUT_ESCAPE) {
   \                     ??sl_cli_input_char_3: (+1)
   \      0x208   0xF899 0x0098      LDRB     R0,[R9, #+152]
   \      0x20C   0x2802             CMP      R0,#+2
   \      0x20E   0xD111             BNE.N    ??sl_cli_input_char_24
    530              // Last input was escape symbol
    531              // Check if new input is one of the handled cases, and act accordingly
    532              if (c == SL_CLI_ARROW_CHAR) {
   \      0x210   0x0028             MOVS     R0,R5
   \      0x212   0xB2C0             UXTB     R0,R0
   \      0x214   0x285B             CMP      R0,#+91
   \      0x216   0xD104             BNE.N    ??sl_cli_input_char_25
    533                handle->last_input_type = SL_CLI_INPUT_ARROW;
   \      0x218   0x2003             MOVS     R0,#+3
   \      0x21A   0xF889 0x0098      STRB     R0,[R9, #+152]
    534                return false;
   \      0x21E   0x2000             MOVS     R0,#+0
   \      0x220   0xE03E             B.N      ??sl_cli_input_char_1
    535              } else {
    536                // Not a recognized case. Recursive call with c as input,
    537                // but this time with last_input_type as ordinary, so this block
    538                // will not be executed again
    539                handle->last_input_type = SL_CLI_INPUT_ORDINARY;
   \                     ??sl_cli_input_char_25: (+1)
   \      0x222   0x2000             MOVS     R0,#+0
   \      0x224   0xF889 0x0098      STRB     R0,[R9, #+152]
    540                return sl_cli_input_char(handle, c);
   \      0x228   0x0029             MOVS     R1,R5
   \      0x22A   0xB2C9             UXTB     R1,R1
   \      0x22C   0x4648             MOV      R0,R9
   \      0x22E   0xF7FF 0xFEE7      BL       sl_cli_input_char
   \      0x232   0xE035             B.N      ??sl_cli_input_char_1
    541              }
    542            } else if (handle->last_input_type == SL_CLI_INPUT_ARROW) {
   \                     ??sl_cli_input_char_24: (+1)
   \      0x234   0xF899 0x0098      LDRB     R0,[R9, #+152]
   \      0x238   0x2803             CMP      R0,#+3
   \      0x23A   0xD130             BNE.N    ??sl_cli_input_char_26
    543              // If last input was the arrow character, treat new input as an arrow
    544              // character in a specific direction
    545              // Set last_input_type to ordinary, so next charcater is treated right
    546              handle->last_input_type = SL_CLI_INPUT_ORDINARY;
   \      0x23C   0x2000             MOVS     R0,#+0
   \      0x23E   0xF889 0x0098      STRB     R0,[R9, #+152]
    547              switch (c) {
   \      0x242   0x0028             MOVS     R0,R5
   \      0x244   0xB2C0             UXTB     R0,R0
   \      0x246   0x2841             CMP      R0,#+65
   \      0x248   0xD006             BEQ.N    ??sl_cli_input_char_27
   \      0x24A   0xD326             BCC.N    ??sl_cli_input_char_28
   \      0x24C   0x2843             CMP      R0,#+67
   \      0x24E   0xD00E             BEQ.N    ??sl_cli_input_char_29
   \      0x250   0xD307             BCC.N    ??sl_cli_input_char_30
   \      0x252   0x2844             CMP      R0,#+68
   \      0x254   0xD017             BEQ.N    ??sl_cli_input_char_31
   \      0x256   0xE020             B.N      ??sl_cli_input_char_28
    548                case SL_CLI_UP_ARROW_CHAR:
    549                  // Reqest history, if enabled
    550          #if SL_CLI_NUM_HISTORY_BYTES
    551                  sl_cli_input_get_history(handle, SL_CLI_INPUT_DIRECTION_UP);
   \                     ??sl_cli_input_char_27: (+1)
   \      0x258   0x2101             MOVS     R1,#+1
   \      0x25A   0x4648             MOV      R0,R9
   \      0x25C   0x.... 0x....      BL       sl_cli_input_get_history
    552          #endif
    553                  break;
   \      0x260   0xE01D             B.N      ??sl_cli_input_char_26
    554                case SL_CLI_DOWN_ARROW_CHAR:
    555                  // Reqest history, if enabled
    556          #if SL_CLI_NUM_HISTORY_BYTES
    557                  sl_cli_input_get_history(handle, SL_CLI_INPUT_DIRECTION_DOWN);
   \                     ??sl_cli_input_char_30: (+1)
   \      0x262   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \      0x266   0x4648             MOV      R0,R9
   \      0x268   0x.... 0x....      BL       sl_cli_input_get_history
    558          #endif
    559                  break;
   \      0x26C   0xE017             B.N      ??sl_cli_input_char_26
    560                #if SL_CLI_ADVANCED_INPUT_HANDLING
    561                case SL_CLI_RIGHT_ARROW_CHAR:
    562                  // Move cursor right if possible
    563                  if (position < length) {
   \                     ??sl_cli_input_char_29: (+1)
   \      0x26E   0x42B4             CMP      R4,R6
   \      0x270   0xDA08             BGE.N    ??sl_cli_input_char_32
    564                    write_right_arrow(handle, position);
   \      0x272   0x0021             MOVS     R1,R4
   \      0x274   0x4648             MOV      R0,R9
   \      0x276   0x.... 0x....      BL       write_right_arrow
    565                    handle->input_pos++;
   \      0x27A   0xF8D9 0x0090      LDR      R0,[R9, #+144]
   \      0x27E   0x1C40             ADDS     R0,R0,#+1
   \      0x280   0xF8C9 0x0090      STR      R0,[R9, #+144]
    566                  }
    567                  break;
   \                     ??sl_cli_input_char_32: (+1)
   \      0x284   0xE00B             B.N      ??sl_cli_input_char_26
    568                case SL_CLI_LEFT_ARROW_CHAR:
    569                  // Move cursor left if not already at the left end
    570                  if (position > 0) {
   \                     ??sl_cli_input_char_31: (+1)
   \      0x286   0x2C01             CMP      R4,#+1
   \      0x288   0xDB06             BLT.N    ??sl_cli_input_char_33
    571                    handle->input_pos--;
   \      0x28A   0xF8D9 0x0090      LDR      R0,[R9, #+144]
   \      0x28E   0x1E40             SUBS     R0,R0,#+1
   \      0x290   0xF8C9 0x0090      STR      R0,[R9, #+144]
    572                    write_left_arrow();
   \      0x294   0x.... 0x....      BL       write_left_arrow
    573                  }
    574                  break;
   \                     ??sl_cli_input_char_33: (+1)
   \      0x298   0xE001             B.N      ??sl_cli_input_char_26
    575                #endif
    576                default:
    577                  // unkown input, do nothing
    578                  return false;
   \                     ??sl_cli_input_char_28: (+1)
   \      0x29A   0x2000             MOVS     R0,#+0
   \      0x29C   0xE000             B.N      ??sl_cli_input_char_1
    579              }
    580              #endif // SL_CLI_ADVANCED_INPUT_HANDLING
    581            }
    582            // Character is not newline
    583            return false;
   \                     ??sl_cli_input_char_26: (+1)
   \      0x29E   0x2000             MOVS     R0,#+0
   \                     ??sl_cli_input_char_1: (+1)
   \      0x2A0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    584          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x3E 0x20          DC8      0x3E, 0x20, 0x00, 0x00
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x25 0x73          DC8      "%s "          
   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0A 0x25          DC8 "\012%s\012%s%s"
   \              0x73 0x0A    
   \              0x25 0x73    
   \              0x25 0x73    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \        0x0   0x3E 0x20          DC8 "> "
   \              0x00
   \        0x3                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x25 0x73          DC8 "%s \010"
   \              0x20 0x08    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .rodata, align 4
   \        0x0   0x25 0x73          DC8 "%s "
   \              0x20 0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   history_get_count
        16   -> strlen
      16   history_get_ofs
        16   -> strlen
     824   sl_cli_input_autocomplete
       824   -> __aeabi_memset
       824   -> sl_cli_command_find_matches
       824   -> sli_cli_io_printf
       824   -> sli_cli_io_putchar
       824   -> strlen
       824   -> write_right_arrow
      40   sl_cli_input_char
        40   -> __aeabi_memmove
        40   -> sl_cli_input_autocomplete
        40   -> sl_cli_input_char
        40   -> sl_cli_input_get_history
        40   -> sli_cli_io_printf
        40   -> sli_cli_io_putchar
        40   -> write_left_arrow
        40   -> write_right_arrow
      24   sl_cli_input_clear
        24   -> __aeabi_memset
      40   sl_cli_input_get_history
        40   -> history_get_count
        40   -> history_get_ofs
        40   -> sl_cli_input_char
        40   -> sl_cli_input_clear
        40   -> sli_cli_io_putchar
        40   -> strlen
      40   sli_cli_input_update_history
        40   -> __aeabi_memcpy
        40   -> __aeabi_memmove
        40   -> history_get_count
        40   -> history_get_ofs
        40   -> sl_strnlen
        40   -> strlen
       8   write_left_arrow
         8   -> sli_cli_io_putchar
      16   write_right_arrow
        16   -> sli_cli_io_putchar


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
      12  ?_0
       4  ?_1
       8  ?_2
       4  ?_3
      54  history_get_count
     144  history_get_ofs
     572  sl_cli_input_autocomplete
     676  sl_cli_input_char
      36  sl_cli_input_clear
     206  sl_cli_input_get_history
     160  sli_cli_input_update_history
      10  write_left_arrow
      14  write_right_arrow

 
    28 bytes in section .rodata
 1'888 bytes in section .text
 
 1'888 bytes of CODE  memory
    28 bytes of CONST memory

Errors: none
Warnings: none
