###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         21/Jan/2025  17:21:05
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\sl_cli_arguments.c
#    Command line                 =
#        -f
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\obj\src_15860922140008369996.dir\sl_cli_arguments.o.rsp
#        (C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\sl_cli_arguments.c
#        -D DEBUG_EFM=1 -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -lC
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\lst\src_15860922140008369996.dir
#        --diag_suppress Pa050 -o
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\obj\src_15860922140008369996.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse --cmse -e --fpu=VFPv5_sp --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\autogen\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\config\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\config\rail\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\config\wisun\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\.\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_project_info\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\device_init\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\common\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\emlib\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\iostream\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\mbedtls\library\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\source\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\common\include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\cpu\include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\ports\source\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\source\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\micrium_os\kernel\include\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\peripheral\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\printf\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\common\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\common\toolchain\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\system\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_core\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\app_setting\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\cli_util\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\event_manager\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ns_list\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\ping\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\app\wisun\component\udp_client\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\plugin\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\
#        -I
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\protocol\wisun\stack\inc\socket\
#        -On --use_c++_inline) --dependencies=n
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\obj\src_15860922140008369996.dir\sl_cli_arguments.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\lst\src_15860922140008369996.dir\sl_cli_arguments.lst
#    Object file                  =
#        C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\ewarm-iar\obj\src_15860922140008369996.dir\sl_cli_arguments.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\train\OneDrive\Desktop\Projects\Wisu\Wisun_Node_App\Wisun_Node_App\gecko_sdk_4.4.5\platform\service\cli\src\sl_cli_arguments.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Functions to convert and validate cli arguments.
      4           * @version x.y.z
      5           *******************************************************************************
      6           * # License
      7           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      8           *******************************************************************************
      9           *
     10           * SPDX-License-Identifier: Zlib
     11           *
     12           * The licensor of this software is Silicon Laboratories Inc.
     13           *
     14           * This software is provided 'as-is', without any express or implied
     15           * warranty. In no event will the authors be held liable for any damages
     16           * arising from the use of this software.
     17           *
     18           * Permission is granted to anyone to use this software for any purpose,
     19           * including commercial applications, and to alter it and redistribute it
     20           * freely, subject to the following restrictions:
     21           *
     22           * 1. The origin of this software must not be misrepresented; you must not
     23           *    claim that you wrote the original software. If you use this software
     24           *    in a product, an acknowledgment in the product documentation would be
     25           *    appreciated but is not required.
     26           * 2. Altered source versions must be plainly marked as such, and must not be
     27           *    misrepresented as being the original software.
     28           * 3. This notice may not be removed or altered from any source distribution.
     29           *
     30           ******************************************************************************/
     31          
     32          #include "sli_cli_arguments.h"
     33          #include <string.h>
     34          #include <stdlib.h>
     35          #include <ctype.h>
     36          
     37          /*******************************************************************************
     38           ****************************   LOCAL FUNCTIONS   ******************************
     39           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     40          static bool is_argument_optional(sl_cli_argument_type_t arg_type)
     41          {
   \                     is_argument_optional: (+1)
   \        0x0   0x0001             MOVS     R1,R0
     42            switch (arg_type) {
   \        0x2   0x000A             MOVS     R2,R1
   \        0x4   0xB2D2             UXTB     R2,R2
   \        0x6   0x3A10             SUBS     R2,R2,#+16
   \        0x8   0x2A07             CMP      R2,#+7
   \        0xA   0xD801             BHI.N    ??is_argument_optional_0
     43              case SL_CLI_ARG_UINT8OPT:
     44              case SL_CLI_ARG_UINT16OPT:
     45              case SL_CLI_ARG_UINT32OPT:
     46              case SL_CLI_ARG_INT8OPT:
     47              case SL_CLI_ARG_INT16OPT:
     48              case SL_CLI_ARG_INT32OPT:
     49              case SL_CLI_ARG_STRINGOPT:
     50              case SL_CLI_ARG_HEXOPT:
     51                return true;
   \                     ??is_argument_optional_1: (+1)
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE000             B.N      ??is_argument_optional_2
     52              default:
     53                break;
     54            }
     55            return false;
   \                     ??is_argument_optional_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??is_argument_optional_2: (+1)
   \       0x12   0x4770             BX       LR
     56          }
     57          

   \                                 In section .text, align 2, keep-with-next
     58          static sl_cli_argument_type_t optional_to_mandatory(sl_cli_argument_type_t arg_type)
     59          {
     60            switch (arg_type) {
   \                     optional_to_mandatory: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   \        0x2   0xB2D2             UXTB     R2,R2
   \        0x4   0x3A10             SUBS     R2,R2,#+16
   \        0x6   0x2A07             CMP      R2,#+7
   \        0x8   0xD802             BHI.N    ??optional_to_mandatory_0
     61              case SL_CLI_ARG_UINT8OPT:
     62              case SL_CLI_ARG_UINT16OPT:
     63              case SL_CLI_ARG_UINT32OPT:
     64              case SL_CLI_ARG_INT8OPT:
     65              case SL_CLI_ARG_INT16OPT:
     66              case SL_CLI_ARG_INT32OPT:
     67              case SL_CLI_ARG_STRINGOPT:
     68              case SL_CLI_ARG_HEXOPT:
     69                return arg_type - 0x10;
   \                     ??optional_to_mandatory_1: (+1)
   \        0xA   0x3810             SUBS     R0,R0,#+16
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0xE000             B.N      ??optional_to_mandatory_2
     70              default:
     71                break;
     72            }
     73            return arg_type;
   \                     ??optional_to_mandatory_0: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0
   \                     ??optional_to_mandatory_2: (+1)
   \       0x12   0x4770             BX       LR
     74          }
     75          
     76          /*******************************************************************************
     77           ****************************   GLOBAL FUNCTIONS   *****************************
     78           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     79          bool sli_cli_arguments_validate_uint(int size,
     80                                               const char *argument,
     81                                               bool neg)
     82          {
   \                     sli_cli_arguments_validate_uint: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
     83            int i;
     84            // Argument is hexadecimal
     85            if (argument[0] == '0' && (argument[1] == 'x' || argument[1] == 'X')) {
   \        0xA   0x7820             LDRB     R0,[R4, #+0]
   \        0xC   0x2830             CMP      R0,#+48
   \        0xE   0xD151             BNE.N    ??sli_cli_arguments_validate_uint_0
   \       0x10   0x7860             LDRB     R0,[R4, #+1]
   \       0x12   0x2878             CMP      R0,#+120
   \       0x14   0xD002             BEQ.N    ??sli_cli_arguments_validate_uint_1
   \       0x16   0x7860             LDRB     R0,[R4, #+1]
   \       0x18   0x2858             CMP      R0,#+88
   \       0x1A   0xD14B             BNE.N    ??sli_cli_arguments_validate_uint_0
     86              i = 2;
   \                     ??sli_cli_arguments_validate_uint_1: (+1)
   \       0x1C   0x2702             MOVS     R7,#+2
     87              while (argument[i] != '\0') {
   \                     ??sli_cli_arguments_validate_uint_2: (+1)
   \       0x1E   0x5DE0             LDRB     R0,[R4, R7]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD010             BEQ.N    ??sli_cli_arguments_validate_uint_3
     88                int value = (int)((unsigned char)argument[i]);
   \       0x24   0xF814 0x8007      LDRB     R8,[R4, R7]
     89                if ((value < 0) || (value > 255) || !isxdigit(value)) {
   \       0x28   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x2C   0xD407             BMI.N    ??sli_cli_arguments_validate_uint_4
   \       0x2E   0xF5B8 0x7F80      CMP      R8,#+256
   \       0x32   0xDA04             BGE.N    ??sli_cli_arguments_validate_uint_4
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0x.... 0x....      BL       isxdigit
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD101             BNE.N    ??sli_cli_arguments_validate_uint_5
     90                  return false;
   \                     ??sli_cli_arguments_validate_uint_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE07C             B.N      ??sli_cli_arguments_validate_uint_6
     91                }
     92                i++;
   \                     ??sli_cli_arguments_validate_uint_5: (+1)
   \       0x42   0x1C7F             ADDS     R7,R7,#+1
   \       0x44   0xE7EB             B.N      ??sli_cli_arguments_validate_uint_2
     93              }
     94              // Check if number of digits is smaller than int size divided by four
     95              if (size % 4 == 3) {
   \                     ??sli_cli_arguments_validate_uint_3: (+1)
   \       0x46   0x2104             MOVS     R1,#+4
   \       0x48   0xFB96 0xF0F1      SDIV     R0,R6,R1
   \       0x4C   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \       0x50   0x2903             CMP      R1,#+3
   \       0x52   0xD121             BNE.N    ??sli_cli_arguments_validate_uint_7
     96                if ((int)(strlen(argument) - 2) == ((size + 1) / 4)) {
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       strlen
   \       0x5A   0x1E80             SUBS     R0,R0,#+2
   \       0x5C   0x1C71             ADDS     R1,R6,#+1
   \       0x5E   0x2204             MOVS     R2,#+4
   \       0x60   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \       0x64   0x4288             CMP      R0,R1
   \       0x66   0xD108             BNE.N    ??sli_cli_arguments_validate_uint_8
     97                  return ((int)argument[2] - (int) '0' <= 7);
   \       0x68   0x78A0             LDRB     R0,[R4, #+2]
   \       0x6A   0x3830             SUBS     R0,R0,#+48
   \       0x6C   0x2808             CMP      R0,#+8
   \       0x6E   0xDA01             BGE.N    ??sli_cli_arguments_validate_uint_9
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE000             B.N      ??sli_cli_arguments_validate_uint_10
   \                     ??sli_cli_arguments_validate_uint_9: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \                     ??sli_cli_arguments_validate_uint_10: (+1)
   \       0x76   0xB2C0             UXTB     R0,R0
   \       0x78   0xE060             B.N      ??sli_cli_arguments_validate_uint_6
     98                }
     99                return ((int)(strlen(argument) - 2) < ((size + 1) / 4));
   \                     ??sli_cli_arguments_validate_uint_8: (+1)
   \       0x7A   0x1C70             ADDS     R0,R6,#+1
   \       0x7C   0x2104             MOVS     R1,#+4
   \       0x7E   0xFB90 0xF8F1      SDIV     R8,R0,R1
   \       0x82   0x0020             MOVS     R0,R4
   \       0x84   0x.... 0x....      BL       strlen
   \       0x88   0x1E80             SUBS     R0,R0,#+2
   \       0x8A   0x4540             CMP      R0,R8
   \       0x8C   0xDA01             BGE.N    ??sli_cli_arguments_validate_uint_11
   \       0x8E   0x2001             MOVS     R0,#+1
   \       0x90   0xE000             B.N      ??sli_cli_arguments_validate_uint_12
   \                     ??sli_cli_arguments_validate_uint_11: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \                     ??sli_cli_arguments_validate_uint_12: (+1)
   \       0x94   0xB2C0             UXTB     R0,R0
   \       0x96   0xE051             B.N      ??sli_cli_arguments_validate_uint_6
    100              }
    101              return (int)(strlen(argument) - 2) <= size / 4;
   \                     ??sli_cli_arguments_validate_uint_7: (+1)
   \       0x98   0x0020             MOVS     R0,R4
   \       0x9A   0x.... 0x....      BL       strlen
   \       0x9E   0x1E80             SUBS     R0,R0,#+2
   \       0xA0   0x2104             MOVS     R1,#+4
   \       0xA2   0xFB96 0xF1F1      SDIV     R1,R6,R1
   \       0xA6   0x4281             CMP      R1,R0
   \       0xA8   0xDB01             BLT.N    ??sli_cli_arguments_validate_uint_13
   \       0xAA   0x2001             MOVS     R0,#+1
   \       0xAC   0xE000             B.N      ??sli_cli_arguments_validate_uint_14
   \                     ??sli_cli_arguments_validate_uint_13: (+1)
   \       0xAE   0x2000             MOVS     R0,#+0
   \                     ??sli_cli_arguments_validate_uint_14: (+1)
   \       0xB0   0xB2C0             UXTB     R0,R0
   \       0xB2   0xE043             B.N      ??sli_cli_arguments_validate_uint_6
    102            }
    103            // Argument is decimal
    104            i = 0;
   \                     ??sli_cli_arguments_validate_uint_0: (+1)
   \       0xB4   0x2700             MOVS     R7,#+0
    105            while (argument[i] != '\0') {
   \                     ??sli_cli_arguments_validate_uint_15: (+1)
   \       0xB6   0x5DE0             LDRB     R0,[R4, R7]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD010             BEQ.N    ??sli_cli_arguments_validate_uint_16
    106              int value = (int)((unsigned char)argument[i]);
   \       0xBC   0xF814 0x8007      LDRB     R8,[R4, R7]
    107              if ((value < 0) || (value > 255) || !isdigit(value)) {
   \       0xC0   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xC4   0xD407             BMI.N    ??sli_cli_arguments_validate_uint_17
   \       0xC6   0xF5B8 0x7F80      CMP      R8,#+256
   \       0xCA   0xDA04             BGE.N    ??sli_cli_arguments_validate_uint_17
   \       0xCC   0x4640             MOV      R0,R8
   \       0xCE   0x.... 0x....      BL       isdigit
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD101             BNE.N    ??sli_cli_arguments_validate_uint_18
    108                return false;
   \                     ??sli_cli_arguments_validate_uint_17: (+1)
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xE030             B.N      ??sli_cli_arguments_validate_uint_6
    109              }
    110              i++;
   \                     ??sli_cli_arguments_validate_uint_18: (+1)
   \       0xDA   0x1C7F             ADDS     R7,R7,#+1
   \       0xDC   0xE7EB             B.N      ??sli_cli_arguments_validate_uint_15
    111            }
    112            // Check if only the size-last bits are set
    113            unsigned long long value = strtoll(argument, NULL, 10);
   \                     ??sli_cli_arguments_validate_uint_16: (+1)
   \       0xDE   0x220A             MOVS     R2,#+10
   \       0xE0   0x2100             MOVS     R1,#+0
   \       0xE2   0x0020             MOVS     R0,R4
   \       0xE4   0x.... 0x....      BL       strtoll
    114            if (size == 32) {
   \       0xE8   0x2E20             CMP      R6,#+32
   \       0xEA   0xD10C             BNE.N    ??sli_cli_arguments_validate_uint_19
    115              return value == (value & 0xFFFFFFFF);
   \       0xEC   0xF030 0x0200      BICS     R2,R0,#0x0
   \       0xF0   0xF031 0x33FF      BICS     R3,R1,#0xFFFFFFFF
   \       0xF4   0x4299             CMP      R1,R3
   \       0xF6   0xD103             BNE.N    ??sli_cli_arguments_validate_uint_20
   \       0xF8   0x4290             CMP      R0,R2
   \       0xFA   0xD101             BNE.N    ??sli_cli_arguments_validate_uint_20
   \       0xFC   0x2001             MOVS     R0,#+1
   \       0xFE   0xE000             B.N      ??sli_cli_arguments_validate_uint_21
   \                     ??sli_cli_arguments_validate_uint_20: (+1)
   \      0x100   0x2000             MOVS     R0,#+0
   \                     ??sli_cli_arguments_validate_uint_21: (+1)
   \      0x102   0xB2C0             UXTB     R0,R0
   \      0x104   0xE01A             B.N      ??sli_cli_arguments_validate_uint_6
    116            }
    117            if (neg && (value > 0)) {
   \                     ??sli_cli_arguments_validate_uint_19: (+1)
   \      0x106   0x002A             MOVS     R2,R5
   \      0x108   0xB2D2             UXTB     R2,R2
   \      0x10A   0x2A00             CMP      R2,#+0
   \      0x10C   0xD006             BEQ.N    ??sli_cli_arguments_validate_uint_22
   \      0x10E   0x2900             CMP      R1,#+0
   \      0x110   0xD101             BNE.N    ??sli_cli_arguments_validate_uint_23
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xD002             BEQ.N    ??sli_cli_arguments_validate_uint_22
    118              // Negative numbers can have one higher magnitude than the positive value.
    119              value--;
   \                     ??sli_cli_arguments_validate_uint_23: (+1)
   \      0x116   0x1E40             SUBS     R0,R0,#+1
   \      0x118   0xF171 0x0100      SBCS     R1,R1,#+0
    120            }
    121            return value == (value & ((1U << size) - 1));
   \                     ??sli_cli_arguments_validate_uint_22: (+1)
   \      0x11C   0x2201             MOVS     R2,#+1
   \      0x11E   0xFA12 0xF606      LSLS     R6,R2,R6
   \      0x122   0x1E76             SUBS     R6,R6,#+1
   \      0x124   0x0032             MOVS     R2,R6
   \      0x126   0x2300             MOVS     R3,#+0
   \      0x128   0x4002             ANDS     R2,R0,R2
   \      0x12A   0x400B             ANDS     R3,R1,R3
   \      0x12C   0x4299             CMP      R1,R3
   \      0x12E   0xD103             BNE.N    ??sli_cli_arguments_validate_uint_24
   \      0x130   0x4290             CMP      R0,R2
   \      0x132   0xD101             BNE.N    ??sli_cli_arguments_validate_uint_24
   \      0x134   0x2001             MOVS     R0,#+1
   \      0x136   0xE000             B.N      ??sli_cli_arguments_validate_uint_25
   \                     ??sli_cli_arguments_validate_uint_24: (+1)
   \      0x138   0x2000             MOVS     R0,#+0
   \                     ??sli_cli_arguments_validate_uint_25: (+1)
   \      0x13A   0xB2C0             UXTB     R0,R0
   \                     ??sli_cli_arguments_validate_uint_6: (+1)
   \      0x13C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    122          }
    123          

   \                                 In section .text, align 2, keep-with-next
    124          bool sli_cli_arguments_validate_int(int size,
    125                                              const char *argument)
    126          {
   \                     sli_cli_arguments_validate_int: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    127            if (argument[0] == '-') {
   \        0x6   0x7828             LDRB     R0,[R5, #+0]
   \        0x8   0x282D             CMP      R0,#+45
   \        0xA   0xD106             BNE.N    ??sli_cli_arguments_validate_int_0
    128              const char *sub_array = argument + 1;
   \        0xC   0x1C6E             ADDS     R6,R5,#+1
    129              return sli_cli_arguments_validate_uint(size - 1, sub_array, true);
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x0031             MOVS     R1,R6
   \       0x12   0x1E60             SUBS     R0,R4,#+1
   \       0x14   0x.... 0x....      BL       sli_cli_arguments_validate_uint
   \       0x18   0xE004             B.N      ??sli_cli_arguments_validate_int_1
    130            }
    131            return sli_cli_arguments_validate_uint(size - 1, argument, false);
   \                     ??sli_cli_arguments_validate_int_0: (+1)
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0x1E60             SUBS     R0,R4,#+1
   \       0x20   0x.... 0x....      BL       sli_cli_arguments_validate_uint
   \                     ??sli_cli_arguments_validate_int_1: (+1)
   \       0x24   0xBD70             POP      {R4-R6,PC}
    132          }
    133          

   \                                 In section .text, align 2, keep-with-next
    134          bool sli_cli_arguments_validate_hex_string(const char *argument)
    135          {
   \                     sli_cli_arguments_validate_hex_string: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    136            if (argument[0] != '{') {
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0x287B             CMP      R0,#+123
   \        0x8   0xD001             BEQ.N    ??sli_cli_arguments_validate_hex_string_0
    137              return false;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE02C             B.N      ??sli_cli_arguments_validate_hex_string_1
    138            }
    139            int i = 1;
   \                     ??sli_cli_arguments_validate_hex_string_0: (+1)
   \        0xE   0x2501             MOVS     R5,#+1
    140            int digit_count = 0;
   \       0x10   0x2600             MOVS     R6,#+0
    141            while (argument[i] != '}') {
   \                     ??sli_cli_arguments_validate_hex_string_2: (+1)
   \       0x12   0x5D60             LDRB     R0,[R4, R5]
   \       0x14   0x287D             CMP      R0,#+125
   \       0x16   0xD01B             BEQ.N    ??sli_cli_arguments_validate_hex_string_3
    142              int value = (int)((unsigned char)argument[i]);
   \       0x18   0x5D67             LDRB     R7,[R4, R5]
    143              if ((value < 0) || (value > 255)) {
   \       0x1A   0x2F00             CMP      R7,#+0
   \       0x1C   0xD402             BMI.N    ??sli_cli_arguments_validate_hex_string_4
   \       0x1E   0xF5B7 0x7F80      CMP      R7,#+256
   \       0x22   0xDB01             BLT.N    ??sli_cli_arguments_validate_hex_string_5
    144                return false;
   \                     ??sli_cli_arguments_validate_hex_string_4: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE01F             B.N      ??sli_cli_arguments_validate_hex_string_1
    145              }
    146              if (isxdigit(value)) {
   \                     ??sli_cli_arguments_validate_hex_string_5: (+1)
   \       0x28   0x0038             MOVS     R0,R7
   \       0x2A   0x.... 0x....      BL       isxdigit
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD002             BEQ.N    ??sli_cli_arguments_validate_hex_string_6
    147                digit_count++;
   \       0x32   0x1C76             ADDS     R6,R6,#+1
    148              } else if (argument[i] == ' ') {
    149                i++;
    150                continue;
    151              } else if (argument[i] == '\0') {
    152                return false;
    153              } else {
    154                return false;
    155              }
    156              i++;
   \       0x34   0x1C6D             ADDS     R5,R5,#+1
   \       0x36   0xE7EC             B.N      ??sli_cli_arguments_validate_hex_string_2
   \                     ??sli_cli_arguments_validate_hex_string_6: (+1)
   \       0x38   0x5D60             LDRB     R0,[R4, R5]
   \       0x3A   0x2820             CMP      R0,#+32
   \       0x3C   0xD101             BNE.N    ??sli_cli_arguments_validate_hex_string_7
   \       0x3E   0x1C6D             ADDS     R5,R5,#+1
   \       0x40   0xE7E7             B.N      ??sli_cli_arguments_validate_hex_string_2
   \                     ??sli_cli_arguments_validate_hex_string_7: (+1)
   \       0x42   0x5D60             LDRB     R0,[R4, R5]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD101             BNE.N    ??sli_cli_arguments_validate_hex_string_8
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xE00D             B.N      ??sli_cli_arguments_validate_hex_string_1
   \                     ??sli_cli_arguments_validate_hex_string_8: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xE00B             B.N      ??sli_cli_arguments_validate_hex_string_1
    157            }
    158            if (argument[i + 1] != '\0') {
   \                     ??sli_cli_arguments_validate_hex_string_3: (+1)
   \       0x50   0xEB04 0x0005      ADD      R0,R4,R5
   \       0x54   0x7840             LDRB     R0,[R0, #+1]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD001             BEQ.N    ??sli_cli_arguments_validate_hex_string_9
    159              return false;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE004             B.N      ??sli_cli_arguments_validate_hex_string_1
    160            }
    161            // Check if number of hex digits is an even number
    162            if (digit_count % 2 != 0) {
   \                     ??sli_cli_arguments_validate_hex_string_9: (+1)
   \       0x5E   0x07F0             LSLS     R0,R6,#+31
   \       0x60   0xD501             BPL.N    ??sli_cli_arguments_validate_hex_string_10
    163              return false;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xE000             B.N      ??sli_cli_arguments_validate_hex_string_1
    164            }
    165            return true;
   \                     ??sli_cli_arguments_validate_hex_string_10: (+1)
   \       0x66   0x2001             MOVS     R0,#+1
   \                     ??sli_cli_arguments_validate_hex_string_1: (+1)
   \       0x68   0xBDF2             POP      {R1,R4-R7,PC}
    166          }
    167          

   \                                 In section .text, align 2, keep-with-next
    168          bool sli_cli_validate_argument(sl_cli_argument_type_t type,
    169                                         const char *argument)
    170          {
   \                     sli_cli_validate_argument: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    171            switch (type) {
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD00B             BEQ.N    ??sli_cli_validate_argument_0
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD015             BEQ.N    ??sli_cli_validate_argument_1
   \       0x12   0xD30E             BCC.N    ??sli_cli_validate_argument_2
   \       0x14   0x2804             CMP      R0,#+4
   \       0x16   0xD01D             BEQ.N    ??sli_cli_validate_argument_3
   \       0x18   0xD317             BCC.N    ??sli_cli_validate_argument_4
   \       0x1A   0x2806             CMP      R0,#+6
   \       0x1C   0xD024             BEQ.N    ??sli_cli_validate_argument_5
   \       0x1E   0xD31E             BCC.N    ??sli_cli_validate_argument_6
   \       0x20   0x2807             CMP      R0,#+7
   \       0x22   0xD023             BEQ.N    ??sli_cli_validate_argument_7
   \       0x24   0xE026             B.N      ??sli_cli_validate_argument_8
    172              case SL_CLI_ARG_UINT8:
    173                return sli_cli_arguments_validate_uint(8, argument, false);
   \                     ??sli_cli_validate_argument_0: (+1)
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x0021             MOVS     R1,R4
   \       0x2A   0x2008             MOVS     R0,#+8
   \       0x2C   0x.... 0x....      BL       sli_cli_arguments_validate_uint
   \       0x30   0xE021             B.N      ??sli_cli_validate_argument_9
    174              case SL_CLI_ARG_UINT16:
    175                return sli_cli_arguments_validate_uint(16, argument, false);
   \                     ??sli_cli_validate_argument_2: (+1)
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x0021             MOVS     R1,R4
   \       0x36   0x2010             MOVS     R0,#+16
   \       0x38   0x.... 0x....      BL       sli_cli_arguments_validate_uint
   \       0x3C   0xE01B             B.N      ??sli_cli_validate_argument_9
    176              case SL_CLI_ARG_UINT32:
    177                return sli_cli_arguments_validate_uint(32, argument, false);
   \                     ??sli_cli_validate_argument_1: (+1)
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x0021             MOVS     R1,R4
   \       0x42   0x2020             MOVS     R0,#+32
   \       0x44   0x.... 0x....      BL       sli_cli_arguments_validate_uint
   \       0x48   0xE015             B.N      ??sli_cli_validate_argument_9
    178              case SL_CLI_ARG_INT8:
    179                return sli_cli_arguments_validate_int(8, argument);
   \                     ??sli_cli_validate_argument_4: (+1)
   \       0x4A   0x0021             MOVS     R1,R4
   \       0x4C   0x2008             MOVS     R0,#+8
   \       0x4E   0x.... 0x....      BL       sli_cli_arguments_validate_int
   \       0x52   0xE010             B.N      ??sli_cli_validate_argument_9
    180              case SL_CLI_ARG_INT16:
    181                return sli_cli_arguments_validate_int(16, argument);
   \                     ??sli_cli_validate_argument_3: (+1)
   \       0x54   0x0021             MOVS     R1,R4
   \       0x56   0x2010             MOVS     R0,#+16
   \       0x58   0x.... 0x....      BL       sli_cli_arguments_validate_int
   \       0x5C   0xE00B             B.N      ??sli_cli_validate_argument_9
    182              case SL_CLI_ARG_INT32:
    183                return sli_cli_arguments_validate_int(32, argument);
   \                     ??sli_cli_validate_argument_6: (+1)
   \       0x5E   0x0021             MOVS     R1,R4
   \       0x60   0x2020             MOVS     R0,#+32
   \       0x62   0x.... 0x....      BL       sli_cli_arguments_validate_int
   \       0x66   0xE006             B.N      ??sli_cli_validate_argument_9
    184              case SL_CLI_ARG_STRING:
    185                return true;
   \                     ??sli_cli_validate_argument_5: (+1)
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xE004             B.N      ??sli_cli_validate_argument_9
    186              case SL_CLI_ARG_HEX:
    187                return sli_cli_arguments_validate_hex_string(argument);
   \                     ??sli_cli_validate_argument_7: (+1)
   \       0x6C   0x0020             MOVS     R0,R4
   \       0x6E   0x.... 0x....      BL       sli_cli_arguments_validate_hex_string
   \       0x72   0xE000             B.N      ??sli_cli_validate_argument_9
    188              default:
    189                return false;
   \                     ??sli_cli_validate_argument_8: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \                     ??sli_cli_validate_argument_9: (+1)
   \       0x76   0xBD32             POP      {R1,R4,R5,PC}
    190            }
    191          }
    192          

   \                                 In section .text, align 2, keep-with-next
    193          void sli_cli_arguments_convert_single(sl_cli_argument_type_t type,
    194                                                char *argument,
    195                                                void *argv[],
    196                                                uint32_t *memory_array,
    197                                                int *arg_index,
    198                                                int *mem_index)
    199          {
   \                     sli_cli_arguments_convert_single: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB082             SUB      SP,SP,#+8
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
   \        0xC   0x9E0C             LDR      R6,[SP, #+48]
   \        0xE   0x9F0D             LDR      R7,[SP, #+52]
    200            switch (type) {
   \       0x10   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD011             BEQ.N    ??sli_cli_arguments_convert_single_0
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD023             BEQ.N    ??sli_cli_arguments_convert_single_1
   \       0x1C   0x2802             CMP      R0,#+2
   \       0x1E   0xD035             BEQ.N    ??sli_cli_arguments_convert_single_2
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xD045             BEQ.N    ??sli_cli_arguments_convert_single_3
   \       0x24   0x2804             CMP      R0,#+4
   \       0x26   0xD057             BEQ.N    ??sli_cli_arguments_convert_single_4
   \       0x28   0x2805             CMP      R0,#+5
   \       0x2A   0xD069             BEQ.N    ??sli_cli_arguments_convert_single_5
   \       0x2C   0x2806             CMP      R0,#+6
   \       0x2E   0xD079             BEQ.N    ??sli_cli_arguments_convert_single_6
   \       0x30   0x2807             CMP      R0,#+7
   \       0x32   0xD07B             BEQ.N    ??sli_cli_arguments_convert_single_7
   \       0x34   0x2821             CMP      R0,#+33
   \       0x36   0xF000 0x80B6      BEQ.W    ??sli_cli_arguments_convert_single_8
   \       0x3A   0xE0B8             B.N      ??sli_cli_arguments_convert_single_9
    201              case SL_CLI_ARG_UINT8:
    202              {
    203                // Convert and store in memory array
    204                uint8_t uint8_argument = (uint8_t)strtoul(argument, NULL, 0);
   \                     ??sli_cli_arguments_convert_single_0: (+1)
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x4658             MOV      R0,R11
   \       0x42   0x.... 0x....      BL       strtoul
    205                memory_array[*mem_index] = uint8_argument;
   \       0x46   0x0002             MOVS     R2,R0
   \       0x48   0xB2D2             UXTB     R2,R2
   \       0x4A   0x6839             LDR      R1,[R7, #+0]
   \       0x4C   0xF845 0x2021      STR      R2,[R5, R1, LSL #+2]
    206                argv[*arg_index] = &memory_array[*mem_index];
   \       0x50   0x6839             LDR      R1,[R7, #+0]
   \       0x52   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \       0x56   0x6832             LDR      R2,[R6, #+0]
   \       0x58   0xF844 0x1022      STR      R1,[R4, R2, LSL #+2]
    207                *mem_index = *mem_index + 1;
   \       0x5C   0x6839             LDR      R1,[R7, #+0]
   \       0x5E   0x1C49             ADDS     R1,R1,#+1
   \       0x60   0x6039             STR      R1,[R7, #+0]
    208              }
    209              break;
   \       0x62   0xE0A5             B.N      ??sli_cli_arguments_convert_single_10
    210              case SL_CLI_ARG_UINT16:
    211              {
    212                // Convert and store in memory array
    213                uint16_t uint16_argument = (uint16_t)strtoul(argument, NULL, 0);
   \                     ??sli_cli_arguments_convert_single_1: (+1)
   \       0x64   0x2200             MOVS     R2,#+0
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0x4658             MOV      R0,R11
   \       0x6A   0x.... 0x....      BL       strtoul
    214                memory_array[*mem_index] = uint16_argument;
   \       0x6E   0x0002             MOVS     R2,R0
   \       0x70   0xB292             UXTH     R2,R2
   \       0x72   0x6839             LDR      R1,[R7, #+0]
   \       0x74   0xF845 0x2021      STR      R2,[R5, R1, LSL #+2]
    215                argv[*arg_index] = &memory_array[*mem_index];
   \       0x78   0x6839             LDR      R1,[R7, #+0]
   \       0x7A   0xEB05 0x0281      ADD      R2,R5,R1, LSL #+2
   \       0x7E   0x6831             LDR      R1,[R6, #+0]
   \       0x80   0xF844 0x2021      STR      R2,[R4, R1, LSL #+2]
    216                *mem_index = *mem_index + 1;
   \       0x84   0x6839             LDR      R1,[R7, #+0]
   \       0x86   0x1C49             ADDS     R1,R1,#+1
   \       0x88   0x6039             STR      R1,[R7, #+0]
    217              }
    218              break;
   \       0x8A   0xE091             B.N      ??sli_cli_arguments_convert_single_10
    219              case SL_CLI_ARG_UINT32:
    220              {
    221                // Convert and store in memory array
    222                uint32_t uint32_argument = (uint32_t)strtoul(argument, NULL, 0);
   \                     ??sli_cli_arguments_convert_single_2: (+1)
   \       0x8C   0x2200             MOVS     R2,#+0
   \       0x8E   0x2100             MOVS     R1,#+0
   \       0x90   0x4658             MOV      R0,R11
   \       0x92   0x.... 0x....      BL       strtoul
    223                memory_array[*mem_index] = uint32_argument;
   \       0x96   0x6839             LDR      R1,[R7, #+0]
   \       0x98   0xF845 0x0021      STR      R0,[R5, R1, LSL #+2]
    224                argv[*arg_index] = &memory_array[*mem_index];
   \       0x9C   0x6839             LDR      R1,[R7, #+0]
   \       0x9E   0xEB05 0x0281      ADD      R2,R5,R1, LSL #+2
   \       0xA2   0x6831             LDR      R1,[R6, #+0]
   \       0xA4   0xF844 0x2021      STR      R2,[R4, R1, LSL #+2]
    225                *mem_index = *mem_index + 1;
   \       0xA8   0x6839             LDR      R1,[R7, #+0]
   \       0xAA   0x1C49             ADDS     R1,R1,#+1
   \       0xAC   0x6039             STR      R1,[R7, #+0]
    226              }
    227              break;
   \       0xAE   0xE07F             B.N      ??sli_cli_arguments_convert_single_10
    228              case SL_CLI_ARG_INT8:
    229              {
    230                // Convert and store in memory array
    231                int8_t int8_argument = (int8_t)strtol(argument, NULL, 0);
   \                     ??sli_cli_arguments_convert_single_3: (+1)
   \       0xB0   0x2200             MOVS     R2,#+0
   \       0xB2   0x2100             MOVS     R1,#+0
   \       0xB4   0x4658             MOV      R0,R11
   \       0xB6   0x.... 0x....      BL       strtol
    232                memory_array[*mem_index] = int8_argument;
   \       0xBA   0x0002             MOVS     R2,R0
   \       0xBC   0xB252             SXTB     R2,R2
   \       0xBE   0x6839             LDR      R1,[R7, #+0]
   \       0xC0   0xF845 0x2021      STR      R2,[R5, R1, LSL #+2]
    233                argv[*arg_index] = &memory_array[*mem_index];
   \       0xC4   0x6839             LDR      R1,[R7, #+0]
   \       0xC6   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \       0xCA   0x6832             LDR      R2,[R6, #+0]
   \       0xCC   0xF844 0x1022      STR      R1,[R4, R2, LSL #+2]
    234                *mem_index = *mem_index + 1;
   \       0xD0   0x6839             LDR      R1,[R7, #+0]
   \       0xD2   0x1C49             ADDS     R1,R1,#+1
   \       0xD4   0x6039             STR      R1,[R7, #+0]
    235              }
    236              break;
   \       0xD6   0xE06B             B.N      ??sli_cli_arguments_convert_single_10
    237              case SL_CLI_ARG_INT16:
    238              {
    239                // Convert and store in memory array
    240                int16_t int16_argument = (int16_t)strtol(argument, NULL, 0);
   \                     ??sli_cli_arguments_convert_single_4: (+1)
   \       0xD8   0x2200             MOVS     R2,#+0
   \       0xDA   0x2100             MOVS     R1,#+0
   \       0xDC   0x4658             MOV      R0,R11
   \       0xDE   0x.... 0x....      BL       strtol
    241                memory_array[*mem_index] = int16_argument;
   \       0xE2   0x0001             MOVS     R1,R0
   \       0xE4   0xB209             SXTH     R1,R1
   \       0xE6   0x683A             LDR      R2,[R7, #+0]
   \       0xE8   0xF845 0x1022      STR      R1,[R5, R2, LSL #+2]
    242                argv[*arg_index] = &memory_array[*mem_index];
   \       0xEC   0x6839             LDR      R1,[R7, #+0]
   \       0xEE   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \       0xF2   0x6832             LDR      R2,[R6, #+0]
   \       0xF4   0xF844 0x1022      STR      R1,[R4, R2, LSL #+2]
    243                *mem_index = *mem_index + 1;
   \       0xF8   0x6839             LDR      R1,[R7, #+0]
   \       0xFA   0x1C49             ADDS     R1,R1,#+1
   \       0xFC   0x6039             STR      R1,[R7, #+0]
    244              }
    245              break;
   \       0xFE   0xE057             B.N      ??sli_cli_arguments_convert_single_10
    246              case SL_CLI_ARG_INT32:
    247              {
    248                // Convert and store in memory array
    249                int32_t int32_argument = (int32_t)strtol(argument, NULL, 0);
   \                     ??sli_cli_arguments_convert_single_5: (+1)
   \      0x100   0x2200             MOVS     R2,#+0
   \      0x102   0x2100             MOVS     R1,#+0
   \      0x104   0x4658             MOV      R0,R11
   \      0x106   0x.... 0x....      BL       strtol
    250                memory_array[*mem_index] = int32_argument;
   \      0x10A   0x6839             LDR      R1,[R7, #+0]
   \      0x10C   0xF845 0x0021      STR      R0,[R5, R1, LSL #+2]
    251                argv[*arg_index] = &memory_array[*mem_index];
   \      0x110   0x6839             LDR      R1,[R7, #+0]
   \      0x112   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \      0x116   0x6832             LDR      R2,[R6, #+0]
   \      0x118   0xF844 0x1022      STR      R1,[R4, R2, LSL #+2]
    252                *mem_index = *mem_index + 1;
   \      0x11C   0x6839             LDR      R1,[R7, #+0]
   \      0x11E   0x1C49             ADDS     R1,R1,#+1
   \      0x120   0x6039             STR      R1,[R7, #+0]
    253              }
    254              break;
   \      0x122   0xE045             B.N      ??sli_cli_arguments_convert_single_10
    255              case SL_CLI_ARG_STRING:
    256              {
    257                // Argument is already a string, so just point to it
    258                argv[*arg_index] = argument;
   \                     ??sli_cli_arguments_convert_single_6: (+1)
   \      0x124   0x6830             LDR      R0,[R6, #+0]
   \      0x126   0xF844 0xB020      STR      R11,[R4, R0, LSL #+2]
    259              }
    260              break;
   \      0x12A   0xE041             B.N      ??sli_cli_arguments_convert_single_10
    261              case SL_CLI_ARG_HEX:
    262              {
    263                // Hex strings are converted byte by byte
    264                int j = 1;
   \                     ??sli_cli_arguments_convert_single_7: (+1)
   \      0x12C   0xF05F 0x0801      MOVS     R8,#+1
    265                uint16_t byte_count = 0;
   \      0x130   0xF05F 0x0900      MOVS     R9,#+0
    266                int digit_count = 0;
   \      0x134   0xF05F 0x0A00      MOVS     R10,#+0
    267                char current_hex_number[3];
    268          
    269                current_hex_number[2] = '\0';
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    270                while (argument[j] != '}') {
   \                     ??sli_cli_arguments_convert_single_11: (+1)
   \      0x13E   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \      0x142   0x287D             CMP      R0,#+125
   \      0x144   0xD024             BEQ.N    ??sli_cli_arguments_convert_single_12
    271                  if (argument[j] == ' ') {
   \      0x146   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \      0x14A   0x2820             CMP      R0,#+32
   \      0x14C   0xD102             BNE.N    ??sli_cli_arguments_convert_single_13
    272                    // Ignore space
    273                    j++;
   \      0x14E   0xF118 0x0801      ADDS     R8,R8,#+1
    274                    continue;
   \      0x152   0xE7F4             B.N      ??sli_cli_arguments_convert_single_11
    275                  } else if (digit_count % 2 == 0) {
   \                     ??sli_cli_arguments_convert_single_13: (+1)
   \      0x154   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \      0x158   0xD406             BMI.N    ??sli_cli_arguments_convert_single_14
    276                    // Interpret input in pairs, so just ignore every other character
    277                    current_hex_number[0] = argument[j];
   \      0x15A   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \      0x15E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    278                    digit_count++;
   \      0x162   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x166   0xE010             B.N      ??sli_cli_arguments_convert_single_15
    279                  } else {
    280                    // Convert and store in the argument buffer.
    281                    current_hex_number[1] = argument[j];
   \                     ??sli_cli_arguments_convert_single_14: (+1)
   \      0x168   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \      0x16C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    282                    digit_count++;
   \      0x170   0xF11A 0x0A01      ADDS     R10,R10,#+1
    283                    argument[byte_count + 2] = (char)strtol(current_hex_number, NULL, 16);
   \      0x174   0x2210             MOVS     R2,#+16
   \      0x176   0x2100             MOVS     R1,#+0
   \      0x178   0x4668             MOV      R0,SP
   \      0x17A   0x.... 0x....      BL       strtol
   \      0x17E   0x4649             MOV      R1,R9
   \      0x180   0xB289             UXTH     R1,R1
   \      0x182   0x4459             ADD      R1,R11,R1
   \      0x184   0x7088             STRB     R0,[R1, #+2]
    284                    byte_count++;
   \      0x186   0xF119 0x0901      ADDS     R9,R9,#+1
    285                  }
    286                  j++;
   \                     ??sli_cli_arguments_convert_single_15: (+1)
   \      0x18A   0xF118 0x0801      ADDS     R8,R8,#+1
   \      0x18E   0xE7D6             B.N      ??sli_cli_arguments_convert_single_11
    287                }
    288                // Byte 0 and 1 shall contain the length, while byte 2..n shall contain the data.
    289                argument[0] = (char)byte_count;
   \                     ??sli_cli_arguments_convert_single_12: (+1)
   \      0x190   0xF88B 0x9000      STRB     R9,[R11, #+0]
    290                argument[1] = (char)(byte_count >> 8);
   \      0x194   0x4648             MOV      R0,R9
   \      0x196   0xB280             UXTH     R0,R0
   \      0x198   0x0A00             LSRS     R0,R0,#+8
   \      0x19A   0xF88B 0x0001      STRB     R0,[R11, #+1]
    291                // Point argv to the decoded argument buffer.
    292                argv[*arg_index] = argument;
   \      0x19E   0x6830             LDR      R0,[R6, #+0]
   \      0x1A0   0xF844 0xB020      STR      R11,[R4, R0, LSL #+2]
    293              }
    294              break;
   \      0x1A4   0xE004             B.N      ??sli_cli_arguments_convert_single_10
    295              case SL_CLI_ARG_WILDCARD:
    296              {
    297                // Wildcard argument. Do no parsing
    298                argv[*arg_index] = argument;
   \                     ??sli_cli_arguments_convert_single_8: (+1)
   \      0x1A6   0x6830             LDR      R0,[R6, #+0]
   \      0x1A8   0xF844 0xB020      STR      R11,[R4, R0, LSL #+2]
    299              }
    300              break;
   \      0x1AC   0xE000             B.N      ??sli_cli_arguments_convert_single_10
    301              default:
    302                // Unknown argument, do nothing and don't increment counter
    303                return;
   \                     ??sli_cli_arguments_convert_single_9: (+1)
   \      0x1AE   0xE002             B.N      ??sli_cli_arguments_convert_single_16
    304            }
    305            *arg_index = *arg_index + 1;
   \                     ??sli_cli_arguments_convert_single_10: (+1)
   \      0x1B0   0x6830             LDR      R0,[R6, #+0]
   \      0x1B2   0x1C40             ADDS     R0,R0,#+1
   \      0x1B4   0x6030             STR      R0,[R6, #+0]
    306          }
   \                     ??sli_cli_arguments_convert_single_16: (+1)
   \      0x1B6   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    307          

   \                                 In section .text, align 2, keep-with-next
    308          sl_status_t sli_cli_arguments_convert_multiple(const sl_cli_argument_type_t *arg_type_list,
    309                                                         const int token_c,
    310                                                         char *token_v[],
    311                                                         int arg_ofs,
    312                                                         void *argv[],
    313                                                         uint32_t *memory_array)
    314          {
   \                     sli_cli_arguments_convert_multiple: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
    315            int arg_index = 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9005             STR      R0,[SP, #+20]
    316            int mem_index = 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x9003             STR      R0,[SP, #+12]
    317            sl_cli_argument_type_t argument_type = SL_CLI_ARG_END;
   \       0x14   0x26FF             MOVS     R6,#+255
    318            bool additional_or_wildcard = false;
   \       0x16   0x2700             MOVS     R7,#+0
    319            bool optional = false;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF88D 0x0009      STRB     R0,[SP, #+9]
    320            bool wildcard = false;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF88D 0x0008      STRB     R0,[SP, #+8]
    321            int arg_type_c = 0;
   \       0x24   0xF05F 0x0800      MOVS     R8,#+0
    322            int arg_total_c;
    323          
    324            // Sanity check of input parameters
    325            if (arg_ofs > token_c) {
   \       0x28   0x9806             LDR      R0,[SP, #+24]
   \       0x2A   0x4284             CMP      R4,R0
   \       0x2C   0xDA01             BGE.N    ??sli_cli_arguments_convert_multiple_0
    326              return SL_STATUS_INVALID_PARAMETER;
   \       0x2E   0x2021             MOVS     R0,#+33
   \       0x30   0xE0A1             B.N      ??sli_cli_arguments_convert_multiple_1
    327            }
    328          
    329            // Check if there is a wildcard or additional argument type in list
    330            while (arg_type_list[arg_type_c] != SL_CLI_ARG_END) {
   \                     ??sli_cli_arguments_convert_multiple_0: (+1)
   \       0x32   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \       0x36   0x28FF             CMP      R0,#+255
   \       0x38   0xD019             BEQ.N    ??sli_cli_arguments_convert_multiple_2
    331              if (arg_type_list[arg_type_c] == SL_CLI_ARG_ADDITIONAL) {
   \       0x3A   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \       0x3E   0x2820             CMP      R0,#+32
   \       0x40   0xD102             BNE.N    ??sli_cli_arguments_convert_multiple_3
    332                additional_or_wildcard = true;
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0x0007             MOVS     R7,R0
   \       0x46   0xE00F             B.N      ??sli_cli_arguments_convert_multiple_4
    333              } else if (arg_type_list[arg_type_c] == SL_CLI_ARG_WILDCARD) {
   \                     ??sli_cli_arguments_convert_multiple_3: (+1)
   \       0x48   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \       0x4C   0x2821             CMP      R0,#+33
   \       0x4E   0xD102             BNE.N    ??sli_cli_arguments_convert_multiple_5
    334                additional_or_wildcard = true;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0x0007             MOVS     R7,R0
   \       0x54   0xE008             B.N      ??sli_cli_arguments_convert_multiple_4
    335              } else if (is_argument_optional(arg_type_list[arg_type_c])) {
   \                     ??sli_cli_arguments_convert_multiple_5: (+1)
   \       0x56   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \       0x5A   0x.... 0x....      BL       is_argument_optional
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD002             BEQ.N    ??sli_cli_arguments_convert_multiple_4
    336                optional = true;
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0xF88D 0x0009      STRB     R0,[SP, #+9]
    337              }
    338              arg_type_c++;
   \                     ??sli_cli_arguments_convert_multiple_4: (+1)
   \       0x68   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x6C   0xE7E1             B.N      ??sli_cli_arguments_convert_multiple_0
    339            }
    340            arg_total_c = arg_type_c + arg_ofs;
   \                     ??sli_cli_arguments_convert_multiple_2: (+1)
   \       0x6E   0x9806             LDR      R0,[SP, #+24]
   \       0x70   0xEB10 0x0008      ADDS     R0,R0,R8
   \       0x74   0x9004             STR      R0,[SP, #+16]
    341          
    342            // Check the number of arguments
    343            if (additional_or_wildcard) {
   \       0x76   0x0038             MOVS     R0,R7
   \       0x78   0xB2C0             UXTB     R0,R0
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD005             BEQ.N    ??sli_cli_arguments_convert_multiple_6
    344              if (token_c < (arg_total_c - 1)) {
   \       0x7E   0x9804             LDR      R0,[SP, #+16]
   \       0x80   0x1E40             SUBS     R0,R0,#+1
   \       0x82   0x4284             CMP      R4,R0
   \       0x84   0xDA10             BGE.N    ??sli_cli_arguments_convert_multiple_7
    345                return SL_STATUS_INVALID_COUNT;
   \       0x86   0x202B             MOVS     R0,#+43
   \       0x88   0xE075             B.N      ??sli_cli_arguments_convert_multiple_1
    346              }
    347            } else if (optional) {
   \                     ??sli_cli_arguments_convert_multiple_6: (+1)
   \       0x8A   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD005             BEQ.N    ??sli_cli_arguments_convert_multiple_8
    348              if (token_c < (arg_total_c - 1)) {
   \       0x92   0x9804             LDR      R0,[SP, #+16]
   \       0x94   0x1E40             SUBS     R0,R0,#+1
   \       0x96   0x4284             CMP      R4,R0
   \       0x98   0xDA06             BGE.N    ??sli_cli_arguments_convert_multiple_7
    349                return SL_STATUS_INVALID_COUNT;
   \       0x9A   0x202B             MOVS     R0,#+43
   \       0x9C   0xE06B             B.N      ??sli_cli_arguments_convert_multiple_1
    350              }
    351            } else {
    352              if (token_c != arg_total_c) {
   \                     ??sli_cli_arguments_convert_multiple_8: (+1)
   \       0x9E   0x9804             LDR      R0,[SP, #+16]
   \       0xA0   0x4284             CMP      R4,R0
   \       0xA2   0xD001             BEQ.N    ??sli_cli_arguments_convert_multiple_7
    353                return SL_STATUS_INVALID_COUNT;
   \       0xA4   0x202B             MOVS     R0,#+43
   \       0xA6   0xE066             B.N      ??sli_cli_arguments_convert_multiple_1
    354              }
    355            }
    356          
    357            // Convert and validate arguments with correct argument type
    358            int type_o = 0;
   \                     ??sli_cli_arguments_convert_multiple_7: (+1)
   \       0xA8   0xF05F 0x0900      MOVS     R9,#+0
    359            for (int i = 0; i < token_c; i++) {
   \       0xAC   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??sli_cli_arguments_convert_multiple_9: (+1)
   \       0xB0   0x45A2             CMP      R10,R4
   \       0xB2   0xDA5F             BGE.N    ??sli_cli_arguments_convert_multiple_10
    360              // Set correct argument type of variables until the additional or wildcard
    361              // type is reached, if there is one
    362              if (i < arg_ofs) {
   \       0xB4   0x9806             LDR      R0,[SP, #+24]
   \       0xB6   0x4582             CMP      R10,R0
   \       0xB8   0xDA02             BGE.N    ??sli_cli_arguments_convert_multiple_11
    363                // commands are strings
    364                argument_type = SL_CLI_ARG_STRING;
   \       0xBA   0x2006             MOVS     R0,#+6
   \       0xBC   0x0006             MOVS     R6,R0
   \       0xBE   0xE030             B.N      ??sli_cli_arguments_convert_multiple_12
    365              } else {
    366                if (arg_type_list[type_o] == SL_CLI_ARG_ADDITIONAL) {
   \                     ??sli_cli_arguments_convert_multiple_11: (+1)
   \       0xC0   0xF81B 0x0009      LDRB     R0,[R11, R9]
   \       0xC4   0x2820             CMP      R0,#+32
   \       0xC6   0xD106             BNE.N    ??sli_cli_arguments_convert_multiple_13
    367                  // If argument type is additional, argument_type variable should be unchanged
    368                  if (arg_type_list[type_o + 1] != SL_CLI_ARG_END) {
   \       0xC8   0xEB0B 0x0009      ADD      R0,R11,R9
   \       0xCC   0x7840             LDRB     R0,[R0, #+1]
   \       0xCE   0x28FF             CMP      R0,#+255
   \       0xD0   0xD027             BEQ.N    ??sli_cli_arguments_convert_multiple_12
    369                    return SL_STATUS_INVALID_COUNT;
   \       0xD2   0x202B             MOVS     R0,#+43
   \       0xD4   0xE04F             B.N      ??sli_cli_arguments_convert_multiple_1
    370                  }
    371                } else if (arg_type_list[type_o] == SL_CLI_ARG_WILDCARD) {
   \                     ??sli_cli_arguments_convert_multiple_13: (+1)
   \       0xD6   0xF81B 0x0009      LDRB     R0,[R11, R9]
   \       0xDA   0x2821             CMP      R0,#+33
   \       0xDC   0xD109             BNE.N    ??sli_cli_arguments_convert_multiple_14
    372                  // If argument type is wildcard, wildcard variable is to true so that
    373                  // no validation is conducted
    374                  wildcard = true;
   \       0xDE   0x2001             MOVS     R0,#+1
   \       0xE0   0xF88D 0x0008      STRB     R0,[SP, #+8]
    375                  if (arg_type_list[type_o + 1] != SL_CLI_ARG_END) {
   \       0xE4   0xEB0B 0x0009      ADD      R0,R11,R9
   \       0xE8   0x7840             LDRB     R0,[R0, #+1]
   \       0xEA   0x28FF             CMP      R0,#+255
   \       0xEC   0xD019             BEQ.N    ??sli_cli_arguments_convert_multiple_12
    376                    return SL_STATUS_INVALID_COUNT;
   \       0xEE   0x202B             MOVS     R0,#+43
   \       0xF0   0xE041             B.N      ??sli_cli_arguments_convert_multiple_1
    377                  }
    378                } else if (is_argument_optional(arg_type_list[type_o])) {
   \                     ??sli_cli_arguments_convert_multiple_14: (+1)
   \       0xF2   0xF81B 0x0009      LDRB     R0,[R11, R9]
   \       0xF6   0x.... 0x....      BL       is_argument_optional
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xD00C             BEQ.N    ??sli_cli_arguments_convert_multiple_15
    379                  // If argument type is optional
    380                  if (arg_type_list[type_o + 1] != SL_CLI_ARG_END) {
   \       0xFE   0xEB0B 0x0009      ADD      R0,R11,R9
   \      0x102   0x7840             LDRB     R0,[R0, #+1]
   \      0x104   0x28FF             CMP      R0,#+255
   \      0x106   0xD001             BEQ.N    ??sli_cli_arguments_convert_multiple_16
    381                    return SL_STATUS_INVALID_COUNT;
   \      0x108   0x202B             MOVS     R0,#+43
   \      0x10A   0xE034             B.N      ??sli_cli_arguments_convert_multiple_1
    382                  }
    383                  argument_type = optional_to_mandatory(arg_type_list[type_o]);
   \                     ??sli_cli_arguments_convert_multiple_16: (+1)
   \      0x10C   0xF81B 0x0009      LDRB     R0,[R11, R9]
   \      0x110   0x.... 0x....      BL       optional_to_mandatory
   \      0x114   0x0006             MOVS     R6,R0
   \      0x116   0xE004             B.N      ??sli_cli_arguments_convert_multiple_12
    384                } else {
    385                  // If argument type is something else, argument_type variable should be
    386                  // set to the argument type in index i of arg_type_list array
    387                  argument_type = arg_type_list[type_o];
   \                     ??sli_cli_arguments_convert_multiple_15: (+1)
   \      0x118   0xF81B 0x0009      LDRB     R0,[R11, R9]
   \      0x11C   0x0006             MOVS     R6,R0
    388                  type_o++;
   \      0x11E   0xF119 0x0901      ADDS     R9,R9,#+1
    389                }
    390              }
    391          
    392              // Validate and convert argument type unless it is a wildcard in which case
    393              // it will only be converted, not validated
    394              if (!wildcard) {
   \                     ??sli_cli_arguments_convert_multiple_12: (+1)
   \      0x122   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD116             BNE.N    ??sli_cli_arguments_convert_multiple_17
    395                if (sli_cli_validate_argument(argument_type, token_v[i])) {
   \      0x12A   0xF855 0x102A      LDR      R1,[R5, R10, LSL #+2]
   \      0x12E   0x0030             MOVS     R0,R6
   \      0x130   0xB2C0             UXTB     R0,R0
   \      0x132   0x.... 0x....      BL       sli_cli_validate_argument
   \      0x136   0x2800             CMP      R0,#+0
   \      0x138   0xD00C             BEQ.N    ??sli_cli_arguments_convert_multiple_18
    396                  sli_cli_arguments_convert_single(argument_type, token_v[i], argv, memory_array,
    397                                                   &arg_index, &mem_index);
   \      0x13A   0xA803             ADD      R0,SP,#+12
   \      0x13C   0x9001             STR      R0,[SP, #+4]
   \      0x13E   0xA805             ADD      R0,SP,#+20
   \      0x140   0x9000             STR      R0,[SP, #+0]
   \      0x142   0x9B11             LDR      R3,[SP, #+68]
   \      0x144   0x9A10             LDR      R2,[SP, #+64]
   \      0x146   0xF855 0x102A      LDR      R1,[R5, R10, LSL #+2]
   \      0x14A   0x0030             MOVS     R0,R6
   \      0x14C   0xB2C0             UXTB     R0,R0
   \      0x14E   0x.... 0x....      BL       sli_cli_arguments_convert_single
   \      0x152   0xE00C             B.N      ??sli_cli_arguments_convert_multiple_19
    398                } else {
    399                  return SL_STATUS_INVALID_TYPE;
   \                     ??sli_cli_arguments_convert_multiple_18: (+1)
   \      0x154   0x2026             MOVS     R0,#+38
   \      0x156   0xE00E             B.N      ??sli_cli_arguments_convert_multiple_1
    400                }
    401              } else {
    402                sli_cli_arguments_convert_single(SL_CLI_ARG_WILDCARD, token_v[i], argv, memory_array,
    403                                                 &arg_index, &mem_index);
   \                     ??sli_cli_arguments_convert_multiple_17: (+1)
   \      0x158   0xA803             ADD      R0,SP,#+12
   \      0x15A   0x9001             STR      R0,[SP, #+4]
   \      0x15C   0xA805             ADD      R0,SP,#+20
   \      0x15E   0x9000             STR      R0,[SP, #+0]
   \      0x160   0x9B11             LDR      R3,[SP, #+68]
   \      0x162   0x9A10             LDR      R2,[SP, #+64]
   \      0x164   0xF855 0x102A      LDR      R1,[R5, R10, LSL #+2]
   \      0x168   0x2021             MOVS     R0,#+33
   \      0x16A   0x.... 0x....      BL       sli_cli_arguments_convert_single
    404              }
    405            }
   \                     ??sli_cli_arguments_convert_multiple_19: (+1)
   \      0x16E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x172   0xE79D             B.N      ??sli_cli_arguments_convert_multiple_9
    406          
    407            return SL_STATUS_OK;
   \                     ??sli_cli_arguments_convert_multiple_10: (+1)
   \      0x174   0x2000             MOVS     R0,#+0
   \                     ??sli_cli_arguments_convert_multiple_1: (+1)
   \      0x176   0xB007             ADD      SP,SP,#+28
   \      0x178   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    408          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   is_argument_optional
       0   optional_to_mandatory
      64   sli_cli_arguments_convert_multiple
        64   -> is_argument_optional
        64   -> optional_to_mandatory
        64   -> sli_cli_arguments_convert_single
        64   -> sli_cli_validate_argument
      48   sli_cli_arguments_convert_single
        48   -> strtol
        48   -> strtoul
      24   sli_cli_arguments_validate_hex_string
        24   -> isxdigit
      16   sli_cli_arguments_validate_int
        16   -> sli_cli_arguments_validate_uint
      24   sli_cli_arguments_validate_uint
        24   -> isdigit
        24   -> isxdigit
        24   -> strlen
        24   -> strtoll
      16   sli_cli_validate_argument
        16   -> sli_cli_arguments_validate_hex_string
        16   -> sli_cli_arguments_validate_int
        16   -> sli_cli_arguments_validate_uint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  is_argument_optional
      20  optional_to_mandatory
     380  sli_cli_arguments_convert_multiple
     442  sli_cli_arguments_convert_single
     106  sli_cli_arguments_validate_hex_string
      38  sli_cli_arguments_validate_int
     320  sli_cli_arguments_validate_uint
     120  sli_cli_validate_argument

 
 1'446 bytes in section .text
 
 1'446 bytes of CODE memory

Errors: none
Warnings: none
