###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:07
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_mac.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_mac.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_mac.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_mac.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir\sli_se_driver_mac.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_mac.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_mac.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Driver Mac functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "sli_psa_driver_common.h"  // sli_psa_zeroize()
     36          #include "psa/crypto.h"
     37          
     38          #include "mbedtls/platform.h"
     39          
     40          #include "sli_se_driver_mac.h"
     41          #include "sli_se_manager_internal.h"
     42          #include "sli_se_driver_key_management.h"
     43          #include "sli_psa_driver_common.h"
     44          
     45          #include <string.h>
     46          
     47          //------------------------------------------------------------------------------
     48          // Static functions
     49          
     50          #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
     51          

   \                                 In section .text, align 2, keep-with-next
     52          sl_se_hash_type_t sli_se_hash_type_from_psa_hmac_alg(psa_algorithm_t alg,
     53                                                               size_t *length)
     54          {
     55            if (!PSA_ALG_IS_HMAC(alg)) {
   \                     sli_se_hash_type_from_psa_hmac_alg: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable1
   \        0x2   0x4002             ANDS     R2,R2,R0
   \        0x4   0xF1B2 0x7F60      CMP      R2,#+58720256
   \        0x8   0xD123             BNE.N    ??sli_se_hash_type_from_psa_hmac_alg_0
     56              return SL_SE_HASH_NONE;
     57            }
     58          
     59            psa_algorithm_t hash_alg = PSA_ALG_HMAC_GET_HASH(alg);
     60            switch (hash_alg) {
   \        0xA   0xF000 0x00FF      AND      R0,R0,#0xFF
   \        0xE   0xF040 0x7000      ORR      R0,R0,#0x2000000
   \       0x12   0x....             LDR.N    R2,??DataTable1_1
   \       0x14   0x1A80             SUBS     R0,R0,R2
   \       0x16   0xD008             BEQ.N    ??sli_se_hash_type_from_psa_hmac_alg_1
   \       0x18   0x1EC0             SUBS     R0,R0,#+3
   \       0x1A   0xD00A             BEQ.N    ??sli_se_hash_type_from_psa_hmac_alg_2
   \       0x1C   0x1E40             SUBS     R0,R0,#+1
   \       0x1E   0xD00C             BEQ.N    ??sli_se_hash_type_from_psa_hmac_alg_3
   \       0x20   0x1E40             SUBS     R0,R0,#+1
   \       0x22   0xD00E             BEQ.N    ??sli_se_hash_type_from_psa_hmac_alg_4
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0xD010             BEQ.N    ??sli_se_hash_type_from_psa_hmac_alg_5
   \       0x28   0xE013             B.N      ??sli_se_hash_type_from_psa_hmac_alg_0
     61              case PSA_ALG_SHA_1:
     62                *length = 20;
   \                     ??sli_se_hash_type_from_psa_hmac_alg_1: (+1)
   \       0x2A   0x2014             MOVS     R0,#+20
   \       0x2C   0x6008             STR      R0,[R1, #+0]
     63                return SL_SE_HASH_SHA1;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x4770             BX       LR
     64              case PSA_ALG_SHA_224:
     65                *length = 28;
   \                     ??sli_se_hash_type_from_psa_hmac_alg_2: (+1)
   \       0x32   0x221C             MOVS     R2,#+28
   \       0x34   0x600A             STR      R2,[R1, #+0]
     66                return SL_SE_HASH_SHA224;
   \       0x36   0x2002             MOVS     R0,#+2
   \       0x38   0x4770             BX       LR
     67              case PSA_ALG_SHA_256:
     68                *length = 32;
   \                     ??sli_se_hash_type_from_psa_hmac_alg_3: (+1)
   \       0x3A   0x2020             MOVS     R0,#+32
   \       0x3C   0x6008             STR      R0,[R1, #+0]
     69                return SL_SE_HASH_SHA256;
   \       0x3E   0x2003             MOVS     R0,#+3
   \       0x40   0x4770             BX       LR
     70          
     71                #if defined(SLI_MBEDTLS_DEVICE_HSE_VAULT_HIGH)
     72              case PSA_ALG_SHA_384:
     73                *length = 48;
   \                     ??sli_se_hash_type_from_psa_hmac_alg_4: (+1)
   \       0x42   0x2230             MOVS     R2,#+48
   \       0x44   0x600A             STR      R2,[R1, #+0]
     74                return SL_SE_HASH_SHA384;
   \       0x46   0x2004             MOVS     R0,#+4
   \       0x48   0x4770             BX       LR
     75              case PSA_ALG_SHA_512:
     76                *length = 64;
   \                     ??sli_se_hash_type_from_psa_hmac_alg_5: (+1)
   \       0x4A   0x2040             MOVS     R0,#+64
   \       0x4C   0x6008             STR      R0,[R1, #+0]
     77                return SL_SE_HASH_SHA512;
   \       0x4E   0x2005             MOVS     R0,#+5
   \       0x50   0x4770             BX       LR
     78                #endif
     79          
     80              default:
     81                return SL_SE_HASH_NONE;
   \                     ??sli_se_hash_type_from_psa_hmac_alg_0: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x4770             BX       LR
     82            }
     83          }
     84          
     85          #endif // SLI_PSA_DRIVER_FEATURE_HMAC
     86          
     87          //------------------------------------------------------------------------------
     88          // Single-shot driver entry points
     89          

   \                                 In section .text, align 2, keep-with-next
     90          psa_status_t sli_se_driver_mac_compute(sl_se_key_descriptor_t *key_desc,
     91                                                 psa_algorithm_t alg,
     92                                                 const uint8_t *input,
     93                                                 size_t input_length,
     94                                                 uint8_t *mac,
     95                                                 size_t mac_size,
     96                                                 size_t *mac_length)
     97          {
   \                     sli_se_driver_mac_compute: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB096             SUB      SP,SP,#+88
   \        0x6   0x9F20             LDR      R7,[SP, #+128]
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x461E             MOV      R6,R3
     98            #if defined(SLI_PSA_DRIVER_FEATURE_MAC)
     99          
    100            if (mac == NULL
    101                || mac_length == NULL
    102                || key_desc == NULL) {
   \        0xE   0xF06F 0x0A86      MVN      R10,#+134
   \       0x12   0x2F00             CMP      R7,#+0
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0x9C22             LDRNE    R4,[SP, #+136]
   \       0x18   0x2C00             CMPNE    R4,#+0
   \       0x1A   0xD023             BEQ.N    ??sli_se_driver_mac_compute_0
   \       0x1C   0x9004             STR      R0,[SP, #+16]
   \       0x1E   0x0001             MOVS     R1,R0
   \       0x20   0xD020             BEQ.N    ??sli_se_driver_mac_compute_0
    103              return PSA_ERROR_INVALID_ARGUMENT;
    104            }
    105          
    106            sl_status_t status;
    107            psa_status_t psa_status = PSA_ERROR_INVALID_ARGUMENT;
    108            sl_se_command_context_t cmd_ctx = { 0 };
   \       0x22   0xA80D             ADD      R0,SP,#+52
   \       0x24   0x2124             MOVS     R1,#+36
   \       0x26   0x.... 0x....      BL       __aeabi_memclr4
    109          
    110            status = sl_se_init_command_context(&cmd_ctx);
    111            if (status != SL_STATUS_OK) {
   \       0x2A   0xA80D             ADD      R0,SP,#+52
   \       0x2C   0x.... 0x....      BL       sl_se_init_command_context
   \       0x30   0x46D0             MOV      R8,R10
   \       0x32   0xF06F 0x0B92      MVN      R11,#+146
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD14F             BNE.N    ??sli_se_driver_mac_compute_1
    112              return PSA_ERROR_HARDWARE_FAILURE;
    113            }
    114          
    115            #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
    116            if (PSA_ALG_IS_HMAC(alg)) {
   \       0x3A   0x....             LDR.N    R1,??DataTable1
   \       0x3C   0xEA01 0x0109      AND      R1,R1,R9
   \       0x40   0xF1B1 0x7F60      CMP      R1,#+58720256
   \       0x44   0xD143             BNE.N    ??sli_se_driver_mac_compute_2
    117              #if defined(SLI_PSA_DRIVER_FEATURE_HASH_STATE_64)
    118              uint8_t tmp_hmac[64];
    119              #else
    120              uint8_t tmp_hmac[32];
    121              #endif
    122          
    123              size_t requested_length = 0;
   \       0x46   0x9003             STR      R0,[SP, #+12]
    124              sl_se_hash_type_t hash_type =
    125                sli_se_hash_type_from_psa_hmac_alg(alg, &requested_length);
   \       0x48   0xA903             ADD      R1,SP,#+12
   \       0x4A   0x4648             MOV      R0,R9
   \       0x4C   0x.... 0x....      BL       sli_se_hash_type_from_psa_hmac_alg
    126              if (hash_type == SL_SE_HASH_NONE) {
   \       0x50   0x0001             MOVS     R1,R0
   \       0x52   0xBF08             IT       EQ
   \       0x54   0xF06F 0x0085      MVNEQ    R0,#+133
    127                return PSA_ERROR_NOT_SUPPORTED;
   \       0x58   0xD042             BEQ.N    ??sli_se_driver_mac_compute_3
    128              }
    129          
    130              if (PSA_MAC_TRUNCATED_LENGTH(alg) > requested_length) {
   \       0x5A   0x9A03             LDR      R2,[SP, #+12]
   \       0x5C   0xF3C9 0x4105      UBFX     R1,R9,#+16,#+6
   \       0x60   0x428A             CMP      R2,R1
   \       0x62   0xD201             BCS.N    ??sli_se_driver_mac_compute_4
    131                return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_mac_compute_0: (+1)
   \       0x64   0x4650             MOV      R0,R10
   \       0x66   0xE03B             B.N      ??sli_se_driver_mac_compute_3
    132              }
    133          
    134              if (PSA_MAC_TRUNCATED_LENGTH(alg) > 0) {
   \                     ??sli_se_driver_mac_compute_4: (+1)
   \       0x68   0xB101             CBZ.N    R1,??sli_se_driver_mac_compute_5
    135                requested_length = PSA_MAC_TRUNCATED_LENGTH(alg);
   \       0x6A   0x9103             STR      R1,[SP, #+12]
   \                     ??sli_se_driver_mac_compute_5: (+1)
   \       0x6C   0x9A21             LDR      R2,[SP, #+132]
    136              }
    137          
    138              if (mac_size < requested_length) {
   \       0x6E   0x9903             LDR      R1,[SP, #+12]
   \       0x70   0x428A             CMP      R2,R1
   \       0x72   0xBF38             IT       CC
   \       0x74   0xF06F 0x0089      MVNCC    R0,#+137
    139                return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x78   0xD332             BCC.N    ??sli_se_driver_mac_compute_3
    140              }
    141          
    142              #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    143              uint8_t *temp_key_buf = NULL;
    144              uint32_t key_buffer_size = key_desc->storage.location.buffer.size;
    145              size_t padding = sli_se_get_padding(key_buffer_size);
    146              size_t word_aligned_buffer_size = 0;
    147          
    148              if (padding > 0u) {
    149                // We can only manipulate the transparent keys.
    150                if (key_desc->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
    151                  word_aligned_buffer_size
    152                    = sli_se_word_align(key_desc->storage.location.buffer.size);
    153                  temp_key_buf = mbedtls_calloc(1, word_aligned_buffer_size);
    154                  if (temp_key_buf == NULL) {
    155                    return PSA_ERROR_INSUFFICIENT_MEMORY;
    156                  }
    157          
    158                  // Since we know that this must be a plaintext key, we can freely
    159                  // modify the key descriptor
    160                  memcpy(temp_key_buf,
    161                         key_desc->storage.location.buffer.pointer,
    162                         key_desc->storage.location.buffer.size);
    163                  key_desc->storage.location.buffer.pointer = temp_key_buf;
    164                  key_desc->storage.location.buffer.size = word_aligned_buffer_size;
    165                }
    166              }
    167              #endif     // SLI_SE_KEY_PADDING_REQUIRED
    168          
    169              status = sl_se_hmac(&cmd_ctx,
    170                                  key_desc,
    171                                  hash_type,
    172                                  input,
    173                                  input_length,
    174                                  tmp_hmac,
    175                                  sizeof(tmp_hmac));
   \       0x7A   0xA905             ADD      R1,SP,#+20
   \       0x7C   0x2220             MOVS     R2,#+32
   \       0x7E   0x9101             STR      R1,[SP, #+4]
   \       0x80   0x9202             STR      R2,[SP, #+8]
   \       0x82   0x9904             LDR      R1,[SP, #+16]
   \       0x84   0x4602             MOV      R2,R0
   \       0x86   0x462B             MOV      R3,R5
   \       0x88   0x9600             STR      R6,[SP, #+0]
   \       0x8A   0xA80D             ADD      R0,SP,#+52
   \       0x8C   0x.... 0x....      BL       sl_se_hmac
   \       0x90   0x0005             MOVS     R5,R0
    176          
    177              #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    178              if (padding > 0u) {
    179                sli_psa_zeroize(temp_key_buf, word_aligned_buffer_size);
    180                mbedtls_free(temp_key_buf);
    181              }
    182              #endif     // SLI_SE_KEY_PADDING_REQUIRED
    183          
    184              if (status == PSA_SUCCESS) {
   \       0x92   0xD106             BNE.N    ??sli_se_driver_mac_compute_6
    185                memcpy(mac, tmp_hmac, requested_length);
   \       0x94   0x9A03             LDR      R2,[SP, #+12]
   \       0x96   0xA905             ADD      R1,SP,#+20
   \       0x98   0x4638             MOV      R0,R7
   \       0x9A   0x.... 0x....      BL       __aeabi_memcpy
    186                *mac_length = requested_length;
   \       0x9E   0x9803             LDR      R0,[SP, #+12]
   \       0xA0   0xE000             B.N      ??sli_se_driver_mac_compute_7
    187              } else {
    188                *mac_length = 0;
   \                     ??sli_se_driver_mac_compute_6: (+1)
   \       0xA2   0x2000             MOVS     R0,#+0
   \                     ??sli_se_driver_mac_compute_7: (+1)
   \       0xA4   0x6020             STR      R0,[R4, #+0]
    189              }
    190          
    191              sli_psa_zeroize(tmp_hmac, sizeof(tmp_hmac));
   \       0xA6   0x2120             MOVS     R1,#+32
   \       0xA8   0xAA05             ADD      R2,SP,#+20
   \       0xAA   0xE002             B.N      ??sli_se_driver_mac_compute_8
   \                     ??sli_se_driver_mac_compute_9: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xF802 0x0B01      STRB     R0,[R2], #+1
   \                     ??sli_se_driver_mac_compute_8: (+1)
   \       0xB2   0x4608             MOV      R0,R1
   \       0xB4   0x1E41             SUBS     R1,R0,#+1
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD1F8             BNE.N    ??sli_se_driver_mac_compute_9
    192          
    193              goto exit;
    194            }
    195            #endif   // SLI_PSA_DRIVER_FEATURE_HMAC
    196          
    197            #if defined(SLI_PSA_DRIVER_FEATURE_HMAC) \
    198            && (defined(SLI_PSA_DRIVER_FEATURE_CMAC) \
    199            || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC))
    200            else
    201            #endif
    202          
    203            #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    204            {
    205              size_t output_length = PSA_MAC_TRUNCATED_LENGTH(alg);
    206              if (output_length == 0) {
    207                output_length = 16;
    208              } else if (output_length > 16) {
    209                return PSA_ERROR_INVALID_ARGUMENT;
    210              }
    211              if (mac_size < output_length) {
    212                return PSA_ERROR_BUFFER_TOO_SMALL;
    213              }
    214          
    215              switch (PSA_ALG_FULL_LENGTH_MAC(alg)) {
    216                #if defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    217                case PSA_ALG_CBC_MAC: {
    218                  uint8_t tmp_buf[16] = { 0 };
    219                  uint8_t tmp_mac[16] = { 0 };
    220          
    221                  if (input_length % 16 != 0 || input_length < 16) {
    222                    return PSA_ERROR_INVALID_ARGUMENT;
    223                  }
    224          
    225                  // Do an AES-CBC encrypt with zero IV, keeping only the last block.
    226                  while (input_length > 0) {
    227                    status = sl_se_aes_crypt_cbc(&cmd_ctx,
    228                                                 key_desc,
    229                                                 SL_SE_ENCRYPT,
    230                                                 16,
    231                                                 tmp_mac,
    232                                                 input,
    233                                                 tmp_buf);
    234          
    235                    input_length -= 16;
    236                    input += 16;
    237                  }
    238          
    239                  // Copy the requested number of bytes (max 16) to the user buffer.
    240                  if (status == SL_STATUS_OK) {
    241                    memcpy(mac, tmp_mac, output_length);
    242                    sli_psa_zeroize(tmp_mac, sizeof(tmp_mac));
    243                    *mac_length = output_length;
    244                  }
    245          
    246                  goto exit;
    247                  break;
    248                }
    249                #endif     // SLI_PSA_DRIVER_FEATURE_CBC_MAC
    250          
    251                #if defined(SLI_PSA_DRIVER_FEATURE_CMAC)
    252                case PSA_ALG_CMAC: {
    253                  uint8_t tmp_mac[16] = { 0 };
    254          
    255                  status = sl_se_cmac(&cmd_ctx,
    256                                      key_desc,
    257                                      input,
    258                                      input_length,
    259                                      tmp_mac);
    260          
    261                  // Copy the requested number of bytes (max 16) to the user buffer.
    262                  if (status == SL_STATUS_OK) {
    263                    memcpy(mac, tmp_mac, output_length);
    264                    sli_psa_zeroize(tmp_mac, sizeof(tmp_mac));
    265                    *mac_length = output_length;
    266                  }
    267          
    268                  goto exit;
    269                  break;
    270                }
    271                #endif     // SLI_PSA_DRIVER_FEATURE_CMAC
    272          
    273                default:
    274                  return PSA_ERROR_NOT_SUPPORTED;
    275                  break;
    276              }
    277            }
    278            #endif   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    279          
    280            exit:
    281          
    282            if (status == SL_STATUS_INVALID_PARAMETER) {
   \       0xBA   0x2D21             CMP      R5,#+33
   \       0xBC   0xD009             BEQ.N    ??sli_se_driver_mac_compute_10
    283              psa_status = PSA_ERROR_INVALID_ARGUMENT;
    284            } else if (status == SL_STATUS_FAIL) {
   \       0xBE   0x2D01             CMP      R5,#+1
   \       0xC0   0xBF08             IT       EQ
   \       0xC2   0xF06F 0x088B      MVNEQ    R8,#+139
    285              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   \       0xC6   0xD004             BEQ.N    ??sli_se_driver_mac_compute_10
    286            } else if (status != SL_STATUS_OK) {
   \       0xC8   0xB10D             CBZ.N    R5,??sli_se_driver_mac_compute_2
    287              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \       0xCA   0x46D8             MOV      R8,R11
   \       0xCC   0xE001             B.N      ??sli_se_driver_mac_compute_10
    288            } else {
    289              psa_status = PSA_SUCCESS;
   \                     ??sli_se_driver_mac_compute_2: (+1)
   \       0xCE   0xF04F 0x0800      MOV      R8,#+0
    290            }
    291          
    292            // Cleanup
    293            status = sl_se_deinit_command_context(&cmd_ctx);
    294            if (status != SL_STATUS_OK) {
   \                     ??sli_se_driver_mac_compute_10: (+1)
   \       0xD2   0xA80D             ADD      R0,SP,#+52
   \       0xD4   0x.... 0x....      BL       sl_se_deinit_command_context
   \       0xD8   0xB108             CBZ.N    R0,??sli_se_driver_mac_compute_11
    295              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_mac_compute_1: (+1)
   \       0xDA   0x4658             MOV      R0,R11
   \       0xDC   0xE000             B.N      ??sli_se_driver_mac_compute_3
    296            }
    297          
    298            return psa_status;
   \                     ??sli_se_driver_mac_compute_11: (+1)
   \       0xDE   0x4640             MOV      R0,R8
   \                     ??sli_se_driver_mac_compute_3: (+1)
   \       0xE0   0xB017             ADD      SP,SP,#+92
   \       0xE2   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    299          
    300            #else // SLI_PSA_DRIVER_FEATURE_MAC
    301          
    302            (void)key_desc;
    303            (void)alg;
    304            (void)input;
    305            (void)input_length;
    306            (void)mac;
    307            (void)mac_size;
    308            (void)mac_length;
    309          
    310            return PSA_ERROR_NOT_SUPPORTED;
    311          
    312            #endif // SLI_PSA_DRIVER_FEATURE_MAC
    313          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x7FC0'0000        DC32     0x7fc00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x0200'0005        DC32     0x2000005
    314          
    315          //------------------------------------------------------------------------------
    316          // Multi-part driver entry points
    317          
    318          #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    319          
    320          psa_status_t sli_se_driver_mac_sign_setup(
    321            sli_se_driver_mac_operation_t *operation,
    322            const psa_key_attributes_t *attributes,
    323            psa_algorithm_t alg)
    324          {
    325            if (operation == NULL
    326                || attributes == NULL) {
    327              return PSA_ERROR_INVALID_ARGUMENT;
    328            }
    329          
    330            // Start by resetting context
    331            memset(operation, 0, sizeof(*operation));
    332          
    333            switch (PSA_ALG_FULL_LENGTH_MAC(alg)) {
    334              #if defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    335              case PSA_ALG_CBC_MAC:
    336                if (psa_get_key_type(attributes) != PSA_KEY_TYPE_AES) {
    337                  return PSA_ERROR_NOT_SUPPORTED;
    338                }
    339                if (PSA_MAC_TRUNCATED_LENGTH(alg) > 16) {
    340                  return PSA_ERROR_INVALID_ARGUMENT;
    341                }
    342                break;
    343              #endif // SLI_PSA_DRIVER_FEATURE_CBC_MAC
    344          
    345              #if defined(SLI_PSA_DRIVER_FEATURE_CMAC)
    346              case PSA_ALG_CMAC:
    347                if (psa_get_key_type(attributes) != PSA_KEY_TYPE_AES) {
    348                  return PSA_ERROR_NOT_SUPPORTED;
    349                }
    350                if (PSA_MAC_TRUNCATED_LENGTH(alg) > 16) {
    351                  return PSA_ERROR_INVALID_ARGUMENT;
    352                }
    353                break;
    354              #endif // SLI_PSA_DRIVER_FEATURE_CMAC
    355          
    356              default:
    357                return PSA_ERROR_NOT_SUPPORTED;
    358            }
    359          
    360            operation->alg = alg;
    361            return PSA_SUCCESS;
    362          }
    363          
    364          psa_status_t sli_se_driver_mac_update(sli_se_driver_mac_operation_t *operation,
    365                                                sl_se_key_descriptor_t *key_desc,
    366                                                const uint8_t *input,
    367                                                size_t input_length)
    368          {
    369            if (operation == NULL
    370                || (input == NULL && input_length > 0)) {
    371              return PSA_ERROR_INVALID_ARGUMENT;
    372            }
    373          
    374            // Ephemeral contexts
    375            sl_se_command_context_t cmd_ctx = { 0 };
    376          
    377            sl_status_t status = sl_se_init_command_context(&cmd_ctx);
    378            if (status != SL_STATUS_OK) {
    379              return PSA_ERROR_HARDWARE_FAILURE;
    380            }
    381          
    382            psa_status_t psa_status = PSA_ERROR_NOT_SUPPORTED;
    383            switch (PSA_ALG_FULL_LENGTH_MAC(operation->alg)) {
    384              #if defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    385              case PSA_ALG_CBC_MAC:
    386                if (input_length == 0) {
    387                  psa_status = PSA_SUCCESS;
    388                  goto exit;
    389                }
    390          
    391                // Add bytes to the streaming buffer up to the next block boundary
    392                if (operation->ctx.cbcmac.processed_length % 16 != 0) {
    393                  size_t bytes_to_boundary
    394                    = 16 - operation->ctx.cbcmac.processed_length % 16;
    395                  if (input_length < bytes_to_boundary) {
    396                    memcpy(&operation->ctx.cbcmac.streaming_block[16 - bytes_to_boundary],
    397                           input,
    398                           input_length);
    399                    operation->ctx.cbcmac.processed_length += input_length;
    400                    psa_status = PSA_SUCCESS;
    401                    goto exit;
    402                  }
    403          
    404                  memcpy(&operation->ctx.cbcmac.streaming_block[16 - bytes_to_boundary],
    405                         input,
    406                         bytes_to_boundary);
    407                  input_length -= bytes_to_boundary;
    408                  input += bytes_to_boundary;
    409                  operation->ctx.cbcmac.processed_length += bytes_to_boundary;
    410          
    411                  status = sl_se_aes_crypt_cbc(&cmd_ctx,
    412                                               key_desc,
    413                                               SL_SE_ENCRYPT,
    414                                               16,
    415                                               operation->ctx.cbcmac.iv,
    416                                               operation->ctx.cbcmac.streaming_block,
    417                                               operation->ctx.cbcmac.iv);
    418          
    419                  if (status == SL_STATUS_FAIL) {
    420                    psa_status = PSA_ERROR_DOES_NOT_EXIST;
    421                    goto exit;
    422                  } else if (status != SL_STATUS_OK) {
    423                    psa_status = PSA_ERROR_HARDWARE_FAILURE;
    424                    goto exit;
    425                  }
    426                }
    427          
    428                // Draw all full blocks
    429                while (input_length >= 16) {
    430                  status = sl_se_aes_crypt_cbc(&cmd_ctx,
    431                                               key_desc,
    432                                               SL_SE_ENCRYPT,
    433                                               16,
    434                                               operation->ctx.cbcmac.iv,
    435                                               input,
    436                                               operation->ctx.cbcmac.iv);
    437          
    438                  if (status != SL_STATUS_OK) {
    439                    psa_status = PSA_ERROR_HARDWARE_FAILURE;
    440                    goto exit;
    441                  }
    442          
    443                  operation->ctx.cbcmac.processed_length += 16;
    444                  input += 16;
    445                  input_length -= 16;
    446                }
    447          
    448                if (input_length > 0) {
    449                  memcpy(operation->ctx.cbcmac.streaming_block,
    450                         input,
    451                         input_length);
    452                  operation->ctx.cbcmac.processed_length += input_length;
    453                }
    454          
    455                psa_status = PSA_SUCCESS;
    456                goto exit;
    457              #endif // SLI_PSA_DRIVER_FEATURE_CBC_MAC
    458          
    459              #if defined(SLI_PSA_DRIVER_FEATURE_CMAC)
    460              case PSA_ALG_CMAC:
    461                if (input_length == 0) {
    462                  psa_status = PSA_SUCCESS;
    463                  goto exit;
    464                }
    465          
    466                status = sl_se_cmac_multipart_update(&operation->ctx.cmac,
    467                                                     &cmd_ctx,
    468                                                     key_desc,
    469                                                     input,
    470                                                     input_length);
    471                if (status == SL_STATUS_FAIL) {
    472                  psa_status = PSA_ERROR_DOES_NOT_EXIST;
    473                  goto exit;
    474                } else if (status != SL_STATUS_OK) {
    475                  psa_status = PSA_ERROR_HARDWARE_FAILURE;
    476                  goto exit;
    477                }
    478                psa_status = PSA_SUCCESS;
    479                goto exit;
    480              #endif // SLI_PSA_DRIVER_FEATURE_CMAC
    481          
    482              default:
    483                psa_status = PSA_ERROR_BAD_STATE;
    484                goto exit;
    485            }
    486          
    487            exit:
    488            // Cleanup
    489            status = sl_se_deinit_command_context(&cmd_ctx);
    490            if (status != SL_STATUS_OK) {
    491              return PSA_ERROR_HARDWARE_FAILURE;
    492            }
    493          
    494            return psa_status;
    495          }
    496          
    497          psa_status_t sli_se_driver_mac_sign_finish(
    498            sli_se_driver_mac_operation_t *operation,
    499            sl_se_key_descriptor_t *key_desc,
    500            uint8_t *mac,
    501            size_t mac_size,
    502            size_t *mac_length)
    503          {
    504            if (operation == NULL
    505                || mac == NULL
    506                || mac_size == 0
    507                || mac_length == NULL) {
    508              return PSA_ERROR_INVALID_ARGUMENT;
    509            }
    510          
    511            // Set maximum output size to 16 or truncated length
    512            if (mac_size > 16) {
    513              mac_size = 16;
    514            }
    515          
    516            size_t truncated_length = PSA_MAC_TRUNCATED_LENGTH(operation->alg);
    517            if (truncated_length != 0
    518                && mac_size > truncated_length) {
    519              mac_size = truncated_length;
    520            }
    521          
    522            switch (PSA_ALG_FULL_LENGTH_MAC(operation->alg)) {
    523              #if defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    524              case PSA_ALG_CBC_MAC: {
    525                (void)key_desc;
    526          
    527                if (operation->ctx.cbcmac.processed_length % 16 != 0) {
    528                  return PSA_ERROR_BAD_STATE;
    529                }
    530          
    531                // Copy the requested number of bytes (max 16) to the user buffer.
    532                memcpy(mac, operation->ctx.cbcmac.iv, mac_size);
    533                *mac_length = mac_size;
    534          
    535                return PSA_SUCCESS;
    536                break;
    537              }
    538              #endif // SLI_PSA_DRIVER_FEATURE_CBC_MAC
    539          
    540              #if defined(SLI_PSA_DRIVER_FEATURE_CMAC)
    541              case PSA_ALG_CMAC: {
    542                // Ephemeral contexts
    543                sl_se_command_context_t cmd_ctx = { 0 };
    544                uint8_t tmp_mac[16] = { 0 };
    545                sl_status_t status = sl_se_init_command_context(&cmd_ctx);
    546                if (status != SL_STATUS_OK) {
    547                  return PSA_ERROR_HARDWARE_FAILURE;
    548                }
    549          
    550                status = sl_se_cmac_multipart_finish(&operation->ctx.cmac,
    551                                                     &cmd_ctx,
    552                                                     key_desc,
    553                                                     tmp_mac);
    554                if (status != SL_STATUS_OK) {
    555                  *mac_length = 0;
    556                  return PSA_ERROR_HARDWARE_FAILURE;
    557                }
    558          
    559                // Cleanup
    560                status = sl_se_deinit_command_context(&cmd_ctx);
    561                if (status != SL_STATUS_OK) {
    562                  *mac_length = 0;
    563                  return PSA_ERROR_HARDWARE_FAILURE;
    564                }
    565          
    566                // Copy the requested number of bytes (max 16) to the user buffer.
    567                memcpy(mac, tmp_mac, mac_size);
    568                *mac_length = mac_size;
    569          
    570                return PSA_SUCCESS;
    571                break;
    572              }
    573              #endif // SLI_PSA_DRIVER_FEATURE_CMAC
    574          
    575              default:
    576                return PSA_ERROR_BAD_STATE;
    577            }
    578          }
    579          
    580          #endif // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    581          
    582          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     128   sli_se_driver_mac_compute
       128   -> __aeabi_memclr4
       128   -> __aeabi_memcpy
       128   -> sl_se_deinit_command_context
       128   -> sl_se_hmac
       128   -> sl_se_init_command_context
       128   -> sli_se_hash_type_from_psa_hmac_alg
       0   sli_se_hash_type_from_psa_hmac_alg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      36  ?_0
     230  sli_se_driver_mac_compute
      86  sli_se_hash_type_from_psa_hmac_alg

 
  36 bytes in section .rodata
 324 bytes in section .text
 
 324 bytes of CODE  memory
  36 bytes of CONST memory

Errors: none
Warnings: none
